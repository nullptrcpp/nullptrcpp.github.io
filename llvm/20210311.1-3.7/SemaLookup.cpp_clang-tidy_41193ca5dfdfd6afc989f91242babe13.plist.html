<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"14": {"id": 14, "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaLookup.cpp", "content": "//===--------------------- SemaLookup.cpp - Name Lookup  ------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file implements name lookup for C, C++, Objective-C, and\n//  Objective-C++.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/CXXInheritance.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclLookups.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/DeclTemplate.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/Basic/Builtins.h\"\n#include \"clang/Basic/FileManager.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Lex/HeaderSearch.h\"\n#include \"clang/Lex/ModuleLoader.h\"\n#include \"clang/Lex/Preprocessor.h\"\n#include \"clang/Sema/DeclSpec.h\"\n#include \"clang/Sema/Lookup.h\"\n#include \"clang/Sema/Overload.h\"\n#include \"clang/Sema/Scope.h\"\n#include \"clang/Sema/ScopeInfo.h\"\n#include \"clang/Sema/Sema.h\"\n#include \"clang/Sema/SemaInternal.h\"\n#include \"clang/Sema/TemplateDeduction.h\"\n#include \"clang/Sema/TypoCorrection.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/TinyPtrVector.h\"\n#include \"llvm/ADT/edit_distance.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <algorithm>\n#include <iterator>\n#include <list>\n#include <set>\n#include <utility>\n#include <vector>\n\n#include \"OpenCLBuiltins.inc\"\n\nusing namespace clang;\nusing namespace sema;\n\nnamespace {\n  class UnqualUsingEntry {\n    const DeclContext *Nominated;\n    const DeclContext *CommonAncestor;\n\n  public:\n    UnqualUsingEntry(const DeclContext *Nominated,\n                     const DeclContext *CommonAncestor)\n      : Nominated(Nominated), CommonAncestor(CommonAncestor) {\n    }\n\n    const DeclContext *getCommonAncestor() const {\n      return CommonAncestor;\n    }\n\n    const DeclContext *getNominatedNamespace() const {\n      return Nominated;\n    }\n\n    // Sort by the pointer value of the common ancestor.\n    struct Comparator {\n      bool operator()(const UnqualUsingEntry &L, const UnqualUsingEntry &R) {\n        return L.getCommonAncestor() < R.getCommonAncestor();\n      }\n\n      bool operator()(const UnqualUsingEntry &E, const DeclContext *DC) {\n        return E.getCommonAncestor() < DC;\n      }\n\n      bool operator()(const DeclContext *DC, const UnqualUsingEntry &E) {\n        return DC < E.getCommonAncestor();\n      }\n    };\n  };\n\n  /// A collection of using directives, as used by C++ unqualified\n  /// lookup.\n  class UnqualUsingDirectiveSet {\n    Sema &SemaRef;\n\n    typedef SmallVector<UnqualUsingEntry, 8> ListTy;\n\n    ListTy list;\n    llvm::SmallPtrSet<DeclContext*, 8> visited;\n\n  public:\n    UnqualUsingDirectiveSet(Sema &SemaRef) : SemaRef(SemaRef) {}\n\n    void visitScopeChain(Scope *S, Scope *InnermostFileScope) {\n      // C++ [namespace.udir]p1:\n      //   During unqualified name lookup, the names appear as if they\n      //   were declared in the nearest enclosing namespace which contains\n      //   both the using-directive and the nominated namespace.\n      DeclContext *InnermostFileDC = InnermostFileScope->getEntity();\n      assert(InnermostFileDC && InnermostFileDC->isFileContext());\n\n      for (; S; S = S->getParent()) {\n        // C++ [namespace.udir]p1:\n        //   A using-directive shall not appear in class scope, but may\n        //   appear in namespace scope or in block scope.\n        DeclContext *Ctx = S->getEntity();\n        if (Ctx && Ctx->isFileContext()) {\n          visit(Ctx, Ctx);\n        } else if (!Ctx || Ctx->isFunctionOrMethod()) {\n          for (auto *I : S->using_directives())\n            if (SemaRef.isVisible(I))\n              visit(I, InnermostFileDC);\n        }\n      }\n    }\n\n    // Visits a context and collect all of its using directives\n    // recursively.  Treats all using directives as if they were\n    // declared in the context.\n    //\n    // A given context is only every visited once, so it is important\n    // that contexts be visited from the inside out in order to get\n    // the effective DCs right.\n    void visit(DeclContext *DC, DeclContext *EffectiveDC) {\n      if (!visited.insert(DC).second)\n        return;\n\n      addUsingDirectives(DC, EffectiveDC);\n    }\n\n    // Visits a using directive and collects all of its using\n    // directives recursively.  Treats all using directives as if they\n    // were declared in the effective DC.\n    void visit(UsingDirectiveDecl *UD, DeclContext *EffectiveDC) {\n      DeclContext *NS = UD->getNominatedNamespace();\n      if (!visited.insert(NS).second)\n        return;\n\n      addUsingDirective(UD, EffectiveDC);\n      addUsingDirectives(NS, EffectiveDC);\n    }\n\n    // Adds all the using directives in a context (and those nominated\n    // by its using directives, transitively) as if they appeared in\n    // the given effective context.\n    void addUsingDirectives(DeclContext *DC, DeclContext *EffectiveDC) {\n      SmallVector<DeclContext*, 4> queue;\n      while (true) {\n        for (auto UD : DC->using_directives()) {\n          DeclContext *NS = UD->getNominatedNamespace();\n          if (SemaRef.isVisible(UD) && visited.insert(NS).second) {\n            addUsingDirective(UD, EffectiveDC);\n            queue.push_back(NS);\n          }\n        }\n\n        if (queue.empty())\n          return;\n\n        DC = queue.pop_back_val();\n      }\n    }\n\n    // Add a using directive as if it had been declared in the given\n    // context.  This helps implement C++ [namespace.udir]p3:\n    //   The using-directive is transitive: if a scope contains a\n    //   using-directive that nominates a second namespace that itself\n    //   contains using-directives, the effect is as if the\n    //   using-directives from the second namespace also appeared in\n    //   the first.\n    void addUsingDirective(UsingDirectiveDecl *UD, DeclContext *EffectiveDC) {\n      // Find the common ancestor between the effective context and\n      // the nominated namespace.\n      DeclContext *Common = UD->getNominatedNamespace();\n      while (!Common->Encloses(EffectiveDC))\n        Common = Common->getParent();\n      Common = Common->getPrimaryContext();\n\n      list.push_back(UnqualUsingEntry(UD->getNominatedNamespace(), Common));\n    }\n\n    void done() { llvm::sort(list, UnqualUsingEntry::Comparator()); }\n\n    typedef ListTy::const_iterator const_iterator;\n\n    const_iterator begin() const { return list.begin(); }\n    const_iterator end() const { return list.end(); }\n\n    llvm::iterator_range<const_iterator>\n    getNamespacesFor(DeclContext *DC) const {\n      return llvm::make_range(std::equal_range(begin(), end(),\n                                               DC->getPrimaryContext(),\n                                               UnqualUsingEntry::Comparator()));\n    }\n  };\n} // end anonymous namespace\n\n// Retrieve the set of identifier namespaces that correspond to a\n// specific kind of name lookup.\nstatic inline unsigned getIDNS(Sema::LookupNameKind NameKind,\n                               bool CPlusPlus,\n                               bool Redeclaration) {\n  unsigned IDNS = 0;\n  switch (NameKind) {\n  case Sema::LookupObjCImplicitSelfParam:\n  case Sema::LookupOrdinaryName:\n  case Sema::LookupRedeclarationWithLinkage:\n  case Sema::LookupLocalFriendName:\n  case Sema::LookupDestructorName:\n    IDNS = Decl::IDNS_Ordinary;\n    if (CPlusPlus) {\n      IDNS |= Decl::IDNS_Tag | Decl::IDNS_Member | Decl::IDNS_Namespace;\n      if (Redeclaration)\n        IDNS |= Decl::IDNS_TagFriend | Decl::IDNS_OrdinaryFriend;\n    }\n    if (Redeclaration)\n      IDNS |= Decl::IDNS_LocalExtern;\n    break;\n\n  case Sema::LookupOperatorName:\n    // Operator lookup is its own crazy thing;  it is not the same\n    // as (e.g.) looking up an operator name for redeclaration.\n    assert(!Redeclaration && \"cannot do redeclaration operator lookup\");\n    IDNS = Decl::IDNS_NonMemberOperator;\n    break;\n\n  case Sema::LookupTagName:\n    if (CPlusPlus) {\n      IDNS = Decl::IDNS_Type;\n\n      // When looking for a redeclaration of a tag name, we add:\n      // 1) TagFriend to find undeclared friend decls\n      // 2) Namespace because they can't \"overload\" with tag decls.\n      // 3) Tag because it includes class templates, which can't\n      //    \"overload\" with tag decls.\n      if (Redeclaration)\n        IDNS |= Decl::IDNS_Tag | Decl::IDNS_TagFriend | Decl::IDNS_Namespace;\n    } else {\n      IDNS = Decl::IDNS_Tag;\n    }\n    break;\n\n  case Sema::LookupLabel:\n    IDNS = Decl::IDNS_Label;\n    break;\n\n  case Sema::LookupMemberName:\n    IDNS = Decl::IDNS_Member;\n    if (CPlusPlus)\n      IDNS |= Decl::IDNS_Tag | Decl::IDNS_Ordinary;\n    break;\n\n  case Sema::LookupNestedNameSpecifierName:\n    IDNS = Decl::IDNS_Type | Decl::IDNS_Namespace;\n    break;\n\n  case Sema::LookupNamespaceName:\n    IDNS = Decl::IDNS_Namespace;\n    break;\n\n  case Sema::LookupUsingDeclName:\n    assert(Redeclaration && \"should only be used for redecl lookup\");\n    IDNS = Decl::IDNS_Ordinary | Decl::IDNS_Tag | Decl::IDNS_Member |\n           Decl::IDNS_Using | Decl::IDNS_TagFriend | Decl::IDNS_OrdinaryFriend |\n           Decl::IDNS_LocalExtern;\n    break;\n\n  case Sema::LookupObjCProtocolName:\n    IDNS = Decl::IDNS_ObjCProtocol;\n    break;\n\n  case Sema::LookupOMPReductionName:\n    IDNS = Decl::IDNS_OMPReduction;\n    break;\n\n  case Sema::LookupOMPMapperName:\n    IDNS = Decl::IDNS_OMPMapper;\n    break;\n\n  case Sema::LookupAnyName:\n    IDNS = Decl::IDNS_Ordinary | Decl::IDNS_Tag | Decl::IDNS_Member\n      | Decl::IDNS_Using | Decl::IDNS_Namespace | Decl::IDNS_ObjCProtocol\n      | Decl::IDNS_Type;\n    break;\n  }\n  return IDNS;\n}\n\nvoid LookupResult::configure() {\n  IDNS = getIDNS(LookupKind, getSema().getLangOpts().CPlusPlus,\n                 isForRedeclaration());\n\n  // If we're looking for one of the allocation or deallocation\n  // operators, make sure that the implicitly-declared new and delete\n  // operators can be found.\n  switch (NameInfo.getName().getCXXOverloadedOperator()) {\n  case OO_New:\n  case OO_Delete:\n  case OO_Array_New:\n  case OO_Array_Delete:\n    getSema().DeclareGlobalNewDelete();\n    break;\n\n  default:\n    break;\n  }\n\n  // Compiler builtins are always visible, regardless of where they end\n  // up being declared.\n  if (IdentifierInfo *Id = NameInfo.getName().getAsIdentifierInfo()) {\n    if (unsigned BuiltinID = Id->getBuiltinID()) {\n      if (!getSema().Context.BuiltinInfo.isPredefinedLibFunction(BuiltinID))\n        AllowHidden = true;\n    }\n  }\n}\n\nbool LookupResult::sanity() const {\n  // This function is never called by NDEBUG builds.\n  assert(ResultKind != NotFound || Decls.size() == 0);\n  assert(ResultKind != Found || Decls.size() == 1);\n  assert(ResultKind != FoundOverloaded || Decls.size() > 1 ||\n         (Decls.size() == 1 &&\n          isa<FunctionTemplateDecl>((*begin())->getUnderlyingDecl())));\n  assert(ResultKind != FoundUnresolvedValue || sanityCheckUnresolved());\n  assert(ResultKind != Ambiguous || Decls.size() > 1 ||\n         (Decls.size() == 1 && (Ambiguity == AmbiguousBaseSubobjects ||\n                                Ambiguity == AmbiguousBaseSubobjectTypes)));\n  assert((Paths != nullptr) == (ResultKind == Ambiguous &&\n                                (Ambiguity == AmbiguousBaseSubobjectTypes ||\n                                 Ambiguity == AmbiguousBaseSubobjects)));\n  return true;\n}\n\n// Necessary because CXXBasePaths is not complete in Sema.h\nvoid LookupResult::deletePaths(CXXBasePaths *Paths) {\n  delete Paths;\n}\n\n/// Get a representative context for a declaration such that two declarations\n/// will have the same context if they were found within the same scope.\nstatic DeclContext *getContextForScopeMatching(Decl *D) {\n  // For function-local declarations, use that function as the context. This\n  // doesn't account for scopes within the function; the caller must deal with\n  // those.\n  DeclContext *DC = D->getLexicalDeclContext();\n  if (DC->isFunctionOrMethod())\n    return DC;\n\n  // Otherwise, look at the semantic context of the declaration. The\n  // declaration must have been found there.\n  return D->getDeclContext()->getRedeclContext();\n}\n\n/// Determine whether \\p D is a better lookup result than \\p Existing,\n/// given that they declare the same entity.\nstatic bool isPreferredLookupResult(Sema &S, Sema::LookupNameKind Kind,\n                                    NamedDecl *D, NamedDecl *Existing) {\n  // When looking up redeclarations of a using declaration, prefer a using\n  // shadow declaration over any other declaration of the same entity.\n  if (Kind == Sema::LookupUsingDeclName && isa<UsingShadowDecl>(D) &&\n      !isa<UsingShadowDecl>(Existing))\n    return true;\n\n  auto *DUnderlying = D->getUnderlyingDecl();\n  auto *EUnderlying = Existing->getUnderlyingDecl();\n\n  // If they have different underlying declarations, prefer a typedef over the\n  // original type (this happens when two type declarations denote the same\n  // type), per a generous reading of C++ [dcl.typedef]p3 and p4. The typedef\n  // might carry additional semantic information, such as an alignment override.\n  // However, per C++ [dcl.typedef]p5, when looking up a tag name, prefer a tag\n  // declaration over a typedef. Also prefer a tag over a typedef for\n  // destructor name lookup because in some contexts we only accept a\n  // class-name in a destructor declaration.\n  if (DUnderlying->getCanonicalDecl() != EUnderlying->getCanonicalDecl()) {\n    assert(isa<TypeDecl>(DUnderlying) && isa<TypeDecl>(EUnderlying));\n    bool HaveTag = isa<TagDecl>(EUnderlying);\n    bool WantTag =\n        Kind == Sema::LookupTagName || Kind == Sema::LookupDestructorName;\n    return HaveTag != WantTag;\n  }\n\n  // Pick the function with more default arguments.\n  // FIXME: In the presence of ambiguous default arguments, we should keep both,\n  //        so we can diagnose the ambiguity if the default argument is needed.\n  //        See C++ [over.match.best]p3.\n  if (auto *DFD = dyn_cast<FunctionDecl>(DUnderlying)) {\n    auto *EFD = cast<FunctionDecl>(EUnderlying);\n    unsigned DMin = DFD->getMinRequiredArguments();\n    unsigned EMin = EFD->getMinRequiredArguments();\n    // If D has more default arguments, it is preferred.\n    if (DMin != EMin)\n      return DMin < EMin;\n    // FIXME: When we track visibility for default function arguments, check\n    // that we pick the declaration with more visible default arguments.\n  }\n\n  // Pick the template with more default template arguments.\n  if (auto *DTD = dyn_cast<TemplateDecl>(DUnderlying)) {\n    auto *ETD = cast<TemplateDecl>(EUnderlying);\n    unsigned DMin = DTD->getTemplateParameters()->getMinRequiredArguments();\n    unsigned EMin = ETD->getTemplateParameters()->getMinRequiredArguments();\n    // If D has more default arguments, it is preferred. Note that default\n    // arguments (and their visibility) is monotonically increasing across the\n    // redeclaration chain, so this is a quick proxy for \"is more recent\".\n    if (DMin != EMin)\n      return DMin < EMin;\n    // If D has more *visible* default arguments, it is preferred. Note, an\n    // earlier default argument being visible does not imply that a later\n    // default argument is visible, so we can't just check the first one.\n    for (unsigned I = DMin, N = DTD->getTemplateParameters()->size();\n        I != N; ++I) {\n      if (!S.hasVisibleDefaultArgument(\n              ETD->getTemplateParameters()->getParam(I)) &&\n          S.hasVisibleDefaultArgument(\n              DTD->getTemplateParameters()->getParam(I)))\n        return true;\n    }\n  }\n\n  // VarDecl can have incomplete array types, prefer the one with more complete\n  // array type.\n  if (VarDecl *DVD = dyn_cast<VarDecl>(DUnderlying)) {\n    VarDecl *EVD = cast<VarDecl>(EUnderlying);\n    if (EVD->getType()->isIncompleteType() &&\n        !DVD->getType()->isIncompleteType()) {\n      // Prefer the decl with a more complete type if visible.\n      return S.isVisible(DVD);\n    }\n    return false; // Avoid picking up a newer decl, just because it was newer.\n  }\n\n  // For most kinds of declaration, it doesn't really matter which one we pick.\n  if (!isa<FunctionDecl>(DUnderlying) && !isa<VarDecl>(DUnderlying)) {\n    // If the existing declaration is hidden, prefer the new one. Otherwise,\n    // keep what we've got.\n    return !S.isVisible(Existing);\n  }\n\n  // Pick the newer declaration; it might have a more precise type.\n  for (Decl *Prev = DUnderlying->getPreviousDecl(); Prev;\n       Prev = Prev->getPreviousDecl())\n    if (Prev == EUnderlying)\n      return true;\n  return false;\n}\n\n/// Determine whether \\p D can hide a tag declaration.\nstatic bool canHideTag(NamedDecl *D) {\n  // C++ [basic.scope.declarative]p4:\n  //   Given a set of declarations in a single declarative region [...]\n  //   exactly one declaration shall declare a class name or enumeration name\n  //   that is not a typedef name and the other declarations shall all refer to\n  //   the same variable, non-static data member, or enumerator, or all refer\n  //   to functions and function templates; in this case the class name or\n  //   enumeration name is hidden.\n  // C++ [basic.scope.hiding]p2:\n  //   A class name or enumeration name can be hidden by the name of a\n  //   variable, data member, function, or enumerator declared in the same\n  //   scope.\n  // An UnresolvedUsingValueDecl always instantiates to one of these.\n  D = D->getUnderlyingDecl();\n  return isa<VarDecl>(D) || isa<EnumConstantDecl>(D) || isa<FunctionDecl>(D) ||\n         isa<FunctionTemplateDecl>(D) || isa<FieldDecl>(D) ||\n         isa<UnresolvedUsingValueDecl>(D);\n}\n\n/// Resolves the result kind of this lookup.\nvoid LookupResult::resolveKind() {\n  unsigned N = Decls.size();\n\n  // Fast case: no possible ambiguity.\n  if (N == 0) {\n    assert(ResultKind == NotFound ||\n           ResultKind == NotFoundInCurrentInstantiation);\n    return;\n  }\n\n  // If there's a single decl, we need to examine it to decide what\n  // kind of lookup this is.\n  if (N == 1) {\n    NamedDecl *D = (*Decls.begin())->getUnderlyingDecl();\n    if (isa<FunctionTemplateDecl>(D))\n      ResultKind = FoundOverloaded;\n    else if (isa<UnresolvedUsingValueDecl>(D))\n      ResultKind = FoundUnresolvedValue;\n    return;\n  }\n\n  // Don't do any extra resolution if we've already resolved as ambiguous.\n  if (ResultKind == Ambiguous) return;\n\n  llvm::SmallDenseMap<NamedDecl*, unsigned, 16> Unique;\n  llvm::SmallDenseMap<QualType, unsigned, 16> UniqueTypes;\n\n  bool Ambiguous = false;\n  bool HasTag = false, HasFunction = false;\n  bool HasFunctionTemplate = false, HasUnresolved = false;\n  NamedDecl *HasNonFunction = nullptr;\n\n  llvm::SmallVector<NamedDecl*, 4> EquivalentNonFunctions;\n\n  unsigned UniqueTagIndex = 0;\n\n  unsigned I = 0;\n  while (I < N) {\n    NamedDecl *D = Decls[I]->getUnderlyingDecl();\n    D = cast<NamedDecl>(D->getCanonicalDecl());\n\n    // Ignore an invalid declaration unless it's the only one left.\n    if (D->isInvalidDecl() && !(I == 0 && N == 1)) {\n      Decls[I] = Decls[--N];\n      continue;\n    }\n\n    llvm::Optional<unsigned> ExistingI;\n\n    // Redeclarations of types via typedef can occur both within a scope\n    // and, through using declarations and directives, across scopes. There is\n    // no ambiguity if they all refer to the same type, so unique based on the\n    // canonical type.\n    if (TypeDecl *TD = dyn_cast<TypeDecl>(D)) {\n      QualType T = getSema().Context.getTypeDeclType(TD);\n      auto UniqueResult = UniqueTypes.insert(\n          std::make_pair(getSema().Context.getCanonicalType(T), I));\n      if (!UniqueResult.second) {\n        // The type is not unique.\n        ExistingI = UniqueResult.first->second;\n      }\n    }\n\n    // For non-type declarations, check for a prior lookup result naming this\n    // canonical declaration.\n    if (!ExistingI) {\n      auto UniqueResult = Unique.insert(std::make_pair(D, I));\n      if (!UniqueResult.second) {\n        // We've seen this entity before.\n        ExistingI = UniqueResult.first->second;\n      }\n    }\n\n    if (ExistingI) {\n      // This is not a unique lookup result. Pick one of the results and\n      // discard the other.\n      if (isPreferredLookupResult(getSema(), getLookupKind(), Decls[I],\n                                  Decls[*ExistingI]))\n        Decls[*ExistingI] = Decls[I];\n      Decls[I] = Decls[--N];\n      continue;\n    }\n\n    // Otherwise, do some decl type analysis and then continue.\n\n    if (isa<UnresolvedUsingValueDecl>(D)) {\n      HasUnresolved = true;\n    } else if (isa<TagDecl>(D)) {\n      if (HasTag)\n        Ambiguous = true;\n      UniqueTagIndex = I;\n      HasTag = true;\n    } else if (isa<FunctionTemplateDecl>(D)) {\n      HasFunction = true;\n      HasFunctionTemplate = true;\n    } else if (isa<FunctionDecl>(D)) {\n      HasFunction = true;\n    } else {\n      if (HasNonFunction) {\n        // If we're about to create an ambiguity between two declarations that\n        // are equivalent, but one is an internal linkage declaration from one\n        // module and the other is an internal linkage declaration from another\n        // module, just skip it.\n        if (getSema().isEquivalentInternalLinkageDeclaration(HasNonFunction,\n                                                             D)) {\n          EquivalentNonFunctions.push_back(D);\n          Decls[I] = Decls[--N];\n          continue;\n        }\n\n        Ambiguous = true;\n      }\n      HasNonFunction = D;\n    }\n    I++;\n  }\n\n  // C++ [basic.scope.hiding]p2:\n  //   A class name or enumeration name can be hidden by the name of\n  //   an object, function, or enumerator declared in the same\n  //   scope. If a class or enumeration name and an object, function,\n  //   or enumerator are declared in the same scope (in any order)\n  //   with the same name, the class or enumeration name is hidden\n  //   wherever the object, function, or enumerator name is visible.\n  // But it's still an error if there are distinct tag types found,\n  // even if they're not visible. (ref?)\n  if (N > 1 && HideTags && HasTag && !Ambiguous &&\n      (HasFunction || HasNonFunction || HasUnresolved)) {\n    NamedDecl *OtherDecl = Decls[UniqueTagIndex ? 0 : N - 1];\n    if (isa<TagDecl>(Decls[UniqueTagIndex]->getUnderlyingDecl()) &&\n        getContextForScopeMatching(Decls[UniqueTagIndex])->Equals(\n            getContextForScopeMatching(OtherDecl)) &&\n        canHideTag(OtherDecl))\n      Decls[UniqueTagIndex] = Decls[--N];\n    else\n      Ambiguous = true;\n  }\n\n  // FIXME: This diagnostic should really be delayed until we're done with\n  // the lookup result, in case the ambiguity is resolved by the caller.\n  if (!EquivalentNonFunctions.empty() && !Ambiguous)\n    getSema().diagnoseEquivalentInternalLinkageDeclarations(\n        getNameLoc(), HasNonFunction, EquivalentNonFunctions);\n\n  Decls.set_size(N);\n\n  if (HasNonFunction && (HasFunction || HasUnresolved))\n    Ambiguous = true;\n\n  if (Ambiguous)\n    setAmbiguous(LookupResult::AmbiguousReference);\n  else if (HasUnresolved)\n    ResultKind = LookupResult::FoundUnresolvedValue;\n  else if (N > 1 || HasFunctionTemplate)\n    ResultKind = LookupResult::FoundOverloaded;\n  else\n    ResultKind = LookupResult::Found;\n}\n\nvoid LookupResult::addDeclsFromBasePaths(const CXXBasePaths &P) {\n  CXXBasePaths::const_paths_iterator I, E;\n  for (I = P.begin(), E = P.end(); I != E; ++I)\n    for (DeclContext::lookup_iterator DI = I->Decls.begin(),\n         DE = I->Decls.end(); DI != DE; ++DI)\n      addDecl(*DI);\n}\n\nvoid LookupResult::setAmbiguousBaseSubobjects(CXXBasePaths &P) {\n  Paths = new CXXBasePaths;\n  Paths->swap(P);\n  addDeclsFromBasePaths(*Paths);\n  resolveKind();\n  setAmbiguous(AmbiguousBaseSubobjects);\n}\n\nvoid LookupResult::setAmbiguousBaseSubobjectTypes(CXXBasePaths &P) {\n  Paths = new CXXBasePaths;\n  Paths->swap(P);\n  addDeclsFromBasePaths(*Paths);\n  resolveKind();\n  setAmbiguous(AmbiguousBaseSubobjectTypes);\n}\n\nvoid LookupResult::print(raw_ostream &Out) {\n  Out << Decls.size() << \" result(s)\";\n  if (isAmbiguous()) Out << \", ambiguous\";\n  if (Paths) Out << \", base paths present\";\n\n  for (iterator I = begin(), E = end(); I != E; ++I) {\n    Out << \"\\n\";\n    (*I)->print(Out, 2);\n  }\n}\n\nLLVM_DUMP_METHOD void LookupResult::dump() {\n  llvm::errs() << \"lookup results for \" << getLookupName().getAsString()\n               << \":\\n\";\n  for (NamedDecl *D : *this)\n    D->dump();\n}\n\n/// Diagnose a missing builtin type.\nstatic QualType diagOpenCLBuiltinTypeError(Sema &S, llvm::StringRef TypeClass,\n                                           llvm::StringRef Name) {\n  S.Diag(SourceLocation(), diag::err_opencl_type_not_found)\n      << TypeClass << Name;\n  return S.Context.VoidTy;\n}\n\n/// Lookup an OpenCL enum type.\nstatic QualType getOpenCLEnumType(Sema &S, llvm::StringRef Name) {\n  LookupResult Result(S, &S.Context.Idents.get(Name), SourceLocation(),\n                      Sema::LookupTagName);\n  S.LookupName(Result, S.TUScope);\n  if (Result.empty())\n    return diagOpenCLBuiltinTypeError(S, \"enum\", Name);\n  EnumDecl *Decl = Result.getAsSingle<EnumDecl>();\n  if (!Decl)\n    return diagOpenCLBuiltinTypeError(S, \"enum\", Name);\n  return S.Context.getEnumType(Decl);\n}\n\n/// Lookup an OpenCL typedef type.\nstatic QualType getOpenCLTypedefType(Sema &S, llvm::StringRef Name) {\n  LookupResult Result(S, &S.Context.Idents.get(Name), SourceLocation(),\n                      Sema::LookupOrdinaryName);\n  S.LookupName(Result, S.TUScope);\n  if (Result.empty())\n    return diagOpenCLBuiltinTypeError(S, \"typedef\", Name);\n  TypedefNameDecl *Decl = Result.getAsSingle<TypedefNameDecl>();\n  if (!Decl)\n    return diagOpenCLBuiltinTypeError(S, \"typedef\", Name);\n  return S.Context.getTypedefType(Decl);\n}\n\n/// Get the QualType instances of the return type and arguments for an OpenCL\n/// builtin function signature.\n/// \\param S (in) The Sema instance.\n/// \\param OpenCLBuiltin (in) The signature currently handled.\n/// \\param GenTypeMaxCnt (out) Maximum number of types contained in a generic\n///        type used as return type or as argument.\n///        Only meaningful for generic types, otherwise equals 1.\n/// \\param RetTypes (out) List of the possible return types.\n/// \\param ArgTypes (out) List of the possible argument types.  For each\n///        argument, ArgTypes contains QualTypes for the Cartesian product\n///        of (vector sizes) x (types) .\nstatic void GetQualTypesForOpenCLBuiltin(\n    Sema &S, const OpenCLBuiltinStruct &OpenCLBuiltin, unsigned &GenTypeMaxCnt,\n    SmallVector<QualType, 1> &RetTypes,\n    SmallVector<SmallVector<QualType, 1>, 5> &ArgTypes) {\n  // Get the QualType instances of the return types.\n  unsigned Sig = SignatureTable[OpenCLBuiltin.SigTableIndex];\n  OCL2Qual(S, TypeTable[Sig], RetTypes);\n  GenTypeMaxCnt = RetTypes.size();\n\n  // Get the QualType instances of the arguments.\n  // First type is the return type, skip it.\n  for (unsigned Index = 1; Index < OpenCLBuiltin.NumTypes; Index++) {\n    SmallVector<QualType, 1> Ty;\n    OCL2Qual(S, TypeTable[SignatureTable[OpenCLBuiltin.SigTableIndex + Index]],\n             Ty);\n    GenTypeMaxCnt = (Ty.size() > GenTypeMaxCnt) ? Ty.size() : GenTypeMaxCnt;\n    ArgTypes.push_back(std::move(Ty));\n  }\n}\n\n/// Create a list of the candidate function overloads for an OpenCL builtin\n/// function.\n/// \\param Context (in) The ASTContext instance.\n/// \\param GenTypeMaxCnt (in) Maximum number of types contained in a generic\n///        type used as return type or as argument.\n///        Only meaningful for generic types, otherwise equals 1.\n/// \\param FunctionList (out) List of FunctionTypes.\n/// \\param RetTypes (in) List of the possible return types.\n/// \\param ArgTypes (in) List of the possible types for the arguments.\nstatic void GetOpenCLBuiltinFctOverloads(\n    ASTContext &Context, unsigned GenTypeMaxCnt,\n    std::vector<QualType> &FunctionList, SmallVector<QualType, 1> &RetTypes,\n    SmallVector<SmallVector<QualType, 1>, 5> &ArgTypes) {\n  FunctionProtoType::ExtProtoInfo PI(\n      Context.getDefaultCallingConvention(false, false, true));\n  PI.Variadic = false;\n\n  // Create FunctionTypes for each (gen)type.\n  for (unsigned IGenType = 0; IGenType < GenTypeMaxCnt; IGenType++) {\n    SmallVector<QualType, 5> ArgList;\n\n    for (unsigned A = 0; A < ArgTypes.size(); A++) {\n      // Builtins such as \"max\" have an \"sgentype\" argument that represents\n      // the corresponding scalar type of a gentype.  The number of gentypes\n      // must be a multiple of the number of sgentypes.\n      assert(GenTypeMaxCnt % ArgTypes[A].size() == 0 &&\n             \"argument type count not compatible with gentype type count\");\n      unsigned Idx = IGenType % ArgTypes[A].size();\n      ArgList.push_back(ArgTypes[A][Idx]);\n    }\n\n    FunctionList.push_back(Context.getFunctionType(\n        RetTypes[(RetTypes.size() != 1) ? IGenType : 0], ArgList, PI));\n  }\n}\n\n/// When trying to resolve a function name, if isOpenCLBuiltin() returns a\n/// non-null <Index, Len> pair, then the name is referencing an OpenCL\n/// builtin function.  Add all candidate signatures to the LookUpResult.\n///\n/// \\param S (in) The Sema instance.\n/// \\param LR (inout) The LookupResult instance.\n/// \\param II (in) The identifier being resolved.\n/// \\param FctIndex (in) Starting index in the BuiltinTable.\n/// \\param Len (in) The signature list has Len elements.\nstatic void InsertOCLBuiltinDeclarationsFromTable(Sema &S, LookupResult &LR,\n                                                  IdentifierInfo *II,\n                                                  const unsigned FctIndex,\n                                                  const unsigned Len) {\n  // The builtin function declaration uses generic types (gentype).\n  bool HasGenType = false;\n\n  // Maximum number of types contained in a generic type used as return type or\n  // as argument.  Only meaningful for generic types, otherwise equals 1.\n  unsigned GenTypeMaxCnt;\n\n  for (unsigned SignatureIndex = 0; SignatureIndex < Len; SignatureIndex++) {\n    const OpenCLBuiltinStruct &OpenCLBuiltin =\n        BuiltinTable[FctIndex + SignatureIndex];\n    ASTContext &Context = S.Context;\n\n    // Ignore this BIF if its version does not match the language options.\n    unsigned OpenCLVersion = Context.getLangOpts().OpenCLVersion;\n    if (Context.getLangOpts().OpenCLCPlusPlus)\n      OpenCLVersion = 200;\n    if (OpenCLVersion < OpenCLBuiltin.MinVersion)\n      continue;\n    if ((OpenCLBuiltin.MaxVersion != 0) &&\n        (OpenCLVersion >= OpenCLBuiltin.MaxVersion))\n      continue;\n\n    // Ignore this builtin function if it carries an extension macro that is\n    // not defined. This indicates that the extension is not supported by the\n    // target, so the builtin function should not be available.\n    StringRef Extensions = FunctionExtensionTable[OpenCLBuiltin.Extension];\n    if (!Extensions.empty()) {\n      SmallVector<StringRef, 2> ExtVec;\n      Extensions.split(ExtVec, \" \");\n      bool AllExtensionsDefined = true;\n      for (StringRef Ext : ExtVec) {\n        if (!S.getPreprocessor().isMacroDefined(Ext)) {\n          AllExtensionsDefined = false;\n          break;\n        }\n      }\n      if (!AllExtensionsDefined)\n        continue;\n    }\n\n    SmallVector<QualType, 1> RetTypes;\n    SmallVector<SmallVector<QualType, 1>, 5> ArgTypes;\n\n    // Obtain QualType lists for the function signature.\n    GetQualTypesForOpenCLBuiltin(S, OpenCLBuiltin, GenTypeMaxCnt, RetTypes,\n                                 ArgTypes);\n    if (GenTypeMaxCnt > 1) {\n      HasGenType = true;\n    }\n\n    // Create function overload for each type combination.\n    std::vector<QualType> FunctionList;\n    GetOpenCLBuiltinFctOverloads(Context, GenTypeMaxCnt, FunctionList, RetTypes,\n                                 ArgTypes);\n\n    SourceLocation Loc = LR.getNameLoc();\n    DeclContext *Parent = Context.getTranslationUnitDecl();\n    FunctionDecl *NewOpenCLBuiltin;\n\n    for (unsigned Index = 0; Index < GenTypeMaxCnt; Index++) {\n      NewOpenCLBuiltin = FunctionDecl::Create(\n          Context, Parent, Loc, Loc, II, FunctionList[Index],\n          /*TInfo=*/nullptr, SC_Extern, false,\n          FunctionList[Index]->isFunctionProtoType());\n      NewOpenCLBuiltin->setImplicit();\n\n      // Create Decl objects for each parameter, adding them to the\n      // FunctionDecl.\n      if (const FunctionProtoType *FP =\n              dyn_cast<FunctionProtoType>(FunctionList[Index])) {\n        SmallVector<ParmVarDecl *, 16> ParmList;\n        for (unsigned IParm = 0, e = FP->getNumParams(); IParm != e; ++IParm) {\n          ParmVarDecl *Parm = ParmVarDecl::Create(\n              Context, NewOpenCLBuiltin, SourceLocation(), SourceLocation(),\n              nullptr, FP->getParamType(IParm),\n              /*TInfo=*/nullptr, SC_None, nullptr);\n          Parm->setScopeInfo(0, IParm);\n          ParmList.push_back(Parm);\n        }\n        NewOpenCLBuiltin->setParams(ParmList);\n      }\n\n      // Add function attributes.\n      if (OpenCLBuiltin.IsPure)\n        NewOpenCLBuiltin->addAttr(PureAttr::CreateImplicit(Context));\n      if (OpenCLBuiltin.IsConst)\n        NewOpenCLBuiltin->addAttr(ConstAttr::CreateImplicit(Context));\n      if (OpenCLBuiltin.IsConv)\n        NewOpenCLBuiltin->addAttr(ConvergentAttr::CreateImplicit(Context));\n\n      if (!S.getLangOpts().OpenCLCPlusPlus)\n        NewOpenCLBuiltin->addAttr(OverloadableAttr::CreateImplicit(Context));\n\n      LR.addDecl(NewOpenCLBuiltin);\n    }\n  }\n\n  // If we added overloads, need to resolve the lookup result.\n  if (Len > 1 || HasGenType)\n    LR.resolveKind();\n}\n\n/// Lookup a builtin function, when name lookup would otherwise\n/// fail.\nbool Sema::LookupBuiltin(LookupResult &R) {\n  Sema::LookupNameKind NameKind = R.getLookupKind();\n\n  // If we didn't find a use of this identifier, and if the identifier\n  // corresponds to a compiler builtin, create the decl object for the builtin\n  // now, injecting it into translation unit scope, and return it.\n  if (NameKind == Sema::LookupOrdinaryName ||\n      NameKind == Sema::LookupRedeclarationWithLinkage) {\n    IdentifierInfo *II = R.getLookupName().getAsIdentifierInfo();\n    if (II) {\n      if (getLangOpts().CPlusPlus && NameKind == Sema::LookupOrdinaryName) {\n        if (II == getASTContext().getMakeIntegerSeqName()) {\n          R.addDecl(getASTContext().getMakeIntegerSeqDecl());\n          return true;\n        } else if (II == getASTContext().getTypePackElementName()) {\n          R.addDecl(getASTContext().getTypePackElementDecl());\n          return true;\n        }\n      }\n\n      // Check if this is an OpenCL Builtin, and if so, insert its overloads.\n      if (getLangOpts().OpenCL && getLangOpts().DeclareOpenCLBuiltins) {\n        auto Index = isOpenCLBuiltin(II->getName());\n        if (Index.first) {\n          InsertOCLBuiltinDeclarationsFromTable(*this, R, II, Index.first - 1,\n                                                Index.second);\n          return true;\n        }\n      }\n\n      // If this is a builtin on this (or all) targets, create the decl.\n      if (unsigned BuiltinID = II->getBuiltinID()) {\n        // In C++ and OpenCL (spec v1.2 s6.9.f), we don't have any predefined\n        // library functions like 'malloc'. Instead, we'll just error.\n        if ((getLangOpts().CPlusPlus || getLangOpts().OpenCL) &&\n            Context.BuiltinInfo.isPredefinedLibFunction(BuiltinID))\n          return false;\n\n        if (NamedDecl *D =\n                LazilyCreateBuiltin(II, BuiltinID, TUScope,\n                                    R.isForRedeclaration(), R.getNameLoc())) {\n          R.addDecl(D);\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\n/// Looks up the declaration of \"struct objc_super\" and\n/// saves it for later use in building builtin declaration of\n/// objc_msgSendSuper and objc_msgSendSuper_stret.\nstatic void LookupPredefedObjCSuperType(Sema &Sema, Scope *S) {\n  ASTContext &Context = Sema.Context;\n  LookupResult Result(Sema, &Context.Idents.get(\"objc_super\"), SourceLocation(),\n                      Sema::LookupTagName);\n  Sema.LookupName(Result, S);\n  if (Result.getResultKind() == LookupResult::Found)\n    if (const TagDecl *TD = Result.getAsSingle<TagDecl>())\n      Context.setObjCSuperType(Context.getTagDeclType(TD));\n}\n\nvoid Sema::LookupNecessaryTypesForBuiltin(Scope *S, unsigned ID) {\n  if (ID == Builtin::BIobjc_msgSendSuper)\n    LookupPredefedObjCSuperType(*this, S);\n}\n\n/// Determine whether we can declare a special member function within\n/// the class at this point.\nstatic bool CanDeclareSpecialMemberFunction(const CXXRecordDecl *Class) {\n  // We need to have a definition for the class.\n  if (!Class->getDefinition() || Class->isDependentContext())\n    return false;\n\n  // We can't be in the middle of defining the class.\n  return !Class->isBeingDefined();\n}\n\nvoid Sema::ForceDeclarationOfImplicitMembers(CXXRecordDecl *Class) {\n  if (!CanDeclareSpecialMemberFunction(Class))\n    return;\n\n  // If the default constructor has not yet been declared, do so now.\n  if (Class->needsImplicitDefaultConstructor())\n    DeclareImplicitDefaultConstructor(Class);\n\n  // If the copy constructor has not yet been declared, do so now.\n  if (Class->needsImplicitCopyConstructor())\n    DeclareImplicitCopyConstructor(Class);\n\n  // If the copy assignment operator has not yet been declared, do so now.\n  if (Class->needsImplicitCopyAssignment())\n    DeclareImplicitCopyAssignment(Class);\n\n  if (getLangOpts().CPlusPlus11) {\n    // If the move constructor has not yet been declared, do so now.\n    if (Class->needsImplicitMoveConstructor())\n      DeclareImplicitMoveConstructor(Class);\n\n    // If the move assignment operator has not yet been declared, do so now.\n    if (Class->needsImplicitMoveAssignment())\n      DeclareImplicitMoveAssignment(Class);\n  }\n\n  // If the destructor has not yet been declared, do so now.\n  if (Class->needsImplicitDestructor())\n    DeclareImplicitDestructor(Class);\n}\n\n/// Determine whether this is the name of an implicitly-declared\n/// special member function.\nstatic bool isImplicitlyDeclaredMemberFunctionName(DeclarationName Name) {\n  switch (Name.getNameKind()) {\n  case DeclarationName::CXXConstructorName:\n  case DeclarationName::CXXDestructorName:\n    return true;\n\n  case DeclarationName::CXXOperatorName:\n    return Name.getCXXOverloadedOperator() == OO_Equal;\n\n  default:\n    break;\n  }\n\n  return false;\n}\n\n/// If there are any implicit member functions with the given name\n/// that need to be declared in the given declaration context, do so.\nstatic void DeclareImplicitMemberFunctionsWithName(Sema &S,\n                                                   DeclarationName Name,\n                                                   SourceLocation Loc,\n                                                   const DeclContext *DC) {\n  if (!DC)\n    return;\n\n  switch (Name.getNameKind()) {\n  case DeclarationName::CXXConstructorName:\n    if (const CXXRecordDecl *Record = dyn_cast<CXXRecordDecl>(DC))\n      if (Record->getDefinition() && CanDeclareSpecialMemberFunction(Record)) {\n        CXXRecordDecl *Class = const_cast<CXXRecordDecl *>(Record);\n        if (Record->needsImplicitDefaultConstructor())\n          S.DeclareImplicitDefaultConstructor(Class);\n        if (Record->needsImplicitCopyConstructor())\n          S.DeclareImplicitCopyConstructor(Class);\n        if (S.getLangOpts().CPlusPlus11 &&\n            Record->needsImplicitMoveConstructor())\n          S.DeclareImplicitMoveConstructor(Class);\n      }\n    break;\n\n  case DeclarationName::CXXDestructorName:\n    if (const CXXRecordDecl *Record = dyn_cast<CXXRecordDecl>(DC))\n      if (Record->getDefinition() && Record->needsImplicitDestructor() &&\n          CanDeclareSpecialMemberFunction(Record))\n        S.DeclareImplicitDestructor(const_cast<CXXRecordDecl *>(Record));\n    break;\n\n  case DeclarationName::CXXOperatorName:\n    if (Name.getCXXOverloadedOperator() != OO_Equal)\n      break;\n\n    if (const CXXRecordDecl *Record = dyn_cast<CXXRecordDecl>(DC)) {\n      if (Record->getDefinition() && CanDeclareSpecialMemberFunction(Record)) {\n        CXXRecordDecl *Class = const_cast<CXXRecordDecl *>(Record);\n        if (Record->needsImplicitCopyAssignment())\n          S.DeclareImplicitCopyAssignment(Class);\n        if (S.getLangOpts().CPlusPlus11 &&\n            Record->needsImplicitMoveAssignment())\n          S.DeclareImplicitMoveAssignment(Class);\n      }\n    }\n    break;\n\n  case DeclarationName::CXXDeductionGuideName:\n    S.DeclareImplicitDeductionGuides(Name.getCXXDeductionGuideTemplate(), Loc);\n    break;\n\n  default:\n    break;\n  }\n}\n\n// Adds all qualifying matches for a name within a decl context to the\n// given lookup result.  Returns true if any matches were found.\nstatic bool LookupDirect(Sema &S, LookupResult &R, const DeclContext *DC) {\n  bool Found = false;\n\n  // Lazily declare C++ special member functions.\n  if (S.getLangOpts().CPlusPlus)\n    DeclareImplicitMemberFunctionsWithName(S, R.getLookupName(), R.getNameLoc(),\n                                           DC);\n\n  // Perform lookup into this declaration context.\n  DeclContext::lookup_result DR = DC->lookup(R.getLookupName());\n  for (NamedDecl *D : DR) {\n    if ((D = R.getAcceptableDecl(D))) {\n      R.addDecl(D);\n      Found = true;\n    }\n  }\n\n  if (!Found && DC->isTranslationUnit() && S.LookupBuiltin(R))\n    return true;\n\n  if (R.getLookupName().getNameKind()\n        != DeclarationName::CXXConversionFunctionName ||\n      R.getLookupName().getCXXNameType()->isDependentType() ||\n      !isa<CXXRecordDecl>(DC))\n    return Found;\n\n  // C++ [temp.mem]p6:\n  //   A specialization of a conversion function template is not found by\n  //   name lookup. Instead, any conversion function templates visible in the\n  //   context of the use are considered. [...]\n  const CXXRecordDecl *Record = cast<CXXRecordDecl>(DC);\n  if (!Record->isCompleteDefinition())\n    return Found;\n\n  // For conversion operators, 'operator auto' should only match\n  // 'operator auto'.  Since 'auto' is not a type, it shouldn't be considered\n  // as a candidate for template substitution.\n  auto *ContainedDeducedType =\n      R.getLookupName().getCXXNameType()->getContainedDeducedType();\n  if (R.getLookupName().getNameKind() ==\n          DeclarationName::CXXConversionFunctionName &&\n      ContainedDeducedType && ContainedDeducedType->isUndeducedType())\n    return Found;\n\n  for (CXXRecordDecl::conversion_iterator U = Record->conversion_begin(),\n         UEnd = Record->conversion_end(); U != UEnd; ++U) {\n    FunctionTemplateDecl *ConvTemplate = dyn_cast<FunctionTemplateDecl>(*U);\n    if (!ConvTemplate)\n      continue;\n\n    // When we're performing lookup for the purposes of redeclaration, just\n    // add the conversion function template. When we deduce template\n    // arguments for specializations, we'll end up unifying the return\n    // type of the new declaration with the type of the function template.\n    if (R.isForRedeclaration()) {\n      R.addDecl(ConvTemplate);\n      Found = true;\n      continue;\n    }\n\n    // C++ [temp.mem]p6:\n    //   [...] For each such operator, if argument deduction succeeds\n    //   (14.9.2.3), the resulting specialization is used as if found by\n    //   name lookup.\n    //\n    // When referencing a conversion function for any purpose other than\n    // a redeclaration (such that we'll be building an expression with the\n    // result), perform template argument deduction and place the\n    // specialization into the result set. We do this to avoid forcing all\n    // callers to perform special deduction for conversion functions.\n    TemplateDeductionInfo Info(R.getNameLoc());\n    FunctionDecl *Specialization = nullptr;\n\n    const FunctionProtoType *ConvProto\n      = ConvTemplate->getTemplatedDecl()->getType()->getAs<FunctionProtoType>();\n    assert(ConvProto && \"Nonsensical conversion function template type\");\n\n    // Compute the type of the function that we would expect the conversion\n    // function to have, if it were to match the name given.\n    // FIXME: Calling convention!\n    FunctionProtoType::ExtProtoInfo EPI = ConvProto->getExtProtoInfo();\n    EPI.ExtInfo = EPI.ExtInfo.withCallingConv(CC_C);\n    EPI.ExceptionSpec = EST_None;\n    QualType ExpectedType\n      = R.getSema().Context.getFunctionType(R.getLookupName().getCXXNameType(),\n                                            None, EPI);\n\n    // Perform template argument deduction against the type that we would\n    // expect the function to have.\n    if (R.getSema().DeduceTemplateArguments(ConvTemplate, nullptr, ExpectedType,\n                                            Specialization, Info)\n          == Sema::TDK_Success) {\n      R.addDecl(Specialization);\n      Found = true;\n    }\n  }\n\n  return Found;\n}\n\n// Performs C++ unqualified lookup into the given file context.\nstatic bool\nCppNamespaceLookup(Sema &S, LookupResult &R, ASTContext &Context,\n                   DeclContext *NS, UnqualUsingDirectiveSet &UDirs) {\n\n  assert(NS && NS->isFileContext() && \"CppNamespaceLookup() requires namespace!\");\n\n  // Perform direct name lookup into the LookupCtx.\n  bool Found = LookupDirect(S, R, NS);\n\n  // Perform direct name lookup into the namespaces nominated by the\n  // using directives whose common ancestor is this namespace.\n  for (const UnqualUsingEntry &UUE : UDirs.getNamespacesFor(NS))\n    if (LookupDirect(S, R, UUE.getNominatedNamespace()))\n      Found = true;\n\n  R.resolveKind();\n\n  return Found;\n}\n\nstatic bool isNamespaceOrTranslationUnitScope(Scope *S) {\n  if (DeclContext *Ctx = S->getEntity())\n    return Ctx->isFileContext();\n  return false;\n}\n\n/// Find the outer declaration context from this scope. This indicates the\n/// context that we should search up to (exclusive) before considering the\n/// parent of the specified scope.\nstatic DeclContext *findOuterContext(Scope *S) {\n  for (Scope *OuterS = S->getParent(); OuterS; OuterS = OuterS->getParent())\n    if (DeclContext *DC = OuterS->getLookupEntity())\n      return DC;\n  return nullptr;\n}\n\nnamespace {\n/// An RAII object to specify that we want to find block scope extern\n/// declarations.\nstruct FindLocalExternScope {\n  FindLocalExternScope(LookupResult &R)\n      : R(R), OldFindLocalExtern(R.getIdentifierNamespace() &\n                                 Decl::IDNS_LocalExtern) {\n    R.setFindLocalExtern(R.getIdentifierNamespace() &\n                         (Decl::IDNS_Ordinary | Decl::IDNS_NonMemberOperator));\n  }\n  void restore() {\n    R.setFindLocalExtern(OldFindLocalExtern);\n  }\n  ~FindLocalExternScope() {\n    restore();\n  }\n  LookupResult &R;\n  bool OldFindLocalExtern;\n};\n} // end anonymous namespace\n\nbool Sema::CppLookupName(LookupResult &R, Scope *S) {\n  assert(getLangOpts().CPlusPlus && \"Can perform only C++ lookup\");\n\n  DeclarationName Name = R.getLookupName();\n  Sema::LookupNameKind NameKind = R.getLookupKind();\n\n  // If this is the name of an implicitly-declared special member function,\n  // go through the scope stack to implicitly declare\n  if (isImplicitlyDeclaredMemberFunctionName(Name)) {\n    for (Scope *PreS = S; PreS; PreS = PreS->getParent())\n      if (DeclContext *DC = PreS->getEntity())\n        DeclareImplicitMemberFunctionsWithName(*this, Name, R.getNameLoc(), DC);\n  }\n\n  // Implicitly declare member functions with the name we're looking for, if in\n  // fact we are in a scope where it matters.\n\n  Scope *Initial = S;\n  IdentifierResolver::iterator\n    I = IdResolver.begin(Name),\n    IEnd = IdResolver.end();\n\n  // First we lookup local scope.\n  // We don't consider using-directives, as per 7.3.4.p1 [namespace.udir]\n  // ...During unqualified name lookup (3.4.1), the names appear as if\n  // they were declared in the nearest enclosing namespace which contains\n  // both the using-directive and the nominated namespace.\n  // [Note: in this context, \"contains\" means \"contains directly or\n  // indirectly\".\n  //\n  // For example:\n  // namespace A { int i; }\n  // void foo() {\n  //   int i;\n  //   {\n  //     using namespace A;\n  //     ++i; // finds local 'i', A::i appears at global scope\n  //   }\n  // }\n  //\n  UnqualUsingDirectiveSet UDirs(*this);\n  bool VisitedUsingDirectives = false;\n  bool LeftStartingScope = false;\n\n  // When performing a scope lookup, we want to find local extern decls.\n  FindLocalExternScope FindLocals(R);\n\n  for (; S && !isNamespaceOrTranslationUnitScope(S); S = S->getParent()) {\n    bool SearchNamespaceScope = true;\n    // Check whether the IdResolver has anything in this scope.\n    for (; I != IEnd && S->isDeclScope(*I); ++I) {\n      if (NamedDecl *ND = R.getAcceptableDecl(*I)) {\n        if (NameKind == LookupRedeclarationWithLinkage &&\n            !(*I)->isTemplateParameter()) {\n          // If it's a template parameter, we still find it, so we can diagnose\n          // the invalid redeclaration.\n\n          // Determine whether this (or a previous) declaration is\n          // out-of-scope.\n          if (!LeftStartingScope && !Initial->isDeclScope(*I))\n            LeftStartingScope = true;\n\n          // If we found something outside of our starting scope that\n          // does not have linkage, skip it.\n          if (LeftStartingScope && !((*I)->hasLinkage())) {\n            R.setShadowed();\n            continue;\n          }\n        } else {\n          // We found something in this scope, we should not look at the\n          // namespace scope\n          SearchNamespaceScope = false;\n        }\n        R.addDecl(ND);\n      }\n    }\n    if (!SearchNamespaceScope) {\n      R.resolveKind();\n      if (S->isClassScope())\n        if (CXXRecordDecl *Record =\n                dyn_cast_or_null<CXXRecordDecl>(S->getEntity()))\n          R.setNamingClass(Record);\n      return true;\n    }\n\n    if (NameKind == LookupLocalFriendName && !S->isClassScope()) {\n      // C++11 [class.friend]p11:\n      //   If a friend declaration appears in a local class and the name\n      //   specified is an unqualified name, a prior declaration is\n      //   looked up without considering scopes that are outside the\n      //   innermost enclosing non-class scope.\n      return false;\n    }\n\n    if (DeclContext *Ctx = S->getLookupEntity()) {\n      DeclContext *OuterCtx = findOuterContext(S);\n      for (; Ctx && !Ctx->Equals(OuterCtx); Ctx = Ctx->getLookupParent()) {\n        // We do not directly look into transparent contexts, since\n        // those entities will be found in the nearest enclosing\n        // non-transparent context.\n        if (Ctx->isTransparentContext())\n          continue;\n\n        // We do not look directly into function or method contexts,\n        // since all of the local variables and parameters of the\n        // function/method are present within the Scope.\n        if (Ctx->isFunctionOrMethod()) {\n          // If we have an Objective-C instance method, look for ivars\n          // in the corresponding interface.\n          if (ObjCMethodDecl *Method = dyn_cast<ObjCMethodDecl>(Ctx)) {\n            if (Method->isInstanceMethod() && Name.getAsIdentifierInfo())\n              if (ObjCInterfaceDecl *Class = Method->getClassInterface()) {\n                ObjCInterfaceDecl *ClassDeclared;\n                if (ObjCIvarDecl *Ivar = Class->lookupInstanceVariable(\n                                                 Name.getAsIdentifierInfo(),\n                                                             ClassDeclared)) {\n                  if (NamedDecl *ND = R.getAcceptableDecl(Ivar)) {\n                    R.addDecl(ND);\n                    R.resolveKind();\n                    return true;\n                  }\n                }\n              }\n          }\n\n          continue;\n        }\n\n        // If this is a file context, we need to perform unqualified name\n        // lookup considering using directives.\n        if (Ctx->isFileContext()) {\n          // If we haven't handled using directives yet, do so now.\n          if (!VisitedUsingDirectives) {\n            // Add using directives from this context up to the top level.\n            for (DeclContext *UCtx = Ctx; UCtx; UCtx = UCtx->getParent()) {\n              if (UCtx->isTransparentContext())\n                continue;\n\n              UDirs.visit(UCtx, UCtx);\n            }\n\n            // Find the innermost file scope, so we can add using directives\n            // from local scopes.\n            Scope *InnermostFileScope = S;\n            while (InnermostFileScope &&\n                   !isNamespaceOrTranslationUnitScope(InnermostFileScope))\n              InnermostFileScope = InnermostFileScope->getParent();\n            UDirs.visitScopeChain(Initial, InnermostFileScope);\n\n            UDirs.done();\n\n            VisitedUsingDirectives = true;\n          }\n\n          if (CppNamespaceLookup(*this, R, Context, Ctx, UDirs)) {\n            R.resolveKind();\n            return true;\n          }\n\n          continue;\n        }\n\n        // Perform qualified name lookup into this context.\n        // FIXME: In some cases, we know that every name that could be found by\n        // this qualified name lookup will also be on the identifier chain. For\n        // example, inside a class without any base classes, we never need to\n        // perform qualified lookup because all of the members are on top of the\n        // identifier chain.\n        if (LookupQualifiedName(R, Ctx, /*InUnqualifiedLookup=*/true))\n          return true;\n      }\n    }\n  }\n\n  // Stop if we ran out of scopes.\n  // FIXME:  This really, really shouldn't be happening.\n  if (!S) return false;\n\n  // If we are looking for members, no need to look into global/namespace scope.\n  if (NameKind == LookupMemberName)\n    return false;\n\n  // Collect UsingDirectiveDecls in all scopes, and recursively all\n  // nominated namespaces by those using-directives.\n  //\n  // FIXME: Cache this sorted list in Scope structure, and DeclContext, so we\n  // don't build it for each lookup!\n  if (!VisitedUsingDirectives) {\n    UDirs.visitScopeChain(Initial, S);\n    UDirs.done();\n  }\n\n  // If we're not performing redeclaration lookup, do not look for local\n  // extern declarations outside of a function scope.\n  if (!R.isForRedeclaration())\n    FindLocals.restore();\n\n  // Lookup namespace scope, and global scope.\n  // Unqualified name lookup in C++ requires looking into scopes\n  // that aren't strictly lexical, and therefore we walk through the\n  // context as well as walking through the scopes.\n  for (; S; S = S->getParent()) {\n    // Check whether the IdResolver has anything in this scope.\n    bool Found = false;\n    for (; I != IEnd && S->isDeclScope(*I); ++I) {\n      if (NamedDecl *ND = R.getAcceptableDecl(*I)) {\n        // We found something.  Look for anything else in our scope\n        // with this same name and in an acceptable identifier\n        // namespace, so that we can construct an overload set if we\n        // need to.\n        Found = true;\n        R.addDecl(ND);\n      }\n    }\n\n    if (Found && S->isTemplateParamScope()) {\n      R.resolveKind();\n      return true;\n    }\n\n    DeclContext *Ctx = S->getLookupEntity();\n    if (Ctx) {\n      DeclContext *OuterCtx = findOuterContext(S);\n      for (; Ctx && !Ctx->Equals(OuterCtx); Ctx = Ctx->getLookupParent()) {\n        // We do not directly look into transparent contexts, since\n        // those entities will be found in the nearest enclosing\n        // non-transparent context.\n        if (Ctx->isTransparentContext())\n          continue;\n\n        // If we have a context, and it's not a context stashed in the\n        // template parameter scope for an out-of-line definition, also\n        // look into that context.\n        if (!(Found && S->isTemplateParamScope())) {\n          assert(Ctx->isFileContext() &&\n              \"We should have been looking only at file context here already.\");\n\n          // Look into context considering using-directives.\n          if (CppNamespaceLookup(*this, R, Context, Ctx, UDirs))\n            Found = true;\n        }\n\n        if (Found) {\n          R.resolveKind();\n          return true;\n        }\n\n        if (R.isForRedeclaration() && !Ctx->isTransparentContext())\n          return false;\n      }\n    }\n\n    if (R.isForRedeclaration() && Ctx && !Ctx->isTransparentContext())\n      return false;\n  }\n\n  return !R.empty();\n}\n\nvoid Sema::makeMergedDefinitionVisible(NamedDecl *ND) {\n  if (auto *M = getCurrentModule())\n    Context.mergeDefinitionIntoModule(ND, M);\n  else\n    // We're not building a module; just make the definition visible.\n    ND->setVisibleDespiteOwningModule();\n\n  // If ND is a template declaration, make the template parameters\n  // visible too. They're not (necessarily) within a mergeable DeclContext.\n  if (auto *TD = dyn_cast<TemplateDecl>(ND))\n    for (auto *Param : *TD->getTemplateParameters())\n      makeMergedDefinitionVisible(Param);\n}\n\n/// Find the module in which the given declaration was defined.\nstatic Module *getDefiningModule(Sema &S, Decl *Entity) {\n  if (FunctionDecl *FD = dyn_cast<FunctionDecl>(Entity)) {\n    // If this function was instantiated from a template, the defining module is\n    // the module containing the pattern.\n    if (FunctionDecl *Pattern = FD->getTemplateInstantiationPattern())\n      Entity = Pattern;\n  } else if (CXXRecordDecl *RD = dyn_cast<CXXRecordDecl>(Entity)) {\n    if (CXXRecordDecl *Pattern = RD->getTemplateInstantiationPattern())\n      Entity = Pattern;\n  } else if (EnumDecl *ED = dyn_cast<EnumDecl>(Entity)) {\n    if (auto *Pattern = ED->getTemplateInstantiationPattern())\n      Entity = Pattern;\n  } else if (VarDecl *VD = dyn_cast<VarDecl>(Entity)) {\n    if (VarDecl *Pattern = VD->getTemplateInstantiationPattern())\n      Entity = Pattern;\n  }\n\n  // Walk up to the containing context. That might also have been instantiated\n  // from a template.\n  DeclContext *Context = Entity->getLexicalDeclContext();\n  if (Context->isFileContext())\n    return S.getOwningModule(Entity);\n  return getDefiningModule(S, cast<Decl>(Context));\n}\n\nllvm::DenseSet<Module*> &Sema::getLookupModules() {\n  unsigned N = CodeSynthesisContexts.size();\n  for (unsigned I = CodeSynthesisContextLookupModules.size();\n       I != N; ++I) {\n    Module *M = CodeSynthesisContexts[I].Entity ?\n                getDefiningModule(*this, CodeSynthesisContexts[I].Entity) :\n                nullptr;\n    if (M && !LookupModulesCache.insert(M).second)\n      M = nullptr;\n    CodeSynthesisContextLookupModules.push_back(M);\n  }\n  return LookupModulesCache;\n}\n\n/// Determine whether the module M is part of the current module from the\n/// perspective of a module-private visibility check.\nstatic bool isInCurrentModule(const Module *M, const LangOptions &LangOpts) {\n  // If M is the global module fragment of a module that we've not yet finished\n  // parsing, then it must be part of the current module.\n  return M->getTopLevelModuleName() == LangOpts.CurrentModule ||\n         (M->Kind == Module::GlobalModuleFragment && !M->Parent);\n}\n\nbool Sema::hasVisibleMergedDefinition(NamedDecl *Def) {\n  for (const Module *Merged : Context.getModulesWithMergedDefinition(Def))\n    if (isModuleVisible(Merged))\n      return true;\n  return false;\n}\n\nbool Sema::hasMergedDefinitionInCurrentModule(NamedDecl *Def) {\n  for (const Module *Merged : Context.getModulesWithMergedDefinition(Def))\n    if (isInCurrentModule(Merged, getLangOpts()))\n      return true;\n  return false;\n}\n\ntemplate<typename ParmDecl>\nstatic bool\nhasVisibleDefaultArgument(Sema &S, const ParmDecl *D,\n                          llvm::SmallVectorImpl<Module *> *Modules) {\n  if (!D->hasDefaultArgument())\n    return false;\n\n  while (D) {\n    auto &DefaultArg = D->getDefaultArgStorage();\n    if (!DefaultArg.isInherited() && S.isVisible(D))\n      return true;\n\n    if (!DefaultArg.isInherited() && Modules) {\n      auto *NonConstD = const_cast<ParmDecl*>(D);\n      Modules->push_back(S.getOwningModule(NonConstD));\n    }\n\n    // If there was a previous default argument, maybe its parameter is visible.\n    D = DefaultArg.getInheritedFrom();\n  }\n  return false;\n}\n\nbool Sema::hasVisibleDefaultArgument(const NamedDecl *D,\n                                     llvm::SmallVectorImpl<Module *> *Modules) {\n  if (auto *P = dyn_cast<TemplateTypeParmDecl>(D))\n    return ::hasVisibleDefaultArgument(*this, P, Modules);\n  if (auto *P = dyn_cast<NonTypeTemplateParmDecl>(D))\n    return ::hasVisibleDefaultArgument(*this, P, Modules);\n  return ::hasVisibleDefaultArgument(*this, cast<TemplateTemplateParmDecl>(D),\n                                     Modules);\n}\n\ntemplate<typename Filter>\nstatic bool hasVisibleDeclarationImpl(Sema &S, const NamedDecl *D,\n                                      llvm::SmallVectorImpl<Module *> *Modules,\n                                      Filter F) {\n  bool HasFilteredRedecls = false;\n\n  for (auto *Redecl : D->redecls()) {\n    auto *R = cast<NamedDecl>(Redecl);\n    if (!F(R))\n      continue;\n\n    if (S.isVisible(R))\n      return true;\n\n    HasFilteredRedecls = true;\n\n    if (Modules)\n      Modules->push_back(R->getOwningModule());\n  }\n\n  // Only return false if there is at least one redecl that is not filtered out.\n  if (HasFilteredRedecls)\n    return false;\n\n  return true;\n}\n\nbool Sema::hasVisibleExplicitSpecialization(\n    const NamedDecl *D, llvm::SmallVectorImpl<Module *> *Modules) {\n  return hasVisibleDeclarationImpl(*this, D, Modules, [](const NamedDecl *D) {\n    if (auto *RD = dyn_cast<CXXRecordDecl>(D))\n      return RD->getTemplateSpecializationKind() == TSK_ExplicitSpecialization;\n    if (auto *FD = dyn_cast<FunctionDecl>(D))\n      return FD->getTemplateSpecializationKind() == TSK_ExplicitSpecialization;\n    if (auto *VD = dyn_cast<VarDecl>(D))\n      return VD->getTemplateSpecializationKind() == TSK_ExplicitSpecialization;\n    llvm_unreachable(\"unknown explicit specialization kind\");\n  });\n}\n\nbool Sema::hasVisibleMemberSpecialization(\n    const NamedDecl *D, llvm::SmallVectorImpl<Module *> *Modules) {\n  assert(isa<CXXRecordDecl>(D->getDeclContext()) &&\n         \"not a member specialization\");\n  return hasVisibleDeclarationImpl(*this, D, Modules, [](const NamedDecl *D) {\n    // If the specialization is declared at namespace scope, then it's a member\n    // specialization declaration. If it's lexically inside the class\n    // definition then it was instantiated.\n    //\n    // FIXME: This is a hack. There should be a better way to determine this.\n    // FIXME: What about MS-style explicit specializations declared within a\n    //        class definition?\n    return D->getLexicalDeclContext()->isFileContext();\n  });\n}\n\n/// Determine whether a declaration is visible to name lookup.\n///\n/// This routine determines whether the declaration D is visible in the current\n/// lookup context, taking into account the current template instantiation\n/// stack. During template instantiation, a declaration is visible if it is\n/// visible from a module containing any entity on the template instantiation\n/// path (by instantiating a template, you allow it to see the declarations that\n/// your module can see, including those later on in your module).\nbool LookupResult::isVisibleSlow(Sema &SemaRef, NamedDecl *D) {\n  assert(!D->isUnconditionallyVisible() &&\n         \"should not call this: not in slow case\");\n\n  Module *DeclModule = SemaRef.getOwningModule(D);\n  assert(DeclModule && \"hidden decl has no owning module\");\n\n  // If the owning module is visible, the decl is visible.\n  if (SemaRef.isModuleVisible(DeclModule, D->isModulePrivate()))\n    return true;\n\n  // Determine whether a decl context is a file context for the purpose of\n  // visibility. This looks through some (export and linkage spec) transparent\n  // contexts, but not others (enums).\n  auto IsEffectivelyFileContext = [](const DeclContext *DC) {\n    return DC->isFileContext() || isa<LinkageSpecDecl>(DC) ||\n           isa<ExportDecl>(DC);\n  };\n\n  // If this declaration is not at namespace scope\n  // then it is visible if its lexical parent has a visible definition.\n  DeclContext *DC = D->getLexicalDeclContext();\n  if (DC && !IsEffectivelyFileContext(DC)) {\n    // For a parameter, check whether our current template declaration's\n    // lexical context is visible, not whether there's some other visible\n    // definition of it, because parameters aren't \"within\" the definition.\n    //\n    // In C++ we need to check for a visible definition due to ODR merging,\n    // and in C we must not because each declaration of a function gets its own\n    // set of declarations for tags in prototype scope.\n    bool VisibleWithinParent;\n    if (D->isTemplateParameter()) {\n      bool SearchDefinitions = true;\n      if (const auto *DCD = dyn_cast<Decl>(DC)) {\n        if (const auto *TD = DCD->getDescribedTemplate()) {\n          TemplateParameterList *TPL = TD->getTemplateParameters();\n          auto Index = getDepthAndIndex(D).second;\n          SearchDefinitions = Index >= TPL->size() || TPL->getParam(Index) != D;\n        }\n      }\n      if (SearchDefinitions)\n        VisibleWithinParent = SemaRef.hasVisibleDefinition(cast<NamedDecl>(DC));\n      else\n        VisibleWithinParent = isVisible(SemaRef, cast<NamedDecl>(DC));\n    } else if (isa<ParmVarDecl>(D) ||\n               (isa<FunctionDecl>(DC) && !SemaRef.getLangOpts().CPlusPlus))\n      VisibleWithinParent = isVisible(SemaRef, cast<NamedDecl>(DC));\n    else if (D->isModulePrivate()) {\n      // A module-private declaration is only visible if an enclosing lexical\n      // parent was merged with another definition in the current module.\n      VisibleWithinParent = false;\n      do {\n        if (SemaRef.hasMergedDefinitionInCurrentModule(cast<NamedDecl>(DC))) {\n          VisibleWithinParent = true;\n          break;\n        }\n        DC = DC->getLexicalParent();\n      } while (!IsEffectivelyFileContext(DC));\n    } else {\n      VisibleWithinParent = SemaRef.hasVisibleDefinition(cast<NamedDecl>(DC));\n    }\n\n    if (VisibleWithinParent && SemaRef.CodeSynthesisContexts.empty() &&\n        // FIXME: Do something better in this case.\n        !SemaRef.getLangOpts().ModulesLocalVisibility) {\n      // Cache the fact that this declaration is implicitly visible because\n      // its parent has a visible definition.\n      D->setVisibleDespiteOwningModule();\n    }\n    return VisibleWithinParent;\n  }\n\n  return false;\n}\n\nbool Sema::isModuleVisible(const Module *M, bool ModulePrivate) {\n  // The module might be ordinarily visible. For a module-private query, that\n  // means it is part of the current module. For any other query, that means it\n  // is in our visible module set.\n  if (ModulePrivate) {\n    if (isInCurrentModule(M, getLangOpts()))\n      return true;\n  } else {\n    if (VisibleModules.isVisible(M))\n      return true;\n  }\n\n  // Otherwise, it might be visible by virtue of the query being within a\n  // template instantiation or similar that is permitted to look inside M.\n\n  // Find the extra places where we need to look.\n  const auto &LookupModules = getLookupModules();\n  if (LookupModules.empty())\n    return false;\n\n  // If our lookup set contains the module, it's visible.\n  if (LookupModules.count(M))\n    return true;\n\n  // For a module-private query, that's everywhere we get to look.\n  if (ModulePrivate)\n    return false;\n\n  // Check whether M is transitively exported to an import of the lookup set.\n  return llvm::any_of(LookupModules, [&](const Module *LookupM) {\n    return LookupM->isModuleVisible(M);\n  });\n}\n\nbool Sema::isVisibleSlow(const NamedDecl *D) {\n  return LookupResult::isVisible(*this, const_cast<NamedDecl*>(D));\n}\n\nbool Sema::shouldLinkPossiblyHiddenDecl(LookupResult &R, const NamedDecl *New) {\n  // FIXME: If there are both visible and hidden declarations, we need to take\n  // into account whether redeclaration is possible. Example:\n  //\n  // Non-imported module:\n  //   int f(T);        // #1\n  // Some TU:\n  //   static int f(U); // #2, not a redeclaration of #1\n  //   int f(T);        // #3, finds both, should link with #1 if T != U, but\n  //                    // with #2 if T == U; neither should be ambiguous.\n  for (auto *D : R) {\n    if (isVisible(D))\n      return true;\n    assert(D->isExternallyDeclarable() &&\n           \"should not have hidden, non-externally-declarable result here\");\n  }\n\n  // This function is called once \"New\" is essentially complete, but before a\n  // previous declaration is attached. We can't query the linkage of \"New\" in\n  // general, because attaching the previous declaration can change the\n  // linkage of New to match the previous declaration.\n  //\n  // However, because we've just determined that there is no *visible* prior\n  // declaration, we can compute the linkage here. There are two possibilities:\n  //\n  //  * This is not a redeclaration; it's safe to compute the linkage now.\n  //\n  //  * This is a redeclaration of a prior declaration that is externally\n  //    redeclarable. In that case, the linkage of the declaration is not\n  //    changed by attaching the prior declaration, because both are externally\n  //    declarable (and thus ExternalLinkage or VisibleNoLinkage).\n  //\n  // FIXME: This is subtle and fragile.\n  return New->isExternallyDeclarable();\n}\n\n/// Retrieve the visible declaration corresponding to D, if any.\n///\n/// This routine determines whether the declaration D is visible in the current\n/// module, with the current imports. If not, it checks whether any\n/// redeclaration of D is visible, and if so, returns that declaration.\n///\n/// \\returns D, or a visible previous declaration of D, whichever is more recent\n/// and visible. If no declaration of D is visible, returns null.\nstatic NamedDecl *findAcceptableDecl(Sema &SemaRef, NamedDecl *D,\n                                     unsigned IDNS) {\n  assert(!LookupResult::isVisible(SemaRef, D) && \"not in slow case\");\n\n  for (auto RD : D->redecls()) {\n    // Don't bother with extra checks if we already know this one isn't visible.\n    if (RD == D)\n      continue;\n\n    auto ND = cast<NamedDecl>(RD);\n    // FIXME: This is wrong in the case where the previous declaration is not\n    // visible in the same scope as D. This needs to be done much more\n    // carefully.\n    if (ND->isInIdentifierNamespace(IDNS) &&\n        LookupResult::isVisible(SemaRef, ND))\n      return ND;\n  }\n\n  return nullptr;\n}\n\nbool Sema::hasVisibleDeclarationSlow(const NamedDecl *D,\n                                     llvm::SmallVectorImpl<Module *> *Modules) {\n  assert(!isVisible(D) && \"not in slow case\");\n  return hasVisibleDeclarationImpl(*this, D, Modules,\n                                   [](const NamedDecl *) { return true; });\n}\n\nNamedDecl *LookupResult::getAcceptableDeclSlow(NamedDecl *D) const {\n  if (auto *ND = dyn_cast<NamespaceDecl>(D)) {\n    // Namespaces are a bit of a special case: we expect there to be a lot of\n    // redeclarations of some namespaces, all declarations of a namespace are\n    // essentially interchangeable, all declarations are found by name lookup\n    // if any is, and namespaces are never looked up during template\n    // instantiation. So we benefit from caching the check in this case, and\n    // it is correct to do so.\n    auto *Key = ND->getCanonicalDecl();\n    if (auto *Acceptable = getSema().VisibleNamespaceCache.lookup(Key))\n      return Acceptable;\n    auto *Acceptable = isVisible(getSema(), Key)\n                           ? Key\n                           : findAcceptableDecl(getSema(), Key, IDNS);\n    if (Acceptable)\n      getSema().VisibleNamespaceCache.insert(std::make_pair(Key, Acceptable));\n    return Acceptable;\n  }\n\n  return findAcceptableDecl(getSema(), D, IDNS);\n}\n\n/// Perform unqualified name lookup starting from a given\n/// scope.\n///\n/// Unqualified name lookup (C++ [basic.lookup.unqual], C99 6.2.1) is\n/// used to find names within the current scope. For example, 'x' in\n/// @code\n/// int x;\n/// int f() {\n///   return x; // unqualified name look finds 'x' in the global scope\n/// }\n/// @endcode\n///\n/// Different lookup criteria can find different names. For example, a\n/// particular scope can have both a struct and a function of the same\n/// name, and each can be found by certain lookup criteria. For more\n/// information about lookup criteria, see the documentation for the\n/// class LookupCriteria.\n///\n/// @param S        The scope from which unqualified name lookup will\n/// begin. If the lookup criteria permits, name lookup may also search\n/// in the parent scopes.\n///\n/// @param [in,out] R Specifies the lookup to perform (e.g., the name to\n/// look up and the lookup kind), and is updated with the results of lookup\n/// including zero or more declarations and possibly additional information\n/// used to diagnose ambiguities.\n///\n/// @returns \\c true if lookup succeeded and false otherwise.\nbool Sema::LookupName(LookupResult &R, Scope *S, bool AllowBuiltinCreation) {\n  DeclarationName Name = R.getLookupName();\n  if (!Name) return false;\n\n  LookupNameKind NameKind = R.getLookupKind();\n\n  if (!getLangOpts().CPlusPlus) {\n    // Unqualified name lookup in C/Objective-C is purely lexical, so\n    // search in the declarations attached to the name.\n    if (NameKind == Sema::LookupRedeclarationWithLinkage) {\n      // Find the nearest non-transparent declaration scope.\n      while (!(S->getFlags() & Scope::DeclScope) ||\n             (S->getEntity() && S->getEntity()->isTransparentContext()))\n        S = S->getParent();\n    }\n\n    // When performing a scope lookup, we want to find local extern decls.\n    FindLocalExternScope FindLocals(R);\n\n    // Scan up the scope chain looking for a decl that matches this\n    // identifier that is in the appropriate namespace.  This search\n    // should not take long, as shadowing of names is uncommon, and\n    // deep shadowing is extremely uncommon.\n    bool LeftStartingScope = false;\n\n    for (IdentifierResolver::iterator I = IdResolver.begin(Name),\n                                   IEnd = IdResolver.end();\n         I != IEnd; ++I)\n      if (NamedDecl *D = R.getAcceptableDecl(*I)) {\n        if (NameKind == LookupRedeclarationWithLinkage) {\n          // Determine whether this (or a previous) declaration is\n          // out-of-scope.\n          if (!LeftStartingScope && !S->isDeclScope(*I))\n            LeftStartingScope = true;\n\n          // If we found something outside of our starting scope that\n          // does not have linkage, skip it.\n          if (LeftStartingScope && !((*I)->hasLinkage())) {\n            R.setShadowed();\n            continue;\n          }\n        }\n        else if (NameKind == LookupObjCImplicitSelfParam &&\n                 !isa<ImplicitParamDecl>(*I))\n          continue;\n\n        R.addDecl(D);\n\n        // Check whether there are any other declarations with the same name\n        // and in the same scope.\n        if (I != IEnd) {\n          // Find the scope in which this declaration was declared (if it\n          // actually exists in a Scope).\n          while (S && !S->isDeclScope(D))\n            S = S->getParent();\n\n          // If the scope containing the declaration is the translation unit,\n          // then we'll need to perform our checks based on the matching\n          // DeclContexts rather than matching scopes.\n          if (S && isNamespaceOrTranslationUnitScope(S))\n            S = nullptr;\n\n          // Compute the DeclContext, if we need it.\n          DeclContext *DC = nullptr;\n          if (!S)\n            DC = (*I)->getDeclContext()->getRedeclContext();\n\n          IdentifierResolver::iterator LastI = I;\n          for (++LastI; LastI != IEnd; ++LastI) {\n            if (S) {\n              // Match based on scope.\n              if (!S->isDeclScope(*LastI))\n                break;\n            } else {\n              // Match based on DeclContext.\n              DeclContext *LastDC\n                = (*LastI)->getDeclContext()->getRedeclContext();\n              if (!LastDC->Equals(DC))\n                break;\n            }\n\n            // If the declaration is in the right namespace and visible, add it.\n            if (NamedDecl *LastD = R.getAcceptableDecl(*LastI))\n              R.addDecl(LastD);\n          }\n\n          R.resolveKind();\n        }\n\n        return true;\n      }\n  } else {\n    // Perform C++ unqualified name lookup.\n    if (CppLookupName(R, S))\n      return true;\n  }\n\n  // If we didn't find a use of this identifier, and if the identifier\n  // corresponds to a compiler builtin, create the decl object for the builtin\n  // now, injecting it into translation unit scope, and return it.\n  if (AllowBuiltinCreation && LookupBuiltin(R))\n    return true;\n\n  // If we didn't find a use of this identifier, the ExternalSource\n  // may be able to handle the situation.\n  // Note: some lookup failures are expected!\n  // See e.g. R.isForRedeclaration().\n  return (ExternalSource && ExternalSource->LookupUnqualified(R, S));\n}\n\n/// Perform qualified name lookup in the namespaces nominated by\n/// using directives by the given context.\n///\n/// C++98 [namespace.qual]p2:\n///   Given X::m (where X is a user-declared namespace), or given \\::m\n///   (where X is the global namespace), let S be the set of all\n///   declarations of m in X and in the transitive closure of all\n///   namespaces nominated by using-directives in X and its used\n///   namespaces, except that using-directives are ignored in any\n///   namespace, including X, directly containing one or more\n///   declarations of m. No namespace is searched more than once in\n///   the lookup of a name. If S is the empty set, the program is\n///   ill-formed. Otherwise, if S has exactly one member, or if the\n///   context of the reference is a using-declaration\n///   (namespace.udecl), S is the required set of declarations of\n///   m. Otherwise if the use of m is not one that allows a unique\n///   declaration to be chosen from S, the program is ill-formed.\n///\n/// C++98 [namespace.qual]p5:\n///   During the lookup of a qualified namespace member name, if the\n///   lookup finds more than one declaration of the member, and if one\n///   declaration introduces a class name or enumeration name and the\n///   other declarations either introduce the same object, the same\n///   enumerator or a set of functions, the non-type name hides the\n///   class or enumeration name if and only if the declarations are\n///   from the same namespace; otherwise (the declarations are from\n///   different namespaces), the program is ill-formed.\nstatic bool LookupQualifiedNameInUsingDirectives(Sema &S, LookupResult &R,\n                                                 DeclContext *StartDC) {\n  assert(StartDC->isFileContext() && \"start context is not a file context\");\n\n  // We have not yet looked into these namespaces, much less added\n  // their \"using-children\" to the queue.\n  SmallVector<NamespaceDecl*, 8> Queue;\n\n  // We have at least added all these contexts to the queue.\n  llvm::SmallPtrSet<DeclContext*, 8> Visited;\n  Visited.insert(StartDC);\n\n  // We have already looked into the initial namespace; seed the queue\n  // with its using-children.\n  for (auto *I : StartDC->using_directives()) {\n    NamespaceDecl *ND = I->getNominatedNamespace()->getOriginalNamespace();\n    if (S.isVisible(I) && Visited.insert(ND).second)\n      Queue.push_back(ND);\n  }\n\n  // The easiest way to implement the restriction in [namespace.qual]p5\n  // is to check whether any of the individual results found a tag\n  // and, if so, to declare an ambiguity if the final result is not\n  // a tag.\n  bool FoundTag = false;\n  bool FoundNonTag = false;\n\n  LookupResult LocalR(LookupResult::Temporary, R);\n\n  bool Found = false;\n  while (!Queue.empty()) {\n    NamespaceDecl *ND = Queue.pop_back_val();\n\n    // We go through some convolutions here to avoid copying results\n    // between LookupResults.\n    bool UseLocal = !R.empty();\n    LookupResult &DirectR = UseLocal ? LocalR : R;\n    bool FoundDirect = LookupDirect(S, DirectR, ND);\n\n    if (FoundDirect) {\n      // First do any local hiding.\n      DirectR.resolveKind();\n\n      // If the local result is a tag, remember that.\n      if (DirectR.isSingleTagDecl())\n        FoundTag = true;\n      else\n        FoundNonTag = true;\n\n      // Append the local results to the total results if necessary.\n      if (UseLocal) {\n        R.addAllDecls(LocalR);\n        LocalR.clear();\n      }\n    }\n\n    // If we find names in this namespace, ignore its using directives.\n    if (FoundDirect) {\n      Found = true;\n      continue;\n    }\n\n    for (auto I : ND->using_directives()) {\n      NamespaceDecl *Nom = I->getNominatedNamespace();\n      if (S.isVisible(I) && Visited.insert(Nom).second)\n        Queue.push_back(Nom);\n    }\n  }\n\n  if (Found) {\n    if (FoundTag && FoundNonTag)\n      R.setAmbiguousQualifiedTagHiding();\n    else\n      R.resolveKind();\n  }\n\n  return Found;\n}\n\n/// Perform qualified name lookup into a given context.\n///\n/// Qualified name lookup (C++ [basic.lookup.qual]) is used to find\n/// names when the context of those names is explicit specified, e.g.,\n/// \"std::vector\" or \"x->member\", or as part of unqualified name lookup.\n///\n/// Different lookup criteria can find different names. For example, a\n/// particular scope can have both a struct and a function of the same\n/// name, and each can be found by certain lookup criteria. For more\n/// information about lookup criteria, see the documentation for the\n/// class LookupCriteria.\n///\n/// \\param R captures both the lookup criteria and any lookup results found.\n///\n/// \\param LookupCtx The context in which qualified name lookup will\n/// search. If the lookup criteria permits, name lookup may also search\n/// in the parent contexts or (for C++ classes) base classes.\n///\n/// \\param InUnqualifiedLookup true if this is qualified name lookup that\n/// occurs as part of unqualified name lookup.\n///\n/// \\returns true if lookup succeeded, false if it failed.\nbool Sema::LookupQualifiedName(LookupResult &R, DeclContext *LookupCtx,\n                               bool InUnqualifiedLookup) {\n  assert(LookupCtx && \"Sema::LookupQualifiedName requires a lookup context\");\n\n  if (!R.getLookupName())\n    return false;\n\n  // Make sure that the declaration context is complete.\n  assert((!isa<TagDecl>(LookupCtx) ||\n          LookupCtx->isDependentContext() ||\n          cast<TagDecl>(LookupCtx)->isCompleteDefinition() ||\n          cast<TagDecl>(LookupCtx)->isBeingDefined()) &&\n         \"Declaration context must already be complete!\");\n\n  struct QualifiedLookupInScope {\n    bool oldVal;\n    DeclContext *Context;\n    // Set flag in DeclContext informing debugger that we're looking for qualified name\n    QualifiedLookupInScope(DeclContext *ctx) : Context(ctx) {\n      oldVal = ctx->setUseQualifiedLookup();\n    }\n    ~QualifiedLookupInScope() {\n      Context->setUseQualifiedLookup(oldVal);\n    }\n  } QL(LookupCtx);\n\n  if (LookupDirect(*this, R, LookupCtx)) {\n    R.resolveKind();\n    if (isa<CXXRecordDecl>(LookupCtx))\n      R.setNamingClass(cast<CXXRecordDecl>(LookupCtx));\n    return true;\n  }\n\n  // Don't descend into implied contexts for redeclarations.\n  // C++98 [namespace.qual]p6:\n  //   In a declaration for a namespace member in which the\n  //   declarator-id is a qualified-id, given that the qualified-id\n  //   for the namespace member has the form\n  //     nested-name-specifier unqualified-id\n  //   the unqualified-id shall name a member of the namespace\n  //   designated by the nested-name-specifier.\n  // See also [class.mfct]p5 and [class.static.data]p2.\n  if (R.isForRedeclaration())\n    return false;\n\n  // If this is a namespace, look it up in the implied namespaces.\n  if (LookupCtx->isFileContext())\n    return LookupQualifiedNameInUsingDirectives(*this, R, LookupCtx);\n\n  // If this isn't a C++ class, we aren't allowed to look into base\n  // classes, we're done.\n  CXXRecordDecl *LookupRec = dyn_cast<CXXRecordDecl>(LookupCtx);\n  if (!LookupRec || !LookupRec->getDefinition())\n    return false;\n\n  // We're done for lookups that can never succeed for C++ classes.\n  if (R.getLookupKind() == LookupOperatorName ||\n      R.getLookupKind() == LookupNamespaceName ||\n      R.getLookupKind() == LookupObjCProtocolName ||\n      R.getLookupKind() == LookupLabel)\n    return false;\n\n  // If we're performing qualified name lookup into a dependent class,\n  // then we are actually looking into a current instantiation. If we have any\n  // dependent base classes, then we either have to delay lookup until\n  // template instantiation time (at which point all bases will be available)\n  // or we have to fail.\n  if (!InUnqualifiedLookup && LookupRec->isDependentContext() &&\n      LookupRec->hasAnyDependentBases()) {\n    R.setNotFoundInCurrentInstantiation();\n    return false;\n  }\n\n  // Perform lookup into our base classes.\n\n  DeclarationName Name = R.getLookupName();\n  unsigned IDNS = R.getIdentifierNamespace();\n\n  // Look for this member in our base classes.\n  auto BaseCallback = [Name, IDNS](const CXXBaseSpecifier *Specifier,\n                                   CXXBasePath &Path) -> bool {\n    CXXRecordDecl *BaseRecord = Specifier->getType()->getAsCXXRecordDecl();\n    // Drop leading non-matching lookup results from the declaration list so\n    // we don't need to consider them again below.\n    for (Path.Decls = BaseRecord->lookup(Name); !Path.Decls.empty();\n         Path.Decls = Path.Decls.slice(1)) {\n      if (Path.Decls.front()->isInIdentifierNamespace(IDNS))\n        return true;\n    }\n    return false;\n  };\n\n  CXXBasePaths Paths;\n  Paths.setOrigin(LookupRec);\n  if (!LookupRec->lookupInBases(BaseCallback, Paths))\n    return false;\n\n  R.setNamingClass(LookupRec);\n\n  // C++ [class.member.lookup]p2:\n  //   [...] If the resulting set of declarations are not all from\n  //   sub-objects of the same type, or the set has a nonstatic member\n  //   and includes members from distinct sub-objects, there is an\n  //   ambiguity and the program is ill-formed. Otherwise that set is\n  //   the result of the lookup.\n  QualType SubobjectType;\n  int SubobjectNumber = 0;\n  AccessSpecifier SubobjectAccess = AS_none;\n\n  // Check whether the given lookup result contains only static members.\n  auto HasOnlyStaticMembers = [&](DeclContextLookupResult Result) {\n    for (NamedDecl *ND : Result)\n      if (ND->isInIdentifierNamespace(IDNS) && ND->isCXXInstanceMember())\n        return false;\n    return true;\n  };\n\n  bool TemplateNameLookup = R.isTemplateNameLookup();\n\n  // Determine whether two sets of members contain the same members, as\n  // required by C++ [class.member.lookup]p6.\n  auto HasSameDeclarations = [&](DeclContextLookupResult A,\n                                 DeclContextLookupResult B) {\n    using Iterator = DeclContextLookupResult::iterator;\n    using Result = const void *;\n\n    auto Next = [&](Iterator &It, Iterator End) -> Result {\n      while (It != End) {\n        NamedDecl *ND = *It++;\n        if (!ND->isInIdentifierNamespace(IDNS))\n          continue;\n\n        // C++ [temp.local]p3:\n        //   A lookup that finds an injected-class-name (10.2) can result in\n        //   an ambiguity in certain cases (for example, if it is found in\n        //   more than one base class). If all of the injected-class-names\n        //   that are found refer to specializations of the same class\n        //   template, and if the name is used as a template-name, the\n        //   reference refers to the class template itself and not a\n        //   specialization thereof, and is not ambiguous.\n        if (TemplateNameLookup)\n          if (auto *TD = getAsTemplateNameDecl(ND))\n            ND = TD;\n\n        // C++ [class.member.lookup]p3:\n        //   type declarations (including injected-class-names) are replaced by\n        //   the types they designate\n        if (const TypeDecl *TD = dyn_cast<TypeDecl>(ND->getUnderlyingDecl())) {\n          QualType T = Context.getTypeDeclType(TD);\n          return T.getCanonicalType().getAsOpaquePtr();\n        }\n\n        return ND->getUnderlyingDecl()->getCanonicalDecl();\n      }\n      return nullptr;\n    };\n\n    // We'll often find the declarations are in the same order. Handle this\n    // case (and the special case of only one declaration) efficiently.\n    Iterator AIt = A.begin(), BIt = B.begin(), AEnd = A.end(), BEnd = B.end();\n    while (true) {\n      Result AResult = Next(AIt, AEnd);\n      Result BResult = Next(BIt, BEnd);\n      if (!AResult && !BResult)\n        return true;\n      if (!AResult || !BResult)\n        return false;\n      if (AResult != BResult) {\n        // Found a mismatch; carefully check both lists, accounting for the\n        // possibility of declarations appearing more than once.\n        llvm::SmallDenseMap<Result, bool, 32> AResults;\n        for (; AResult; AResult = Next(AIt, AEnd))\n          AResults.insert({AResult, /*FoundInB*/false});\n        unsigned Found = 0;\n        for (; BResult; BResult = Next(BIt, BEnd)) {\n          auto It = AResults.find(BResult);\n          if (It == AResults.end())\n            return false;\n          if (!It->second) {\n            It->second = true;\n            ++Found;\n          }\n        }\n        return AResults.size() == Found;\n      }\n    }\n  };\n\n  for (CXXBasePaths::paths_iterator Path = Paths.begin(), PathEnd = Paths.end();\n       Path != PathEnd; ++Path) {\n    const CXXBasePathElement &PathElement = Path->back();\n\n    // Pick the best (i.e. most permissive i.e. numerically lowest) access\n    // across all paths.\n    SubobjectAccess = std::min(SubobjectAccess, Path->Access);\n\n    // Determine whether we're looking at a distinct sub-object or not.\n    if (SubobjectType.isNull()) {\n      // This is the first subobject we've looked at. Record its type.\n      SubobjectType = Context.getCanonicalType(PathElement.Base->getType());\n      SubobjectNumber = PathElement.SubobjectNumber;\n      continue;\n    }\n\n    if (SubobjectType !=\n        Context.getCanonicalType(PathElement.Base->getType())) {\n      // We found members of the given name in two subobjects of\n      // different types. If the declaration sets aren't the same, this\n      // lookup is ambiguous.\n      //\n      // FIXME: The language rule says that this applies irrespective of\n      // whether the sets contain only static members.\n      if (HasOnlyStaticMembers(Path->Decls) &&\n          HasSameDeclarations(Paths.begin()->Decls, Path->Decls))\n        continue;\n\n      R.setAmbiguousBaseSubobjectTypes(Paths);\n      return true;\n    }\n\n    // FIXME: This language rule no longer exists. Checking for ambiguous base\n    // subobjects should be done as part of formation of a class member access\n    // expression (when converting the object parameter to the member's type).\n    if (SubobjectNumber != PathElement.SubobjectNumber) {\n      // We have a different subobject of the same type.\n\n      // C++ [class.member.lookup]p5:\n      //   A static member, a nested type or an enumerator defined in\n      //   a base class T can unambiguously be found even if an object\n      //   has more than one base class subobject of type T.\n      if (HasOnlyStaticMembers(Path->Decls))\n        continue;\n\n      // We have found a nonstatic member name in multiple, distinct\n      // subobjects. Name lookup is ambiguous.\n      R.setAmbiguousBaseSubobjects(Paths);\n      return true;\n    }\n  }\n\n  // Lookup in a base class succeeded; return these results.\n\n  for (auto *D : Paths.front().Decls) {\n    AccessSpecifier AS = CXXRecordDecl::MergeAccess(SubobjectAccess,\n                                                    D->getAccess());\n    if (NamedDecl *ND = R.getAcceptableDecl(D))\n      R.addDecl(ND, AS);\n  }\n  R.resolveKind();\n  return true;\n}\n\n/// Performs qualified name lookup or special type of lookup for\n/// \"__super::\" scope specifier.\n///\n/// This routine is a convenience overload meant to be called from contexts\n/// that need to perform a qualified name lookup with an optional C++ scope\n/// specifier that might require special kind of lookup.\n///\n/// \\param R captures both the lookup criteria and any lookup results found.\n///\n/// \\param LookupCtx The context in which qualified name lookup will\n/// search.\n///\n/// \\param SS An optional C++ scope-specifier.\n///\n/// \\returns true if lookup succeeded, false if it failed.\nbool Sema::LookupQualifiedName(LookupResult &R, DeclContext *LookupCtx,\n                               CXXScopeSpec &SS) {\n  auto *NNS = SS.getScopeRep();\n  if (NNS && NNS->getKind() == NestedNameSpecifier::Super)\n    return LookupInSuper(R, NNS->getAsRecordDecl());\n  else\n\n    return LookupQualifiedName(R, LookupCtx);\n}\n\n/// Performs name lookup for a name that was parsed in the\n/// source code, and may contain a C++ scope specifier.\n///\n/// This routine is a convenience routine meant to be called from\n/// contexts that receive a name and an optional C++ scope specifier\n/// (e.g., \"N::M::x\"). It will then perform either qualified or\n/// unqualified name lookup (with LookupQualifiedName or LookupName,\n/// respectively) on the given name and return those results. It will\n/// perform a special type of lookup for \"__super::\" scope specifier.\n///\n/// @param S        The scope from which unqualified name lookup will\n/// begin.\n///\n/// @param SS       An optional C++ scope-specifier, e.g., \"::N::M\".\n///\n/// @param EnteringContext Indicates whether we are going to enter the\n/// context of the scope-specifier SS (if present).\n///\n/// @returns True if any decls were found (but possibly ambiguous)\nbool Sema::LookupParsedName(LookupResult &R, Scope *S, CXXScopeSpec *SS,\n                            bool AllowBuiltinCreation, bool EnteringContext) {\n  if (SS && SS->isInvalid()) {\n    // When the scope specifier is invalid, don't even look for\n    // anything.\n    return false;\n  }\n\n  if (SS && SS->isSet()) {\n    NestedNameSpecifier *NNS = SS->getScopeRep();\n    if (NNS->getKind() == NestedNameSpecifier::Super)\n      return LookupInSuper(R, NNS->getAsRecordDecl());\n\n    if (DeclContext *DC = computeDeclContext(*SS, EnteringContext)) {\n      // We have resolved the scope specifier to a particular declaration\n      // contex, and will perform name lookup in that context.\n      if (!DC->isDependentContext() && RequireCompleteDeclContext(*SS, DC))\n        return false;\n\n      R.setContextRange(SS->getRange());\n      return LookupQualifiedName(R, DC);\n    }\n\n    // We could not resolve the scope specified to a specific declaration\n    // context, which means that SS refers to an unknown specialization.\n    // Name lookup can't find anything in this case.\n    R.setNotFoundInCurrentInstantiation();\n    R.setContextRange(SS->getRange());\n    return false;\n  }\n\n  // Perform unqualified name lookup starting in the given scope.\n  return LookupName(R, S, AllowBuiltinCreation);\n}\n\n/// Perform qualified name lookup into all base classes of the given\n/// class.\n///\n/// \\param R captures both the lookup criteria and any lookup results found.\n///\n/// \\param Class The context in which qualified name lookup will\n/// search. Name lookup will search in all base classes merging the results.\n///\n/// @returns True if any decls were found (but possibly ambiguous)\nbool Sema::LookupInSuper(LookupResult &R, CXXRecordDecl *Class) {\n  // The access-control rules we use here are essentially the rules for\n  // doing a lookup in Class that just magically skipped the direct\n  // members of Class itself.  That is, the naming class is Class, and the\n  // access includes the access of the base.\n  for (const auto &BaseSpec : Class->bases()) {\n    CXXRecordDecl *RD = cast<CXXRecordDecl>(\n        BaseSpec.getType()->castAs<RecordType>()->getDecl());\n    LookupResult Result(*this, R.getLookupNameInfo(), R.getLookupKind());\n    Result.setBaseObjectType(Context.getRecordType(Class));\n    LookupQualifiedName(Result, RD);\n\n    // Copy the lookup results into the target, merging the base's access into\n    // the path access.\n    for (auto I = Result.begin(), E = Result.end(); I != E; ++I) {\n      R.addDecl(I.getDecl(),\n                CXXRecordDecl::MergeAccess(BaseSpec.getAccessSpecifier(),\n                                           I.getAccess()));\n    }\n\n    Result.suppressDiagnostics();\n  }\n\n  R.resolveKind();\n  R.setNamingClass(Class);\n\n  return !R.empty();\n}\n\n/// Produce a diagnostic describing the ambiguity that resulted\n/// from name lookup.\n///\n/// \\param Result The result of the ambiguous lookup to be diagnosed.\nvoid Sema::DiagnoseAmbiguousLookup(LookupResult &Result) {\n  assert(Result.isAmbiguous() && \"Lookup result must be ambiguous\");\n\n  DeclarationName Name = Result.getLookupName();\n  SourceLocation NameLoc = Result.getNameLoc();\n  SourceRange LookupRange = Result.getContextRange();\n\n  switch (Result.getAmbiguityKind()) {\n  case LookupResult::AmbiguousBaseSubobjects: {\n    CXXBasePaths *Paths = Result.getBasePaths();\n    QualType SubobjectType = Paths->front().back().Base->getType();\n    Diag(NameLoc, diag::err_ambiguous_member_multiple_subobjects)\n      << Name << SubobjectType << getAmbiguousPathsDisplayString(*Paths)\n      << LookupRange;\n\n    DeclContext::lookup_iterator Found = Paths->front().Decls.begin();\n    while (isa<CXXMethodDecl>(*Found) &&\n           cast<CXXMethodDecl>(*Found)->isStatic())\n      ++Found;\n\n    Diag((*Found)->getLocation(), diag::note_ambiguous_member_found);\n    break;\n  }\n\n  case LookupResult::AmbiguousBaseSubobjectTypes: {\n    Diag(NameLoc, diag::err_ambiguous_member_multiple_subobject_types)\n      << Name << LookupRange;\n\n    CXXBasePaths *Paths = Result.getBasePaths();\n    std::set<const NamedDecl *> DeclsPrinted;\n    for (CXXBasePaths::paths_iterator Path = Paths->begin(),\n                                      PathEnd = Paths->end();\n         Path != PathEnd; ++Path) {\n      const NamedDecl *D = Path->Decls.front();\n      if (!D->isInIdentifierNamespace(Result.getIdentifierNamespace()))\n        continue;\n      if (DeclsPrinted.insert(D).second) {\n        if (const auto *TD = dyn_cast<TypedefNameDecl>(D->getUnderlyingDecl()))\n          Diag(D->getLocation(), diag::note_ambiguous_member_type_found)\n              << TD->getUnderlyingType();\n        else if (const auto *TD = dyn_cast<TypeDecl>(D->getUnderlyingDecl()))\n          Diag(D->getLocation(), diag::note_ambiguous_member_type_found)\n              << Context.getTypeDeclType(TD);\n        else\n          Diag(D->getLocation(), diag::note_ambiguous_member_found);\n      }\n    }\n    break;\n  }\n\n  case LookupResult::AmbiguousTagHiding: {\n    Diag(NameLoc, diag::err_ambiguous_tag_hiding) << Name << LookupRange;\n\n    llvm::SmallPtrSet<NamedDecl*, 8> TagDecls;\n\n    for (auto *D : Result)\n      if (TagDecl *TD = dyn_cast<TagDecl>(D)) {\n        TagDecls.insert(TD);\n        Diag(TD->getLocation(), diag::note_hidden_tag);\n      }\n\n    for (auto *D : Result)\n      if (!isa<TagDecl>(D))\n        Diag(D->getLocation(), diag::note_hiding_object);\n\n    // For recovery purposes, go ahead and implement the hiding.\n    LookupResult::Filter F = Result.makeFilter();\n    while (F.hasNext()) {\n      if (TagDecls.count(F.next()))\n        F.erase();\n    }\n    F.done();\n    break;\n  }\n\n  case LookupResult::AmbiguousReference: {\n    Diag(NameLoc, diag::err_ambiguous_reference) << Name << LookupRange;\n\n    for (auto *D : Result)\n      Diag(D->getLocation(), diag::note_ambiguous_candidate) << D;\n    break;\n  }\n  }\n}\n\nnamespace {\n  struct AssociatedLookup {\n    AssociatedLookup(Sema &S, SourceLocation InstantiationLoc,\n                     Sema::AssociatedNamespaceSet &Namespaces,\n                     Sema::AssociatedClassSet &Classes)\n      : S(S), Namespaces(Namespaces), Classes(Classes),\n        InstantiationLoc(InstantiationLoc) {\n    }\n\n    bool addClassTransitive(CXXRecordDecl *RD) {\n      Classes.insert(RD);\n      return ClassesTransitive.insert(RD);\n    }\n\n    Sema &S;\n    Sema::AssociatedNamespaceSet &Namespaces;\n    Sema::AssociatedClassSet &Classes;\n    SourceLocation InstantiationLoc;\n\n  private:\n    Sema::AssociatedClassSet ClassesTransitive;\n  };\n} // end anonymous namespace\n\nstatic void\naddAssociatedClassesAndNamespaces(AssociatedLookup &Result, QualType T);\n\n// Given the declaration context \\param Ctx of a class, class template or\n// enumeration, add the associated namespaces to \\param Namespaces as described\n// in [basic.lookup.argdep]p2.\nstatic void CollectEnclosingNamespace(Sema::AssociatedNamespaceSet &Namespaces,\n                                      DeclContext *Ctx) {\n  // The exact wording has been changed in C++14 as a result of\n  // CWG 1691 (see also CWG 1690 and CWG 1692). We apply it unconditionally\n  // to all language versions since it is possible to return a local type\n  // from a lambda in C++11.\n  //\n  // C++14 [basic.lookup.argdep]p2:\n  //   If T is a class type [...]. Its associated namespaces are the innermost\n  //   enclosing namespaces of its associated classes. [...]\n  //\n  //   If T is an enumeration type, its associated namespace is the innermost\n  //   enclosing namespace of its declaration. [...]\n\n  // We additionally skip inline namespaces. The innermost non-inline namespace\n  // contains all names of all its nested inline namespaces anyway, so we can\n  // replace the entire inline namespace tree with its root.\n  while (!Ctx->isFileContext() || Ctx->isInlineNamespace())\n    Ctx = Ctx->getParent();\n\n  Namespaces.insert(Ctx->getPrimaryContext());\n}\n\n// Add the associated classes and namespaces for argument-dependent\n// lookup that involves a template argument (C++ [basic.lookup.argdep]p2).\nstatic void\naddAssociatedClassesAndNamespaces(AssociatedLookup &Result,\n                                  const TemplateArgument &Arg) {\n  // C++ [basic.lookup.argdep]p2, last bullet:\n  //   -- [...] ;\n  switch (Arg.getKind()) {\n    case TemplateArgument::Null:\n      break;\n\n    case TemplateArgument::Type:\n      // [...] the namespaces and classes associated with the types of the\n      // template arguments provided for template type parameters (excluding\n      // template template parameters)\n      addAssociatedClassesAndNamespaces(Result, Arg.getAsType());\n      break;\n\n    case TemplateArgument::Template:\n    case TemplateArgument::TemplateExpansion: {\n      // [...] the namespaces in which any template template arguments are\n      // defined; and the classes in which any member templates used as\n      // template template arguments are defined.\n      TemplateName Template = Arg.getAsTemplateOrTemplatePattern();\n      if (ClassTemplateDecl *ClassTemplate\n                 = dyn_cast<ClassTemplateDecl>(Template.getAsTemplateDecl())) {\n        DeclContext *Ctx = ClassTemplate->getDeclContext();\n        if (CXXRecordDecl *EnclosingClass = dyn_cast<CXXRecordDecl>(Ctx))\n          Result.Classes.insert(EnclosingClass);\n        // Add the associated namespace for this class.\n        CollectEnclosingNamespace(Result.Namespaces, Ctx);\n      }\n      break;\n    }\n\n    case TemplateArgument::Declaration:\n    case TemplateArgument::Integral:\n    case TemplateArgument::Expression:\n    case TemplateArgument::NullPtr:\n      // [Note: non-type template arguments do not contribute to the set of\n      //  associated namespaces. ]\n      break;\n\n    case TemplateArgument::Pack:\n      for (const auto &P : Arg.pack_elements())\n        addAssociatedClassesAndNamespaces(Result, P);\n      break;\n  }\n}\n\n// Add the associated classes and namespaces for argument-dependent lookup\n// with an argument of class type (C++ [basic.lookup.argdep]p2).\nstatic void\naddAssociatedClassesAndNamespaces(AssociatedLookup &Result,\n                                  CXXRecordDecl *Class) {\n\n  // Just silently ignore anything whose name is __va_list_tag.\n  if (Class->getDeclName() == Result.S.VAListTagName)\n    return;\n\n  // C++ [basic.lookup.argdep]p2:\n  //   [...]\n  //     -- If T is a class type (including unions), its associated\n  //        classes are: the class itself; the class of which it is a\n  //        member, if any; and its direct and indirect base classes.\n  //        Its associated namespaces are the innermost enclosing\n  //        namespaces of its associated classes.\n\n  // Add the class of which it is a member, if any.\n  DeclContext *Ctx = Class->getDeclContext();\n  if (CXXRecordDecl *EnclosingClass = dyn_cast<CXXRecordDecl>(Ctx))\n    Result.Classes.insert(EnclosingClass);\n\n  // Add the associated namespace for this class.\n  CollectEnclosingNamespace(Result.Namespaces, Ctx);\n\n  // -- If T is a template-id, its associated namespaces and classes are\n  //    the namespace in which the template is defined; for member\n  //    templates, the member template's class; the namespaces and classes\n  //    associated with the types of the template arguments provided for\n  //    template type parameters (excluding template template parameters); the\n  //    namespaces in which any template template arguments are defined; and\n  //    the classes in which any member templates used as template template\n  //    arguments are defined. [Note: non-type template arguments do not\n  //    contribute to the set of associated namespaces. ]\n  if (ClassTemplateSpecializationDecl *Spec\n        = dyn_cast<ClassTemplateSpecializationDecl>(Class)) {\n    DeclContext *Ctx = Spec->getSpecializedTemplate()->getDeclContext();\n    if (CXXRecordDecl *EnclosingClass = dyn_cast<CXXRecordDecl>(Ctx))\n      Result.Classes.insert(EnclosingClass);\n    // Add the associated namespace for this class.\n    CollectEnclosingNamespace(Result.Namespaces, Ctx);\n\n    const TemplateArgumentList &TemplateArgs = Spec->getTemplateArgs();\n    for (unsigned I = 0, N = TemplateArgs.size(); I != N; ++I)\n      addAssociatedClassesAndNamespaces(Result, TemplateArgs[I]);\n  }\n\n  // Add the class itself. If we've already transitively visited this class,\n  // we don't need to visit base classes.\n  if (!Result.addClassTransitive(Class))\n    return;\n\n  // Only recurse into base classes for complete types.\n  if (!Result.S.isCompleteType(Result.InstantiationLoc,\n                               Result.S.Context.getRecordType(Class)))\n    return;\n\n  // Add direct and indirect base classes along with their associated\n  // namespaces.\n  SmallVector<CXXRecordDecl *, 32> Bases;\n  Bases.push_back(Class);\n  while (!Bases.empty()) {\n    // Pop this class off the stack.\n    Class = Bases.pop_back_val();\n\n    // Visit the base classes.\n    for (const auto &Base : Class->bases()) {\n      const RecordType *BaseType = Base.getType()->getAs<RecordType>();\n      // In dependent contexts, we do ADL twice, and the first time around,\n      // the base type might be a dependent TemplateSpecializationType, or a\n      // TemplateTypeParmType. If that happens, simply ignore it.\n      // FIXME: If we want to support export, we probably need to add the\n      // namespace of the template in a TemplateSpecializationType, or even\n      // the classes and namespaces of known non-dependent arguments.\n      if (!BaseType)\n        continue;\n      CXXRecordDecl *BaseDecl = cast<CXXRecordDecl>(BaseType->getDecl());\n      if (Result.addClassTransitive(BaseDecl)) {\n        // Find the associated namespace for this base class.\n        DeclContext *BaseCtx = BaseDecl->getDeclContext();\n        CollectEnclosingNamespace(Result.Namespaces, BaseCtx);\n\n        // Make sure we visit the bases of this base class.\n        if (BaseDecl->bases_begin() != BaseDecl->bases_end())\n          Bases.push_back(BaseDecl);\n      }\n    }\n  }\n}\n\n// Add the associated classes and namespaces for\n// argument-dependent lookup with an argument of type T\n// (C++ [basic.lookup.koenig]p2).\nstatic void\naddAssociatedClassesAndNamespaces(AssociatedLookup &Result, QualType Ty) {\n  // C++ [basic.lookup.koenig]p2:\n  //\n  //   For each argument type T in the function call, there is a set\n  //   of zero or more associated namespaces and a set of zero or more\n  //   associated classes to be considered. The sets of namespaces and\n  //   classes is determined entirely by the types of the function\n  //   arguments (and the namespace of any template template\n  //   argument). Typedef names and using-declarations used to specify\n  //   the types do not contribute to this set. The sets of namespaces\n  //   and classes are determined in the following way:\n\n  SmallVector<const Type *, 16> Queue;\n  const Type *T = Ty->getCanonicalTypeInternal().getTypePtr();\n\n  while (true) {\n    switch (T->getTypeClass()) {\n\n#define TYPE(Class, Base)\n#define DEPENDENT_TYPE(Class, Base) case Type::Class:\n#define NON_CANONICAL_TYPE(Class, Base) case Type::Class:\n#define NON_CANONICAL_UNLESS_DEPENDENT_TYPE(Class, Base) case Type::Class:\n#define ABSTRACT_TYPE(Class, Base)\n#include \"clang/AST/TypeNodes.inc\"\n      // T is canonical.  We can also ignore dependent types because\n      // we don't need to do ADL at the definition point, but if we\n      // wanted to implement template export (or if we find some other\n      // use for associated classes and namespaces...) this would be\n      // wrong.\n      break;\n\n    //    -- If T is a pointer to U or an array of U, its associated\n    //       namespaces and classes are those associated with U.\n    case Type::Pointer:\n      T = cast<PointerType>(T)->getPointeeType().getTypePtr();\n      continue;\n    case Type::ConstantArray:\n    case Type::IncompleteArray:\n    case Type::VariableArray:\n      T = cast<ArrayType>(T)->getElementType().getTypePtr();\n      continue;\n\n    //     -- If T is a fundamental type, its associated sets of\n    //        namespaces and classes are both empty.\n    case Type::Builtin:\n      break;\n\n    //     -- If T is a class type (including unions), its associated\n    //        classes are: the class itself; the class of which it is\n    //        a member, if any; and its direct and indirect base classes.\n    //        Its associated namespaces are the innermost enclosing\n    //        namespaces of its associated classes.\n    case Type::Record: {\n      CXXRecordDecl *Class =\n          cast<CXXRecordDecl>(cast<RecordType>(T)->getDecl());\n      addAssociatedClassesAndNamespaces(Result, Class);\n      break;\n    }\n\n    //     -- If T is an enumeration type, its associated namespace\n    //        is the innermost enclosing namespace of its declaration.\n    //        If it is a class member, its associated class is the\n    //        member\u2019s class; else it has no associated class.\n    case Type::Enum: {\n      EnumDecl *Enum = cast<EnumType>(T)->getDecl();\n\n      DeclContext *Ctx = Enum->getDeclContext();\n      if (CXXRecordDecl *EnclosingClass = dyn_cast<CXXRecordDecl>(Ctx))\n        Result.Classes.insert(EnclosingClass);\n\n      // Add the associated namespace for this enumeration.\n      CollectEnclosingNamespace(Result.Namespaces, Ctx);\n\n      break;\n    }\n\n    //     -- If T is a function type, its associated namespaces and\n    //        classes are those associated with the function parameter\n    //        types and those associated with the return type.\n    case Type::FunctionProto: {\n      const FunctionProtoType *Proto = cast<FunctionProtoType>(T);\n      for (const auto &Arg : Proto->param_types())\n        Queue.push_back(Arg.getTypePtr());\n      // fallthrough\n      LLVM_FALLTHROUGH;\n    }\n    case Type::FunctionNoProto: {\n      const FunctionType *FnType = cast<FunctionType>(T);\n      T = FnType->getReturnType().getTypePtr();\n      continue;\n    }\n\n    //     -- If T is a pointer to a member function of a class X, its\n    //        associated namespaces and classes are those associated\n    //        with the function parameter types and return type,\n    //        together with those associated with X.\n    //\n    //     -- If T is a pointer to a data member of class X, its\n    //        associated namespaces and classes are those associated\n    //        with the member type together with those associated with\n    //        X.\n    case Type::MemberPointer: {\n      const MemberPointerType *MemberPtr = cast<MemberPointerType>(T);\n\n      // Queue up the class type into which this points.\n      Queue.push_back(MemberPtr->getClass());\n\n      // And directly continue with the pointee type.\n      T = MemberPtr->getPointeeType().getTypePtr();\n      continue;\n    }\n\n    // As an extension, treat this like a normal pointer.\n    case Type::BlockPointer:\n      T = cast<BlockPointerType>(T)->getPointeeType().getTypePtr();\n      continue;\n\n    // References aren't covered by the standard, but that's such an\n    // obvious defect that we cover them anyway.\n    case Type::LValueReference:\n    case Type::RValueReference:\n      T = cast<ReferenceType>(T)->getPointeeType().getTypePtr();\n      continue;\n\n    // These are fundamental types.\n    case Type::Vector:\n    case Type::ExtVector:\n    case Type::ConstantMatrix:\n    case Type::Complex:\n    case Type::ExtInt:\n      break;\n\n    // Non-deduced auto types only get here for error cases.\n    case Type::Auto:\n    case Type::DeducedTemplateSpecialization:\n      break;\n\n    // If T is an Objective-C object or interface type, or a pointer to an\n    // object or interface type, the associated namespace is the global\n    // namespace.\n    case Type::ObjCObject:\n    case Type::ObjCInterface:\n    case Type::ObjCObjectPointer:\n      Result.Namespaces.insert(Result.S.Context.getTranslationUnitDecl());\n      break;\n\n    // Atomic types are just wrappers; use the associations of the\n    // contained type.\n    case Type::Atomic:\n      T = cast<AtomicType>(T)->getValueType().getTypePtr();\n      continue;\n    case Type::Pipe:\n      T = cast<PipeType>(T)->getElementType().getTypePtr();\n      continue;\n    }\n\n    if (Queue.empty())\n      break;\n    T = Queue.pop_back_val();\n  }\n}\n\n/// Find the associated classes and namespaces for\n/// argument-dependent lookup for a call with the given set of\n/// arguments.\n///\n/// This routine computes the sets of associated classes and associated\n/// namespaces searched by argument-dependent lookup\n/// (C++ [basic.lookup.argdep]) for a given set of arguments.\nvoid Sema::FindAssociatedClassesAndNamespaces(\n    SourceLocation InstantiationLoc, ArrayRef<Expr *> Args,\n    AssociatedNamespaceSet &AssociatedNamespaces,\n    AssociatedClassSet &AssociatedClasses) {\n  AssociatedNamespaces.clear();\n  AssociatedClasses.clear();\n\n  AssociatedLookup Result(*this, InstantiationLoc,\n                          AssociatedNamespaces, AssociatedClasses);\n\n  // C++ [basic.lookup.koenig]p2:\n  //   For each argument type T in the function call, there is a set\n  //   of zero or more associated namespaces and a set of zero or more\n  //   associated classes to be considered. The sets of namespaces and\n  //   classes is determined entirely by the types of the function\n  //   arguments (and the namespace of any template template\n  //   argument).\n  for (unsigned ArgIdx = 0; ArgIdx != Args.size(); ++ArgIdx) {\n    Expr *Arg = Args[ArgIdx];\n\n    if (Arg->getType() != Context.OverloadTy) {\n      addAssociatedClassesAndNamespaces(Result, Arg->getType());\n      continue;\n    }\n\n    // [...] In addition, if the argument is the name or address of a\n    // set of overloaded functions and/or function templates, its\n    // associated classes and namespaces are the union of those\n    // associated with each of the members of the set: the namespace\n    // in which the function or function template is defined and the\n    // classes and namespaces associated with its (non-dependent)\n    // parameter types and return type.\n    OverloadExpr *OE = OverloadExpr::find(Arg).Expression;\n\n    for (const NamedDecl *D : OE->decls()) {\n      // Look through any using declarations to find the underlying function.\n      const FunctionDecl *FDecl = D->getUnderlyingDecl()->getAsFunction();\n\n      // Add the classes and namespaces associated with the parameter\n      // types and return type of this function.\n      addAssociatedClassesAndNamespaces(Result, FDecl->getType());\n    }\n  }\n}\n\nNamedDecl *Sema::LookupSingleName(Scope *S, DeclarationName Name,\n                                  SourceLocation Loc,\n                                  LookupNameKind NameKind,\n                                  RedeclarationKind Redecl) {\n  LookupResult R(*this, Name, Loc, NameKind, Redecl);\n  LookupName(R, S);\n  return R.getAsSingle<NamedDecl>();\n}\n\n/// Find the protocol with the given name, if any.\nObjCProtocolDecl *Sema::LookupProtocol(IdentifierInfo *II,\n                                       SourceLocation IdLoc,\n                                       RedeclarationKind Redecl) {\n  Decl *D = LookupSingleName(TUScope, II, IdLoc,\n                             LookupObjCProtocolName, Redecl);\n  return cast_or_null<ObjCProtocolDecl>(D);\n}\n\nvoid Sema::LookupOverloadedOperatorName(OverloadedOperatorKind Op, Scope *S,\n                                        UnresolvedSetImpl &Functions) {\n  // C++ [over.match.oper]p3:\n  //     -- The set of non-member candidates is the result of the\n  //        unqualified lookup of operator@ in the context of the\n  //        expression according to the usual rules for name lookup in\n  //        unqualified function calls (3.4.2) except that all member\n  //        functions are ignored.\n  DeclarationName OpName = Context.DeclarationNames.getCXXOperatorName(Op);\n  LookupResult Operators(*this, OpName, SourceLocation(), LookupOperatorName);\n  LookupName(Operators, S);\n\n  assert(!Operators.isAmbiguous() && \"Operator lookup cannot be ambiguous\");\n  Functions.append(Operators.begin(), Operators.end());\n}\n\nSema::SpecialMemberOverloadResult Sema::LookupSpecialMember(CXXRecordDecl *RD,\n                                                           CXXSpecialMember SM,\n                                                           bool ConstArg,\n                                                           bool VolatileArg,\n                                                           bool RValueThis,\n                                                           bool ConstThis,\n                                                           bool VolatileThis) {\n  assert(CanDeclareSpecialMemberFunction(RD) &&\n         \"doing special member lookup into record that isn't fully complete\");\n  RD = RD->getDefinition();\n  if (RValueThis || ConstThis || VolatileThis)\n    assert((SM == CXXCopyAssignment || SM == CXXMoveAssignment) &&\n           \"constructors and destructors always have unqualified lvalue this\");\n  if (ConstArg || VolatileArg)\n    assert((SM != CXXDefaultConstructor && SM != CXXDestructor) &&\n           \"parameter-less special members can't have qualified arguments\");\n\n  // FIXME: Get the caller to pass in a location for the lookup.\n  SourceLocation LookupLoc = RD->getLocation();\n\n  llvm::FoldingSetNodeID ID;\n  ID.AddPointer(RD);\n  ID.AddInteger(SM);\n  ID.AddInteger(ConstArg);\n  ID.AddInteger(VolatileArg);\n  ID.AddInteger(RValueThis);\n  ID.AddInteger(ConstThis);\n  ID.AddInteger(VolatileThis);\n\n  void *InsertPoint;\n  SpecialMemberOverloadResultEntry *Result =\n    SpecialMemberCache.FindNodeOrInsertPos(ID, InsertPoint);\n\n  // This was already cached\n  if (Result)\n    return *Result;\n\n  Result = BumpAlloc.Allocate<SpecialMemberOverloadResultEntry>();\n  Result = new (Result) SpecialMemberOverloadResultEntry(ID);\n  SpecialMemberCache.InsertNode(Result, InsertPoint);\n\n  if (SM == CXXDestructor) {\n    if (RD->needsImplicitDestructor()) {\n      runWithSufficientStackSpace(RD->getLocation(), [&] {\n        DeclareImplicitDestructor(RD);\n      });\n    }\n    CXXDestructorDecl *DD = RD->getDestructor();\n    Result->setMethod(DD);\n    Result->setKind(DD && !DD->isDeleted()\n                        ? SpecialMemberOverloadResult::Success\n                        : SpecialMemberOverloadResult::NoMemberOrDeleted);\n    return *Result;\n  }\n\n  // Prepare for overload resolution. Here we construct a synthetic argument\n  // if necessary and make sure that implicit functions are declared.\n  CanQualType CanTy = Context.getCanonicalType(Context.getTagDeclType(RD));\n  DeclarationName Name;\n  Expr *Arg = nullptr;\n  unsigned NumArgs;\n\n  QualType ArgType = CanTy;\n  ExprValueKind VK = VK_LValue;\n\n  if (SM == CXXDefaultConstructor) {\n    Name = Context.DeclarationNames.getCXXConstructorName(CanTy);\n    NumArgs = 0;\n    if (RD->needsImplicitDefaultConstructor()) {\n      runWithSufficientStackSpace(RD->getLocation(), [&] {\n        DeclareImplicitDefaultConstructor(RD);\n      });\n    }\n  } else {\n    if (SM == CXXCopyConstructor || SM == CXXMoveConstructor) {\n      Name = Context.DeclarationNames.getCXXConstructorName(CanTy);\n      if (RD->needsImplicitCopyConstructor()) {\n        runWithSufficientStackSpace(RD->getLocation(), [&] {\n          DeclareImplicitCopyConstructor(RD);\n        });\n      }\n      if (getLangOpts().CPlusPlus11 && RD->needsImplicitMoveConstructor()) {\n        runWithSufficientStackSpace(RD->getLocation(), [&] {\n          DeclareImplicitMoveConstructor(RD);\n        });\n      }\n    } else {\n      Name = Context.DeclarationNames.getCXXOperatorName(OO_Equal);\n      if (RD->needsImplicitCopyAssignment()) {\n        runWithSufficientStackSpace(RD->getLocation(), [&] {\n          DeclareImplicitCopyAssignment(RD);\n        });\n      }\n      if (getLangOpts().CPlusPlus11 && RD->needsImplicitMoveAssignment()) {\n        runWithSufficientStackSpace(RD->getLocation(), [&] {\n          DeclareImplicitMoveAssignment(RD);\n        });\n      }\n    }\n\n    if (ConstArg)\n      ArgType.addConst();\n    if (VolatileArg)\n      ArgType.addVolatile();\n\n    // This isn't /really/ specified by the standard, but it's implied\n    // we should be working from an RValue in the case of move to ensure\n    // that we prefer to bind to rvalue references, and an LValue in the\n    // case of copy to ensure we don't bind to rvalue references.\n    // Possibly an XValue is actually correct in the case of move, but\n    // there is no semantic difference for class types in this restricted\n    // case.\n    if (SM == CXXCopyConstructor || SM == CXXCopyAssignment)\n      VK = VK_LValue;\n    else\n      VK = VK_RValue;\n  }\n\n  OpaqueValueExpr FakeArg(LookupLoc, ArgType, VK);\n\n  if (SM != CXXDefaultConstructor) {\n    NumArgs = 1;\n    Arg = &FakeArg;\n  }\n\n  // Create the object argument\n  QualType ThisTy = CanTy;\n  if (ConstThis)\n    ThisTy.addConst();\n  if (VolatileThis)\n    ThisTy.addVolatile();\n  Expr::Classification Classification =\n    OpaqueValueExpr(LookupLoc, ThisTy,\n                    RValueThis ? VK_RValue : VK_LValue).Classify(Context);\n\n  // Now we perform lookup on the name we computed earlier and do overload\n  // resolution. Lookup is only performed directly into the class since there\n  // will always be a (possibly implicit) declaration to shadow any others.\n  OverloadCandidateSet OCS(LookupLoc, OverloadCandidateSet::CSK_Normal);\n  DeclContext::lookup_result R = RD->lookup(Name);\n\n  if (R.empty()) {\n    // We might have no default constructor because we have a lambda's closure\n    // type, rather than because there's some other declared constructor.\n    // Every class has a copy/move constructor, copy/move assignment, and\n    // destructor.\n    assert(SM == CXXDefaultConstructor &&\n           \"lookup for a constructor or assignment operator was empty\");\n    Result->setMethod(nullptr);\n    Result->setKind(SpecialMemberOverloadResult::NoMemberOrDeleted);\n    return *Result;\n  }\n\n  // Copy the candidates as our processing of them may load new declarations\n  // from an external source and invalidate lookup_result.\n  SmallVector<NamedDecl *, 8> Candidates(R.begin(), R.end());\n\n  for (NamedDecl *CandDecl : Candidates) {\n    if (CandDecl->isInvalidDecl())\n      continue;\n\n    DeclAccessPair Cand = DeclAccessPair::make(CandDecl, AS_public);\n    auto CtorInfo = getConstructorInfo(Cand);\n    if (CXXMethodDecl *M = dyn_cast<CXXMethodDecl>(Cand->getUnderlyingDecl())) {\n      if (SM == CXXCopyAssignment || SM == CXXMoveAssignment)\n        AddMethodCandidate(M, Cand, RD, ThisTy, Classification,\n                           llvm::makeArrayRef(&Arg, NumArgs), OCS, true);\n      else if (CtorInfo)\n        AddOverloadCandidate(CtorInfo.Constructor, CtorInfo.FoundDecl,\n                             llvm::makeArrayRef(&Arg, NumArgs), OCS,\n                             /*SuppressUserConversions*/ true);\n      else\n        AddOverloadCandidate(M, Cand, llvm::makeArrayRef(&Arg, NumArgs), OCS,\n                             /*SuppressUserConversions*/ true);\n    } else if (FunctionTemplateDecl *Tmpl =\n                 dyn_cast<FunctionTemplateDecl>(Cand->getUnderlyingDecl())) {\n      if (SM == CXXCopyAssignment || SM == CXXMoveAssignment)\n        AddMethodTemplateCandidate(\n            Tmpl, Cand, RD, nullptr, ThisTy, Classification,\n            llvm::makeArrayRef(&Arg, NumArgs), OCS, true);\n      else if (CtorInfo)\n        AddTemplateOverloadCandidate(\n            CtorInfo.ConstructorTmpl, CtorInfo.FoundDecl, nullptr,\n            llvm::makeArrayRef(&Arg, NumArgs), OCS, true);\n      else\n        AddTemplateOverloadCandidate(\n            Tmpl, Cand, nullptr, llvm::makeArrayRef(&Arg, NumArgs), OCS, true);\n    } else {\n      assert(isa<UsingDecl>(Cand.getDecl()) &&\n             \"illegal Kind of operator = Decl\");\n    }\n  }\n\n  OverloadCandidateSet::iterator Best;\n  switch (OCS.BestViableFunction(*this, LookupLoc, Best)) {\n    case OR_Success:\n      Result->setMethod(cast<CXXMethodDecl>(Best->Function));\n      Result->setKind(SpecialMemberOverloadResult::Success);\n      break;\n\n    case OR_Deleted:\n      Result->setMethod(cast<CXXMethodDecl>(Best->Function));\n      Result->setKind(SpecialMemberOverloadResult::NoMemberOrDeleted);\n      break;\n\n    case OR_Ambiguous:\n      Result->setMethod(nullptr);\n      Result->setKind(SpecialMemberOverloadResult::Ambiguous);\n      break;\n\n    case OR_No_Viable_Function:\n      Result->setMethod(nullptr);\n      Result->setKind(SpecialMemberOverloadResult::NoMemberOrDeleted);\n      break;\n  }\n\n  return *Result;\n}\n\n/// Look up the default constructor for the given class.\nCXXConstructorDecl *Sema::LookupDefaultConstructor(CXXRecordDecl *Class) {\n  SpecialMemberOverloadResult Result =\n    LookupSpecialMember(Class, CXXDefaultConstructor, false, false, false,\n                        false, false);\n\n  return cast_or_null<CXXConstructorDecl>(Result.getMethod());\n}\n\n/// Look up the copying constructor for the given class.\nCXXConstructorDecl *Sema::LookupCopyingConstructor(CXXRecordDecl *Class,\n                                                   unsigned Quals) {\n  assert(!(Quals & ~(Qualifiers::Const | Qualifiers::Volatile)) &&\n         \"non-const, non-volatile qualifiers for copy ctor arg\");\n  SpecialMemberOverloadResult Result =\n    LookupSpecialMember(Class, CXXCopyConstructor, Quals & Qualifiers::Const,\n                        Quals & Qualifiers::Volatile, false, false, false);\n\n  return cast_or_null<CXXConstructorDecl>(Result.getMethod());\n}\n\n/// Look up the moving constructor for the given class.\nCXXConstructorDecl *Sema::LookupMovingConstructor(CXXRecordDecl *Class,\n                                                  unsigned Quals) {\n  SpecialMemberOverloadResult Result =\n    LookupSpecialMember(Class, CXXMoveConstructor, Quals & Qualifiers::Const,\n                        Quals & Qualifiers::Volatile, false, false, false);\n\n  return cast_or_null<CXXConstructorDecl>(Result.getMethod());\n}\n\n/// Look up the constructors for the given class.\nDeclContext::lookup_result Sema::LookupConstructors(CXXRecordDecl *Class) {\n  // If the implicit constructors have not yet been declared, do so now.\n  if (CanDeclareSpecialMemberFunction(Class)) {\n    runWithSufficientStackSpace(Class->getLocation(), [&] {\n      if (Class->needsImplicitDefaultConstructor())\n        DeclareImplicitDefaultConstructor(Class);\n      if (Class->needsImplicitCopyConstructor())\n        DeclareImplicitCopyConstructor(Class);\n      if (getLangOpts().CPlusPlus11 && Class->needsImplicitMoveConstructor())\n        DeclareImplicitMoveConstructor(Class);\n    });\n  }\n\n  CanQualType T = Context.getCanonicalType(Context.getTypeDeclType(Class));\n  DeclarationName Name = Context.DeclarationNames.getCXXConstructorName(T);\n  return Class->lookup(Name);\n}\n\n/// Look up the copying assignment operator for the given class.\nCXXMethodDecl *Sema::LookupCopyingAssignment(CXXRecordDecl *Class,\n                                             unsigned Quals, bool RValueThis,\n                                             unsigned ThisQuals) {\n  assert(!(Quals & ~(Qualifiers::Const | Qualifiers::Volatile)) &&\n         \"non-const, non-volatile qualifiers for copy assignment arg\");\n  assert(!(ThisQuals & ~(Qualifiers::Const | Qualifiers::Volatile)) &&\n         \"non-const, non-volatile qualifiers for copy assignment this\");\n  SpecialMemberOverloadResult Result =\n    LookupSpecialMember(Class, CXXCopyAssignment, Quals & Qualifiers::Const,\n                        Quals & Qualifiers::Volatile, RValueThis,\n                        ThisQuals & Qualifiers::Const,\n                        ThisQuals & Qualifiers::Volatile);\n\n  return Result.getMethod();\n}\n\n/// Look up the moving assignment operator for the given class.\nCXXMethodDecl *Sema::LookupMovingAssignment(CXXRecordDecl *Class,\n                                            unsigned Quals,\n                                            bool RValueThis,\n                                            unsigned ThisQuals) {\n  assert(!(ThisQuals & ~(Qualifiers::Const | Qualifiers::Volatile)) &&\n         \"non-const, non-volatile qualifiers for copy assignment this\");\n  SpecialMemberOverloadResult Result =\n    LookupSpecialMember(Class, CXXMoveAssignment, Quals & Qualifiers::Const,\n                        Quals & Qualifiers::Volatile, RValueThis,\n                        ThisQuals & Qualifiers::Const,\n                        ThisQuals & Qualifiers::Volatile);\n\n  return Result.getMethod();\n}\n\n/// Look for the destructor of the given class.\n///\n/// During semantic analysis, this routine should be used in lieu of\n/// CXXRecordDecl::getDestructor().\n///\n/// \\returns The destructor for this class.\nCXXDestructorDecl *Sema::LookupDestructor(CXXRecordDecl *Class) {\n  return cast<CXXDestructorDecl>(LookupSpecialMember(Class, CXXDestructor,\n                                                     false, false, false,\n                                                     false, false).getMethod());\n}\n\n/// LookupLiteralOperator - Determine which literal operator should be used for\n/// a user-defined literal, per C++11 [lex.ext].\n///\n/// Normal overload resolution is not used to select which literal operator to\n/// call for a user-defined literal. Look up the provided literal operator name,\n/// and filter the results to the appropriate set for the given argument types.\nSema::LiteralOperatorLookupResult\nSema::LookupLiteralOperator(Scope *S, LookupResult &R,\n                            ArrayRef<QualType> ArgTys, bool AllowRaw,\n                            bool AllowTemplate, bool AllowStringTemplatePack,\n                            bool DiagnoseMissing, StringLiteral *StringLit) {\n  LookupName(R, S);\n  assert(R.getResultKind() != LookupResult::Ambiguous &&\n         \"literal operator lookup can't be ambiguous\");\n\n  // Filter the lookup results appropriately.\n  LookupResult::Filter F = R.makeFilter();\n\n  bool AllowCooked = true;\n  bool FoundRaw = false;\n  bool FoundTemplate = false;\n  bool FoundStringTemplatePack = false;\n  bool FoundCooked = false;\n\n  while (F.hasNext()) {\n    Decl *D = F.next();\n    if (UsingShadowDecl *USD = dyn_cast<UsingShadowDecl>(D))\n      D = USD->getTargetDecl();\n\n    // If the declaration we found is invalid, skip it.\n    if (D->isInvalidDecl()) {\n      F.erase();\n      continue;\n    }\n\n    bool IsRaw = false;\n    bool IsTemplate = false;\n    bool IsStringTemplatePack = false;\n    bool IsCooked = false;\n\n    if (FunctionDecl *FD = dyn_cast<FunctionDecl>(D)) {\n      if (FD->getNumParams() == 1 &&\n          FD->getParamDecl(0)->getType()->getAs<PointerType>())\n        IsRaw = true;\n      else if (FD->getNumParams() == ArgTys.size()) {\n        IsCooked = true;\n        for (unsigned ArgIdx = 0; ArgIdx != ArgTys.size(); ++ArgIdx) {\n          QualType ParamTy = FD->getParamDecl(ArgIdx)->getType();\n          if (!Context.hasSameUnqualifiedType(ArgTys[ArgIdx], ParamTy)) {\n            IsCooked = false;\n            break;\n          }\n        }\n      }\n    }\n    if (FunctionTemplateDecl *FD = dyn_cast<FunctionTemplateDecl>(D)) {\n      TemplateParameterList *Params = FD->getTemplateParameters();\n      if (Params->size() == 1) {\n        IsTemplate = true;\n        if (!Params->getParam(0)->isTemplateParameterPack() && !StringLit) {\n          // Implied but not stated: user-defined integer and floating literals\n          // only ever use numeric literal operator templates, not templates\n          // taking a parameter of class type.\n          F.erase();\n          continue;\n        }\n\n        // A string literal template is only considered if the string literal\n        // is a well-formed template argument for the template parameter.\n        if (StringLit) {\n          SFINAETrap Trap(*this);\n          SmallVector<TemplateArgument, 1> Checked;\n          TemplateArgumentLoc Arg(TemplateArgument(StringLit), StringLit);\n          if (CheckTemplateArgument(Params->getParam(0), Arg, FD,\n                                    R.getNameLoc(), R.getNameLoc(), 0,\n                                    Checked) ||\n              Trap.hasErrorOccurred())\n            IsTemplate = false;\n        }\n      } else {\n        IsStringTemplatePack = true;\n      }\n    }\n\n    if (AllowTemplate && StringLit && IsTemplate) {\n      FoundTemplate = true;\n      AllowRaw = false;\n      AllowCooked = false;\n      AllowStringTemplatePack = false;\n      if (FoundRaw || FoundCooked || FoundStringTemplatePack) {\n        F.restart();\n        FoundRaw = FoundCooked = FoundStringTemplatePack = false;\n      }\n    } else if (AllowCooked && IsCooked) {\n      FoundCooked = true;\n      AllowRaw = false;\n      AllowTemplate = StringLit;\n      AllowStringTemplatePack = false;\n      if (FoundRaw || FoundTemplate || FoundStringTemplatePack) {\n        // Go through again and remove the raw and template decls we've\n        // already found.\n        F.restart();\n        FoundRaw = FoundTemplate = FoundStringTemplatePack = false;\n      }\n    } else if (AllowRaw && IsRaw) {\n      FoundRaw = true;\n    } else if (AllowTemplate && IsTemplate) {\n      FoundTemplate = true;\n    } else if (AllowStringTemplatePack && IsStringTemplatePack) {\n      FoundStringTemplatePack = true;\n    } else {\n      F.erase();\n    }\n  }\n\n  F.done();\n\n  // Per C++20 [lex.ext]p5, we prefer the template form over the non-template\n  // form for string literal operator templates.\n  if (StringLit && FoundTemplate)\n    return LOLR_Template;\n\n  // C++11 [lex.ext]p3, p4: If S contains a literal operator with a matching\n  // parameter type, that is used in preference to a raw literal operator\n  // or literal operator template.\n  if (FoundCooked)\n    return LOLR_Cooked;\n\n  // C++11 [lex.ext]p3, p4: S shall contain a raw literal operator or a literal\n  // operator template, but not both.\n  if (FoundRaw && FoundTemplate) {\n    Diag(R.getNameLoc(), diag::err_ovl_ambiguous_call) << R.getLookupName();\n    for (LookupResult::iterator I = R.begin(), E = R.end(); I != E; ++I)\n      NoteOverloadCandidate(*I, (*I)->getUnderlyingDecl()->getAsFunction());\n    return LOLR_Error;\n  }\n\n  if (FoundRaw)\n    return LOLR_Raw;\n\n  if (FoundTemplate)\n    return LOLR_Template;\n\n  if (FoundStringTemplatePack)\n    return LOLR_StringTemplatePack;\n\n  // Didn't find anything we could use.\n  if (DiagnoseMissing) {\n    Diag(R.getNameLoc(), diag::err_ovl_no_viable_literal_operator)\n        << R.getLookupName() << (int)ArgTys.size() << ArgTys[0]\n        << (ArgTys.size() == 2 ? ArgTys[1] : QualType()) << AllowRaw\n        << (AllowTemplate || AllowStringTemplatePack);\n    return LOLR_Error;\n  }\n\n  return LOLR_ErrorNoDiagnostic;\n}\n\nvoid ADLResult::insert(NamedDecl *New) {\n  NamedDecl *&Old = Decls[cast<NamedDecl>(New->getCanonicalDecl())];\n\n  // If we haven't yet seen a decl for this key, or the last decl\n  // was exactly this one, we're done.\n  if (Old == nullptr || Old == New) {\n    Old = New;\n    return;\n  }\n\n  // Otherwise, decide which is a more recent redeclaration.\n  FunctionDecl *OldFD = Old->getAsFunction();\n  FunctionDecl *NewFD = New->getAsFunction();\n\n  FunctionDecl *Cursor = NewFD;\n  while (true) {\n    Cursor = Cursor->getPreviousDecl();\n\n    // If we got to the end without finding OldFD, OldFD is the newer\n    // declaration;  leave things as they are.\n    if (!Cursor) return;\n\n    // If we do find OldFD, then NewFD is newer.\n    if (Cursor == OldFD) break;\n\n    // Otherwise, keep looking.\n  }\n\n  Old = New;\n}\n\nvoid Sema::ArgumentDependentLookup(DeclarationName Name, SourceLocation Loc,\n                                   ArrayRef<Expr *> Args, ADLResult &Result) {\n  // Find all of the associated namespaces and classes based on the\n  // arguments we have.\n  AssociatedNamespaceSet AssociatedNamespaces;\n  AssociatedClassSet AssociatedClasses;\n  FindAssociatedClassesAndNamespaces(Loc, Args,\n                                     AssociatedNamespaces,\n                                     AssociatedClasses);\n\n  // C++ [basic.lookup.argdep]p3:\n  //   Let X be the lookup set produced by unqualified lookup (3.4.1)\n  //   and let Y be the lookup set produced by argument dependent\n  //   lookup (defined as follows). If X contains [...] then Y is\n  //   empty. Otherwise Y is the set of declarations found in the\n  //   namespaces associated with the argument types as described\n  //   below. The set of declarations found by the lookup of the name\n  //   is the union of X and Y.\n  //\n  // Here, we compute Y and add its members to the overloaded\n  // candidate set.\n  for (auto *NS : AssociatedNamespaces) {\n    //   When considering an associated namespace, the lookup is the\n    //   same as the lookup performed when the associated namespace is\n    //   used as a qualifier (3.4.3.2) except that:\n    //\n    //     -- Any using-directives in the associated namespace are\n    //        ignored.\n    //\n    //     -- Any namespace-scope friend functions declared in\n    //        associated classes are visible within their respective\n    //        namespaces even if they are not visible during an ordinary\n    //        lookup (11.4).\n    DeclContext::lookup_result R = NS->lookup(Name);\n    for (auto *D : R) {\n      auto *Underlying = D;\n      if (auto *USD = dyn_cast<UsingShadowDecl>(D))\n        Underlying = USD->getTargetDecl();\n\n      if (!isa<FunctionDecl>(Underlying) &&\n          !isa<FunctionTemplateDecl>(Underlying))\n        continue;\n\n      // The declaration is visible to argument-dependent lookup if either\n      // it's ordinarily visible or declared as a friend in an associated\n      // class.\n      bool Visible = false;\n      for (D = D->getMostRecentDecl(); D;\n           D = cast_or_null<NamedDecl>(D->getPreviousDecl())) {\n        if (D->getIdentifierNamespace() & Decl::IDNS_Ordinary) {\n          if (isVisible(D)) {\n            Visible = true;\n            break;\n          }\n        } else if (D->getFriendObjectKind()) {\n          auto *RD = cast<CXXRecordDecl>(D->getLexicalDeclContext());\n          if (AssociatedClasses.count(RD) && isVisible(D)) {\n            Visible = true;\n            break;\n          }\n        }\n      }\n\n      // FIXME: Preserve D as the FoundDecl.\n      if (Visible)\n        Result.insert(Underlying);\n    }\n  }\n}\n\n//----------------------------------------------------------------------------\n// Search for all visible declarations.\n//----------------------------------------------------------------------------\nVisibleDeclConsumer::~VisibleDeclConsumer() { }\n\nbool VisibleDeclConsumer::includeHiddenDecls() const { return false; }\n\nnamespace {\n\nclass ShadowContextRAII;\n\nclass VisibleDeclsRecord {\npublic:\n  /// An entry in the shadow map, which is optimized to store a\n  /// single declaration (the common case) but can also store a list\n  /// of declarations.\n  typedef llvm::TinyPtrVector<NamedDecl*> ShadowMapEntry;\n\nprivate:\n  /// A mapping from declaration names to the declarations that have\n  /// this name within a particular scope.\n  typedef llvm::DenseMap<DeclarationName, ShadowMapEntry> ShadowMap;\n\n  /// A list of shadow maps, which is used to model name hiding.\n  std::list<ShadowMap> ShadowMaps;\n\n  /// The declaration contexts we have already visited.\n  llvm::SmallPtrSet<DeclContext *, 8> VisitedContexts;\n\n  friend class ShadowContextRAII;\n\npublic:\n  /// Determine whether we have already visited this context\n  /// (and, if not, note that we are going to visit that context now).\n  bool visitedContext(DeclContext *Ctx) {\n    return !VisitedContexts.insert(Ctx).second;\n  }\n\n  bool alreadyVisitedContext(DeclContext *Ctx) {\n    return VisitedContexts.count(Ctx);\n  }\n\n  /// Determine whether the given declaration is hidden in the\n  /// current scope.\n  ///\n  /// \\returns the declaration that hides the given declaration, or\n  /// NULL if no such declaration exists.\n  NamedDecl *checkHidden(NamedDecl *ND);\n\n  /// Add a declaration to the current shadow map.\n  void add(NamedDecl *ND) {\n    ShadowMaps.back()[ND->getDeclName()].push_back(ND);\n  }\n};\n\n/// RAII object that records when we've entered a shadow context.\nclass ShadowContextRAII {\n  VisibleDeclsRecord &Visible;\n\n  typedef VisibleDeclsRecord::ShadowMap ShadowMap;\n\npublic:\n  ShadowContextRAII(VisibleDeclsRecord &Visible) : Visible(Visible) {\n    Visible.ShadowMaps.emplace_back();\n  }\n\n  ~ShadowContextRAII() {\n    Visible.ShadowMaps.pop_back();\n  }\n};\n\n} // end anonymous namespace\n\nNamedDecl *VisibleDeclsRecord::checkHidden(NamedDecl *ND) {\n  unsigned IDNS = ND->getIdentifierNamespace();\n  std::list<ShadowMap>::reverse_iterator SM = ShadowMaps.rbegin();\n  for (std::list<ShadowMap>::reverse_iterator SMEnd = ShadowMaps.rend();\n       SM != SMEnd; ++SM) {\n    ShadowMap::iterator Pos = SM->find(ND->getDeclName());\n    if (Pos == SM->end())\n      continue;\n\n    for (auto *D : Pos->second) {\n      // A tag declaration does not hide a non-tag declaration.\n      if (D->hasTagIdentifierNamespace() &&\n          (IDNS & (Decl::IDNS_Member | Decl::IDNS_Ordinary |\n                   Decl::IDNS_ObjCProtocol)))\n        continue;\n\n      // Protocols are in distinct namespaces from everything else.\n      if (((D->getIdentifierNamespace() & Decl::IDNS_ObjCProtocol)\n           || (IDNS & Decl::IDNS_ObjCProtocol)) &&\n          D->getIdentifierNamespace() != IDNS)\n        continue;\n\n      // Functions and function templates in the same scope overload\n      // rather than hide.  FIXME: Look for hiding based on function\n      // signatures!\n      if (D->getUnderlyingDecl()->isFunctionOrFunctionTemplate() &&\n          ND->getUnderlyingDecl()->isFunctionOrFunctionTemplate() &&\n          SM == ShadowMaps.rbegin())\n        continue;\n\n      // A shadow declaration that's created by a resolved using declaration\n      // is not hidden by the same using declaration.\n      if (isa<UsingShadowDecl>(ND) && isa<UsingDecl>(D) &&\n          cast<UsingShadowDecl>(ND)->getUsingDecl() == D)\n        continue;\n\n      // We've found a declaration that hides this one.\n      return D;\n    }\n  }\n\n  return nullptr;\n}\n\nnamespace {\nclass LookupVisibleHelper {\npublic:\n  LookupVisibleHelper(VisibleDeclConsumer &Consumer, bool IncludeDependentBases,\n                      bool LoadExternal)\n      : Consumer(Consumer), IncludeDependentBases(IncludeDependentBases),\n        LoadExternal(LoadExternal) {}\n\n  void lookupVisibleDecls(Sema &SemaRef, Scope *S, Sema::LookupNameKind Kind,\n                          bool IncludeGlobalScope) {\n    // Determine the set of using directives available during\n    // unqualified name lookup.\n    Scope *Initial = S;\n    UnqualUsingDirectiveSet UDirs(SemaRef);\n    if (SemaRef.getLangOpts().CPlusPlus) {\n      // Find the first namespace or translation-unit scope.\n      while (S && !isNamespaceOrTranslationUnitScope(S))\n        S = S->getParent();\n\n      UDirs.visitScopeChain(Initial, S);\n    }\n    UDirs.done();\n\n    // Look for visible declarations.\n    LookupResult Result(SemaRef, DeclarationName(), SourceLocation(), Kind);\n    Result.setAllowHidden(Consumer.includeHiddenDecls());\n    if (!IncludeGlobalScope)\n      Visited.visitedContext(SemaRef.getASTContext().getTranslationUnitDecl());\n    ShadowContextRAII Shadow(Visited);\n    lookupInScope(Initial, Result, UDirs);\n  }\n\n  void lookupVisibleDecls(Sema &SemaRef, DeclContext *Ctx,\n                          Sema::LookupNameKind Kind, bool IncludeGlobalScope) {\n    LookupResult Result(SemaRef, DeclarationName(), SourceLocation(), Kind);\n    Result.setAllowHidden(Consumer.includeHiddenDecls());\n    if (!IncludeGlobalScope)\n      Visited.visitedContext(SemaRef.getASTContext().getTranslationUnitDecl());\n\n    ShadowContextRAII Shadow(Visited);\n    lookupInDeclContext(Ctx, Result, /*QualifiedNameLookup=*/true,\n                        /*InBaseClass=*/false);\n  }\n\nprivate:\n  void lookupInDeclContext(DeclContext *Ctx, LookupResult &Result,\n                           bool QualifiedNameLookup, bool InBaseClass) {\n    if (!Ctx)\n      return;\n\n    // Make sure we don't visit the same context twice.\n    if (Visited.visitedContext(Ctx->getPrimaryContext()))\n      return;\n\n    Consumer.EnteredContext(Ctx);\n\n    // Outside C++, lookup results for the TU live on identifiers.\n    if (isa<TranslationUnitDecl>(Ctx) &&\n        !Result.getSema().getLangOpts().CPlusPlus) {\n      auto &S = Result.getSema();\n      auto &Idents = S.Context.Idents;\n\n      // Ensure all external identifiers are in the identifier table.\n      if (LoadExternal)\n        if (IdentifierInfoLookup *External =\n                Idents.getExternalIdentifierLookup()) {\n          std::unique_ptr<IdentifierIterator> Iter(External->getIdentifiers());\n          for (StringRef Name = Iter->Next(); !Name.empty();\n               Name = Iter->Next())\n            Idents.get(Name);\n        }\n\n      // Walk all lookup results in the TU for each identifier.\n      for (const auto &Ident : Idents) {\n        for (auto I = S.IdResolver.begin(Ident.getValue()),\n                  E = S.IdResolver.end();\n             I != E; ++I) {\n          if (S.IdResolver.isDeclInScope(*I, Ctx)) {\n            if (NamedDecl *ND = Result.getAcceptableDecl(*I)) {\n              Consumer.FoundDecl(ND, Visited.checkHidden(ND), Ctx, InBaseClass);\n              Visited.add(ND);\n            }\n          }\n        }\n      }\n\n      return;\n    }\n\n    if (CXXRecordDecl *Class = dyn_cast<CXXRecordDecl>(Ctx))\n      Result.getSema().ForceDeclarationOfImplicitMembers(Class);\n\n    // We sometimes skip loading namespace-level results (they tend to be huge).\n    bool Load = LoadExternal ||\n                !(isa<TranslationUnitDecl>(Ctx) || isa<NamespaceDecl>(Ctx));\n    // Enumerate all of the results in this context.\n    for (DeclContextLookupResult R :\n         Load ? Ctx->lookups()\n              : Ctx->noload_lookups(/*PreserveInternalState=*/false)) {\n      for (auto *D : R) {\n        if (auto *ND = Result.getAcceptableDecl(D)) {\n          Consumer.FoundDecl(ND, Visited.checkHidden(ND), Ctx, InBaseClass);\n          Visited.add(ND);\n        }\n      }\n    }\n\n    // Traverse using directives for qualified name lookup.\n    if (QualifiedNameLookup) {\n      ShadowContextRAII Shadow(Visited);\n      for (auto I : Ctx->using_directives()) {\n        if (!Result.getSema().isVisible(I))\n          continue;\n        lookupInDeclContext(I->getNominatedNamespace(), Result,\n                            QualifiedNameLookup, InBaseClass);\n      }\n    }\n\n    // Traverse the contexts of inherited C++ classes.\n    if (CXXRecordDecl *Record = dyn_cast<CXXRecordDecl>(Ctx)) {\n      if (!Record->hasDefinition())\n        return;\n\n      for (const auto &B : Record->bases()) {\n        QualType BaseType = B.getType();\n\n        RecordDecl *RD;\n        if (BaseType->isDependentType()) {\n          if (!IncludeDependentBases) {\n            // Don't look into dependent bases, because name lookup can't look\n            // there anyway.\n            continue;\n          }\n          const auto *TST = BaseType->getAs<TemplateSpecializationType>();\n          if (!TST)\n            continue;\n          TemplateName TN = TST->getTemplateName();\n          const auto *TD =\n              dyn_cast_or_null<ClassTemplateDecl>(TN.getAsTemplateDecl());\n          if (!TD)\n            continue;\n          RD = TD->getTemplatedDecl();\n        } else {\n          const auto *Record = BaseType->getAs<RecordType>();\n          if (!Record)\n            continue;\n          RD = Record->getDecl();\n        }\n\n        // FIXME: It would be nice to be able to determine whether referencing\n        // a particular member would be ambiguous. For example, given\n        //\n        //   struct A { int member; };\n        //   struct B { int member; };\n        //   struct C : A, B { };\n        //\n        //   void f(C *c) { c->### }\n        //\n        // accessing 'member' would result in an ambiguity. However, we\n        // could be smart enough to qualify the member with the base\n        // class, e.g.,\n        //\n        //   c->B::member\n        //\n        // or\n        //\n        //   c->A::member\n\n        // Find results in this base class (and its bases).\n        ShadowContextRAII Shadow(Visited);\n        lookupInDeclContext(RD, Result, QualifiedNameLookup,\n                            /*InBaseClass=*/true);\n      }\n    }\n\n    // Traverse the contexts of Objective-C classes.\n    if (ObjCInterfaceDecl *IFace = dyn_cast<ObjCInterfaceDecl>(Ctx)) {\n      // Traverse categories.\n      for (auto *Cat : IFace->visible_categories()) {\n        ShadowContextRAII Shadow(Visited);\n        lookupInDeclContext(Cat, Result, QualifiedNameLookup,\n                            /*InBaseClass=*/false);\n      }\n\n      // Traverse protocols.\n      for (auto *I : IFace->all_referenced_protocols()) {\n        ShadowContextRAII Shadow(Visited);\n        lookupInDeclContext(I, Result, QualifiedNameLookup,\n                            /*InBaseClass=*/false);\n      }\n\n      // Traverse the superclass.\n      if (IFace->getSuperClass()) {\n        ShadowContextRAII Shadow(Visited);\n        lookupInDeclContext(IFace->getSuperClass(), Result, QualifiedNameLookup,\n                            /*InBaseClass=*/true);\n      }\n\n      // If there is an implementation, traverse it. We do this to find\n      // synthesized ivars.\n      if (IFace->getImplementation()) {\n        ShadowContextRAII Shadow(Visited);\n        lookupInDeclContext(IFace->getImplementation(), Result,\n                            QualifiedNameLookup, InBaseClass);\n      }\n    } else if (ObjCProtocolDecl *Protocol = dyn_cast<ObjCProtocolDecl>(Ctx)) {\n      for (auto *I : Protocol->protocols()) {\n        ShadowContextRAII Shadow(Visited);\n        lookupInDeclContext(I, Result, QualifiedNameLookup,\n                            /*InBaseClass=*/false);\n      }\n    } else if (ObjCCategoryDecl *Category = dyn_cast<ObjCCategoryDecl>(Ctx)) {\n      for (auto *I : Category->protocols()) {\n        ShadowContextRAII Shadow(Visited);\n        lookupInDeclContext(I, Result, QualifiedNameLookup,\n                            /*InBaseClass=*/false);\n      }\n\n      // If there is an implementation, traverse it.\n      if (Category->getImplementation()) {\n        ShadowContextRAII Shadow(Visited);\n        lookupInDeclContext(Category->getImplementation(), Result,\n                            QualifiedNameLookup, /*InBaseClass=*/true);\n      }\n    }\n  }\n\n  void lookupInScope(Scope *S, LookupResult &Result,\n                     UnqualUsingDirectiveSet &UDirs) {\n    // No clients run in this mode and it's not supported. Please add tests and\n    // remove the assertion if you start relying on it.\n    assert(!IncludeDependentBases && \"Unsupported flag for lookupInScope\");\n\n    if (!S)\n      return;\n\n    if (!S->getEntity() ||\n        (!S->getParent() && !Visited.alreadyVisitedContext(S->getEntity())) ||\n        (S->getEntity())->isFunctionOrMethod()) {\n      FindLocalExternScope FindLocals(Result);\n      // Walk through the declarations in this Scope. The consumer might add new\n      // decls to the scope as part of deserialization, so make a copy first.\n      SmallVector<Decl *, 8> ScopeDecls(S->decls().begin(), S->decls().end());\n      for (Decl *D : ScopeDecls) {\n        if (NamedDecl *ND = dyn_cast<NamedDecl>(D))\n          if ((ND = Result.getAcceptableDecl(ND))) {\n            Consumer.FoundDecl(ND, Visited.checkHidden(ND), nullptr, false);\n            Visited.add(ND);\n          }\n      }\n    }\n\n    DeclContext *Entity = S->getLookupEntity();\n    if (Entity) {\n      // Look into this scope's declaration context, along with any of its\n      // parent lookup contexts (e.g., enclosing classes), up to the point\n      // where we hit the context stored in the next outer scope.\n      DeclContext *OuterCtx = findOuterContext(S);\n\n      for (DeclContext *Ctx = Entity; Ctx && !Ctx->Equals(OuterCtx);\n           Ctx = Ctx->getLookupParent()) {\n        if (ObjCMethodDecl *Method = dyn_cast<ObjCMethodDecl>(Ctx)) {\n          if (Method->isInstanceMethod()) {\n            // For instance methods, look for ivars in the method's interface.\n            LookupResult IvarResult(Result.getSema(), Result.getLookupName(),\n                                    Result.getNameLoc(),\n                                    Sema::LookupMemberName);\n            if (ObjCInterfaceDecl *IFace = Method->getClassInterface()) {\n              lookupInDeclContext(IFace, IvarResult,\n                                  /*QualifiedNameLookup=*/false,\n                                  /*InBaseClass=*/false);\n            }\n          }\n\n          // We've already performed all of the name lookup that we need\n          // to for Objective-C methods; the next context will be the\n          // outer scope.\n          break;\n        }\n\n        if (Ctx->isFunctionOrMethod())\n          continue;\n\n        lookupInDeclContext(Ctx, Result, /*QualifiedNameLookup=*/false,\n                            /*InBaseClass=*/false);\n      }\n    } else if (!S->getParent()) {\n      // Look into the translation unit scope. We walk through the translation\n      // unit's declaration context, because the Scope itself won't have all of\n      // the declarations if we loaded a precompiled header.\n      // FIXME: We would like the translation unit's Scope object to point to\n      // the translation unit, so we don't need this special \"if\" branch.\n      // However, doing so would force the normal C++ name-lookup code to look\n      // into the translation unit decl when the IdentifierInfo chains would\n      // suffice. Once we fix that problem (which is part of a more general\n      // \"don't look in DeclContexts unless we have to\" optimization), we can\n      // eliminate this.\n      Entity = Result.getSema().Context.getTranslationUnitDecl();\n      lookupInDeclContext(Entity, Result, /*QualifiedNameLookup=*/false,\n                          /*InBaseClass=*/false);\n    }\n\n    if (Entity) {\n      // Lookup visible declarations in any namespaces found by using\n      // directives.\n      for (const UnqualUsingEntry &UUE : UDirs.getNamespacesFor(Entity))\n        lookupInDeclContext(\n            const_cast<DeclContext *>(UUE.getNominatedNamespace()), Result,\n            /*QualifiedNameLookup=*/false,\n            /*InBaseClass=*/false);\n    }\n\n    // Lookup names in the parent scope.\n    ShadowContextRAII Shadow(Visited);\n    lookupInScope(S->getParent(), Result, UDirs);\n  }\n\nprivate:\n  VisibleDeclsRecord Visited;\n  VisibleDeclConsumer &Consumer;\n  bool IncludeDependentBases;\n  bool LoadExternal;\n};\n} // namespace\n\nvoid Sema::LookupVisibleDecls(Scope *S, LookupNameKind Kind,\n                              VisibleDeclConsumer &Consumer,\n                              bool IncludeGlobalScope, bool LoadExternal) {\n  LookupVisibleHelper H(Consumer, /*IncludeDependentBases=*/false,\n                        LoadExternal);\n  H.lookupVisibleDecls(*this, S, Kind, IncludeGlobalScope);\n}\n\nvoid Sema::LookupVisibleDecls(DeclContext *Ctx, LookupNameKind Kind,\n                              VisibleDeclConsumer &Consumer,\n                              bool IncludeGlobalScope,\n                              bool IncludeDependentBases, bool LoadExternal) {\n  LookupVisibleHelper H(Consumer, IncludeDependentBases, LoadExternal);\n  H.lookupVisibleDecls(*this, Ctx, Kind, IncludeGlobalScope);\n}\n\n/// LookupOrCreateLabel - Do a name lookup of a label with the specified name.\n/// If GnuLabelLoc is a valid source location, then this is a definition\n/// of an __label__ label name, otherwise it is a normal label definition\n/// or use.\nLabelDecl *Sema::LookupOrCreateLabel(IdentifierInfo *II, SourceLocation Loc,\n                                     SourceLocation GnuLabelLoc) {\n  // Do a lookup to see if we have a label with this name already.\n  NamedDecl *Res = nullptr;\n\n  if (GnuLabelLoc.isValid()) {\n    // Local label definitions always shadow existing labels.\n    Res = LabelDecl::Create(Context, CurContext, Loc, II, GnuLabelLoc);\n    Scope *S = CurScope;\n    PushOnScopeChains(Res, S, true);\n    return cast<LabelDecl>(Res);\n  }\n\n  // Not a GNU local label.\n  Res = LookupSingleName(CurScope, II, Loc, LookupLabel, NotForRedeclaration);\n  // If we found a label, check to see if it is in the same context as us.\n  // When in a Block, we don't want to reuse a label in an enclosing function.\n  if (Res && Res->getDeclContext() != CurContext)\n    Res = nullptr;\n  if (!Res) {\n    // If not forward referenced or defined already, create the backing decl.\n    Res = LabelDecl::Create(Context, CurContext, Loc, II);\n    Scope *S = CurScope->getFnParent();\n    assert(S && \"Not in a function?\");\n    PushOnScopeChains(Res, S, true);\n  }\n  return cast<LabelDecl>(Res);\n}\n\n//===----------------------------------------------------------------------===//\n// Typo correction\n//===----------------------------------------------------------------------===//\n\nstatic bool isCandidateViable(CorrectionCandidateCallback &CCC,\n                              TypoCorrection &Candidate) {\n  Candidate.setCallbackDistance(CCC.RankCandidate(Candidate));\n  return Candidate.getEditDistance(false) != TypoCorrection::InvalidDistance;\n}\n\nstatic void LookupPotentialTypoResult(Sema &SemaRef,\n                                      LookupResult &Res,\n                                      IdentifierInfo *Name,\n                                      Scope *S, CXXScopeSpec *SS,\n                                      DeclContext *MemberContext,\n                                      bool EnteringContext,\n                                      bool isObjCIvarLookup,\n                                      bool FindHidden);\n\n/// Check whether the declarations found for a typo correction are\n/// visible. Set the correction's RequiresImport flag to true if none of the\n/// declarations are visible, false otherwise.\nstatic void checkCorrectionVisibility(Sema &SemaRef, TypoCorrection &TC) {\n  TypoCorrection::decl_iterator DI = TC.begin(), DE = TC.end();\n\n  for (/**/; DI != DE; ++DI)\n    if (!LookupResult::isVisible(SemaRef, *DI))\n      break;\n  // No filtering needed if all decls are visible.\n  if (DI == DE) {\n    TC.setRequiresImport(false);\n    return;\n  }\n\n  llvm::SmallVector<NamedDecl*, 4> NewDecls(TC.begin(), DI);\n  bool AnyVisibleDecls = !NewDecls.empty();\n\n  for (/**/; DI != DE; ++DI) {\n    if (LookupResult::isVisible(SemaRef, *DI)) {\n      if (!AnyVisibleDecls) {\n        // Found a visible decl, discard all hidden ones.\n        AnyVisibleDecls = true;\n        NewDecls.clear();\n      }\n      NewDecls.push_back(*DI);\n    } else if (!AnyVisibleDecls && !(*DI)->isModulePrivate())\n      NewDecls.push_back(*DI);\n  }\n\n  if (NewDecls.empty())\n    TC = TypoCorrection();\n  else {\n    TC.setCorrectionDecls(NewDecls);\n    TC.setRequiresImport(!AnyVisibleDecls);\n  }\n}\n\n// Fill the supplied vector with the IdentifierInfo pointers for each piece of\n// the given NestedNameSpecifier (i.e. given a NestedNameSpecifier \"foo::bar::\",\n// fill the vector with the IdentifierInfo pointers for \"foo\" and \"bar\").\nstatic void getNestedNameSpecifierIdentifiers(\n    NestedNameSpecifier *NNS,\n    SmallVectorImpl<const IdentifierInfo*> &Identifiers) {\n  if (NestedNameSpecifier *Prefix = NNS->getPrefix())\n    getNestedNameSpecifierIdentifiers(Prefix, Identifiers);\n  else\n    Identifiers.clear();\n\n  const IdentifierInfo *II = nullptr;\n\n  switch (NNS->getKind()) {\n  case NestedNameSpecifier::Identifier:\n    II = NNS->getAsIdentifier();\n    break;\n\n  case NestedNameSpecifier::Namespace:\n    if (NNS->getAsNamespace()->isAnonymousNamespace())\n      return;\n    II = NNS->getAsNamespace()->getIdentifier();\n    break;\n\n  case NestedNameSpecifier::NamespaceAlias:\n    II = NNS->getAsNamespaceAlias()->getIdentifier();\n    break;\n\n  case NestedNameSpecifier::TypeSpecWithTemplate:\n  case NestedNameSpecifier::TypeSpec:\n    II = QualType(NNS->getAsType(), 0).getBaseTypeIdentifier();\n    break;\n\n  case NestedNameSpecifier::Global:\n  case NestedNameSpecifier::Super:\n    return;\n  }\n\n  if (II)\n    Identifiers.push_back(II);\n}\n\nvoid TypoCorrectionConsumer::FoundDecl(NamedDecl *ND, NamedDecl *Hiding,\n                                       DeclContext *Ctx, bool InBaseClass) {\n  // Don't consider hidden names for typo correction.\n  if (Hiding)\n    return;\n\n  // Only consider entities with identifiers for names, ignoring\n  // special names (constructors, overloaded operators, selectors,\n  // etc.).\n  IdentifierInfo *Name = ND->getIdentifier();\n  if (!Name)\n    return;\n\n  // Only consider visible declarations and declarations from modules with\n  // names that exactly match.\n  if (!LookupResult::isVisible(SemaRef, ND) && Name != Typo)\n    return;\n\n  FoundName(Name->getName());\n}\n\nvoid TypoCorrectionConsumer::FoundName(StringRef Name) {\n  // Compute the edit distance between the typo and the name of this\n  // entity, and add the identifier to the list of results.\n  addName(Name, nullptr);\n}\n\nvoid TypoCorrectionConsumer::addKeywordResult(StringRef Keyword) {\n  // Compute the edit distance between the typo and this keyword,\n  // and add the keyword to the list of results.\n  addName(Keyword, nullptr, nullptr, true);\n}\n\nvoid TypoCorrectionConsumer::addName(StringRef Name, NamedDecl *ND,\n                                     NestedNameSpecifier *NNS, bool isKeyword) {\n  // Use a simple length-based heuristic to determine the minimum possible\n  // edit distance. If the minimum isn't good enough, bail out early.\n  StringRef TypoStr = Typo->getName();\n  unsigned MinED = abs((int)Name.size() - (int)TypoStr.size());\n  if (MinED && TypoStr.size() / MinED < 3)\n    return;\n\n  // Compute an upper bound on the allowable edit distance, so that the\n  // edit-distance algorithm can short-circuit.\n  unsigned UpperBound = (TypoStr.size() + 2) / 3;\n  unsigned ED = TypoStr.edit_distance(Name, true, UpperBound);\n  if (ED > UpperBound) return;\n\n  TypoCorrection TC(&SemaRef.Context.Idents.get(Name), ND, NNS, ED);\n  if (isKeyword) TC.makeKeyword();\n  TC.setCorrectionRange(nullptr, Result.getLookupNameInfo());\n  addCorrection(TC);\n}\n\nstatic const unsigned MaxTypoDistanceResultSets = 5;\n\nvoid TypoCorrectionConsumer::addCorrection(TypoCorrection Correction) {\n  StringRef TypoStr = Typo->getName();\n  StringRef Name = Correction.getCorrectionAsIdentifierInfo()->getName();\n\n  // For very short typos, ignore potential corrections that have a different\n  // base identifier from the typo or which have a normalized edit distance\n  // longer than the typo itself.\n  if (TypoStr.size() < 3 &&\n      (Name != TypoStr || Correction.getEditDistance(true) > TypoStr.size()))\n    return;\n\n  // If the correction is resolved but is not viable, ignore it.\n  if (Correction.isResolved()) {\n    checkCorrectionVisibility(SemaRef, Correction);\n    if (!Correction || !isCandidateViable(*CorrectionValidator, Correction))\n      return;\n  }\n\n  TypoResultList &CList =\n      CorrectionResults[Correction.getEditDistance(false)][Name];\n\n  if (!CList.empty() && !CList.back().isResolved())\n    CList.pop_back();\n  if (NamedDecl *NewND = Correction.getCorrectionDecl()) {\n    std::string CorrectionStr = Correction.getAsString(SemaRef.getLangOpts());\n    for (TypoResultList::iterator RI = CList.begin(), RIEnd = CList.end();\n         RI != RIEnd; ++RI) {\n      // If the Correction refers to a decl already in the result list,\n      // replace the existing result if the string representation of Correction\n      // comes before the current result alphabetically, then stop as there is\n      // nothing more to be done to add Correction to the candidate set.\n      if (RI->getCorrectionDecl() == NewND) {\n        if (CorrectionStr < RI->getAsString(SemaRef.getLangOpts()))\n          *RI = Correction;\n        return;\n      }\n    }\n  }\n  if (CList.empty() || Correction.isResolved())\n    CList.push_back(Correction);\n\n  while (CorrectionResults.size() > MaxTypoDistanceResultSets)\n    CorrectionResults.erase(std::prev(CorrectionResults.end()));\n}\n\nvoid TypoCorrectionConsumer::addNamespaces(\n    const llvm::MapVector<NamespaceDecl *, bool> &KnownNamespaces) {\n  SearchNamespaces = true;\n\n  for (auto KNPair : KnownNamespaces)\n    Namespaces.addNameSpecifier(KNPair.first);\n\n  bool SSIsTemplate = false;\n  if (NestedNameSpecifier *NNS =\n          (SS && SS->isValid()) ? SS->getScopeRep() : nullptr) {\n    if (const Type *T = NNS->getAsType())\n      SSIsTemplate = T->getTypeClass() == Type::TemplateSpecialization;\n  }\n  // Do not transform this into an iterator-based loop. The loop body can\n  // trigger the creation of further types (through lazy deserialization) and\n  // invalid iterators into this list.\n  auto &Types = SemaRef.getASTContext().getTypes();\n  for (unsigned I = 0; I != Types.size(); ++I) {\n    const auto *TI = Types[I];\n    if (CXXRecordDecl *CD = TI->getAsCXXRecordDecl()) {\n      CD = CD->getCanonicalDecl();\n      if (!CD->isDependentType() && !CD->isAnonymousStructOrUnion() &&\n          !CD->isUnion() && CD->getIdentifier() &&\n          (SSIsTemplate || !isa<ClassTemplateSpecializationDecl>(CD)) &&\n          (CD->isBeingDefined() || CD->isCompleteDefinition()))\n        Namespaces.addNameSpecifier(CD);\n    }\n  }\n}\n\nconst TypoCorrection &TypoCorrectionConsumer::getNextCorrection() {\n  if (++CurrentTCIndex < ValidatedCorrections.size())\n    return ValidatedCorrections[CurrentTCIndex];\n\n  CurrentTCIndex = ValidatedCorrections.size();\n  while (!CorrectionResults.empty()) {\n    auto DI = CorrectionResults.begin();\n    if (DI->second.empty()) {\n      CorrectionResults.erase(DI);\n      continue;\n    }\n\n    auto RI = DI->second.begin();\n    if (RI->second.empty()) {\n      DI->second.erase(RI);\n      performQualifiedLookups();\n      continue;\n    }\n\n    TypoCorrection TC = RI->second.pop_back_val();\n    if (TC.isResolved() || TC.requiresImport() || resolveCorrection(TC)) {\n      ValidatedCorrections.push_back(TC);\n      return ValidatedCorrections[CurrentTCIndex];\n    }\n  }\n  return ValidatedCorrections[0];  // The empty correction.\n}\n\nbool TypoCorrectionConsumer::resolveCorrection(TypoCorrection &Candidate) {\n  IdentifierInfo *Name = Candidate.getCorrectionAsIdentifierInfo();\n  DeclContext *TempMemberContext = MemberContext;\n  CXXScopeSpec *TempSS = SS.get();\nretry_lookup:\n  LookupPotentialTypoResult(SemaRef, Result, Name, S, TempSS, TempMemberContext,\n                            EnteringContext,\n                            CorrectionValidator->IsObjCIvarLookup,\n                            Name == Typo && !Candidate.WillReplaceSpecifier());\n  switch (Result.getResultKind()) {\n  case LookupResult::NotFound:\n  case LookupResult::NotFoundInCurrentInstantiation:\n  case LookupResult::FoundUnresolvedValue:\n    if (TempSS) {\n      // Immediately retry the lookup without the given CXXScopeSpec\n      TempSS = nullptr;\n      Candidate.WillReplaceSpecifier(true);\n      goto retry_lookup;\n    }\n    if (TempMemberContext) {\n      if (SS && !TempSS)\n        TempSS = SS.get();\n      TempMemberContext = nullptr;\n      goto retry_lookup;\n    }\n    if (SearchNamespaces)\n      QualifiedResults.push_back(Candidate);\n    break;\n\n  case LookupResult::Ambiguous:\n    // We don't deal with ambiguities.\n    break;\n\n  case LookupResult::Found:\n  case LookupResult::FoundOverloaded:\n    // Store all of the Decls for overloaded symbols\n    for (auto *TRD : Result)\n      Candidate.addCorrectionDecl(TRD);\n    checkCorrectionVisibility(SemaRef, Candidate);\n    if (!isCandidateViable(*CorrectionValidator, Candidate)) {\n      if (SearchNamespaces)\n        QualifiedResults.push_back(Candidate);\n      break;\n    }\n    Candidate.setCorrectionRange(SS.get(), Result.getLookupNameInfo());\n    return true;\n  }\n  return false;\n}\n\nvoid TypoCorrectionConsumer::performQualifiedLookups() {\n  unsigned TypoLen = Typo->getName().size();\n  for (const TypoCorrection &QR : QualifiedResults) {\n    for (const auto &NSI : Namespaces) {\n      DeclContext *Ctx = NSI.DeclCtx;\n      const Type *NSType = NSI.NameSpecifier->getAsType();\n\n      // If the current NestedNameSpecifier refers to a class and the\n      // current correction candidate is the name of that class, then skip\n      // it as it is unlikely a qualified version of the class' constructor\n      // is an appropriate correction.\n      if (CXXRecordDecl *NSDecl = NSType ? NSType->getAsCXXRecordDecl() :\n                                           nullptr) {\n        if (NSDecl->getIdentifier() == QR.getCorrectionAsIdentifierInfo())\n          continue;\n      }\n\n      TypoCorrection TC(QR);\n      TC.ClearCorrectionDecls();\n      TC.setCorrectionSpecifier(NSI.NameSpecifier);\n      TC.setQualifierDistance(NSI.EditDistance);\n      TC.setCallbackDistance(0); // Reset the callback distance\n\n      // If the current correction candidate and namespace combination are\n      // too far away from the original typo based on the normalized edit\n      // distance, then skip performing a qualified name lookup.\n      unsigned TmpED = TC.getEditDistance(true);\n      if (QR.getCorrectionAsIdentifierInfo() != Typo && TmpED &&\n          TypoLen / TmpED < 3)\n        continue;\n\n      Result.clear();\n      Result.setLookupName(QR.getCorrectionAsIdentifierInfo());\n      if (!SemaRef.LookupQualifiedName(Result, Ctx))\n        continue;\n\n      // Any corrections added below will be validated in subsequent\n      // iterations of the main while() loop over the Consumer's contents.\n      switch (Result.getResultKind()) {\n      case LookupResult::Found:\n      case LookupResult::FoundOverloaded: {\n        if (SS && SS->isValid()) {\n          std::string NewQualified = TC.getAsString(SemaRef.getLangOpts());\n          std::string OldQualified;\n          llvm::raw_string_ostream OldOStream(OldQualified);\n          SS->getScopeRep()->print(OldOStream, SemaRef.getPrintingPolicy());\n          OldOStream << Typo->getName();\n          // If correction candidate would be an identical written qualified\n          // identifier, then the existing CXXScopeSpec probably included a\n          // typedef that didn't get accounted for properly.\n          if (OldOStream.str() == NewQualified)\n            break;\n        }\n        for (LookupResult::iterator TRD = Result.begin(), TRDEnd = Result.end();\n             TRD != TRDEnd; ++TRD) {\n          if (SemaRef.CheckMemberAccess(TC.getCorrectionRange().getBegin(),\n                                        NSType ? NSType->getAsCXXRecordDecl()\n                                               : nullptr,\n                                        TRD.getPair()) == Sema::AR_accessible)\n            TC.addCorrectionDecl(*TRD);\n        }\n        if (TC.isResolved()) {\n          TC.setCorrectionRange(SS.get(), Result.getLookupNameInfo());\n          addCorrection(TC);\n        }\n        break;\n      }\n      case LookupResult::NotFound:\n      case LookupResult::NotFoundInCurrentInstantiation:\n      case LookupResult::Ambiguous:\n      case LookupResult::FoundUnresolvedValue:\n        break;\n      }\n    }\n  }\n  QualifiedResults.clear();\n}\n\nTypoCorrectionConsumer::NamespaceSpecifierSet::NamespaceSpecifierSet(\n    ASTContext &Context, DeclContext *CurContext, CXXScopeSpec *CurScopeSpec)\n    : Context(Context), CurContextChain(buildContextChain(CurContext)) {\n  if (NestedNameSpecifier *NNS =\n          CurScopeSpec ? CurScopeSpec->getScopeRep() : nullptr) {\n    llvm::raw_string_ostream SpecifierOStream(CurNameSpecifier);\n    NNS->print(SpecifierOStream, Context.getPrintingPolicy());\n\n    getNestedNameSpecifierIdentifiers(NNS, CurNameSpecifierIdentifiers);\n  }\n  // Build the list of identifiers that would be used for an absolute\n  // (from the global context) NestedNameSpecifier referring to the current\n  // context.\n  for (DeclContext *C : llvm::reverse(CurContextChain)) {\n    if (auto *ND = dyn_cast_or_null<NamespaceDecl>(C))\n      CurContextIdentifiers.push_back(ND->getIdentifier());\n  }\n\n  // Add the global context as a NestedNameSpecifier\n  SpecifierInfo SI = {cast<DeclContext>(Context.getTranslationUnitDecl()),\n                      NestedNameSpecifier::GlobalSpecifier(Context), 1};\n  DistanceMap[1].push_back(SI);\n}\n\nauto TypoCorrectionConsumer::NamespaceSpecifierSet::buildContextChain(\n    DeclContext *Start) -> DeclContextList {\n  assert(Start && \"Building a context chain from a null context\");\n  DeclContextList Chain;\n  for (DeclContext *DC = Start->getPrimaryContext(); DC != nullptr;\n       DC = DC->getLookupParent()) {\n    NamespaceDecl *ND = dyn_cast_or_null<NamespaceDecl>(DC);\n    if (!DC->isInlineNamespace() && !DC->isTransparentContext() &&\n        !(ND && ND->isAnonymousNamespace()))\n      Chain.push_back(DC->getPrimaryContext());\n  }\n  return Chain;\n}\n\nunsigned\nTypoCorrectionConsumer::NamespaceSpecifierSet::buildNestedNameSpecifier(\n    DeclContextList &DeclChain, NestedNameSpecifier *&NNS) {\n  unsigned NumSpecifiers = 0;\n  for (DeclContext *C : llvm::reverse(DeclChain)) {\n    if (auto *ND = dyn_cast_or_null<NamespaceDecl>(C)) {\n      NNS = NestedNameSpecifier::Create(Context, NNS, ND);\n      ++NumSpecifiers;\n    } else if (auto *RD = dyn_cast_or_null<RecordDecl>(C)) {\n      NNS = NestedNameSpecifier::Create(Context, NNS, RD->isTemplateDecl(),\n                                        RD->getTypeForDecl());\n      ++NumSpecifiers;\n    }\n  }\n  return NumSpecifiers;\n}\n\nvoid TypoCorrectionConsumer::NamespaceSpecifierSet::addNameSpecifier(\n    DeclContext *Ctx) {\n  NestedNameSpecifier *NNS = nullptr;\n  unsigned NumSpecifiers = 0;\n  DeclContextList NamespaceDeclChain(buildContextChain(Ctx));\n  DeclContextList FullNamespaceDeclChain(NamespaceDeclChain);\n\n  // Eliminate common elements from the two DeclContext chains.\n  for (DeclContext *C : llvm::reverse(CurContextChain)) {\n    if (NamespaceDeclChain.empty() || NamespaceDeclChain.back() != C)\n      break;\n    NamespaceDeclChain.pop_back();\n  }\n\n  // Build the NestedNameSpecifier from what is left of the NamespaceDeclChain\n  NumSpecifiers = buildNestedNameSpecifier(NamespaceDeclChain, NNS);\n\n  // Add an explicit leading '::' specifier if needed.\n  if (NamespaceDeclChain.empty()) {\n    // Rebuild the NestedNameSpecifier as a globally-qualified specifier.\n    NNS = NestedNameSpecifier::GlobalSpecifier(Context);\n    NumSpecifiers =\n        buildNestedNameSpecifier(FullNamespaceDeclChain, NNS);\n  } else if (NamedDecl *ND =\n                 dyn_cast_or_null<NamedDecl>(NamespaceDeclChain.back())) {\n    IdentifierInfo *Name = ND->getIdentifier();\n    bool SameNameSpecifier = false;\n    if (std::find(CurNameSpecifierIdentifiers.begin(),\n                  CurNameSpecifierIdentifiers.end(),\n                  Name) != CurNameSpecifierIdentifiers.end()) {\n      std::string NewNameSpecifier;\n      llvm::raw_string_ostream SpecifierOStream(NewNameSpecifier);\n      SmallVector<const IdentifierInfo *, 4> NewNameSpecifierIdentifiers;\n      getNestedNameSpecifierIdentifiers(NNS, NewNameSpecifierIdentifiers);\n      NNS->print(SpecifierOStream, Context.getPrintingPolicy());\n      SpecifierOStream.flush();\n      SameNameSpecifier = NewNameSpecifier == CurNameSpecifier;\n    }\n    if (SameNameSpecifier || llvm::find(CurContextIdentifiers, Name) !=\n                                 CurContextIdentifiers.end()) {\n      // Rebuild the NestedNameSpecifier as a globally-qualified specifier.\n      NNS = NestedNameSpecifier::GlobalSpecifier(Context);\n      NumSpecifiers =\n          buildNestedNameSpecifier(FullNamespaceDeclChain, NNS);\n    }\n  }\n\n  // If the built NestedNameSpecifier would be replacing an existing\n  // NestedNameSpecifier, use the number of component identifiers that\n  // would need to be changed as the edit distance instead of the number\n  // of components in the built NestedNameSpecifier.\n  if (NNS && !CurNameSpecifierIdentifiers.empty()) {\n    SmallVector<const IdentifierInfo*, 4> NewNameSpecifierIdentifiers;\n    getNestedNameSpecifierIdentifiers(NNS, NewNameSpecifierIdentifiers);\n    NumSpecifiers = llvm::ComputeEditDistance(\n        llvm::makeArrayRef(CurNameSpecifierIdentifiers),\n        llvm::makeArrayRef(NewNameSpecifierIdentifiers));\n  }\n\n  SpecifierInfo SI = {Ctx, NNS, NumSpecifiers};\n  DistanceMap[NumSpecifiers].push_back(SI);\n}\n\n/// Perform name lookup for a possible result for typo correction.\nstatic void LookupPotentialTypoResult(Sema &SemaRef,\n                                      LookupResult &Res,\n                                      IdentifierInfo *Name,\n                                      Scope *S, CXXScopeSpec *SS,\n                                      DeclContext *MemberContext,\n                                      bool EnteringContext,\n                                      bool isObjCIvarLookup,\n                                      bool FindHidden) {\n  Res.suppressDiagnostics();\n  Res.clear();\n  Res.setLookupName(Name);\n  Res.setAllowHidden(FindHidden);\n  if (MemberContext) {\n    if (ObjCInterfaceDecl *Class = dyn_cast<ObjCInterfaceDecl>(MemberContext)) {\n      if (isObjCIvarLookup) {\n        if (ObjCIvarDecl *Ivar = Class->lookupInstanceVariable(Name)) {\n          Res.addDecl(Ivar);\n          Res.resolveKind();\n          return;\n        }\n      }\n\n      if (ObjCPropertyDecl *Prop = Class->FindPropertyDeclaration(\n              Name, ObjCPropertyQueryKind::OBJC_PR_query_instance)) {\n        Res.addDecl(Prop);\n        Res.resolveKind();\n        return;\n      }\n    }\n\n    SemaRef.LookupQualifiedName(Res, MemberContext);\n    return;\n  }\n\n  SemaRef.LookupParsedName(Res, S, SS, /*AllowBuiltinCreation=*/false,\n                           EnteringContext);\n\n  // Fake ivar lookup; this should really be part of\n  // LookupParsedName.\n  if (ObjCMethodDecl *Method = SemaRef.getCurMethodDecl()) {\n    if (Method->isInstanceMethod() && Method->getClassInterface() &&\n        (Res.empty() ||\n         (Res.isSingleResult() &&\n          Res.getFoundDecl()->isDefinedOutsideFunctionOrMethod()))) {\n       if (ObjCIvarDecl *IV\n             = Method->getClassInterface()->lookupInstanceVariable(Name)) {\n         Res.addDecl(IV);\n         Res.resolveKind();\n       }\n     }\n  }\n}\n\n/// Add keywords to the consumer as possible typo corrections.\nstatic void AddKeywordsToConsumer(Sema &SemaRef,\n                                  TypoCorrectionConsumer &Consumer,\n                                  Scope *S, CorrectionCandidateCallback &CCC,\n                                  bool AfterNestedNameSpecifier) {\n  if (AfterNestedNameSpecifier) {\n    // For 'X::', we know exactly which keywords can appear next.\n    Consumer.addKeywordResult(\"template\");\n    if (CCC.WantExpressionKeywords)\n      Consumer.addKeywordResult(\"operator\");\n    return;\n  }\n\n  if (CCC.WantObjCSuper)\n    Consumer.addKeywordResult(\"super\");\n\n  if (CCC.WantTypeSpecifiers) {\n    // Add type-specifier keywords to the set of results.\n    static const char *const CTypeSpecs[] = {\n      \"char\", \"const\", \"double\", \"enum\", \"float\", \"int\", \"long\", \"short\",\n      \"signed\", \"struct\", \"union\", \"unsigned\", \"void\", \"volatile\",\n      \"_Complex\", \"_Imaginary\",\n      // storage-specifiers as well\n      \"extern\", \"inline\", \"static\", \"typedef\"\n    };\n\n    const unsigned NumCTypeSpecs = llvm::array_lengthof(CTypeSpecs);\n    for (unsigned I = 0; I != NumCTypeSpecs; ++I)\n      Consumer.addKeywordResult(CTypeSpecs[I]);\n\n    if (SemaRef.getLangOpts().C99)\n      Consumer.addKeywordResult(\"restrict\");\n    if (SemaRef.getLangOpts().Bool || SemaRef.getLangOpts().CPlusPlus)\n      Consumer.addKeywordResult(\"bool\");\n    else if (SemaRef.getLangOpts().C99)\n      Consumer.addKeywordResult(\"_Bool\");\n\n    if (SemaRef.getLangOpts().CPlusPlus) {\n      Consumer.addKeywordResult(\"class\");\n      Consumer.addKeywordResult(\"typename\");\n      Consumer.addKeywordResult(\"wchar_t\");\n\n      if (SemaRef.getLangOpts().CPlusPlus11) {\n        Consumer.addKeywordResult(\"char16_t\");\n        Consumer.addKeywordResult(\"char32_t\");\n        Consumer.addKeywordResult(\"constexpr\");\n        Consumer.addKeywordResult(\"decltype\");\n        Consumer.addKeywordResult(\"thread_local\");\n      }\n    }\n\n    if (SemaRef.getLangOpts().GNUKeywords)\n      Consumer.addKeywordResult(\"typeof\");\n  } else if (CCC.WantFunctionLikeCasts) {\n    static const char *const CastableTypeSpecs[] = {\n      \"char\", \"double\", \"float\", \"int\", \"long\", \"short\",\n      \"signed\", \"unsigned\", \"void\"\n    };\n    for (auto *kw : CastableTypeSpecs)\n      Consumer.addKeywordResult(kw);\n  }\n\n  if (CCC.WantCXXNamedCasts && SemaRef.getLangOpts().CPlusPlus) {\n    Consumer.addKeywordResult(\"const_cast\");\n    Consumer.addKeywordResult(\"dynamic_cast\");\n    Consumer.addKeywordResult(\"reinterpret_cast\");\n    Consumer.addKeywordResult(\"static_cast\");\n  }\n\n  if (CCC.WantExpressionKeywords) {\n    Consumer.addKeywordResult(\"sizeof\");\n    if (SemaRef.getLangOpts().Bool || SemaRef.getLangOpts().CPlusPlus) {\n      Consumer.addKeywordResult(\"false\");\n      Consumer.addKeywordResult(\"true\");\n    }\n\n    if (SemaRef.getLangOpts().CPlusPlus) {\n      static const char *const CXXExprs[] = {\n        \"delete\", \"new\", \"operator\", \"throw\", \"typeid\"\n      };\n      const unsigned NumCXXExprs = llvm::array_lengthof(CXXExprs);\n      for (unsigned I = 0; I != NumCXXExprs; ++I)\n        Consumer.addKeywordResult(CXXExprs[I]);\n\n      if (isa<CXXMethodDecl>(SemaRef.CurContext) &&\n          cast<CXXMethodDecl>(SemaRef.CurContext)->isInstance())\n        Consumer.addKeywordResult(\"this\");\n\n      if (SemaRef.getLangOpts().CPlusPlus11) {\n        Consumer.addKeywordResult(\"alignof\");\n        Consumer.addKeywordResult(\"nullptr\");\n      }\n    }\n\n    if (SemaRef.getLangOpts().C11) {\n      // FIXME: We should not suggest _Alignof if the alignof macro\n      // is present.\n      Consumer.addKeywordResult(\"_Alignof\");\n    }\n  }\n\n  if (CCC.WantRemainingKeywords) {\n    if (SemaRef.getCurFunctionOrMethodDecl() || SemaRef.getCurBlock()) {\n      // Statements.\n      static const char *const CStmts[] = {\n        \"do\", \"else\", \"for\", \"goto\", \"if\", \"return\", \"switch\", \"while\" };\n      const unsigned NumCStmts = llvm::array_lengthof(CStmts);\n      for (unsigned I = 0; I != NumCStmts; ++I)\n        Consumer.addKeywordResult(CStmts[I]);\n\n      if (SemaRef.getLangOpts().CPlusPlus) {\n        Consumer.addKeywordResult(\"catch\");\n        Consumer.addKeywordResult(\"try\");\n      }\n\n      if (S && S->getBreakParent())\n        Consumer.addKeywordResult(\"break\");\n\n      if (S && S->getContinueParent())\n        Consumer.addKeywordResult(\"continue\");\n\n      if (SemaRef.getCurFunction() &&\n          !SemaRef.getCurFunction()->SwitchStack.empty()) {\n        Consumer.addKeywordResult(\"case\");\n        Consumer.addKeywordResult(\"default\");\n      }\n    } else {\n      if (SemaRef.getLangOpts().CPlusPlus) {\n        Consumer.addKeywordResult(\"namespace\");\n        Consumer.addKeywordResult(\"template\");\n      }\n\n      if (S && S->isClassScope()) {\n        Consumer.addKeywordResult(\"explicit\");\n        Consumer.addKeywordResult(\"friend\");\n        Consumer.addKeywordResult(\"mutable\");\n        Consumer.addKeywordResult(\"private\");\n        Consumer.addKeywordResult(\"protected\");\n        Consumer.addKeywordResult(\"public\");\n        Consumer.addKeywordResult(\"virtual\");\n      }\n    }\n\n    if (SemaRef.getLangOpts().CPlusPlus) {\n      Consumer.addKeywordResult(\"using\");\n\n      if (SemaRef.getLangOpts().CPlusPlus11)\n        Consumer.addKeywordResult(\"static_assert\");\n    }\n  }\n}\n\nstd::unique_ptr<TypoCorrectionConsumer> Sema::makeTypoCorrectionConsumer(\n    const DeclarationNameInfo &TypoName, Sema::LookupNameKind LookupKind,\n    Scope *S, CXXScopeSpec *SS, CorrectionCandidateCallback &CCC,\n    DeclContext *MemberContext, bool EnteringContext,\n    const ObjCObjectPointerType *OPT, bool ErrorRecovery) {\n\n  if (Diags.hasFatalErrorOccurred() || !getLangOpts().SpellChecking ||\n      DisableTypoCorrection)\n    return nullptr;\n\n  // In Microsoft mode, don't perform typo correction in a template member\n  // function dependent context because it interferes with the \"lookup into\n  // dependent bases of class templates\" feature.\n  if (getLangOpts().MSVCCompat && CurContext->isDependentContext() &&\n      isa<CXXMethodDecl>(CurContext))\n    return nullptr;\n\n  // We only attempt to correct typos for identifiers.\n  IdentifierInfo *Typo = TypoName.getName().getAsIdentifierInfo();\n  if (!Typo)\n    return nullptr;\n\n  // If the scope specifier itself was invalid, don't try to correct\n  // typos.\n  if (SS && SS->isInvalid())\n    return nullptr;\n\n  // Never try to correct typos during any kind of code synthesis.\n  if (!CodeSynthesisContexts.empty())\n    return nullptr;\n\n  // Don't try to correct 'super'.\n  if (S && S->isInObjcMethodScope() && Typo == getSuperIdentifier())\n    return nullptr;\n\n  // Abort if typo correction already failed for this specific typo.\n  IdentifierSourceLocations::iterator locs = TypoCorrectionFailures.find(Typo);\n  if (locs != TypoCorrectionFailures.end() &&\n      locs->second.count(TypoName.getLoc()))\n    return nullptr;\n\n  // Don't try to correct the identifier \"vector\" when in AltiVec mode.\n  // TODO: Figure out why typo correction misbehaves in this case, fix it, and\n  // remove this workaround.\n  if ((getLangOpts().AltiVec || getLangOpts().ZVector) && Typo->isStr(\"vector\"))\n    return nullptr;\n\n  // Provide a stop gap for files that are just seriously broken.  Trying\n  // to correct all typos can turn into a HUGE performance penalty, causing\n  // some files to take minutes to get rejected by the parser.\n  unsigned Limit = getDiagnostics().getDiagnosticOptions().SpellCheckingLimit;\n  if (Limit && TyposCorrected >= Limit)\n    return nullptr;\n  ++TyposCorrected;\n\n  // If we're handling a missing symbol error, using modules, and the\n  // special search all modules option is used, look for a missing import.\n  if (ErrorRecovery && getLangOpts().Modules &&\n      getLangOpts().ModulesSearchAll) {\n    // The following has the side effect of loading the missing module.\n    getModuleLoader().lookupMissingImports(Typo->getName(),\n                                           TypoName.getBeginLoc());\n  }\n\n  // Extend the lifetime of the callback. We delayed this until here\n  // to avoid allocations in the hot path (which is where no typo correction\n  // occurs). Note that CorrectionCandidateCallback is polymorphic and\n  // initially stack-allocated.\n  std::unique_ptr<CorrectionCandidateCallback> ClonedCCC = CCC.clone();\n  auto Consumer = std::make_unique<TypoCorrectionConsumer>(\n      *this, TypoName, LookupKind, S, SS, std::move(ClonedCCC), MemberContext,\n      EnteringContext);\n\n  // Perform name lookup to find visible, similarly-named entities.\n  bool IsUnqualifiedLookup = false;\n  DeclContext *QualifiedDC = MemberContext;\n  if (MemberContext) {\n    LookupVisibleDecls(MemberContext, LookupKind, *Consumer);\n\n    // Look in qualified interfaces.\n    if (OPT) {\n      for (auto *I : OPT->quals())\n        LookupVisibleDecls(I, LookupKind, *Consumer);\n    }\n  } else if (SS && SS->isSet()) {\n    QualifiedDC = computeDeclContext(*SS, EnteringContext);\n    if (!QualifiedDC)\n      return nullptr;\n\n    LookupVisibleDecls(QualifiedDC, LookupKind, *Consumer);\n  } else {\n    IsUnqualifiedLookup = true;\n  }\n\n  // Determine whether we are going to search in the various namespaces for\n  // corrections.\n  bool SearchNamespaces\n    = getLangOpts().CPlusPlus &&\n      (IsUnqualifiedLookup || (SS && SS->isSet()));\n\n  if (IsUnqualifiedLookup || SearchNamespaces) {\n    // For unqualified lookup, look through all of the names that we have\n    // seen in this translation unit.\n    // FIXME: Re-add the ability to skip very unlikely potential corrections.\n    for (const auto &I : Context.Idents)\n      Consumer->FoundName(I.getKey());\n\n    // Walk through identifiers in external identifier sources.\n    // FIXME: Re-add the ability to skip very unlikely potential corrections.\n    if (IdentifierInfoLookup *External\n                            = Context.Idents.getExternalIdentifierLookup()) {\n      std::unique_ptr<IdentifierIterator> Iter(External->getIdentifiers());\n      do {\n        StringRef Name = Iter->Next();\n        if (Name.empty())\n          break;\n\n        Consumer->FoundName(Name);\n      } while (true);\n    }\n  }\n\n  AddKeywordsToConsumer(*this, *Consumer, S,\n                        *Consumer->getCorrectionValidator(),\n                        SS && SS->isNotEmpty());\n\n  // Build the NestedNameSpecifiers for the KnownNamespaces, if we're going\n  // to search those namespaces.\n  if (SearchNamespaces) {\n    // Load any externally-known namespaces.\n    if (ExternalSource && !LoadedExternalKnownNamespaces) {\n      SmallVector<NamespaceDecl *, 4> ExternalKnownNamespaces;\n      LoadedExternalKnownNamespaces = true;\n      ExternalSource->ReadKnownNamespaces(ExternalKnownNamespaces);\n      for (auto *N : ExternalKnownNamespaces)\n        KnownNamespaces[N] = true;\n    }\n\n    Consumer->addNamespaces(KnownNamespaces);\n  }\n\n  return Consumer;\n}\n\n/// Try to \"correct\" a typo in the source code by finding\n/// visible declarations whose names are similar to the name that was\n/// present in the source code.\n///\n/// \\param TypoName the \\c DeclarationNameInfo structure that contains\n/// the name that was present in the source code along with its location.\n///\n/// \\param LookupKind the name-lookup criteria used to search for the name.\n///\n/// \\param S the scope in which name lookup occurs.\n///\n/// \\param SS the nested-name-specifier that precedes the name we're\n/// looking for, if present.\n///\n/// \\param CCC A CorrectionCandidateCallback object that provides further\n/// validation of typo correction candidates. It also provides flags for\n/// determining the set of keywords permitted.\n///\n/// \\param MemberContext if non-NULL, the context in which to look for\n/// a member access expression.\n///\n/// \\param EnteringContext whether we're entering the context described by\n/// the nested-name-specifier SS.\n///\n/// \\param OPT when non-NULL, the search for visible declarations will\n/// also walk the protocols in the qualified interfaces of \\p OPT.\n///\n/// \\returns a \\c TypoCorrection containing the corrected name if the typo\n/// along with information such as the \\c NamedDecl where the corrected name\n/// was declared, and any additional \\c NestedNameSpecifier needed to access\n/// it (C++ only). The \\c TypoCorrection is empty if there is no correction.\nTypoCorrection Sema::CorrectTypo(const DeclarationNameInfo &TypoName,\n                                 Sema::LookupNameKind LookupKind,\n                                 Scope *S, CXXScopeSpec *SS,\n                                 CorrectionCandidateCallback &CCC,\n                                 CorrectTypoKind Mode,\n                                 DeclContext *MemberContext,\n                                 bool EnteringContext,\n                                 const ObjCObjectPointerType *OPT,\n                                 bool RecordFailure) {\n  // Always let the ExternalSource have the first chance at correction, even\n  // if we would otherwise have given up.\n  if (ExternalSource) {\n    if (TypoCorrection Correction =\n            ExternalSource->CorrectTypo(TypoName, LookupKind, S, SS, CCC,\n                                        MemberContext, EnteringContext, OPT))\n      return Correction;\n  }\n\n  // Ugly hack equivalent to CTC == CTC_ObjCMessageReceiver;\n  // WantObjCSuper is only true for CTC_ObjCMessageReceiver and for\n  // some instances of CTC_Unknown, while WantRemainingKeywords is true\n  // for CTC_Unknown but not for CTC_ObjCMessageReceiver.\n  bool ObjCMessageReceiver = CCC.WantObjCSuper && !CCC.WantRemainingKeywords;\n\n  IdentifierInfo *Typo = TypoName.getName().getAsIdentifierInfo();\n  auto Consumer = makeTypoCorrectionConsumer(TypoName, LookupKind, S, SS, CCC,\n                                             MemberContext, EnteringContext,\n                                             OPT, Mode == CTK_ErrorRecovery);\n\n  if (!Consumer)\n    return TypoCorrection();\n\n  // If we haven't found anything, we're done.\n  if (Consumer->empty())\n    return FailedCorrection(Typo, TypoName.getLoc(), RecordFailure);\n\n  // Make sure the best edit distance (prior to adding any namespace qualifiers)\n  // is not more that about a third of the length of the typo's identifier.\n  unsigned ED = Consumer->getBestEditDistance(true);\n  unsigned TypoLen = Typo->getName().size();\n  if (ED > 0 && TypoLen / ED < 3)\n    return FailedCorrection(Typo, TypoName.getLoc(), RecordFailure);\n\n  TypoCorrection BestTC = Consumer->getNextCorrection();\n  TypoCorrection SecondBestTC = Consumer->getNextCorrection();\n  if (!BestTC)\n    return FailedCorrection(Typo, TypoName.getLoc(), RecordFailure);\n\n  ED = BestTC.getEditDistance();\n\n  if (TypoLen >= 3 && ED > 0 && TypoLen / ED < 3) {\n    // If this was an unqualified lookup and we believe the callback\n    // object wouldn't have filtered out possible corrections, note\n    // that no correction was found.\n    return FailedCorrection(Typo, TypoName.getLoc(), RecordFailure);\n  }\n\n  // If only a single name remains, return that result.\n  if (!SecondBestTC ||\n      SecondBestTC.getEditDistance(false) > BestTC.getEditDistance(false)) {\n    const TypoCorrection &Result = BestTC;\n\n    // Don't correct to a keyword that's the same as the typo; the keyword\n    // wasn't actually in scope.\n    if (ED == 0 && Result.isKeyword())\n      return FailedCorrection(Typo, TypoName.getLoc(), RecordFailure);\n\n    TypoCorrection TC = Result;\n    TC.setCorrectionRange(SS, TypoName);\n    checkCorrectionVisibility(*this, TC);\n    return TC;\n  } else if (SecondBestTC && ObjCMessageReceiver) {\n    // Prefer 'super' when we're completing in a message-receiver\n    // context.\n\n    if (BestTC.getCorrection().getAsString() != \"super\") {\n      if (SecondBestTC.getCorrection().getAsString() == \"super\")\n        BestTC = SecondBestTC;\n      else if ((*Consumer)[\"super\"].front().isKeyword())\n        BestTC = (*Consumer)[\"super\"].front();\n    }\n    // Don't correct to a keyword that's the same as the typo; the keyword\n    // wasn't actually in scope.\n    if (BestTC.getEditDistance() == 0 ||\n        BestTC.getCorrection().getAsString() != \"super\")\n      return FailedCorrection(Typo, TypoName.getLoc(), RecordFailure);\n\n    BestTC.setCorrectionRange(SS, TypoName);\n    return BestTC;\n  }\n\n  // Record the failure's location if needed and return an empty correction. If\n  // this was an unqualified lookup and we believe the callback object did not\n  // filter out possible corrections, also cache the failure for the typo.\n  return FailedCorrection(Typo, TypoName.getLoc(), RecordFailure && !SecondBestTC);\n}\n\n/// Try to \"correct\" a typo in the source code by finding\n/// visible declarations whose names are similar to the name that was\n/// present in the source code.\n///\n/// \\param TypoName the \\c DeclarationNameInfo structure that contains\n/// the name that was present in the source code along with its location.\n///\n/// \\param LookupKind the name-lookup criteria used to search for the name.\n///\n/// \\param S the scope in which name lookup occurs.\n///\n/// \\param SS the nested-name-specifier that precedes the name we're\n/// looking for, if present.\n///\n/// \\param CCC A CorrectionCandidateCallback object that provides further\n/// validation of typo correction candidates. It also provides flags for\n/// determining the set of keywords permitted.\n///\n/// \\param TDG A TypoDiagnosticGenerator functor that will be used to print\n/// diagnostics when the actual typo correction is attempted.\n///\n/// \\param TRC A TypoRecoveryCallback functor that will be used to build an\n/// Expr from a typo correction candidate.\n///\n/// \\param MemberContext if non-NULL, the context in which to look for\n/// a member access expression.\n///\n/// \\param EnteringContext whether we're entering the context described by\n/// the nested-name-specifier SS.\n///\n/// \\param OPT when non-NULL, the search for visible declarations will\n/// also walk the protocols in the qualified interfaces of \\p OPT.\n///\n/// \\returns a new \\c TypoExpr that will later be replaced in the AST with an\n/// Expr representing the result of performing typo correction, or nullptr if\n/// typo correction is not possible. If nullptr is returned, no diagnostics will\n/// be emitted and it is the responsibility of the caller to emit any that are\n/// needed.\nTypoExpr *Sema::CorrectTypoDelayed(\n    const DeclarationNameInfo &TypoName, Sema::LookupNameKind LookupKind,\n    Scope *S, CXXScopeSpec *SS, CorrectionCandidateCallback &CCC,\n    TypoDiagnosticGenerator TDG, TypoRecoveryCallback TRC, CorrectTypoKind Mode,\n    DeclContext *MemberContext, bool EnteringContext,\n    const ObjCObjectPointerType *OPT) {\n  auto Consumer = makeTypoCorrectionConsumer(TypoName, LookupKind, S, SS, CCC,\n                                             MemberContext, EnteringContext,\n                                             OPT, Mode == CTK_ErrorRecovery);\n\n  // Give the external sema source a chance to correct the typo.\n  TypoCorrection ExternalTypo;\n  if (ExternalSource && Consumer) {\n    ExternalTypo = ExternalSource->CorrectTypo(\n        TypoName, LookupKind, S, SS, *Consumer->getCorrectionValidator(),\n        MemberContext, EnteringContext, OPT);\n    if (ExternalTypo)\n      Consumer->addCorrection(ExternalTypo);\n  }\n\n  if (!Consumer || Consumer->empty())\n    return nullptr;\n\n  // Make sure the best edit distance (prior to adding any namespace qualifiers)\n  // is not more that about a third of the length of the typo's identifier.\n  unsigned ED = Consumer->getBestEditDistance(true);\n  IdentifierInfo *Typo = TypoName.getName().getAsIdentifierInfo();\n  if (!ExternalTypo && ED > 0 && Typo->getName().size() / ED < 3)\n    return nullptr;\n  ExprEvalContexts.back().NumTypos++;\n  return createDelayedTypo(std::move(Consumer), std::move(TDG), std::move(TRC),\n                           TypoName.getLoc());\n}\n\nvoid TypoCorrection::addCorrectionDecl(NamedDecl *CDecl) {\n  if (!CDecl) return;\n\n  if (isKeyword())\n    CorrectionDecls.clear();\n\n  CorrectionDecls.push_back(CDecl);\n\n  if (!CorrectionName)\n    CorrectionName = CDecl->getDeclName();\n}\n\nstd::string TypoCorrection::getAsString(const LangOptions &LO) const {\n  if (CorrectionNameSpec) {\n    std::string tmpBuffer;\n    llvm::raw_string_ostream PrefixOStream(tmpBuffer);\n    CorrectionNameSpec->print(PrefixOStream, PrintingPolicy(LO));\n    PrefixOStream << CorrectionName;\n    return PrefixOStream.str();\n  }\n\n  return CorrectionName.getAsString();\n}\n\nbool CorrectionCandidateCallback::ValidateCandidate(\n    const TypoCorrection &candidate) {\n  if (!candidate.isResolved())\n    return true;\n\n  if (candidate.isKeyword())\n    return WantTypeSpecifiers || WantExpressionKeywords || WantCXXNamedCasts ||\n           WantRemainingKeywords || WantObjCSuper;\n\n  bool HasNonType = false;\n  bool HasStaticMethod = false;\n  bool HasNonStaticMethod = false;\n  for (Decl *D : candidate) {\n    if (FunctionTemplateDecl *FTD = dyn_cast<FunctionTemplateDecl>(D))\n      D = FTD->getTemplatedDecl();\n    if (CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(D)) {\n      if (Method->isStatic())\n        HasStaticMethod = true;\n      else\n        HasNonStaticMethod = true;\n    }\n    if (!isa<TypeDecl>(D))\n      HasNonType = true;\n  }\n\n  if (IsAddressOfOperand && HasNonStaticMethod && !HasStaticMethod &&\n      !candidate.getCorrectionSpecifier())\n    return false;\n\n  return WantTypeSpecifiers || HasNonType;\n}\n\nFunctionCallFilterCCC::FunctionCallFilterCCC(Sema &SemaRef, unsigned NumArgs,\n                                             bool HasExplicitTemplateArgs,\n                                             MemberExpr *ME)\n    : NumArgs(NumArgs), HasExplicitTemplateArgs(HasExplicitTemplateArgs),\n      CurContext(SemaRef.CurContext), MemberFn(ME) {\n  WantTypeSpecifiers = false;\n  WantFunctionLikeCasts = SemaRef.getLangOpts().CPlusPlus &&\n                          !HasExplicitTemplateArgs && NumArgs == 1;\n  WantCXXNamedCasts = HasExplicitTemplateArgs && NumArgs == 1;\n  WantRemainingKeywords = false;\n}\n\nbool FunctionCallFilterCCC::ValidateCandidate(const TypoCorrection &candidate) {\n  if (!candidate.getCorrectionDecl())\n    return candidate.isKeyword();\n\n  for (auto *C : candidate) {\n    FunctionDecl *FD = nullptr;\n    NamedDecl *ND = C->getUnderlyingDecl();\n    if (FunctionTemplateDecl *FTD = dyn_cast<FunctionTemplateDecl>(ND))\n      FD = FTD->getTemplatedDecl();\n    if (!HasExplicitTemplateArgs && !FD) {\n      if (!(FD = dyn_cast<FunctionDecl>(ND)) && isa<ValueDecl>(ND)) {\n        // If the Decl is neither a function nor a template function,\n        // determine if it is a pointer or reference to a function. If so,\n        // check against the number of arguments expected for the pointee.\n        QualType ValType = cast<ValueDecl>(ND)->getType();\n        if (ValType.isNull())\n          continue;\n        if (ValType->isAnyPointerType() || ValType->isReferenceType())\n          ValType = ValType->getPointeeType();\n        if (const FunctionProtoType *FPT = ValType->getAs<FunctionProtoType>())\n          if (FPT->getNumParams() == NumArgs)\n            return true;\n      }\n    }\n\n    // A typo for a function-style cast can look like a function call in C++.\n    if ((HasExplicitTemplateArgs ? getAsTypeTemplateDecl(ND) != nullptr\n                                 : isa<TypeDecl>(ND)) &&\n        CurContext->getParentASTContext().getLangOpts().CPlusPlus)\n      // Only a class or class template can take two or more arguments.\n      return NumArgs <= 1 || HasExplicitTemplateArgs || isa<CXXRecordDecl>(ND);\n\n    // Skip the current candidate if it is not a FunctionDecl or does not accept\n    // the current number of arguments.\n    if (!FD || !(FD->getNumParams() >= NumArgs &&\n                 FD->getMinRequiredArguments() <= NumArgs))\n      continue;\n\n    // If the current candidate is a non-static C++ method, skip the candidate\n    // unless the method being corrected--or the current DeclContext, if the\n    // function being corrected is not a method--is a method in the same class\n    // or a descendent class of the candidate's parent class.\n    if (CXXMethodDecl *MD = dyn_cast<CXXMethodDecl>(FD)) {\n      if (MemberFn || !MD->isStatic()) {\n        CXXMethodDecl *CurMD =\n            MemberFn\n                ? dyn_cast_or_null<CXXMethodDecl>(MemberFn->getMemberDecl())\n                : dyn_cast_or_null<CXXMethodDecl>(CurContext);\n        CXXRecordDecl *CurRD =\n            CurMD ? CurMD->getParent()->getCanonicalDecl() : nullptr;\n        CXXRecordDecl *RD = MD->getParent()->getCanonicalDecl();\n        if (!CurRD || (CurRD != RD && !CurRD->isDerivedFrom(RD)))\n          continue;\n      }\n    }\n    return true;\n  }\n  return false;\n}\n\nvoid Sema::diagnoseTypo(const TypoCorrection &Correction,\n                        const PartialDiagnostic &TypoDiag,\n                        bool ErrorRecovery) {\n  diagnoseTypo(Correction, TypoDiag, PDiag(diag::note_previous_decl),\n               ErrorRecovery);\n}\n\n/// Find which declaration we should import to provide the definition of\n/// the given declaration.\nstatic NamedDecl *getDefinitionToImport(NamedDecl *D) {\n  if (VarDecl *VD = dyn_cast<VarDecl>(D))\n    return VD->getDefinition();\n  if (FunctionDecl *FD = dyn_cast<FunctionDecl>(D))\n    return FD->getDefinition();\n  if (TagDecl *TD = dyn_cast<TagDecl>(D))\n    return TD->getDefinition();\n  // The first definition for this ObjCInterfaceDecl might be in the TU\n  // and not associated with any module. Use the one we know to be complete\n  // and have just seen in a module.\n  if (ObjCInterfaceDecl *ID = dyn_cast<ObjCInterfaceDecl>(D))\n    return ID;\n  if (ObjCProtocolDecl *PD = dyn_cast<ObjCProtocolDecl>(D))\n    return PD->getDefinition();\n  if (TemplateDecl *TD = dyn_cast<TemplateDecl>(D))\n    if (NamedDecl *TTD = TD->getTemplatedDecl())\n      return getDefinitionToImport(TTD);\n  return nullptr;\n}\n\nvoid Sema::diagnoseMissingImport(SourceLocation Loc, NamedDecl *Decl,\n                                 MissingImportKind MIK, bool Recover) {\n  // Suggest importing a module providing the definition of this entity, if\n  // possible.\n  NamedDecl *Def = getDefinitionToImport(Decl);\n  if (!Def)\n    Def = Decl;\n\n  Module *Owner = getOwningModule(Def);\n  assert(Owner && \"definition of hidden declaration is not in a module\");\n\n  llvm::SmallVector<Module*, 8> OwningModules;\n  OwningModules.push_back(Owner);\n  auto Merged = Context.getModulesWithMergedDefinition(Def);\n  OwningModules.insert(OwningModules.end(), Merged.begin(), Merged.end());\n\n  diagnoseMissingImport(Loc, Def, Def->getLocation(), OwningModules, MIK,\n                        Recover);\n}\n\n/// Get a \"quoted.h\" or <angled.h> include path to use in a diagnostic\n/// suggesting the addition of a #include of the specified file.\nstatic std::string getHeaderNameForHeader(Preprocessor &PP, const FileEntry *E,\n                                          llvm::StringRef IncludingFile) {\n  bool IsSystem = false;\n  auto Path = PP.getHeaderSearchInfo().suggestPathToFileForDiagnostics(\n      E, IncludingFile, &IsSystem);\n  return (IsSystem ? '<' : '\"') + Path + (IsSystem ? '>' : '\"');\n}\n\nvoid Sema::diagnoseMissingImport(SourceLocation UseLoc, NamedDecl *Decl,\n                                 SourceLocation DeclLoc,\n                                 ArrayRef<Module *> Modules,\n                                 MissingImportKind MIK, bool Recover) {\n  assert(!Modules.empty());\n\n  auto NotePrevious = [&] {\n    // FIXME: Suppress the note backtrace even under\n    // -fdiagnostics-show-note-include-stack. We don't care how this\n    // declaration was previously reached.\n    Diag(DeclLoc, diag::note_unreachable_entity) << (int)MIK;\n  };\n\n  // Weed out duplicates from module list.\n  llvm::SmallVector<Module*, 8> UniqueModules;\n  llvm::SmallDenseSet<Module*, 8> UniqueModuleSet;\n  for (auto *M : Modules) {\n    if (M->Kind == Module::GlobalModuleFragment)\n      continue;\n    if (UniqueModuleSet.insert(M).second)\n      UniqueModules.push_back(M);\n  }\n\n  // Try to find a suitable header-name to #include.\n  std::string HeaderName;\n  if (const FileEntry *Header =\n          PP.getHeaderToIncludeForDiagnostics(UseLoc, DeclLoc)) {\n    if (const FileEntry *FE =\n            SourceMgr.getFileEntryForID(SourceMgr.getFileID(UseLoc)))\n      HeaderName = getHeaderNameForHeader(PP, Header, FE->tryGetRealPathName());\n  }\n\n  // If we have a #include we should suggest, or if all definition locations\n  // were in global module fragments, don't suggest an import.\n  if (!HeaderName.empty() || UniqueModules.empty()) {\n    // FIXME: Find a smart place to suggest inserting a #include, and add\n    // a FixItHint there.\n    Diag(UseLoc, diag::err_module_unimported_use_header)\n        << (int)MIK << Decl << !HeaderName.empty() << HeaderName;\n    // Produce a note showing where the entity was declared.\n    NotePrevious();\n    if (Recover)\n      createImplicitModuleImportForErrorRecovery(UseLoc, Modules[0]);\n    return;\n  }\n\n  Modules = UniqueModules;\n\n  if (Modules.size() > 1) {\n    std::string ModuleList;\n    unsigned N = 0;\n    for (Module *M : Modules) {\n      ModuleList += \"\\n        \";\n      if (++N == 5 && N != Modules.size()) {\n        ModuleList += \"[...]\";\n        break;\n      }\n      ModuleList += M->getFullModuleName();\n    }\n\n    Diag(UseLoc, diag::err_module_unimported_use_multiple)\n      << (int)MIK << Decl << ModuleList;\n  } else {\n    // FIXME: Add a FixItHint that imports the corresponding module.\n    Diag(UseLoc, diag::err_module_unimported_use)\n      << (int)MIK << Decl << Modules[0]->getFullModuleName();\n  }\n\n  NotePrevious();\n\n  // Try to recover by implicitly importing this module.\n  if (Recover)\n    createImplicitModuleImportForErrorRecovery(UseLoc, Modules[0]);\n}\n\n/// Diagnose a successfully-corrected typo. Separated from the correction\n/// itself to allow external validation of the result, etc.\n///\n/// \\param Correction The result of performing typo correction.\n/// \\param TypoDiag The diagnostic to produce. This will have the corrected\n///        string added to it (and usually also a fixit).\n/// \\param PrevNote A note to use when indicating the location of the entity to\n///        which we are correcting. Will have the correction string added to it.\n/// \\param ErrorRecovery If \\c true (the default), the caller is going to\n///        recover from the typo as if the corrected string had been typed.\n///        In this case, \\c PDiag must be an error, and we will attach a fixit\n///        to it.\nvoid Sema::diagnoseTypo(const TypoCorrection &Correction,\n                        const PartialDiagnostic &TypoDiag,\n                        const PartialDiagnostic &PrevNote,\n                        bool ErrorRecovery) {\n  std::string CorrectedStr = Correction.getAsString(getLangOpts());\n  std::string CorrectedQuotedStr = Correction.getQuoted(getLangOpts());\n  FixItHint FixTypo = FixItHint::CreateReplacement(\n      Correction.getCorrectionRange(), CorrectedStr);\n\n  // Maybe we're just missing a module import.\n  if (Correction.requiresImport()) {\n    NamedDecl *Decl = Correction.getFoundDecl();\n    assert(Decl && \"import required but no declaration to import\");\n\n    diagnoseMissingImport(Correction.getCorrectionRange().getBegin(), Decl,\n                          MissingImportKind::Declaration, ErrorRecovery);\n    return;\n  }\n\n  Diag(Correction.getCorrectionRange().getBegin(), TypoDiag)\n    << CorrectedQuotedStr << (ErrorRecovery ? FixTypo : FixItHint());\n\n  NamedDecl *ChosenDecl =\n      Correction.isKeyword() ? nullptr : Correction.getFoundDecl();\n  if (PrevNote.getDiagID() && ChosenDecl)\n    Diag(ChosenDecl->getLocation(), PrevNote)\n      << CorrectedQuotedStr << (ErrorRecovery ? FixItHint() : FixTypo);\n\n  // Add any extra diagnostics.\n  for (const PartialDiagnostic &PD : Correction.getExtraDiagnostics())\n    Diag(Correction.getCorrectionRange().getBegin(), PD);\n}\n\nTypoExpr *Sema::createDelayedTypo(std::unique_ptr<TypoCorrectionConsumer> TCC,\n                                  TypoDiagnosticGenerator TDG,\n                                  TypoRecoveryCallback TRC,\n                                  SourceLocation TypoLoc) {\n  assert(TCC && \"createDelayedTypo requires a valid TypoCorrectionConsumer\");\n  auto TE = new (Context) TypoExpr(Context.DependentTy, TypoLoc);\n  auto &State = DelayedTypos[TE];\n  State.Consumer = std::move(TCC);\n  State.DiagHandler = std::move(TDG);\n  State.RecoveryHandler = std::move(TRC);\n  if (TE)\n    TypoExprs.push_back(TE);\n  return TE;\n}\n\nconst Sema::TypoExprState &Sema::getTypoExprState(TypoExpr *TE) const {\n  auto Entry = DelayedTypos.find(TE);\n  assert(Entry != DelayedTypos.end() &&\n         \"Failed to get the state for a TypoExpr!\");\n  return Entry->second;\n}\n\nvoid Sema::clearDelayedTypo(TypoExpr *TE) {\n  DelayedTypos.erase(TE);\n}\n\nvoid Sema::ActOnPragmaDump(Scope *S, SourceLocation IILoc, IdentifierInfo *II) {\n  DeclarationNameInfo Name(II, IILoc);\n  LookupResult R(*this, Name, LookupAnyName, Sema::NotForRedeclaration);\n  R.suppressDiagnostics();\n  R.setHideTags(false);\n  LookupName(R, S);\n  R.dump();\n}\n"}}, "reports": [{"events": [{"location": {"col": 12, "file": 14, "line": 75}, "message": "'Comparator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaLookup.cpp", "reportHash": "808a1f9a36469b6fba7716ab62418e0f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
