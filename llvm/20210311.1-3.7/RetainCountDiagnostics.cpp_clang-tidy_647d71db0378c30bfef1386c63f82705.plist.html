<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"50": {"id": 50, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h", "content": "//===- BugReporter.h - Generate PathDiagnostics -----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines BugReporter, a utility class for generating\n//  PathDiagnostics for analyses based on ProgramState.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_BUGREPORTER_BUGREPORTER_H\n#define LLVM_CLANG_STATICANALYZER_CORE_BUGREPORTER_BUGREPORTER_H\n\n#include \"clang/Analysis/PathDiagnostic.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Lex/Preprocessor.h\"\n#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h\"\n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Core/CheckerManager.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ExplodedGraph.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SVals.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/ImmutableSet.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/SmallSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/ilist.h\"\n#include \"llvm/ADT/ilist_node.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include <cassert>\n#include <memory>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace clang {\n\nclass AnalyzerOptions;\nclass ASTContext;\nclass Decl;\nclass DiagnosticsEngine;\nclass LocationContext;\nclass SourceManager;\nclass Stmt;\n\nnamespace ento {\n\nclass BugType;\nclass CheckerBase;\nclass ExplodedGraph;\nclass ExplodedNode;\nclass ExprEngine;\nclass MemRegion;\nclass SValBuilder;\n\n//===----------------------------------------------------------------------===//\n// Interface for individual bug reports.\n//===----------------------------------------------------------------------===//\n\n/// A mapping from diagnostic consumers to the diagnostics they should\n/// consume.\nusing DiagnosticForConsumerMapTy =\n    llvm::DenseMap<PathDiagnosticConsumer *, std::unique_ptr<PathDiagnostic>>;\n\n/// Interface for classes constructing Stack hints.\n///\n/// If a PathDiagnosticEvent occurs in a different frame than the final\n/// diagnostic the hints can be used to summarize the effect of the call.\nclass StackHintGenerator {\npublic:\n  virtual ~StackHintGenerator() = 0;\n\n  /// Construct the Diagnostic message for the given ExplodedNode.\n  virtual std::string getMessage(const ExplodedNode *N) = 0;\n};\n\n/// Constructs a Stack hint for the given symbol.\n///\n/// The class knows how to construct the stack hint message based on\n/// traversing the CallExpr associated with the call and checking if the given\n/// symbol is returned or is one of the arguments.\n/// The hint can be customized by redefining 'getMessageForX()' methods.\nclass StackHintGeneratorForSymbol : public StackHintGenerator {\nprivate:\n  SymbolRef Sym;\n  std::string Msg;\n\npublic:\n  StackHintGeneratorForSymbol(SymbolRef S, StringRef M) : Sym(S), Msg(M) {}\n  ~StackHintGeneratorForSymbol() override = default;\n\n  /// Search the call expression for the symbol Sym and dispatch the\n  /// 'getMessageForX()' methods to construct a specific message.\n  std::string getMessage(const ExplodedNode *N) override;\n\n  /// Produces the message of the following form:\n  ///   'Msg via Nth parameter'\n  virtual std::string getMessageForArg(const Expr *ArgE, unsigned ArgIndex);\n\n  virtual std::string getMessageForReturn(const CallExpr *CallExpr) {\n    return Msg;\n  }\n\n  virtual std::string getMessageForSymbolNotFound() {\n    return Msg;\n  }\n};\n\n/// This class provides an interface through which checkers can create\n/// individual bug reports.\nclass BugReport {\npublic:\n  enum class Kind { Basic, PathSensitive };\n\nprotected:\n  friend class BugReportEquivClass;\n  friend class BugReporter;\n\n  Kind K;\n  const BugType& BT;\n  std::string ShortDescription;\n  std::string Description;\n\n  SmallVector<SourceRange, 4> Ranges;\n  SmallVector<std::shared_ptr<PathDiagnosticNotePiece>, 4> Notes;\n  SmallVector<FixItHint, 4> Fixits;\n\n  BugReport(Kind kind, const BugType &bt, StringRef desc)\n      : BugReport(kind, bt, \"\", desc) {}\n\n  BugReport(Kind K, const BugType &BT, StringRef ShortDescription,\n            StringRef Description)\n      : K(K), BT(BT), ShortDescription(ShortDescription),\n        Description(Description) {}\n\npublic:\n  virtual ~BugReport() = default;\n\n  Kind getKind() const { return K; }\n\n  const BugType& getBugType() const { return BT; }\n\n  /// A verbose warning message that is appropriate for displaying next to\n  /// the source code that introduces the problem. The description should be\n  /// at least a full sentence starting with a capital letter. The period at\n  /// the end of the warning is traditionally omitted. If the description\n  /// consists of multiple sentences, periods between the sentences are\n  /// encouraged, but the period at the end of the description is still omitted.\n  StringRef getDescription() const { return Description; }\n\n  /// A short general warning message that is appropriate for displaying in\n  /// the list of all reported bugs. It should describe what kind of bug is found\n  /// but does not need to try to go into details of that specific bug.\n  /// Grammatical conventions of getDescription() apply here as well.\n  StringRef getShortDescription(bool UseFallback = true) const {\n    if (ShortDescription.empty() && UseFallback)\n      return Description;\n    return ShortDescription;\n  }\n\n  /// The primary location of the bug report that points at the undesirable\n  /// behavior in the code. UIs should attach the warning description to this\n  /// location. The warning description should describe the bad behavior\n  /// at this location.\n  virtual PathDiagnosticLocation getLocation() const = 0;\n\n  /// The smallest declaration that contains the bug location.\n  /// This is purely cosmetic; the declaration can be displayed to the user\n  /// but it does not affect whether the report is emitted.\n  virtual const Decl *getDeclWithIssue() const = 0;\n\n  /// Get the location on which the report should be uniqued. Two warnings are\n  /// considered to be equivalent whenever they have the same bug types,\n  /// descriptions, and uniqueing locations. Out of a class of equivalent\n  /// warnings only one gets displayed to the user. For most warnings the\n  /// uniqueing location coincides with their location, but sometimes\n  /// it makes sense to use different locations. For example, a leak\n  /// checker can place the warning at the location where the last reference\n  /// to the leaking resource is dropped but at the same time unique the warning\n  /// by where that resource is acquired (allocated).\n  virtual PathDiagnosticLocation getUniqueingLocation() const = 0;\n\n  /// Get the declaration that corresponds to (usually contains) the uniqueing\n  /// location. This is not actively used for uniqueing, i.e. otherwise\n  /// identical reports that have different uniqueing decls will be considered\n  /// equivalent.\n  virtual const Decl *getUniqueingDecl() const = 0;\n\n  /// Add new item to the list of additional notes that need to be attached to\n  /// this report. If the report is path-sensitive, these notes will not be\n  /// displayed as part of the execution path explanation, but will be displayed\n  /// separately. Use bug visitors if you need to add an extra path note.\n  void addNote(StringRef Msg, const PathDiagnosticLocation &Pos,\n               ArrayRef<SourceRange> Ranges = {}) {\n    auto P = std::make_shared<PathDiagnosticNotePiece>(Pos, Msg);\n\n    for (const auto &R : Ranges)\n      P->addRange(R);\n\n    Notes.push_back(std::move(P));\n  }\n\n  ArrayRef<std::shared_ptr<PathDiagnosticNotePiece>> getNotes() {\n    return Notes;\n  }\n\n  /// Add a range to a bug report.\n  ///\n  /// Ranges are used to highlight regions of interest in the source code.\n  /// They should be at the same source code line as the BugReport location.\n  /// By default, the source range of the statement corresponding to the error\n  /// node will be used; add a single invalid range to specify absence of\n  /// ranges.\n  void addRange(SourceRange R) {\n    assert((R.isValid() || Ranges.empty()) && \"Invalid range can only be used \"\n                           \"to specify that the report does not have a range.\");\n    Ranges.push_back(R);\n  }\n\n  /// Get the SourceRanges associated with the report.\n  virtual ArrayRef<SourceRange> getRanges() const {\n    return Ranges;\n  }\n\n  /// Add a fix-it hint to the bug report.\n  ///\n  /// Fix-it hints are the suggested edits to the code that would resolve\n  /// the problem explained by the bug report. Fix-it hints should be\n  /// as conservative as possible because it is not uncommon for the user\n  /// to blindly apply all fixits to their project. Note that it is very hard\n  /// to produce a good fix-it hint for most path-sensitive warnings.\n  void addFixItHint(const FixItHint &F) {\n    Fixits.push_back(F);\n  }\n\n  llvm::ArrayRef<FixItHint> getFixits() const { return Fixits; }\n\n  /// Reports are uniqued to ensure that we do not emit multiple diagnostics\n  /// for each bug.\n  virtual void Profile(llvm::FoldingSetNodeID& hash) const = 0;\n};\n\nclass BasicBugReport : public BugReport {\n  PathDiagnosticLocation Location;\n  const Decl *DeclWithIssue = nullptr;\n\npublic:\n  BasicBugReport(const BugType &bt, StringRef desc, PathDiagnosticLocation l)\n      : BugReport(Kind::Basic, bt, desc), Location(l) {}\n\n  static bool classof(const BugReport *R) {\n    return R->getKind() == Kind::Basic;\n  }\n\n  PathDiagnosticLocation getLocation() const override {\n    assert(Location.isValid());\n    return Location;\n  }\n\n  const Decl *getDeclWithIssue() const override {\n    return DeclWithIssue;\n  }\n\n  PathDiagnosticLocation getUniqueingLocation() const override {\n    return getLocation();\n  }\n\n  const Decl *getUniqueingDecl() const override {\n    return getDeclWithIssue();\n  }\n\n  /// Specifically set the Decl where an issue occurred. This isn't necessary\n  /// for BugReports that cover a path as it will be automatically inferred.\n  void setDeclWithIssue(const Decl *declWithIssue) {\n    DeclWithIssue = declWithIssue;\n  }\n\n  void Profile(llvm::FoldingSetNodeID& hash) const override;\n};\n\nclass PathSensitiveBugReport : public BugReport {\npublic:\n  using VisitorList = SmallVector<std::unique_ptr<BugReporterVisitor>, 8>;\n  using visitor_iterator = VisitorList::iterator;\n  using visitor_range = llvm::iterator_range<visitor_iterator>;\n\nprotected:\n  /// The ExplodedGraph node against which the report was thrown. It corresponds\n  /// to the end of the execution path that demonstrates the bug.\n  const ExplodedNode *ErrorNode = nullptr;\n\n  /// The range that corresponds to ErrorNode's program point. It is usually\n  /// highlighted in the report.\n  const SourceRange ErrorNodeRange;\n\n  /// Profile to identify equivalent bug reports for error report coalescing.\n\n  /// A (stack of) a set of symbols that are registered with this\n  /// report as being \"interesting\", and thus used to help decide which\n  /// diagnostics to include when constructing the final path diagnostic.\n  /// The stack is largely used by BugReporter when generating PathDiagnostics\n  /// for multiple PathDiagnosticConsumers.\n  llvm::DenseMap<SymbolRef, bugreporter::TrackingKind> InterestingSymbols;\n\n  /// A (stack of) set of regions that are registered with this report as being\n  /// \"interesting\", and thus used to help decide which diagnostics\n  /// to include when constructing the final path diagnostic.\n  /// The stack is largely used by BugReporter when generating PathDiagnostics\n  /// for multiple PathDiagnosticConsumers.\n  llvm::DenseMap<const MemRegion *, bugreporter::TrackingKind>\n      InterestingRegions;\n\n  /// A set of location contexts that correspoind to call sites which should be\n  /// considered \"interesting\".\n  llvm::SmallSet<const LocationContext *, 2> InterestingLocationContexts;\n\n  /// A set of custom visitors which generate \"event\" diagnostics at\n  /// interesting points in the path.\n  VisitorList Callbacks;\n\n  /// Used for ensuring the visitors are only added once.\n  llvm::FoldingSet<BugReporterVisitor> CallbacksSet;\n\n  /// When set, this flag disables all callstack pruning from a diagnostic\n  /// path.  This is useful for some reports that want maximum fidelty\n  /// when reporting an issue.\n  bool DoNotPrunePath = false;\n\n  /// Used to track unique reasons why a bug report might be invalid.\n  ///\n  /// \\sa markInvalid\n  /// \\sa removeInvalidation\n  using InvalidationRecord = std::pair<const void *, const void *>;\n\n  /// If non-empty, this bug report is likely a false positive and should not be\n  /// shown to the user.\n  ///\n  /// \\sa markInvalid\n  /// \\sa removeInvalidation\n  llvm::SmallSet<InvalidationRecord, 4> Invalidations;\n\n  /// Conditions we're already tracking.\n  llvm::SmallSet<const ExplodedNode *, 4> TrackedConditions;\n\n  /// Reports with different uniqueing locations are considered to be different\n  /// for the purposes of deduplication.\n  PathDiagnosticLocation UniqueingLocation;\n  const Decl *UniqueingDecl;\n\n  const Stmt *getStmt() const;\n\n  /// If an event occurs in a different frame than the final diagnostic,\n  /// supply a message that will be used to construct an extra hint on the\n  /// returns from all the calls on the stack from this event to the final\n  /// diagnostic.\n  // FIXME: Allow shared_ptr keys in DenseMap?\n  std::map<PathDiagnosticPieceRef, std::unique_ptr<StackHintGenerator>>\n      StackHints;\n\npublic:\n  PathSensitiveBugReport(const BugType &bt, StringRef desc,\n                         const ExplodedNode *errorNode)\n      : PathSensitiveBugReport(bt, desc, desc, errorNode) {}\n\n  PathSensitiveBugReport(const BugType &bt, StringRef shortDesc, StringRef desc,\n                         const ExplodedNode *errorNode)\n      : PathSensitiveBugReport(bt, shortDesc, desc, errorNode,\n                               /*LocationToUnique*/ {},\n                               /*DeclToUnique*/ nullptr) {}\n\n  /// Create a PathSensitiveBugReport with a custom uniqueing location.\n  ///\n  /// The reports that have the same report location, description, bug type, and\n  /// ranges are uniqued - only one of the equivalent reports will be presented\n  /// to the user. This method allows to rest the location which should be used\n  /// for uniquing reports. For example, memory leaks checker, could set this to\n  /// the allocation site, rather then the location where the bug is reported.\n  PathSensitiveBugReport(const BugType &bt, StringRef desc,\n                         const ExplodedNode *errorNode,\n                         PathDiagnosticLocation LocationToUnique,\n                         const Decl *DeclToUnique)\n      : PathSensitiveBugReport(bt, desc, desc, errorNode, LocationToUnique,\n                               DeclToUnique) {}\n\n  PathSensitiveBugReport(const BugType &bt, StringRef shortDesc, StringRef desc,\n                         const ExplodedNode *errorNode,\n                         PathDiagnosticLocation LocationToUnique,\n                         const Decl *DeclToUnique);\n\n  static bool classof(const BugReport *R) {\n    return R->getKind() == Kind::PathSensitive;\n  }\n\n  const ExplodedNode *getErrorNode() const { return ErrorNode; }\n\n  /// Indicates whether or not any path pruning should take place\n  /// when generating a PathDiagnostic from this BugReport.\n  bool shouldPrunePath() const { return !DoNotPrunePath; }\n\n  /// Disable all path pruning when generating a PathDiagnostic.\n  void disablePathPruning() { DoNotPrunePath = true; }\n\n  /// Get the location on which the report should be uniqued.\n  PathDiagnosticLocation getUniqueingLocation() const override {\n    return UniqueingLocation;\n  }\n\n  /// Get the declaration containing the uniqueing location.\n  const Decl *getUniqueingDecl() const override {\n    return UniqueingDecl;\n  }\n\n  const Decl *getDeclWithIssue() const override;\n\n  ArrayRef<SourceRange> getRanges() const override;\n\n  PathDiagnosticLocation getLocation() const override;\n\n  /// Marks a symbol as interesting. Different kinds of interestingness will\n  /// be processed differently by visitors (e.g. if the tracking kind is\n  /// condition, will append \"will be used as a condition\" to the message).\n  void markInteresting(SymbolRef sym, bugreporter::TrackingKind TKind =\n                                          bugreporter::TrackingKind::Thorough);\n\n  /// Marks a region as interesting. Different kinds of interestingness will\n  /// be processed differently by visitors (e.g. if the tracking kind is\n  /// condition, will append \"will be used as a condition\" to the message).\n  void markInteresting(\n      const MemRegion *R,\n      bugreporter::TrackingKind TKind = bugreporter::TrackingKind::Thorough);\n\n  /// Marks a symbolic value as interesting. Different kinds of interestingness\n  /// will be processed differently by visitors (e.g. if the tracking kind is\n  /// condition, will append \"will be used as a condition\" to the message).\n  void markInteresting(SVal V, bugreporter::TrackingKind TKind =\n                                   bugreporter::TrackingKind::Thorough);\n  void markInteresting(const LocationContext *LC);\n\n  bool isInteresting(SymbolRef sym) const;\n  bool isInteresting(const MemRegion *R) const;\n  bool isInteresting(SVal V) const;\n  bool isInteresting(const LocationContext *LC) const;\n\n  Optional<bugreporter::TrackingKind>\n  getInterestingnessKind(SymbolRef sym) const;\n\n  Optional<bugreporter::TrackingKind>\n  getInterestingnessKind(const MemRegion *R) const;\n\n  Optional<bugreporter::TrackingKind> getInterestingnessKind(SVal V) const;\n\n  /// Returns whether or not this report should be considered valid.\n  ///\n  /// Invalid reports are those that have been classified as likely false\n  /// positives after the fact.\n  bool isValid() const {\n    return Invalidations.empty();\n  }\n\n  /// Marks the current report as invalid, meaning that it is probably a false\n  /// positive and should not be reported to the user.\n  ///\n  /// The \\p Tag and \\p Data arguments are intended to be opaque identifiers for\n  /// this particular invalidation, where \\p Tag represents the visitor\n  /// responsible for invalidation, and \\p Data represents the reason this\n  /// visitor decided to invalidate the bug report.\n  ///\n  /// \\sa removeInvalidation\n  void markInvalid(const void *Tag, const void *Data) {\n    Invalidations.insert(std::make_pair(Tag, Data));\n  }\n\n  /// Profile to identify equivalent bug reports for error report coalescing.\n  /// Reports are uniqued to ensure that we do not emit multiple diagnostics\n  /// for each bug.\n  void Profile(llvm::FoldingSetNodeID &hash) const override;\n\n  /// Add custom or predefined bug report visitors to this report.\n  ///\n  /// The visitors should be used when the default trace is not sufficient.\n  /// For example, they allow constructing a more elaborate trace.\n  /// \\sa registerConditionVisitor(), registerTrackNullOrUndefValue(),\n  /// registerFindLastStore(), registerNilReceiverVisitor(), and\n  /// registerVarDeclsLastStore().\n  void addVisitor(std::unique_ptr<BugReporterVisitor> visitor);\n\n  /// Remove all visitors attached to this bug report.\n  void clearVisitors();\n\n  /// Iterators through the custom diagnostic visitors.\n  visitor_iterator visitor_begin() { return Callbacks.begin(); }\n  visitor_iterator visitor_end() { return Callbacks.end(); }\n  visitor_range visitors() { return {visitor_begin(), visitor_end()}; }\n\n  /// Notes that the condition of the CFGBlock associated with \\p Cond is\n  /// being tracked.\n  /// \\returns false if the condition is already being tracked.\n  bool addTrackedCondition(const ExplodedNode *Cond) {\n    return TrackedConditions.insert(Cond).second;\n  }\n\n  void addCallStackHint(PathDiagnosticPieceRef Piece,\n                        std::unique_ptr<StackHintGenerator> StackHint) {\n    StackHints[Piece] = std::move(StackHint);\n  }\n\n  bool hasCallStackHint(PathDiagnosticPieceRef Piece) const {\n    return StackHints.count(Piece) > 0;\n  }\n\n  /// Produce the hint for the given node. The node contains\n  /// information about the call for which the diagnostic can be generated.\n  std::string\n  getCallStackMessage(PathDiagnosticPieceRef Piece,\n                      const ExplodedNode *N) const {\n    auto I = StackHints.find(Piece);\n    if (I != StackHints.end())\n      return I->second->getMessage(N);\n    return \"\";\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// BugTypes (collections of related reports).\n//===----------------------------------------------------------------------===//\n\nclass BugReportEquivClass : public llvm::FoldingSetNode {\n  friend class BugReporter;\n\n  /// List of *owned* BugReport objects.\n  llvm::SmallVector<std::unique_ptr<BugReport>, 4> Reports;\n\n  void AddReport(std::unique_ptr<BugReport> &&R) {\n    Reports.push_back(std::move(R));\n  }\n\npublic:\n  BugReportEquivClass(std::unique_ptr<BugReport> R) { AddReport(std::move(R)); }\n\n  ArrayRef<std::unique_ptr<BugReport>> getReports() const { return Reports; }\n\n  void Profile(llvm::FoldingSetNodeID& ID) const {\n    assert(!Reports.empty());\n    Reports.front()->Profile(ID);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// BugReporter and friends.\n//===----------------------------------------------------------------------===//\n\nclass BugReporterData {\npublic:\n  virtual ~BugReporterData() = default;\n\n  virtual ArrayRef<PathDiagnosticConsumer*> getPathDiagnosticConsumers() = 0;\n  virtual ASTContext &getASTContext() = 0;\n  virtual SourceManager &getSourceManager() = 0;\n  virtual AnalyzerOptions &getAnalyzerOptions() = 0;\n  virtual Preprocessor &getPreprocessor() = 0;\n};\n\n/// BugReporter is a utility class for generating PathDiagnostics for analysis.\n/// It collects the BugReports and BugTypes and knows how to generate\n/// and flush the corresponding diagnostics.\n///\n/// The base class is used for generating path-insensitive\nclass BugReporter {\nprivate:\n  BugReporterData& D;\n\n  /// Generate and flush the diagnostics for the given bug report.\n  void FlushReport(BugReportEquivClass& EQ);\n\n  /// The set of bug reports tracked by the BugReporter.\n  llvm::FoldingSet<BugReportEquivClass> EQClasses;\n\n  /// A vector of BugReports for tracking the allocated pointers and cleanup.\n  std::vector<BugReportEquivClass *> EQClassesVector;\n\npublic:\n  BugReporter(BugReporterData &d);\n  virtual ~BugReporter();\n\n  /// Generate and flush diagnostics for all bug reports.\n  void FlushReports();\n\n  ArrayRef<PathDiagnosticConsumer*> getPathDiagnosticConsumers() {\n    return D.getPathDiagnosticConsumers();\n  }\n\n  /// Iterator over the set of BugReports tracked by the BugReporter.\n  using EQClasses_iterator = llvm::FoldingSet<BugReportEquivClass>::iterator;\n  EQClasses_iterator EQClasses_begin() { return EQClasses.begin(); }\n  EQClasses_iterator EQClasses_end() { return EQClasses.end(); }\n\n  ASTContext &getContext() { return D.getASTContext(); }\n\n  const SourceManager &getSourceManager() { return D.getSourceManager(); }\n\n  const AnalyzerOptions &getAnalyzerOptions() { return D.getAnalyzerOptions(); }\n\n  Preprocessor &getPreprocessor() { return D.getPreprocessor(); }\n\n  /// Add the given report to the set of reports tracked by BugReporter.\n  ///\n  /// The reports are usually generated by the checkers. Further, they are\n  /// folded based on the profile value, which is done to coalesce similar\n  /// reports.\n  virtual void emitReport(std::unique_ptr<BugReport> R);\n\n  void EmitBasicReport(const Decl *DeclWithIssue, const CheckerBase *Checker,\n                       StringRef BugName, StringRef BugCategory,\n                       StringRef BugStr, PathDiagnosticLocation Loc,\n                       ArrayRef<SourceRange> Ranges = None,\n                       ArrayRef<FixItHint> Fixits = None);\n\n  void EmitBasicReport(const Decl *DeclWithIssue, CheckerNameRef CheckerName,\n                       StringRef BugName, StringRef BugCategory,\n                       StringRef BugStr, PathDiagnosticLocation Loc,\n                       ArrayRef<SourceRange> Ranges = None,\n                       ArrayRef<FixItHint> Fixits = None);\n\nprivate:\n  llvm::StringMap<std::unique_ptr<BugType>> StrBugTypes;\n\n  /// Returns a BugType that is associated with the given name and\n  /// category.\n  BugType *getBugTypeForName(CheckerNameRef CheckerName, StringRef name,\n                             StringRef category);\n\n  virtual BugReport *\n  findReportInEquivalenceClass(BugReportEquivClass &eqClass,\n                               SmallVectorImpl<BugReport *> &bugReports) {\n    return eqClass.getReports()[0].get();\n  }\n\nprotected:\n  /// Generate the diagnostics for the given bug report.\n  virtual std::unique_ptr<DiagnosticForConsumerMapTy>\n  generateDiagnosticForConsumerMap(BugReport *exampleReport,\n                                   ArrayRef<PathDiagnosticConsumer *> consumers,\n                                   ArrayRef<BugReport *> bugReports);\n};\n\n/// GRBugReporter is used for generating path-sensitive reports.\nclass PathSensitiveBugReporter final : public BugReporter {\n  ExprEngine& Eng;\n\n  BugReport *findReportInEquivalenceClass(\n      BugReportEquivClass &eqClass,\n      SmallVectorImpl<BugReport *> &bugReports) override;\n\n  /// Generate the diagnostics for the given bug report.\n  std::unique_ptr<DiagnosticForConsumerMapTy>\n  generateDiagnosticForConsumerMap(BugReport *exampleReport,\n                                   ArrayRef<PathDiagnosticConsumer *> consumers,\n                                   ArrayRef<BugReport *> bugReports) override;\npublic:\n  PathSensitiveBugReporter(BugReporterData& d, ExprEngine& eng)\n      : BugReporter(d), Eng(eng) {}\n\n  /// getGraph - Get the exploded graph created by the analysis engine\n  ///  for the analyzed method or function.\n  const ExplodedGraph &getGraph() const;\n\n  /// getStateManager - Return the state manager used by the analysis\n  ///  engine.\n  ProgramStateManager &getStateManager() const;\n\n  /// \\p bugReports A set of bug reports within a *single* equivalence class\n  ///\n  /// \\return A mapping from consumers to the corresponding diagnostics.\n  /// Iterates through the bug reports within a single equivalence class,\n  /// stops at a first non-invalidated report.\n  std::unique_ptr<DiagnosticForConsumerMapTy> generatePathDiagnostics(\n      ArrayRef<PathDiagnosticConsumer *> consumers,\n      ArrayRef<PathSensitiveBugReport *> &bugReports);\n\n  void emitReport(std::unique_ptr<BugReport> R) override;\n};\n\n\nclass BugReporterContext {\n  PathSensitiveBugReporter &BR;\n\n  virtual void anchor();\n\npublic:\n  BugReporterContext(PathSensitiveBugReporter &br) : BR(br) {}\n\n  virtual ~BugReporterContext() = default;\n\n  PathSensitiveBugReporter& getBugReporter() { return BR; }\n\n  ProgramStateManager& getStateManager() const {\n    return BR.getStateManager();\n  }\n\n  ASTContext &getASTContext() const {\n    return BR.getContext();\n  }\n\n  const SourceManager& getSourceManager() const {\n    return BR.getSourceManager();\n  }\n\n  const AnalyzerOptions &getAnalyzerOptions() const {\n    return BR.getAnalyzerOptions();\n  }\n};\n\n\n/// The tag upon which the TagVisitor reacts. Add these in order to display\n/// additional PathDiagnosticEventPieces along the path.\nclass NoteTag : public ProgramPointTag {\npublic:\n  using Callback =\n      std::function<std::string(BugReporterContext &,\n                                PathSensitiveBugReport &)>;\n\nprivate:\n  static int Kind;\n\n  const Callback Cb;\n  const bool IsPrunable;\n\n  NoteTag(Callback &&Cb, bool IsPrunable)\n      : ProgramPointTag(&Kind), Cb(std::move(Cb)), IsPrunable(IsPrunable) {}\n\npublic:\n  static bool classof(const ProgramPointTag *T) {\n    return T->getTagKind() == &Kind;\n  }\n\n  Optional<std::string> generateMessage(BugReporterContext &BRC,\n                                        PathSensitiveBugReport &R) const {\n    std::string Msg = Cb(BRC, R);\n    if (Msg.empty())\n      return None;\n\n    return std::move(Msg);\n  }\n\n  StringRef getTagDescription() const override {\n    // TODO: Remember a few examples of generated messages\n    // and display them in the ExplodedGraph dump by\n    // returning them from this function.\n    return \"Note Tag\";\n  }\n\n  bool isPrunable() const { return IsPrunable; }\n\n  // Manage memory for NoteTag objects.\n  class Factory {\n    std::vector<std::unique_ptr<NoteTag>> Tags;\n\n  public:\n    const NoteTag *makeNoteTag(Callback &&Cb, bool IsPrunable = false) {\n      // We cannot use std::make_unique because we cannot access the private\n      // constructor from inside it.\n      std::unique_ptr<NoteTag> T(new NoteTag(std::move(Cb), IsPrunable));\n      Tags.push_back(std::move(T));\n      return Tags.back().get();\n    }\n  };\n\n  friend class TagVisitor;\n};\n\n} // namespace ento\n\n} // namespace clang\n\n#endif // LLVM_CLANG_STATICANALYZER_CORE_BUGREPORTER_BUGREPORTER_H\n"}, "51": {"id": 51, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h", "content": "//===- BugReporterVisitors.h - Generate PathDiagnostics ---------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file declares BugReporterVisitors, which are used to generate enhanced\n//  diagnostic traces.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_BUGREPORTER_BUGREPORTERVISITORS_H\n#define LLVM_CLANG_STATICANALYZER_CORE_BUGREPORTER_BUGREPORTERVISITORS_H\n\n#include \"clang/Analysis/ProgramPoint.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/RangedConstraintManager.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SVals.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <memory>\n\nnamespace clang {\n\nclass BinaryOperator;\nclass CFGBlock;\nclass DeclRefExpr;\nclass Expr;\nclass Stmt;\n\nnamespace ento {\n\nclass PathSensitiveBugReport;\nclass BugReporterContext;\nclass ExplodedNode;\nclass MemRegion;\nclass PathDiagnosticPiece;\nusing PathDiagnosticPieceRef = std::shared_ptr<PathDiagnosticPiece>;\n\n/// BugReporterVisitors are used to add custom diagnostics along a path.\nclass BugReporterVisitor : public llvm::FoldingSetNode {\npublic:\n  BugReporterVisitor() = default;\n  BugReporterVisitor(const BugReporterVisitor &) = default;\n  BugReporterVisitor(BugReporterVisitor &&) {}\n  virtual ~BugReporterVisitor();\n\n  /// Return a diagnostic piece which should be associated with the\n  /// given node.\n  /// Note that this function does *not* get run on the very last node\n  /// of the report, as the PathDiagnosticPiece associated with the\n  /// last node should be unique.\n  /// Use \\ref getEndPath to customize the note associated with the report\n  /// end instead.\n  ///\n  /// The last parameter can be used to register a new visitor with the given\n  /// BugReport while processing a node.\n  virtual PathDiagnosticPieceRef VisitNode(const ExplodedNode *Succ,\n                                           BugReporterContext &BRC,\n                                           PathSensitiveBugReport &BR) = 0;\n\n  /// Last function called on the visitor, no further calls to VisitNode\n  /// would follow.\n  virtual void finalizeVisitor(BugReporterContext &BRC,\n                               const ExplodedNode *EndPathNode,\n                               PathSensitiveBugReport &BR);\n\n  /// Provide custom definition for the final diagnostic piece on the\n  /// path - the piece, which is displayed before the path is expanded.\n  ///\n  /// NOTE that this function can be implemented on at most one used visitor,\n  /// and otherwise it crahes at runtime.\n  virtual PathDiagnosticPieceRef getEndPath(BugReporterContext &BRC,\n                                            const ExplodedNode *N,\n                                            PathSensitiveBugReport &BR);\n\n  virtual void Profile(llvm::FoldingSetNodeID &ID) const = 0;\n\n  /// Generates the default final diagnostic piece.\n  static PathDiagnosticPieceRef\n  getDefaultEndPath(const BugReporterContext &BRC, const ExplodedNode *N,\n                    const PathSensitiveBugReport &BR);\n};\n\nnamespace bugreporter {\n\n/// Specifies the type of tracking for an expression.\nenum class TrackingKind {\n  /// Default tracking kind -- specifies that as much information should be\n  /// gathered about the tracked expression value as possible.\n  Thorough,\n  /// Specifies that a more moderate tracking should be used for the expression\n  /// value. This will essentially make sure that functions relevant to the it\n  /// aren't pruned, but otherwise relies on the user reading the code or\n  /// following the arrows.\n  Condition\n};\n\n/// Attempts to add visitors to track expression value back to its point of\n/// origin.\n///\n/// \\param N A node \"downstream\" from the evaluation of the statement.\n/// \\param E The expression value which we are tracking\n/// \\param R The bug report to which visitors should be attached.\n/// \\param EnableNullFPSuppression Whether we should employ false positive\n///         suppression (inlined defensive checks, returned null).\n///\n/// \\return Whether or not the function was able to add visitors for this\n///         statement. Note that returning \\c true does not actually imply\n///         that any visitors were added.\nbool trackExpressionValue(const ExplodedNode *N, const Expr *E,\n                          PathSensitiveBugReport &R,\n                          TrackingKind TKind = TrackingKind::Thorough,\n                          bool EnableNullFPSuppression = true);\n\nconst Expr *getDerefExpr(const Stmt *S);\n\n} // namespace bugreporter\n\n/// Finds last store into the given region,\n/// which is different from a given symbolic value.\nclass FindLastStoreBRVisitor final : public BugReporterVisitor {\n  const MemRegion *R;\n  SVal V;\n  bool Satisfied = false;\n\n  /// If the visitor is tracking the value directly responsible for the\n  /// bug, we are going to employ false positive suppression.\n  bool EnableNullFPSuppression;\n\n  using TrackingKind = bugreporter::TrackingKind;\n  TrackingKind TKind;\n  const StackFrameContext *OriginSFC;\n\npublic:\n  /// \\param V We're searching for the store where \\c R received this value.\n  /// \\param R The region we're tracking.\n  /// \\param TKind May limit the amount of notes added to the bug report.\n  /// \\param OriginSFC Only adds notes when the last store happened in a\n  ///        different stackframe to this one. Disregarded if the tracking kind\n  ///        is thorough.\n  ///        This is useful, because for non-tracked regions, notes about\n  ///        changes to its value in a nested stackframe could be pruned, and\n  ///        this visitor can prevent that without polluting the bugpath too\n  ///        much.\n  FindLastStoreBRVisitor(KnownSVal V, const MemRegion *R,\n                         bool InEnableNullFPSuppression, TrackingKind TKind,\n                         const StackFrameContext *OriginSFC = nullptr)\n      : R(R), V(V), EnableNullFPSuppression(InEnableNullFPSuppression),\n        TKind(TKind), OriginSFC(OriginSFC) {\n    assert(R);\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n\n  PathDiagnosticPieceRef VisitNode(const ExplodedNode *N,\n                                   BugReporterContext &BRC,\n                                   PathSensitiveBugReport &BR) override;\n};\n\nclass TrackConstraintBRVisitor final : public BugReporterVisitor {\n  DefinedSVal Constraint;\n  bool Assumption;\n  bool IsSatisfied = false;\n  bool IsZeroCheck;\n\n  /// We should start tracking from the last node along the path in which the\n  /// value is constrained.\n  bool IsTrackingTurnedOn = false;\n\npublic:\n  TrackConstraintBRVisitor(DefinedSVal constraint, bool assumption)\n      : Constraint(constraint), Assumption(assumption),\n        IsZeroCheck(!Assumption && Constraint.getAs<Loc>()) {}\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n\n  /// Return the tag associated with this visitor.  This tag will be used\n  /// to make all PathDiagnosticPieces created by this visitor.\n  static const char *getTag();\n\n  PathDiagnosticPieceRef VisitNode(const ExplodedNode *N,\n                                   BugReporterContext &BRC,\n                                   PathSensitiveBugReport &BR) override;\n\nprivate:\n  /// Checks if the constraint is valid in the current state.\n  bool isUnderconstrained(const ExplodedNode *N) const;\n};\n\n/// \\class NilReceiverBRVisitor\n/// Prints path notes when a message is sent to a nil receiver.\nclass NilReceiverBRVisitor final : public BugReporterVisitor {\npublic:\n  void Profile(llvm::FoldingSetNodeID &ID) const override {\n    static int x = 0;\n    ID.AddPointer(&x);\n  }\n\n  PathDiagnosticPieceRef VisitNode(const ExplodedNode *N,\n                                   BugReporterContext &BRC,\n                                   PathSensitiveBugReport &BR) override;\n\n  /// If the statement is a message send expression with nil receiver, returns\n  /// the receiver expression. Returns NULL otherwise.\n  static const Expr *getNilReceiver(const Stmt *S, const ExplodedNode *N);\n};\n\n/// Visitor that tries to report interesting diagnostics from conditions.\nclass ConditionBRVisitor final : public BugReporterVisitor {\n  // FIXME: constexpr initialization isn't supported by MSVC2013.\n  constexpr static llvm::StringLiteral GenericTrueMessage =\n      \"Assuming the condition is true\";\n  constexpr static llvm::StringLiteral GenericFalseMessage =\n      \"Assuming the condition is false\";\n\npublic:\n  void Profile(llvm::FoldingSetNodeID &ID) const override {\n    static int x = 0;\n    ID.AddPointer(&x);\n  }\n\n  /// Return the tag associated with this visitor.  This tag will be used\n  /// to make all PathDiagnosticPieces created by this visitor.\n  static const char *getTag();\n\n  PathDiagnosticPieceRef VisitNode(const ExplodedNode *N,\n                                   BugReporterContext &BRC,\n                                   PathSensitiveBugReport &BR) override;\n\n  PathDiagnosticPieceRef VisitNodeImpl(const ExplodedNode *N,\n                                       BugReporterContext &BRC,\n                                       PathSensitiveBugReport &BR);\n\n  PathDiagnosticPieceRef\n  VisitTerminator(const Stmt *Term, const ExplodedNode *N,\n                  const CFGBlock *SrcBlk, const CFGBlock *DstBlk,\n                  PathSensitiveBugReport &R, BugReporterContext &BRC);\n\n  PathDiagnosticPieceRef VisitTrueTest(const Expr *Cond,\n                                       BugReporterContext &BRC,\n                                       PathSensitiveBugReport &R,\n                                       const ExplodedNode *N, bool TookTrue);\n\n  PathDiagnosticPieceRef VisitTrueTest(const Expr *Cond, const DeclRefExpr *DR,\n                                       BugReporterContext &BRC,\n                                       PathSensitiveBugReport &R,\n                                       const ExplodedNode *N, bool TookTrue,\n                                       bool IsAssuming);\n\n  PathDiagnosticPieceRef\n  VisitTrueTest(const Expr *Cond, const BinaryOperator *BExpr,\n                BugReporterContext &BRC, PathSensitiveBugReport &R,\n                const ExplodedNode *N, bool TookTrue, bool IsAssuming);\n\n  PathDiagnosticPieceRef VisitTrueTest(const Expr *Cond, const MemberExpr *ME,\n                                       BugReporterContext &BRC,\n                                       PathSensitiveBugReport &R,\n                                       const ExplodedNode *N, bool TookTrue,\n                                       bool IsAssuming);\n\n  PathDiagnosticPieceRef\n  VisitConditionVariable(StringRef LhsString, const Expr *CondVarExpr,\n                         BugReporterContext &BRC, PathSensitiveBugReport &R,\n                         const ExplodedNode *N, bool TookTrue);\n\n  /// Tries to print the value of the given expression.\n  ///\n  /// \\param CondVarExpr The expression to print its value.\n  /// \\param Out The stream to print.\n  /// \\param N The node where we encountered the condition.\n  /// \\param TookTrue Whether we took the \\c true branch of the condition.\n  ///\n  /// \\return Whether the print was successful. (The printing is successful if\n  ///         we model the value and we could obtain it.)\n  bool printValue(const Expr *CondVarExpr, raw_ostream &Out,\n                  const ExplodedNode *N, bool TookTrue, bool IsAssuming);\n\n  bool patternMatch(const Expr *Ex,\n                    const Expr *ParentEx,\n                    raw_ostream &Out,\n                    BugReporterContext &BRC,\n                    PathSensitiveBugReport &R,\n                    const ExplodedNode *N,\n                    Optional<bool> &prunable,\n                    bool IsSameFieldName);\n\n  static bool isPieceMessageGeneric(const PathDiagnosticPiece *Piece);\n};\n\n/// Suppress reports that might lead to known false positives.\n///\n/// Currently this suppresses reports based on locations of bugs.\nclass LikelyFalsePositiveSuppressionBRVisitor final\n    : public BugReporterVisitor {\npublic:\n  static void *getTag() {\n    static int Tag = 0;\n    return static_cast<void *>(&Tag);\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override {\n    ID.AddPointer(getTag());\n  }\n\n  PathDiagnosticPieceRef VisitNode(const ExplodedNode *, BugReporterContext &,\n                                   PathSensitiveBugReport &) override {\n    return nullptr;\n  }\n\n  void finalizeVisitor(BugReporterContext &BRC, const ExplodedNode *N,\n                       PathSensitiveBugReport &BR) override;\n};\n\n/// When a region containing undefined value or '0' value is passed\n/// as an argument in a call, marks the call as interesting.\n///\n/// As a result, BugReporter will not prune the path through the function even\n/// if the region's contents are not modified/accessed by the call.\nclass UndefOrNullArgVisitor final : public BugReporterVisitor {\n  /// The interesting memory region this visitor is tracking.\n  const MemRegion *R;\n\npublic:\n  UndefOrNullArgVisitor(const MemRegion *InR) : R(InR) {}\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override {\n    static int Tag = 0;\n    ID.AddPointer(&Tag);\n    ID.AddPointer(R);\n  }\n\n  PathDiagnosticPieceRef VisitNode(const ExplodedNode *N,\n                                   BugReporterContext &BRC,\n                                   PathSensitiveBugReport &BR) override;\n};\n\nclass SuppressInlineDefensiveChecksVisitor final : public BugReporterVisitor {\n  /// The symbolic value for which we are tracking constraints.\n  /// This value is constrained to null in the end of path.\n  DefinedSVal V;\n\n  /// Track if we found the node where the constraint was first added.\n  bool IsSatisfied = false;\n\n  /// Since the visitors can be registered on nodes previous to the last\n  /// node in the BugReport, but the path traversal always starts with the last\n  /// node, the visitor invariant (that we start with a node in which V is null)\n  /// might not hold when node visitation starts. We are going to start tracking\n  /// from the last node in which the value is null.\n  bool IsTrackingTurnedOn = false;\n\npublic:\n  SuppressInlineDefensiveChecksVisitor(DefinedSVal Val, const ExplodedNode *N);\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n\n  /// Return the tag associated with this visitor.  This tag will be used\n  /// to make all PathDiagnosticPieces created by this visitor.\n  static const char *getTag();\n\n  PathDiagnosticPieceRef VisitNode(const ExplodedNode *Succ,\n                                   BugReporterContext &BRC,\n                                   PathSensitiveBugReport &BR) override;\n};\n\n/// The bug visitor will walk all the nodes in a path and collect all the\n/// constraints. When it reaches the root node, will create a refutation\n/// manager and check if the constraints are satisfiable\nclass FalsePositiveRefutationBRVisitor final : public BugReporterVisitor {\nprivate:\n  /// Holds the constraints in a given path\n  ConstraintMap Constraints;\n\npublic:\n  FalsePositiveRefutationBRVisitor();\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n\n  PathDiagnosticPieceRef VisitNode(const ExplodedNode *N,\n                                   BugReporterContext &BRC,\n                                   PathSensitiveBugReport &BR) override;\n\n  void finalizeVisitor(BugReporterContext &BRC, const ExplodedNode *EndPathNode,\n                       PathSensitiveBugReport &BR) override;\n  void addConstraints(const ExplodedNode *N,\n                      bool OverwriteConstraintsOnExistingSyms);\n};\n\n/// The visitor detects NoteTags and displays the event notes they contain.\nclass TagVisitor : public BugReporterVisitor {\npublic:\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n\n  PathDiagnosticPieceRef VisitNode(const ExplodedNode *N,\n                                   BugReporterContext &BRC,\n                                   PathSensitiveBugReport &R) override;\n};\n\n} // namespace ento\n\n} // namespace clang\n\n#endif // LLVM_CLANG_STATICANALYZER_CORE_BUGREPORTER_BUGREPORTERVISITORS_H\n"}, "52": {"id": 52, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugType.h", "content": "//===---  BugType.h - Bug Information Description ---------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines BugType, a class representing a bug type.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_BUGREPORTER_BUGTYPE_H\n#define LLVM_CLANG_STATICANALYZER_CORE_BUGREPORTER_BUGTYPE_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/StaticAnalyzer/Core/BugReporter/CommonBugCategories.h\"\n#include \"clang/StaticAnalyzer/Core/Checker.h\"\n#include <string>\n\nnamespace clang {\n\nnamespace ento {\n\nclass BugReporter;\nclass ExplodedNode;\nclass ExprEngine;\n\nclass BugType {\nprivate:\n  const CheckerNameRef CheckerName;\n  const std::string Description;\n  const std::string Category;\n  const CheckerBase *Checker;\n  bool SuppressOnSink;\n\n  virtual void anchor();\n\npublic:\n  BugType(CheckerNameRef CheckerName, StringRef Name, StringRef Cat,\n          bool SuppressOnSink = false)\n      : CheckerName(CheckerName), Description(Name), Category(Cat),\n        Checker(nullptr), SuppressOnSink(SuppressOnSink) {}\n  BugType(const CheckerBase *Checker, StringRef Name, StringRef Cat,\n          bool SuppressOnSink = false)\n      : CheckerName(Checker->getCheckerName()), Description(Name),\n        Category(Cat), Checker(Checker), SuppressOnSink(SuppressOnSink) {}\n  virtual ~BugType() = default;\n\n  StringRef getDescription() const { return Description; }\n  StringRef getCategory() const { return Category; }\n  StringRef getCheckerName() const {\n    // FIXME: This is a workaround to ensure that the correct checerk name is\n    // used. The checker names are set after the constructors are run.\n    // In case the BugType object is initialized in the checker's ctor\n    // the CheckerName field will be empty. To circumvent this problem we use\n    // CheckerBase whenever it is possible.\n    StringRef Ret = Checker ? Checker->getCheckerName() : CheckerName;\n    assert(!Ret.empty() && \"Checker name is not set properly.\");\n    return Ret;\n  }\n\n  /// isSuppressOnSink - Returns true if bug reports associated with this bug\n  ///  type should be suppressed if the end node of the report is post-dominated\n  ///  by a sink node.\n  bool isSuppressOnSink() const { return SuppressOnSink; }\n};\n\nclass BuiltinBug : public BugType {\n  const std::string desc;\n  void anchor() override;\npublic:\n  BuiltinBug(class CheckerNameRef checker, const char *name,\n             const char *description)\n      : BugType(checker, name, categories::LogicError), desc(description) {}\n\n  BuiltinBug(const CheckerBase *checker, const char *name,\n             const char *description)\n      : BugType(checker, name, categories::LogicError), desc(description) {}\n\n  BuiltinBug(class CheckerNameRef checker, const char *name)\n      : BugType(checker, name, categories::LogicError), desc(name) {}\n\n  BuiltinBug(const CheckerBase *checker, const char *name)\n      : BugType(checker, name, categories::LogicError), desc(name) {}\n\n  StringRef getDescription() const { return desc; }\n};\n\n} // namespace ento\n\n} // end clang namespace\n#endif\n"}, "53": {"id": 53, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/Checker.h", "content": "//== Checker.h - Registration mechanism for checkers -------------*- C++ -*--=//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines Checker, used to create and register checkers.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_CHECKER_H\n#define LLVM_CLANG_STATICANALYZER_CORE_CHECKER_H\n\n#include \"clang/Analysis/ProgramPoint.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/StaticAnalyzer/Core/CheckerManager.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SVals.h\"\n#include \"llvm/Support/Casting.h\"\n\nnamespace clang {\nnamespace ento {\n  class BugReporter;\n\nnamespace check {\n\ntemplate <typename DECL>\nclass ASTDecl {\n  template <typename CHECKER>\n  static void _checkDecl(void *checker, const Decl *D, AnalysisManager& mgr,\n                         BugReporter &BR) {\n    ((const CHECKER *)checker)->checkASTDecl(cast<DECL>(D), mgr, BR);\n  }\n\n  static bool _handlesDecl(const Decl *D) {\n    return isa<DECL>(D);\n  }\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForDecl(CheckerManager::CheckDeclFunc(checker,\n                                                       _checkDecl<CHECKER>),\n                         _handlesDecl);\n  }\n};\n\nclass ASTCodeBody {\n  template <typename CHECKER>\n  static void _checkBody(void *checker, const Decl *D, AnalysisManager& mgr,\n                         BugReporter &BR) {\n    ((const CHECKER *)checker)->checkASTCodeBody(D, mgr, BR);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForBody(CheckerManager::CheckDeclFunc(checker,\n                                                       _checkBody<CHECKER>));\n  }\n};\n\nclass EndOfTranslationUnit {\n  template <typename CHECKER>\n  static void _checkEndOfTranslationUnit(void *checker,\n                                         const TranslationUnitDecl *TU,\n                                         AnalysisManager& mgr,\n                                         BugReporter &BR) {\n    ((const CHECKER *)checker)->checkEndOfTranslationUnit(TU, mgr, BR);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr){\n    mgr._registerForEndOfTranslationUnit(\n                              CheckerManager::CheckEndOfTranslationUnit(checker,\n                                          _checkEndOfTranslationUnit<CHECKER>));\n  }\n};\n\ntemplate <typename STMT>\nclass PreStmt {\n  template <typename CHECKER>\n  static void _checkStmt(void *checker, const Stmt *S, CheckerContext &C) {\n    ((const CHECKER *)checker)->checkPreStmt(cast<STMT>(S), C);\n  }\n\n  static bool _handlesStmt(const Stmt *S) {\n    return isa<STMT>(S);\n  }\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForPreStmt(CheckerManager::CheckStmtFunc(checker,\n                                                          _checkStmt<CHECKER>),\n                            _handlesStmt);\n  }\n};\n\ntemplate <typename STMT>\nclass PostStmt {\n  template <typename CHECKER>\n  static void _checkStmt(void *checker, const Stmt *S, CheckerContext &C) {\n    ((const CHECKER *)checker)->checkPostStmt(cast<STMT>(S), C);\n  }\n\n  static bool _handlesStmt(const Stmt *S) {\n    return isa<STMT>(S);\n  }\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForPostStmt(CheckerManager::CheckStmtFunc(checker,\n                                                           _checkStmt<CHECKER>),\n                             _handlesStmt);\n  }\n};\n\nclass PreObjCMessage {\n  template <typename CHECKER>\n  static void _checkObjCMessage(void *checker, const ObjCMethodCall &msg,\n                                CheckerContext &C) {\n    ((const CHECKER *)checker)->checkPreObjCMessage(msg, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForPreObjCMessage(\n     CheckerManager::CheckObjCMessageFunc(checker, _checkObjCMessage<CHECKER>));\n  }\n};\n\nclass ObjCMessageNil {\n  template <typename CHECKER>\n  static void _checkObjCMessage(void *checker, const ObjCMethodCall &msg,\n                                CheckerContext &C) {\n    ((const CHECKER *)checker)->checkObjCMessageNil(msg, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForObjCMessageNil(\n     CheckerManager::CheckObjCMessageFunc(checker, _checkObjCMessage<CHECKER>));\n  }\n};\n\nclass PostObjCMessage {\n  template <typename CHECKER>\n  static void _checkObjCMessage(void *checker, const ObjCMethodCall &msg,\n                                CheckerContext &C) {\n    ((const CHECKER *)checker)->checkPostObjCMessage(msg, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForPostObjCMessage(\n     CheckerManager::CheckObjCMessageFunc(checker, _checkObjCMessage<CHECKER>));\n  }\n};\n\nclass PreCall {\n  template <typename CHECKER>\n  static void _checkCall(void *checker, const CallEvent &msg,\n                         CheckerContext &C) {\n    ((const CHECKER *)checker)->checkPreCall(msg, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForPreCall(\n     CheckerManager::CheckCallFunc(checker, _checkCall<CHECKER>));\n  }\n};\n\nclass PostCall {\n  template <typename CHECKER>\n  static void _checkCall(void *checker, const CallEvent &msg,\n                         CheckerContext &C) {\n    ((const CHECKER *)checker)->checkPostCall(msg, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForPostCall(\n     CheckerManager::CheckCallFunc(checker, _checkCall<CHECKER>));\n  }\n};\n\nclass Location {\n  template <typename CHECKER>\n  static void _checkLocation(void *checker,\n                             const SVal &location, bool isLoad, const Stmt *S,\n                             CheckerContext &C) {\n    ((const CHECKER *)checker)->checkLocation(location, isLoad, S, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForLocation(\n           CheckerManager::CheckLocationFunc(checker, _checkLocation<CHECKER>));\n  }\n};\n\nclass Bind {\n  template <typename CHECKER>\n  static void _checkBind(void *checker,\n                         const SVal &location, const SVal &val, const Stmt *S,\n                         CheckerContext &C) {\n    ((const CHECKER *)checker)->checkBind(location, val, S, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForBind(\n           CheckerManager::CheckBindFunc(checker, _checkBind<CHECKER>));\n  }\n};\n\nclass EndAnalysis {\n  template <typename CHECKER>\n  static void _checkEndAnalysis(void *checker, ExplodedGraph &G,\n                                BugReporter &BR, ExprEngine &Eng) {\n    ((const CHECKER *)checker)->checkEndAnalysis(G, BR, Eng);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForEndAnalysis(\n     CheckerManager::CheckEndAnalysisFunc(checker, _checkEndAnalysis<CHECKER>));\n  }\n};\n\nclass BeginFunction {\n  template <typename CHECKER>\n  static void _checkBeginFunction(void *checker, CheckerContext &C) {\n    ((const CHECKER *)checker)->checkBeginFunction(C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForBeginFunction(CheckerManager::CheckBeginFunctionFunc(\n        checker, _checkBeginFunction<CHECKER>));\n  }\n};\n\nclass EndFunction {\n  template <typename CHECKER>\n  static void _checkEndFunction(void *checker, const ReturnStmt *RS,\n                                CheckerContext &C) {\n    ((const CHECKER *)checker)->checkEndFunction(RS, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForEndFunction(\n     CheckerManager::CheckEndFunctionFunc(checker, _checkEndFunction<CHECKER>));\n  }\n};\n\nclass BranchCondition {\n  template <typename CHECKER>\n  static void _checkBranchCondition(void *checker, const Stmt *Condition,\n                                    CheckerContext & C) {\n    ((const CHECKER *)checker)->checkBranchCondition(Condition, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForBranchCondition(\n      CheckerManager::CheckBranchConditionFunc(checker,\n                                               _checkBranchCondition<CHECKER>));\n  }\n};\n\nclass NewAllocator {\n  template <typename CHECKER>\n  static void _checkNewAllocator(void *checker, const CXXAllocatorCall &Call,\n                                 CheckerContext &C) {\n    ((const CHECKER *)checker)->checkNewAllocator(Call, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForNewAllocator(\n        CheckerManager::CheckNewAllocatorFunc(checker,\n                                              _checkNewAllocator<CHECKER>));\n  }\n};\n\nclass LiveSymbols {\n  template <typename CHECKER>\n  static void _checkLiveSymbols(void *checker, ProgramStateRef state,\n                                SymbolReaper &SR) {\n    ((const CHECKER *)checker)->checkLiveSymbols(state, SR);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForLiveSymbols(\n     CheckerManager::CheckLiveSymbolsFunc(checker, _checkLiveSymbols<CHECKER>));\n  }\n};\n\nclass DeadSymbols {\n  template <typename CHECKER>\n  static void _checkDeadSymbols(void *checker,\n                                SymbolReaper &SR, CheckerContext &C) {\n    ((const CHECKER *)checker)->checkDeadSymbols(SR, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForDeadSymbols(\n     CheckerManager::CheckDeadSymbolsFunc(checker, _checkDeadSymbols<CHECKER>));\n  }\n};\n\nclass RegionChanges {\n  template <typename CHECKER>\n  static ProgramStateRef\n  _checkRegionChanges(void *checker,\n                      ProgramStateRef state,\n                      const InvalidatedSymbols *invalidated,\n                      ArrayRef<const MemRegion *> Explicits,\n                      ArrayRef<const MemRegion *> Regions,\n                      const LocationContext *LCtx,\n                      const CallEvent *Call) {\n    return ((const CHECKER *) checker)->checkRegionChanges(state, invalidated,\n                                                           Explicits, Regions,\n                                                           LCtx, Call);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForRegionChanges(\n          CheckerManager::CheckRegionChangesFunc(checker,\n                                                 _checkRegionChanges<CHECKER>));\n  }\n};\n\nclass PointerEscape {\n  template <typename CHECKER>\n  static ProgramStateRef\n  _checkPointerEscape(void *Checker,\n                     ProgramStateRef State,\n                     const InvalidatedSymbols &Escaped,\n                     const CallEvent *Call,\n                     PointerEscapeKind Kind,\n                     RegionAndSymbolInvalidationTraits *ETraits) {\n\n    if (!ETraits)\n      return ((const CHECKER *)Checker)->checkPointerEscape(State,\n                                                            Escaped,\n                                                            Call,\n                                                            Kind);\n\n    InvalidatedSymbols RegularEscape;\n    for (InvalidatedSymbols::const_iterator I = Escaped.begin(),\n                                            E = Escaped.end(); I != E; ++I)\n      if (!ETraits->hasTrait(*I,\n              RegionAndSymbolInvalidationTraits::TK_PreserveContents) &&\n          !ETraits->hasTrait(*I,\n              RegionAndSymbolInvalidationTraits::TK_SuppressEscape))\n        RegularEscape.insert(*I);\n\n    if (RegularEscape.empty())\n      return State;\n\n    return ((const CHECKER *)Checker)->checkPointerEscape(State,\n                                                          RegularEscape,\n                                                          Call,\n                                                          Kind);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForPointerEscape(\n          CheckerManager::CheckPointerEscapeFunc(checker,\n                                                _checkPointerEscape<CHECKER>));\n  }\n};\n\nclass ConstPointerEscape {\n  template <typename CHECKER>\n  static ProgramStateRef\n  _checkConstPointerEscape(void *Checker,\n                      ProgramStateRef State,\n                      const InvalidatedSymbols &Escaped,\n                      const CallEvent *Call,\n                      PointerEscapeKind Kind,\n                      RegionAndSymbolInvalidationTraits *ETraits) {\n\n    if (!ETraits)\n      return State;\n\n    InvalidatedSymbols ConstEscape;\n    for (InvalidatedSymbols::const_iterator I = Escaped.begin(),\n                                            E = Escaped.end(); I != E; ++I)\n      if (ETraits->hasTrait(*I,\n              RegionAndSymbolInvalidationTraits::TK_PreserveContents) &&\n          !ETraits->hasTrait(*I,\n              RegionAndSymbolInvalidationTraits::TK_SuppressEscape))\n        ConstEscape.insert(*I);\n\n    if (ConstEscape.empty())\n      return State;\n\n    return ((const CHECKER *)Checker)->checkConstPointerEscape(State,\n                                                               ConstEscape,\n                                                               Call,\n                                                               Kind);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForPointerEscape(\n      CheckerManager::CheckPointerEscapeFunc(checker,\n                                            _checkConstPointerEscape<CHECKER>));\n  }\n};\n\n\ntemplate <typename EVENT>\nclass Event {\n  template <typename CHECKER>\n  static void _checkEvent(void *checker, const void *event) {\n    ((const CHECKER *)checker)->checkEvent(*(const EVENT *)event);\n  }\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerListenerForEvent<EVENT>(\n                 CheckerManager::CheckEventFunc(checker, _checkEvent<CHECKER>));\n  }\n};\n\n} // end check namespace\n\nnamespace eval {\n\nclass Assume {\n  template <typename CHECKER>\n  static ProgramStateRef _evalAssume(void *checker,\n                                         ProgramStateRef state,\n                                         const SVal &cond,\n                                         bool assumption) {\n    return ((const CHECKER *)checker)->evalAssume(state, cond, assumption);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForEvalAssume(\n                 CheckerManager::EvalAssumeFunc(checker, _evalAssume<CHECKER>));\n  }\n};\n\nclass Call {\n  template <typename CHECKER>\n  static bool _evalCall(void *checker, const CallEvent &Call,\n                        CheckerContext &C) {\n    return ((const CHECKER *)checker)->evalCall(Call, C);\n  }\n\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerForEvalCall(\n                     CheckerManager::EvalCallFunc(checker, _evalCall<CHECKER>));\n  }\n};\n\n} // end eval namespace\n\nclass CheckerBase : public ProgramPointTag {\n  CheckerNameRef Name;\n  friend class ::clang::ento::CheckerManager;\n\npublic:\n  StringRef getTagDescription() const override;\n  CheckerNameRef getCheckerName() const;\n\n  /// See CheckerManager::runCheckersForPrintState.\n  virtual void printState(raw_ostream &Out, ProgramStateRef State,\n                          const char *NL, const char *Sep) const { }\n};\n\n/// Dump checker name to stream.\nraw_ostream& operator<<(raw_ostream &Out, const CheckerBase &Checker);\n\n/// Tag that can use a checker name as a message provider\n/// (see SimpleProgramPointTag).\nclass CheckerProgramPointTag : public SimpleProgramPointTag {\npublic:\n  CheckerProgramPointTag(StringRef CheckerName, StringRef Msg);\n  CheckerProgramPointTag(const CheckerBase *Checker, StringRef Msg);\n};\n\ntemplate <typename CHECK1, typename... CHECKs>\nclass Checker : public CHECK1, public CHECKs..., public CheckerBase {\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    CHECK1::_register(checker, mgr);\n    Checker<CHECKs...>::_register(checker, mgr);\n  }\n};\n\ntemplate <typename CHECK1>\nclass Checker<CHECK1> : public CHECK1, public CheckerBase {\npublic:\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    CHECK1::_register(checker, mgr);\n  }\n};\n\ntemplate <typename EVENT>\nclass EventDispatcher {\n  CheckerManager *Mgr;\npublic:\n  EventDispatcher() : Mgr(nullptr) { }\n\n  template <typename CHECKER>\n  static void _register(CHECKER *checker, CheckerManager &mgr) {\n    mgr._registerDispatcherForEvent<EVENT>();\n    static_cast<EventDispatcher<EVENT> *>(checker)->Mgr = &mgr;\n  }\n\n  void dispatchEvent(const EVENT &event) const {\n    Mgr->_dispatchEvent(event);\n  }\n};\n\n/// We dereferenced a location that may be null.\nstruct ImplicitNullDerefEvent {\n  SVal Location;\n  bool IsLoad;\n  ExplodedNode *SinkNode;\n  BugReporter *BR;\n  // When true, the dereference is in the source code directly. When false, the\n  // dereference might happen later (for example pointer passed to a parameter\n  // that is marked with nonnull attribute.)\n  bool IsDirectDereference;\n\n  static int Tag;\n};\n\n/// A helper class which wraps a boolean value set to false by default.\n///\n/// This class should behave exactly like 'bool' except that it doesn't need to\n/// be explicitly initialized.\nstruct DefaultBool {\n  bool val;\n  DefaultBool() : val(false) {}\n  /*implicit*/ operator bool&() { return val; }\n  /*implicit*/ operator const bool&() const { return val; }\n  DefaultBool &operator=(bool b) { val = b; return *this; }\n};\n\n} // end ento namespace\n\n} // end clang namespace\n\n#endif\n"}, "54": {"id": 54, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/BasicValueFactory.h", "content": "//==- BasicValueFactory.h - Basic values for Path Sens analysis --*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines BasicValueFactory, a class that manages the lifetime\n//  of APSInt objects and symbolic constraints used by ExprEngine\n//  and related classes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_BASICVALUEFACTORY_H\n#define LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_BASICVALUEFACTORY_H\n\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/APSIntType.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SVals.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/StoreRef.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/ImmutableList.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <cassert>\n#include <cstdint>\n#include <utility>\n\nnamespace clang {\n\nclass CXXBaseSpecifier;\nclass DeclaratorDecl;\n\nnamespace ento {\n\nclass CompoundValData : public llvm::FoldingSetNode {\n  QualType T;\n  llvm::ImmutableList<SVal> L;\n\npublic:\n  CompoundValData(QualType t, llvm::ImmutableList<SVal> l) : T(t), L(l) {\n    assert(NonLoc::isCompoundType(t));\n  }\n\n  using iterator = llvm::ImmutableList<SVal>::iterator;\n\n  iterator begin() const { return L.begin(); }\n  iterator end() const { return L.end(); }\n\n  static void Profile(llvm::FoldingSetNodeID& ID, QualType T,\n                      llvm::ImmutableList<SVal> L);\n\n  void Profile(llvm::FoldingSetNodeID& ID) { Profile(ID, T, L); }\n};\n\nclass LazyCompoundValData : public llvm::FoldingSetNode {\n  StoreRef store;\n  const TypedValueRegion *region;\n\npublic:\n  LazyCompoundValData(const StoreRef &st, const TypedValueRegion *r)\n      : store(st), region(r) {\n    assert(NonLoc::isCompoundType(r->getValueType()));\n  }\n\n  const void *getStore() const { return store.getStore(); }\n  const TypedValueRegion *getRegion() const { return region; }\n\n  static void Profile(llvm::FoldingSetNodeID& ID,\n                      const StoreRef &store,\n                      const TypedValueRegion *region);\n\n  void Profile(llvm::FoldingSetNodeID& ID) { Profile(ID, store, region); }\n};\n\nclass PointerToMemberData : public llvm::FoldingSetNode {\n  const NamedDecl *D;\n  llvm::ImmutableList<const CXXBaseSpecifier *> L;\n\npublic:\n  PointerToMemberData(const NamedDecl *D,\n                      llvm::ImmutableList<const CXXBaseSpecifier *> L)\n      : D(D), L(L) {}\n\n  using iterator = llvm::ImmutableList<const CXXBaseSpecifier *>::iterator;\n\n  iterator begin() const { return L.begin(); }\n  iterator end() const { return L.end(); }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const NamedDecl *D,\n                      llvm::ImmutableList<const CXXBaseSpecifier *> L);\n\n  void Profile(llvm::FoldingSetNodeID &ID) { Profile(ID, D, L); }\n  const NamedDecl *getDeclaratorDecl() const { return D; }\n\n  llvm::ImmutableList<const CXXBaseSpecifier *> getCXXBaseList() const {\n    return L;\n  }\n};\n\nclass BasicValueFactory {\n  using APSIntSetTy =\n      llvm::FoldingSet<llvm::FoldingSetNodeWrapper<llvm::APSInt>>;\n\n  ASTContext &Ctx;\n  llvm::BumpPtrAllocator& BPAlloc;\n\n  APSIntSetTy APSIntSet;\n  void *PersistentSVals = nullptr;\n  void *PersistentSValPairs = nullptr;\n\n  llvm::ImmutableList<SVal>::Factory SValListFactory;\n  llvm::ImmutableList<const CXXBaseSpecifier *>::Factory CXXBaseListFactory;\n  llvm::FoldingSet<CompoundValData>  CompoundValDataSet;\n  llvm::FoldingSet<LazyCompoundValData> LazyCompoundValDataSet;\n  llvm::FoldingSet<PointerToMemberData> PointerToMemberDataSet;\n\n  // This is private because external clients should use the factory\n  // method that takes a QualType.\n  const llvm::APSInt& getValue(uint64_t X, unsigned BitWidth, bool isUnsigned);\n\npublic:\n  BasicValueFactory(ASTContext &ctx, llvm::BumpPtrAllocator &Alloc)\n      : Ctx(ctx), BPAlloc(Alloc), SValListFactory(Alloc),\n        CXXBaseListFactory(Alloc) {}\n\n  ~BasicValueFactory();\n\n  ASTContext &getContext() const { return Ctx; }\n\n  const llvm::APSInt& getValue(const llvm::APSInt& X);\n  const llvm::APSInt& getValue(const llvm::APInt& X, bool isUnsigned);\n  const llvm::APSInt& getValue(uint64_t X, QualType T);\n\n  /// Returns the type of the APSInt used to store values of the given QualType.\n  APSIntType getAPSIntType(QualType T) const {\n    assert(T->isIntegralOrEnumerationType() || Loc::isLocType(T));\n    return APSIntType(Ctx.getIntWidth(T),\n                      !T->isSignedIntegerOrEnumerationType());\n  }\n\n  /// Convert - Create a new persistent APSInt with the same value as 'From'\n  ///  but with the bitwidth and signedness of 'To'.\n  const llvm::APSInt &Convert(const llvm::APSInt& To,\n                              const llvm::APSInt& From) {\n    APSIntType TargetType(To);\n    if (TargetType == APSIntType(From))\n      return From;\n\n    return getValue(TargetType.convert(From));\n  }\n\n  const llvm::APSInt &Convert(QualType T, const llvm::APSInt &From) {\n    APSIntType TargetType = getAPSIntType(T);\n    return Convert(TargetType, From);\n  }\n\n  const llvm::APSInt &Convert(APSIntType TargetType, const llvm::APSInt &From) {\n    if (TargetType == APSIntType(From))\n      return From;\n\n    return getValue(TargetType.convert(From));\n  }\n\n  const llvm::APSInt &getIntValue(uint64_t X, bool isUnsigned) {\n    QualType T = isUnsigned ? Ctx.UnsignedIntTy : Ctx.IntTy;\n    return getValue(X, T);\n  }\n\n  const llvm::APSInt &getMaxValue(const llvm::APSInt &v) {\n    return getValue(APSIntType(v).getMaxValue());\n  }\n\n  const llvm::APSInt &getMinValue(const llvm::APSInt &v) {\n    return getValue(APSIntType(v).getMinValue());\n  }\n\n  const llvm::APSInt &getMaxValue(QualType T) {\n    return getMaxValue(getAPSIntType(T));\n  }\n\n  const llvm::APSInt &getMinValue(QualType T) {\n    return getMinValue(getAPSIntType(T));\n  }\n\n  const llvm::APSInt &getMaxValue(APSIntType T) {\n    return getValue(T.getMaxValue());\n  }\n\n  const llvm::APSInt &getMinValue(APSIntType T) {\n    return getValue(T.getMinValue());\n  }\n\n  const llvm::APSInt &Add1(const llvm::APSInt &V) {\n    llvm::APSInt X = V;\n    ++X;\n    return getValue(X);\n  }\n\n  const llvm::APSInt &Sub1(const llvm::APSInt &V) {\n    llvm::APSInt X = V;\n    --X;\n    return getValue(X);\n  }\n\n  const llvm::APSInt &getZeroWithTypeSize(QualType T) {\n    assert(T->isScalarType());\n    return getValue(0, Ctx.getTypeSize(T), true);\n  }\n\n  const llvm::APSInt &getZeroWithPtrWidth(bool isUnsigned = true) {\n    return getValue(0, Ctx.getTypeSize(Ctx.VoidPtrTy), isUnsigned);\n  }\n\n  const llvm::APSInt &getIntWithPtrWidth(uint64_t X, bool isUnsigned) {\n    return getValue(X, Ctx.getTypeSize(Ctx.VoidPtrTy), isUnsigned);\n  }\n\n  const llvm::APSInt &getTruthValue(bool b, QualType T) {\n    return getValue(b ? 1 : 0, Ctx.getIntWidth(T),\n                    T->isUnsignedIntegerOrEnumerationType());\n  }\n\n  const llvm::APSInt &getTruthValue(bool b) {\n    return getTruthValue(b, Ctx.getLogicalOperationType());\n  }\n\n  const CompoundValData *getCompoundValData(QualType T,\n                                            llvm::ImmutableList<SVal> Vals);\n\n  const LazyCompoundValData *getLazyCompoundValData(const StoreRef &store,\n                                            const TypedValueRegion *region);\n\n  const PointerToMemberData *\n  getPointerToMemberData(const NamedDecl *ND,\n                         llvm::ImmutableList<const CXXBaseSpecifier *> L);\n\n  llvm::ImmutableList<SVal> getEmptySValList() {\n    return SValListFactory.getEmptyList();\n  }\n\n  llvm::ImmutableList<SVal> prependSVal(SVal X, llvm::ImmutableList<SVal> L) {\n    return SValListFactory.add(X, L);\n  }\n\n  llvm::ImmutableList<const CXXBaseSpecifier *> getEmptyCXXBaseList() {\n    return CXXBaseListFactory.getEmptyList();\n  }\n\n  llvm::ImmutableList<const CXXBaseSpecifier *> prependCXXBase(\n      const CXXBaseSpecifier *CBS,\n      llvm::ImmutableList<const CXXBaseSpecifier *> L) {\n    return CXXBaseListFactory.add(CBS, L);\n  }\n\n  const PointerToMemberData *\n  accumCXXBase(llvm::iterator_range<CastExpr::path_const_iterator> PathRange,\n               const nonloc::PointerToMember &PTM, const clang::CastKind &kind);\n\n  const llvm::APSInt* evalAPSInt(BinaryOperator::Opcode Op,\n                                     const llvm::APSInt& V1,\n                                     const llvm::APSInt& V2);\n\n  const std::pair<SVal, uintptr_t>&\n  getPersistentSValWithData(const SVal& V, uintptr_t Data);\n\n  const std::pair<SVal, SVal>&\n  getPersistentSValPair(const SVal& V1, const SVal& V2);\n\n  const SVal* getPersistentSVal(SVal X);\n};\n\n} // namespace ento\n\n} // namespace clang\n\n#endif // LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_BASICVALUEFACTORY_H\n"}, "55": {"id": 55, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/BlockCounter.h", "content": "//==- BlockCounter.h - ADT for counting block visits ---------------*- C++ -*-//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines BlockCounter, an abstract data type used to count\n//  the number of times a given block has been visited along a path\n//  analyzed by CoreEngine.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_BLOCKCOUNTER_H\n#define LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_BLOCKCOUNTER_H\n\n#include \"llvm/Support/Allocator.h\"\n\nnamespace clang {\n\nclass StackFrameContext;\n\nnamespace ento {\n\n/// \\class BlockCounter\n/// An abstract data type used to count the number of times a given\n/// block has been visited along a path analyzed by CoreEngine.\nclass BlockCounter {\n  void *Data;\n\n  BlockCounter(void *D) : Data(D) {}\n\npublic:\n  BlockCounter() : Data(nullptr) {}\n\n  unsigned getNumVisited(const StackFrameContext *CallSite,\n                         unsigned BlockID) const;\n\n  class Factory {\n    void *F;\n  public:\n    Factory(llvm::BumpPtrAllocator& Alloc);\n    ~Factory();\n\n    BlockCounter GetEmptyCounter();\n    BlockCounter IncrementCount(BlockCounter BC,\n                                  const StackFrameContext *CallSite,\n                                  unsigned BlockID);\n  };\n\n  friend class Factory;\n};\n\n} // end GR namespace\n\n} // end clang namespace\n\n#endif\n"}, "56": {"id": 56, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h", "content": "//===- CallEvent.h - Wrapper for all function and method calls --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file This file defines CallEvent and its subclasses, which represent path-\n/// sensitive instances of different kinds of function and method calls\n/// (C, C++, and Objective-C).\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_CALLEVENT_H\n#define LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_CALLEVENT_H\n\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/ExprObjC.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ExprEngine.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState_Fwd.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SVals.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <cassert>\n#include <limits>\n#include <utility>\n\nnamespace clang {\n\nclass LocationContext;\nclass ProgramPoint;\nclass ProgramPointTag;\nclass StackFrameContext;\n\nnamespace ento {\n\nenum CallEventKind {\n  CE_Function,\n  CE_CXXMember,\n  CE_CXXMemberOperator,\n  CE_CXXDestructor,\n  CE_BEG_CXX_INSTANCE_CALLS = CE_CXXMember,\n  CE_END_CXX_INSTANCE_CALLS = CE_CXXDestructor,\n  CE_CXXConstructor,\n  CE_CXXInheritedConstructor,\n  CE_BEG_CXX_CONSTRUCTOR_CALLS = CE_CXXConstructor,\n  CE_END_CXX_CONSTRUCTOR_CALLS = CE_CXXInheritedConstructor,\n  CE_CXXAllocator,\n  CE_CXXDeallocator,\n  CE_BEG_FUNCTION_CALLS = CE_Function,\n  CE_END_FUNCTION_CALLS = CE_CXXDeallocator,\n  CE_Block,\n  CE_ObjCMessage\n};\n\nclass CallEvent;\nclass CallDescription;\n\ntemplate<typename T = CallEvent>\nclass CallEventRef : public IntrusiveRefCntPtr<const T> {\npublic:\n  CallEventRef(const T *Call) : IntrusiveRefCntPtr<const T>(Call) {}\n  CallEventRef(const CallEventRef &Orig) : IntrusiveRefCntPtr<const T>(Orig) {}\n\n  CallEventRef<T> cloneWithState(ProgramStateRef State) const {\n    return this->get()->template cloneWithState<T>(State);\n  }\n\n  // Allow implicit conversions to a superclass type, since CallEventRef\n  // behaves like a pointer-to-const.\n  template <typename SuperT>\n  operator CallEventRef<SuperT> () const {\n    return this->get();\n  }\n};\n\n/// \\class RuntimeDefinition\n/// Defines the runtime definition of the called function.\n///\n/// Encapsulates the information we have about which Decl will be used\n/// when the call is executed on the given path. When dealing with dynamic\n/// dispatch, the information is based on DynamicTypeInfo and might not be\n/// precise.\nclass RuntimeDefinition {\n  /// The Declaration of the function which could be called at runtime.\n  /// NULL if not available.\n  const Decl *D = nullptr;\n\n  /// The region representing an object (ObjC/C++) on which the method is\n  /// called. With dynamic dispatch, the method definition depends on the\n  /// runtime type of this object. NULL when the DynamicTypeInfo is\n  /// precise.\n  const MemRegion *R = nullptr;\n\npublic:\n  RuntimeDefinition() = default;\n  RuntimeDefinition(const Decl *InD): D(InD) {}\n  RuntimeDefinition(const Decl *InD, const MemRegion *InR): D(InD), R(InR) {}\n\n  const Decl *getDecl() { return D; }\n\n  /// Check if the definition we have is precise.\n  /// If not, it is possible that the call dispatches to another definition at\n  /// execution time.\n  bool mayHaveOtherDefinitions() { return R != nullptr; }\n\n  /// When other definitions are possible, returns the region whose runtime type\n  /// determines the method definition.\n  const MemRegion *getDispatchRegion() { return R; }\n};\n\n/// Represents an abstract call to a function or method along a\n/// particular path.\n///\n/// CallEvents are created through the factory methods of CallEventManager.\n///\n/// CallEvents should always be cheap to create and destroy. In order for\n/// CallEventManager to be able to re-use CallEvent-sized memory blocks,\n/// subclasses of CallEvent may not add any data members to the base class.\n/// Use the \"Data\" and \"Location\" fields instead.\nclass CallEvent {\npublic:\n  using Kind = CallEventKind;\n\nprivate:\n  ProgramStateRef State;\n  const LocationContext *LCtx;\n  llvm::PointerUnion<const Expr *, const Decl *> Origin;\n\nprotected:\n  // This is user data for subclasses.\n  const void *Data;\n\n  // This is user data for subclasses.\n  // This should come right before RefCount, so that the two fields can be\n  // packed together on LP64 platforms.\n  SourceLocation Location;\n\nprivate:\n  template <typename T> friend struct llvm::IntrusiveRefCntPtrInfo;\n\n  mutable unsigned RefCount = 0;\n\n  void Retain() const { ++RefCount; }\n  void Release() const;\n\nprotected:\n  friend class CallEventManager;\n\n  CallEvent(const Expr *E, ProgramStateRef state, const LocationContext *lctx)\n      : State(std::move(state)), LCtx(lctx), Origin(E) {}\n\n  CallEvent(const Decl *D, ProgramStateRef state, const LocationContext *lctx)\n      : State(std::move(state)), LCtx(lctx), Origin(D) {}\n\n  // DO NOT MAKE PUBLIC\n  CallEvent(const CallEvent &Original)\n      : State(Original.State), LCtx(Original.LCtx), Origin(Original.Origin),\n        Data(Original.Data), Location(Original.Location) {}\n\n  /// Copies this CallEvent, with vtable intact, into a new block of memory.\n  virtual void cloneTo(void *Dest) const = 0;\n\n  /// Get the value of arbitrary expressions at this point in the path.\n  SVal getSVal(const Stmt *S) const {\n    return getState()->getSVal(S, getLocationContext());\n  }\n\n  using ValueList = SmallVectorImpl<SVal>;\n\n  /// Used to specify non-argument regions that will be invalidated as a\n  /// result of this call.\n  virtual void getExtraInvalidatedValues(ValueList &Values,\n                 RegionAndSymbolInvalidationTraits *ETraits) const {}\n\npublic:\n  CallEvent &operator=(const CallEvent &) = delete;\n  virtual ~CallEvent() = default;\n\n  /// Returns the kind of call this is.\n  virtual Kind getKind() const = 0;\n  virtual StringRef getKindAsString() const = 0;\n\n  /// Returns the declaration of the function or method that will be\n  /// called. May be null.\n  virtual const Decl *getDecl() const {\n    return Origin.dyn_cast<const Decl *>();\n  }\n\n  /// The state in which the call is being evaluated.\n  const ProgramStateRef &getState() const {\n    return State;\n  }\n\n  /// The context in which the call is being evaluated.\n  const LocationContext *getLocationContext() const {\n    return LCtx;\n  }\n\n  /// Returns the definition of the function or method that will be\n  /// called.\n  virtual RuntimeDefinition getRuntimeDefinition() const = 0;\n\n  /// Returns the expression whose value will be the result of this call.\n  /// May be null.\n  virtual const Expr *getOriginExpr() const {\n    return Origin.dyn_cast<const Expr *>();\n  }\n\n  /// Returns the number of arguments (explicit and implicit).\n  ///\n  /// Note that this may be greater than the number of parameters in the\n  /// callee's declaration, and that it may include arguments not written in\n  /// the source.\n  virtual unsigned getNumArgs() const = 0;\n\n  /// Returns true if the callee is known to be from a system header.\n  bool isInSystemHeader() const {\n    const Decl *D = getDecl();\n    if (!D)\n      return false;\n\n    SourceLocation Loc = D->getLocation();\n    if (Loc.isValid()) {\n      const SourceManager &SM =\n        getState()->getStateManager().getContext().getSourceManager();\n      return SM.isInSystemHeader(D->getLocation());\n    }\n\n    // Special case for implicitly-declared global operator new/delete.\n    // These should be considered system functions.\n    if (const auto *FD = dyn_cast<FunctionDecl>(D))\n      return FD->isOverloadedOperator() && FD->isImplicit() && FD->isGlobal();\n\n    return false;\n  }\n\n  /// Returns true if the CallEvent is a call to a function that matches\n  /// the CallDescription.\n  ///\n  /// Note that this function is not intended to be used to match Obj-C method\n  /// calls.\n  bool isCalled(const CallDescription &CD) const;\n\n  /// Returns true whether the CallEvent is any of the CallDescriptions supplied\n  /// as a parameter.\n  template <typename FirstCallDesc, typename... CallDescs>\n  bool isCalled(const FirstCallDesc &First, const CallDescs &... Rest) const {\n    return isCalled(First) || isCalled(Rest...);\n  }\n\n  /// Returns a source range for the entire call, suitable for\n  /// outputting in diagnostics.\n  virtual SourceRange getSourceRange() const {\n    return getOriginExpr()->getSourceRange();\n  }\n\n  /// Returns the value of a given argument at the time of the call.\n  virtual SVal getArgSVal(unsigned Index) const;\n\n  /// Returns the expression associated with a given argument.\n  /// May be null if this expression does not appear in the source.\n  virtual const Expr *getArgExpr(unsigned Index) const { return nullptr; }\n\n  /// Returns the source range for errors associated with this argument.\n  ///\n  /// May be invalid if the argument is not written in the source.\n  virtual SourceRange getArgSourceRange(unsigned Index) const;\n\n  /// Returns the result type, adjusted for references.\n  QualType getResultType() const;\n\n  /// Returns the return value of the call.\n  ///\n  /// This should only be called if the CallEvent was created using a state in\n  /// which the return value has already been bound to the origin expression.\n  SVal getReturnValue() const;\n\n  /// Returns true if the type of any of the non-null arguments satisfies\n  /// the condition.\n  bool hasNonNullArgumentsWithType(bool (*Condition)(QualType)) const;\n\n  /// Returns true if any of the arguments appear to represent callbacks.\n  bool hasNonZeroCallbackArg() const;\n\n  /// Returns true if any of the arguments is void*.\n  bool hasVoidPointerToNonConstArg() const;\n\n  /// Returns true if any of the arguments are known to escape to long-\n  /// term storage, even if this method will not modify them.\n  // NOTE: The exact semantics of this are still being defined!\n  // We don't really want a list of hardcoded exceptions in the long run,\n  // but we don't want duplicated lists of known APIs in the short term either.\n  virtual bool argumentsMayEscape() const {\n    return hasNonZeroCallbackArg();\n  }\n\n  /// Returns true if the callee is an externally-visible function in the\n  /// top-level namespace, such as \\c malloc.\n  ///\n  /// You can use this call to determine that a particular function really is\n  /// a library function and not, say, a C++ member function with the same name.\n  ///\n  /// If a name is provided, the function must additionally match the given\n  /// name.\n  ///\n  /// Note that this deliberately excludes C++ library functions in the \\c std\n  /// namespace, but will include C library functions accessed through the\n  /// \\c std namespace. This also does not check if the function is declared\n  /// as 'extern \"C\"', or if it uses C++ name mangling.\n  // FIXME: Add a helper for checking namespaces.\n  // FIXME: Move this down to AnyFunctionCall once checkers have more\n  // precise callbacks.\n  bool isGlobalCFunction(StringRef SpecificName = StringRef()) const;\n\n  /// Returns the name of the callee, if its name is a simple identifier.\n  ///\n  /// Note that this will fail for Objective-C methods, blocks, and C++\n  /// overloaded operators. The former is named by a Selector rather than a\n  /// simple identifier, and the latter two do not have names.\n  // FIXME: Move this down to AnyFunctionCall once checkers have more\n  // precise callbacks.\n  const IdentifierInfo *getCalleeIdentifier() const {\n    const auto *ND = dyn_cast_or_null<NamedDecl>(getDecl());\n    if (!ND)\n      return nullptr;\n    return ND->getIdentifier();\n  }\n\n  /// Returns an appropriate ProgramPoint for this call.\n  ProgramPoint getProgramPoint(bool IsPreVisit = false,\n                               const ProgramPointTag *Tag = nullptr) const;\n\n  /// Returns a new state with all argument regions invalidated.\n  ///\n  /// This accepts an alternate state in case some processing has already\n  /// occurred.\n  ProgramStateRef invalidateRegions(unsigned BlockCount,\n                                    ProgramStateRef Orig = nullptr) const;\n\n  using FrameBindingTy = std::pair<SVal, SVal>;\n  using BindingsTy = SmallVectorImpl<FrameBindingTy>;\n\n  /// Populates the given SmallVector with the bindings in the callee's stack\n  /// frame at the start of this call.\n  virtual void getInitialStackFrameContents(const StackFrameContext *CalleeCtx,\n                                            BindingsTy &Bindings) const = 0;\n\n  /// Returns a copy of this CallEvent, but using the given state.\n  template <typename T>\n  CallEventRef<T> cloneWithState(ProgramStateRef NewState) const;\n\n  /// Returns a copy of this CallEvent, but using the given state.\n  CallEventRef<> cloneWithState(ProgramStateRef NewState) const {\n    return cloneWithState<CallEvent>(NewState);\n  }\n\n  /// Returns true if this is a statement is a function or method call\n  /// of some kind.\n  static bool isCallStmt(const Stmt *S);\n\n  /// Returns the result type of a function or method declaration.\n  ///\n  /// This will return a null QualType if the result type cannot be determined.\n  static QualType getDeclaredResultType(const Decl *D);\n\n  /// Returns true if the given decl is known to be variadic.\n  ///\n  /// \\p D must not be null.\n  static bool isVariadic(const Decl *D);\n\n  /// Returns AnalysisDeclContext for the callee stack frame.\n  /// Currently may fail; returns null on failure.\n  AnalysisDeclContext *getCalleeAnalysisDeclContext() const;\n\n  /// Returns the callee stack frame. That stack frame will only be entered\n  /// during analysis if the call is inlined, but it may still be useful\n  /// in intermediate calculations even if the call isn't inlined.\n  /// May fail; returns null on failure.\n  const StackFrameContext *getCalleeStackFrame(unsigned BlockCount) const;\n\n  /// Returns memory location for a parameter variable within the callee stack\n  /// frame. The behavior is undefined if the block count is different from the\n  /// one that is there when call happens. May fail; returns null on failure.\n  const ParamVarRegion *getParameterLocation(unsigned Index,\n                                             unsigned BlockCount) const;\n\n  /// Returns true if on the current path, the argument was constructed by\n  /// calling a C++ constructor over it. This is an internal detail of the\n  /// analysis which doesn't necessarily represent the program semantics:\n  /// if we are supposed to construct an argument directly, we may still\n  /// not do that because we don't know how (i.e., construction context is\n  /// unavailable in the CFG or not supported by the analyzer).\n  bool isArgumentConstructedDirectly(unsigned Index) const {\n    // This assumes that the object was not yet removed from the state.\n    return ExprEngine::getObjectUnderConstruction(\n        getState(), {getOriginExpr(), Index}, getLocationContext()).hasValue();\n  }\n\n  /// Some calls have parameter numbering mismatched from argument numbering.\n  /// This function converts an argument index to the corresponding\n  /// parameter index. Returns None is the argument doesn't correspond\n  /// to any parameter variable.\n  virtual Optional<unsigned>\n  getAdjustedParameterIndex(unsigned ASTArgumentIndex) const {\n    return ASTArgumentIndex;\n  }\n\n  /// Some call event sub-classes conveniently adjust mismatching AST indices\n  /// to match parameter indices. This function converts an argument index\n  /// as understood by CallEvent to the argument index as understood by the AST.\n  virtual unsigned getASTArgumentIndex(unsigned CallArgumentIndex) const {\n    return CallArgumentIndex;\n  }\n\n  /// Returns the construction context of the call, if it is a C++ constructor\n  /// call or a call of a function returning a C++ class instance. Otherwise\n  /// return nullptr.\n  const ConstructionContext *getConstructionContext() const;\n\n  /// If the call returns a C++ record type then the region of its return value\n  /// can be retrieved from its construction context.\n  Optional<SVal> getReturnValueUnderConstruction() const;\n\n  // Iterator access to formal parameters and their types.\nprivate:\n  struct GetTypeFn {\n    QualType operator()(ParmVarDecl *PD) const { return PD->getType(); }\n  };\n\npublic:\n  /// Return call's formal parameters.\n  ///\n  /// Remember that the number of formal parameters may not match the number\n  /// of arguments for all calls. However, the first parameter will always\n  /// correspond with the argument value returned by \\c getArgSVal(0).\n  virtual ArrayRef<ParmVarDecl *> parameters() const = 0;\n\n  using param_type_iterator =\n      llvm::mapped_iterator<ArrayRef<ParmVarDecl *>::iterator, GetTypeFn>;\n\n  /// Returns an iterator over the types of the call's formal parameters.\n  ///\n  /// This uses the callee decl found by default name lookup rather than the\n  /// definition because it represents a public interface, and probably has\n  /// more annotations.\n  param_type_iterator param_type_begin() const {\n    return llvm::map_iterator(parameters().begin(), GetTypeFn());\n  }\n  /// \\sa param_type_begin()\n  param_type_iterator param_type_end() const {\n    return llvm::map_iterator(parameters().end(), GetTypeFn());\n  }\n\n  // For debugging purposes only\n  void dump(raw_ostream &Out) const;\n  void dump() const;\n};\n\n/// Represents a call to any sort of function that might have a\n/// FunctionDecl.\nclass AnyFunctionCall : public CallEvent {\nprotected:\n  AnyFunctionCall(const Expr *E, ProgramStateRef St,\n                  const LocationContext *LCtx)\n      : CallEvent(E, St, LCtx) {}\n  AnyFunctionCall(const Decl *D, ProgramStateRef St,\n                  const LocationContext *LCtx)\n      : CallEvent(D, St, LCtx) {}\n  AnyFunctionCall(const AnyFunctionCall &Other) = default;\n\npublic:\n  // This function is overridden by subclasses, but they must return\n  // a FunctionDecl.\n  const FunctionDecl *getDecl() const override {\n    return cast<FunctionDecl>(CallEvent::getDecl());\n  }\n\n  RuntimeDefinition getRuntimeDefinition() const override;\n\n  bool argumentsMayEscape() const override;\n\n  void getInitialStackFrameContents(const StackFrameContext *CalleeCtx,\n                                    BindingsTy &Bindings) const override;\n\n  ArrayRef<ParmVarDecl *> parameters() const override;\n\n  static bool classof(const CallEvent *CA) {\n    return CA->getKind() >= CE_BEG_FUNCTION_CALLS &&\n           CA->getKind() <= CE_END_FUNCTION_CALLS;\n  }\n};\n\n/// Represents a C function or static C++ member function call.\n///\n/// Example: \\c fun()\nclass SimpleFunctionCall : public AnyFunctionCall {\n  friend class CallEventManager;\n\nprotected:\n  SimpleFunctionCall(const CallExpr *CE, ProgramStateRef St,\n                     const LocationContext *LCtx)\n      : AnyFunctionCall(CE, St, LCtx) {}\n  SimpleFunctionCall(const SimpleFunctionCall &Other) = default;\n\n  void cloneTo(void *Dest) const override {\n    new (Dest) SimpleFunctionCall(*this);\n  }\n\npublic:\n  const CallExpr *getOriginExpr() const override {\n    return cast<CallExpr>(AnyFunctionCall::getOriginExpr());\n  }\n\n  const FunctionDecl *getDecl() const override;\n\n  unsigned getNumArgs() const override { return getOriginExpr()->getNumArgs(); }\n\n  const Expr *getArgExpr(unsigned Index) const override {\n    return getOriginExpr()->getArg(Index);\n  }\n\n  Kind getKind() const override { return CE_Function; }\n  StringRef getKindAsString() const override { return \"SimpleFunctionCall\"; }\n\n  static bool classof(const CallEvent *CA) {\n    return CA->getKind() == CE_Function;\n  }\n};\n\n/// Represents a call to a block.\n///\n/// Example: <tt>^{ statement-body }()</tt>\nclass BlockCall : public CallEvent {\n  friend class CallEventManager;\n\nprotected:\n  BlockCall(const CallExpr *CE, ProgramStateRef St,\n            const LocationContext *LCtx)\n      : CallEvent(CE, St, LCtx) {}\n  BlockCall(const BlockCall &Other) = default;\n\n  void cloneTo(void *Dest) const override { new (Dest) BlockCall(*this); }\n\n  void getExtraInvalidatedValues(ValueList &Values,\n         RegionAndSymbolInvalidationTraits *ETraits) const override;\n\npublic:\n  const CallExpr *getOriginExpr() const override {\n    return cast<CallExpr>(CallEvent::getOriginExpr());\n  }\n\n  unsigned getNumArgs() const override { return getOriginExpr()->getNumArgs(); }\n\n  const Expr *getArgExpr(unsigned Index) const override {\n    return getOriginExpr()->getArg(Index);\n  }\n\n  /// Returns the region associated with this instance of the block.\n  ///\n  /// This may be NULL if the block's origin is unknown.\n  const BlockDataRegion *getBlockRegion() const;\n\n  const BlockDecl *getDecl() const override {\n    const BlockDataRegion *BR = getBlockRegion();\n    if (!BR)\n      return nullptr;\n    return BR->getDecl();\n  }\n\n  bool isConversionFromLambda() const {\n    const BlockDecl *BD = getDecl();\n    if (!BD)\n      return false;\n\n    return BD->isConversionFromLambda();\n  }\n\n  /// For a block converted from a C++ lambda, returns the block\n  /// VarRegion for the variable holding the captured C++ lambda record.\n  const VarRegion *getRegionStoringCapturedLambda() const {\n    assert(isConversionFromLambda());\n    const BlockDataRegion *BR = getBlockRegion();\n    assert(BR && \"Block converted from lambda must have a block region\");\n\n    auto I = BR->referenced_vars_begin();\n    assert(I != BR->referenced_vars_end());\n\n    return I.getCapturedRegion();\n  }\n\n  RuntimeDefinition getRuntimeDefinition() const override {\n    if (!isConversionFromLambda())\n      return RuntimeDefinition(getDecl());\n\n    // Clang converts lambdas to blocks with an implicit user-defined\n    // conversion operator method on the lambda record that looks (roughly)\n    // like:\n    //\n    // typedef R(^block_type)(P1, P2, ...);\n    // operator block_type() const {\n    //   auto Lambda = *this;\n    //   return ^(P1 p1, P2 p2, ...){\n    //     /* return Lambda(p1, p2, ...); */\n    //   };\n    // }\n    //\n    // Here R is the return type of the lambda and P1, P2, ... are\n    // its parameter types. 'Lambda' is a fake VarDecl captured by the block\n    // that is initialized to a copy of the lambda.\n    //\n    // Sema leaves the body of a lambda-converted block empty (it is\n    // produced by CodeGen), so we can't analyze it directly. Instead, we skip\n    // the block body and analyze the operator() method on the captured lambda.\n    const VarDecl *LambdaVD = getRegionStoringCapturedLambda()->getDecl();\n    const CXXRecordDecl *LambdaDecl = LambdaVD->getType()->getAsCXXRecordDecl();\n    CXXMethodDecl* LambdaCallOperator = LambdaDecl->getLambdaCallOperator();\n\n    return RuntimeDefinition(LambdaCallOperator);\n  }\n\n  bool argumentsMayEscape() const override {\n    return true;\n  }\n\n  void getInitialStackFrameContents(const StackFrameContext *CalleeCtx,\n                                    BindingsTy &Bindings) const override;\n\n  ArrayRef<ParmVarDecl *> parameters() const override;\n\n  Kind getKind() const override { return CE_Block; }\n  StringRef getKindAsString() const override { return \"BlockCall\"; }\n\n  static bool classof(const CallEvent *CA) { return CA->getKind() == CE_Block; }\n};\n\n/// Represents a non-static C++ member function call, no matter how\n/// it is written.\nclass CXXInstanceCall : public AnyFunctionCall {\nprotected:\n  CXXInstanceCall(const CallExpr *CE, ProgramStateRef St,\n                  const LocationContext *LCtx)\n      : AnyFunctionCall(CE, St, LCtx) {}\n  CXXInstanceCall(const FunctionDecl *D, ProgramStateRef St,\n                  const LocationContext *LCtx)\n      : AnyFunctionCall(D, St, LCtx) {}\n  CXXInstanceCall(const CXXInstanceCall &Other) = default;\n\n  void getExtraInvalidatedValues(ValueList &Values,\n         RegionAndSymbolInvalidationTraits *ETraits) const override;\n\npublic:\n  /// Returns the expression representing the implicit 'this' object.\n  virtual const Expr *getCXXThisExpr() const { return nullptr; }\n\n  /// Returns the value of the implicit 'this' object.\n  virtual SVal getCXXThisVal() const;\n\n  const FunctionDecl *getDecl() const override;\n\n  RuntimeDefinition getRuntimeDefinition() const override;\n\n  void getInitialStackFrameContents(const StackFrameContext *CalleeCtx,\n                                    BindingsTy &Bindings) const override;\n\n  static bool classof(const CallEvent *CA) {\n    return CA->getKind() >= CE_BEG_CXX_INSTANCE_CALLS &&\n           CA->getKind() <= CE_END_CXX_INSTANCE_CALLS;\n  }\n};\n\n/// Represents a non-static C++ member function call.\n///\n/// Example: \\c obj.fun()\nclass CXXMemberCall : public CXXInstanceCall {\n  friend class CallEventManager;\n\nprotected:\n  CXXMemberCall(const CXXMemberCallExpr *CE, ProgramStateRef St,\n                const LocationContext *LCtx)\n      : CXXInstanceCall(CE, St, LCtx) {}\n  CXXMemberCall(const CXXMemberCall &Other) = default;\n\n  void cloneTo(void *Dest) const override { new (Dest) CXXMemberCall(*this); }\n\npublic:\n  const CXXMemberCallExpr *getOriginExpr() const override {\n    return cast<CXXMemberCallExpr>(CXXInstanceCall::getOriginExpr());\n  }\n\n  unsigned getNumArgs() const override {\n    if (const CallExpr *CE = getOriginExpr())\n      return CE->getNumArgs();\n    return 0;\n  }\n\n  const Expr *getArgExpr(unsigned Index) const override {\n    return getOriginExpr()->getArg(Index);\n  }\n\n  const Expr *getCXXThisExpr() const override;\n\n  RuntimeDefinition getRuntimeDefinition() const override;\n\n  Kind getKind() const override { return CE_CXXMember; }\n  StringRef getKindAsString() const override { return \"CXXMemberCall\"; }\n\n  static bool classof(const CallEvent *CA) {\n    return CA->getKind() == CE_CXXMember;\n  }\n};\n\n/// Represents a C++ overloaded operator call where the operator is\n/// implemented as a non-static member function.\n///\n/// Example: <tt>iter + 1</tt>\nclass CXXMemberOperatorCall : public CXXInstanceCall {\n  friend class CallEventManager;\n\nprotected:\n  CXXMemberOperatorCall(const CXXOperatorCallExpr *CE, ProgramStateRef St,\n                        const LocationContext *LCtx)\n      : CXXInstanceCall(CE, St, LCtx) {}\n  CXXMemberOperatorCall(const CXXMemberOperatorCall &Other) = default;\n\n  void cloneTo(void *Dest) const override {\n    new (Dest) CXXMemberOperatorCall(*this);\n  }\n\npublic:\n  const CXXOperatorCallExpr *getOriginExpr() const override {\n    return cast<CXXOperatorCallExpr>(CXXInstanceCall::getOriginExpr());\n  }\n\n  unsigned getNumArgs() const override {\n    return getOriginExpr()->getNumArgs() - 1;\n  }\n\n  const Expr *getArgExpr(unsigned Index) const override {\n    return getOriginExpr()->getArg(Index + 1);\n  }\n\n  const Expr *getCXXThisExpr() const override;\n\n  Kind getKind() const override { return CE_CXXMemberOperator; }\n  StringRef getKindAsString() const override { return \"CXXMemberOperatorCall\"; }\n\n  static bool classof(const CallEvent *CA) {\n    return CA->getKind() == CE_CXXMemberOperator;\n  }\n\n  Optional<unsigned>\n  getAdjustedParameterIndex(unsigned ASTArgumentIndex) const override {\n    // For member operator calls argument 0 on the expression corresponds\n    // to implicit this-parameter on the declaration.\n    return (ASTArgumentIndex > 0) ? Optional<unsigned>(ASTArgumentIndex - 1)\n                                  : None;\n  }\n\n  unsigned getASTArgumentIndex(unsigned CallArgumentIndex) const override {\n    // For member operator calls argument 0 on the expression corresponds\n    // to implicit this-parameter on the declaration.\n    return CallArgumentIndex + 1;\n  }\n\n  OverloadedOperatorKind getOverloadedOperator() const {\n    return getOriginExpr()->getOperator();\n  }\n};\n\n/// Represents an implicit call to a C++ destructor.\n///\n/// This can occur at the end of a scope (for automatic objects), at the end\n/// of a full-expression (for temporaries), or as part of a delete.\nclass CXXDestructorCall : public CXXInstanceCall {\n  friend class CallEventManager;\n\nprotected:\n  using DtorDataTy = llvm::PointerIntPair<const MemRegion *, 1, bool>;\n\n  /// Creates an implicit destructor.\n  ///\n  /// \\param DD The destructor that will be called.\n  /// \\param Trigger The statement whose completion causes this destructor call.\n  /// \\param Target The object region to be destructed.\n  /// \\param St The path-sensitive state at this point in the program.\n  /// \\param LCtx The location context at this point in the program.\n  CXXDestructorCall(const CXXDestructorDecl *DD, const Stmt *Trigger,\n                    const MemRegion *Target, bool IsBaseDestructor,\n                    ProgramStateRef St, const LocationContext *LCtx)\n      : CXXInstanceCall(DD, St, LCtx) {\n    Data = DtorDataTy(Target, IsBaseDestructor).getOpaqueValue();\n    Location = Trigger->getEndLoc();\n  }\n\n  CXXDestructorCall(const CXXDestructorCall &Other) = default;\n\n  void cloneTo(void *Dest) const override {new (Dest) CXXDestructorCall(*this);}\n\npublic:\n  SourceRange getSourceRange() const override { return Location; }\n  unsigned getNumArgs() const override { return 0; }\n\n  RuntimeDefinition getRuntimeDefinition() const override;\n\n  /// Returns the value of the implicit 'this' object.\n  SVal getCXXThisVal() const override;\n\n  /// Returns true if this is a call to a base class destructor.\n  bool isBaseDestructor() const {\n    return DtorDataTy::getFromOpaqueValue(Data).getInt();\n  }\n\n  Kind getKind() const override { return CE_CXXDestructor; }\n  StringRef getKindAsString() const override { return \"CXXDestructorCall\"; }\n\n  static bool classof(const CallEvent *CA) {\n    return CA->getKind() == CE_CXXDestructor;\n  }\n};\n\n/// Represents any constructor invocation. This includes regular constructors\n/// and inherited constructors.\nclass AnyCXXConstructorCall : public AnyFunctionCall {\nprotected:\n  AnyCXXConstructorCall(const Expr *E, const MemRegion *Target,\n                        ProgramStateRef St, const LocationContext *LCtx)\n      : AnyFunctionCall(E, St, LCtx) {\n    assert(E && (isa<CXXConstructExpr>(E) || isa<CXXInheritedCtorInitExpr>(E)));\n    // Target may be null when the region is unknown.\n    Data = Target;\n  }\n\n  void getExtraInvalidatedValues(ValueList &Values,\n         RegionAndSymbolInvalidationTraits *ETraits) const override;\n\n  void getInitialStackFrameContents(const StackFrameContext *CalleeCtx,\n                                    BindingsTy &Bindings) const override;\n\npublic:\n  /// Returns the value of the implicit 'this' object.\n  SVal getCXXThisVal() const;\n\n  static bool classof(const CallEvent *Call) {\n    return Call->getKind() >= CE_BEG_CXX_CONSTRUCTOR_CALLS &&\n           Call->getKind() <= CE_END_CXX_CONSTRUCTOR_CALLS;\n  }\n};\n\n/// Represents a call to a C++ constructor.\n///\n/// Example: \\c T(1)\nclass CXXConstructorCall : public AnyCXXConstructorCall {\n  friend class CallEventManager;\n\nprotected:\n  /// Creates a constructor call.\n  ///\n  /// \\param CE The constructor expression as written in the source.\n  /// \\param Target The region where the object should be constructed. If NULL,\n  ///               a new symbolic region will be used.\n  /// \\param St The path-sensitive state at this point in the program.\n  /// \\param LCtx The location context at this point in the program.\n  CXXConstructorCall(const CXXConstructExpr *CE, const MemRegion *Target,\n                     ProgramStateRef St, const LocationContext *LCtx)\n      : AnyCXXConstructorCall(CE, Target, St, LCtx) {}\n\n  CXXConstructorCall(const CXXConstructorCall &Other) = default;\n\n  void cloneTo(void *Dest) const override { new (Dest) CXXConstructorCall(*this); }\n\npublic:\n  const CXXConstructExpr *getOriginExpr() const override {\n    return cast<CXXConstructExpr>(AnyFunctionCall::getOriginExpr());\n  }\n\n  const CXXConstructorDecl *getDecl() const override {\n    return getOriginExpr()->getConstructor();\n  }\n\n  unsigned getNumArgs() const override { return getOriginExpr()->getNumArgs(); }\n\n  const Expr *getArgExpr(unsigned Index) const override {\n    return getOriginExpr()->getArg(Index);\n  }\n\n  Kind getKind() const override { return CE_CXXConstructor; }\n  StringRef getKindAsString() const override { return \"CXXConstructorCall\"; }\n\n  static bool classof(const CallEvent *CA) {\n    return CA->getKind() == CE_CXXConstructor;\n  }\n};\n\n/// Represents a call to a C++ inherited constructor.\n///\n/// Example: \\c class T : public S { using S::S; }; T(1);\n///\n// Note, it is difficult to model the parameters. This is one of the reasons\n// why we skip analysis of inheriting constructors as top-level functions.\n// CXXInheritedCtorInitExpr doesn't take arguments and doesn't model parameter\n// initialization because there is none: the arguments in the outer\n// CXXConstructExpr directly initialize the parameters of the base class\n// constructor, and no copies are made. (Making a copy of the parameter is\n// incorrect, at least if it's done in an observable way.) The derived class\n// constructor doesn't even exist in the formal model.\n/// E.g., in:\n///\n/// struct X { X *p = this; ~X() {} };\n/// struct A { A(X x) : b(x.p == &x) {} bool b; };\n/// struct B : A { using A::A; };\n/// B b = X{};\n///\n/// ... b.b is initialized to true.\nclass CXXInheritedConstructorCall : public AnyCXXConstructorCall {\n  friend class CallEventManager;\n\nprotected:\n  CXXInheritedConstructorCall(const CXXInheritedCtorInitExpr *CE,\n                              const MemRegion *Target, ProgramStateRef St,\n                              const LocationContext *LCtx)\n      : AnyCXXConstructorCall(CE, Target, St, LCtx) {}\n\n  CXXInheritedConstructorCall(const CXXInheritedConstructorCall &Other) =\n      default;\n\n  void cloneTo(void *Dest) const override {\n    new (Dest) CXXInheritedConstructorCall(*this);\n  }\n\npublic:\n  const CXXInheritedCtorInitExpr *getOriginExpr() const override {\n    return cast<CXXInheritedCtorInitExpr>(AnyFunctionCall::getOriginExpr());\n  }\n\n  const CXXConstructorDecl *getDecl() const override {\n    return getOriginExpr()->getConstructor();\n  }\n\n  /// Obtain the stack frame of the inheriting constructor. Argument expressions\n  /// can be found on the call site of that stack frame.\n  const StackFrameContext *getInheritingStackFrame() const;\n\n  /// Obtain the CXXConstructExpr for the sub-class that inherited the current\n  /// constructor (possibly indirectly). It's the statement that contains\n  /// argument expressions.\n  const CXXConstructExpr *getInheritingConstructor() const {\n    return cast<CXXConstructExpr>(getInheritingStackFrame()->getCallSite());\n  }\n\n  unsigned getNumArgs() const override {\n    return getInheritingConstructor()->getNumArgs();\n  }\n\n  const Expr *getArgExpr(unsigned Index) const override {\n    return getInheritingConstructor()->getArg(Index);\n  }\n\n  SVal getArgSVal(unsigned Index) const override {\n    return getState()->getSVal(\n        getArgExpr(Index),\n        getInheritingStackFrame()->getParent()->getStackFrame());\n  }\n\n  Kind getKind() const override { return CE_CXXInheritedConstructor; }\n  StringRef getKindAsString() const override {\n    return \"CXXInheritedConstructorCall\";\n  }\n\n  static bool classof(const CallEvent *CA) {\n    return CA->getKind() == CE_CXXInheritedConstructor;\n  }\n};\n\n/// Represents the memory allocation call in a C++ new-expression.\n///\n/// This is a call to \"operator new\".\nclass CXXAllocatorCall : public AnyFunctionCall {\n  friend class CallEventManager;\n\nprotected:\n  CXXAllocatorCall(const CXXNewExpr *E, ProgramStateRef St,\n                   const LocationContext *LCtx)\n      : AnyFunctionCall(E, St, LCtx) {}\n  CXXAllocatorCall(const CXXAllocatorCall &Other) = default;\n\n  void cloneTo(void *Dest) const override { new (Dest) CXXAllocatorCall(*this); }\n\npublic:\n  const CXXNewExpr *getOriginExpr() const override {\n    return cast<CXXNewExpr>(AnyFunctionCall::getOriginExpr());\n  }\n\n  const FunctionDecl *getDecl() const override {\n    return getOriginExpr()->getOperatorNew();\n  }\n\n  SVal getObjectUnderConstruction() const {\n    return ExprEngine::getObjectUnderConstruction(getState(), getOriginExpr(),\n                                                  getLocationContext())\n        .getValue();\n  }\n\n  /// Number of non-placement arguments to the call. It is equal to 2 for\n  /// C++17 aligned operator new() calls that have alignment implicitly\n  /// passed as the second argument, and to 1 for other operator new() calls.\n  unsigned getNumImplicitArgs() const {\n    return getOriginExpr()->passAlignment() ? 2 : 1;\n  }\n\n  unsigned getNumArgs() const override {\n    return getOriginExpr()->getNumPlacementArgs() + getNumImplicitArgs();\n  }\n\n  const Expr *getArgExpr(unsigned Index) const override {\n    // The first argument of an allocator call is the size of the allocation.\n    if (Index < getNumImplicitArgs())\n      return nullptr;\n    return getOriginExpr()->getPlacementArg(Index - getNumImplicitArgs());\n  }\n\n  /// Number of placement arguments to the operator new() call. For example,\n  /// standard std::nothrow operator new and standard placement new both have\n  /// 1 implicit argument (size) and 1 placement argument, while regular\n  /// operator new() has 1 implicit argument and 0 placement arguments.\n  const Expr *getPlacementArgExpr(unsigned Index) const {\n    return getOriginExpr()->getPlacementArg(Index);\n  }\n\n  Kind getKind() const override { return CE_CXXAllocator; }\n  StringRef getKindAsString() const override { return \"CXXAllocatorCall\"; }\n\n  static bool classof(const CallEvent *CE) {\n    return CE->getKind() == CE_CXXAllocator;\n  }\n};\n\n/// Represents the memory deallocation call in a C++ delete-expression.\n///\n/// This is a call to \"operator delete\".\n// FIXME: CXXDeleteExpr isn't present for custom delete operators, or even for\n// some those that are in the standard library, like the no-throw or align_val\n// versions.\n// Some pointers:\n// http://lists.llvm.org/pipermail/cfe-dev/2020-April/065080.html\n// clang/test/Analysis/cxx-dynamic-memory-analysis-order.cpp\n// clang/unittests/StaticAnalyzer/CallEventTest.cpp\nclass CXXDeallocatorCall : public AnyFunctionCall {\n  friend class CallEventManager;\n\nprotected:\n  CXXDeallocatorCall(const CXXDeleteExpr *E, ProgramStateRef St,\n                     const LocationContext *LCtx)\n      : AnyFunctionCall(E, St, LCtx) {}\n  CXXDeallocatorCall(const CXXDeallocatorCall &Other) = default;\n\n  void cloneTo(void *Dest) const override {\n    new (Dest) CXXDeallocatorCall(*this);\n  }\n\npublic:\n  const CXXDeleteExpr *getOriginExpr() const override {\n    return cast<CXXDeleteExpr>(AnyFunctionCall::getOriginExpr());\n  }\n\n  const FunctionDecl *getDecl() const override {\n    return getOriginExpr()->getOperatorDelete();\n  }\n\n  unsigned getNumArgs() const override { return getDecl()->getNumParams(); }\n\n  const Expr *getArgExpr(unsigned Index) const override {\n    // CXXDeleteExpr's only have a single argument.\n    return getOriginExpr()->getArgument();\n  }\n\n  Kind getKind() const override { return CE_CXXDeallocator; }\n  StringRef getKindAsString() const override { return \"CXXDeallocatorCall\"; }\n\n  static bool classof(const CallEvent *CE) {\n    return CE->getKind() == CE_CXXDeallocator;\n  }\n};\n\n/// Represents the ways an Objective-C message send can occur.\n//\n// Note to maintainers: OCM_Message should always be last, since it does not\n// need to fit in the Data field's low bits.\nenum ObjCMessageKind {\n  OCM_PropertyAccess,\n  OCM_Subscript,\n  OCM_Message\n};\n\n/// Represents any expression that calls an Objective-C method.\n///\n/// This includes all of the kinds listed in ObjCMessageKind.\nclass ObjCMethodCall : public CallEvent {\n  friend class CallEventManager;\n\n  const PseudoObjectExpr *getContainingPseudoObjectExpr() const;\n\nprotected:\n  ObjCMethodCall(const ObjCMessageExpr *Msg, ProgramStateRef St,\n                 const LocationContext *LCtx)\n      : CallEvent(Msg, St, LCtx) {\n    Data = nullptr;\n  }\n\n  ObjCMethodCall(const ObjCMethodCall &Other) = default;\n\n  void cloneTo(void *Dest) const override { new (Dest) ObjCMethodCall(*this); }\n\n  void getExtraInvalidatedValues(ValueList &Values,\n         RegionAndSymbolInvalidationTraits *ETraits) const override;\n\n  /// Check if the selector may have multiple definitions (may have overrides).\n  virtual bool canBeOverridenInSubclass(ObjCInterfaceDecl *IDecl,\n                                        Selector Sel) const;\n\npublic:\n  const ObjCMessageExpr *getOriginExpr() const override {\n    return cast<ObjCMessageExpr>(CallEvent::getOriginExpr());\n  }\n\n  const ObjCMethodDecl *getDecl() const override {\n    return getOriginExpr()->getMethodDecl();\n  }\n\n  unsigned getNumArgs() const override {\n    return getOriginExpr()->getNumArgs();\n  }\n\n  const Expr *getArgExpr(unsigned Index) const override {\n    return getOriginExpr()->getArg(Index);\n  }\n\n  bool isInstanceMessage() const {\n    return getOriginExpr()->isInstanceMessage();\n  }\n\n  ObjCMethodFamily getMethodFamily() const {\n    return getOriginExpr()->getMethodFamily();\n  }\n\n  Selector getSelector() const {\n    return getOriginExpr()->getSelector();\n  }\n\n  SourceRange getSourceRange() const override;\n\n  /// Returns the value of the receiver at the time of this call.\n  SVal getReceiverSVal() const;\n\n  /// Get the interface for the receiver.\n  ///\n  /// This works whether this is an instance message or a class message.\n  /// However, it currently just uses the static type of the receiver.\n  const ObjCInterfaceDecl *getReceiverInterface() const {\n    return getOriginExpr()->getReceiverInterface();\n  }\n\n  /// Checks if the receiver refers to 'self' or 'super'.\n  bool isReceiverSelfOrSuper() const;\n\n  /// Returns how the message was written in the source (property access,\n  /// subscript, or explicit message send).\n  ObjCMessageKind getMessageKind() const;\n\n  /// Returns true if this property access or subscript is a setter (has the\n  /// form of an assignment).\n  bool isSetter() const {\n    switch (getMessageKind()) {\n    case OCM_Message:\n      llvm_unreachable(\"This is not a pseudo-object access!\");\n    case OCM_PropertyAccess:\n      return getNumArgs() > 0;\n    case OCM_Subscript:\n      return getNumArgs() > 1;\n    }\n    llvm_unreachable(\"Unknown message kind\");\n  }\n\n  // Returns the property accessed by this method, either explicitly via\n  // property syntax or implicitly via a getter or setter method. Returns\n  // nullptr if the call is not a prooperty access.\n  const ObjCPropertyDecl *getAccessedProperty() const;\n\n  RuntimeDefinition getRuntimeDefinition() const override;\n\n  bool argumentsMayEscape() const override;\n\n  void getInitialStackFrameContents(const StackFrameContext *CalleeCtx,\n                                    BindingsTy &Bindings) const override;\n\n  ArrayRef<ParmVarDecl*> parameters() const override;\n\n  Kind getKind() const override { return CE_ObjCMessage; }\n  StringRef getKindAsString() const override { return \"ObjCMethodCall\"; }\n\n  static bool classof(const CallEvent *CA) {\n    return CA->getKind() == CE_ObjCMessage;\n  }\n};\n\nenum CallDescriptionFlags : int {\n  /// Describes a C standard function that is sometimes implemented as a macro\n  /// that expands to a compiler builtin with some __builtin prefix.\n  /// The builtin may as well have a few extra arguments on top of the requested\n  /// number of arguments.\n  CDF_MaybeBuiltin = 1 << 0,\n};\n\n/// This class represents a description of a function call using the number of\n/// arguments and the name of the function.\nclass CallDescription {\n  friend CallEvent;\n\n  mutable IdentifierInfo *II = nullptr;\n  mutable bool IsLookupDone = false;\n  // The list of the qualified names used to identify the specified CallEvent,\n  // e.g. \"{a, b}\" represent the qualified names, like \"a::b\".\n  std::vector<const char *> QualifiedName;\n  Optional<unsigned> RequiredArgs;\n  Optional<size_t> RequiredParams;\n  int Flags;\n\n  // A constructor helper.\n  static Optional<size_t> readRequiredParams(Optional<unsigned> RequiredArgs,\n                                             Optional<size_t> RequiredParams) {\n    if (RequiredParams)\n      return RequiredParams;\n    if (RequiredArgs)\n      return static_cast<size_t>(*RequiredArgs);\n    return None;\n  }\n\npublic:\n  /// Constructs a CallDescription object.\n  ///\n  /// @param QualifiedName The list of the name qualifiers of the function that\n  /// will be matched. The user is allowed to skip any of the qualifiers.\n  /// For example, {\"std\", \"basic_string\", \"c_str\"} would match both\n  /// std::basic_string<...>::c_str() and std::__1::basic_string<...>::c_str().\n  ///\n  /// @param RequiredArgs The number of arguments that is expected to match a\n  /// call. Omit this parameter to match every occurrence of call with a given\n  /// name regardless the number of arguments.\n  CallDescription(int Flags, ArrayRef<const char *> QualifiedName,\n                  Optional<unsigned> RequiredArgs = None,\n                  Optional<size_t> RequiredParams = None)\n      : QualifiedName(QualifiedName), RequiredArgs(RequiredArgs),\n        RequiredParams(readRequiredParams(RequiredArgs, RequiredParams)),\n        Flags(Flags) {}\n\n  /// Construct a CallDescription with default flags.\n  CallDescription(ArrayRef<const char *> QualifiedName,\n                  Optional<unsigned> RequiredArgs = None,\n                  Optional<size_t> RequiredParams = None)\n      : CallDescription(0, QualifiedName, RequiredArgs, RequiredParams) {}\n\n  /// Get the name of the function that this object matches.\n  StringRef getFunctionName() const { return QualifiedName.back(); }\n};\n\n/// An immutable map from CallDescriptions to arbitrary data. Provides a unified\n/// way for checkers to react on function calls.\ntemplate <typename T> class CallDescriptionMap {\n  // Some call descriptions aren't easily hashable (eg., the ones with qualified\n  // names in which some sections are omitted), so let's put them\n  // in a simple vector and use linear lookup.\n  // TODO: Implement an actual map for fast lookup for \"hashable\" call\n  // descriptions (eg., the ones for C functions that just match the name).\n  std::vector<std::pair<CallDescription, T>> LinearMap;\n\npublic:\n  CallDescriptionMap(\n      std::initializer_list<std::pair<CallDescription, T>> &&List)\n      : LinearMap(List) {}\n\n  ~CallDescriptionMap() = default;\n\n  // These maps are usually stored once per checker, so let's make sure\n  // we don't do redundant copies.\n  CallDescriptionMap(const CallDescriptionMap &) = delete;\n  CallDescriptionMap &operator=(const CallDescription &) = delete;\n\n  const T *lookup(const CallEvent &Call) const {\n    // Slow path: linear lookup.\n    // TODO: Implement some sort of fast path.\n    for (const std::pair<CallDescription, T> &I : LinearMap)\n      if (Call.isCalled(I.first))\n        return &I.second;\n\n    return nullptr;\n  }\n};\n\n/// Manages the lifetime of CallEvent objects.\n///\n/// CallEventManager provides a way to create arbitrary CallEvents \"on the\n/// stack\" as if they were value objects by keeping a cache of CallEvent-sized\n/// memory blocks. The CallEvents created by CallEventManager are only valid\n/// for the lifetime of the OwnedCallEvent that holds them; right now these\n/// objects cannot be copied and ownership cannot be transferred.\nclass CallEventManager {\n  friend class CallEvent;\n\n  llvm::BumpPtrAllocator &Alloc;\n  SmallVector<void *, 8> Cache;\n\n  using CallEventTemplateTy = SimpleFunctionCall;\n\n  void reclaim(const void *Memory) {\n    Cache.push_back(const_cast<void *>(Memory));\n  }\n\n  /// Returns memory that can be initialized as a CallEvent.\n  void *allocate() {\n    if (Cache.empty())\n      return Alloc.Allocate<CallEventTemplateTy>();\n    else\n      return Cache.pop_back_val();\n  }\n\n  template <typename T, typename Arg>\n  T *create(Arg A, ProgramStateRef St, const LocationContext *LCtx) {\n    static_assert(sizeof(T) == sizeof(CallEventTemplateTy),\n                  \"CallEvent subclasses are not all the same size\");\n    return new (allocate()) T(A, St, LCtx);\n  }\n\n  template <typename T, typename Arg1, typename Arg2>\n  T *create(Arg1 A1, Arg2 A2, ProgramStateRef St, const LocationContext *LCtx) {\n    static_assert(sizeof(T) == sizeof(CallEventTemplateTy),\n                  \"CallEvent subclasses are not all the same size\");\n    return new (allocate()) T(A1, A2, St, LCtx);\n  }\n\n  template <typename T, typename Arg1, typename Arg2, typename Arg3>\n  T *create(Arg1 A1, Arg2 A2, Arg3 A3, ProgramStateRef St,\n            const LocationContext *LCtx) {\n    static_assert(sizeof(T) == sizeof(CallEventTemplateTy),\n                  \"CallEvent subclasses are not all the same size\");\n    return new (allocate()) T(A1, A2, A3, St, LCtx);\n  }\n\n  template <typename T, typename Arg1, typename Arg2, typename Arg3,\n            typename Arg4>\n  T *create(Arg1 A1, Arg2 A2, Arg3 A3, Arg4 A4, ProgramStateRef St,\n            const LocationContext *LCtx) {\n    static_assert(sizeof(T) == sizeof(CallEventTemplateTy),\n                  \"CallEvent subclasses are not all the same size\");\n    return new (allocate()) T(A1, A2, A3, A4, St, LCtx);\n  }\n\npublic:\n  CallEventManager(llvm::BumpPtrAllocator &alloc) : Alloc(alloc) {}\n\n  /// Gets an outside caller given a callee context.\n  CallEventRef<>\n  getCaller(const StackFrameContext *CalleeCtx, ProgramStateRef State);\n\n  /// Gets a call event for a function call, Objective-C method call,\n  /// or a 'new' call.\n  CallEventRef<>\n  getCall(const Stmt *S, ProgramStateRef State,\n          const LocationContext *LC);\n\n  CallEventRef<>\n  getSimpleCall(const CallExpr *E, ProgramStateRef State,\n                const LocationContext *LCtx);\n\n  CallEventRef<ObjCMethodCall>\n  getObjCMethodCall(const ObjCMessageExpr *E, ProgramStateRef State,\n                    const LocationContext *LCtx) {\n    return create<ObjCMethodCall>(E, State, LCtx);\n  }\n\n  CallEventRef<CXXConstructorCall>\n  getCXXConstructorCall(const CXXConstructExpr *E, const MemRegion *Target,\n                        ProgramStateRef State, const LocationContext *LCtx) {\n    return create<CXXConstructorCall>(E, Target, State, LCtx);\n  }\n\n  CallEventRef<CXXInheritedConstructorCall>\n  getCXXInheritedConstructorCall(const CXXInheritedCtorInitExpr *E,\n                                 const MemRegion *Target, ProgramStateRef State,\n                                 const LocationContext *LCtx) {\n    return create<CXXInheritedConstructorCall>(E, Target, State, LCtx);\n  }\n\n  CallEventRef<CXXDestructorCall>\n  getCXXDestructorCall(const CXXDestructorDecl *DD, const Stmt *Trigger,\n                       const MemRegion *Target, bool IsBase,\n                       ProgramStateRef State, const LocationContext *LCtx) {\n    return create<CXXDestructorCall>(DD, Trigger, Target, IsBase, State, LCtx);\n  }\n\n  CallEventRef<CXXAllocatorCall>\n  getCXXAllocatorCall(const CXXNewExpr *E, ProgramStateRef State,\n                      const LocationContext *LCtx) {\n    return create<CXXAllocatorCall>(E, State, LCtx);\n  }\n\n  CallEventRef<CXXDeallocatorCall>\n  getCXXDeallocatorCall(const CXXDeleteExpr *E, ProgramStateRef State,\n                        const LocationContext *LCtx) {\n    return create<CXXDeallocatorCall>(E, State, LCtx);\n  }\n};\n\ntemplate <typename T>\nCallEventRef<T> CallEvent::cloneWithState(ProgramStateRef NewState) const {\n  assert(isa<T>(*this) && \"Cloning to unrelated type\");\n  static_assert(sizeof(T) == sizeof(CallEvent),\n                \"Subclasses may not add fields\");\n\n  if (NewState == State)\n    return cast<T>(this);\n\n  CallEventManager &Mgr = State->getStateManager().getCallEventManager();\n  T *Copy = static_cast<T *>(Mgr.allocate());\n  cloneTo(Copy);\n  assert(Copy->getKind() == this->getKind() && \"Bad copy\");\n\n  Copy->State = NewState;\n  return Copy;\n}\n\ninline void CallEvent::Release() const {\n  assert(RefCount > 0 && \"Reference count is already zero.\");\n  --RefCount;\n\n  if (RefCount > 0)\n    return;\n\n  CallEventManager &Mgr = State->getStateManager().getCallEventManager();\n  Mgr.reclaim(this);\n\n  this->~CallEvent();\n}\n\n} // namespace ento\n\n} // namespace clang\n\nnamespace llvm {\n\n// Support isa<>, cast<>, and dyn_cast<> for CallEventRef.\ntemplate<class T> struct simplify_type< clang::ento::CallEventRef<T>> {\n  using SimpleType = const T *;\n\n  static SimpleType\n  getSimplifiedValue(clang::ento::CallEventRef<T> Val) {\n    return Val.get();\n  }\n};\n\n} // namespace llvm\n\n#endif // LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_CALLEVENT_H\n"}, "57": {"id": 57, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CoreEngine.h", "content": "//===- CoreEngine.h - Path-Sensitive Dataflow Engine ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines a generic engine for intraprocedural, path-sensitive,\n//  dataflow analysis via graph reachability.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_COREENGINE_H\n#define LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_COREENGINE_H\n\n#include \"clang/AST/Stmt.h\"\n#include \"clang/Analysis/AnalysisDeclContext.h\"\n#include \"clang/Analysis/CFG.h\"\n#include \"clang/Analysis/ProgramPoint.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/BlockCounter.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ExplodedGraph.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState_Fwd.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/WorkList.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/Support/Casting.h\"\n#include <cassert>\n#include <memory>\n#include <utility>\n#include <vector>\n\nnamespace clang {\n\nclass AnalyzerOptions;\nclass CXXBindTemporaryExpr;\nclass Expr;\nclass LabelDecl;\n\nnamespace ento {\n\nclass FunctionSummariesTy;\nclass ExprEngine;\n\n//===----------------------------------------------------------------------===//\n/// CoreEngine - Implements the core logic of the graph-reachability\n///   analysis. It traverses the CFG and generates the ExplodedGraph.\n///   Program \"states\" are treated as opaque void pointers.\n///   The template class CoreEngine (which subclasses CoreEngine)\n///   provides the matching component to the engine that knows the actual types\n///   for states.  Note that this engine only dispatches to transfer functions\n///   at the statement and block-level.  The analyses themselves must implement\n///   any transfer function logic and the sub-expression level (if any).\nclass CoreEngine {\n  friend class CommonNodeBuilder;\n  friend class EndOfFunctionNodeBuilder;\n  friend class ExprEngine;\n  friend class IndirectGotoNodeBuilder;\n  friend class NodeBuilder;\n  friend struct NodeBuilderContext;\n  friend class SwitchNodeBuilder;\n\npublic:\n  using BlocksExhausted =\n      std::vector<std::pair<BlockEdge, const ExplodedNode *>>;\n\n  using BlocksAborted =\n      std::vector<std::pair<const CFGBlock *, const ExplodedNode *>>;\n\nprivate:\n  ExprEngine &ExprEng;\n\n  /// G - The simulation graph.  Each node is a (location,state) pair.\n  mutable ExplodedGraph G;\n\n  /// WList - A set of queued nodes that need to be processed by the\n  ///  worklist algorithm.  It is up to the implementation of WList to decide\n  ///  the order that nodes are processed.\n  std::unique_ptr<WorkList> WList;\n\n  /// BCounterFactory - A factory object for created BlockCounter objects.\n  ///   These are used to record for key nodes in the ExplodedGraph the\n  ///   number of times different CFGBlocks have been visited along a path.\n  BlockCounter::Factory BCounterFactory;\n\n  /// The locations where we stopped doing work because we visited a location\n  ///  too many times.\n  BlocksExhausted blocksExhausted;\n\n  /// The locations where we stopped because the engine aborted analysis,\n  /// usually because it could not reason about something.\n  BlocksAborted blocksAborted;\n\n  /// The information about functions shared by the whole translation unit.\n  /// (This data is owned by AnalysisConsumer.)\n  FunctionSummariesTy *FunctionSummaries;\n\n  /// Add path note tags along the path when we see that something interesting\n  /// is happening. This field is the allocator for such tags.\n  NoteTag::Factory NoteTags;\n\n  void generateNode(const ProgramPoint &Loc,\n                    ProgramStateRef State,\n                    ExplodedNode *Pred);\n\n  void HandleBlockEdge(const BlockEdge &E, ExplodedNode *Pred);\n  void HandleBlockEntrance(const BlockEntrance &E, ExplodedNode *Pred);\n  void HandleBlockExit(const CFGBlock *B, ExplodedNode *Pred);\n\n  void HandleCallEnter(const CallEnter &CE, ExplodedNode *Pred);\n\n  void HandlePostStmt(const CFGBlock *B, unsigned StmtIdx, ExplodedNode *Pred);\n\n  void HandleBranch(const Stmt *Cond, const Stmt *Term, const CFGBlock *B,\n                    ExplodedNode *Pred);\n  void HandleCleanupTemporaryBranch(const CXXBindTemporaryExpr *BTE,\n                                    const CFGBlock *B, ExplodedNode *Pred);\n\n  /// Handle conditional logic for running static initializers.\n  void HandleStaticInit(const DeclStmt *DS, const CFGBlock *B,\n                        ExplodedNode *Pred);\n\n  void HandleVirtualBaseBranch(const CFGBlock *B, ExplodedNode *Pred);\n\nprivate:\n  ExplodedNode *generateCallExitBeginNode(ExplodedNode *N,\n                                          const ReturnStmt *RS);\n\npublic:\n  /// Construct a CoreEngine object to analyze the provided CFG.\n  CoreEngine(ExprEngine &exprengine,\n             FunctionSummariesTy *FS,\n             AnalyzerOptions &Opts);\n\n  CoreEngine(const CoreEngine &) = delete;\n  CoreEngine &operator=(const CoreEngine &) = delete;\n\n  /// getGraph - Returns the exploded graph.\n  ExplodedGraph &getGraph() { return G; }\n\n  /// ExecuteWorkList - Run the worklist algorithm for a maximum number of\n  ///  steps.  Returns true if there is still simulation state on the worklist.\n  bool ExecuteWorkList(const LocationContext *L, unsigned Steps,\n                       ProgramStateRef InitState);\n\n  /// Returns true if there is still simulation state on the worklist.\n  bool ExecuteWorkListWithInitialState(const LocationContext *L,\n                                       unsigned Steps,\n                                       ProgramStateRef InitState,\n                                       ExplodedNodeSet &Dst);\n\n  /// Dispatch the work list item based on the given location information.\n  /// Use Pred parameter as the predecessor state.\n  void dispatchWorkItem(ExplodedNode* Pred, ProgramPoint Loc,\n                        const WorkListUnit& WU);\n\n  // Functions for external checking of whether we have unfinished work\n  bool wasBlockAborted() const { return !blocksAborted.empty(); }\n  bool wasBlocksExhausted() const { return !blocksExhausted.empty(); }\n  bool hasWorkRemaining() const { return wasBlocksExhausted() ||\n                                         WList->hasWork() ||\n                                         wasBlockAborted(); }\n\n  /// Inform the CoreEngine that a basic block was aborted because\n  /// it could not be completely analyzed.\n  void addAbortedBlock(const ExplodedNode *node, const CFGBlock *block) {\n    blocksAborted.push_back(std::make_pair(block, node));\n  }\n\n  WorkList *getWorkList() const { return WList.get(); }\n\n  BlocksExhausted::const_iterator blocks_exhausted_begin() const {\n    return blocksExhausted.begin();\n  }\n\n  BlocksExhausted::const_iterator blocks_exhausted_end() const {\n    return blocksExhausted.end();\n  }\n\n  BlocksAborted::const_iterator blocks_aborted_begin() const {\n    return blocksAborted.begin();\n  }\n\n  BlocksAborted::const_iterator blocks_aborted_end() const {\n    return blocksAborted.end();\n  }\n\n  /// Enqueue the given set of nodes onto the work list.\n  void enqueue(ExplodedNodeSet &Set);\n\n  /// Enqueue nodes that were created as a result of processing\n  /// a statement onto the work list.\n  void enqueue(ExplodedNodeSet &Set, const CFGBlock *Block, unsigned Idx);\n\n  /// enqueue the nodes corresponding to the end of function onto the\n  /// end of path / work list.\n  void enqueueEndOfFunction(ExplodedNodeSet &Set, const ReturnStmt *RS);\n\n  /// Enqueue a single node created as a result of statement processing.\n  void enqueueStmtNode(ExplodedNode *N, const CFGBlock *Block, unsigned Idx);\n\n  NoteTag::Factory &getNoteTags() { return NoteTags; }\n};\n\n// TODO: Turn into a class.\nstruct NodeBuilderContext {\n  const CoreEngine &Eng;\n  const CFGBlock *Block;\n  const LocationContext *LC;\n\n  NodeBuilderContext(const CoreEngine &E, const CFGBlock *B, ExplodedNode *N)\n      : Eng(E), Block(B), LC(N->getLocationContext()) { assert(B); }\n\n  /// Return the CFGBlock associated with this builder.\n  const CFGBlock *getBlock() const { return Block; }\n\n  /// Returns the number of times the current basic block has been\n  /// visited on the exploded graph path.\n  unsigned blockCount() const {\n    return Eng.WList->getBlockCounter().getNumVisited(\n                    LC->getStackFrame(),\n                    Block->getBlockID());\n  }\n};\n\n/// \\class NodeBuilder\n/// This is the simplest builder which generates nodes in the\n/// ExplodedGraph.\n///\n/// The main benefit of the builder is that it automatically tracks the\n/// frontier nodes (or destination set). This is the set of nodes which should\n/// be propagated to the next step / builder. They are the nodes which have been\n/// added to the builder (either as the input node set or as the newly\n/// constructed nodes) but did not have any outgoing transitions added.\nclass NodeBuilder {\n  virtual void anchor();\n\nprotected:\n  const NodeBuilderContext &C;\n\n  /// Specifies if the builder results have been finalized. For example, if it\n  /// is set to false, autotransitions are yet to be generated.\n  bool Finalized;\n\n  bool HasGeneratedNodes = false;\n\n  /// The frontier set - a set of nodes which need to be propagated after\n  /// the builder dies.\n  ExplodedNodeSet &Frontier;\n\n  /// Checks if the results are ready.\n  virtual bool checkResults() {\n    return Finalized;\n  }\n\n  bool hasNoSinksInFrontier() {\n    for (const auto  I : Frontier)\n      if (I->isSink())\n        return false;\n    return true;\n  }\n\n  /// Allow subclasses to finalize results before result_begin() is executed.\n  virtual void finalizeResults() {}\n\n  ExplodedNode *generateNodeImpl(const ProgramPoint &PP,\n                                 ProgramStateRef State,\n                                 ExplodedNode *Pred,\n                                 bool MarkAsSink = false);\n\npublic:\n  NodeBuilder(ExplodedNode *SrcNode, ExplodedNodeSet &DstSet,\n              const NodeBuilderContext &Ctx, bool F = true)\n      : C(Ctx), Finalized(F), Frontier(DstSet) {\n    Frontier.Add(SrcNode);\n  }\n\n  NodeBuilder(const ExplodedNodeSet &SrcSet, ExplodedNodeSet &DstSet,\n              const NodeBuilderContext &Ctx, bool F = true)\n      : C(Ctx), Finalized(F), Frontier(DstSet) {\n    Frontier.insert(SrcSet);\n    assert(hasNoSinksInFrontier());\n  }\n\n  virtual ~NodeBuilder() = default;\n\n  /// Generates a node in the ExplodedGraph.\n  ExplodedNode *generateNode(const ProgramPoint &PP,\n                             ProgramStateRef State,\n                             ExplodedNode *Pred) {\n    return generateNodeImpl(PP, State, Pred, false);\n  }\n\n  /// Generates a sink in the ExplodedGraph.\n  ///\n  /// When a node is marked as sink, the exploration from the node is stopped -\n  /// the node becomes the last node on the path and certain kinds of bugs are\n  /// suppressed.\n  ExplodedNode *generateSink(const ProgramPoint &PP,\n                             ProgramStateRef State,\n                             ExplodedNode *Pred) {\n    return generateNodeImpl(PP, State, Pred, true);\n  }\n\n  const ExplodedNodeSet &getResults() {\n    finalizeResults();\n    assert(checkResults());\n    return Frontier;\n  }\n\n  using iterator = ExplodedNodeSet::iterator;\n\n  /// Iterators through the results frontier.\n  iterator begin() {\n    finalizeResults();\n    assert(checkResults());\n    return Frontier.begin();\n  }\n\n  iterator end() {\n    finalizeResults();\n    return Frontier.end();\n  }\n\n  const NodeBuilderContext &getContext() { return C; }\n  bool hasGeneratedNodes() { return HasGeneratedNodes; }\n\n  void takeNodes(const ExplodedNodeSet &S) {\n    for (const auto I : S)\n      Frontier.erase(I);\n  }\n\n  void takeNodes(ExplodedNode *N) { Frontier.erase(N); }\n  void addNodes(const ExplodedNodeSet &S) { Frontier.insert(S); }\n  void addNodes(ExplodedNode *N) { Frontier.Add(N); }\n};\n\n/// \\class NodeBuilderWithSinks\n/// This node builder keeps track of the generated sink nodes.\nclass NodeBuilderWithSinks: public NodeBuilder {\n  void anchor() override;\n\nprotected:\n  SmallVector<ExplodedNode*, 2> sinksGenerated;\n  ProgramPoint &Location;\n\npublic:\n  NodeBuilderWithSinks(ExplodedNode *Pred, ExplodedNodeSet &DstSet,\n                       const NodeBuilderContext &Ctx, ProgramPoint &L)\n      : NodeBuilder(Pred, DstSet, Ctx), Location(L) {}\n\n  ExplodedNode *generateNode(ProgramStateRef State,\n                             ExplodedNode *Pred,\n                             const ProgramPointTag *Tag = nullptr) {\n    const ProgramPoint &LocalLoc = (Tag ? Location.withTag(Tag) : Location);\n    return NodeBuilder::generateNode(LocalLoc, State, Pred);\n  }\n\n  ExplodedNode *generateSink(ProgramStateRef State, ExplodedNode *Pred,\n                             const ProgramPointTag *Tag = nullptr) {\n    const ProgramPoint &LocalLoc = (Tag ? Location.withTag(Tag) : Location);\n    ExplodedNode *N = NodeBuilder::generateSink(LocalLoc, State, Pred);\n    if (N && N->isSink())\n      sinksGenerated.push_back(N);\n    return N;\n  }\n\n  const SmallVectorImpl<ExplodedNode*> &getSinks() const {\n    return sinksGenerated;\n  }\n};\n\n/// \\class StmtNodeBuilder\n/// This builder class is useful for generating nodes that resulted from\n/// visiting a statement. The main difference from its parent NodeBuilder is\n/// that it creates a statement specific ProgramPoint.\nclass StmtNodeBuilder: public NodeBuilder {\n  NodeBuilder *EnclosingBldr;\n\npublic:\n  /// Constructs a StmtNodeBuilder. If the builder is going to process\n  /// nodes currently owned by another builder(with larger scope), use\n  /// Enclosing builder to transfer ownership.\n  StmtNodeBuilder(ExplodedNode *SrcNode, ExplodedNodeSet &DstSet,\n                  const NodeBuilderContext &Ctx,\n                  NodeBuilder *Enclosing = nullptr)\n      : NodeBuilder(SrcNode, DstSet, Ctx), EnclosingBldr(Enclosing) {\n    if (EnclosingBldr)\n      EnclosingBldr->takeNodes(SrcNode);\n  }\n\n  StmtNodeBuilder(ExplodedNodeSet &SrcSet, ExplodedNodeSet &DstSet,\n                  const NodeBuilderContext &Ctx,\n                  NodeBuilder *Enclosing = nullptr)\n      : NodeBuilder(SrcSet, DstSet, Ctx), EnclosingBldr(Enclosing) {\n    if (EnclosingBldr)\n      for (const auto I : SrcSet)\n        EnclosingBldr->takeNodes(I);\n  }\n\n  ~StmtNodeBuilder() override;\n\n  using NodeBuilder::generateNode;\n  using NodeBuilder::generateSink;\n\n  ExplodedNode *generateNode(const Stmt *S,\n                             ExplodedNode *Pred,\n                             ProgramStateRef St,\n                             const ProgramPointTag *tag = nullptr,\n                             ProgramPoint::Kind K = ProgramPoint::PostStmtKind){\n    const ProgramPoint &L = ProgramPoint::getProgramPoint(S, K,\n                                  Pred->getLocationContext(), tag);\n    return NodeBuilder::generateNode(L, St, Pred);\n  }\n\n  ExplodedNode *generateSink(const Stmt *S,\n                             ExplodedNode *Pred,\n                             ProgramStateRef St,\n                             const ProgramPointTag *tag = nullptr,\n                             ProgramPoint::Kind K = ProgramPoint::PostStmtKind){\n    const ProgramPoint &L = ProgramPoint::getProgramPoint(S, K,\n                                  Pred->getLocationContext(), tag);\n    return NodeBuilder::generateSink(L, St, Pred);\n  }\n};\n\n/// BranchNodeBuilder is responsible for constructing the nodes\n/// corresponding to the two branches of the if statement - true and false.\nclass BranchNodeBuilder: public NodeBuilder {\n  const CFGBlock *DstT;\n  const CFGBlock *DstF;\n\n  bool InFeasibleTrue;\n  bool InFeasibleFalse;\n\n  void anchor() override;\n\npublic:\n  BranchNodeBuilder(ExplodedNode *SrcNode, ExplodedNodeSet &DstSet,\n                    const NodeBuilderContext &C,\n                    const CFGBlock *dstT, const CFGBlock *dstF)\n      : NodeBuilder(SrcNode, DstSet, C), DstT(dstT), DstF(dstF),\n        InFeasibleTrue(!DstT), InFeasibleFalse(!DstF) {\n    // The branch node builder does not generate autotransitions.\n    // If there are no successors it means that both branches are infeasible.\n    takeNodes(SrcNode);\n  }\n\n  BranchNodeBuilder(const ExplodedNodeSet &SrcSet, ExplodedNodeSet &DstSet,\n                    const NodeBuilderContext &C,\n                    const CFGBlock *dstT, const CFGBlock *dstF)\n      : NodeBuilder(SrcSet, DstSet, C), DstT(dstT), DstF(dstF),\n        InFeasibleTrue(!DstT), InFeasibleFalse(!DstF) {\n    takeNodes(SrcSet);\n  }\n\n  ExplodedNode *generateNode(ProgramStateRef State, bool branch,\n                             ExplodedNode *Pred);\n\n  const CFGBlock *getTargetBlock(bool branch) const {\n    return branch ? DstT : DstF;\n  }\n\n  void markInfeasible(bool branch) {\n    if (branch)\n      InFeasibleTrue = true;\n    else\n      InFeasibleFalse = true;\n  }\n\n  bool isFeasible(bool branch) {\n    return branch ? !InFeasibleTrue : !InFeasibleFalse;\n  }\n};\n\nclass IndirectGotoNodeBuilder {\n  CoreEngine& Eng;\n  const CFGBlock *Src;\n  const CFGBlock &DispatchBlock;\n  const Expr *E;\n  ExplodedNode *Pred;\n\npublic:\n  IndirectGotoNodeBuilder(ExplodedNode *pred, const CFGBlock *src,\n                    const Expr *e, const CFGBlock *dispatch, CoreEngine* eng)\n      : Eng(*eng), Src(src), DispatchBlock(*dispatch), E(e), Pred(pred) {}\n\n  class iterator {\n    friend class IndirectGotoNodeBuilder;\n\n    CFGBlock::const_succ_iterator I;\n\n    iterator(CFGBlock::const_succ_iterator i) : I(i) {}\n\n  public:\n    iterator &operator++() { ++I; return *this; }\n    bool operator!=(const iterator &X) const { return I != X.I; }\n\n    const LabelDecl *getLabel() const {\n      return cast<LabelStmt>((*I)->getLabel())->getDecl();\n    }\n\n    const CFGBlock *getBlock() const {\n      return *I;\n    }\n  };\n\n  iterator begin() { return iterator(DispatchBlock.succ_begin()); }\n  iterator end() { return iterator(DispatchBlock.succ_end()); }\n\n  ExplodedNode *generateNode(const iterator &I,\n                             ProgramStateRef State,\n                             bool isSink = false);\n\n  const Expr *getTarget() const { return E; }\n\n  ProgramStateRef getState() const { return Pred->State; }\n\n  const LocationContext *getLocationContext() const {\n    return Pred->getLocationContext();\n  }\n};\n\nclass SwitchNodeBuilder {\n  CoreEngine& Eng;\n  const CFGBlock *Src;\n  const Expr *Condition;\n  ExplodedNode *Pred;\n\npublic:\n  SwitchNodeBuilder(ExplodedNode *pred, const CFGBlock *src,\n                    const Expr *condition, CoreEngine* eng)\n      : Eng(*eng), Src(src), Condition(condition), Pred(pred) {}\n\n  class iterator {\n    friend class SwitchNodeBuilder;\n\n    CFGBlock::const_succ_reverse_iterator I;\n\n    iterator(CFGBlock::const_succ_reverse_iterator i) : I(i) {}\n\n  public:\n    iterator &operator++() { ++I; return *this; }\n    bool operator!=(const iterator &X) const { return I != X.I; }\n    bool operator==(const iterator &X) const { return I == X.I; }\n\n    const CaseStmt *getCase() const {\n      return cast<CaseStmt>((*I)->getLabel());\n    }\n\n    const CFGBlock *getBlock() const {\n      return *I;\n    }\n  };\n\n  iterator begin() { return iterator(Src->succ_rbegin()+1); }\n  iterator end() { return iterator(Src->succ_rend()); }\n\n  const SwitchStmt *getSwitch() const {\n    return cast<SwitchStmt>(Src->getTerminator());\n  }\n\n  ExplodedNode *generateCaseStmtNode(const iterator &I,\n                                     ProgramStateRef State);\n\n  ExplodedNode *generateDefaultCaseNode(ProgramStateRef State,\n                                        bool isSink = false);\n\n  const Expr *getCondition() const { return Condition; }\n\n  ProgramStateRef getState() const { return Pred->State; }\n\n  const LocationContext *getLocationContext() const {\n    return Pred->getLocationContext();\n  }\n};\n\n} // namespace ento\n\n} // namespace clang\n\n#endif // LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_COREENGINE_H\n"}, "58": {"id": 58, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/Environment.h", "content": "//===- Environment.h - Map from Stmt* to Locations/Values -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defined the Environment and EnvironmentManager classes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_ENVIRONMENT_H\n#define LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_ENVIRONMENT_H\n\n#include \"clang/Analysis/AnalysisDeclContext.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState_Fwd.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SVals.h\"\n#include \"llvm/ADT/ImmutableMap.h\"\n#include <utility>\n\nnamespace clang {\n\nclass Stmt;\n\nnamespace ento {\n\nclass SValBuilder;\nclass SymbolReaper;\n\n/// An entry in the environment consists of a Stmt and an LocationContext.\n/// This allows the environment to manage context-sensitive bindings,\n/// which is essentially for modeling recursive function analysis, among\n/// other things.\nclass EnvironmentEntry : public std::pair<const Stmt *,\n                                          const StackFrameContext *> {\npublic:\n  EnvironmentEntry(const Stmt *s, const LocationContext *L);\n\n  const Stmt *getStmt() const { return first; }\n  const LocationContext *getLocationContext() const { return second; }\n\n  /// Profile an EnvironmentEntry for inclusion in a FoldingSet.\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      const EnvironmentEntry &E) {\n    ID.AddPointer(E.getStmt());\n    ID.AddPointer(E.getLocationContext());\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    Profile(ID, *this);\n  }\n};\n\n/// An immutable map from EnvironemntEntries to SVals.\nclass Environment {\nprivate:\n  friend class EnvironmentManager;\n\n  using BindingsTy = llvm::ImmutableMap<EnvironmentEntry, SVal>;\n\n  BindingsTy ExprBindings;\n\n  Environment(BindingsTy eb) : ExprBindings(eb) {}\n\n  SVal lookupExpr(const EnvironmentEntry &E) const;\n\npublic:\n  using iterator = BindingsTy::iterator;\n\n  iterator begin() const { return ExprBindings.begin(); }\n  iterator end() const { return ExprBindings.end(); }\n\n  /// Fetches the current binding of the expression in the\n  /// Environment.\n  SVal getSVal(const EnvironmentEntry &E, SValBuilder &svalBuilder) const;\n\n  /// Profile - Profile the contents of an Environment object for use\n  ///  in a FoldingSet.\n  static void Profile(llvm::FoldingSetNodeID& ID, const Environment* env) {\n    env->ExprBindings.Profile(ID);\n  }\n\n  /// Profile - Used to profile the contents of this object for inclusion\n  ///  in a FoldingSet.\n  void Profile(llvm::FoldingSetNodeID& ID) const {\n    Profile(ID, this);\n  }\n\n  bool operator==(const Environment& RHS) const {\n    return ExprBindings == RHS.ExprBindings;\n  }\n\n  void printJson(raw_ostream &Out, const ASTContext &Ctx,\n                 const LocationContext *LCtx = nullptr, const char *NL = \"\\n\",\n                 unsigned int Space = 0, bool IsDot = false) const;\n};\n\nclass EnvironmentManager {\nprivate:\n  using FactoryTy = Environment::BindingsTy::Factory;\n\n  FactoryTy F;\n\npublic:\n  EnvironmentManager(llvm::BumpPtrAllocator &Allocator) : F(Allocator) {}\n\n  Environment getInitialEnvironment() {\n    return Environment(F.getEmptyMap());\n  }\n\n  /// Bind a symbolic value to the given environment entry.\n  Environment bindExpr(Environment Env, const EnvironmentEntry &E, SVal V,\n                       bool Invalidate);\n\n  Environment removeDeadBindings(Environment Env,\n                                 SymbolReaper &SymReaper,\n                                 ProgramStateRef state);\n};\n\n} // namespace ento\n\n} // namespace clang\n\n#endif // LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_ENVIRONMENT_H\n"}, "59": {"id": 59, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExplodedGraph.h", "content": "//===- ExplodedGraph.h - Local, Path-Sens. \"Exploded Graph\" -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the template classes ExplodedNode and ExplodedGraph,\n//  which represent a path-sensitive, intra-procedural \"exploded graph.\"\n//  See \"Precise interprocedural dataflow analysis via graph reachability\"\n//  by Reps, Horwitz, and Sagiv\n//  (http://portal.acm.org/citation.cfm?id=199462) for the definition of an\n//  exploded graph.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_EXPLODEDGRAPH_H\n#define LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_EXPLODEDGRAPH_H\n\n#include \"clang/Analysis/AnalysisDeclContext.h\"\n#include \"clang/Analysis/ProgramPoint.h\"\n#include \"clang/Analysis/Support/BumpVector.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState_Fwd.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SVals.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DepthFirstIterator.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/GraphTraits.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Compiler.h\"\n#include <cassert>\n#include <cstdint>\n#include <memory>\n#include <utility>\n#include <vector>\n\nnamespace clang {\n\nclass CFG;\nclass Decl;\nclass Expr;\nclass ParentMap;\nclass Stmt;\n\nnamespace ento {\n\nclass ExplodedGraph;\n\n//===----------------------------------------------------------------------===//\n// ExplodedGraph \"implementation\" classes.  These classes are not typed to\n// contain a specific kind of state.  Typed-specialized versions are defined\n// on top of these classes.\n//===----------------------------------------------------------------------===//\n\n// ExplodedNode is not constified all over the engine because we need to add\n// successors to it at any time after creating it.\n\nclass ExplodedNode : public llvm::FoldingSetNode {\n  friend class BranchNodeBuilder;\n  friend class CoreEngine;\n  friend class EndOfFunctionNodeBuilder;\n  friend class ExplodedGraph;\n  friend class IndirectGotoNodeBuilder;\n  friend class NodeBuilder;\n  friend class SwitchNodeBuilder;\n\n  /// Efficiently stores a list of ExplodedNodes, or an optional flag.\n  ///\n  /// NodeGroup provides opaque storage for a list of ExplodedNodes, optimizing\n  /// for the case when there is only one node in the group. This is a fairly\n  /// common case in an ExplodedGraph, where most nodes have only one\n  /// predecessor and many have only one successor. It can also be used to\n  /// store a flag rather than a node list, which ExplodedNode uses to mark\n  /// whether a node is a sink. If the flag is set, the group is implicitly\n  /// empty and no nodes may be added.\n  class NodeGroup {\n    // Conceptually a discriminated union. If the low bit is set, the node is\n    // a sink. If the low bit is not set, the pointer refers to the storage\n    // for the nodes in the group.\n    // This is not a PointerIntPair in order to keep the storage type opaque.\n    uintptr_t P;\n\n  public:\n    NodeGroup(bool Flag = false) : P(Flag) {\n      assert(getFlag() == Flag);\n    }\n\n    ExplodedNode * const *begin() const;\n\n    ExplodedNode * const *end() const;\n\n    unsigned size() const;\n\n    bool empty() const { return P == 0 || getFlag() != 0; }\n\n    /// Adds a node to the list.\n    ///\n    /// The group must not have been created with its flag set.\n    void addNode(ExplodedNode *N, ExplodedGraph &G);\n\n    /// Replaces the single node in this group with a new node.\n    ///\n    /// Note that this should only be used when you know the group was not\n    /// created with its flag set, and that the group is empty or contains\n    /// only a single node.\n    void replaceNode(ExplodedNode *node);\n\n    /// Returns whether this group was created with its flag set.\n    bool getFlag() const {\n      return (P & 1);\n    }\n  };\n\n  /// Location - The program location (within a function body) associated\n  ///  with this node.\n  const ProgramPoint Location;\n\n  /// State - The state associated with this node.\n  ProgramStateRef State;\n\n  /// Preds - The predecessors of this node.\n  NodeGroup Preds;\n\n  /// Succs - The successors of this node.\n  NodeGroup Succs;\n\n  int64_t Id;\n\npublic:\n  explicit ExplodedNode(const ProgramPoint &loc, ProgramStateRef state,\n                        int64_t Id, bool IsSink)\n      : Location(loc), State(std::move(state)), Succs(IsSink), Id(Id) {\n    assert(isSink() == IsSink);\n  }\n\n  /// getLocation - Returns the edge associated with the given node.\n  ProgramPoint getLocation() const { return Location; }\n\n  const LocationContext *getLocationContext() const {\n    return getLocation().getLocationContext();\n  }\n\n  const StackFrameContext *getStackFrame() const {\n    return getLocation().getStackFrame();\n  }\n\n  const Decl &getCodeDecl() const { return *getLocationContext()->getDecl(); }\n\n  CFG &getCFG() const { return *getLocationContext()->getCFG(); }\n\n  const CFGBlock *getCFGBlock() const;\n\n  const ParentMap &getParentMap() const {\n    return getLocationContext()->getParentMap();\n  }\n\n  template <typename T>\n  T &getAnalysis() const {\n    return *getLocationContext()->getAnalysis<T>();\n  }\n\n  const ProgramStateRef &getState() const { return State; }\n\n  template <typename T>\n  Optional<T> getLocationAs() const LLVM_LVALUE_FUNCTION {\n    return Location.getAs<T>();\n  }\n\n  /// Get the value of an arbitrary expression at this node.\n  SVal getSVal(const Stmt *S) const {\n    return getState()->getSVal(S, getLocationContext());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      const ProgramPoint &Loc,\n                      const ProgramStateRef &state,\n                      bool IsSink) {\n    ID.Add(Loc);\n    ID.AddPointer(state.get());\n    ID.AddBoolean(IsSink);\n  }\n\n  void Profile(llvm::FoldingSetNodeID& ID) const {\n    // We avoid copy constructors by not using accessors.\n    Profile(ID, Location, State, isSink());\n  }\n\n  /// addPredeccessor - Adds a predecessor to the current node, and\n  ///  in tandem add this node as a successor of the other node.\n  void addPredecessor(ExplodedNode *V, ExplodedGraph &G);\n\n  unsigned succ_size() const { return Succs.size(); }\n  unsigned pred_size() const { return Preds.size(); }\n  bool succ_empty() const { return Succs.empty(); }\n  bool pred_empty() const { return Preds.empty(); }\n\n  bool isSink() const { return Succs.getFlag(); }\n\n  bool hasSinglePred() const {\n    return (pred_size() == 1);\n  }\n\n  ExplodedNode *getFirstPred() {\n    return pred_empty() ? nullptr : *(pred_begin());\n  }\n\n  const ExplodedNode *getFirstPred() const {\n    return const_cast<ExplodedNode*>(this)->getFirstPred();\n  }\n\n  ExplodedNode *getFirstSucc() {\n    return succ_empty() ? nullptr : *(succ_begin());\n  }\n\n  const ExplodedNode *getFirstSucc() const {\n    return const_cast<ExplodedNode*>(this)->getFirstSucc();\n  }\n\n  // Iterators over successor and predecessor vertices.\n  using succ_iterator = ExplodedNode * const *;\n  using succ_range = llvm::iterator_range<succ_iterator>;\n\n  using const_succ_iterator = const ExplodedNode * const *;\n  using const_succ_range = llvm::iterator_range<const_succ_iterator>;\n\n  using pred_iterator = ExplodedNode * const *;\n  using pred_range = llvm::iterator_range<pred_iterator>;\n\n  using const_pred_iterator = const ExplodedNode * const *;\n  using const_pred_range = llvm::iterator_range<const_pred_iterator>;\n\n  pred_iterator pred_begin() { return Preds.begin(); }\n  pred_iterator pred_end() { return Preds.end(); }\n  pred_range preds() { return {Preds.begin(), Preds.end()}; }\n\n  const_pred_iterator pred_begin() const {\n    return const_cast<ExplodedNode*>(this)->pred_begin();\n  }\n  const_pred_iterator pred_end() const {\n    return const_cast<ExplodedNode*>(this)->pred_end();\n  }\n  const_pred_range preds() const { return {Preds.begin(), Preds.end()}; }\n\n  succ_iterator succ_begin() { return Succs.begin(); }\n  succ_iterator succ_end() { return Succs.end(); }\n  succ_range succs() { return {Succs.begin(), Succs.end()}; }\n\n  const_succ_iterator succ_begin() const {\n    return const_cast<ExplodedNode*>(this)->succ_begin();\n  }\n  const_succ_iterator succ_end() const {\n    return const_cast<ExplodedNode*>(this)->succ_end();\n  }\n  const_succ_range succs() const { return {Succs.begin(), Succs.end()}; }\n\n  int64_t getID() const { return Id; }\n\n  /// The node is trivial if it has only one successor, only one predecessor,\n  /// it's predecessor has only one successor,\n  /// and its program state is the same as the program state of the previous\n  /// node.\n  /// Trivial nodes may be skipped while printing exploded graph.\n  bool isTrivial() const;\n\n  /// If the node's program point corresponds to a statement, retrieve that\n  /// statement. Useful for figuring out where to put a warning or a note.\n  /// If the statement belongs to a body-farmed definition,\n  /// retrieve the call site for that definition.\n  const Stmt *getStmtForDiagnostics() const;\n\n  /// Find the next statement that was executed on this node's execution path.\n  /// Useful for explaining control flow that follows the current node.\n  /// If the statement belongs to a body-farmed definition, retrieve the\n  /// call site for that definition.\n  const Stmt *getNextStmtForDiagnostics() const;\n\n  /// Find the statement that was executed immediately before this node.\n  /// Useful when the node corresponds to a CFG block entrance.\n  /// If the statement belongs to a body-farmed definition, retrieve the\n  /// call site for that definition.\n  const Stmt *getPreviousStmtForDiagnostics() const;\n\n  /// Find the statement that was executed at or immediately before this node.\n  /// Useful when any nearby statement will do.\n  /// If the statement belongs to a body-farmed definition, retrieve the\n  /// call site for that definition.\n  const Stmt *getCurrentOrPreviousStmtForDiagnostics() const;\n\nprivate:\n  void replaceSuccessor(ExplodedNode *node) { Succs.replaceNode(node); }\n  void replacePredecessor(ExplodedNode *node) { Preds.replaceNode(node); }\n};\n\nusing InterExplodedGraphMap =\n    llvm::DenseMap<const ExplodedNode *, const ExplodedNode *>;\n\nclass ExplodedGraph {\nprotected:\n  friend class CoreEngine;\n\n  // Type definitions.\n  using NodeVector = std::vector<ExplodedNode *>;\n\n  /// The roots of the simulation graph. Usually there will be only\n  /// one, but clients are free to establish multiple subgraphs within a single\n  /// SimulGraph. Moreover, these subgraphs can often merge when paths from\n  /// different roots reach the same state at the same program location.\n  NodeVector Roots;\n\n  /// The nodes in the simulation graph which have been\n  /// specially marked as the endpoint of an abstract simulation path.\n  NodeVector EndNodes;\n\n  /// Nodes - The nodes in the graph.\n  llvm::FoldingSet<ExplodedNode> Nodes;\n\n  /// BVC - Allocator and context for allocating nodes and their predecessor\n  /// and successor groups.\n  BumpVectorContext BVC;\n\n  /// NumNodes - The number of nodes in the graph.\n  int64_t NumNodes = 0;\n\n  /// A list of recently allocated nodes that can potentially be recycled.\n  NodeVector ChangedNodes;\n\n  /// A list of nodes that can be reused.\n  NodeVector FreeNodes;\n\n  /// Determines how often nodes are reclaimed.\n  ///\n  /// If this is 0, nodes will never be reclaimed.\n  unsigned ReclaimNodeInterval = 0;\n\n  /// Counter to determine when to reclaim nodes.\n  unsigned ReclaimCounter;\n\npublic:\n  ExplodedGraph();\n  ~ExplodedGraph();\n\n  /// Retrieve the node associated with a (Location,State) pair,\n  ///  where the 'Location' is a ProgramPoint in the CFG.  If no node for\n  ///  this pair exists, it is created. IsNew is set to true if\n  ///  the node was freshly created.\n  ExplodedNode *getNode(const ProgramPoint &L, ProgramStateRef State,\n                        bool IsSink = false,\n                        bool* IsNew = nullptr);\n\n  /// Create a node for a (Location, State) pair,\n  ///  but don't store it for deduplication later.  This\n  ///  is useful when copying an already completed\n  ///  ExplodedGraph for further processing.\n  ExplodedNode *createUncachedNode(const ProgramPoint &L,\n    ProgramStateRef State,\n    int64_t Id,\n    bool IsSink = false);\n\n  std::unique_ptr<ExplodedGraph> MakeEmptyGraph() const {\n    return std::make_unique<ExplodedGraph>();\n  }\n\n  /// addRoot - Add an untyped node to the set of roots.\n  ExplodedNode *addRoot(ExplodedNode *V) {\n    Roots.push_back(V);\n    return V;\n  }\n\n  /// addEndOfPath - Add an untyped node to the set of EOP nodes.\n  ExplodedNode *addEndOfPath(ExplodedNode *V) {\n    EndNodes.push_back(V);\n    return V;\n  }\n\n  unsigned num_roots() const { return Roots.size(); }\n  unsigned num_eops() const { return EndNodes.size(); }\n\n  bool empty() const { return NumNodes == 0; }\n  unsigned size() const { return NumNodes; }\n\n  void reserve(unsigned NodeCount) { Nodes.reserve(NodeCount); }\n\n  // Iterators.\n  using NodeTy = ExplodedNode;\n  using AllNodesTy = llvm::FoldingSet<ExplodedNode>;\n  using roots_iterator = NodeVector::iterator;\n  using const_roots_iterator = NodeVector::const_iterator;\n  using eop_iterator = NodeVector::iterator;\n  using const_eop_iterator = NodeVector::const_iterator;\n  using node_iterator = AllNodesTy::iterator;\n  using const_node_iterator = AllNodesTy::const_iterator;\n\n  node_iterator nodes_begin() { return Nodes.begin(); }\n\n  node_iterator nodes_end() { return Nodes.end(); }\n\n  const_node_iterator nodes_begin() const { return Nodes.begin(); }\n\n  const_node_iterator nodes_end() const { return Nodes.end(); }\n\n  roots_iterator roots_begin() { return Roots.begin(); }\n\n  roots_iterator roots_end() { return Roots.end(); }\n\n  const_roots_iterator roots_begin() const { return Roots.begin(); }\n\n  const_roots_iterator roots_end() const { return Roots.end(); }\n\n  eop_iterator eop_begin() { return EndNodes.begin(); }\n\n  eop_iterator eop_end() { return EndNodes.end(); }\n\n  const_eop_iterator eop_begin() const { return EndNodes.begin(); }\n\n  const_eop_iterator eop_end() const { return EndNodes.end(); }\n\n  llvm::BumpPtrAllocator & getAllocator() { return BVC.getAllocator(); }\n  BumpVectorContext &getNodeAllocator() { return BVC; }\n\n  using NodeMap = llvm::DenseMap<const ExplodedNode *, ExplodedNode *>;\n\n  /// Creates a trimmed version of the graph that only contains paths leading\n  /// to the given nodes.\n  ///\n  /// \\param Nodes The nodes which must appear in the final graph. Presumably\n  ///              these are end-of-path nodes (i.e. they have no successors).\n  /// \\param[out] ForwardMap A optional map from nodes in this graph to nodes in\n  ///                        the returned graph.\n  /// \\param[out] InverseMap An optional map from nodes in the returned graph to\n  ///                        nodes in this graph.\n  /// \\returns The trimmed graph\n  std::unique_ptr<ExplodedGraph>\n  trim(ArrayRef<const NodeTy *> Nodes,\n       InterExplodedGraphMap *ForwardMap = nullptr,\n       InterExplodedGraphMap *InverseMap = nullptr) const;\n\n  /// Enable tracking of recently allocated nodes for potential reclamation\n  /// when calling reclaimRecentlyAllocatedNodes().\n  void enableNodeReclamation(unsigned Interval) {\n    ReclaimCounter = ReclaimNodeInterval = Interval;\n  }\n\n  /// Reclaim \"uninteresting\" nodes created since the last time this method\n  /// was called.\n  void reclaimRecentlyAllocatedNodes();\n\n  /// Returns true if nodes for the given expression kind are always\n  ///        kept around.\n  static bool isInterestingLValueExpr(const Expr *Ex);\n\nprivate:\n  bool shouldCollect(const ExplodedNode *node);\n  void collectNode(ExplodedNode *node);\n};\n\nclass ExplodedNodeSet {\n  using ImplTy = llvm::SmallSetVector<ExplodedNode *, 4>;\n  ImplTy Impl;\n\npublic:\n  ExplodedNodeSet(ExplodedNode *N) {\n    assert(N && !static_cast<ExplodedNode*>(N)->isSink());\n    Impl.insert(N);\n  }\n\n  ExplodedNodeSet() = default;\n\n  void Add(ExplodedNode *N) {\n    if (N && !static_cast<ExplodedNode*>(N)->isSink()) Impl.insert(N);\n  }\n\n  using iterator = ImplTy::iterator;\n  using const_iterator = ImplTy::const_iterator;\n\n  unsigned size() const { return Impl.size();  }\n  bool empty()    const { return Impl.empty(); }\n  bool erase(ExplodedNode *N) { return Impl.remove(N); }\n\n  void clear() { Impl.clear(); }\n\n  void insert(const ExplodedNodeSet &S) {\n    assert(&S != this);\n    if (empty())\n      Impl = S.Impl;\n    else\n      Impl.insert(S.begin(), S.end());\n  }\n\n  iterator begin() { return Impl.begin(); }\n  iterator end() { return Impl.end(); }\n\n  const_iterator begin() const { return Impl.begin(); }\n  const_iterator end() const { return Impl.end(); }\n};\n\n} // namespace ento\n\n} // namespace clang\n\n// GraphTraits\n\nnamespace llvm {\n  template <> struct GraphTraits<clang::ento::ExplodedGraph *> {\n    using GraphTy = clang::ento::ExplodedGraph *;\n    using NodeRef = clang::ento::ExplodedNode *;\n    using ChildIteratorType = clang::ento::ExplodedNode::succ_iterator;\n    using nodes_iterator = llvm::df_iterator<GraphTy>;\n\n    static NodeRef getEntryNode(const GraphTy G) {\n      return *G->roots_begin();\n    }\n\n    static bool predecessorOfTrivial(NodeRef N) {\n      return N->succ_size() == 1 && N->getFirstSucc()->isTrivial();\n    }\n\n    static ChildIteratorType child_begin(NodeRef N) {\n      if (predecessorOfTrivial(N))\n        return child_begin(*N->succ_begin());\n      return N->succ_begin();\n    }\n\n    static ChildIteratorType child_end(NodeRef N) {\n      if (predecessorOfTrivial(N))\n        return child_end(N->getFirstSucc());\n      return N->succ_end();\n    }\n\n    static nodes_iterator nodes_begin(const GraphTy G) {\n      return df_begin(G);\n    }\n\n    static nodes_iterator nodes_end(const GraphTy G) {\n      return df_end(G);\n    }\n  };\n} // namespace llvm\n\n#endif // LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_EXPLODEDGRAPH_H\n"}, "60": {"id": 60, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExprEngine.h", "content": "//===- ExprEngine.h - Path-Sensitive Expression-Level Dataflow --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines a meta-engine for path-sensitive dataflow analysis that\n//  is built on CoreEngine, but provides the boilerplate to execute transfer\n//  functions and build the ExplodedGraph at the expression level.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_EXPRENGINE_H\n#define LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_EXPRENGINE_H\n\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Analysis/CFG.h\"\n#include \"clang/Analysis/DomainSpecific/ObjCNoReturn.h\"\n#include \"clang/Analysis/ProgramPoint.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/StaticAnalyzer/Core/CheckerManager.h\"\n#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporter.h\"\n#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/AnalysisManager.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CoreEngine.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/FunctionSummary.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState_Fwd.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/Store.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SValBuilder.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SVals.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/WorkList.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include <cassert>\n#include <utility>\n\nnamespace clang {\n\nclass AnalysisDeclContextManager;\nclass AnalyzerOptions;\nclass ASTContext;\nclass CFGBlock;\nclass CFGElement;\nclass ConstructionContext;\nclass CXXBindTemporaryExpr;\nclass CXXCatchStmt;\nclass CXXConstructExpr;\nclass CXXDeleteExpr;\nclass CXXNewExpr;\nclass CXXThisExpr;\nclass Decl;\nclass DeclStmt;\nclass GCCAsmStmt;\nclass LambdaExpr;\nclass LocationContext;\nclass MaterializeTemporaryExpr;\nclass MSAsmStmt;\nclass NamedDecl;\nclass ObjCAtSynchronizedStmt;\nclass ObjCForCollectionStmt;\nclass ObjCIvarRefExpr;\nclass ObjCMessageExpr;\nclass ReturnStmt;\nclass Stmt;\n\nnamespace cross_tu {\n\nclass CrossTranslationUnitContext;\n\n} // namespace cross_tu\n\nnamespace ento {\n\nclass AnalysisManager;\nclass BasicValueFactory;\nclass BlockCounter;\nclass BranchNodeBuilder;\nclass CallEvent;\nclass CheckerManager;\nclass ConstraintManager;\nclass CXXTempObjectRegion;\nclass EndOfFunctionNodeBuilder;\nclass ExplodedNodeSet;\nclass ExplodedNode;\nclass IndirectGotoNodeBuilder;\nclass MemRegion;\nstruct NodeBuilderContext;\nclass NodeBuilderWithSinks;\nclass ProgramState;\nclass ProgramStateManager;\nclass RegionAndSymbolInvalidationTraits;\nclass SymbolManager;\nclass SwitchNodeBuilder;\n\n/// Hints for figuring out of a call should be inlined during evalCall().\nstruct EvalCallOptions {\n  /// This call is a constructor or a destructor for which we do not currently\n  /// compute the this-region correctly.\n  bool IsCtorOrDtorWithImproperlyModeledTargetRegion = false;\n\n  /// This call is a constructor or a destructor for a single element within\n  /// an array, a part of array construction or destruction.\n  bool IsArrayCtorOrDtor = false;\n\n  /// This call is a constructor or a destructor of a temporary value.\n  bool IsTemporaryCtorOrDtor = false;\n\n  /// This call is a constructor for a temporary that is lifetime-extended\n  /// by binding it to a reference-type field within an aggregate,\n  /// for example 'A { const C &c; }; A a = { C() };'\n  bool IsTemporaryLifetimeExtendedViaAggregate = false;\n\n  /// This call is a pre-C++17 elidable constructor that we failed to elide\n  /// because we failed to compute the target region into which\n  /// this constructor would have been ultimately elided. Analysis that\n  /// we perform in this case is still correct but it behaves differently,\n  /// as if copy elision is disabled.\n  bool IsElidableCtorThatHasNotBeenElided = false;\n\n  EvalCallOptions() {}\n};\n\nclass ExprEngine {\n  void anchor();\n\npublic:\n  /// The modes of inlining, which override the default analysis-wide settings.\n  enum InliningModes {\n    /// Follow the default settings for inlining callees.\n    Inline_Regular = 0,\n\n    /// Do minimal inlining of callees.\n    Inline_Minimal = 0x1\n  };\n\nprivate:\n  cross_tu::CrossTranslationUnitContext &CTU;\n\n  AnalysisManager &AMgr;\n\n  AnalysisDeclContextManager &AnalysisDeclContexts;\n\n  CoreEngine Engine;\n\n  /// G - the simulation graph.\n  ExplodedGraph &G;\n\n  /// StateMgr - Object that manages the data for all created states.\n  ProgramStateManager StateMgr;\n\n  /// SymMgr - Object that manages the symbol information.\n  SymbolManager &SymMgr;\n\n  /// MRMgr - MemRegionManager object that creates memory regions.\n  MemRegionManager &MRMgr;\n\n  /// svalBuilder - SValBuilder object that creates SVals from expressions.\n  SValBuilder &svalBuilder;\n\n  unsigned int currStmtIdx = 0;\n  const NodeBuilderContext *currBldrCtx = nullptr;\n\n  /// Helper object to determine if an Objective-C message expression\n  /// implicitly never returns.\n  ObjCNoReturn ObjCNoRet;\n\n  /// The BugReporter associated with this engine.  It is important that\n  /// this object be placed at the very end of member variables so that its\n  /// destructor is called before the rest of the ExprEngine is destroyed.\n  PathSensitiveBugReporter BR;\n\n  /// The functions which have been analyzed through inlining. This is owned by\n  /// AnalysisConsumer. It can be null.\n  SetOfConstDecls *VisitedCallees;\n\n  /// The flag, which specifies the mode of inlining for the engine.\n  InliningModes HowToInline;\n\npublic:\n  ExprEngine(cross_tu::CrossTranslationUnitContext &CTU, AnalysisManager &mgr,\n             SetOfConstDecls *VisitedCalleesIn,\n             FunctionSummariesTy *FS, InliningModes HowToInlineIn);\n\n  virtual ~ExprEngine() = default;\n\n  /// Returns true if there is still simulation state on the worklist.\n  bool ExecuteWorkList(const LocationContext *L, unsigned Steps = 150000) {\n    return Engine.ExecuteWorkList(L, Steps, nullptr);\n  }\n\n  /// Execute the work list with an initial state. Nodes that reaches the exit\n  /// of the function are added into the Dst set, which represent the exit\n  /// state of the function call. Returns true if there is still simulation\n  /// state on the worklist.\n  bool ExecuteWorkListWithInitialState(const LocationContext *L, unsigned Steps,\n                                       ProgramStateRef InitState,\n                                       ExplodedNodeSet &Dst) {\n    return Engine.ExecuteWorkListWithInitialState(L, Steps, InitState, Dst);\n  }\n\n  /// getContext - Return the ASTContext associated with this analysis.\n  ASTContext &getContext() const { return AMgr.getASTContext(); }\n\n  AnalysisManager &getAnalysisManager() { return AMgr; }\n\n  AnalysisDeclContextManager &getAnalysisDeclContextManager() {\n    return AMgr.getAnalysisDeclContextManager();\n  }\n\n  CheckerManager &getCheckerManager() const {\n    return *AMgr.getCheckerManager();\n  }\n\n  SValBuilder &getSValBuilder() { return svalBuilder; }\n\n  BugReporter &getBugReporter() { return BR; }\n\n  cross_tu::CrossTranslationUnitContext *\n  getCrossTranslationUnitContext() {\n    return &CTU;\n  }\n\n  const NodeBuilderContext &getBuilderContext() {\n    assert(currBldrCtx);\n    return *currBldrCtx;\n  }\n\n  const Stmt *getStmt() const;\n\n  void GenerateAutoTransition(ExplodedNode *N);\n  void enqueueEndOfPath(ExplodedNodeSet &S);\n  void GenerateCallExitNode(ExplodedNode *N);\n\n\n  /// Dump graph to the specified filename.\n  /// If filename is empty, generate a temporary one.\n  /// \\return The filename the graph is written into.\n  std::string DumpGraph(bool trim = false, StringRef Filename=\"\");\n\n  /// Dump the graph consisting of the given nodes to a specified filename.\n  /// Generate a temporary filename if it's not provided.\n  /// \\return The filename the graph is written into.\n  std::string DumpGraph(ArrayRef<const ExplodedNode *> Nodes,\n                        StringRef Filename = \"\");\n\n  /// Visualize the ExplodedGraph created by executing the simulation.\n  void ViewGraph(bool trim = false);\n\n  /// Visualize a trimmed ExplodedGraph that only contains paths to the given\n  /// nodes.\n  void ViewGraph(ArrayRef<const ExplodedNode *> Nodes);\n\n  /// getInitialState - Return the initial state used for the root vertex\n  ///  in the ExplodedGraph.\n  ProgramStateRef getInitialState(const LocationContext *InitLoc);\n\n  ExplodedGraph &getGraph() { return G; }\n  const ExplodedGraph &getGraph() const { return G; }\n\n  /// Run the analyzer's garbage collection - remove dead symbols and\n  /// bindings from the state.\n  ///\n  /// Checkers can participate in this process with two callbacks:\n  /// \\c checkLiveSymbols and \\c checkDeadSymbols. See the CheckerDocumentation\n  /// class for more information.\n  ///\n  /// \\param Node The predecessor node, from which the processing should start.\n  /// \\param Out The returned set of output nodes.\n  /// \\param ReferenceStmt The statement which is about to be processed.\n  ///        Everything needed for this statement should be considered live.\n  ///        A null statement means that everything in child LocationContexts\n  ///        is dead.\n  /// \\param LC The location context of the \\p ReferenceStmt. A null location\n  ///        context means that we have reached the end of analysis and that\n  ///        all statements and local variables should be considered dead.\n  /// \\param DiagnosticStmt Used as a location for any warnings that should\n  ///        occur while removing the dead (e.g. leaks). By default, the\n  ///        \\p ReferenceStmt is used.\n  /// \\param K Denotes whether this is a pre- or post-statement purge. This\n  ///        must only be ProgramPoint::PostStmtPurgeDeadSymbolsKind if an\n  ///        entire location context is being cleared, in which case the\n  ///        \\p ReferenceStmt must either be a ReturnStmt or \\c NULL. Otherwise,\n  ///        it must be ProgramPoint::PreStmtPurgeDeadSymbolsKind (the default)\n  ///        and \\p ReferenceStmt must be valid (non-null).\n  void removeDead(ExplodedNode *Node, ExplodedNodeSet &Out,\n            const Stmt *ReferenceStmt, const LocationContext *LC,\n            const Stmt *DiagnosticStmt = nullptr,\n            ProgramPoint::Kind K = ProgramPoint::PreStmtPurgeDeadSymbolsKind);\n\n  /// processCFGElement - Called by CoreEngine. Used to generate new successor\n  ///  nodes by processing the 'effects' of a CFG element.\n  void processCFGElement(const CFGElement E, ExplodedNode *Pred,\n                         unsigned StmtIdx, NodeBuilderContext *Ctx);\n\n  void ProcessStmt(const Stmt *S, ExplodedNode *Pred);\n\n  void ProcessLoopExit(const Stmt* S, ExplodedNode *Pred);\n\n  void ProcessInitializer(const CFGInitializer I, ExplodedNode *Pred);\n\n  void ProcessImplicitDtor(const CFGImplicitDtor D, ExplodedNode *Pred);\n\n  void ProcessNewAllocator(const CXXNewExpr *NE, ExplodedNode *Pred);\n\n  void ProcessAutomaticObjDtor(const CFGAutomaticObjDtor D,\n                               ExplodedNode *Pred, ExplodedNodeSet &Dst);\n  void ProcessDeleteDtor(const CFGDeleteDtor D,\n                         ExplodedNode *Pred, ExplodedNodeSet &Dst);\n  void ProcessBaseDtor(const CFGBaseDtor D,\n                       ExplodedNode *Pred, ExplodedNodeSet &Dst);\n  void ProcessMemberDtor(const CFGMemberDtor D,\n                         ExplodedNode *Pred, ExplodedNodeSet &Dst);\n  void ProcessTemporaryDtor(const CFGTemporaryDtor D,\n                            ExplodedNode *Pred, ExplodedNodeSet &Dst);\n\n  /// Called by CoreEngine when processing the entrance of a CFGBlock.\n  void processCFGBlockEntrance(const BlockEdge &L,\n                               NodeBuilderWithSinks &nodeBuilder,\n                               ExplodedNode *Pred);\n\n  /// ProcessBranch - Called by CoreEngine.  Used to generate successor\n  ///  nodes by processing the 'effects' of a branch condition.\n  void processBranch(const Stmt *Condition,\n                     NodeBuilderContext& BuilderCtx,\n                     ExplodedNode *Pred,\n                     ExplodedNodeSet &Dst,\n                     const CFGBlock *DstT,\n                     const CFGBlock *DstF);\n\n  /// Called by CoreEngine.\n  /// Used to generate successor nodes for temporary destructors depending\n  /// on whether the corresponding constructor was visited.\n  void processCleanupTemporaryBranch(const CXXBindTemporaryExpr *BTE,\n                                     NodeBuilderContext &BldCtx,\n                                     ExplodedNode *Pred, ExplodedNodeSet &Dst,\n                                     const CFGBlock *DstT,\n                                     const CFGBlock *DstF);\n\n  /// Called by CoreEngine.  Used to processing branching behavior\n  /// at static initializers.\n  void processStaticInitializer(const DeclStmt *DS,\n                                NodeBuilderContext& BuilderCtx,\n                                ExplodedNode *Pred,\n                                ExplodedNodeSet &Dst,\n                                const CFGBlock *DstT,\n                                const CFGBlock *DstF);\n\n  /// processIndirectGoto - Called by CoreEngine.  Used to generate successor\n  ///  nodes by processing the 'effects' of a computed goto jump.\n  void processIndirectGoto(IndirectGotoNodeBuilder& builder);\n\n  /// ProcessSwitch - Called by CoreEngine.  Used to generate successor\n  ///  nodes by processing the 'effects' of a switch statement.\n  void processSwitch(SwitchNodeBuilder& builder);\n\n  /// Called by CoreEngine.  Used to notify checkers that processing a\n  /// function has begun. Called for both inlined and and top-level functions.\n  void processBeginOfFunction(NodeBuilderContext &BC,\n                              ExplodedNode *Pred, ExplodedNodeSet &Dst,\n                              const BlockEdge &L);\n\n  /// Called by CoreEngine.  Used to notify checkers that processing a\n  /// function has ended. Called for both inlined and and top-level functions.\n  void processEndOfFunction(NodeBuilderContext& BC,\n                            ExplodedNode *Pred,\n                            const ReturnStmt *RS = nullptr);\n\n  /// Remove dead bindings/symbols before exiting a function.\n  void removeDeadOnEndOfFunction(NodeBuilderContext& BC,\n                                 ExplodedNode *Pred,\n                                 ExplodedNodeSet &Dst);\n\n  /// Generate the entry node of the callee.\n  void processCallEnter(NodeBuilderContext& BC, CallEnter CE,\n                        ExplodedNode *Pred);\n\n  /// Generate the sequence of nodes that simulate the call exit and the post\n  /// visit for CallExpr.\n  void processCallExit(ExplodedNode *Pred);\n\n  /// Called by CoreEngine when the analysis worklist has terminated.\n  void processEndWorklist();\n\n  /// evalAssume - Callback function invoked by the ConstraintManager when\n  ///  making assumptions about state values.\n  ProgramStateRef processAssume(ProgramStateRef state, SVal cond,\n                                bool assumption);\n\n  /// processRegionChanges - Called by ProgramStateManager whenever a change is made\n  ///  to the store. Used to update checkers that track region values.\n  ProgramStateRef\n  processRegionChanges(ProgramStateRef state,\n                       const InvalidatedSymbols *invalidated,\n                       ArrayRef<const MemRegion *> ExplicitRegions,\n                       ArrayRef<const MemRegion *> Regions,\n                       const LocationContext *LCtx,\n                       const CallEvent *Call);\n\n  inline ProgramStateRef\n  processRegionChange(ProgramStateRef state,\n                      const MemRegion* MR,\n                      const LocationContext *LCtx) {\n    return processRegionChanges(state, nullptr, MR, MR, LCtx, nullptr);\n  }\n\n  /// printJson - Called by ProgramStateManager to print checker-specific data.\n  void printJson(raw_ostream &Out, ProgramStateRef State,\n                 const LocationContext *LCtx, const char *NL,\n                 unsigned int Space, bool IsDot) const;\n\n  ProgramStateManager &getStateManager() { return StateMgr; }\n\n  StoreManager &getStoreManager() { return StateMgr.getStoreManager(); }\n\n  ConstraintManager &getConstraintManager() {\n    return StateMgr.getConstraintManager();\n  }\n\n  // FIXME: Remove when we migrate over to just using SValBuilder.\n  BasicValueFactory &getBasicVals() {\n    return StateMgr.getBasicVals();\n  }\n\n  SymbolManager &getSymbolManager() { return SymMgr; }\n  MemRegionManager &getRegionManager() { return MRMgr; }\n\n  NoteTag::Factory &getNoteTags() { return Engine.getNoteTags(); }\n\n\n  // Functions for external checking of whether we have unfinished work\n  bool wasBlocksExhausted() const { return Engine.wasBlocksExhausted(); }\n  bool hasEmptyWorkList() const { return !Engine.getWorkList()->hasWork(); }\n  bool hasWorkRemaining() const { return Engine.hasWorkRemaining(); }\n\n  const CoreEngine &getCoreEngine() const { return Engine; }\n\npublic:\n  /// Visit - Transfer function logic for all statements.  Dispatches to\n  ///  other functions that handle specific kinds of statements.\n  void Visit(const Stmt *S, ExplodedNode *Pred, ExplodedNodeSet &Dst);\n\n  /// VisitArraySubscriptExpr - Transfer function for array accesses.\n  void VisitArraySubscriptExpr(const ArraySubscriptExpr *Ex,\n                               ExplodedNode *Pred,\n                               ExplodedNodeSet &Dst);\n\n  /// VisitGCCAsmStmt - Transfer function logic for inline asm.\n  void VisitGCCAsmStmt(const GCCAsmStmt *A, ExplodedNode *Pred,\n                       ExplodedNodeSet &Dst);\n\n  /// VisitMSAsmStmt - Transfer function logic for MS inline asm.\n  void VisitMSAsmStmt(const MSAsmStmt *A, ExplodedNode *Pred,\n                      ExplodedNodeSet &Dst);\n\n  /// VisitBlockExpr - Transfer function logic for BlockExprs.\n  void VisitBlockExpr(const BlockExpr *BE, ExplodedNode *Pred,\n                      ExplodedNodeSet &Dst);\n\n  /// VisitLambdaExpr - Transfer function logic for LambdaExprs.\n  void VisitLambdaExpr(const LambdaExpr *LE, ExplodedNode *Pred,\n                       ExplodedNodeSet &Dst);\n\n  /// VisitBinaryOperator - Transfer function logic for binary operators.\n  void VisitBinaryOperator(const BinaryOperator* B, ExplodedNode *Pred,\n                           ExplodedNodeSet &Dst);\n\n\n  /// VisitCall - Transfer function for function calls.\n  void VisitCallExpr(const CallExpr *CE, ExplodedNode *Pred,\n                     ExplodedNodeSet &Dst);\n\n  /// VisitCast - Transfer function logic for all casts (implicit and explicit).\n  void VisitCast(const CastExpr *CastE, const Expr *Ex, ExplodedNode *Pred,\n                 ExplodedNodeSet &Dst);\n\n  /// VisitCompoundLiteralExpr - Transfer function logic for compound literals.\n  void VisitCompoundLiteralExpr(const CompoundLiteralExpr *CL,\n                                ExplodedNode *Pred, ExplodedNodeSet &Dst);\n\n  /// Transfer function logic for DeclRefExprs and BlockDeclRefExprs.\n  void VisitCommonDeclRefExpr(const Expr *DR, const NamedDecl *D,\n                              ExplodedNode *Pred, ExplodedNodeSet &Dst);\n\n  /// VisitDeclStmt - Transfer function logic for DeclStmts.\n  void VisitDeclStmt(const DeclStmt *DS, ExplodedNode *Pred,\n                     ExplodedNodeSet &Dst);\n\n  /// VisitGuardedExpr - Transfer function logic for ?, __builtin_choose\n  void VisitGuardedExpr(const Expr *Ex, const Expr *L, const Expr *R,\n                        ExplodedNode *Pred, ExplodedNodeSet &Dst);\n\n  void VisitInitListExpr(const InitListExpr *E, ExplodedNode *Pred,\n                         ExplodedNodeSet &Dst);\n\n  /// VisitLogicalExpr - Transfer function logic for '&&', '||'\n  void VisitLogicalExpr(const BinaryOperator* B, ExplodedNode *Pred,\n                        ExplodedNodeSet &Dst);\n\n  /// VisitMemberExpr - Transfer function for member expressions.\n  void VisitMemberExpr(const MemberExpr *M, ExplodedNode *Pred,\n                       ExplodedNodeSet &Dst);\n\n  /// VisitAtomicExpr - Transfer function for builtin atomic expressions\n  void VisitAtomicExpr(const AtomicExpr *E, ExplodedNode *Pred,\n                       ExplodedNodeSet &Dst);\n\n  /// Transfer function logic for ObjCAtSynchronizedStmts.\n  void VisitObjCAtSynchronizedStmt(const ObjCAtSynchronizedStmt *S,\n                                   ExplodedNode *Pred, ExplodedNodeSet &Dst);\n\n  /// Transfer function logic for computing the lvalue of an Objective-C ivar.\n  void VisitLvalObjCIvarRefExpr(const ObjCIvarRefExpr *DR, ExplodedNode *Pred,\n                                ExplodedNodeSet &Dst);\n\n  /// VisitObjCForCollectionStmt - Transfer function logic for\n  ///  ObjCForCollectionStmt.\n  void VisitObjCForCollectionStmt(const ObjCForCollectionStmt *S,\n                                  ExplodedNode *Pred, ExplodedNodeSet &Dst);\n\n  void VisitObjCMessage(const ObjCMessageExpr *ME, ExplodedNode *Pred,\n                        ExplodedNodeSet &Dst);\n\n  /// VisitReturnStmt - Transfer function logic for return statements.\n  void VisitReturnStmt(const ReturnStmt *R, ExplodedNode *Pred,\n                       ExplodedNodeSet &Dst);\n\n  /// VisitOffsetOfExpr - Transfer function for offsetof.\n  void VisitOffsetOfExpr(const OffsetOfExpr *Ex, ExplodedNode *Pred,\n                         ExplodedNodeSet &Dst);\n\n  /// VisitUnaryExprOrTypeTraitExpr - Transfer function for sizeof.\n  void VisitUnaryExprOrTypeTraitExpr(const UnaryExprOrTypeTraitExpr *Ex,\n                                     ExplodedNode *Pred, ExplodedNodeSet &Dst);\n\n  /// VisitUnaryOperator - Transfer function logic for unary operators.\n  void VisitUnaryOperator(const UnaryOperator* B, ExplodedNode *Pred,\n                          ExplodedNodeSet &Dst);\n\n  /// Handle ++ and -- (both pre- and post-increment).\n  void VisitIncrementDecrementOperator(const UnaryOperator* U,\n                                       ExplodedNode *Pred,\n                                       ExplodedNodeSet &Dst);\n\n  void VisitCXXBindTemporaryExpr(const CXXBindTemporaryExpr *BTE,\n                                 ExplodedNodeSet &PreVisit,\n                                 ExplodedNodeSet &Dst);\n\n  void VisitCXXCatchStmt(const CXXCatchStmt *CS, ExplodedNode *Pred,\n                         ExplodedNodeSet &Dst);\n\n  void VisitCXXThisExpr(const CXXThisExpr *TE, ExplodedNode *Pred,\n                        ExplodedNodeSet & Dst);\n\n  void VisitCXXConstructExpr(const CXXConstructExpr *E, ExplodedNode *Pred,\n                             ExplodedNodeSet &Dst);\n\n  void VisitCXXInheritedCtorInitExpr(const CXXInheritedCtorInitExpr *E,\n                                     ExplodedNode *Pred, ExplodedNodeSet &Dst);\n\n  void VisitCXXDestructor(QualType ObjectType, const MemRegion *Dest,\n                          const Stmt *S, bool IsBaseDtor,\n                          ExplodedNode *Pred, ExplodedNodeSet &Dst,\n                          EvalCallOptions &Options);\n\n  void VisitCXXNewAllocatorCall(const CXXNewExpr *CNE,\n                                ExplodedNode *Pred,\n                                ExplodedNodeSet &Dst);\n\n  void VisitCXXNewExpr(const CXXNewExpr *CNE, ExplodedNode *Pred,\n                       ExplodedNodeSet &Dst);\n\n  void VisitCXXDeleteExpr(const CXXDeleteExpr *CDE, ExplodedNode *Pred,\n                          ExplodedNodeSet &Dst);\n\n  /// Create a C++ temporary object for an rvalue.\n  void CreateCXXTemporaryObject(const MaterializeTemporaryExpr *ME,\n                                ExplodedNode *Pred,\n                                ExplodedNodeSet &Dst);\n\n  /// evalEagerlyAssumeBinOpBifurcation - Given the nodes in 'Src', eagerly assume symbolic\n  ///  expressions of the form 'x != 0' and generate new nodes (stored in Dst)\n  ///  with those assumptions.\n  void evalEagerlyAssumeBinOpBifurcation(ExplodedNodeSet &Dst, ExplodedNodeSet &Src,\n                         const Expr *Ex);\n\n  static std::pair<const ProgramPointTag *, const ProgramPointTag *>\n    geteagerlyAssumeBinOpBifurcationTags();\n\n  SVal evalMinus(SVal X) {\n    return X.isValid() ? svalBuilder.evalMinus(X.castAs<NonLoc>()) : X;\n  }\n\n  SVal evalComplement(SVal X) {\n    return X.isValid() ? svalBuilder.evalComplement(X.castAs<NonLoc>()) : X;\n  }\n\n  ProgramStateRef handleLValueBitCast(ProgramStateRef state, const Expr *Ex,\n                                      const LocationContext *LCtx, QualType T,\n                                      QualType ExTy, const CastExpr *CastE,\n                                      StmtNodeBuilder &Bldr,\n                                      ExplodedNode *Pred);\n\n  ProgramStateRef handleLVectorSplat(ProgramStateRef state,\n                                     const LocationContext *LCtx,\n                                     const CastExpr *CastE,\n                                     StmtNodeBuilder &Bldr,\n                                     ExplodedNode *Pred);\n\n  void handleUOExtension(ExplodedNodeSet::iterator I,\n                         const UnaryOperator* U,\n                         StmtNodeBuilder &Bldr);\n\npublic:\n  SVal evalBinOp(ProgramStateRef state, BinaryOperator::Opcode op,\n                 NonLoc L, NonLoc R, QualType T) {\n    return svalBuilder.evalBinOpNN(state, op, L, R, T);\n  }\n\n  SVal evalBinOp(ProgramStateRef state, BinaryOperator::Opcode op,\n                 NonLoc L, SVal R, QualType T) {\n    return R.isValid() ? svalBuilder.evalBinOpNN(state, op, L,\n                                                 R.castAs<NonLoc>(), T) : R;\n  }\n\n  SVal evalBinOp(ProgramStateRef ST, BinaryOperator::Opcode Op,\n                 SVal LHS, SVal RHS, QualType T) {\n    return svalBuilder.evalBinOp(ST, Op, LHS, RHS, T);\n  }\n\n  /// By looking at a certain item that may be potentially part of an object's\n  /// ConstructionContext, retrieve such object's location. A particular\n  /// statement can be transparently passed as \\p Item in most cases.\n  static Optional<SVal>\n  getObjectUnderConstruction(ProgramStateRef State,\n                             const ConstructionContextItem &Item,\n                             const LocationContext *LC);\n\n  /// Call PointerEscape callback when a value escapes as a result of bind.\n  ProgramStateRef processPointerEscapedOnBind(\n      ProgramStateRef State, ArrayRef<std::pair<SVal, SVal>> LocAndVals,\n      const LocationContext *LCtx, PointerEscapeKind Kind,\n      const CallEvent *Call);\n\n  /// Call PointerEscape callback when a value escapes as a result of\n  /// region invalidation.\n  /// \\param[in] ITraits Specifies invalidation traits for regions/symbols.\n  ProgramStateRef notifyCheckersOfPointerEscape(\n                           ProgramStateRef State,\n                           const InvalidatedSymbols *Invalidated,\n                           ArrayRef<const MemRegion *> ExplicitRegions,\n                           const CallEvent *Call,\n                           RegionAndSymbolInvalidationTraits &ITraits);\n\nprivate:\n  /// evalBind - Handle the semantics of binding a value to a specific location.\n  ///  This method is used by evalStore, VisitDeclStmt, and others.\n  void evalBind(ExplodedNodeSet &Dst, const Stmt *StoreE, ExplodedNode *Pred,\n                SVal location, SVal Val, bool atDeclInit = false,\n                const ProgramPoint *PP = nullptr);\n\n  ProgramStateRef\n  processPointerEscapedOnBind(ProgramStateRef State,\n                              SVal Loc, SVal Val,\n                              const LocationContext *LCtx);\n\n  /// A simple wrapper when you only need to notify checkers of pointer-escape\n  /// of some values.\n  ProgramStateRef escapeValues(ProgramStateRef State, ArrayRef<SVal> Vs,\n                               PointerEscapeKind K,\n                               const CallEvent *Call = nullptr) const;\n\npublic:\n  // FIXME: 'tag' should be removed, and a LocationContext should be used\n  // instead.\n  // FIXME: Comment on the meaning of the arguments, when 'St' may not\n  // be the same as Pred->state, and when 'location' may not be the\n  // same as state->getLValue(Ex).\n  /// Simulate a read of the result of Ex.\n  void evalLoad(ExplodedNodeSet &Dst,\n                const Expr *NodeEx,  /* Eventually will be a CFGStmt */\n                const Expr *BoundExpr,\n                ExplodedNode *Pred,\n                ProgramStateRef St,\n                SVal location,\n                const ProgramPointTag *tag = nullptr,\n                QualType LoadTy = QualType());\n\n  // FIXME: 'tag' should be removed, and a LocationContext should be used\n  // instead.\n  void evalStore(ExplodedNodeSet &Dst, const Expr *AssignE, const Expr *StoreE,\n                 ExplodedNode *Pred, ProgramStateRef St, SVal TargetLV, SVal Val,\n                 const ProgramPointTag *tag = nullptr);\n\n  /// Return the CFG element corresponding to the worklist element\n  /// that is currently being processed by ExprEngine.\n  CFGElement getCurrentCFGElement() {\n    return (*currBldrCtx->getBlock())[currStmtIdx];\n  }\n\n  /// Create a new state in which the call return value is binded to the\n  /// call origin expression.\n  ProgramStateRef bindReturnValue(const CallEvent &Call,\n                                  const LocationContext *LCtx,\n                                  ProgramStateRef State);\n\n  /// Evaluate a call, running pre- and post-call checkers and allowing checkers\n  /// to be responsible for handling the evaluation of the call itself.\n  void evalCall(ExplodedNodeSet &Dst, ExplodedNode *Pred,\n                const CallEvent &Call);\n\n  /// Default implementation of call evaluation.\n  void defaultEvalCall(NodeBuilder &B, ExplodedNode *Pred,\n                       const CallEvent &Call,\n                       const EvalCallOptions &CallOpts = {});\n\n  /// Find location of the object that is being constructed by a given\n  /// constructor. This should ideally always succeed but due to not being\n  /// fully implemented it sometimes indicates that it failed via its\n  /// out-parameter CallOpts; in such cases a fake temporary region is\n  /// returned, which is better than nothing but does not represent\n  /// the actual behavior of the program.\n  SVal computeObjectUnderConstruction(\n      const Expr *E, ProgramStateRef State, const LocationContext *LCtx,\n      const ConstructionContext *CC, EvalCallOptions &CallOpts);\n\n  /// Update the program state with all the path-sensitive information\n  /// that's necessary to perform construction of an object with a given\n  /// syntactic construction context. V and CallOpts have to be obtained from\n  /// computeObjectUnderConstruction() invoked with the same set of\n  /// the remaining arguments (E, State, LCtx, CC).\n  ProgramStateRef updateObjectsUnderConstruction(\n      SVal V, const Expr *E, ProgramStateRef State, const LocationContext *LCtx,\n      const ConstructionContext *CC, const EvalCallOptions &CallOpts);\n\n  /// A convenient wrapper around computeObjectUnderConstruction\n  /// and updateObjectsUnderConstruction.\n  std::pair<ProgramStateRef, SVal> handleConstructionContext(\n      const Expr *E, ProgramStateRef State, const LocationContext *LCtx,\n      const ConstructionContext *CC, EvalCallOptions &CallOpts) {\n    SVal V = computeObjectUnderConstruction(E, State, LCtx, CC, CallOpts);\n    return std::make_pair(\n        updateObjectsUnderConstruction(V, E, State, LCtx, CC, CallOpts), V);\n  }\n\nprivate:\n  ProgramStateRef finishArgumentConstruction(ProgramStateRef State,\n                                             const CallEvent &Call);\n  void finishArgumentConstruction(ExplodedNodeSet &Dst, ExplodedNode *Pred,\n                                  const CallEvent &Call);\n\n  void evalLoadCommon(ExplodedNodeSet &Dst,\n                      const Expr *NodeEx,  /* Eventually will be a CFGStmt */\n                      const Expr *BoundEx,\n                      ExplodedNode *Pred,\n                      ProgramStateRef St,\n                      SVal location,\n                      const ProgramPointTag *tag,\n                      QualType LoadTy);\n\n  void evalLocation(ExplodedNodeSet &Dst,\n                    const Stmt *NodeEx, /* This will eventually be a CFGStmt */\n                    const Stmt *BoundEx,\n                    ExplodedNode *Pred,\n                    ProgramStateRef St,\n                    SVal location,\n                    bool isLoad);\n\n  /// Count the stack depth and determine if the call is recursive.\n  void examineStackFrames(const Decl *D, const LocationContext *LCtx,\n                          bool &IsRecursive, unsigned &StackDepth);\n\n  enum CallInlinePolicy {\n    CIP_Allowed,\n    CIP_DisallowedOnce,\n    CIP_DisallowedAlways\n  };\n\n  /// See if a particular call should be inlined, by only looking\n  /// at the call event and the current state of analysis.\n  CallInlinePolicy mayInlineCallKind(const CallEvent &Call,\n                                     const ExplodedNode *Pred,\n                                     AnalyzerOptions &Opts,\n                                     const EvalCallOptions &CallOpts);\n\n  /// See if the given AnalysisDeclContext is built for a function that we\n  /// should always inline simply because it's small enough.\n  /// Apart from \"small\" functions, we also have \"large\" functions\n  /// (cf. isLarge()), some of which are huge (cf. isHuge()), and we classify\n  /// the remaining functions as \"medium\".\n  bool isSmall(AnalysisDeclContext *ADC) const;\n\n  /// See if the given AnalysisDeclContext is built for a function that we\n  /// should inline carefully because it looks pretty large.\n  bool isLarge(AnalysisDeclContext *ADC) const;\n\n  /// See if the given AnalysisDeclContext is built for a function that we\n  /// should never inline because it's legit gigantic.\n  bool isHuge(AnalysisDeclContext *ADC) const;\n\n  /// See if the given AnalysisDeclContext is built for a function that we\n  /// should inline, just by looking at the declaration of the function.\n  bool mayInlineDecl(AnalysisDeclContext *ADC) const;\n\n  /// Checks our policies and decides weither the given call should be inlined.\n  bool shouldInlineCall(const CallEvent &Call, const Decl *D,\n                        const ExplodedNode *Pred,\n                        const EvalCallOptions &CallOpts = {});\n\n  bool inlineCall(const CallEvent &Call, const Decl *D, NodeBuilder &Bldr,\n                  ExplodedNode *Pred, ProgramStateRef State);\n\n  /// Conservatively evaluate call by invalidating regions and binding\n  /// a conjured return value.\n  void conservativeEvalCall(const CallEvent &Call, NodeBuilder &Bldr,\n                            ExplodedNode *Pred, ProgramStateRef State);\n\n  /// Either inline or process the call conservatively (or both), based\n  /// on DynamicDispatchBifurcation data.\n  void BifurcateCall(const MemRegion *BifurReg,\n                     const CallEvent &Call, const Decl *D, NodeBuilder &Bldr,\n                     ExplodedNode *Pred);\n\n  bool replayWithoutInlining(ExplodedNode *P, const LocationContext *CalleeLC);\n\n  /// Models a trivial copy or move constructor or trivial assignment operator\n  /// call with a simple bind.\n  void performTrivialCopy(NodeBuilder &Bldr, ExplodedNode *Pred,\n                          const CallEvent &Call);\n\n  /// If the value of the given expression \\p InitWithAdjustments is a NonLoc,\n  /// copy it into a new temporary object region, and replace the value of the\n  /// expression with that.\n  ///\n  /// If \\p Result is provided, the new region will be bound to this expression\n  /// instead of \\p InitWithAdjustments.\n  ///\n  /// Returns the temporary region with adjustments into the optional\n  /// OutRegionWithAdjustments out-parameter if a new region was indeed needed,\n  /// otherwise sets it to nullptr.\n  ProgramStateRef createTemporaryRegionIfNeeded(\n      ProgramStateRef State, const LocationContext *LC,\n      const Expr *InitWithAdjustments, const Expr *Result = nullptr,\n      const SubRegion **OutRegionWithAdjustments = nullptr);\n\n  /// Returns a region representing the first element of a (possibly\n  /// multi-dimensional) array, for the purposes of element construction or\n  /// destruction.\n  ///\n  /// On return, \\p Ty will be set to the base type of the array.\n  ///\n  /// If the type is not an array type at all, the original value is returned.\n  /// Otherwise the \"IsArray\" flag is set.\n  static SVal makeZeroElementRegion(ProgramStateRef State, SVal LValue,\n                                    QualType &Ty, bool &IsArray);\n\n  /// For a DeclStmt or CXXInitCtorInitializer, walk backward in the current CFG\n  /// block to find the constructor expression that directly constructed into\n  /// the storage for this statement. Returns null if the constructor for this\n  /// statement created a temporary object region rather than directly\n  /// constructing into an existing region.\n  const CXXConstructExpr *findDirectConstructorForCurrentCFGElement();\n\n  /// Common code that handles either a CXXConstructExpr or a\n  /// CXXInheritedCtorInitExpr.\n  void handleConstructor(const Expr *E, ExplodedNode *Pred,\n                         ExplodedNodeSet &Dst);\n\npublic:\n  /// Note whether this loop has any more iteratios to model. These methods are\n  /// essentially an interface for a GDM trait. Further reading in\n  /// ExprEngine::VisitObjCForCollectionStmt().\n  LLVM_NODISCARD static ProgramStateRef\n  setWhetherHasMoreIteration(ProgramStateRef State,\n                             const ObjCForCollectionStmt *O,\n                             const LocationContext *LC, bool HasMoreIteraton);\n\n  LLVM_NODISCARD static ProgramStateRef\n  removeIterationState(ProgramStateRef State, const ObjCForCollectionStmt *O,\n                       const LocationContext *LC);\n\n  LLVM_NODISCARD static bool hasMoreIteration(ProgramStateRef State,\n                                              const ObjCForCollectionStmt *O,\n                                              const LocationContext *LC);\nprivate:\n  /// Store the location of a C++ object corresponding to a statement\n  /// until the statement is actually encountered. For example, if a DeclStmt\n  /// has CXXConstructExpr as its initializer, the object would be considered\n  /// to be \"under construction\" between CXXConstructExpr and DeclStmt.\n  /// This allows, among other things, to keep bindings to variable's fields\n  /// made within the constructor alive until its declaration actually\n  /// goes into scope.\n  static ProgramStateRef\n  addObjectUnderConstruction(ProgramStateRef State,\n                             const ConstructionContextItem &Item,\n                             const LocationContext *LC, SVal V);\n\n  /// Mark the object sa fully constructed, cleaning up the state trait\n  /// that tracks objects under construction.\n  static ProgramStateRef\n  finishObjectConstruction(ProgramStateRef State,\n                           const ConstructionContextItem &Item,\n                           const LocationContext *LC);\n\n  /// If the given expression corresponds to a temporary that was used for\n  /// passing into an elidable copy/move constructor and that constructor\n  /// was actually elided, track that we also need to elide the destructor.\n  static ProgramStateRef elideDestructor(ProgramStateRef State,\n                                         const CXXBindTemporaryExpr *BTE,\n                                         const LocationContext *LC);\n\n  /// Stop tracking the destructor that corresponds to an elided constructor.\n  static ProgramStateRef\n  cleanupElidedDestructor(ProgramStateRef State,\n                          const CXXBindTemporaryExpr *BTE,\n                          const LocationContext *LC);\n\n  /// Returns true if the given expression corresponds to a temporary that\n  /// was constructed for passing into an elidable copy/move constructor\n  /// and that constructor was actually elided.\n  static bool isDestructorElided(ProgramStateRef State,\n                                 const CXXBindTemporaryExpr *BTE,\n                                 const LocationContext *LC);\n\n  /// Check if all objects under construction have been fully constructed\n  /// for the given context range (including FromLC, not including ToLC).\n  /// This is useful for assertions. Also checks if elided destructors\n  /// were cleaned up.\n  static bool areAllObjectsFullyConstructed(ProgramStateRef State,\n                                            const LocationContext *FromLC,\n                                            const LocationContext *ToLC);\n};\n\n/// Traits for storing the call processing policy inside GDM.\n/// The GDM stores the corresponding CallExpr pointer.\n// FIXME: This does not use the nice trait macros because it must be accessible\n// from multiple translation units.\nstruct ReplayWithoutInlining{};\ntemplate <>\nstruct ProgramStateTrait<ReplayWithoutInlining> :\n  public ProgramStatePartialTrait<const void*> {\n  static void *GDMIndex();\n};\n\n} // namespace ento\n\n} // namespace clang\n\n#endif // LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_EXPRENGINE_H\n"}, "62": {"id": 62, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h", "content": "//==- MemRegion.h - Abstract memory regions for static analysis -*- C++ -*--==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines MemRegion and its subclasses.  MemRegion defines a\n//  partially-typed abstraction of memory useful for path-sensitive dataflow\n//  analyses.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_MEMREGION_H\n#define LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_MEMREGION_H\n\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/CharUnits.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprObjC.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Analysis/AnalysisDeclContext.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SVals.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Casting.h\"\n#include <cassert>\n#include <cstdint>\n#include <limits>\n#include <string>\n#include <utility>\n\nnamespace clang {\n\nclass AnalysisDeclContext;\nclass CXXRecordDecl;\nclass Decl;\nclass LocationContext;\nclass StackFrameContext;\n\nnamespace ento {\n\nclass CodeTextRegion;\nclass MemRegion;\nclass MemRegionManager;\nclass MemSpaceRegion;\nclass SValBuilder;\nclass SymbolicRegion;\nclass VarRegion;\n\n/// Represent a region's offset within the top level base region.\nclass RegionOffset {\n  /// The base region.\n  const MemRegion *R = nullptr;\n\n  /// The bit offset within the base region. Can be negative.\n  int64_t Offset;\n\npublic:\n  // We're using a const instead of an enumeration due to the size required;\n  // Visual Studio will only create enumerations of size int, not long long.\n  static const int64_t Symbolic = std::numeric_limits<int64_t>::max();\n\n  RegionOffset() = default;\n  RegionOffset(const MemRegion *r, int64_t off) : R(r), Offset(off) {}\n\n  const MemRegion *getRegion() const { return R; }\n\n  bool hasSymbolicOffset() const { return Offset == Symbolic; }\n\n  int64_t getOffset() const {\n    assert(!hasSymbolicOffset());\n    return Offset;\n  }\n\n  bool isValid() const { return R; }\n};\n\n//===----------------------------------------------------------------------===//\n// Base region classes.\n//===----------------------------------------------------------------------===//\n\n/// MemRegion - The root abstract class for all memory regions.\nclass MemRegion : public llvm::FoldingSetNode {\npublic:\n  enum Kind {\n#define REGION(Id, Parent) Id ## Kind,\n#define REGION_RANGE(Id, First, Last) BEGIN_##Id = First, END_##Id = Last,\n#include \"clang/StaticAnalyzer/Core/PathSensitive/Regions.def\"\n  };\n\nprivate:\n  const Kind kind;\n  mutable Optional<RegionOffset> cachedOffset;\n\nprotected:\n  MemRegion(Kind k) : kind(k) {}\n  virtual ~MemRegion();\n\npublic:\n  ASTContext &getContext() const;\n\n  virtual void Profile(llvm::FoldingSetNodeID& ID) const = 0;\n\n  virtual MemRegionManager &getMemRegionManager() const = 0;\n\n  const MemSpaceRegion *getMemorySpace() const;\n\n  const MemRegion *getBaseRegion() const;\n\n  /// Recursively retrieve the region of the most derived class instance of\n  /// regions of C++ base class instances.\n  const MemRegion *getMostDerivedObjectRegion() const;\n\n  /// Check if the region is a subregion of the given region.\n  /// Each region is a subregion of itself.\n  virtual bool isSubRegionOf(const MemRegion *R) const;\n\n  const MemRegion *StripCasts(bool StripBaseAndDerivedCasts = true) const;\n\n  /// If this is a symbolic region, returns the region. Otherwise,\n  /// goes up the base chain looking for the first symbolic base region.\n  const SymbolicRegion *getSymbolicBase() const;\n\n  bool hasGlobalsOrParametersStorage() const;\n\n  bool hasStackStorage() const;\n\n  bool hasStackNonParametersStorage() const;\n\n  bool hasStackParametersStorage() const;\n\n  /// Compute the offset within the top level memory object.\n  RegionOffset getAsOffset() const;\n\n  /// Get a string representation of a region for debug use.\n  std::string getString() const;\n\n  virtual void dumpToStream(raw_ostream &os) const;\n\n  void dump() const;\n\n  /// Returns true if this region can be printed in a user-friendly way.\n  virtual bool canPrintPretty() const;\n\n  /// Print the region for use in diagnostics.\n  virtual void printPretty(raw_ostream &os) const;\n\n  /// Returns true if this region's textual representation can be used\n  /// as part of a larger expression.\n  virtual bool canPrintPrettyAsExpr() const;\n\n  /// Print the region as expression.\n  ///\n  /// When this region represents a subexpression, the method is for printing\n  /// an expression containing it.\n  virtual void printPrettyAsExpr(raw_ostream &os) const;\n\n  Kind getKind() const { return kind; }\n\n  template<typename RegionTy> const RegionTy* getAs() const;\n  template<typename RegionTy> const RegionTy* castAs() const;\n\n  virtual bool isBoundable() const { return false; }\n\n  /// Get descriptive name for memory region. The name is obtained from\n  /// the variable/field declaration retrieved from the memory region.\n  /// Regions that point to an element of an array are returned as: \"arr[0]\".\n  /// Regions that point to a struct are returned as: \"st.var\".\n  //\n  /// \\param UseQuotes Set if the name should be quoted.\n  ///\n  /// \\returns variable name for memory region\n  std::string getDescriptiveName(bool UseQuotes = true) const;\n\n  /// Retrieve source range from memory region. The range retrieval\n  /// is based on the decl obtained from the memory region.\n  /// For a VarRegion the range of the base region is returned.\n  /// For a FieldRegion the range of the field is returned.\n  /// If no declaration is found, an empty source range is returned.\n  /// The client is responsible for checking if the returned range is valid.\n  ///\n  /// \\returns source range for declaration retrieved from memory region\n  SourceRange sourceRange() const;\n};\n\n/// MemSpaceRegion - A memory region that represents a \"memory space\";\n///  for example, the set of global variables, the stack frame, etc.\nclass MemSpaceRegion : public MemRegion {\nprotected:\n  MemRegionManager &Mgr;\n\n  MemSpaceRegion(MemRegionManager &mgr, Kind k) : MemRegion(k), Mgr(mgr) {\n    assert(classof(this));\n  }\n\n  MemRegionManager &getMemRegionManager() const override { return Mgr; }\n\npublic:\n  bool isBoundable() const override { return false; }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n\n  static bool classof(const MemRegion *R) {\n    Kind k = R->getKind();\n    return k >= BEGIN_MEMSPACES && k <= END_MEMSPACES;\n  }\n};\n\n/// CodeSpaceRegion - The memory space that holds the executable code of\n/// functions and blocks.\nclass CodeSpaceRegion : public MemSpaceRegion {\n  friend class MemRegionManager;\n\n  CodeSpaceRegion(MemRegionManager &mgr)\n      : MemSpaceRegion(mgr, CodeSpaceRegionKind) {}\n\npublic:\n  void dumpToStream(raw_ostream &os) const override;\n\n  static bool classof(const MemRegion *R) {\n    return R->getKind() == CodeSpaceRegionKind;\n  }\n};\n\nclass GlobalsSpaceRegion : public MemSpaceRegion {\n  virtual void anchor();\n\nprotected:\n  GlobalsSpaceRegion(MemRegionManager &mgr, Kind k) : MemSpaceRegion(mgr, k) {\n    assert(classof(this));\n  }\n\npublic:\n  static bool classof(const MemRegion *R) {\n    Kind k = R->getKind();\n    return k >= BEGIN_GLOBAL_MEMSPACES && k <= END_GLOBAL_MEMSPACES;\n  }\n};\n\n/// The region of the static variables within the current CodeTextRegion\n/// scope.\n///\n/// Currently, only the static locals are placed there, so we know that these\n/// variables do not get invalidated by calls to other functions.\nclass StaticGlobalSpaceRegion : public GlobalsSpaceRegion {\n  friend class MemRegionManager;\n\n  const CodeTextRegion *CR;\n\n  StaticGlobalSpaceRegion(MemRegionManager &mgr, const CodeTextRegion *cr)\n      : GlobalsSpaceRegion(mgr, StaticGlobalSpaceRegionKind), CR(cr) {\n    assert(cr);\n  }\n\npublic:\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n\n  void dumpToStream(raw_ostream &os) const override;\n\n  const CodeTextRegion *getCodeRegion() const { return CR; }\n\n  static bool classof(const MemRegion *R) {\n    return R->getKind() == StaticGlobalSpaceRegionKind;\n  }\n};\n\n/// The region for all the non-static global variables.\n///\n/// This class is further split into subclasses for efficient implementation of\n/// invalidating a set of related global values as is done in\n/// RegionStoreManager::invalidateRegions (instead of finding all the dependent\n/// globals, we invalidate the whole parent region).\nclass NonStaticGlobalSpaceRegion : public GlobalsSpaceRegion {\n  void anchor() override;\n\nprotected:\n  NonStaticGlobalSpaceRegion(MemRegionManager &mgr, Kind k)\n      : GlobalsSpaceRegion(mgr, k) {\n    assert(classof(this));\n  }\n\npublic:\n  static bool classof(const MemRegion *R) {\n    Kind k = R->getKind();\n    return k >= BEGIN_NON_STATIC_GLOBAL_MEMSPACES &&\n           k <= END_NON_STATIC_GLOBAL_MEMSPACES;\n  }\n};\n\n/// The region containing globals which are defined in system/external\n/// headers and are considered modifiable by system calls (ex: errno).\nclass GlobalSystemSpaceRegion : public NonStaticGlobalSpaceRegion {\n  friend class MemRegionManager;\n\n  GlobalSystemSpaceRegion(MemRegionManager &mgr)\n      : NonStaticGlobalSpaceRegion(mgr, GlobalSystemSpaceRegionKind) {}\n\npublic:\n  void dumpToStream(raw_ostream &os) const override;\n\n  static bool classof(const MemRegion *R) {\n    return R->getKind() == GlobalSystemSpaceRegionKind;\n  }\n};\n\n/// The region containing globals which are considered not to be modified\n/// or point to data which could be modified as a result of a function call\n/// (system or internal). Ex: Const global scalars would be modeled as part of\n/// this region. This region also includes most system globals since they have\n/// low chance of being modified.\nclass GlobalImmutableSpaceRegion : public NonStaticGlobalSpaceRegion {\n  friend class MemRegionManager;\n\n  GlobalImmutableSpaceRegion(MemRegionManager &mgr)\n      : NonStaticGlobalSpaceRegion(mgr, GlobalImmutableSpaceRegionKind) {}\n\npublic:\n  void dumpToStream(raw_ostream &os) const override;\n\n  static bool classof(const MemRegion *R) {\n    return R->getKind() == GlobalImmutableSpaceRegionKind;\n  }\n};\n\n/// The region containing globals which can be modified by calls to\n/// \"internally\" defined functions - (for now just) functions other then system\n/// calls.\nclass GlobalInternalSpaceRegion : public NonStaticGlobalSpaceRegion {\n  friend class MemRegionManager;\n\n  GlobalInternalSpaceRegion(MemRegionManager &mgr)\n      : NonStaticGlobalSpaceRegion(mgr, GlobalInternalSpaceRegionKind) {}\n\npublic:\n  void dumpToStream(raw_ostream &os) const override;\n\n  static bool classof(const MemRegion *R) {\n    return R->getKind() == GlobalInternalSpaceRegionKind;\n  }\n};\n\nclass HeapSpaceRegion : public MemSpaceRegion {\n  friend class MemRegionManager;\n\n  HeapSpaceRegion(MemRegionManager &mgr)\n      : MemSpaceRegion(mgr, HeapSpaceRegionKind) {}\n\npublic:\n  void dumpToStream(raw_ostream &os) const override;\n\n  static bool classof(const MemRegion *R) {\n    return R->getKind() == HeapSpaceRegionKind;\n  }\n};\n\nclass UnknownSpaceRegion : public MemSpaceRegion {\n  friend class MemRegionManager;\n\n  UnknownSpaceRegion(MemRegionManager &mgr)\n      : MemSpaceRegion(mgr, UnknownSpaceRegionKind) {}\n\npublic:\n  void dumpToStream(raw_ostream &os) const override;\n\n  static bool classof(const MemRegion *R) {\n    return R->getKind() == UnknownSpaceRegionKind;\n  }\n};\n\nclass StackSpaceRegion : public MemSpaceRegion {\n  virtual void anchor();\n\n  const StackFrameContext *SFC;\n\nprotected:\n  StackSpaceRegion(MemRegionManager &mgr, Kind k, const StackFrameContext *sfc)\n      : MemSpaceRegion(mgr, k), SFC(sfc) {\n    assert(classof(this));\n    assert(sfc);\n  }\n\npublic:\n  const StackFrameContext *getStackFrame() const { return SFC; }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n\n  static bool classof(const MemRegion *R) {\n    Kind k = R->getKind();\n    return k >= BEGIN_STACK_MEMSPACES && k <= END_STACK_MEMSPACES;\n  }\n};\n\nclass StackLocalsSpaceRegion : public StackSpaceRegion {\n  friend class MemRegionManager;\n\n  StackLocalsSpaceRegion(MemRegionManager &mgr, const StackFrameContext *sfc)\n      : StackSpaceRegion(mgr, StackLocalsSpaceRegionKind, sfc) {}\n\npublic:\n  void dumpToStream(raw_ostream &os) const override;\n\n  static bool classof(const MemRegion *R) {\n    return R->getKind() == StackLocalsSpaceRegionKind;\n  }\n};\n\nclass StackArgumentsSpaceRegion : public StackSpaceRegion {\nprivate:\n  friend class MemRegionManager;\n\n  StackArgumentsSpaceRegion(MemRegionManager &mgr, const StackFrameContext *sfc)\n      : StackSpaceRegion(mgr, StackArgumentsSpaceRegionKind, sfc) {}\n\npublic:\n  void dumpToStream(raw_ostream &os) const override;\n\n  static bool classof(const MemRegion *R) {\n    return R->getKind() == StackArgumentsSpaceRegionKind;\n  }\n};\n\n/// SubRegion - A region that subsets another larger region.  Most regions\n///  are subclasses of SubRegion.\nclass SubRegion : public MemRegion {\n  virtual void anchor();\n\nprotected:\n  const MemRegion* superRegion;\n\n  SubRegion(const MemRegion *sReg, Kind k) : MemRegion(k), superRegion(sReg) {\n    assert(classof(this));\n    assert(sReg);\n  }\n\npublic:\n  const MemRegion* getSuperRegion() const {\n    return superRegion;\n  }\n\n  MemRegionManager &getMemRegionManager() const override;\n\n  bool isSubRegionOf(const MemRegion* R) const override;\n\n  static bool classof(const MemRegion* R) {\n    return R->getKind() > END_MEMSPACES;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// MemRegion subclasses.\n//===----------------------------------------------------------------------===//\n\n/// AllocaRegion - A region that represents an untyped blob of bytes created\n///  by a call to 'alloca'.\nclass AllocaRegion : public SubRegion {\n  friend class MemRegionManager;\n\n  // Block counter. Used to distinguish different pieces of memory allocated by\n  // alloca at the same call site.\n  unsigned Cnt;\n\n  const Expr *Ex;\n\n  AllocaRegion(const Expr *ex, unsigned cnt, const MemSpaceRegion *superRegion)\n      : SubRegion(superRegion, AllocaRegionKind), Cnt(cnt), Ex(ex) {\n    assert(Ex);\n  }\n\n  static void ProfileRegion(llvm::FoldingSetNodeID& ID, const Expr *Ex,\n                            unsigned Cnt, const MemRegion *superRegion);\n\npublic:\n  const Expr *getExpr() const { return Ex; }\n\n  bool isBoundable() const override { return true; }\n\n  void Profile(llvm::FoldingSetNodeID& ID) const override;\n\n  void dumpToStream(raw_ostream &os) const override;\n\n  static bool classof(const MemRegion* R) {\n    return R->getKind() == AllocaRegionKind;\n  }\n};\n\n/// TypedRegion - An abstract class representing regions that are typed.\nclass TypedRegion : public SubRegion {\n  void anchor() override;\n\nprotected:\n  TypedRegion(const MemRegion *sReg, Kind k) : SubRegion(sReg, k) {\n    assert(classof(this));\n  }\n\npublic:\n  virtual QualType getLocationType() const = 0;\n\n  QualType getDesugaredLocationType(ASTContext &Context) const {\n    return getLocationType().getDesugaredType(Context);\n  }\n\n  bool isBoundable() const override { return true; }\n\n  static bool classof(const MemRegion* R) {\n    unsigned k = R->getKind();\n    return k >= BEGIN_TYPED_REGIONS && k <= END_TYPED_REGIONS;\n  }\n};\n\n/// TypedValueRegion - An abstract class representing regions having a typed value.\nclass TypedValueRegion : public TypedRegion {\n  void anchor() override;\n\nprotected:\n  TypedValueRegion(const MemRegion* sReg, Kind k) : TypedRegion(sReg, k) {\n    assert(classof(this));\n  }\n\npublic:\n  virtual QualType getValueType() const = 0;\n\n  QualType getLocationType() const override {\n    // FIXME: We can possibly optimize this later to cache this value.\n    QualType T = getValueType();\n    ASTContext &ctx = getContext();\n    if (T->getAs<ObjCObjectType>())\n      return ctx.getObjCObjectPointerType(T);\n    return ctx.getPointerType(getValueType());\n  }\n\n  QualType getDesugaredValueType(ASTContext &Context) const {\n    QualType T = getValueType();\n    return T.getTypePtrOrNull() ? T.getDesugaredType(Context) : T;\n  }\n\n  static bool classof(const MemRegion* R) {\n    unsigned k = R->getKind();\n    return k >= BEGIN_TYPED_VALUE_REGIONS && k <= END_TYPED_VALUE_REGIONS;\n  }\n};\n\nclass CodeTextRegion : public TypedRegion {\n  void anchor() override;\n\nprotected:\n  CodeTextRegion(const MemSpaceRegion *sreg, Kind k) : TypedRegion(sreg, k) {\n    assert(classof(this));\n  }\n\npublic:\n  bool isBoundable() const override { return false; }\n\n  static bool classof(const MemRegion* R) {\n    Kind k = R->getKind();\n    return k >= BEGIN_CODE_TEXT_REGIONS && k <= END_CODE_TEXT_REGIONS;\n  }\n};\n\n/// FunctionCodeRegion - A region that represents code texts of function.\nclass FunctionCodeRegion : public CodeTextRegion {\n  friend class MemRegionManager;\n\n  const NamedDecl *FD;\n\n  FunctionCodeRegion(const NamedDecl *fd, const CodeSpaceRegion* sreg)\n      : CodeTextRegion(sreg, FunctionCodeRegionKind), FD(fd) {\n    assert(isa<ObjCMethodDecl>(fd) || isa<FunctionDecl>(fd));\n  }\n\n  static void ProfileRegion(llvm::FoldingSetNodeID& ID, const NamedDecl *FD,\n                            const MemRegion*);\n\npublic:\n  QualType getLocationType() const override {\n    const ASTContext &Ctx = getContext();\n    if (const auto *D = dyn_cast<FunctionDecl>(FD)) {\n      return Ctx.getPointerType(D->getType());\n    }\n\n    assert(isa<ObjCMethodDecl>(FD));\n    assert(false && \"Getting the type of ObjCMethod is not supported yet\");\n\n    // TODO: We might want to return a different type here (ex: id (*ty)(...))\n    //       depending on how it is used.\n    return {};\n  }\n\n  const NamedDecl *getDecl() const {\n    return FD;\n  }\n\n  void dumpToStream(raw_ostream &os) const override;\n\n  void Profile(llvm::FoldingSetNodeID& ID) const override;\n\n  static bool classof(const MemRegion* R) {\n    return R->getKind() == FunctionCodeRegionKind;\n  }\n};\n\n/// BlockCodeRegion - A region that represents code texts of blocks (closures).\n///  Blocks are represented with two kinds of regions.  BlockCodeRegions\n///  represent the \"code\", while BlockDataRegions represent instances of blocks,\n///  which correspond to \"code+data\".  The distinction is important, because\n///  like a closure a block captures the values of externally referenced\n///  variables.\nclass BlockCodeRegion : public CodeTextRegion {\n  friend class MemRegionManager;\n\n  const BlockDecl *BD;\n  AnalysisDeclContext *AC;\n  CanQualType locTy;\n\n  BlockCodeRegion(const BlockDecl *bd, CanQualType lTy,\n                  AnalysisDeclContext *ac, const CodeSpaceRegion* sreg)\n      : CodeTextRegion(sreg, BlockCodeRegionKind), BD(bd), AC(ac), locTy(lTy) {\n    assert(bd);\n    assert(ac);\n    assert(lTy->getTypePtr()->isBlockPointerType());\n  }\n\n  static void ProfileRegion(llvm::FoldingSetNodeID& ID, const BlockDecl *BD,\n                            CanQualType, const AnalysisDeclContext*,\n                            const MemRegion*);\n\npublic:\n  QualType getLocationType() const override {\n    return locTy;\n  }\n\n  const BlockDecl *getDecl() const {\n    return BD;\n  }\n\n  AnalysisDeclContext *getAnalysisDeclContext() const { return AC; }\n\n  void dumpToStream(raw_ostream &os) const override;\n\n  void Profile(llvm::FoldingSetNodeID& ID) const override;\n\n  static bool classof(const MemRegion* R) {\n    return R->getKind() == BlockCodeRegionKind;\n  }\n};\n\n/// BlockDataRegion - A region that represents a block instance.\n///  Blocks are represented with two kinds of regions.  BlockCodeRegions\n///  represent the \"code\", while BlockDataRegions represent instances of blocks,\n///  which correspond to \"code+data\".  The distinction is important, because\n///  like a closure a block captures the values of externally referenced\n///  variables.\nclass BlockDataRegion : public TypedRegion {\n  friend class MemRegionManager;\n\n  const BlockCodeRegion *BC;\n  const LocationContext *LC; // Can be null\n  unsigned BlockCount;\n  void *ReferencedVars = nullptr;\n  void *OriginalVars = nullptr;\n\n  BlockDataRegion(const BlockCodeRegion *bc, const LocationContext *lc,\n                  unsigned count, const MemSpaceRegion *sreg)\n      : TypedRegion(sreg, BlockDataRegionKind), BC(bc), LC(lc),\n        BlockCount(count) {\n    assert(bc);\n    assert(lc);\n    assert(isa<GlobalImmutableSpaceRegion>(sreg) ||\n           isa<StackLocalsSpaceRegion>(sreg) ||\n           isa<UnknownSpaceRegion>(sreg));\n  }\n\n  static void ProfileRegion(llvm::FoldingSetNodeID&, const BlockCodeRegion *,\n                            const LocationContext *, unsigned,\n                            const MemRegion *);\n\npublic:\n  const BlockCodeRegion *getCodeRegion() const { return BC; }\n\n  const BlockDecl *getDecl() const { return BC->getDecl(); }\n\n  QualType getLocationType() const override { return BC->getLocationType(); }\n\n  class referenced_vars_iterator {\n    const MemRegion * const *R;\n    const MemRegion * const *OriginalR;\n\n  public:\n    explicit referenced_vars_iterator(const MemRegion * const *r,\n                                      const MemRegion * const *originalR)\n        : R(r), OriginalR(originalR) {}\n\n    const VarRegion *getCapturedRegion() const {\n      return cast<VarRegion>(*R);\n    }\n\n    const VarRegion *getOriginalRegion() const {\n      return cast<VarRegion>(*OriginalR);\n    }\n\n    bool operator==(const referenced_vars_iterator &I) const {\n      assert((R == nullptr) == (I.R == nullptr));\n      return I.R == R;\n    }\n\n    bool operator!=(const referenced_vars_iterator &I) const {\n      assert((R == nullptr) == (I.R == nullptr));\n      return I.R != R;\n    }\n\n    referenced_vars_iterator &operator++() {\n      ++R;\n      ++OriginalR;\n      return *this;\n    }\n  };\n\n  /// Return the original region for a captured region, if\n  /// one exists.\n  const VarRegion *getOriginalRegion(const VarRegion *VR) const;\n\n  referenced_vars_iterator referenced_vars_begin() const;\n  referenced_vars_iterator referenced_vars_end() const;\n\n  void dumpToStream(raw_ostream &os) const override;\n\n  void Profile(llvm::FoldingSetNodeID& ID) const override;\n\n  static bool classof(const MemRegion* R) {\n    return R->getKind() == BlockDataRegionKind;\n  }\n\nprivate:\n  void LazyInitializeReferencedVars();\n  std::pair<const VarRegion *, const VarRegion *>\n  getCaptureRegions(const VarDecl *VD);\n};\n\n/// SymbolicRegion - A special, \"non-concrete\" region. Unlike other region\n///  classes, SymbolicRegion represents a region that serves as an alias for\n///  either a real region, a NULL pointer, etc.  It essentially is used to\n///  map the concept of symbolic values into the domain of regions.  Symbolic\n///  regions do not need to be typed.\nclass SymbolicRegion : public SubRegion {\n  friend class MemRegionManager;\n\n  const SymbolRef sym;\n\n  SymbolicRegion(const SymbolRef s, const MemSpaceRegion *sreg)\n      : SubRegion(sreg, SymbolicRegionKind), sym(s) {\n    // Because pointer arithmetic is represented by ElementRegion layers,\n    // the base symbol here should not contain any arithmetic.\n    assert(s && isa<SymbolData>(s));\n    assert(s->getType()->isAnyPointerType() ||\n           s->getType()->isReferenceType() ||\n           s->getType()->isBlockPointerType());\n    assert(isa<UnknownSpaceRegion>(sreg) || isa<HeapSpaceRegion>(sreg));\n  }\n\npublic:\n  SymbolRef getSymbol() const { return sym; }\n\n  bool isBoundable() const override { return true; }\n\n  void Profile(llvm::FoldingSetNodeID& ID) const override;\n\n  static void ProfileRegion(llvm::FoldingSetNodeID& ID,\n                            SymbolRef sym,\n                            const MemRegion* superRegion);\n\n  void dumpToStream(raw_ostream &os) const override;\n\n  static bool classof(const MemRegion* R) {\n    return R->getKind() == SymbolicRegionKind;\n  }\n};\n\n/// StringRegion - Region associated with a StringLiteral.\nclass StringRegion : public TypedValueRegion {\n  friend class MemRegionManager;\n\n  const StringLiteral *Str;\n\n  StringRegion(const StringLiteral *str, const GlobalInternalSpaceRegion *sreg)\n      : TypedValueRegion(sreg, StringRegionKind), Str(str) {\n    assert(str);\n  }\n\n  static void ProfileRegion(llvm::FoldingSetNodeID &ID,\n                            const StringLiteral *Str,\n                            const MemRegion *superRegion);\n\npublic:\n  const StringLiteral *getStringLiteral() const { return Str; }\n\n  QualType getValueType() const override { return Str->getType(); }\n\n  bool isBoundable() const override { return false; }\n\n  void Profile(llvm::FoldingSetNodeID& ID) const override {\n    ProfileRegion(ID, Str, superRegion);\n  }\n\n  void dumpToStream(raw_ostream &os) const override;\n\n  static bool classof(const MemRegion* R) {\n    return R->getKind() == StringRegionKind;\n  }\n};\n\n/// The region associated with an ObjCStringLiteral.\nclass ObjCStringRegion : public TypedValueRegion {\n  friend class MemRegionManager;\n\n  const ObjCStringLiteral *Str;\n\n  ObjCStringRegion(const ObjCStringLiteral *str,\n                   const GlobalInternalSpaceRegion *sreg)\n      : TypedValueRegion(sreg, ObjCStringRegionKind), Str(str) {\n    assert(str);\n  }\n\n  static void ProfileRegion(llvm::FoldingSetNodeID &ID,\n                            const ObjCStringLiteral *Str,\n                            const MemRegion *superRegion);\n\npublic:\n  const ObjCStringLiteral *getObjCStringLiteral() const { return Str; }\n\n  QualType getValueType() const override { return Str->getType(); }\n\n  bool isBoundable() const override { return false; }\n\n  void Profile(llvm::FoldingSetNodeID& ID) const override {\n    ProfileRegion(ID, Str, superRegion);\n  }\n\n  void dumpToStream(raw_ostream &os) const override;\n\n  static bool classof(const MemRegion* R) {\n    return R->getKind() == ObjCStringRegionKind;\n  }\n};\n\n/// CompoundLiteralRegion - A memory region representing a compound literal.\n///   Compound literals are essentially temporaries that are stack allocated\n///   or in the global constant pool.\nclass CompoundLiteralRegion : public TypedValueRegion {\n  friend class MemRegionManager;\n\n  const CompoundLiteralExpr *CL;\n\n  CompoundLiteralRegion(const CompoundLiteralExpr *cl,\n                        const MemSpaceRegion *sReg)\n      : TypedValueRegion(sReg, CompoundLiteralRegionKind), CL(cl) {\n    assert(cl);\n    assert(isa<GlobalInternalSpaceRegion>(sReg) ||\n           isa<StackLocalsSpaceRegion>(sReg));\n  }\n\n  static void ProfileRegion(llvm::FoldingSetNodeID& ID,\n                            const CompoundLiteralExpr *CL,\n                            const MemRegion* superRegion);\n\npublic:\n  QualType getValueType() const override { return CL->getType(); }\n\n  bool isBoundable() const override { return !CL->isFileScope(); }\n\n  void Profile(llvm::FoldingSetNodeID& ID) const override;\n\n  void dumpToStream(raw_ostream &os) const override;\n\n  const CompoundLiteralExpr *getLiteralExpr() const { return CL; }\n\n  static bool classof(const MemRegion* R) {\n    return R->getKind() == CompoundLiteralRegionKind;\n  }\n};\n\nclass DeclRegion : public TypedValueRegion {\nprotected:\n  DeclRegion(const MemRegion *sReg, Kind k) : TypedValueRegion(sReg, k) {\n    assert(classof(this));\n  }\n\npublic:\n  virtual const ValueDecl *getDecl() const = 0;\n\n  static bool classof(const MemRegion* R) {\n    unsigned k = R->getKind();\n    return k >= BEGIN_DECL_REGIONS && k <= END_DECL_REGIONS;\n  }\n};\n\nclass VarRegion : public DeclRegion {\n  friend class MemRegionManager;\n\nprotected:\n  // Constructors and protected methods.\n  VarRegion(const MemRegion *sReg, Kind k) : DeclRegion(sReg, k) {\n    // VarRegion appears in unknown space when it's a block variable as seen\n    // from a block using it, when this block is analyzed at top-level.\n    // Other block variables appear within block data regions,\n    // which, unlike everything else on this list, are not memory spaces.\n    assert(isa<GlobalsSpaceRegion>(sReg) || isa<StackSpaceRegion>(sReg) ||\n           isa<BlockDataRegion>(sReg) || isa<UnknownSpaceRegion>(sReg));\n  }\n\npublic:\n  const VarDecl *getDecl() const override = 0;\n\n  const StackFrameContext *getStackFrame() const;\n\n  QualType getValueType() const override {\n    // FIXME: We can cache this if needed.\n    return getDecl()->getType();\n  }\n\n  static bool classof(const MemRegion *R) {\n    unsigned k = R->getKind();\n    return k >= BEGIN_VAR_REGIONS && k <= END_VAR_REGIONS;\n  }\n};\n\nclass NonParamVarRegion : public VarRegion {\n  friend class MemRegionManager;\n\n  const VarDecl *VD;\n\n  // Constructors and private methods.\n  NonParamVarRegion(const VarDecl *vd, const MemRegion *sReg)\n      : VarRegion(sReg, NonParamVarRegionKind), VD(vd) {\n    // VarRegion appears in unknown space when it's a block variable as seen\n    // from a block using it, when this block is analyzed at top-level.\n    // Other block variables appear within block data regions,\n    // which, unlike everything else on this list, are not memory spaces.\n    assert(isa<GlobalsSpaceRegion>(sReg) || isa<StackSpaceRegion>(sReg) ||\n           isa<BlockDataRegion>(sReg) || isa<UnknownSpaceRegion>(sReg));\n  }\n\n  static void ProfileRegion(llvm::FoldingSetNodeID &ID, const VarDecl *VD,\n                            const MemRegion *superRegion);\n\npublic:\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n\n  const VarDecl *getDecl() const override { return VD; }\n\n  QualType getValueType() const override {\n    // FIXME: We can cache this if needed.\n    return getDecl()->getType();\n  }\n\n  void dumpToStream(raw_ostream &os) const override;\n\n  bool canPrintPrettyAsExpr() const override;\n\n  void printPrettyAsExpr(raw_ostream &os) const override;\n\n  static bool classof(const MemRegion* R) {\n    return R->getKind() == NonParamVarRegionKind;\n  }\n};\n\n/// ParamVarRegion - Represents a region for paremters. Only parameters of the\n/// function in the current stack frame are represented as `ParamVarRegion`s.\n/// Parameters of top-level analyzed functions as well as captured paremeters\n/// by lambdas and blocks are repesented as `VarRegion`s.\n\n// FIXME: `ParamVarRegion` only supports parameters of functions, C++\n// constructors, blocks and Objective-C methods with existing `Decl`. Upon\n// implementing stack frame creations for functions without decl (functions\n// passed by unknown function pointer) methods of `ParamVarRegion` must be\n// updated.\nclass ParamVarRegion : public VarRegion {\n  friend class MemRegionManager;\n\n  const Expr *OriginExpr;\n  unsigned Index;\n\n  ParamVarRegion(const Expr *OE, unsigned Idx, const MemRegion *SReg)\n      : VarRegion(SReg, ParamVarRegionKind), OriginExpr(OE), Index(Idx) {\n    assert(!cast<StackSpaceRegion>(SReg)->getStackFrame()->inTopFrame());\n  }\n\n  static void ProfileRegion(llvm::FoldingSetNodeID &ID, const Expr *OE,\n                            unsigned Idx, const MemRegion *SReg);\n\npublic:\n  const Expr *getOriginExpr() const { return OriginExpr; }\n  unsigned getIndex() const { return Index; }\n\n  void Profile(llvm::FoldingSetNodeID& ID) const override;\n\n  void dumpToStream(raw_ostream &os) const override;\n\n  QualType getValueType() const override;\n  const ParmVarDecl *getDecl() const override;\n\n  bool canPrintPrettyAsExpr() const override;\n  void printPrettyAsExpr(raw_ostream &os) const override;\n\n  static bool classof(const MemRegion *R) {\n    return R->getKind() == ParamVarRegionKind;\n  }\n};\n\n/// CXXThisRegion - Represents the region for the implicit 'this' parameter\n///  in a call to a C++ method.  This region doesn't represent the object\n///  referred to by 'this', but rather 'this' itself.\nclass CXXThisRegion : public TypedValueRegion {\n  friend class MemRegionManager;\n\n  CXXThisRegion(const PointerType *thisPointerTy,\n                const StackArgumentsSpaceRegion *sReg)\n      : TypedValueRegion(sReg, CXXThisRegionKind),\n        ThisPointerTy(thisPointerTy) {\n    assert(ThisPointerTy->getPointeeType()->getAsCXXRecordDecl() &&\n           \"Invalid region type!\");\n  }\n\n  static void ProfileRegion(llvm::FoldingSetNodeID &ID,\n                            const PointerType *PT,\n                            const MemRegion *sReg);\n\npublic:\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n\n  QualType getValueType() const override {\n    return QualType(ThisPointerTy, 0);\n  }\n\n  void dumpToStream(raw_ostream &os) const override;\n\n  static bool classof(const MemRegion* R) {\n    return R->getKind() == CXXThisRegionKind;\n  }\n\nprivate:\n  const PointerType *ThisPointerTy;\n};\n\nclass FieldRegion : public DeclRegion {\n  friend class MemRegionManager;\n\n  const FieldDecl *FD;\n\n  FieldRegion(const FieldDecl *fd, const SubRegion *sReg)\n      : DeclRegion(sReg, FieldRegionKind), FD(fd) {}\n\n  static void ProfileRegion(llvm::FoldingSetNodeID &ID, const FieldDecl *FD,\n                            const MemRegion* superRegion) {\n    ID.AddInteger(static_cast<unsigned>(FieldRegionKind));\n    ID.AddPointer(FD);\n    ID.AddPointer(superRegion);\n  }\n\npublic:\n  const FieldDecl *getDecl() const override { return FD; }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n\n  QualType getValueType() const override {\n    // FIXME: We can cache this if needed.\n    return getDecl()->getType();\n  }\n\n  void dumpToStream(raw_ostream &os) const override;\n\n  bool canPrintPretty() const override;\n  void printPretty(raw_ostream &os) const override;\n  bool canPrintPrettyAsExpr() const override;\n  void printPrettyAsExpr(raw_ostream &os) const override;\n\n  static bool classof(const MemRegion* R) {\n    return R->getKind() == FieldRegionKind;\n  }\n};\n\nclass ObjCIvarRegion : public DeclRegion {\n  friend class MemRegionManager;\n\n  const ObjCIvarDecl *IVD;\n\n  ObjCIvarRegion(const ObjCIvarDecl *ivd, const SubRegion *sReg);\n\n  static void ProfileRegion(llvm::FoldingSetNodeID& ID, const ObjCIvarDecl *ivd,\n                            const MemRegion* superRegion);\n\npublic:\n  const ObjCIvarDecl *getDecl() const override;\n\n  void Profile(llvm::FoldingSetNodeID& ID) const override;\n\n  QualType getValueType() const override;\n\n  bool canPrintPrettyAsExpr() const override;\n  void printPrettyAsExpr(raw_ostream &os) const override;\n\n  void dumpToStream(raw_ostream &os) const override;\n\n  static bool classof(const MemRegion* R) {\n    return R->getKind() == ObjCIvarRegionKind;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Auxiliary data classes for use with MemRegions.\n//===----------------------------------------------------------------------===//\n\nclass RegionRawOffset {\n  friend class ElementRegion;\n\n  const MemRegion *Region;\n  CharUnits Offset;\n\n  RegionRawOffset(const MemRegion* reg, CharUnits offset = CharUnits::Zero())\n      : Region(reg), Offset(offset) {}\n\npublic:\n  // FIXME: Eventually support symbolic offsets.\n  CharUnits getOffset() const { return Offset; }\n  const MemRegion *getRegion() const { return Region; }\n\n  void dumpToStream(raw_ostream &os) const;\n  void dump() const;\n};\n\n/// ElementRegion is used to represent both array elements and casts.\nclass ElementRegion : public TypedValueRegion {\n  friend class MemRegionManager;\n\n  QualType ElementType;\n  NonLoc Index;\n\n  ElementRegion(QualType elementType, NonLoc Idx, const SubRegion *sReg)\n      : TypedValueRegion(sReg, ElementRegionKind), ElementType(elementType),\n        Index(Idx) {\n    assert((!Idx.getAs<nonloc::ConcreteInt>() ||\n            Idx.castAs<nonloc::ConcreteInt>().getValue().isSigned()) &&\n           \"The index must be signed\");\n    assert(!elementType.isNull() && !elementType->isVoidType() &&\n           \"Invalid region type!\");\n  }\n\n  static void ProfileRegion(llvm::FoldingSetNodeID& ID, QualType elementType,\n                            SVal Idx, const MemRegion* superRegion);\n\npublic:\n  NonLoc getIndex() const { return Index; }\n\n  QualType getValueType() const override { return ElementType; }\n\n  QualType getElementType() const { return ElementType; }\n\n  /// Compute the offset within the array. The array might also be a subobject.\n  RegionRawOffset getAsArrayOffset() const;\n\n  void dumpToStream(raw_ostream &os) const override;\n\n  void Profile(llvm::FoldingSetNodeID& ID) const override;\n\n  static bool classof(const MemRegion* R) {\n    return R->getKind() == ElementRegionKind;\n  }\n};\n\n// C++ temporary object associated with an expression.\nclass CXXTempObjectRegion : public TypedValueRegion {\n  friend class MemRegionManager;\n\n  Expr const *Ex;\n\n  CXXTempObjectRegion(Expr const *E, MemSpaceRegion const *sReg)\n      : TypedValueRegion(sReg, CXXTempObjectRegionKind), Ex(E) {\n    assert(E);\n    assert(isa<StackLocalsSpaceRegion>(sReg) ||\n           isa<GlobalInternalSpaceRegion>(sReg));\n  }\n\n  static void ProfileRegion(llvm::FoldingSetNodeID &ID,\n                            Expr const *E, const MemRegion *sReg);\n\npublic:\n  const Expr *getExpr() const { return Ex; }\n\n  QualType getValueType() const override { return Ex->getType(); }\n\n  void dumpToStream(raw_ostream &os) const override;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n\n  static bool classof(const MemRegion* R) {\n    return R->getKind() == CXXTempObjectRegionKind;\n  }\n};\n\n// CXXBaseObjectRegion represents a base object within a C++ object. It is\n// identified by the base class declaration and the region of its parent object.\nclass CXXBaseObjectRegion : public TypedValueRegion {\n  friend class MemRegionManager;\n\n  llvm::PointerIntPair<const CXXRecordDecl *, 1, bool> Data;\n\n  CXXBaseObjectRegion(const CXXRecordDecl *RD, bool IsVirtual,\n                      const SubRegion *SReg)\n      : TypedValueRegion(SReg, CXXBaseObjectRegionKind), Data(RD, IsVirtual) {\n    assert(RD);\n  }\n\n  static void ProfileRegion(llvm::FoldingSetNodeID &ID, const CXXRecordDecl *RD,\n                            bool IsVirtual, const MemRegion *SReg);\n\npublic:\n  const CXXRecordDecl *getDecl() const { return Data.getPointer(); }\n  bool isVirtual() const { return Data.getInt(); }\n\n  QualType getValueType() const override;\n\n  void dumpToStream(raw_ostream &os) const override;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n\n  bool canPrintPrettyAsExpr() const override;\n\n  void printPrettyAsExpr(raw_ostream &os) const override;\n\n  static bool classof(const MemRegion *region) {\n    return region->getKind() == CXXBaseObjectRegionKind;\n  }\n};\n\n// CXXDerivedObjectRegion represents a derived-class object that surrounds\n// a C++ object. It is identified by the derived class declaration and the\n// region of its parent object. It is a bit counter-intuitive (but not otherwise\n// unseen) that this region represents a larger segment of memory that its\n// super-region.\nclass CXXDerivedObjectRegion : public TypedValueRegion {\n  friend class MemRegionManager;\n\n  const CXXRecordDecl *DerivedD;\n\n  CXXDerivedObjectRegion(const CXXRecordDecl *DerivedD, const SubRegion *SReg)\n      : TypedValueRegion(SReg, CXXDerivedObjectRegionKind), DerivedD(DerivedD) {\n    assert(DerivedD);\n    // In case of a concrete region, it should always be possible to model\n    // the base-to-derived cast by undoing a previous derived-to-base cast,\n    // otherwise the cast is most likely ill-formed.\n    assert(SReg->getSymbolicBase() &&\n           \"Should have unwrapped a base region instead!\");\n  }\n\n  static void ProfileRegion(llvm::FoldingSetNodeID &ID, const CXXRecordDecl *RD,\n                            const MemRegion *SReg);\n\npublic:\n  const CXXRecordDecl *getDecl() const { return DerivedD; }\n\n  QualType getValueType() const override;\n\n  void dumpToStream(raw_ostream &os) const override;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n\n  bool canPrintPrettyAsExpr() const override;\n\n  void printPrettyAsExpr(raw_ostream &os) const override;\n\n  static bool classof(const MemRegion *region) {\n    return region->getKind() == CXXDerivedObjectRegionKind;\n  }\n};\n\ntemplate<typename RegionTy>\nconst RegionTy* MemRegion::getAs() const {\n  if (const auto *RT = dyn_cast<RegionTy>(this))\n    return RT;\n\n  return nullptr;\n}\n\ntemplate<typename RegionTy>\nconst RegionTy* MemRegion::castAs() const {\n  return cast<RegionTy>(this);\n}\n\n//===----------------------------------------------------------------------===//\n// MemRegionManager - Factory object for creating regions.\n//===----------------------------------------------------------------------===//\n\nclass MemRegionManager {\n  ASTContext &Ctx;\n  llvm::BumpPtrAllocator& A;\n\n  llvm::FoldingSet<MemRegion> Regions;\n\n  GlobalInternalSpaceRegion *InternalGlobals = nullptr;\n  GlobalSystemSpaceRegion *SystemGlobals = nullptr;\n  GlobalImmutableSpaceRegion *ImmutableGlobals = nullptr;\n\n  llvm::DenseMap<const StackFrameContext *, StackLocalsSpaceRegion *>\n    StackLocalsSpaceRegions;\n  llvm::DenseMap<const StackFrameContext *, StackArgumentsSpaceRegion *>\n    StackArgumentsSpaceRegions;\n  llvm::DenseMap<const CodeTextRegion *, StaticGlobalSpaceRegion *>\n    StaticsGlobalSpaceRegions;\n\n  HeapSpaceRegion *heap = nullptr;\n  UnknownSpaceRegion *unknown = nullptr;\n  CodeSpaceRegion *code = nullptr;\n\npublic:\n  MemRegionManager(ASTContext &c, llvm::BumpPtrAllocator &a) : Ctx(c), A(a) {}\n  ~MemRegionManager();\n\n  ASTContext &getContext() { return Ctx; }\n\n  llvm::BumpPtrAllocator &getAllocator() { return A; }\n\n  /// \\returns The static size in bytes of the region \\p MR.\n  /// \\note The region \\p MR must be a 'SubRegion'.\n  DefinedOrUnknownSVal getStaticSize(const MemRegion *MR,\n                                     SValBuilder &SVB) const;\n\n  /// getStackLocalsRegion - Retrieve the memory region associated with the\n  ///  specified stack frame.\n  const StackLocalsSpaceRegion *\n  getStackLocalsRegion(const StackFrameContext *STC);\n\n  /// getStackArgumentsRegion - Retrieve the memory region associated with\n  ///  function/method arguments of the specified stack frame.\n  const StackArgumentsSpaceRegion *\n  getStackArgumentsRegion(const StackFrameContext *STC);\n\n  /// getGlobalsRegion - Retrieve the memory region associated with\n  ///  global variables.\n  const GlobalsSpaceRegion *getGlobalsRegion(\n      MemRegion::Kind K = MemRegion::GlobalInternalSpaceRegionKind,\n      const CodeTextRegion *R = nullptr);\n\n  /// getHeapRegion - Retrieve the memory region associated with the\n  ///  generic \"heap\".\n  const HeapSpaceRegion *getHeapRegion();\n\n  /// getUnknownRegion - Retrieve the memory region associated with unknown\n  /// memory space.\n  const UnknownSpaceRegion *getUnknownRegion();\n\n  const CodeSpaceRegion *getCodeRegion();\n\n  /// getAllocaRegion - Retrieve a region associated with a call to alloca().\n  const AllocaRegion *getAllocaRegion(const Expr *Ex, unsigned Cnt,\n                                      const LocationContext *LC);\n\n  /// getCompoundLiteralRegion - Retrieve the region associated with a\n  ///  given CompoundLiteral.\n  const CompoundLiteralRegion*\n  getCompoundLiteralRegion(const CompoundLiteralExpr *CL,\n                           const LocationContext *LC);\n\n  /// getCXXThisRegion - Retrieve the [artificial] region associated with the\n  ///  parameter 'this'.\n  const CXXThisRegion *getCXXThisRegion(QualType thisPointerTy,\n                                        const LocationContext *LC);\n\n  /// Retrieve or create a \"symbolic\" memory region.\n  const SymbolicRegion* getSymbolicRegion(SymbolRef Sym);\n\n  /// Return a unique symbolic region belonging to heap memory space.\n  const SymbolicRegion *getSymbolicHeapRegion(SymbolRef sym);\n\n  const StringRegion *getStringRegion(const StringLiteral *Str);\n\n  const ObjCStringRegion *getObjCStringRegion(const ObjCStringLiteral *Str);\n\n  /// getVarRegion - Retrieve or create the memory region associated with\n  ///  a specified VarDecl and LocationContext.\n  const VarRegion *getVarRegion(const VarDecl *VD, const LocationContext *LC);\n\n  /// getVarRegion - Retrieve or create the memory region associated with\n  ///  a specified VarDecl and LocationContext.\n  const NonParamVarRegion *getNonParamVarRegion(const VarDecl *VD,\n                                                const MemRegion *superR);\n\n  /// getParamVarRegion - Retrieve or create the memory region\n  /// associated with a specified CallExpr, Index and LocationContext.\n  const ParamVarRegion *getParamVarRegion(const Expr *OriginExpr,\n                                          unsigned Index,\n                                          const LocationContext *LC);\n\n  /// getElementRegion - Retrieve the memory region associated with the\n  ///  associated element type, index, and super region.\n  const ElementRegion *getElementRegion(QualType elementType, NonLoc Idx,\n                                        const SubRegion *superRegion,\n                                        ASTContext &Ctx);\n\n  const ElementRegion *getElementRegionWithSuper(const ElementRegion *ER,\n                                                 const SubRegion *superRegion) {\n    return getElementRegion(ER->getElementType(), ER->getIndex(),\n                            superRegion, ER->getContext());\n  }\n\n  /// getFieldRegion - Retrieve or create the memory region associated with\n  ///  a specified FieldDecl.  'superRegion' corresponds to the containing\n  ///  memory region (which typically represents the memory representing\n  ///  a structure or class).\n  const FieldRegion *getFieldRegion(const FieldDecl *fd,\n                                    const SubRegion* superRegion);\n\n  const FieldRegion *getFieldRegionWithSuper(const FieldRegion *FR,\n                                             const SubRegion *superRegion) {\n    return getFieldRegion(FR->getDecl(), superRegion);\n  }\n\n  /// getObjCIvarRegion - Retrieve or create the memory region associated with\n  ///   a specified Objective-c instance variable.  'superRegion' corresponds\n  ///   to the containing region (which typically represents the Objective-C\n  ///   object).\n  const ObjCIvarRegion *getObjCIvarRegion(const ObjCIvarDecl *ivd,\n                                          const SubRegion* superRegion);\n\n  const CXXTempObjectRegion *getCXXTempObjectRegion(Expr const *Ex,\n                                                    LocationContext const *LC);\n\n  /// Create a CXXBaseObjectRegion with the given base class for region\n  /// \\p Super.\n  ///\n  /// The type of \\p Super is assumed be a class deriving from \\p BaseClass.\n  const CXXBaseObjectRegion *\n  getCXXBaseObjectRegion(const CXXRecordDecl *BaseClass, const SubRegion *Super,\n                         bool IsVirtual);\n\n  /// Create a CXXBaseObjectRegion with the same CXXRecordDecl but a different\n  /// super region.\n  const CXXBaseObjectRegion *\n  getCXXBaseObjectRegionWithSuper(const CXXBaseObjectRegion *baseReg,\n                                  const SubRegion *superRegion) {\n    return getCXXBaseObjectRegion(baseReg->getDecl(), superRegion,\n                                  baseReg->isVirtual());\n  }\n\n  /// Create a CXXDerivedObjectRegion with the given derived class for region\n  /// \\p Super. This should not be used for casting an existing\n  /// CXXBaseObjectRegion back to the derived type; instead, CXXBaseObjectRegion\n  /// should be removed.\n  const CXXDerivedObjectRegion *\n  getCXXDerivedObjectRegion(const CXXRecordDecl *BaseClass,\n                            const SubRegion *Super);\n\n  const FunctionCodeRegion *getFunctionCodeRegion(const NamedDecl *FD);\n  const BlockCodeRegion *getBlockCodeRegion(const BlockDecl *BD,\n                                            CanQualType locTy,\n                                            AnalysisDeclContext *AC);\n\n  /// getBlockDataRegion - Get the memory region associated with an instance\n  ///  of a block.  Unlike many other MemRegions, the LocationContext*\n  ///  argument is allowed to be NULL for cases where we have no known\n  ///  context.\n  const BlockDataRegion *getBlockDataRegion(const BlockCodeRegion *bc,\n                                            const LocationContext *lc,\n                                            unsigned blockCount);\n\n  /// Create a CXXTempObjectRegion for temporaries which are lifetime-extended\n  /// by static references. This differs from getCXXTempObjectRegion in the\n  /// super-region used.\n  const CXXTempObjectRegion *getCXXStaticTempObjectRegion(const Expr *Ex);\n\nprivate:\n  template <typename RegionTy, typename SuperTy,\n            typename Arg1Ty>\n  RegionTy* getSubRegion(const Arg1Ty arg1,\n                         const SuperTy* superRegion);\n\n  template <typename RegionTy, typename SuperTy,\n            typename Arg1Ty, typename Arg2Ty>\n  RegionTy* getSubRegion(const Arg1Ty arg1, const Arg2Ty arg2,\n                         const SuperTy* superRegion);\n\n  template <typename RegionTy, typename SuperTy,\n            typename Arg1Ty, typename Arg2Ty, typename Arg3Ty>\n  RegionTy* getSubRegion(const Arg1Ty arg1, const Arg2Ty arg2,\n                         const Arg3Ty arg3,\n                         const SuperTy* superRegion);\n\n  template <typename REG>\n  const REG* LazyAllocate(REG*& region);\n\n  template <typename REG, typename ARG>\n  const REG* LazyAllocate(REG*& region, ARG a);\n};\n\n//===----------------------------------------------------------------------===//\n// Out-of-line member definitions.\n//===----------------------------------------------------------------------===//\n\ninline ASTContext &MemRegion::getContext() const {\n  return getMemRegionManager().getContext();\n}\n\n//===----------------------------------------------------------------------===//\n// Means for storing region/symbol handling traits.\n//===----------------------------------------------------------------------===//\n\n/// Information about invalidation for a particular region/symbol.\nclass RegionAndSymbolInvalidationTraits {\n  using StorageTypeForKinds = unsigned char;\n\n  llvm::DenseMap<const MemRegion *, StorageTypeForKinds> MRTraitsMap;\n  llvm::DenseMap<SymbolRef, StorageTypeForKinds> SymTraitsMap;\n\n  using const_region_iterator =\n      llvm::DenseMap<const MemRegion *, StorageTypeForKinds>::const_iterator;\n  using const_symbol_iterator =\n      llvm::DenseMap<SymbolRef, StorageTypeForKinds>::const_iterator;\n\npublic:\n  /// Describes different invalidation traits.\n  enum InvalidationKinds {\n    /// Tells that a region's contents is not changed.\n    TK_PreserveContents = 0x1,\n\n    /// Suppress pointer-escaping of a region.\n    TK_SuppressEscape = 0x2,\n\n    // Do not invalidate super region.\n    TK_DoNotInvalidateSuperRegion = 0x4,\n\n    /// When applied to a MemSpaceRegion, indicates the entire memory space\n    /// should be invalidated.\n    TK_EntireMemSpace = 0x8\n\n    // Do not forget to extend StorageTypeForKinds if number of traits exceed\n    // the number of bits StorageTypeForKinds can store.\n  };\n\n  void setTrait(SymbolRef Sym, InvalidationKinds IK);\n  void setTrait(const MemRegion *MR, InvalidationKinds IK);\n  bool hasTrait(SymbolRef Sym, InvalidationKinds IK) const;\n  bool hasTrait(const MemRegion *MR, InvalidationKinds IK) const;\n};\n\n//===----------------------------------------------------------------------===//\n// Pretty-printing regions.\n//===----------------------------------------------------------------------===//\ninline raw_ostream &operator<<(raw_ostream &os, const MemRegion *R) {\n  R->dumpToStream(os);\n  return os;\n}\n\n} // namespace ento\n\n} // namespace clang\n\n#endif // LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_MEMREGION_H\n"}, "63": {"id": 63, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/RangedConstraintManager.h", "content": "//== RangedConstraintManager.h ----------------------------------*- C++ -*--==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  Ranged constraint manager, built on SimpleConstraintManager.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LIB_STATICANALYZER_CORE_RANGEDCONSTRAINTMANAGER_H\n#define LLVM_CLANG_LIB_STATICANALYZER_CORE_RANGEDCONSTRAINTMANAGER_H\n\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SimpleConstraintManager.h\"\n\nnamespace clang {\n\nnamespace ento {\n\n/// A Range represents the closed range [from, to].  The caller must\n/// guarantee that from <= to.  Note that Range is immutable, so as not\n/// to subvert RangeSet's immutability.\nclass Range : public std::pair<const llvm::APSInt *, const llvm::APSInt *> {\npublic:\n  Range(const llvm::APSInt &from, const llvm::APSInt &to)\n      : std::pair<const llvm::APSInt *, const llvm::APSInt *>(&from, &to) {\n    assert(from <= to);\n  }\n\n  Range(const llvm::APSInt &point)\n      : std::pair<const llvm::APSInt *, const llvm::APSInt *>(&point, &point) {}\n\n  bool Includes(const llvm::APSInt &v) const {\n    return *first <= v && v <= *second;\n  }\n  const llvm::APSInt &From() const { return *first; }\n  const llvm::APSInt &To() const { return *second; }\n  const llvm::APSInt *getConcreteValue() const {\n    return &From() == &To() ? &From() : nullptr;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    ID.AddPointer(&From());\n    ID.AddPointer(&To());\n  }\n};\n\nclass RangeTrait : public llvm::ImutContainerInfo<Range> {\npublic:\n  // When comparing if one Range is less than another, we should compare\n  // the actual APSInt values instead of their pointers.  This keeps the order\n  // consistent (instead of comparing by pointer values) and can potentially\n  // be used to speed up some of the operations in RangeSet.\n  static inline bool isLess(key_type_ref lhs, key_type_ref rhs) {\n    return *lhs.first < *rhs.first ||\n           (!(*rhs.first < *lhs.first) && *lhs.second < *rhs.second);\n  }\n};\n\n/// RangeSet contains a set of ranges. If the set is empty, then\n///  there the value of a symbol is overly constrained and there are no\n///  possible values for that symbol.\nclass RangeSet {\n  typedef llvm::ImmutableSet<Range, RangeTrait> PrimRangeSet;\n  PrimRangeSet ranges; // no need to make const, since it is an\n                       // ImmutableSet - this allows default operator=\n                       // to work.\npublic:\n  typedef PrimRangeSet::Factory Factory;\n  typedef PrimRangeSet::iterator iterator;\n\n  RangeSet(PrimRangeSet RS) : ranges(RS) {}\n\n  /// Create a new set with all ranges of this set and RS.\n  /// Possible intersections are not checked here.\n  RangeSet addRange(Factory &F, const RangeSet &RS) {\n    PrimRangeSet Ranges(RS.ranges);\n    for (const auto &range : ranges)\n      Ranges = F.add(Ranges, range);\n    return RangeSet(Ranges);\n  }\n\n  iterator begin() const { return ranges.begin(); }\n  iterator end() const { return ranges.end(); }\n\n  bool isEmpty() const { return ranges.isEmpty(); }\n\n  /// Construct a new RangeSet representing '{ [from, to] }'.\n  RangeSet(Factory &F, const llvm::APSInt &from, const llvm::APSInt &to)\n      : ranges(F.add(F.getEmptySet(), Range(from, to))) {}\n\n  /// Construct a new RangeSet representing the given point as a range.\n  RangeSet(Factory &F, const llvm::APSInt &point) : RangeSet(F, point, point) {}\n\n  /// Profile - Generates a hash profile of this RangeSet for use\n  ///  by FoldingSet.\n  void Profile(llvm::FoldingSetNodeID &ID) const { ranges.Profile(ID); }\n\n  /// getConcreteValue - If a symbol is contrained to equal a specific integer\n  ///  constant then this method returns that value.  Otherwise, it returns\n  ///  NULL.\n  const llvm::APSInt *getConcreteValue() const {\n    return ranges.isSingleton() ? ranges.begin()->getConcreteValue() : nullptr;\n  }\n\n  /// Get a minimal value covered by the ranges in the set\n  const llvm::APSInt &getMinValue() const;\n  /// Get a maximal value covered by the ranges in the set\n  const llvm::APSInt &getMaxValue() const;\n\nprivate:\n  void IntersectInRange(BasicValueFactory &BV, Factory &F,\n                        const llvm::APSInt &Lower, const llvm::APSInt &Upper,\n                        PrimRangeSet &newRanges, PrimRangeSet::iterator &i,\n                        PrimRangeSet::iterator &e) const;\n\n  bool pin(llvm::APSInt &Lower, llvm::APSInt &Upper) const;\n\npublic:\n  RangeSet Intersect(BasicValueFactory &BV, Factory &F, llvm::APSInt Lower,\n                     llvm::APSInt Upper) const;\n  RangeSet Intersect(BasicValueFactory &BV, Factory &F,\n                     const RangeSet &Other) const;\n  RangeSet Negate(BasicValueFactory &BV, Factory &F) const;\n  RangeSet Delete(BasicValueFactory &BV, Factory &F,\n                  const llvm::APSInt &Point) const;\n\n  void print(raw_ostream &os) const;\n\n  bool operator==(const RangeSet &other) const {\n    return ranges == other.ranges;\n  }\n};\n\nusing ConstraintMap = llvm::ImmutableMap<SymbolRef, RangeSet>;\nConstraintMap getConstraintMap(ProgramStateRef State);\n\nclass RangedConstraintManager : public SimpleConstraintManager {\npublic:\n  RangedConstraintManager(ExprEngine *EE, SValBuilder &SB)\n      : SimpleConstraintManager(EE, SB) {}\n\n  ~RangedConstraintManager() override;\n\n  //===------------------------------------------------------------------===//\n  // Implementation for interface from SimpleConstraintManager.\n  //===------------------------------------------------------------------===//\n\n  ProgramStateRef assumeSym(ProgramStateRef State, SymbolRef Sym,\n                            bool Assumption) override;\n\n  ProgramStateRef assumeSymInclusiveRange(ProgramStateRef State, SymbolRef Sym,\n                                          const llvm::APSInt &From,\n                                          const llvm::APSInt &To,\n                                          bool InRange) override;\n\n  ProgramStateRef assumeSymUnsupported(ProgramStateRef State, SymbolRef Sym,\n                                       bool Assumption) override;\n\nprotected:\n  /// Assume a constraint between a symbolic expression and a concrete integer.\n  virtual ProgramStateRef assumeSymRel(ProgramStateRef State, SymbolRef Sym,\n                                       BinaryOperator::Opcode op,\n                                       const llvm::APSInt &Int);\n\n  //===------------------------------------------------------------------===//\n  // Interface that subclasses must implement.\n  //===------------------------------------------------------------------===//\n\n  // Each of these is of the form \"$Sym+Adj <> V\", where \"<>\" is the comparison\n  // operation for the method being invoked.\n\n  virtual ProgramStateRef assumeSymNE(ProgramStateRef State, SymbolRef Sym,\n                                      const llvm::APSInt &V,\n                                      const llvm::APSInt &Adjustment) = 0;\n\n  virtual ProgramStateRef assumeSymEQ(ProgramStateRef State, SymbolRef Sym,\n                                      const llvm::APSInt &V,\n                                      const llvm::APSInt &Adjustment) = 0;\n\n  virtual ProgramStateRef assumeSymLT(ProgramStateRef State, SymbolRef Sym,\n                                      const llvm::APSInt &V,\n                                      const llvm::APSInt &Adjustment) = 0;\n\n  virtual ProgramStateRef assumeSymGT(ProgramStateRef State, SymbolRef Sym,\n                                      const llvm::APSInt &V,\n                                      const llvm::APSInt &Adjustment) = 0;\n\n  virtual ProgramStateRef assumeSymLE(ProgramStateRef State, SymbolRef Sym,\n                                      const llvm::APSInt &V,\n                                      const llvm::APSInt &Adjustment) = 0;\n\n  virtual ProgramStateRef assumeSymGE(ProgramStateRef State, SymbolRef Sym,\n                                      const llvm::APSInt &V,\n                                      const llvm::APSInt &Adjustment) = 0;\n\n  virtual ProgramStateRef assumeSymWithinInclusiveRange(\n      ProgramStateRef State, SymbolRef Sym, const llvm::APSInt &From,\n      const llvm::APSInt &To, const llvm::APSInt &Adjustment) = 0;\n\n  virtual ProgramStateRef assumeSymOutsideInclusiveRange(\n      ProgramStateRef State, SymbolRef Sym, const llvm::APSInt &From,\n      const llvm::APSInt &To, const llvm::APSInt &Adjustment) = 0;\n\n  //===------------------------------------------------------------------===//\n  // Internal implementation.\n  //===------------------------------------------------------------------===//\nprivate:\n  static void computeAdjustment(SymbolRef &Sym, llvm::APSInt &Adjustment);\n};\n\n} // namespace ento\n} // namespace clang\n\nREGISTER_FACTORY_WITH_PROGRAMSTATE(ConstraintMap)\n\n#endif\n"}, "64": {"id": 64, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SVals.h", "content": "//===- SVals.h - Abstract Values for Static Analysis ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines SVal, Loc, and NonLoc, classes that represent\n//  abstract r-values for use with path-sensitive value tracking.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_SVALS_H\n#define LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_SVALS_H\n\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/ImmutableList.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/Support/Casting.h\"\n#include <cassert>\n#include <cstdint>\n#include <utility>\n\n//==------------------------------------------------------------------------==//\n//  Base SVal types.\n//==------------------------------------------------------------------------==//\n\nnamespace clang {\n\nclass CXXBaseSpecifier;\nclass DeclaratorDecl;\nclass FunctionDecl;\nclass LabelDecl;\n\nnamespace ento {\n\nclass BasicValueFactory;\nclass CompoundValData;\nclass LazyCompoundValData;\nclass MemRegion;\nclass PointerToMemberData;\nclass SValBuilder;\nclass TypedValueRegion;\n\nnamespace nonloc {\n\n/// Sub-kinds for NonLoc values.\nenum Kind {\n#define NONLOC_SVAL(Id, Parent) Id ## Kind,\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SVals.def\"\n};\n\n} // namespace nonloc\n\nnamespace loc {\n\n/// Sub-kinds for Loc values.\nenum Kind {\n#define LOC_SVAL(Id, Parent) Id ## Kind,\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SVals.def\"\n};\n\n} // namespace loc\n\n/// SVal - This represents a symbolic expression, which can be either\n///  an L-value or an R-value.\n///\nclass SVal {\npublic:\n  enum BaseKind {\n    // The enumerators must be representable using 2 bits.\n#define BASIC_SVAL(Id, Parent) Id ## Kind,\n#define ABSTRACT_SVAL_WITH_KIND(Id, Parent) Id ## Kind,\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SVals.def\"\n  };\n  enum { BaseBits = 2, BaseMask = 0b11 };\n\nprotected:\n  const void *Data = nullptr;\n\n  /// The lowest 2 bits are a BaseKind (0 -- 3).\n  ///  The higher bits are an unsigned \"kind\" value.\n  unsigned Kind = 0;\n\n  explicit SVal(const void *d, bool isLoc, unsigned ValKind)\n      : Data(d), Kind((isLoc ? LocKind : NonLocKind) | (ValKind << BaseBits)) {}\n\n  explicit SVal(BaseKind k, const void *D = nullptr) : Data(D), Kind(k) {}\n\npublic:\n  explicit SVal() = default;\n\n  /// Convert to the specified SVal type, asserting that this SVal is of\n  /// the desired type.\n  template<typename T>\n  T castAs() const {\n    assert(T::isKind(*this));\n    return *static_cast<const T *>(this);\n  }\n\n  /// Convert to the specified SVal type, returning None if this SVal is\n  /// not of the desired type.\n  template<typename T>\n  Optional<T> getAs() const {\n    if (!T::isKind(*this))\n      return None;\n    return *static_cast<const T *>(this);\n  }\n\n  unsigned getRawKind() const { return Kind; }\n  BaseKind getBaseKind() const { return (BaseKind) (Kind & BaseMask); }\n  unsigned getSubKind() const { return Kind >> BaseBits; }\n\n  // This method is required for using SVal in a FoldingSetNode.  It\n  // extracts a unique signature for this SVal object.\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    ID.AddInteger((unsigned) getRawKind());\n    ID.AddPointer(Data);\n  }\n\n  bool operator==(const SVal &R) const {\n    return getRawKind() == R.getRawKind() && Data == R.Data;\n  }\n\n  bool operator!=(const SVal &R) const {\n    return !(*this == R);\n  }\n\n  bool isUnknown() const {\n    return getRawKind() == UnknownValKind;\n  }\n\n  bool isUndef() const {\n    return getRawKind() == UndefinedValKind;\n  }\n\n  bool isUnknownOrUndef() const {\n    return getRawKind() <= UnknownValKind;\n  }\n\n  bool isValid() const {\n    return getRawKind() > UnknownValKind;\n  }\n\n  bool isConstant() const;\n\n  bool isConstant(int I) const;\n\n  bool isZeroConstant() const;\n\n  /// hasConjuredSymbol - If this SVal wraps a conjured symbol, return true;\n  bool hasConjuredSymbol() const;\n\n  /// getAsFunctionDecl - If this SVal is a MemRegionVal and wraps a\n  /// CodeTextRegion wrapping a FunctionDecl, return that FunctionDecl.\n  /// Otherwise return 0.\n  const FunctionDecl *getAsFunctionDecl() const;\n\n  /// If this SVal is a location and wraps a symbol, return that\n  ///  SymbolRef. Otherwise return 0.\n  ///\n  /// Casts are ignored during lookup.\n  /// \\param IncludeBaseRegions The boolean that controls whether the search\n  /// should continue to the base regions if the region is not symbolic.\n  SymbolRef getAsLocSymbol(bool IncludeBaseRegions = false) const;\n\n  /// Get the symbol in the SVal or its base region.\n  SymbolRef getLocSymbolInBase() const;\n\n  /// If this SVal wraps a symbol return that SymbolRef.\n  /// Otherwise, return 0.\n  ///\n  /// Casts are ignored during lookup.\n  /// \\param IncludeBaseRegions The boolean that controls whether the search\n  /// should continue to the base regions if the region is not symbolic.\n  SymbolRef getAsSymbol(bool IncludeBaseRegions = false) const;\n\n  const MemRegion *getAsRegion() const;\n\n  /// printJson - Pretty-prints in JSON format.\n  void printJson(raw_ostream &Out, bool AddQuotes) const;\n\n  void dumpToStream(raw_ostream &OS) const;\n  void dump() const;\n\n  SymExpr::symbol_iterator symbol_begin() const {\n    const SymExpr *SE = getAsSymbol(/*IncludeBaseRegions=*/true);\n    if (SE)\n      return SE->symbol_begin();\n    else\n      return SymExpr::symbol_iterator();\n  }\n\n  SymExpr::symbol_iterator symbol_end() const {\n    return SymExpr::symbol_end();\n  }\n};\n\ninline raw_ostream &operator<<(raw_ostream &os, clang::ento::SVal V) {\n  V.dumpToStream(os);\n  return os;\n}\n\nclass UndefinedVal : public SVal {\npublic:\n  UndefinedVal() : SVal(UndefinedValKind) {}\n\nprivate:\n  friend class SVal;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == UndefinedValKind;\n  }\n};\n\nclass DefinedOrUnknownSVal : public SVal {\npublic:\n  // We want calling these methods to be a compiler error since they are\n  // tautologically false.\n  bool isUndef() const = delete;\n  bool isValid() const = delete;\n\nprotected:\n  DefinedOrUnknownSVal() = default;\n  explicit DefinedOrUnknownSVal(const void *d, bool isLoc, unsigned ValKind)\n      : SVal(d, isLoc, ValKind) {}\n  explicit DefinedOrUnknownSVal(BaseKind k, void *D = nullptr) : SVal(k, D) {}\n\nprivate:\n  friend class SVal;\n\n  static bool isKind(const SVal& V) {\n    return !V.isUndef();\n  }\n};\n\nclass UnknownVal : public DefinedOrUnknownSVal {\npublic:\n  explicit UnknownVal() : DefinedOrUnknownSVal(UnknownValKind) {}\n\nprivate:\n  friend class SVal;\n\n  static bool isKind(const SVal &V) {\n    return V.getBaseKind() == UnknownValKind;\n  }\n};\n\nclass DefinedSVal : public DefinedOrUnknownSVal {\npublic:\n  // We want calling these methods to be a compiler error since they are\n  // tautologically true/false.\n  bool isUnknown() const = delete;\n  bool isUnknownOrUndef() const = delete;\n  bool isValid() const = delete;\n\nprotected:\n  DefinedSVal() = default;\n  explicit DefinedSVal(const void *d, bool isLoc, unsigned ValKind)\n      : DefinedOrUnknownSVal(d, isLoc, ValKind) {}\n\nprivate:\n  friend class SVal;\n\n  static bool isKind(const SVal& V) {\n    return !V.isUnknownOrUndef();\n  }\n};\n\n/// Represents an SVal that is guaranteed to not be UnknownVal.\nclass KnownSVal : public SVal {\n  friend class SVal;\n\n  KnownSVal() = default;\n\n  static bool isKind(const SVal &V) {\n    return !V.isUnknown();\n  }\n\npublic:\n  KnownSVal(const DefinedSVal &V) : SVal(V) {}\n  KnownSVal(const UndefinedVal &V) : SVal(V) {}\n};\n\nclass NonLoc : public DefinedSVal {\nprotected:\n  NonLoc() = default;\n  explicit NonLoc(unsigned SubKind, const void *d)\n      : DefinedSVal(d, false, SubKind) {}\n\npublic:\n  void dumpToStream(raw_ostream &Out) const;\n\n  static bool isCompoundType(QualType T) {\n    return T->isArrayType() || T->isRecordType() ||\n           T->isAnyComplexType() || T->isVectorType();\n  }\n\nprivate:\n  friend class SVal;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == NonLocKind;\n  }\n};\n\nclass Loc : public DefinedSVal {\nprotected:\n  Loc() = default;\n  explicit Loc(unsigned SubKind, const void *D)\n      : DefinedSVal(const_cast<void *>(D), true, SubKind) {}\n\npublic:\n  void dumpToStream(raw_ostream &Out) const;\n\n  static bool isLocType(QualType T) {\n    return T->isAnyPointerType() || T->isBlockPointerType() ||\n           T->isReferenceType() || T->isNullPtrType();\n  }\n\nprivate:\n  friend class SVal;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == LocKind;\n  }\n};\n\n//==------------------------------------------------------------------------==//\n//  Subclasses of NonLoc.\n//==------------------------------------------------------------------------==//\n\nnamespace nonloc {\n\n/// Represents symbolic expression that isn't a location.\nclass SymbolVal : public NonLoc {\npublic:\n  SymbolVal() = delete;\n  SymbolVal(SymbolRef sym) : NonLoc(SymbolValKind, sym) {\n    assert(sym);\n    assert(!Loc::isLocType(sym->getType()));\n  }\n\n  SymbolRef getSymbol() const {\n    return (const SymExpr *) Data;\n  }\n\n  bool isExpression() const {\n    return !isa<SymbolData>(getSymbol());\n  }\n\nprivate:\n  friend class SVal;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == NonLocKind &&\n           V.getSubKind() == SymbolValKind;\n  }\n\n  static bool isKind(const NonLoc& V) {\n    return V.getSubKind() == SymbolValKind;\n  }\n};\n\n/// Value representing integer constant.\nclass ConcreteInt : public NonLoc {\npublic:\n  explicit ConcreteInt(const llvm::APSInt& V) : NonLoc(ConcreteIntKind, &V) {}\n\n  const llvm::APSInt& getValue() const {\n    return *static_cast<const llvm::APSInt *>(Data);\n  }\n\n  // Transfer functions for binary/unary operations on ConcreteInts.\n  SVal evalBinOp(SValBuilder &svalBuilder, BinaryOperator::Opcode Op,\n                 const ConcreteInt& R) const;\n\n  ConcreteInt evalComplement(SValBuilder &svalBuilder) const;\n\n  ConcreteInt evalMinus(SValBuilder &svalBuilder) const;\n\nprivate:\n  friend class SVal;\n\n  ConcreteInt() = default;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == NonLocKind &&\n           V.getSubKind() == ConcreteIntKind;\n  }\n\n  static bool isKind(const NonLoc& V) {\n    return V.getSubKind() == ConcreteIntKind;\n  }\n};\n\nclass LocAsInteger : public NonLoc {\n  friend class ento::SValBuilder;\n\n  explicit LocAsInteger(const std::pair<SVal, uintptr_t> &data)\n      : NonLoc(LocAsIntegerKind, &data) {\n    // We do not need to represent loc::ConcreteInt as LocAsInteger,\n    // as it'd collapse into a nonloc::ConcreteInt instead.\n    assert(data.first.getBaseKind() == LocKind &&\n           (data.first.getSubKind() == loc::MemRegionValKind ||\n            data.first.getSubKind() == loc::GotoLabelKind));\n  }\n\npublic:\n  Loc getLoc() const {\n    const std::pair<SVal, uintptr_t> *D =\n      static_cast<const std::pair<SVal, uintptr_t> *>(Data);\n    return D->first.castAs<Loc>();\n  }\n\n  Loc getPersistentLoc() const {\n    const std::pair<SVal, uintptr_t> *D =\n      static_cast<const std::pair<SVal, uintptr_t> *>(Data);\n    const SVal& V = D->first;\n    return V.castAs<Loc>();\n  }\n\n  unsigned getNumBits() const {\n    const std::pair<SVal, uintptr_t> *D =\n      static_cast<const std::pair<SVal, uintptr_t> *>(Data);\n    return D->second;\n  }\n\nprivate:\n  friend class SVal;\n\n  LocAsInteger() = default;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == NonLocKind &&\n           V.getSubKind() == LocAsIntegerKind;\n  }\n\n  static bool isKind(const NonLoc& V) {\n    return V.getSubKind() == LocAsIntegerKind;\n  }\n};\n\nclass CompoundVal : public NonLoc {\n  friend class ento::SValBuilder;\n\n  explicit CompoundVal(const CompoundValData* D) : NonLoc(CompoundValKind, D) {}\n\npublic:\n  const CompoundValData* getValue() const {\n    return static_cast<const CompoundValData *>(Data);\n  }\n\n  using iterator = llvm::ImmutableList<SVal>::iterator;\n\n  iterator begin() const;\n  iterator end() const;\n\nprivate:\n  friend class SVal;\n\n  CompoundVal() = default;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == NonLocKind && V.getSubKind() == CompoundValKind;\n  }\n\n  static bool isKind(const NonLoc& V) {\n    return V.getSubKind() == CompoundValKind;\n  }\n};\n\nclass LazyCompoundVal : public NonLoc {\n  friend class ento::SValBuilder;\n\n  explicit LazyCompoundVal(const LazyCompoundValData *D)\n      : NonLoc(LazyCompoundValKind, D) {}\n\npublic:\n  const LazyCompoundValData *getCVData() const {\n    return static_cast<const LazyCompoundValData *>(Data);\n  }\n\n  const void *getStore() const;\n  const TypedValueRegion *getRegion() const;\n\nprivate:\n  friend class SVal;\n\n  LazyCompoundVal() = default;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == NonLocKind &&\n           V.getSubKind() == LazyCompoundValKind;\n  }\n\n  static bool isKind(const NonLoc& V) {\n    return V.getSubKind() == LazyCompoundValKind;\n  }\n};\n\n/// Value representing pointer-to-member.\n///\n/// This value is qualified as NonLoc because neither loading nor storing\n/// operations are applied to it. Instead, the analyzer uses the L-value coming\n/// from pointer-to-member applied to an object.\n/// This SVal is represented by a NamedDecl which can be a member function\n/// pointer or a member data pointer and an optional list of CXXBaseSpecifiers.\n/// This list is required to accumulate the pointer-to-member cast history to\n/// figure out the correct subobject field. In particular, implicit casts grow\n/// this list and explicit casts like static_cast shrink this list.\nclass PointerToMember : public NonLoc {\n  friend class ento::SValBuilder;\n\npublic:\n  using PTMDataType =\n      llvm::PointerUnion<const NamedDecl *, const PointerToMemberData *>;\n\n  const PTMDataType getPTMData() const {\n    return PTMDataType::getFromOpaqueValue(const_cast<void *>(Data));\n  }\n\n  bool isNullMemberPointer() const;\n\n  const NamedDecl *getDecl() const;\n\n  template<typename AdjustedDecl>\n  const AdjustedDecl *getDeclAs() const {\n    return dyn_cast_or_null<AdjustedDecl>(getDecl());\n  }\n\n  using iterator = llvm::ImmutableList<const CXXBaseSpecifier *>::iterator;\n\n  iterator begin() const;\n  iterator end() const;\n\nprivate:\n  friend class SVal;\n\n  PointerToMember() = default;\n  explicit PointerToMember(const PTMDataType D)\n      : NonLoc(PointerToMemberKind, D.getOpaqueValue()) {}\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == NonLocKind &&\n           V.getSubKind() == PointerToMemberKind;\n  }\n\n  static bool isKind(const NonLoc& V) {\n    return V.getSubKind() == PointerToMemberKind;\n  }\n};\n\n} // namespace nonloc\n\n//==------------------------------------------------------------------------==//\n//  Subclasses of Loc.\n//==------------------------------------------------------------------------==//\n\nnamespace loc {\n\nclass GotoLabel : public Loc {\npublic:\n  explicit GotoLabel(const LabelDecl *Label) : Loc(GotoLabelKind, Label) {\n    assert(Label);\n  }\n\n  const LabelDecl *getLabel() const {\n    return static_cast<const LabelDecl *>(Data);\n  }\n\nprivate:\n  friend class SVal;\n\n  GotoLabel() = default;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == LocKind && V.getSubKind() == GotoLabelKind;\n  }\n\n  static bool isKind(const Loc& V) {\n    return V.getSubKind() == GotoLabelKind;\n  }\n};\n\nclass MemRegionVal : public Loc {\npublic:\n  explicit MemRegionVal(const MemRegion* r) : Loc(MemRegionValKind, r) {\n    assert(r);\n  }\n\n  /// Get the underlining region.\n  const MemRegion *getRegion() const {\n    return static_cast<const MemRegion *>(Data);\n  }\n\n  /// Get the underlining region and strip casts.\n  const MemRegion* stripCasts(bool StripBaseCasts = true) const;\n\n  template <typename REGION>\n  const REGION* getRegionAs() const {\n    return dyn_cast<REGION>(getRegion());\n  }\n\n  bool operator==(const MemRegionVal &R) const {\n    return getRegion() == R.getRegion();\n  }\n\n  bool operator!=(const MemRegionVal &R) const {\n    return getRegion() != R.getRegion();\n  }\n\nprivate:\n  friend class SVal;\n\n  MemRegionVal() = default;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == LocKind &&\n           V.getSubKind() == MemRegionValKind;\n  }\n\n  static bool isKind(const Loc& V) {\n    return V.getSubKind() == MemRegionValKind;\n  }\n};\n\nclass ConcreteInt : public Loc {\npublic:\n  explicit ConcreteInt(const llvm::APSInt& V) : Loc(ConcreteIntKind, &V) {}\n\n  const llvm::APSInt &getValue() const {\n    return *static_cast<const llvm::APSInt *>(Data);\n  }\n\n  // Transfer functions for binary/unary operations on ConcreteInts.\n  SVal evalBinOp(BasicValueFactory& BasicVals, BinaryOperator::Opcode Op,\n                 const ConcreteInt& R) const;\n\nprivate:\n  friend class SVal;\n\n  ConcreteInt() = default;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == LocKind &&\n           V.getSubKind() == ConcreteIntKind;\n  }\n\n  static bool isKind(const Loc& V) {\n    return V.getSubKind() == ConcreteIntKind;\n  }\n};\n\n} // namespace loc\n\n} // namespace ento\n\n} // namespace clang\n\n#endif // LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_SVALS_H\n"}, "65": {"id": 65, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/Store.h", "content": "//===- Store.h - Interface for maps from Locations to Values ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defined the types Store and StoreManager.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_STORE_H\n#define LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_STORE_H\n\n#include \"clang/AST/Type.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState_Fwd.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SValBuilder.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SVals.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/StoreRef.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include <cassert>\n#include <cstdint>\n#include <memory>\n\nnamespace clang {\n\nclass ASTContext;\nclass CastExpr;\nclass CompoundLiteralExpr;\nclass CXXBasePath;\nclass Decl;\nclass Expr;\nclass LocationContext;\nclass ObjCIvarDecl;\nclass StackFrameContext;\n\nnamespace ento {\n\nclass CallEvent;\nclass ProgramStateManager;\nclass ScanReachableSymbols;\nclass SymbolReaper;\n\nusing InvalidatedSymbols = llvm::DenseSet<SymbolRef>;\n\nclass StoreManager {\nprotected:\n  SValBuilder &svalBuilder;\n  ProgramStateManager &StateMgr;\n\n  /// MRMgr - Manages region objects associated with this StoreManager.\n  MemRegionManager &MRMgr;\n  ASTContext &Ctx;\n\n  StoreManager(ProgramStateManager &stateMgr);\n\npublic:\n  virtual ~StoreManager() = default;\n\n  /// Return the value bound to specified location in a given state.\n  /// \\param[in] store The store in which to make the lookup.\n  /// \\param[in] loc The symbolic memory location.\n  /// \\param[in] T An optional type that provides a hint indicating the\n  ///   expected type of the returned value.  This is used if the value is\n  ///   lazily computed.\n  /// \\return The value bound to the location \\c loc.\n  virtual SVal getBinding(Store store, Loc loc, QualType T = QualType()) = 0;\n\n  /// Return the default value bound to a region in a given store. The default\n  /// binding is the value of sub-regions that were not initialized separately\n  /// from their base region. For example, if the structure is zero-initialized\n  /// upon construction, this method retrieves the concrete zero value, even if\n  /// some or all fields were later overwritten manually. Default binding may be\n  /// an unknown, undefined, concrete, or symbolic value.\n  /// \\param[in] store The store in which to make the lookup.\n  /// \\param[in] R The region to find the default binding for.\n  /// \\return The default value bound to the region in the store, if a default\n  /// binding exists.\n  virtual Optional<SVal> getDefaultBinding(Store store, const MemRegion *R) = 0;\n\n  /// Return the default value bound to a LazyCompoundVal. The default binding\n  /// is used to represent the value of any fields or elements within the\n  /// structure represented by the LazyCompoundVal which were not initialized\n  /// explicitly separately from the whole structure. Default binding may be an\n  /// unknown, undefined, concrete, or symbolic value.\n  /// \\param[in] lcv The lazy compound value.\n  /// \\return The default value bound to the LazyCompoundVal \\c lcv, if a\n  /// default binding exists.\n  Optional<SVal> getDefaultBinding(nonloc::LazyCompoundVal lcv) {\n    return getDefaultBinding(lcv.getStore(), lcv.getRegion());\n  }\n\n  /// Return a store with the specified value bound to the given location.\n  /// \\param[in] store The store in which to make the binding.\n  /// \\param[in] loc The symbolic memory location.\n  /// \\param[in] val The value to bind to location \\c loc.\n  /// \\return A StoreRef object that contains the same\n  ///   bindings as \\c store with the addition of having the value specified\n  ///   by \\c val bound to the location given for \\c loc.\n  virtual StoreRef Bind(Store store, Loc loc, SVal val) = 0;\n\n  /// Return a store with the specified value bound to all sub-regions of the\n  /// region. The region must not have previous bindings. If you need to\n  /// invalidate existing bindings, consider invalidateRegions().\n  virtual StoreRef BindDefaultInitial(Store store, const MemRegion *R,\n                                      SVal V) = 0;\n\n  /// Return a store with in which all values within the given region are\n  /// reset to zero. This method is allowed to overwrite previous bindings.\n  virtual StoreRef BindDefaultZero(Store store, const MemRegion *R) = 0;\n\n  /// Create a new store with the specified binding removed.\n  /// \\param ST the original store, that is the basis for the new store.\n  /// \\param L the location whose binding should be removed.\n  virtual StoreRef killBinding(Store ST, Loc L) = 0;\n\n  /// getInitialStore - Returns the initial \"empty\" store representing the\n  ///  value bindings upon entry to an analyzed function.\n  virtual StoreRef getInitialStore(const LocationContext *InitLoc) = 0;\n\n  /// getRegionManager - Returns the internal RegionManager object that is\n  ///  used to query and manipulate MemRegion objects.\n  MemRegionManager& getRegionManager() { return MRMgr; }\n\n  SValBuilder& getSValBuilder() { return svalBuilder; }\n\n  virtual Loc getLValueVar(const VarDecl *VD, const LocationContext *LC) {\n    return svalBuilder.makeLoc(MRMgr.getVarRegion(VD, LC));\n  }\n\n  Loc getLValueCompoundLiteral(const CompoundLiteralExpr *CL,\n                               const LocationContext *LC) {\n    return loc::MemRegionVal(MRMgr.getCompoundLiteralRegion(CL, LC));\n  }\n\n  virtual SVal getLValueIvar(const ObjCIvarDecl *decl, SVal base);\n\n  virtual SVal getLValueField(const FieldDecl *D, SVal Base) {\n    return getLValueFieldOrIvar(D, Base);\n  }\n\n  virtual SVal getLValueElement(QualType elementType, NonLoc offset, SVal Base);\n\n  /// ArrayToPointer - Used by ExprEngine::VistCast to handle implicit\n  ///  conversions between arrays and pointers.\n  virtual SVal ArrayToPointer(Loc Array, QualType ElementTy) = 0;\n\n  /// Evaluates a chain of derived-to-base casts through the path specified in\n  /// \\p Cast.\n  SVal evalDerivedToBase(SVal Derived, const CastExpr *Cast);\n\n  /// Evaluates a chain of derived-to-base casts through the specified path.\n  SVal evalDerivedToBase(SVal Derived, const CXXBasePath &CastPath);\n\n  /// Evaluates a derived-to-base cast through a single level of derivation.\n  SVal evalDerivedToBase(SVal Derived, QualType DerivedPtrType,\n                         bool IsVirtual);\n\n  /// Attempts to do a down cast. Used to model BaseToDerived and C++\n  ///        dynamic_cast.\n  /// The callback may result in the following 3 scenarios:\n  ///  - Successful cast (ex: derived is subclass of base).\n  ///  - Failed cast (ex: derived is definitely not a subclass of base).\n  ///    The distinction of this case from the next one is necessary to model\n  ///    dynamic_cast.\n  ///  - We don't know (base is a symbolic region and we don't have\n  ///    enough info to determine if the cast will succeed at run time).\n  /// The function returns an SVal representing the derived class; it's\n  /// valid only if Failed flag is set to false.\n  SVal attemptDownCast(SVal Base, QualType DerivedPtrType, bool &Failed);\n\n  const ElementRegion *GetElementZeroRegion(const SubRegion *R, QualType T);\n\n  /// castRegion - Used by ExprEngine::VisitCast to handle casts from\n  ///  a MemRegion* to a specific location type.  'R' is the region being\n  ///  casted and 'CastToTy' the result type of the cast.\n  const MemRegion *castRegion(const MemRegion *region, QualType CastToTy);\n\n  virtual StoreRef removeDeadBindings(Store store, const StackFrameContext *LCtx,\n                                      SymbolReaper &SymReaper) = 0;\n\n  virtual bool includedInBindings(Store store,\n                                  const MemRegion *region) const = 0;\n\n  /// If the StoreManager supports it, increment the reference count of\n  /// the specified Store object.\n  virtual void incrementReferenceCount(Store store) {}\n\n  /// If the StoreManager supports it, decrement the reference count of\n  /// the specified Store object.  If the reference count hits 0, the memory\n  /// associated with the object is recycled.\n  virtual void decrementReferenceCount(Store store) {}\n\n  using InvalidatedRegions = SmallVector<const MemRegion *, 8>;\n\n  /// invalidateRegions - Clears out the specified regions from the store,\n  ///  marking their values as unknown. Depending on the store, this may also\n  ///  invalidate additional regions that may have changed based on accessing\n  ///  the given regions. Optionally, invalidates non-static globals as well.\n  /// \\param[in] store The initial store\n  /// \\param[in] Values The values to invalidate.\n  /// \\param[in] E The current statement being evaluated. Used to conjure\n  ///   symbols to mark the values of invalidated regions.\n  /// \\param[in] Count The current block count. Used to conjure\n  ///   symbols to mark the values of invalidated regions.\n  /// \\param[in] Call The call expression which will be used to determine which\n  ///   globals should get invalidated.\n  /// \\param[in,out] IS A set to fill with any symbols that are no longer\n  ///   accessible. Pass \\c NULL if this information will not be used.\n  /// \\param[in] ITraits Information about invalidation for a particular\n  ///   region/symbol.\n  /// \\param[in,out] InvalidatedTopLevel A vector to fill with regions\n  ////  explicitly being invalidated. Pass \\c NULL if this\n  ///   information will not be used.\n  /// \\param[in,out] Invalidated A vector to fill with any regions being\n  ///   invalidated. This should include any regions explicitly invalidated\n  ///   even if they do not currently have bindings. Pass \\c NULL if this\n  ///   information will not be used.\n  virtual StoreRef invalidateRegions(Store store,\n                                  ArrayRef<SVal> Values,\n                                  const Expr *E, unsigned Count,\n                                  const LocationContext *LCtx,\n                                  const CallEvent *Call,\n                                  InvalidatedSymbols &IS,\n                                  RegionAndSymbolInvalidationTraits &ITraits,\n                                  InvalidatedRegions *InvalidatedTopLevel,\n                                  InvalidatedRegions *Invalidated) = 0;\n\n  /// enterStackFrame - Let the StoreManager to do something when execution\n  /// engine is about to execute into a callee.\n  StoreRef enterStackFrame(Store store,\n                           const CallEvent &Call,\n                           const StackFrameContext *CalleeCtx);\n\n  /// Finds the transitive closure of symbols within the given region.\n  ///\n  /// Returns false if the visitor aborted the scan.\n  virtual bool scanReachableSymbols(Store S, const MemRegion *R,\n                                    ScanReachableSymbols &Visitor) = 0;\n\n  virtual void printJson(raw_ostream &Out, Store S, const char *NL,\n                         unsigned int Space, bool IsDot) const = 0;\n\n  class BindingsHandler {\n  public:\n    virtual ~BindingsHandler();\n\n    /// \\return whether the iteration should continue.\n    virtual bool HandleBinding(StoreManager& SMgr, Store store,\n                               const MemRegion *region, SVal val) = 0;\n  };\n\n  class FindUniqueBinding : public BindingsHandler {\n    SymbolRef Sym;\n    const MemRegion* Binding = nullptr;\n    bool First = true;\n\n  public:\n    FindUniqueBinding(SymbolRef sym) : Sym(sym) {}\n\n    explicit operator bool() { return First && Binding; }\n\n    bool HandleBinding(StoreManager& SMgr, Store store, const MemRegion* R,\n                       SVal val) override;\n    const MemRegion *getRegion() { return Binding; }\n  };\n\n  /// iterBindings - Iterate over the bindings in the Store.\n  virtual void iterBindings(Store store, BindingsHandler& f) = 0;\n\nprotected:\n  const ElementRegion *MakeElementRegion(const SubRegion *baseRegion,\n                                         QualType pointeeTy,\n                                         uint64_t index = 0);\n\n  /// CastRetrievedVal - Used by subclasses of StoreManager to implement\n  ///  implicit casts that arise from loads from regions that are reinterpreted\n  ///  as another region.\n  SVal CastRetrievedVal(SVal val, const TypedValueRegion *region,\n                        QualType castTy);\n\nprivate:\n  SVal getLValueFieldOrIvar(const Decl *decl, SVal base);\n};\n\ninline StoreRef::StoreRef(Store store, StoreManager & smgr)\n    : store(store), mgr(smgr) {\n  if (store)\n    mgr.incrementReferenceCount(store);\n}\n\ninline StoreRef::StoreRef(const StoreRef &sr)\n    : store(sr.store), mgr(sr.mgr)\n{\n  if (store)\n    mgr.incrementReferenceCount(store);\n}\n\ninline StoreRef::~StoreRef() {\n  if (store)\n    mgr.decrementReferenceCount(store);\n}\n\ninline StoreRef &StoreRef::operator=(StoreRef const &newStore) {\n  assert(&newStore.mgr == &mgr);\n  if (store != newStore.store) {\n    mgr.incrementReferenceCount(newStore.store);\n    mgr.decrementReferenceCount(store);\n    store = newStore.getStore();\n  }\n  return *this;\n}\n\n// FIXME: Do we need to pass ProgramStateManager anymore?\nstd::unique_ptr<StoreManager>\nCreateRegionStoreManager(ProgramStateManager &StMgr);\nstd::unique_ptr<StoreManager>\nCreateFieldsOnlyRegionStoreManager(ProgramStateManager &StMgr);\n\n} // namespace ento\n\n} // namespace clang\n\n#endif // LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_STORE_H\n"}, "66": {"id": 66, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h", "content": "//===- SymbolManager.h - Management of Symbolic Values ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines SymbolManager, a class that manages symbolic values\n//  created for use by ExprEngine and related classes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_SYMBOLMANAGER_H\n#define LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_SYMBOLMANAGER_H\n\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Analysis/AnalysisDeclContext.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/StoreRef.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <cassert>\n\nnamespace clang {\n\nclass ASTContext;\nclass Stmt;\n\nnamespace ento {\n\nclass BasicValueFactory;\nclass StoreManager;\n\n///A symbol representing the value stored at a MemRegion.\nclass SymbolRegionValue : public SymbolData {\n  const TypedValueRegion *R;\n\npublic:\n  SymbolRegionValue(SymbolID sym, const TypedValueRegion *r)\n      : SymbolData(SymbolRegionValueKind, sym), R(r) {\n    assert(r);\n    assert(isValidTypeForSymbol(r->getValueType()));\n  }\n\n  const TypedValueRegion* getRegion() const { return R; }\n\n  static void Profile(llvm::FoldingSetNodeID& profile, const TypedValueRegion* R) {\n    profile.AddInteger((unsigned) SymbolRegionValueKind);\n    profile.AddPointer(R);\n  }\n\n  void Profile(llvm::FoldingSetNodeID& profile) override {\n    Profile(profile, R);\n  }\n\n  StringRef getKindStr() const override;\n\n  void dumpToStream(raw_ostream &os) const override;\n  const MemRegion *getOriginRegion() const override { return getRegion(); }\n\n  QualType getType() const override;\n\n  // Implement isa<T> support.\n  static bool classof(const SymExpr *SE) {\n    return SE->getKind() == SymbolRegionValueKind;\n  }\n};\n\n/// A symbol representing the result of an expression in the case when we do\n/// not know anything about what the expression is.\nclass SymbolConjured : public SymbolData {\n  const Stmt *S;\n  QualType T;\n  unsigned Count;\n  const LocationContext *LCtx;\n  const void *SymbolTag;\n\npublic:\n  SymbolConjured(SymbolID sym, const Stmt *s, const LocationContext *lctx,\n                 QualType t, unsigned count, const void *symbolTag)\n      : SymbolData(SymbolConjuredKind, sym), S(s), T(t), Count(count),\n        LCtx(lctx), SymbolTag(symbolTag) {\n    // FIXME: 's' might be a nullptr if we're conducting invalidation\n    // that was caused by a destructor call on a temporary object,\n    // which has no statement associated with it.\n    // Due to this, we might be creating the same invalidation symbol for\n    // two different invalidation passes (for two different temporaries).\n    assert(lctx);\n    assert(isValidTypeForSymbol(t));\n  }\n\n  const Stmt *getStmt() const { return S; }\n  unsigned getCount() const { return Count; }\n  const void *getTag() const { return SymbolTag; }\n\n  QualType getType() const override;\n\n  StringRef getKindStr() const override;\n\n  void dumpToStream(raw_ostream &os) const override;\n\n  static void Profile(llvm::FoldingSetNodeID& profile, const Stmt *S,\n                      QualType T, unsigned Count, const LocationContext *LCtx,\n                      const void *SymbolTag) {\n    profile.AddInteger((unsigned) SymbolConjuredKind);\n    profile.AddPointer(S);\n    profile.AddPointer(LCtx);\n    profile.Add(T);\n    profile.AddInteger(Count);\n    profile.AddPointer(SymbolTag);\n  }\n\n  void Profile(llvm::FoldingSetNodeID& profile) override {\n    Profile(profile, S, T, Count, LCtx, SymbolTag);\n  }\n\n  // Implement isa<T> support.\n  static bool classof(const SymExpr *SE) {\n    return SE->getKind() == SymbolConjuredKind;\n  }\n};\n\n/// A symbol representing the value of a MemRegion whose parent region has\n/// symbolic value.\nclass SymbolDerived : public SymbolData {\n  SymbolRef parentSymbol;\n  const TypedValueRegion *R;\n\npublic:\n  SymbolDerived(SymbolID sym, SymbolRef parent, const TypedValueRegion *r)\n      : SymbolData(SymbolDerivedKind, sym), parentSymbol(parent), R(r) {\n    assert(parent);\n    assert(r);\n    assert(isValidTypeForSymbol(r->getValueType()));\n  }\n\n  SymbolRef getParentSymbol() const { return parentSymbol; }\n  const TypedValueRegion *getRegion() const { return R; }\n\n  QualType getType() const override;\n\n  StringRef getKindStr() const override;\n\n  void dumpToStream(raw_ostream &os) const override;\n  const MemRegion *getOriginRegion() const override { return getRegion(); }\n\n  static void Profile(llvm::FoldingSetNodeID& profile, SymbolRef parent,\n                      const TypedValueRegion *r) {\n    profile.AddInteger((unsigned) SymbolDerivedKind);\n    profile.AddPointer(r);\n    profile.AddPointer(parent);\n  }\n\n  void Profile(llvm::FoldingSetNodeID& profile) override {\n    Profile(profile, parentSymbol, R);\n  }\n\n  // Implement isa<T> support.\n  static bool classof(const SymExpr *SE) {\n    return SE->getKind() == SymbolDerivedKind;\n  }\n};\n\n/// SymbolExtent - Represents the extent (size in bytes) of a bounded region.\n///  Clients should not ask the SymbolManager for a region's extent. Always use\n///  SubRegion::getExtent instead -- the value returned may not be a symbol.\nclass SymbolExtent : public SymbolData {\n  const SubRegion *R;\n\npublic:\n  SymbolExtent(SymbolID sym, const SubRegion *r)\n      : SymbolData(SymbolExtentKind, sym), R(r) {\n    assert(r);\n  }\n\n  const SubRegion *getRegion() const { return R; }\n\n  QualType getType() const override;\n\n  StringRef getKindStr() const override;\n\n  void dumpToStream(raw_ostream &os) const override;\n\n  static void Profile(llvm::FoldingSetNodeID& profile, const SubRegion *R) {\n    profile.AddInteger((unsigned) SymbolExtentKind);\n    profile.AddPointer(R);\n  }\n\n  void Profile(llvm::FoldingSetNodeID& profile) override {\n    Profile(profile, R);\n  }\n\n  // Implement isa<T> support.\n  static bool classof(const SymExpr *SE) {\n    return SE->getKind() == SymbolExtentKind;\n  }\n};\n\n/// SymbolMetadata - Represents path-dependent metadata about a specific region.\n///  Metadata symbols remain live as long as they are marked as in use before\n///  dead-symbol sweeping AND their associated regions are still alive.\n///  Intended for use by checkers.\nclass SymbolMetadata : public SymbolData {\n  const MemRegion* R;\n  const Stmt *S;\n  QualType T;\n  const LocationContext *LCtx;\n  unsigned Count;\n  const void *Tag;\n\npublic:\n  SymbolMetadata(SymbolID sym, const MemRegion* r, const Stmt *s, QualType t,\n                 const LocationContext *LCtx, unsigned count, const void *tag)\n      : SymbolData(SymbolMetadataKind, sym), R(r), S(s), T(t), LCtx(LCtx),\n        Count(count), Tag(tag) {\n      assert(r);\n      assert(s);\n      assert(isValidTypeForSymbol(t));\n      assert(LCtx);\n      assert(tag);\n    }\n\n  const MemRegion *getRegion() const { return R; }\n  const Stmt *getStmt() const { return S; }\n  const LocationContext *getLocationContext() const { return LCtx; }\n  unsigned getCount() const { return Count; }\n  const void *getTag() const { return Tag; }\n\n  QualType getType() const override;\n\n  StringRef getKindStr() const override;\n\n  void dumpToStream(raw_ostream &os) const override;\n\n  static void Profile(llvm::FoldingSetNodeID& profile, const MemRegion *R,\n                      const Stmt *S, QualType T, const LocationContext *LCtx,\n                      unsigned Count, const void *Tag) {\n    profile.AddInteger((unsigned) SymbolMetadataKind);\n    profile.AddPointer(R);\n    profile.AddPointer(S);\n    profile.Add(T);\n    profile.AddPointer(LCtx);\n    profile.AddInteger(Count);\n    profile.AddPointer(Tag);\n  }\n\n  void Profile(llvm::FoldingSetNodeID& profile) override {\n    Profile(profile, R, S, T, LCtx, Count, Tag);\n  }\n\n  // Implement isa<T> support.\n  static bool classof(const SymExpr *SE) {\n    return SE->getKind() == SymbolMetadataKind;\n  }\n};\n\n/// Represents a cast expression.\nclass SymbolCast : public SymExpr {\n  const SymExpr *Operand;\n\n  /// Type of the operand.\n  QualType FromTy;\n\n  /// The type of the result.\n  QualType ToTy;\n\npublic:\n  SymbolCast(const SymExpr *In, QualType From, QualType To)\n      : SymExpr(SymbolCastKind), Operand(In), FromTy(From), ToTy(To) {\n    assert(In);\n    assert(isValidTypeForSymbol(From));\n    // FIXME: GenericTaintChecker creates symbols of void type.\n    // Otherwise, 'To' should also be a valid type.\n  }\n\n  unsigned computeComplexity() const override {\n    if (Complexity == 0)\n      Complexity = 1 + Operand->computeComplexity();\n    return Complexity;\n  }\n\n  QualType getType() const override { return ToTy; }\n\n  const SymExpr *getOperand() const { return Operand; }\n\n  void dumpToStream(raw_ostream &os) const override;\n\n  static void Profile(llvm::FoldingSetNodeID& ID,\n                      const SymExpr *In, QualType From, QualType To) {\n    ID.AddInteger((unsigned) SymbolCastKind);\n    ID.AddPointer(In);\n    ID.Add(From);\n    ID.Add(To);\n  }\n\n  void Profile(llvm::FoldingSetNodeID& ID) override {\n    Profile(ID, Operand, FromTy, ToTy);\n  }\n\n  // Implement isa<T> support.\n  static bool classof(const SymExpr *SE) {\n    return SE->getKind() == SymbolCastKind;\n  }\n};\n\n/// Represents a symbolic expression involving a binary operator\nclass BinarySymExpr : public SymExpr {\n  BinaryOperator::Opcode Op;\n  QualType T;\n\nprotected:\n  BinarySymExpr(Kind k, BinaryOperator::Opcode op, QualType t)\n      : SymExpr(k), Op(op), T(t) {\n    assert(classof(this));\n    // Binary expressions are results of arithmetic. Pointer arithmetic is not\n    // handled by binary expressions, but it is instead handled by applying\n    // sub-regions to regions.\n    assert(isValidTypeForSymbol(t) && !Loc::isLocType(t));\n  }\n\npublic:\n  // FIXME: We probably need to make this out-of-line to avoid redundant\n  // generation of virtual functions.\n  QualType getType() const override { return T; }\n\n  BinaryOperator::Opcode getOpcode() const { return Op; }\n\n  // Implement isa<T> support.\n  static bool classof(const SymExpr *SE) {\n    Kind k = SE->getKind();\n    return k >= BEGIN_BINARYSYMEXPRS && k <= END_BINARYSYMEXPRS;\n  }\n\nprotected:\n  static unsigned computeOperandComplexity(const SymExpr *Value) {\n    return Value->computeComplexity();\n  }\n  static unsigned computeOperandComplexity(const llvm::APSInt &Value) {\n    return 1;\n  }\n\n  static const llvm::APSInt *getPointer(const llvm::APSInt &Value) {\n    return &Value;\n  }\n  static const SymExpr *getPointer(const SymExpr *Value) { return Value; }\n\n  static void dumpToStreamImpl(raw_ostream &os, const SymExpr *Value);\n  static void dumpToStreamImpl(raw_ostream &os, const llvm::APSInt &Value);\n  static void dumpToStreamImpl(raw_ostream &os, BinaryOperator::Opcode op);\n};\n\n/// Template implementation for all binary symbolic expressions\ntemplate <class LHSTYPE, class RHSTYPE, SymExpr::Kind ClassKind>\nclass BinarySymExprImpl : public BinarySymExpr {\n  LHSTYPE LHS;\n  RHSTYPE RHS;\n\npublic:\n  BinarySymExprImpl(LHSTYPE lhs, BinaryOperator::Opcode op, RHSTYPE rhs,\n                    QualType t)\n      : BinarySymExpr(ClassKind, op, t), LHS(lhs), RHS(rhs) {\n    assert(getPointer(lhs));\n    assert(getPointer(rhs));\n  }\n\n  void dumpToStream(raw_ostream &os) const override {\n    dumpToStreamImpl(os, LHS);\n    dumpToStreamImpl(os, getOpcode());\n    dumpToStreamImpl(os, RHS);\n  }\n\n  LHSTYPE getLHS() const { return LHS; }\n  RHSTYPE getRHS() const { return RHS; }\n\n  unsigned computeComplexity() const override {\n    if (Complexity == 0)\n      Complexity =\n          computeOperandComplexity(RHS) + computeOperandComplexity(LHS);\n    return Complexity;\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, LHSTYPE lhs,\n                      BinaryOperator::Opcode op, RHSTYPE rhs, QualType t) {\n    ID.AddInteger((unsigned)ClassKind);\n    ID.AddPointer(getPointer(lhs));\n    ID.AddInteger(op);\n    ID.AddPointer(getPointer(rhs));\n    ID.Add(t);\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) override {\n    Profile(ID, LHS, getOpcode(), RHS, getType());\n  }\n\n  // Implement isa<T> support.\n  static bool classof(const SymExpr *SE) { return SE->getKind() == ClassKind; }\n};\n\n/// Represents a symbolic expression like 'x' + 3.\nusing SymIntExpr = BinarySymExprImpl<const SymExpr *, const llvm::APSInt &,\n                                     SymExpr::Kind::SymIntExprKind>;\n\n/// Represents a symbolic expression like 3 - 'x'.\nusing IntSymExpr = BinarySymExprImpl<const llvm::APSInt &, const SymExpr *,\n                                     SymExpr::Kind::IntSymExprKind>;\n\n/// Represents a symbolic expression like 'x' + 'y'.\nusing SymSymExpr = BinarySymExprImpl<const SymExpr *, const SymExpr *,\n                                     SymExpr::Kind::SymSymExprKind>;\n\nclass SymbolManager {\n  using DataSetTy = llvm::FoldingSet<SymExpr>;\n  using SymbolDependTy =\n      llvm::DenseMap<SymbolRef, std::unique_ptr<SymbolRefSmallVectorTy>>;\n\n  DataSetTy DataSet;\n\n  /// Stores the extra dependencies between symbols: the data should be kept\n  /// alive as long as the key is live.\n  SymbolDependTy SymbolDependencies;\n\n  unsigned SymbolCounter = 0;\n  llvm::BumpPtrAllocator& BPAlloc;\n  BasicValueFactory &BV;\n  ASTContext &Ctx;\n\npublic:\n  SymbolManager(ASTContext &ctx, BasicValueFactory &bv,\n                llvm::BumpPtrAllocator& bpalloc)\n      : SymbolDependencies(16), BPAlloc(bpalloc), BV(bv), Ctx(ctx) {}\n\n  static bool canSymbolicate(QualType T);\n\n  /// Make a unique symbol for MemRegion R according to its kind.\n  const SymbolRegionValue* getRegionValueSymbol(const TypedValueRegion* R);\n\n  const SymbolConjured* conjureSymbol(const Stmt *E,\n                                      const LocationContext *LCtx,\n                                      QualType T,\n                                      unsigned VisitCount,\n                                      const void *SymbolTag = nullptr);\n\n  const SymbolConjured* conjureSymbol(const Expr *E,\n                                      const LocationContext *LCtx,\n                                      unsigned VisitCount,\n                                      const void *SymbolTag = nullptr) {\n    return conjureSymbol(E, LCtx, E->getType(), VisitCount, SymbolTag);\n  }\n\n  const SymbolDerived *getDerivedSymbol(SymbolRef parentSymbol,\n                                        const TypedValueRegion *R);\n\n  const SymbolExtent *getExtentSymbol(const SubRegion *R);\n\n  /// Creates a metadata symbol associated with a specific region.\n  ///\n  /// VisitCount can be used to differentiate regions corresponding to\n  /// different loop iterations, thus, making the symbol path-dependent.\n  const SymbolMetadata *getMetadataSymbol(const MemRegion *R, const Stmt *S,\n                                          QualType T,\n                                          const LocationContext *LCtx,\n                                          unsigned VisitCount,\n                                          const void *SymbolTag = nullptr);\n\n  const SymbolCast* getCastSymbol(const SymExpr *Operand,\n                                  QualType From, QualType To);\n\n  const SymIntExpr *getSymIntExpr(const SymExpr *lhs, BinaryOperator::Opcode op,\n                                  const llvm::APSInt& rhs, QualType t);\n\n  const SymIntExpr *getSymIntExpr(const SymExpr &lhs, BinaryOperator::Opcode op,\n                                  const llvm::APSInt& rhs, QualType t) {\n    return getSymIntExpr(&lhs, op, rhs, t);\n  }\n\n  const IntSymExpr *getIntSymExpr(const llvm::APSInt& lhs,\n                                  BinaryOperator::Opcode op,\n                                  const SymExpr *rhs, QualType t);\n\n  const SymSymExpr *getSymSymExpr(const SymExpr *lhs, BinaryOperator::Opcode op,\n                                  const SymExpr *rhs, QualType t);\n\n  QualType getType(const SymExpr *SE) const {\n    return SE->getType();\n  }\n\n  /// Add artificial symbol dependency.\n  ///\n  /// The dependent symbol should stay alive as long as the primary is alive.\n  void addSymbolDependency(const SymbolRef Primary, const SymbolRef Dependent);\n\n  const SymbolRefSmallVectorTy *getDependentSymbols(const SymbolRef Primary);\n\n  ASTContext &getContext() { return Ctx; }\n  BasicValueFactory &getBasicVals() { return BV; }\n};\n\n/// A class responsible for cleaning up unused symbols.\nclass SymbolReaper {\n  enum SymbolStatus {\n    NotProcessed,\n    HaveMarkedDependents\n  };\n\n  using SymbolSetTy = llvm::DenseSet<SymbolRef>;\n  using SymbolMapTy = llvm::DenseMap<SymbolRef, SymbolStatus>;\n  using RegionSetTy = llvm::DenseSet<const MemRegion *>;\n\n  SymbolMapTy TheLiving;\n  SymbolSetTy MetadataInUse;\n\n  RegionSetTy RegionRoots;\n\n  const StackFrameContext *LCtx;\n  const Stmt *Loc;\n  SymbolManager& SymMgr;\n  StoreRef reapedStore;\n  llvm::DenseMap<const MemRegion *, unsigned> includedRegionCache;\n\npublic:\n  /// Construct a reaper object, which removes everything which is not\n  /// live before we execute statement s in the given location context.\n  ///\n  /// If the statement is NULL, everything is this and parent contexts is\n  /// considered live.\n  /// If the stack frame context is NULL, everything on stack is considered\n  /// dead.\n  SymbolReaper(const StackFrameContext *Ctx, const Stmt *s,\n               SymbolManager &symmgr, StoreManager &storeMgr)\n      : LCtx(Ctx), Loc(s), SymMgr(symmgr), reapedStore(nullptr, storeMgr) {}\n\n  const LocationContext *getLocationContext() const { return LCtx; }\n\n  bool isLive(SymbolRef sym);\n  bool isLiveRegion(const MemRegion *region);\n  bool isLive(const Expr *ExprVal, const LocationContext *LCtx) const;\n  bool isLive(const VarRegion *VR, bool includeStoreBindings = false) const;\n\n  /// Unconditionally marks a symbol as live.\n  ///\n  /// This should never be\n  /// used by checkers, only by the state infrastructure such as the store and\n  /// environment. Checkers should instead use metadata symbols and markInUse.\n  void markLive(SymbolRef sym);\n\n  /// Marks a symbol as important to a checker.\n  ///\n  /// For metadata symbols,\n  /// this will keep the symbol alive as long as its associated region is also\n  /// live. For other symbols, this has no effect; checkers are not permitted\n  /// to influence the life of other symbols. This should be used before any\n  /// symbol marking has occurred, i.e. in the MarkLiveSymbols callback.\n  void markInUse(SymbolRef sym);\n\n  using region_iterator = RegionSetTy::const_iterator;\n\n  region_iterator region_begin() const { return RegionRoots.begin(); }\n  region_iterator region_end() const { return RegionRoots.end(); }\n\n  /// Returns whether or not a symbol has been confirmed dead.\n  ///\n  /// This should only be called once all marking of dead symbols has completed.\n  /// (For checkers, this means only in the checkDeadSymbols callback.)\n  bool isDead(SymbolRef sym) {\n    return !isLive(sym);\n  }\n\n  void markLive(const MemRegion *region);\n  void markElementIndicesLive(const MemRegion *region);\n\n  /// Set to the value of the symbolic store after\n  /// StoreManager::removeDeadBindings has been called.\n  void setReapedStore(StoreRef st) { reapedStore = st; }\n\nprivate:\n  /// Mark the symbols dependent on the input symbol as live.\n  void markDependentsLive(SymbolRef sym);\n};\n\nclass SymbolVisitor {\nprotected:\n  ~SymbolVisitor() = default;\n\npublic:\n  SymbolVisitor() = default;\n  SymbolVisitor(const SymbolVisitor &) = default;\n  SymbolVisitor(SymbolVisitor &&) {}\n\n  /// A visitor method invoked by ProgramStateManager::scanReachableSymbols.\n  ///\n  /// The method returns \\c true if symbols should continue be scanned and \\c\n  /// false otherwise.\n  virtual bool VisitSymbol(SymbolRef sym) = 0;\n  virtual bool VisitMemRegion(const MemRegion *) { return true; }\n};\n\n} // namespace ento\n\n} // namespace clang\n\n#endif // LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_SYMBOLMANAGER_H\n"}, "67": {"id": 67, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/WorkList.h", "content": "//==- WorkList.h - Worklist class used by CoreEngine ---------------*- C++ -*-//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines WorkList, a pure virtual class that represents an opaque\n//  worklist used by CoreEngine to explore the reachability state space.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_WORKLIST_H\n#define LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_WORKLIST_H\n\n#include \"clang/StaticAnalyzer/Core/PathSensitive/BlockCounter.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ExplodedGraph.h\"\n#include <cassert>\n\nnamespace clang {\n\nclass CFGBlock;\n\nnamespace ento {\n\nclass WorkListUnit {\n  ExplodedNode *node;\n  BlockCounter counter;\n  const CFGBlock *block;\n  unsigned blockIdx; // This is the index of the next statement.\n\npublic:\n  WorkListUnit(ExplodedNode *N, BlockCounter C,\n               const CFGBlock *B, unsigned idx)\n  : node(N),\n    counter(C),\n    block(B),\n    blockIdx(idx) {}\n\n  explicit WorkListUnit(ExplodedNode *N, BlockCounter C)\n  : node(N),\n    counter(C),\n    block(nullptr),\n    blockIdx(0) {}\n\n  /// Returns the node associated with the worklist unit.\n  ExplodedNode *getNode() const { return node; }\n\n  /// Returns the block counter map associated with the worklist unit.\n  BlockCounter getBlockCounter() const { return counter; }\n\n  /// Returns the CFGblock associated with the worklist unit.\n  const CFGBlock *getBlock() const { return block; }\n\n  /// Return the index within the CFGBlock for the worklist unit.\n  unsigned getIndex() const { return blockIdx; }\n};\n\nclass WorkList {\n  BlockCounter CurrentCounter;\npublic:\n  virtual ~WorkList();\n  virtual bool hasWork() const = 0;\n\n  virtual void enqueue(const WorkListUnit& U) = 0;\n\n  void enqueue(ExplodedNode *N, const CFGBlock *B, unsigned idx) {\n    enqueue(WorkListUnit(N, CurrentCounter, B, idx));\n  }\n\n  void enqueue(ExplodedNode *N) {\n    assert(N->getLocation().getKind() != ProgramPoint::PostStmtKind);\n    enqueue(WorkListUnit(N, CurrentCounter));\n  }\n\n  virtual WorkListUnit dequeue() = 0;\n\n  void setBlockCounter(BlockCounter C) { CurrentCounter = C; }\n  BlockCounter getBlockCounter() const { return CurrentCounter; }\n\n  static std::unique_ptr<WorkList> makeDFS();\n  static std::unique_ptr<WorkList> makeBFS();\n  static std::unique_ptr<WorkList> makeBFSBlockDFSContents();\n  static std::unique_ptr<WorkList> makeUnexploredFirst();\n  static std::unique_ptr<WorkList> makeUnexploredFirstPriorityQueue();\n  static std::unique_ptr<WorkList> makeUnexploredFirstPriorityLocationQueue();\n};\n\n} // end ento namespace\n\n} // end clang namespace\n\n#endif\n"}, "68": {"id": 68, "path": "/home/vsts/work/1/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp", "content": "// RetainCountDiagnostics.cpp - Checks for leaks and other issues -*- C++ -*--//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines diagnostics for RetainCountChecker, which implements\n//  a reference count checker for Core Foundation and Cocoa on (Mac OS X).\n//\n//===----------------------------------------------------------------------===//\n\n#include \"RetainCountDiagnostics.h\"\n#include \"RetainCountChecker.h\"\n\nusing namespace clang;\nusing namespace ento;\nusing namespace retaincountchecker;\n\nStringRef RefCountBug::bugTypeToName(RefCountBug::RefCountBugKind BT) {\n  switch (BT) {\n  case UseAfterRelease:\n    return \"Use-after-release\";\n  case ReleaseNotOwned:\n    return \"Bad release\";\n  case DeallocNotOwned:\n    return \"-dealloc sent to non-exclusively owned object\";\n  case FreeNotOwned:\n    return \"freeing non-exclusively owned object\";\n  case OverAutorelease:\n    return \"Object autoreleased too many times\";\n  case ReturnNotOwnedForOwned:\n    return \"Method should return an owned object\";\n  case LeakWithinFunction:\n    return \"Leak\";\n  case LeakAtReturn:\n    return \"Leak of returned object\";\n  }\n  llvm_unreachable(\"Unknown RefCountBugKind\");\n}\n\nStringRef RefCountBug::getDescription() const {\n  switch (BT) {\n  case UseAfterRelease:\n    return \"Reference-counted object is used after it is released\";\n  case ReleaseNotOwned:\n    return \"Incorrect decrement of the reference count of an object that is \"\n           \"not owned at this point by the caller\";\n  case DeallocNotOwned:\n    return \"-dealloc sent to object that may be referenced elsewhere\";\n  case FreeNotOwned:\n    return  \"'free' called on an object that may be referenced elsewhere\";\n  case OverAutorelease:\n    return \"Object autoreleased too many times\";\n  case ReturnNotOwnedForOwned:\n    return \"Object with a +0 retain count returned to caller where a +1 \"\n           \"(owning) retain count is expected\";\n  case LeakWithinFunction:\n  case LeakAtReturn:\n    return \"\";\n  }\n  llvm_unreachable(\"Unknown RefCountBugKind\");\n}\n\nRefCountBug::RefCountBug(CheckerNameRef Checker, RefCountBugKind BT)\n    : BugType(Checker, bugTypeToName(BT), categories::MemoryRefCount,\n              /*SuppressOnSink=*/BT == LeakWithinFunction ||\n                  BT == LeakAtReturn),\n      BT(BT) {}\n\nstatic bool isNumericLiteralExpression(const Expr *E) {\n  // FIXME: This set of cases was copied from SemaExprObjC.\n  return isa<IntegerLiteral>(E) ||\n         isa<CharacterLiteral>(E) ||\n         isa<FloatingLiteral>(E) ||\n         isa<ObjCBoolLiteralExpr>(E) ||\n         isa<CXXBoolLiteralExpr>(E);\n}\n\n/// If type represents a pointer to CXXRecordDecl,\n/// and is not a typedef, return the decl name.\n/// Otherwise, return the serialization of type.\nstatic std::string getPrettyTypeName(QualType QT) {\n  QualType PT = QT->getPointeeType();\n  if (!PT.isNull() && !QT->getAs<TypedefType>())\n    if (const auto *RD = PT->getAsCXXRecordDecl())\n      return std::string(RD->getName());\n  return QT.getAsString();\n}\n\n/// Write information about the type state change to {@code os},\n/// return whether the note should be generated.\nstatic bool shouldGenerateNote(llvm::raw_string_ostream &os,\n                               const RefVal *PrevT,\n                               const RefVal &CurrV,\n                               bool DeallocSent) {\n  // Get the previous type state.\n  RefVal PrevV = *PrevT;\n\n  // Specially handle -dealloc.\n  if (DeallocSent) {\n    // Determine if the object's reference count was pushed to zero.\n    assert(!PrevV.hasSameState(CurrV) && \"The state should have changed.\");\n    // We may not have transitioned to 'release' if we hit an error.\n    // This case is handled elsewhere.\n    if (CurrV.getKind() == RefVal::Released) {\n      assert(CurrV.getCombinedCounts() == 0);\n      os << \"Object released by directly sending the '-dealloc' message\";\n      return true;\n    }\n  }\n\n  // Determine if the typestate has changed.\n  if (!PrevV.hasSameState(CurrV))\n    switch (CurrV.getKind()) {\n    case RefVal::Owned:\n    case RefVal::NotOwned:\n      if (PrevV.getCount() == CurrV.getCount()) {\n        // Did an autorelease message get sent?\n        if (PrevV.getAutoreleaseCount() == CurrV.getAutoreleaseCount())\n          return false;\n\n        assert(PrevV.getAutoreleaseCount() < CurrV.getAutoreleaseCount());\n        os << \"Object autoreleased\";\n        return true;\n      }\n\n      if (PrevV.getCount() > CurrV.getCount())\n        os << \"Reference count decremented.\";\n      else\n        os << \"Reference count incremented.\";\n\n      if (unsigned Count = CurrV.getCount())\n        os << \" The object now has a +\" << Count << \" retain count.\";\n\n      return true;\n\n    case RefVal::Released:\n      if (CurrV.getIvarAccessHistory() ==\n              RefVal::IvarAccessHistory::ReleasedAfterDirectAccess &&\n          CurrV.getIvarAccessHistory() != PrevV.getIvarAccessHistory()) {\n        os << \"Strong instance variable relinquished. \";\n      }\n      os << \"Object released.\";\n      return true;\n\n    case RefVal::ReturnedOwned:\n      // Autoreleases can be applied after marking a node ReturnedOwned.\n      if (CurrV.getAutoreleaseCount())\n        return false;\n\n      os << \"Object returned to caller as an owning reference (single \"\n            \"retain count transferred to caller)\";\n      return true;\n\n    case RefVal::ReturnedNotOwned:\n      os << \"Object returned to caller with a +0 retain count\";\n      return true;\n\n    default:\n      return false;\n    }\n  return true;\n}\n\n/// Finds argument index of the out paramter in the call {@code S}\n/// corresponding to the symbol {@code Sym}.\n/// If none found, returns None.\nstatic Optional<unsigned> findArgIdxOfSymbol(ProgramStateRef CurrSt,\n                                             const LocationContext *LCtx,\n                                             SymbolRef &Sym,\n                                             Optional<CallEventRef<>> CE) {\n  if (!CE)\n    return None;\n\n  for (unsigned Idx = 0; Idx < (*CE)->getNumArgs(); Idx++)\n    if (const MemRegion *MR = (*CE)->getArgSVal(Idx).getAsRegion())\n      if (const auto *TR = dyn_cast<TypedValueRegion>(MR))\n        if (CurrSt->getSVal(MR, TR->getValueType()).getAsSymbol() == Sym)\n          return Idx;\n\n  return None;\n}\n\nstatic Optional<std::string> findMetaClassAlloc(const Expr *Callee) {\n  if (const auto *ME = dyn_cast<MemberExpr>(Callee)) {\n    if (ME->getMemberDecl()->getNameAsString() != \"alloc\")\n      return None;\n    const Expr *This = ME->getBase()->IgnoreParenImpCasts();\n    if (const auto *DRE = dyn_cast<DeclRefExpr>(This)) {\n      const ValueDecl *VD = DRE->getDecl();\n      if (VD->getNameAsString() != \"metaClass\")\n        return None;\n\n      if (const auto *RD = dyn_cast<CXXRecordDecl>(VD->getDeclContext()))\n        return RD->getNameAsString();\n\n    }\n  }\n  return None;\n}\n\nstatic std::string findAllocatedObjectName(const Stmt *S, QualType QT) {\n  if (const auto *CE = dyn_cast<CallExpr>(S))\n    if (auto Out = findMetaClassAlloc(CE->getCallee()))\n      return *Out;\n  return getPrettyTypeName(QT);\n}\n\nstatic void generateDiagnosticsForCallLike(ProgramStateRef CurrSt,\n                                           const LocationContext *LCtx,\n                                           const RefVal &CurrV, SymbolRef &Sym,\n                                           const Stmt *S,\n                                           llvm::raw_string_ostream &os) {\n  CallEventManager &Mgr = CurrSt->getStateManager().getCallEventManager();\n  if (const CallExpr *CE = dyn_cast<CallExpr>(S)) {\n    // Get the name of the callee (if it is available)\n    // from the tracked SVal.\n    SVal X = CurrSt->getSValAsScalarOrLoc(CE->getCallee(), LCtx);\n    const FunctionDecl *FD = X.getAsFunctionDecl();\n\n    // If failed, try to get it from AST.\n    if (!FD)\n      FD = dyn_cast<FunctionDecl>(CE->getCalleeDecl());\n\n    if (const auto *MD = dyn_cast<CXXMethodDecl>(CE->getCalleeDecl())) {\n      os << \"Call to method '\" << MD->getQualifiedNameAsString() << '\\'';\n    } else if (FD) {\n      os << \"Call to function '\" << FD->getQualifiedNameAsString() << '\\'';\n    } else {\n      os << \"function call\";\n    }\n  } else if (isa<CXXNewExpr>(S)) {\n    os << \"Operator 'new'\";\n  } else {\n    assert(isa<ObjCMessageExpr>(S));\n    CallEventRef<ObjCMethodCall> Call =\n        Mgr.getObjCMethodCall(cast<ObjCMessageExpr>(S), CurrSt, LCtx);\n\n    switch (Call->getMessageKind()) {\n    case OCM_Message:\n      os << \"Method\";\n      break;\n    case OCM_PropertyAccess:\n      os << \"Property\";\n      break;\n    case OCM_Subscript:\n      os << \"Subscript\";\n      break;\n    }\n  }\n\n  Optional<CallEventRef<>> CE = Mgr.getCall(S, CurrSt, LCtx);\n  auto Idx = findArgIdxOfSymbol(CurrSt, LCtx, Sym, CE);\n\n  // If index is not found, we assume that the symbol was returned.\n  if (!Idx) {\n    os << \" returns \";\n  } else {\n    os << \" writes \";\n  }\n\n  if (CurrV.getObjKind() == ObjKind::CF) {\n    os << \"a Core Foundation object of type '\"\n       << Sym->getType().getAsString() << \"' with a \";\n  } else if (CurrV.getObjKind() == ObjKind::OS) {\n    os << \"an OSObject of type '\" << findAllocatedObjectName(S, Sym->getType())\n       << \"' with a \";\n  } else if (CurrV.getObjKind() == ObjKind::Generalized) {\n    os << \"an object of type '\" << Sym->getType().getAsString()\n       << \"' with a \";\n  } else {\n    assert(CurrV.getObjKind() == ObjKind::ObjC);\n    QualType T = Sym->getType();\n    if (!isa<ObjCObjectPointerType>(T)) {\n      os << \"an Objective-C object with a \";\n    } else {\n      const ObjCObjectPointerType *PT = cast<ObjCObjectPointerType>(T);\n      os << \"an instance of \" << PT->getPointeeType().getAsString()\n         << \" with a \";\n    }\n  }\n\n  if (CurrV.isOwned()) {\n    os << \"+1 retain count\";\n  } else {\n    assert(CurrV.isNotOwned());\n    os << \"+0 retain count\";\n  }\n\n  if (Idx) {\n    os << \" into an out parameter '\";\n    const ParmVarDecl *PVD = (*CE)->parameters()[*Idx];\n    PVD->getNameForDiagnostic(os, PVD->getASTContext().getPrintingPolicy(),\n                              /*Qualified=*/false);\n    os << \"'\";\n\n    QualType RT = (*CE)->getResultType();\n    if (!RT.isNull() && !RT->isVoidType()) {\n      SVal RV = (*CE)->getReturnValue();\n      if (CurrSt->isNull(RV).isConstrainedTrue()) {\n        os << \" (assuming the call returns zero)\";\n      } else if (CurrSt->isNonNull(RV).isConstrainedTrue()) {\n        os << \" (assuming the call returns non-zero)\";\n      }\n\n    }\n  }\n}\n\nnamespace clang {\nnamespace ento {\nnamespace retaincountchecker {\n\nclass RefCountReportVisitor : public BugReporterVisitor {\nprotected:\n  SymbolRef Sym;\n\npublic:\n  RefCountReportVisitor(SymbolRef sym) : Sym(sym) {}\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override {\n    static int x = 0;\n    ID.AddPointer(&x);\n    ID.AddPointer(Sym);\n  }\n\n  PathDiagnosticPieceRef VisitNode(const ExplodedNode *N,\n                                   BugReporterContext &BRC,\n                                   PathSensitiveBugReport &BR) override;\n\n  PathDiagnosticPieceRef getEndPath(BugReporterContext &BRC,\n                                    const ExplodedNode *N,\n                                    PathSensitiveBugReport &BR) override;\n};\n\nclass RefLeakReportVisitor : public RefCountReportVisitor {\npublic:\n  RefLeakReportVisitor(SymbolRef sym) : RefCountReportVisitor(sym) {}\n\n  PathDiagnosticPieceRef getEndPath(BugReporterContext &BRC,\n                                    const ExplodedNode *N,\n                                    PathSensitiveBugReport &BR) override;\n};\n\n} // end namespace retaincountchecker\n} // end namespace ento\n} // end namespace clang\n\n\n/// Find the first node with the parent stack frame.\nstatic const ExplodedNode *getCalleeNode(const ExplodedNode *Pred) {\n  const StackFrameContext *SC = Pred->getStackFrame();\n  if (SC->inTopFrame())\n    return nullptr;\n  const StackFrameContext *PC = SC->getParent()->getStackFrame();\n  if (!PC)\n    return nullptr;\n\n  const ExplodedNode *N = Pred;\n  while (N && N->getStackFrame() != PC) {\n    N = N->getFirstPred();\n  }\n  return N;\n}\n\n\n/// Insert a diagnostic piece at function exit\n/// if a function parameter is annotated as \"os_consumed\",\n/// but it does not actually consume the reference.\nstatic std::shared_ptr<PathDiagnosticEventPiece>\nannotateConsumedSummaryMismatch(const ExplodedNode *N,\n                                CallExitBegin &CallExitLoc,\n                                const SourceManager &SM,\n                                CallEventManager &CEMgr) {\n\n  const ExplodedNode *CN = getCalleeNode(N);\n  if (!CN)\n    return nullptr;\n\n  CallEventRef<> Call = CEMgr.getCaller(N->getStackFrame(), N->getState());\n\n  std::string sbuf;\n  llvm::raw_string_ostream os(sbuf);\n  ArrayRef<const ParmVarDecl *> Parameters = Call->parameters();\n  for (unsigned I=0; I < Call->getNumArgs() && I < Parameters.size(); ++I) {\n    const ParmVarDecl *PVD = Parameters[I];\n\n    if (!PVD->hasAttr<OSConsumedAttr>())\n      continue;\n\n    if (SymbolRef SR = Call->getArgSVal(I).getAsLocSymbol()) {\n      const RefVal *CountBeforeCall = getRefBinding(CN->getState(), SR);\n      const RefVal *CountAtExit = getRefBinding(N->getState(), SR);\n\n      if (!CountBeforeCall || !CountAtExit)\n        continue;\n\n      unsigned CountBefore = CountBeforeCall->getCount();\n      unsigned CountAfter = CountAtExit->getCount();\n\n      bool AsExpected = CountBefore > 0 && CountAfter == CountBefore - 1;\n      if (!AsExpected) {\n        os << \"Parameter '\";\n        PVD->getNameForDiagnostic(os, PVD->getASTContext().getPrintingPolicy(),\n                                  /*Qualified=*/false);\n        os << \"' is marked as consuming, but the function did not consume \"\n           << \"the reference\\n\";\n      }\n    }\n  }\n\n  if (os.str().empty())\n    return nullptr;\n\n  PathDiagnosticLocation L = PathDiagnosticLocation::create(CallExitLoc, SM);\n  return std::make_shared<PathDiagnosticEventPiece>(L, os.str());\n}\n\n/// Annotate the parameter at the analysis entry point.\nstatic std::shared_ptr<PathDiagnosticEventPiece>\nannotateStartParameter(const ExplodedNode *N, SymbolRef Sym,\n                       const SourceManager &SM) {\n  auto PP = N->getLocationAs<BlockEdge>();\n  if (!PP)\n    return nullptr;\n\n  const CFGBlock *Src = PP->getSrc();\n  const RefVal *CurrT = getRefBinding(N->getState(), Sym);\n\n  if (&Src->getParent()->getEntry() != Src || !CurrT ||\n      getRefBinding(N->getFirstPred()->getState(), Sym))\n    return nullptr;\n\n  const auto *VR = cast<VarRegion>(cast<SymbolRegionValue>(Sym)->getRegion());\n  const auto *PVD = cast<ParmVarDecl>(VR->getDecl());\n  PathDiagnosticLocation L = PathDiagnosticLocation(PVD, SM);\n\n  std::string s;\n  llvm::raw_string_ostream os(s);\n  os << \"Parameter '\" << PVD->getDeclName() << \"' starts at +\";\n  if (CurrT->getCount() == 1) {\n    os << \"1, as it is marked as consuming\";\n  } else {\n    assert(CurrT->getCount() == 0);\n    os << \"0\";\n  }\n  return std::make_shared<PathDiagnosticEventPiece>(L, os.str());\n}\n\nPathDiagnosticPieceRef\nRefCountReportVisitor::VisitNode(const ExplodedNode *N, BugReporterContext &BRC,\n                                 PathSensitiveBugReport &BR) {\n\n  const auto &BT = static_cast<const RefCountBug&>(BR.getBugType());\n\n  bool IsFreeUnowned = BT.getBugType() == RefCountBug::FreeNotOwned ||\n                       BT.getBugType() == RefCountBug::DeallocNotOwned;\n\n  const SourceManager &SM = BRC.getSourceManager();\n  CallEventManager &CEMgr = BRC.getStateManager().getCallEventManager();\n  if (auto CE = N->getLocationAs<CallExitBegin>())\n    if (auto PD = annotateConsumedSummaryMismatch(N, *CE, SM, CEMgr))\n      return PD;\n\n  if (auto PD = annotateStartParameter(N, Sym, SM))\n    return PD;\n\n  // FIXME: We will eventually need to handle non-statement-based events\n  // (__attribute__((cleanup))).\n  if (!N->getLocation().getAs<StmtPoint>())\n    return nullptr;\n\n  // Check if the type state has changed.\n  const ExplodedNode *PrevNode = N->getFirstPred();\n  ProgramStateRef PrevSt = PrevNode->getState();\n  ProgramStateRef CurrSt = N->getState();\n  const LocationContext *LCtx = N->getLocationContext();\n\n  const RefVal* CurrT = getRefBinding(CurrSt, Sym);\n  if (!CurrT)\n    return nullptr;\n\n  const RefVal &CurrV = *CurrT;\n  const RefVal *PrevT = getRefBinding(PrevSt, Sym);\n\n  // Create a string buffer to constain all the useful things we want\n  // to tell the user.\n  std::string sbuf;\n  llvm::raw_string_ostream os(sbuf);\n\n  if (PrevT && IsFreeUnowned && CurrV.isNotOwned() && PrevT->isOwned()) {\n    os << \"Object is now not exclusively owned\";\n    auto Pos = PathDiagnosticLocation::create(N->getLocation(), SM);\n    return std::make_shared<PathDiagnosticEventPiece>(Pos, os.str());\n  }\n\n  // This is the allocation site since the previous node had no bindings\n  // for this symbol.\n  if (!PrevT) {\n    const Stmt *S = N->getLocation().castAs<StmtPoint>().getStmt();\n\n    if (isa<ObjCIvarRefExpr>(S) &&\n        isSynthesizedAccessor(LCtx->getStackFrame())) {\n      S = LCtx->getStackFrame()->getCallSite();\n    }\n\n    if (isa<ObjCArrayLiteral>(S)) {\n      os << \"NSArray literal is an object with a +0 retain count\";\n    } else if (isa<ObjCDictionaryLiteral>(S)) {\n      os << \"NSDictionary literal is an object with a +0 retain count\";\n    } else if (const ObjCBoxedExpr *BL = dyn_cast<ObjCBoxedExpr>(S)) {\n      if (isNumericLiteralExpression(BL->getSubExpr()))\n        os << \"NSNumber literal is an object with a +0 retain count\";\n      else {\n        const ObjCInterfaceDecl *BoxClass = nullptr;\n        if (const ObjCMethodDecl *Method = BL->getBoxingMethod())\n          BoxClass = Method->getClassInterface();\n\n        // We should always be able to find the boxing class interface,\n        // but consider this future-proofing.\n        if (BoxClass) {\n          os << *BoxClass << \" b\";\n        } else {\n          os << \"B\";\n        }\n\n        os << \"oxed expression produces an object with a +0 retain count\";\n      }\n    } else if (isa<ObjCIvarRefExpr>(S)) {\n      os << \"Object loaded from instance variable\";\n    } else {\n      generateDiagnosticsForCallLike(CurrSt, LCtx, CurrV, Sym, S, os);\n    }\n\n    PathDiagnosticLocation Pos(S, SM, N->getLocationContext());\n    return std::make_shared<PathDiagnosticEventPiece>(Pos, os.str());\n  }\n\n  // Gather up the effects that were performed on the object at this\n  // program point\n  bool DeallocSent = false;\n\n  const ProgramPointTag *Tag = N->getLocation().getTag();\n\n  if (Tag == &RetainCountChecker::getCastFailTag()) {\n    os << \"Assuming dynamic cast returns null due to type mismatch\";\n  }\n\n  if (Tag == &RetainCountChecker::getDeallocSentTag()) {\n    // We only have summaries attached to nodes after evaluating CallExpr and\n    // ObjCMessageExprs.\n    const Stmt *S = N->getLocation().castAs<StmtPoint>().getStmt();\n\n    if (const CallExpr *CE = dyn_cast<CallExpr>(S)) {\n      // Iterate through the parameter expressions and see if the symbol\n      // was ever passed as an argument.\n      unsigned i = 0;\n\n      for (auto AI=CE->arg_begin(), AE=CE->arg_end(); AI!=AE; ++AI, ++i) {\n\n        // Retrieve the value of the argument.  Is it the symbol\n        // we are interested in?\n        if (CurrSt->getSValAsScalarOrLoc(*AI, LCtx).getAsLocSymbol() != Sym)\n          continue;\n\n        // We have an argument.  Get the effect!\n        DeallocSent = true;\n      }\n    } else if (const ObjCMessageExpr *ME = dyn_cast<ObjCMessageExpr>(S)) {\n      if (const Expr *receiver = ME->getInstanceReceiver()) {\n        if (CurrSt->getSValAsScalarOrLoc(receiver, LCtx)\n              .getAsLocSymbol() == Sym) {\n          // The symbol we are tracking is the receiver.\n          DeallocSent = true;\n        }\n      }\n    }\n  }\n\n  if (!shouldGenerateNote(os, PrevT, CurrV, DeallocSent))\n    return nullptr;\n\n  if (os.str().empty())\n    return nullptr; // We have nothing to say!\n\n  const Stmt *S = N->getLocation().castAs<StmtPoint>().getStmt();\n  PathDiagnosticLocation Pos(S, BRC.getSourceManager(),\n                                N->getLocationContext());\n  auto P = std::make_shared<PathDiagnosticEventPiece>(Pos, os.str());\n\n  // Add the range by scanning the children of the statement for any bindings\n  // to Sym.\n  for (const Stmt *Child : S->children())\n    if (const Expr *Exp = dyn_cast_or_null<Expr>(Child))\n      if (CurrSt->getSValAsScalarOrLoc(Exp, LCtx).getAsLocSymbol() == Sym) {\n        P->addRange(Exp->getSourceRange());\n        break;\n      }\n\n  return std::move(P);\n}\n\nstatic Optional<std::string> describeRegion(const MemRegion *MR) {\n  if (const auto *VR = dyn_cast_or_null<VarRegion>(MR))\n    return std::string(VR->getDecl()->getName());\n  // Once we support more storage locations for bindings,\n  // this would need to be improved.\n  return None;\n}\n\nnamespace {\n// Find the first node in the current function context that referred to the\n// tracked symbol and the memory location that value was stored to. Note, the\n// value is only reported if the allocation occurred in the same function as\n// the leak. The function can also return a location context, which should be\n// treated as interesting.\nstruct AllocationInfo {\n  const ExplodedNode* N;\n  const MemRegion *R;\n  const LocationContext *InterestingMethodContext;\n  AllocationInfo(const ExplodedNode *InN,\n                 const MemRegion *InR,\n                 const LocationContext *InInterestingMethodContext) :\n    N(InN), R(InR), InterestingMethodContext(InInterestingMethodContext) {}\n};\n} // end anonymous namespace\n\nstatic AllocationInfo GetAllocationSite(ProgramStateManager &StateMgr,\n                                        const ExplodedNode *N, SymbolRef Sym) {\n  const ExplodedNode *AllocationNode = N;\n  const ExplodedNode *AllocationNodeInCurrentOrParentContext = N;\n  const MemRegion *FirstBinding = nullptr;\n  const LocationContext *LeakContext = N->getLocationContext();\n\n  // The location context of the init method called on the leaked object, if\n  // available.\n  const LocationContext *InitMethodContext = nullptr;\n\n  while (N) {\n    ProgramStateRef St = N->getState();\n    const LocationContext *NContext = N->getLocationContext();\n\n    if (!getRefBinding(St, Sym))\n      break;\n\n    StoreManager::FindUniqueBinding FB(Sym);\n    StateMgr.iterBindings(St, FB);\n\n    if (FB) {\n      const MemRegion *R = FB.getRegion();\n      // Do not show local variables belonging to a function other than\n      // where the error is reported.\n      if (auto MR = dyn_cast<StackSpaceRegion>(R->getMemorySpace()))\n        if (MR->getStackFrame() == LeakContext->getStackFrame())\n          FirstBinding = R;\n    }\n\n    // AllocationNode is the last node in which the symbol was tracked.\n    AllocationNode = N;\n\n    // AllocationNodeInCurrentContext, is the last node in the current or\n    // parent context in which the symbol was tracked.\n    //\n    // Note that the allocation site might be in the parent context. For example,\n    // the case where an allocation happens in a block that captures a reference\n    // to it and that reference is overwritten/dropped by another call to\n    // the block.\n    if (NContext == LeakContext || NContext->isParentOf(LeakContext))\n      AllocationNodeInCurrentOrParentContext = N;\n\n    // Find the last init that was called on the given symbol and store the\n    // init method's location context.\n    if (!InitMethodContext)\n      if (auto CEP = N->getLocation().getAs<CallEnter>()) {\n        const Stmt *CE = CEP->getCallExpr();\n        if (const auto *ME = dyn_cast_or_null<ObjCMessageExpr>(CE)) {\n          const Stmt *RecExpr = ME->getInstanceReceiver();\n          if (RecExpr) {\n            SVal RecV = St->getSVal(RecExpr, NContext);\n            if (ME->getMethodFamily() == OMF_init && RecV.getAsSymbol() == Sym)\n              InitMethodContext = CEP->getCalleeContext();\n          }\n        }\n      }\n\n    N = N->getFirstPred();\n  }\n\n  // If we are reporting a leak of the object that was allocated with alloc,\n  // mark its init method as interesting.\n  const LocationContext *InterestingMethodContext = nullptr;\n  if (InitMethodContext) {\n    const ProgramPoint AllocPP = AllocationNode->getLocation();\n    if (Optional<StmtPoint> SP = AllocPP.getAs<StmtPoint>())\n      if (const ObjCMessageExpr *ME = SP->getStmtAs<ObjCMessageExpr>())\n        if (ME->getMethodFamily() == OMF_alloc)\n          InterestingMethodContext = InitMethodContext;\n  }\n\n  // If allocation happened in a function different from the leak node context,\n  // do not report the binding.\n  assert(N && \"Could not find allocation node\");\n\n  if (AllocationNodeInCurrentOrParentContext &&\n      AllocationNodeInCurrentOrParentContext->getLocationContext() !=\n      LeakContext)\n    FirstBinding = nullptr;\n\n  return AllocationInfo(AllocationNodeInCurrentOrParentContext, FirstBinding,\n                        InterestingMethodContext);\n}\n\nPathDiagnosticPieceRef\nRefCountReportVisitor::getEndPath(BugReporterContext &BRC,\n                                  const ExplodedNode *EndN,\n                                  PathSensitiveBugReport &BR) {\n  BR.markInteresting(Sym);\n  return BugReporterVisitor::getDefaultEndPath(BRC, EndN, BR);\n}\n\nPathDiagnosticPieceRef\nRefLeakReportVisitor::getEndPath(BugReporterContext &BRC,\n                                 const ExplodedNode *EndN,\n                                 PathSensitiveBugReport &BR) {\n\n  // Tell the BugReporterContext to report cases when the tracked symbol is\n  // assigned to different variables, etc.\n  BR.markInteresting(Sym);\n\n  // We are reporting a leak.  Walk up the graph to get to the first node where\n  // the symbol appeared, and also get the first VarDecl that tracked object\n  // is stored to.\n  AllocationInfo AllocI = GetAllocationSite(BRC.getStateManager(), EndN, Sym);\n\n  const MemRegion* FirstBinding = AllocI.R;\n  BR.markInteresting(AllocI.InterestingMethodContext);\n\n  PathDiagnosticLocation L = cast<RefLeakReport>(BR).getEndOfPath();\n\n  std::string sbuf;\n  llvm::raw_string_ostream os(sbuf);\n\n  os << \"Object leaked: \";\n\n  Optional<std::string> RegionDescription = describeRegion(FirstBinding);\n  if (RegionDescription) {\n    os << \"object allocated and stored into '\" << *RegionDescription << '\\'';\n  } else {\n    os << \"allocated object of type '\" << getPrettyTypeName(Sym->getType())\n       << \"'\";\n  }\n\n  // Get the retain count.\n  const RefVal* RV = getRefBinding(EndN->getState(), Sym);\n  assert(RV);\n\n  if (RV->getKind() == RefVal::ErrorLeakReturned) {\n    // FIXME: Per comments in rdar://6320065, \"create\" only applies to CF\n    // objects.  Only \"copy\", \"alloc\", \"retain\" and \"new\" transfer ownership\n    // to the caller for NS objects.\n    const Decl *D = &EndN->getCodeDecl();\n\n    os << (isa<ObjCMethodDecl>(D) ? \" is returned from a method \"\n                                  : \" is returned from a function \");\n\n    if (D->hasAttr<CFReturnsNotRetainedAttr>()) {\n      os << \"that is annotated as CF_RETURNS_NOT_RETAINED\";\n    } else if (D->hasAttr<NSReturnsNotRetainedAttr>()) {\n      os << \"that is annotated as NS_RETURNS_NOT_RETAINED\";\n    } else if (D->hasAttr<OSReturnsNotRetainedAttr>()) {\n      os << \"that is annotated as OS_RETURNS_NOT_RETAINED\";\n    } else {\n      if (const ObjCMethodDecl *MD = dyn_cast<ObjCMethodDecl>(D)) {\n        if (BRC.getASTContext().getLangOpts().ObjCAutoRefCount) {\n          os << \"managed by Automatic Reference Counting\";\n        } else {\n          os << \"whose name ('\" << MD->getSelector().getAsString()\n             << \"') does not start with \"\n                \"'copy', 'mutableCopy', 'alloc' or 'new'.\"\n                \"  This violates the naming convention rules\"\n                \" given in the Memory Management Guide for Cocoa\";\n        }\n      } else {\n        const FunctionDecl *FD = cast<FunctionDecl>(D);\n        ObjKind K = RV->getObjKind();\n        if (K == ObjKind::ObjC || K == ObjKind::CF) {\n          os << \"whose name ('\" << *FD\n             << \"') does not contain 'Copy' or 'Create'.  This violates the \"\n                \"naming\"\n                \" convention rules given in the Memory Management Guide for \"\n                \"Core\"\n                \" Foundation\";\n        } else if (RV->getObjKind() == ObjKind::OS) {\n          std::string FuncName = FD->getNameAsString();\n          os << \"whose name ('\" << FuncName\n            << \"') starts with '\" << StringRef(FuncName).substr(0, 3) << \"'\";\n        }\n      }\n    }\n  } else {\n    os << \" is not referenced later in this execution path and has a retain \"\n          \"count of +\" << RV->getCount();\n  }\n\n  return std::make_shared<PathDiagnosticEventPiece>(L, os.str());\n}\n\nRefCountReport::RefCountReport(const RefCountBug &D, const LangOptions &LOpts,\n                               ExplodedNode *n, SymbolRef sym, bool isLeak)\n    : PathSensitiveBugReport(D, D.getDescription(), n), Sym(sym),\n      isLeak(isLeak) {\n  if (!isLeak)\n    addVisitor(std::make_unique<RefCountReportVisitor>(sym));\n}\n\nRefCountReport::RefCountReport(const RefCountBug &D, const LangOptions &LOpts,\n                               ExplodedNode *n, SymbolRef sym,\n                               StringRef endText)\n    : PathSensitiveBugReport(D, D.getDescription(), endText, n) {\n\n  addVisitor(std::make_unique<RefCountReportVisitor>(sym));\n}\n\nvoid RefLeakReport::deriveParamLocation(CheckerContext &Ctx, SymbolRef sym) {\n  const SourceManager& SMgr = Ctx.getSourceManager();\n\n  if (!sym->getOriginRegion())\n    return;\n\n  auto *Region = dyn_cast<DeclRegion>(sym->getOriginRegion());\n  if (Region) {\n    const Decl *PDecl = Region->getDecl();\n    if (PDecl && isa<ParmVarDecl>(PDecl)) {\n      PathDiagnosticLocation ParamLocation =\n          PathDiagnosticLocation::create(PDecl, SMgr);\n      Location = ParamLocation;\n      UniqueingLocation = ParamLocation;\n      UniqueingDecl = Ctx.getLocationContext()->getDecl();\n    }\n  }\n}\n\nvoid RefLeakReport::deriveAllocLocation(CheckerContext &Ctx,\n                                          SymbolRef sym) {\n  // Most bug reports are cached at the location where they occurred.\n  // With leaks, we want to unique them by the location where they were\n  // allocated, and only report a single path.  To do this, we need to find\n  // the allocation site of a piece of tracked memory, which we do via a\n  // call to GetAllocationSite.  This will walk the ExplodedGraph backwards.\n  // Note that this is *not* the trimmed graph; we are guaranteed, however,\n  // that all ancestor nodes that represent the allocation site have the\n  // same SourceLocation.\n  const ExplodedNode *AllocNode = nullptr;\n\n  const SourceManager& SMgr = Ctx.getSourceManager();\n\n  AllocationInfo AllocI =\n      GetAllocationSite(Ctx.getStateManager(), getErrorNode(), sym);\n\n  AllocNode = AllocI.N;\n  AllocBinding = AllocI.R;\n  markInteresting(AllocI.InterestingMethodContext);\n\n  // Get the SourceLocation for the allocation site.\n  // FIXME: This will crash the analyzer if an allocation comes from an\n  // implicit call (ex: a destructor call).\n  // (Currently there are no such allocations in Cocoa, though.)\n  AllocStmt = AllocNode->getStmtForDiagnostics();\n\n  if (!AllocStmt) {\n    AllocBinding = nullptr;\n    return;\n  }\n\n  PathDiagnosticLocation AllocLocation =\n    PathDiagnosticLocation::createBegin(AllocStmt, SMgr,\n                                        AllocNode->getLocationContext());\n  Location = AllocLocation;\n\n  // Set uniqieing info, which will be used for unique the bug reports. The\n  // leaks should be uniqued on the allocation site.\n  UniqueingLocation = AllocLocation;\n  UniqueingDecl = AllocNode->getLocationContext()->getDecl();\n}\n\nvoid RefLeakReport::createDescription(CheckerContext &Ctx) {\n  assert(Location.isValid() && UniqueingDecl && UniqueingLocation.isValid());\n  Description.clear();\n  llvm::raw_string_ostream os(Description);\n  os << \"Potential leak of an object\";\n\n  Optional<std::string> RegionDescription = describeRegion(AllocBinding);\n  if (RegionDescription) {\n    os << \" stored into '\" << *RegionDescription << '\\'';\n  } else {\n\n    // If we can't figure out the name, just supply the type information.\n    os << \" of type '\" << getPrettyTypeName(Sym->getType()) << \"'\";\n  }\n}\n\nRefLeakReport::RefLeakReport(const RefCountBug &D, const LangOptions &LOpts,\n                             ExplodedNode *n, SymbolRef sym,\n                             CheckerContext &Ctx)\n    : RefCountReport(D, LOpts, n, sym, /*isLeak=*/true) {\n\n  deriveAllocLocation(Ctx, sym);\n  if (!AllocBinding)\n    deriveParamLocation(Ctx, sym);\n\n  createDescription(Ctx);\n\n  addVisitor(std::make_unique<RefLeakReportVisitor>(sym));\n}\n"}, "69": {"id": 69, "path": "/home/vsts/work/1/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.h", "content": "//== RetainCountDiagnostics.h - Checks for leaks and other issues -*- C++ -*--//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines diagnostics for RetainCountChecker, which implements\n//  a reference count checker for Core Foundation and Cocoa on (Mac OS X).\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LIB_STATICANALYZER_CHECKERS_RETAINCOUNTCHECKER_DIAGNOSTICS_H\n#define LLVM_CLANG_LIB_STATICANALYZER_CHECKERS_RETAINCOUNTCHECKER_DIAGNOSTICS_H\n\n#include \"clang/Analysis/PathDiagnostic.h\"\n#include \"clang/Analysis/RetainSummaryManager.h\"\n#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n#include \"clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h\"\n\nnamespace clang {\nnamespace ento {\nnamespace retaincountchecker {\n\nclass RefCountBug : public BugType {\npublic:\n  enum RefCountBugKind {\n    UseAfterRelease,\n    ReleaseNotOwned,\n    DeallocNotOwned,\n    FreeNotOwned,\n    OverAutorelease,\n    ReturnNotOwnedForOwned,\n    LeakWithinFunction,\n    LeakAtReturn,\n  };\n  RefCountBug(CheckerNameRef Checker, RefCountBugKind BT);\n  StringRef getDescription() const;\n\n  RefCountBugKind getBugType() const { return BT; }\n\nprivate:\n  RefCountBugKind BT;\n  static StringRef bugTypeToName(RefCountBugKind BT);\n};\n\nclass RefCountReport : public PathSensitiveBugReport {\nprotected:\n  SymbolRef Sym;\n  bool isLeak = false;\n\npublic:\n  RefCountReport(const RefCountBug &D, const LangOptions &LOpts,\n              ExplodedNode *n, SymbolRef sym,\n              bool isLeak=false);\n\n  RefCountReport(const RefCountBug &D, const LangOptions &LOpts,\n              ExplodedNode *n, SymbolRef sym,\n              StringRef endText);\n\n  ArrayRef<SourceRange> getRanges() const override {\n    if (!isLeak)\n      return PathSensitiveBugReport::getRanges();\n    return {};\n  }\n};\n\nclass RefLeakReport : public RefCountReport {\n  const MemRegion* AllocBinding;\n  const Stmt *AllocStmt;\n  PathDiagnosticLocation Location;\n\n  // Finds the function declaration where a leak warning for the parameter\n  // 'sym' should be raised.\n  void deriveParamLocation(CheckerContext &Ctx, SymbolRef sym);\n  // Finds the location where a leak warning for 'sym' should be raised.\n  void deriveAllocLocation(CheckerContext &Ctx, SymbolRef sym);\n  // Produces description of a leak warning which is printed on the console.\n  void createDescription(CheckerContext &Ctx);\n\npublic:\n  RefLeakReport(const RefCountBug &D, const LangOptions &LOpts, ExplodedNode *n,\n                SymbolRef sym, CheckerContext &Ctx);\n  PathDiagnosticLocation getLocation() const override {\n    assert(Location.isValid());\n    return Location;\n  }\n\n  PathDiagnosticLocation getEndOfPath() const {\n    return PathSensitiveBugReport::getLocation();\n  }\n};\n\n} // end namespace retaincountchecker\n} // end namespace ento\n} // end namespace clang\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 7, "file": 50, "line": 253}, "message": "'BasicBugReport' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h", "reportHash": "0987b6a2768985828df9a7aa0c7069fd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 50, "line": 291}, "message": "'PathSensitiveBugReport' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h", "reportHash": "85fe9721ce23503b333da55cf547022a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 50, "line": 657}, "message": "'PathSensitiveBugReporter' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h", "reportHash": "4e1053b3cf39c031a3a98666e2a19956", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 50, "line": 726}, "message": "'NoteTag' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h", "reportHash": "76edb89339639b7da242a55b1f2a2919", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 51, "line": 48}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 51, "line": 48}, "message": "'BugReporterVisitor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h", "reportHash": "2b863ad3e5af34d53fa99bff7804bd7b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 51, "line": 125}, "message": "'FindLastStoreBRVisitor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h", "reportHash": "1c9a88276a129905f20ee6b826aabbc0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 51, "line": 164}, "message": "'TrackConstraintBRVisitor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h", "reportHash": "4189bac443e8b3ccfacbbc56cd1e6fd7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 51, "line": 196}, "message": "'NilReceiverBRVisitor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h", "reportHash": "0d054546dcfdf557922f110d07be7e5a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 51, "line": 213}, "message": "'ConditionBRVisitor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h", "reportHash": "cfb96465c9fdad45e26d5bce6e1c8009", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 51, "line": 297}, "message": "'LikelyFalsePositiveSuppressionBRVisitor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h", "reportHash": "f132169aa4d93b633af43223579c35ca", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 51, "line": 323}, "message": "'UndefOrNullArgVisitor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h", "reportHash": "2c4a92c67498fe0ca3d7f8e48229e5c2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 51, "line": 341}, "message": "'SuppressInlineDefensiveChecksVisitor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h", "reportHash": "76f41dc6ef86eea2e27638c711c7cd79", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 51, "line": 373}, "message": "'FalsePositiveRefutationBRVisitor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h", "reportHash": "7a179c50b36fea0af6aac921a5892077", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 51, "line": 394}, "message": "'TagVisitor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h", "reportHash": "925a9ffa8a49aaf4f647de28e6010f8b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 52, "line": 69}, "message": "'BuiltinBug' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugType.h", "reportHash": "be972460f3876d5b44ba723942266c09", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 53, "line": 492}, "message": "'CheckerBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/Checker.h", "reportHash": "5276b94f16f4a937ab14f229356827aa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 54, "line": 61}, "message": "'LazyCompoundValData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/BasicValueFactory.h", "reportHash": "76c02451de5d805fa09428f9a0cafed0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 55, "line": 29}, "message": "'BlockCounter' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/BlockCounter.h", "reportHash": "a4675f63fce4e562435fff3bfb31f011", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 56, "line": 449}, "message": "'GetTypeFn' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h", "reportHash": "66d68ff1b0314f876505f14df6dd45ca", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 56, "line": 846}, "message": "'AnyCXXConstructorCall' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h", "reportHash": "92c2a3210e0d73d65a8a30809645faa0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 57, "line": 341}, "message": "'NodeBuilderWithSinks' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CoreEngine.h", "reportHash": "cffd93e0665627e579a5b076b07c2b10", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 57, "line": 430}, "message": "'BranchNodeBuilder' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CoreEngine.h", "reportHash": "b73ccab395d60f849932b6c00b7eafdf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 58, "line": 35}, "message": "'EnvironmentEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/Environment.h", "reportHash": "3c635ec560e745c6c874b69f19c93eac", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 59, "line": 83}, "message": "'NodeGroup' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExplodedGraph.h", "reportHash": "9adcb892451f345681384243fc5c64c5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 59, "line": 463}, "message": "'ExplodedNodeSet' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExplodedGraph.h", "reportHash": "c022ee0f7ad87f7cecb425ccad4a2814", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 60, "line": 100}, "message": "'EvalCallOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExprEngine.h", "reportHash": "2d7d5078a61b7e99db0ea2c20d64b1fd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 62, "line": 199}, "message": "'MemSpaceRegion' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h", "reportHash": "be72059a743becc0439bd6b787f0e7c0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 62, "line": 236}, "message": "'GlobalsSpaceRegion' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h", "reportHash": "a71e33db069db4dfebf23dbd51f5504b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 62, "line": 284}, "message": "'NonStaticGlobalSpaceRegion' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h", "reportHash": "5ce6d5defdf5876a961ef32fe46379be", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 62, "line": 381}, "message": "'StackSpaceRegion' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h", "reportHash": "d6a283a006686e217ca097668fc62dc4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 62, "line": 435}, "message": "'SubRegion' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h", "reportHash": "692b79e502634c2292aa00d4414e07b9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 62, "line": 498}, "message": "'TypedRegion' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h", "reportHash": "dfdabe8f6da50b0ee64ff4f50f0593c4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 62, "line": 522}, "message": "'TypedValueRegion' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h", "reportHash": "2bd3d03aafe5fbc29ebc26cf43d4efab", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 62, "line": 553}, "message": "'CodeTextRegion' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h", "reportHash": "a96ce13773397a6794b74dc746d98319", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 62, "line": 891}, "message": "'DeclRegion' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h", "reportHash": "9ba26408db096f1508ac869a024dba9f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 62, "line": 906}, "message": "'VarRegion' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h", "reportHash": "d5d5e7a84e4277ce881a530504468613", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 63, "line": 27}, "message": "'Range' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/RangedConstraintManager.h", "reportHash": "ae29ebb45ce3b117ed796ff1b4c236fb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 63, "line": 67}, "message": "'RangeSet' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/RangedConstraintManager.h", "reportHash": "923796c949c3b45c478ada758a72a0e9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 64, "line": 244}, "message": "'UnknownVal' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SVals.h", "reportHash": "4747d7a2d6614477e820c3fca0ba8367", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 64, "line": 343}, "message": "'SymbolVal' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SVals.h", "reportHash": "b3f6a88490e4481f67ba4c7c88702f0d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 64, "line": 519}, "message": "'PointerToMember' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SVals.h", "reportHash": "7d15da40a5a184a12ad8a563abf89863", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 64, "line": 569}, "message": "'GotoLabel' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SVals.h", "reportHash": "d0e9746dbed53f844e0e9b969648b3b2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 64, "line": 593}, "message": "'MemRegionVal' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SVals.h", "reportHash": "b13f4de4e93f26c874bff6fdfcd12396", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 65, "line": 260}, "message": "'FindUniqueBinding' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/Store.h", "reportHash": "fecfe5c56307565f08f8c19ac124ea16", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 66, "line": 41}, "message": "'SymbolRegionValue' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h", "reportHash": "9e73eb1674a016209cf001ae65221c54", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 66, "line": 77}, "message": "'SymbolConjured' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h", "reportHash": "957bc619baca30fbed4d865fa5a1b05e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 66, "line": 131}, "message": "'SymbolDerived' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h", "reportHash": "e8db6e16c9116703a5b8c3b36d52c616", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 66, "line": 173}, "message": "'SymbolExtent' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h", "reportHash": "1cff8d4b132aad9441092ede0cfc3e93", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 66, "line": 209}, "message": "'SymbolMetadata' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h", "reportHash": "871f9afcb6c07d07a5f61e8eda19f88e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 66, "line": 264}, "message": "'SymbolCast' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h", "reportHash": "e25715a9a56beb7cb65def3bcafdedc0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 66, "line": 313}, "message": "'BinarySymExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h", "reportHash": "ec61a4d45e77a423e1c94a5b414e7412", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 66, "line": 505}, "message": "'SymbolReaper' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h", "reportHash": "4ad7f199f780bbc78d93fe995a6e200a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 66, "line": 593}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 66, "line": 593}, "message": "'SymbolVisitor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h", "reportHash": "8029b6e624d22a4e3ac17030b4e89b25", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 67, "line": 27}, "message": "'WorkListUnit' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/WorkList.h", "reportHash": "305037bf20e9c4b7b316d8aeec14672f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 68, "line": 316}, "message": "'RefCountReportVisitor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.cpp", "reportHash": "40e20512951be2e3b3c45d2dfd873bcb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 69, "line": 27}, "message": "'RefCountBug' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.h", "reportHash": "36814eea682e7b6a074056c1566d956c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 69, "line": 49}, "message": "'RefCountReport' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.h", "reportHash": "e10af02110b2ad9b061a4d3f9d869c49", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 69, "line": 70}, "message": "'RefLeakReport' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountDiagnostics.h", "reportHash": "4e3fecb20df79fc85d8d6e481143b675", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
