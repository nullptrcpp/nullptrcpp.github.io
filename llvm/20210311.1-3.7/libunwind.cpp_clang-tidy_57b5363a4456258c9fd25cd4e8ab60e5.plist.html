<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/home/vsts/work/1/llvm-project/libunwind/include/libunwind.h", "content": "//===---------------------------- libunwind.h -----------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//\n// Compatible with libunwind API documented at:\n//   http://www.nongnu.org/libunwind/man/libunwind(3).html\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef __LIBUNWIND__\n#define __LIBUNWIND__\n\n#include <__libunwind_config.h>\n\n#include <stdint.h>\n#include <stddef.h>\n\n#ifdef __APPLE__\n  #if __clang__\n    #if __has_include(<Availability.h>)\n      #include <Availability.h>\n    #endif\n  #elif __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1050\n    #include <Availability.h>\n  #endif\n\n  #ifdef __arm__\n     #define LIBUNWIND_AVAIL __attribute__((unavailable))\n  #elif defined(__OSX_AVAILABLE_STARTING)\n    #define LIBUNWIND_AVAIL __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_5_0)\n  #else\n    #include <AvailabilityMacros.h>\n    #ifdef AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER\n      #define LIBUNWIND_AVAIL AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER\n    #else\n      #define LIBUNWIND_AVAIL __attribute__((unavailable))\n    #endif\n  #endif\n#else\n  #define LIBUNWIND_AVAIL\n#endif\n\n#if defined(_WIN32) && defined(__SEH__)\n  #define LIBUNWIND_CURSOR_ALIGNMENT_ATTR __attribute__((__aligned__(16)))\n#else\n  #define LIBUNWIND_CURSOR_ALIGNMENT_ATTR\n#endif\n\n/* error codes */\nenum {\n  UNW_ESUCCESS      = 0,     /* no error */\n  UNW_EUNSPEC       = -6540, /* unspecified (general) error */\n  UNW_ENOMEM        = -6541, /* out of memory */\n  UNW_EBADREG       = -6542, /* bad register number */\n  UNW_EREADONLYREG  = -6543, /* attempt to write read-only register */\n  UNW_ESTOPUNWIND   = -6544, /* stop unwinding */\n  UNW_EINVALIDIP    = -6545, /* invalid IP */\n  UNW_EBADFRAME     = -6546, /* bad frame */\n  UNW_EINVAL        = -6547, /* unsupported operation or bad value */\n  UNW_EBADVERSION   = -6548, /* unwind info has unsupported version */\n  UNW_ENOINFO       = -6549  /* no unwind info found */\n#if defined(_LIBUNWIND_TARGET_AARCH64) && !defined(_LIBUNWIND_IS_NATIVE_ONLY)\n  , UNW_ECROSSRASIGNING = -6550 /* cross unwind with return address signing */\n#endif\n};\n\nstruct unw_context_t {\n  uint64_t data[_LIBUNWIND_CONTEXT_SIZE];\n};\ntypedef struct unw_context_t unw_context_t;\n\nstruct unw_cursor_t {\n  uint64_t data[_LIBUNWIND_CURSOR_SIZE];\n} LIBUNWIND_CURSOR_ALIGNMENT_ATTR;\ntypedef struct unw_cursor_t unw_cursor_t;\n\ntypedef struct unw_addr_space *unw_addr_space_t;\n\ntypedef int unw_regnum_t;\ntypedef uintptr_t unw_word_t;\n#if defined(__arm__) && !defined(__ARM_DWARF_EH__)\ntypedef uint64_t unw_fpreg_t;\n#else\ntypedef double unw_fpreg_t;\n#endif\n\nstruct unw_proc_info_t {\n  unw_word_t  start_ip;         /* start address of function */\n  unw_word_t  end_ip;           /* address after end of function */\n  unw_word_t  lsda;             /* address of language specific data area, */\n                                /*  or zero if not used */\n  unw_word_t  handler;          /* personality routine, or zero if not used */\n  unw_word_t  gp;               /* not used */\n  unw_word_t  flags;            /* not used */\n  uint32_t    format;           /* compact unwind encoding, or zero if none */\n  uint32_t    unwind_info_size; /* size of DWARF unwind info, or zero if none */\n  unw_word_t  unwind_info;      /* address of DWARF unwind info, or zero */\n  unw_word_t  extra;            /* mach_header of mach-o image containing func */\n};\ntypedef struct unw_proc_info_t unw_proc_info_t;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern int unw_getcontext(unw_context_t *) LIBUNWIND_AVAIL;\nextern int unw_init_local(unw_cursor_t *, unw_context_t *) LIBUNWIND_AVAIL;\nextern int unw_step(unw_cursor_t *) LIBUNWIND_AVAIL;\nextern int unw_get_reg(unw_cursor_t *, unw_regnum_t, unw_word_t *) LIBUNWIND_AVAIL;\nextern int unw_get_fpreg(unw_cursor_t *, unw_regnum_t, unw_fpreg_t *) LIBUNWIND_AVAIL;\nextern int unw_set_reg(unw_cursor_t *, unw_regnum_t, unw_word_t) LIBUNWIND_AVAIL;\nextern int unw_set_fpreg(unw_cursor_t *, unw_regnum_t, unw_fpreg_t)  LIBUNWIND_AVAIL;\nextern int unw_resume(unw_cursor_t *) LIBUNWIND_AVAIL;\n\n#ifdef __arm__\n/* Save VFP registers in FSTMX format (instead of FSTMD). */\nextern void unw_save_vfp_as_X(unw_cursor_t *) LIBUNWIND_AVAIL;\n#endif\n\n\nextern const char *unw_regname(unw_cursor_t *, unw_regnum_t) LIBUNWIND_AVAIL;\nextern int unw_get_proc_info(unw_cursor_t *, unw_proc_info_t *) LIBUNWIND_AVAIL;\nextern int unw_is_fpreg(unw_cursor_t *, unw_regnum_t) LIBUNWIND_AVAIL;\nextern int unw_is_signal_frame(unw_cursor_t *) LIBUNWIND_AVAIL;\nextern int unw_get_proc_name(unw_cursor_t *, char *, size_t, unw_word_t *) LIBUNWIND_AVAIL;\n//extern int       unw_get_save_loc(unw_cursor_t*, int, unw_save_loc_t*);\n\nextern unw_addr_space_t unw_local_addr_space;\n\n#ifdef __cplusplus\n}\n#endif\n\n// architecture independent register numbers\nenum {\n  UNW_REG_IP = -1, // instruction pointer\n  UNW_REG_SP = -2, // stack pointer\n};\n\n// 32-bit x86 registers\nenum {\n  UNW_X86_EAX = 0,\n  UNW_X86_ECX = 1,\n  UNW_X86_EDX = 2,\n  UNW_X86_EBX = 3,\n  UNW_X86_EBP = 4,\n  UNW_X86_ESP = 5,\n  UNW_X86_ESI = 6,\n  UNW_X86_EDI = 7\n};\n\n// 64-bit x86_64 registers\nenum {\n  UNW_X86_64_RAX = 0,\n  UNW_X86_64_RDX = 1,\n  UNW_X86_64_RCX = 2,\n  UNW_X86_64_RBX = 3,\n  UNW_X86_64_RSI = 4,\n  UNW_X86_64_RDI = 5,\n  UNW_X86_64_RBP = 6,\n  UNW_X86_64_RSP = 7,\n  UNW_X86_64_R8  = 8,\n  UNW_X86_64_R9  = 9,\n  UNW_X86_64_R10 = 10,\n  UNW_X86_64_R11 = 11,\n  UNW_X86_64_R12 = 12,\n  UNW_X86_64_R13 = 13,\n  UNW_X86_64_R14 = 14,\n  UNW_X86_64_R15 = 15,\n  UNW_X86_64_RIP = 16,\n  UNW_X86_64_XMM0 = 17,\n  UNW_X86_64_XMM1 = 18,\n  UNW_X86_64_XMM2 = 19,\n  UNW_X86_64_XMM3 = 20,\n  UNW_X86_64_XMM4 = 21,\n  UNW_X86_64_XMM5 = 22,\n  UNW_X86_64_XMM6 = 23,\n  UNW_X86_64_XMM7 = 24,\n  UNW_X86_64_XMM8 = 25,\n  UNW_X86_64_XMM9 = 26,\n  UNW_X86_64_XMM10 = 27,\n  UNW_X86_64_XMM11 = 28,\n  UNW_X86_64_XMM12 = 29,\n  UNW_X86_64_XMM13 = 30,\n  UNW_X86_64_XMM14 = 31,\n  UNW_X86_64_XMM15 = 32,\n};\n\n\n// 32-bit ppc register numbers\nenum {\n  UNW_PPC_R0  = 0,\n  UNW_PPC_R1  = 1,\n  UNW_PPC_R2  = 2,\n  UNW_PPC_R3  = 3,\n  UNW_PPC_R4  = 4,\n  UNW_PPC_R5  = 5,\n  UNW_PPC_R6  = 6,\n  UNW_PPC_R7  = 7,\n  UNW_PPC_R8  = 8,\n  UNW_PPC_R9  = 9,\n  UNW_PPC_R10 = 10,\n  UNW_PPC_R11 = 11,\n  UNW_PPC_R12 = 12,\n  UNW_PPC_R13 = 13,\n  UNW_PPC_R14 = 14,\n  UNW_PPC_R15 = 15,\n  UNW_PPC_R16 = 16,\n  UNW_PPC_R17 = 17,\n  UNW_PPC_R18 = 18,\n  UNW_PPC_R19 = 19,\n  UNW_PPC_R20 = 20,\n  UNW_PPC_R21 = 21,\n  UNW_PPC_R22 = 22,\n  UNW_PPC_R23 = 23,\n  UNW_PPC_R24 = 24,\n  UNW_PPC_R25 = 25,\n  UNW_PPC_R26 = 26,\n  UNW_PPC_R27 = 27,\n  UNW_PPC_R28 = 28,\n  UNW_PPC_R29 = 29,\n  UNW_PPC_R30 = 30,\n  UNW_PPC_R31 = 31,\n  UNW_PPC_F0  = 32,\n  UNW_PPC_F1  = 33,\n  UNW_PPC_F2  = 34,\n  UNW_PPC_F3  = 35,\n  UNW_PPC_F4  = 36,\n  UNW_PPC_F5  = 37,\n  UNW_PPC_F6  = 38,\n  UNW_PPC_F7  = 39,\n  UNW_PPC_F8  = 40,\n  UNW_PPC_F9  = 41,\n  UNW_PPC_F10 = 42,\n  UNW_PPC_F11 = 43,\n  UNW_PPC_F12 = 44,\n  UNW_PPC_F13 = 45,\n  UNW_PPC_F14 = 46,\n  UNW_PPC_F15 = 47,\n  UNW_PPC_F16 = 48,\n  UNW_PPC_F17 = 49,\n  UNW_PPC_F18 = 50,\n  UNW_PPC_F19 = 51,\n  UNW_PPC_F20 = 52,\n  UNW_PPC_F21 = 53,\n  UNW_PPC_F22 = 54,\n  UNW_PPC_F23 = 55,\n  UNW_PPC_F24 = 56,\n  UNW_PPC_F25 = 57,\n  UNW_PPC_F26 = 58,\n  UNW_PPC_F27 = 59,\n  UNW_PPC_F28 = 60,\n  UNW_PPC_F29 = 61,\n  UNW_PPC_F30 = 62,\n  UNW_PPC_F31 = 63,\n  UNW_PPC_MQ  = 64,\n  UNW_PPC_LR  = 65,\n  UNW_PPC_CTR = 66,\n  UNW_PPC_AP  = 67,\n  UNW_PPC_CR0 = 68,\n  UNW_PPC_CR1 = 69,\n  UNW_PPC_CR2 = 70,\n  UNW_PPC_CR3 = 71,\n  UNW_PPC_CR4 = 72,\n  UNW_PPC_CR5 = 73,\n  UNW_PPC_CR6 = 74,\n  UNW_PPC_CR7 = 75,\n  UNW_PPC_XER = 76,\n  UNW_PPC_V0  = 77,\n  UNW_PPC_V1  = 78,\n  UNW_PPC_V2  = 79,\n  UNW_PPC_V3  = 80,\n  UNW_PPC_V4  = 81,\n  UNW_PPC_V5  = 82,\n  UNW_PPC_V6  = 83,\n  UNW_PPC_V7  = 84,\n  UNW_PPC_V8  = 85,\n  UNW_PPC_V9  = 86,\n  UNW_PPC_V10 = 87,\n  UNW_PPC_V11 = 88,\n  UNW_PPC_V12 = 89,\n  UNW_PPC_V13 = 90,\n  UNW_PPC_V14 = 91,\n  UNW_PPC_V15 = 92,\n  UNW_PPC_V16 = 93,\n  UNW_PPC_V17 = 94,\n  UNW_PPC_V18 = 95,\n  UNW_PPC_V19 = 96,\n  UNW_PPC_V20 = 97,\n  UNW_PPC_V21 = 98,\n  UNW_PPC_V22 = 99,\n  UNW_PPC_V23 = 100,\n  UNW_PPC_V24 = 101,\n  UNW_PPC_V25 = 102,\n  UNW_PPC_V26 = 103,\n  UNW_PPC_V27 = 104,\n  UNW_PPC_V28 = 105,\n  UNW_PPC_V29 = 106,\n  UNW_PPC_V30 = 107,\n  UNW_PPC_V31 = 108,\n  UNW_PPC_VRSAVE  = 109,\n  UNW_PPC_VSCR    = 110,\n  UNW_PPC_SPE_ACC = 111,\n  UNW_PPC_SPEFSCR = 112\n};\n\n// 64-bit ppc register numbers\nenum {\n  UNW_PPC64_R0      = 0,\n  UNW_PPC64_R1      = 1,\n  UNW_PPC64_R2      = 2,\n  UNW_PPC64_R3      = 3,\n  UNW_PPC64_R4      = 4,\n  UNW_PPC64_R5      = 5,\n  UNW_PPC64_R6      = 6,\n  UNW_PPC64_R7      = 7,\n  UNW_PPC64_R8      = 8,\n  UNW_PPC64_R9      = 9,\n  UNW_PPC64_R10     = 10,\n  UNW_PPC64_R11     = 11,\n  UNW_PPC64_R12     = 12,\n  UNW_PPC64_R13     = 13,\n  UNW_PPC64_R14     = 14,\n  UNW_PPC64_R15     = 15,\n  UNW_PPC64_R16     = 16,\n  UNW_PPC64_R17     = 17,\n  UNW_PPC64_R18     = 18,\n  UNW_PPC64_R19     = 19,\n  UNW_PPC64_R20     = 20,\n  UNW_PPC64_R21     = 21,\n  UNW_PPC64_R22     = 22,\n  UNW_PPC64_R23     = 23,\n  UNW_PPC64_R24     = 24,\n  UNW_PPC64_R25     = 25,\n  UNW_PPC64_R26     = 26,\n  UNW_PPC64_R27     = 27,\n  UNW_PPC64_R28     = 28,\n  UNW_PPC64_R29     = 29,\n  UNW_PPC64_R30     = 30,\n  UNW_PPC64_R31     = 31,\n  UNW_PPC64_F0      = 32,\n  UNW_PPC64_F1      = 33,\n  UNW_PPC64_F2      = 34,\n  UNW_PPC64_F3      = 35,\n  UNW_PPC64_F4      = 36,\n  UNW_PPC64_F5      = 37,\n  UNW_PPC64_F6      = 38,\n  UNW_PPC64_F7      = 39,\n  UNW_PPC64_F8      = 40,\n  UNW_PPC64_F9      = 41,\n  UNW_PPC64_F10     = 42,\n  UNW_PPC64_F11     = 43,\n  UNW_PPC64_F12     = 44,\n  UNW_PPC64_F13     = 45,\n  UNW_PPC64_F14     = 46,\n  UNW_PPC64_F15     = 47,\n  UNW_PPC64_F16     = 48,\n  UNW_PPC64_F17     = 49,\n  UNW_PPC64_F18     = 50,\n  UNW_PPC64_F19     = 51,\n  UNW_PPC64_F20     = 52,\n  UNW_PPC64_F21     = 53,\n  UNW_PPC64_F22     = 54,\n  UNW_PPC64_F23     = 55,\n  UNW_PPC64_F24     = 56,\n  UNW_PPC64_F25     = 57,\n  UNW_PPC64_F26     = 58,\n  UNW_PPC64_F27     = 59,\n  UNW_PPC64_F28     = 60,\n  UNW_PPC64_F29     = 61,\n  UNW_PPC64_F30     = 62,\n  UNW_PPC64_F31     = 63,\n  // 64: reserved\n  UNW_PPC64_LR      = 65,\n  UNW_PPC64_CTR     = 66,\n  // 67: reserved\n  UNW_PPC64_CR0     = 68,\n  UNW_PPC64_CR1     = 69,\n  UNW_PPC64_CR2     = 70,\n  UNW_PPC64_CR3     = 71,\n  UNW_PPC64_CR4     = 72,\n  UNW_PPC64_CR5     = 73,\n  UNW_PPC64_CR6     = 74,\n  UNW_PPC64_CR7     = 75,\n  UNW_PPC64_XER     = 76,\n  UNW_PPC64_V0      = 77,\n  UNW_PPC64_V1      = 78,\n  UNW_PPC64_V2      = 79,\n  UNW_PPC64_V3      = 80,\n  UNW_PPC64_V4      = 81,\n  UNW_PPC64_V5      = 82,\n  UNW_PPC64_V6      = 83,\n  UNW_PPC64_V7      = 84,\n  UNW_PPC64_V8      = 85,\n  UNW_PPC64_V9      = 86,\n  UNW_PPC64_V10     = 87,\n  UNW_PPC64_V11     = 88,\n  UNW_PPC64_V12     = 89,\n  UNW_PPC64_V13     = 90,\n  UNW_PPC64_V14     = 91,\n  UNW_PPC64_V15     = 92,\n  UNW_PPC64_V16     = 93,\n  UNW_PPC64_V17     = 94,\n  UNW_PPC64_V18     = 95,\n  UNW_PPC64_V19     = 96,\n  UNW_PPC64_V20     = 97,\n  UNW_PPC64_V21     = 98,\n  UNW_PPC64_V22     = 99,\n  UNW_PPC64_V23     = 100,\n  UNW_PPC64_V24     = 101,\n  UNW_PPC64_V25     = 102,\n  UNW_PPC64_V26     = 103,\n  UNW_PPC64_V27     = 104,\n  UNW_PPC64_V28     = 105,\n  UNW_PPC64_V29     = 106,\n  UNW_PPC64_V30     = 107,\n  UNW_PPC64_V31     = 108,\n  // 109, 111-113: OpenPOWER ELF V2 ABI: reserved\n  // Borrowing VRSAVE number from PPC32.\n  UNW_PPC64_VRSAVE  = 109,\n  UNW_PPC64_VSCR    = 110,\n  UNW_PPC64_TFHAR   = 114,\n  UNW_PPC64_TFIAR   = 115,\n  UNW_PPC64_TEXASR  = 116,\n  UNW_PPC64_VS0     = UNW_PPC64_F0,\n  UNW_PPC64_VS1     = UNW_PPC64_F1,\n  UNW_PPC64_VS2     = UNW_PPC64_F2,\n  UNW_PPC64_VS3     = UNW_PPC64_F3,\n  UNW_PPC64_VS4     = UNW_PPC64_F4,\n  UNW_PPC64_VS5     = UNW_PPC64_F5,\n  UNW_PPC64_VS6     = UNW_PPC64_F6,\n  UNW_PPC64_VS7     = UNW_PPC64_F7,\n  UNW_PPC64_VS8     = UNW_PPC64_F8,\n  UNW_PPC64_VS9     = UNW_PPC64_F9,\n  UNW_PPC64_VS10    = UNW_PPC64_F10,\n  UNW_PPC64_VS11    = UNW_PPC64_F11,\n  UNW_PPC64_VS12    = UNW_PPC64_F12,\n  UNW_PPC64_VS13    = UNW_PPC64_F13,\n  UNW_PPC64_VS14    = UNW_PPC64_F14,\n  UNW_PPC64_VS15    = UNW_PPC64_F15,\n  UNW_PPC64_VS16    = UNW_PPC64_F16,\n  UNW_PPC64_VS17    = UNW_PPC64_F17,\n  UNW_PPC64_VS18    = UNW_PPC64_F18,\n  UNW_PPC64_VS19    = UNW_PPC64_F19,\n  UNW_PPC64_VS20    = UNW_PPC64_F20,\n  UNW_PPC64_VS21    = UNW_PPC64_F21,\n  UNW_PPC64_VS22    = UNW_PPC64_F22,\n  UNW_PPC64_VS23    = UNW_PPC64_F23,\n  UNW_PPC64_VS24    = UNW_PPC64_F24,\n  UNW_PPC64_VS25    = UNW_PPC64_F25,\n  UNW_PPC64_VS26    = UNW_PPC64_F26,\n  UNW_PPC64_VS27    = UNW_PPC64_F27,\n  UNW_PPC64_VS28    = UNW_PPC64_F28,\n  UNW_PPC64_VS29    = UNW_PPC64_F29,\n  UNW_PPC64_VS30    = UNW_PPC64_F30,\n  UNW_PPC64_VS31    = UNW_PPC64_F31,\n  UNW_PPC64_VS32    = UNW_PPC64_V0,\n  UNW_PPC64_VS33    = UNW_PPC64_V1,\n  UNW_PPC64_VS34    = UNW_PPC64_V2,\n  UNW_PPC64_VS35    = UNW_PPC64_V3,\n  UNW_PPC64_VS36    = UNW_PPC64_V4,\n  UNW_PPC64_VS37    = UNW_PPC64_V5,\n  UNW_PPC64_VS38    = UNW_PPC64_V6,\n  UNW_PPC64_VS39    = UNW_PPC64_V7,\n  UNW_PPC64_VS40    = UNW_PPC64_V8,\n  UNW_PPC64_VS41    = UNW_PPC64_V9,\n  UNW_PPC64_VS42    = UNW_PPC64_V10,\n  UNW_PPC64_VS43    = UNW_PPC64_V11,\n  UNW_PPC64_VS44    = UNW_PPC64_V12,\n  UNW_PPC64_VS45    = UNW_PPC64_V13,\n  UNW_PPC64_VS46    = UNW_PPC64_V14,\n  UNW_PPC64_VS47    = UNW_PPC64_V15,\n  UNW_PPC64_VS48    = UNW_PPC64_V16,\n  UNW_PPC64_VS49    = UNW_PPC64_V17,\n  UNW_PPC64_VS50    = UNW_PPC64_V18,\n  UNW_PPC64_VS51    = UNW_PPC64_V19,\n  UNW_PPC64_VS52    = UNW_PPC64_V20,\n  UNW_PPC64_VS53    = UNW_PPC64_V21,\n  UNW_PPC64_VS54    = UNW_PPC64_V22,\n  UNW_PPC64_VS55    = UNW_PPC64_V23,\n  UNW_PPC64_VS56    = UNW_PPC64_V24,\n  UNW_PPC64_VS57    = UNW_PPC64_V25,\n  UNW_PPC64_VS58    = UNW_PPC64_V26,\n  UNW_PPC64_VS59    = UNW_PPC64_V27,\n  UNW_PPC64_VS60    = UNW_PPC64_V28,\n  UNW_PPC64_VS61    = UNW_PPC64_V29,\n  UNW_PPC64_VS62    = UNW_PPC64_V30,\n  UNW_PPC64_VS63    = UNW_PPC64_V31\n};\n\n// 64-bit ARM64 registers\nenum {\n  UNW_ARM64_X0 = 0,\n  UNW_ARM64_X1 = 1,\n  UNW_ARM64_X2 = 2,\n  UNW_ARM64_X3 = 3,\n  UNW_ARM64_X4 = 4,\n  UNW_ARM64_X5 = 5,\n  UNW_ARM64_X6 = 6,\n  UNW_ARM64_X7 = 7,\n  UNW_ARM64_X8 = 8,\n  UNW_ARM64_X9 = 9,\n  UNW_ARM64_X10 = 10,\n  UNW_ARM64_X11 = 11,\n  UNW_ARM64_X12 = 12,\n  UNW_ARM64_X13 = 13,\n  UNW_ARM64_X14 = 14,\n  UNW_ARM64_X15 = 15,\n  UNW_ARM64_X16 = 16,\n  UNW_ARM64_X17 = 17,\n  UNW_ARM64_X18 = 18,\n  UNW_ARM64_X19 = 19,\n  UNW_ARM64_X20 = 20,\n  UNW_ARM64_X21 = 21,\n  UNW_ARM64_X22 = 22,\n  UNW_ARM64_X23 = 23,\n  UNW_ARM64_X24 = 24,\n  UNW_ARM64_X25 = 25,\n  UNW_ARM64_X26 = 26,\n  UNW_ARM64_X27 = 27,\n  UNW_ARM64_X28 = 28,\n  UNW_ARM64_X29 = 29,\n  UNW_ARM64_FP = 29,\n  UNW_ARM64_X30 = 30,\n  UNW_ARM64_LR = 30,\n  UNW_ARM64_X31 = 31,\n  UNW_ARM64_SP = 31,\n  UNW_ARM64_PC = 32,\n  // reserved block\n  UNW_ARM64_RA_SIGN_STATE = 34,\n  // reserved block\n  UNW_ARM64_D0 = 64,\n  UNW_ARM64_D1 = 65,\n  UNW_ARM64_D2 = 66,\n  UNW_ARM64_D3 = 67,\n  UNW_ARM64_D4 = 68,\n  UNW_ARM64_D5 = 69,\n  UNW_ARM64_D6 = 70,\n  UNW_ARM64_D7 = 71,\n  UNW_ARM64_D8 = 72,\n  UNW_ARM64_D9 = 73,\n  UNW_ARM64_D10 = 74,\n  UNW_ARM64_D11 = 75,\n  UNW_ARM64_D12 = 76,\n  UNW_ARM64_D13 = 77,\n  UNW_ARM64_D14 = 78,\n  UNW_ARM64_D15 = 79,\n  UNW_ARM64_D16 = 80,\n  UNW_ARM64_D17 = 81,\n  UNW_ARM64_D18 = 82,\n  UNW_ARM64_D19 = 83,\n  UNW_ARM64_D20 = 84,\n  UNW_ARM64_D21 = 85,\n  UNW_ARM64_D22 = 86,\n  UNW_ARM64_D23 = 87,\n  UNW_ARM64_D24 = 88,\n  UNW_ARM64_D25 = 89,\n  UNW_ARM64_D26 = 90,\n  UNW_ARM64_D27 = 91,\n  UNW_ARM64_D28 = 92,\n  UNW_ARM64_D29 = 93,\n  UNW_ARM64_D30 = 94,\n  UNW_ARM64_D31 = 95,\n};\n\n// 32-bit ARM registers. Numbers match DWARF for ARM spec #3.1 Table 1.\n// Naming scheme uses recommendations given in Note 4 for VFP-v2 and VFP-v3.\n// In this scheme, even though the 64-bit floating point registers D0-D31\n// overlap physically with the 32-bit floating pointer registers S0-S31,\n// they are given a non-overlapping range of register numbers.\n//\n// Commented out ranges are not preserved during unwinding.\nenum {\n  UNW_ARM_R0  = 0,\n  UNW_ARM_R1  = 1,\n  UNW_ARM_R2  = 2,\n  UNW_ARM_R3  = 3,\n  UNW_ARM_R4  = 4,\n  UNW_ARM_R5  = 5,\n  UNW_ARM_R6  = 6,\n  UNW_ARM_R7  = 7,\n  UNW_ARM_R8  = 8,\n  UNW_ARM_R9  = 9,\n  UNW_ARM_R10 = 10,\n  UNW_ARM_R11 = 11,\n  UNW_ARM_R12 = 12,\n  UNW_ARM_SP  = 13,  // Logical alias for UNW_REG_SP\n  UNW_ARM_R13 = 13,\n  UNW_ARM_LR  = 14,\n  UNW_ARM_R14 = 14,\n  UNW_ARM_IP  = 15,  // Logical alias for UNW_REG_IP\n  UNW_ARM_R15 = 15,\n  // 16-63 -- OBSOLETE. Used in VFP1 to represent both S0-S31 and D0-D31.\n  UNW_ARM_S0  = 64,\n  UNW_ARM_S1  = 65,\n  UNW_ARM_S2  = 66,\n  UNW_ARM_S3  = 67,\n  UNW_ARM_S4  = 68,\n  UNW_ARM_S5  = 69,\n  UNW_ARM_S6  = 70,\n  UNW_ARM_S7  = 71,\n  UNW_ARM_S8  = 72,\n  UNW_ARM_S9  = 73,\n  UNW_ARM_S10 = 74,\n  UNW_ARM_S11 = 75,\n  UNW_ARM_S12 = 76,\n  UNW_ARM_S13 = 77,\n  UNW_ARM_S14 = 78,\n  UNW_ARM_S15 = 79,\n  UNW_ARM_S16 = 80,\n  UNW_ARM_S17 = 81,\n  UNW_ARM_S18 = 82,\n  UNW_ARM_S19 = 83,\n  UNW_ARM_S20 = 84,\n  UNW_ARM_S21 = 85,\n  UNW_ARM_S22 = 86,\n  UNW_ARM_S23 = 87,\n  UNW_ARM_S24 = 88,\n  UNW_ARM_S25 = 89,\n  UNW_ARM_S26 = 90,\n  UNW_ARM_S27 = 91,\n  UNW_ARM_S28 = 92,\n  UNW_ARM_S29 = 93,\n  UNW_ARM_S30 = 94,\n  UNW_ARM_S31 = 95,\n  //  96-103 -- OBSOLETE. F0-F7. Used by the FPA system. Superseded by VFP.\n  // 104-111 -- wCGR0-wCGR7, ACC0-ACC7 (Intel wireless MMX)\n  UNW_ARM_WR0 = 112,\n  UNW_ARM_WR1 = 113,\n  UNW_ARM_WR2 = 114,\n  UNW_ARM_WR3 = 115,\n  UNW_ARM_WR4 = 116,\n  UNW_ARM_WR5 = 117,\n  UNW_ARM_WR6 = 118,\n  UNW_ARM_WR7 = 119,\n  UNW_ARM_WR8 = 120,\n  UNW_ARM_WR9 = 121,\n  UNW_ARM_WR10 = 122,\n  UNW_ARM_WR11 = 123,\n  UNW_ARM_WR12 = 124,\n  UNW_ARM_WR13 = 125,\n  UNW_ARM_WR14 = 126,\n  UNW_ARM_WR15 = 127,\n  // 128-133 -- SPSR, SPSR_{FIQ|IRQ|ABT|UND|SVC}\n  // 134-143 -- Reserved\n  // 144-150 -- R8_USR-R14_USR\n  // 151-157 -- R8_FIQ-R14_FIQ\n  // 158-159 -- R13_IRQ-R14_IRQ\n  // 160-161 -- R13_ABT-R14_ABT\n  // 162-163 -- R13_UND-R14_UND\n  // 164-165 -- R13_SVC-R14_SVC\n  // 166-191 -- Reserved\n  UNW_ARM_WC0 = 192,\n  UNW_ARM_WC1 = 193,\n  UNW_ARM_WC2 = 194,\n  UNW_ARM_WC3 = 195,\n  // 196-199 -- wC4-wC7 (Intel wireless MMX control)\n  // 200-255 -- Reserved\n  UNW_ARM_D0  = 256,\n  UNW_ARM_D1  = 257,\n  UNW_ARM_D2  = 258,\n  UNW_ARM_D3  = 259,\n  UNW_ARM_D4  = 260,\n  UNW_ARM_D5  = 261,\n  UNW_ARM_D6  = 262,\n  UNW_ARM_D7  = 263,\n  UNW_ARM_D8  = 264,\n  UNW_ARM_D9  = 265,\n  UNW_ARM_D10 = 266,\n  UNW_ARM_D11 = 267,\n  UNW_ARM_D12 = 268,\n  UNW_ARM_D13 = 269,\n  UNW_ARM_D14 = 270,\n  UNW_ARM_D15 = 271,\n  UNW_ARM_D16 = 272,\n  UNW_ARM_D17 = 273,\n  UNW_ARM_D18 = 274,\n  UNW_ARM_D19 = 275,\n  UNW_ARM_D20 = 276,\n  UNW_ARM_D21 = 277,\n  UNW_ARM_D22 = 278,\n  UNW_ARM_D23 = 279,\n  UNW_ARM_D24 = 280,\n  UNW_ARM_D25 = 281,\n  UNW_ARM_D26 = 282,\n  UNW_ARM_D27 = 283,\n  UNW_ARM_D28 = 284,\n  UNW_ARM_D29 = 285,\n  UNW_ARM_D30 = 286,\n  UNW_ARM_D31 = 287,\n  // 288-319 -- Reserved for VFP/Neon\n  // 320-8191 -- Reserved\n  // 8192-16383 -- Unspecified vendor co-processor register.\n};\n\n// OpenRISC1000 register numbers\nenum {\n  UNW_OR1K_R0  = 0,\n  UNW_OR1K_R1  = 1,\n  UNW_OR1K_R2  = 2,\n  UNW_OR1K_R3  = 3,\n  UNW_OR1K_R4  = 4,\n  UNW_OR1K_R5  = 5,\n  UNW_OR1K_R6  = 6,\n  UNW_OR1K_R7  = 7,\n  UNW_OR1K_R8  = 8,\n  UNW_OR1K_R9  = 9,\n  UNW_OR1K_R10 = 10,\n  UNW_OR1K_R11 = 11,\n  UNW_OR1K_R12 = 12,\n  UNW_OR1K_R13 = 13,\n  UNW_OR1K_R14 = 14,\n  UNW_OR1K_R15 = 15,\n  UNW_OR1K_R16 = 16,\n  UNW_OR1K_R17 = 17,\n  UNW_OR1K_R18 = 18,\n  UNW_OR1K_R19 = 19,\n  UNW_OR1K_R20 = 20,\n  UNW_OR1K_R21 = 21,\n  UNW_OR1K_R22 = 22,\n  UNW_OR1K_R23 = 23,\n  UNW_OR1K_R24 = 24,\n  UNW_OR1K_R25 = 25,\n  UNW_OR1K_R26 = 26,\n  UNW_OR1K_R27 = 27,\n  UNW_OR1K_R28 = 28,\n  UNW_OR1K_R29 = 29,\n  UNW_OR1K_R30 = 30,\n  UNW_OR1K_R31 = 31,\n  UNW_OR1K_EPCR = 32,\n};\n\n// MIPS registers\nenum {\n  UNW_MIPS_R0  = 0,\n  UNW_MIPS_R1  = 1,\n  UNW_MIPS_R2  = 2,\n  UNW_MIPS_R3  = 3,\n  UNW_MIPS_R4  = 4,\n  UNW_MIPS_R5  = 5,\n  UNW_MIPS_R6  = 6,\n  UNW_MIPS_R7  = 7,\n  UNW_MIPS_R8  = 8,\n  UNW_MIPS_R9  = 9,\n  UNW_MIPS_R10 = 10,\n  UNW_MIPS_R11 = 11,\n  UNW_MIPS_R12 = 12,\n  UNW_MIPS_R13 = 13,\n  UNW_MIPS_R14 = 14,\n  UNW_MIPS_R15 = 15,\n  UNW_MIPS_R16 = 16,\n  UNW_MIPS_R17 = 17,\n  UNW_MIPS_R18 = 18,\n  UNW_MIPS_R19 = 19,\n  UNW_MIPS_R20 = 20,\n  UNW_MIPS_R21 = 21,\n  UNW_MIPS_R22 = 22,\n  UNW_MIPS_R23 = 23,\n  UNW_MIPS_R24 = 24,\n  UNW_MIPS_R25 = 25,\n  UNW_MIPS_R26 = 26,\n  UNW_MIPS_R27 = 27,\n  UNW_MIPS_R28 = 28,\n  UNW_MIPS_R29 = 29,\n  UNW_MIPS_R30 = 30,\n  UNW_MIPS_R31 = 31,\n  UNW_MIPS_F0  = 32,\n  UNW_MIPS_F1  = 33,\n  UNW_MIPS_F2  = 34,\n  UNW_MIPS_F3  = 35,\n  UNW_MIPS_F4  = 36,\n  UNW_MIPS_F5  = 37,\n  UNW_MIPS_F6  = 38,\n  UNW_MIPS_F7  = 39,\n  UNW_MIPS_F8  = 40,\n  UNW_MIPS_F9  = 41,\n  UNW_MIPS_F10 = 42,\n  UNW_MIPS_F11 = 43,\n  UNW_MIPS_F12 = 44,\n  UNW_MIPS_F13 = 45,\n  UNW_MIPS_F14 = 46,\n  UNW_MIPS_F15 = 47,\n  UNW_MIPS_F16 = 48,\n  UNW_MIPS_F17 = 49,\n  UNW_MIPS_F18 = 50,\n  UNW_MIPS_F19 = 51,\n  UNW_MIPS_F20 = 52,\n  UNW_MIPS_F21 = 53,\n  UNW_MIPS_F22 = 54,\n  UNW_MIPS_F23 = 55,\n  UNW_MIPS_F24 = 56,\n  UNW_MIPS_F25 = 57,\n  UNW_MIPS_F26 = 58,\n  UNW_MIPS_F27 = 59,\n  UNW_MIPS_F28 = 60,\n  UNW_MIPS_F29 = 61,\n  UNW_MIPS_F30 = 62,\n  UNW_MIPS_F31 = 63,\n  UNW_MIPS_HI = 64,\n  UNW_MIPS_LO = 65,\n};\n\n// SPARC registers\nenum {\n  UNW_SPARC_G0 = 0,\n  UNW_SPARC_G1 = 1,\n  UNW_SPARC_G2 = 2,\n  UNW_SPARC_G3 = 3,\n  UNW_SPARC_G4 = 4,\n  UNW_SPARC_G5 = 5,\n  UNW_SPARC_G6 = 6,\n  UNW_SPARC_G7 = 7,\n  UNW_SPARC_O0 = 8,\n  UNW_SPARC_O1 = 9,\n  UNW_SPARC_O2 = 10,\n  UNW_SPARC_O3 = 11,\n  UNW_SPARC_O4 = 12,\n  UNW_SPARC_O5 = 13,\n  UNW_SPARC_O6 = 14,\n  UNW_SPARC_O7 = 15,\n  UNW_SPARC_L0 = 16,\n  UNW_SPARC_L1 = 17,\n  UNW_SPARC_L2 = 18,\n  UNW_SPARC_L3 = 19,\n  UNW_SPARC_L4 = 20,\n  UNW_SPARC_L5 = 21,\n  UNW_SPARC_L6 = 22,\n  UNW_SPARC_L7 = 23,\n  UNW_SPARC_I0 = 24,\n  UNW_SPARC_I1 = 25,\n  UNW_SPARC_I2 = 26,\n  UNW_SPARC_I3 = 27,\n  UNW_SPARC_I4 = 28,\n  UNW_SPARC_I5 = 29,\n  UNW_SPARC_I6 = 30,\n  UNW_SPARC_I7 = 31,\n};\n\n// Hexagon register numbers\nenum {\n  UNW_HEXAGON_R0,\n  UNW_HEXAGON_R1,\n  UNW_HEXAGON_R2,\n  UNW_HEXAGON_R3,\n  UNW_HEXAGON_R4,\n  UNW_HEXAGON_R5,\n  UNW_HEXAGON_R6,\n  UNW_HEXAGON_R7,\n  UNW_HEXAGON_R8,\n  UNW_HEXAGON_R9,\n  UNW_HEXAGON_R10,\n  UNW_HEXAGON_R11,\n  UNW_HEXAGON_R12,\n  UNW_HEXAGON_R13,\n  UNW_HEXAGON_R14,\n  UNW_HEXAGON_R15,\n  UNW_HEXAGON_R16,\n  UNW_HEXAGON_R17,\n  UNW_HEXAGON_R18,\n  UNW_HEXAGON_R19,\n  UNW_HEXAGON_R20,\n  UNW_HEXAGON_R21,\n  UNW_HEXAGON_R22,\n  UNW_HEXAGON_R23,\n  UNW_HEXAGON_R24,\n  UNW_HEXAGON_R25,\n  UNW_HEXAGON_R26,\n  UNW_HEXAGON_R27,\n  UNW_HEXAGON_R28,\n  UNW_HEXAGON_R29,\n  UNW_HEXAGON_R30,\n  UNW_HEXAGON_R31,\n  UNW_HEXAGON_P3_0,\n  UNW_HEXAGON_PC,\n};\n\n// RISC-V registers. These match the DWARF register numbers defined by section\n// 4 of the RISC-V ELF psABI specification, which can be found at:\n//\n// https://github.com/riscv/riscv-elf-psabi-doc/blob/master/riscv-elf.md\nenum {\n  UNW_RISCV_X0  = 0,\n  UNW_RISCV_X1  = 1,\n  UNW_RISCV_X2  = 2,\n  UNW_RISCV_X3  = 3,\n  UNW_RISCV_X4  = 4,\n  UNW_RISCV_X5  = 5,\n  UNW_RISCV_X6  = 6,\n  UNW_RISCV_X7  = 7,\n  UNW_RISCV_X8  = 8,\n  UNW_RISCV_X9  = 9,\n  UNW_RISCV_X10 = 10,\n  UNW_RISCV_X11 = 11,\n  UNW_RISCV_X12 = 12,\n  UNW_RISCV_X13 = 13,\n  UNW_RISCV_X14 = 14,\n  UNW_RISCV_X15 = 15,\n  UNW_RISCV_X16 = 16,\n  UNW_RISCV_X17 = 17,\n  UNW_RISCV_X18 = 18,\n  UNW_RISCV_X19 = 19,\n  UNW_RISCV_X20 = 20,\n  UNW_RISCV_X21 = 21,\n  UNW_RISCV_X22 = 22,\n  UNW_RISCV_X23 = 23,\n  UNW_RISCV_X24 = 24,\n  UNW_RISCV_X25 = 25,\n  UNW_RISCV_X26 = 26,\n  UNW_RISCV_X27 = 27,\n  UNW_RISCV_X28 = 28,\n  UNW_RISCV_X29 = 29,\n  UNW_RISCV_X30 = 30,\n  UNW_RISCV_X31 = 31,\n  UNW_RISCV_F0  = 32,\n  UNW_RISCV_F1  = 33,\n  UNW_RISCV_F2  = 34,\n  UNW_RISCV_F3  = 35,\n  UNW_RISCV_F4  = 36,\n  UNW_RISCV_F5  = 37,\n  UNW_RISCV_F6  = 38,\n  UNW_RISCV_F7  = 39,\n  UNW_RISCV_F8  = 40,\n  UNW_RISCV_F9  = 41,\n  UNW_RISCV_F10 = 42,\n  UNW_RISCV_F11 = 43,\n  UNW_RISCV_F12 = 44,\n  UNW_RISCV_F13 = 45,\n  UNW_RISCV_F14 = 46,\n  UNW_RISCV_F15 = 47,\n  UNW_RISCV_F16 = 48,\n  UNW_RISCV_F17 = 49,\n  UNW_RISCV_F18 = 50,\n  UNW_RISCV_F19 = 51,\n  UNW_RISCV_F20 = 52,\n  UNW_RISCV_F21 = 53,\n  UNW_RISCV_F22 = 54,\n  UNW_RISCV_F23 = 55,\n  UNW_RISCV_F24 = 56,\n  UNW_RISCV_F25 = 57,\n  UNW_RISCV_F26 = 58,\n  UNW_RISCV_F27 = 59,\n  UNW_RISCV_F28 = 60,\n  UNW_RISCV_F29 = 61,\n  UNW_RISCV_F30 = 62,\n  UNW_RISCV_F31 = 63,\n};\n\n// VE register numbers\nenum {\n  UNW_VE_S0   = 0,\n  UNW_VE_S1   = 1,\n  UNW_VE_S2   = 2,\n  UNW_VE_S3   = 3,\n  UNW_VE_S4   = 4,\n  UNW_VE_S5   = 5,\n  UNW_VE_S6   = 6,\n  UNW_VE_S7   = 7,\n  UNW_VE_S8   = 8,\n  UNW_VE_S9   = 9,\n  UNW_VE_S10  = 10,\n  UNW_VE_S11  = 11,\n  UNW_VE_S12  = 12,\n  UNW_VE_S13  = 13,\n  UNW_VE_S14  = 14,\n  UNW_VE_S15  = 15,\n  UNW_VE_S16  = 16,\n  UNW_VE_S17  = 17,\n  UNW_VE_S18  = 18,\n  UNW_VE_S19  = 19,\n  UNW_VE_S20  = 20,\n  UNW_VE_S21  = 21,\n  UNW_VE_S22  = 22,\n  UNW_VE_S23  = 23,\n  UNW_VE_S24  = 24,\n  UNW_VE_S25  = 25,\n  UNW_VE_S26  = 26,\n  UNW_VE_S27  = 27,\n  UNW_VE_S28  = 28,\n  UNW_VE_S29  = 29,\n  UNW_VE_S30  = 30,\n  UNW_VE_S31  = 31,\n  UNW_VE_S32  = 32,\n  UNW_VE_S33  = 33,\n  UNW_VE_S34  = 34,\n  UNW_VE_S35  = 35,\n  UNW_VE_S36  = 36,\n  UNW_VE_S37  = 37,\n  UNW_VE_S38  = 38,\n  UNW_VE_S39  = 39,\n  UNW_VE_S40  = 40,\n  UNW_VE_S41  = 41,\n  UNW_VE_S42  = 42,\n  UNW_VE_S43  = 43,\n  UNW_VE_S44  = 44,\n  UNW_VE_S45  = 45,\n  UNW_VE_S46  = 46,\n  UNW_VE_S47  = 47,\n  UNW_VE_S48  = 48,\n  UNW_VE_S49  = 49,\n  UNW_VE_S50  = 50,\n  UNW_VE_S51  = 51,\n  UNW_VE_S52  = 52,\n  UNW_VE_S53  = 53,\n  UNW_VE_S54  = 54,\n  UNW_VE_S55  = 55,\n  UNW_VE_S56  = 56,\n  UNW_VE_S57  = 57,\n  UNW_VE_S58  = 58,\n  UNW_VE_S59  = 59,\n  UNW_VE_S60  = 60,\n  UNW_VE_S61  = 61,\n  UNW_VE_S62  = 62,\n  UNW_VE_S63  = 63,\n  UNW_VE_V0   = 64 + 0,\n  UNW_VE_V1   = 64 + 1,\n  UNW_VE_V2   = 64 + 2,\n  UNW_VE_V3   = 64 + 3,\n  UNW_VE_V4   = 64 + 4,\n  UNW_VE_V5   = 64 + 5,\n  UNW_VE_V6   = 64 + 6,\n  UNW_VE_V7   = 64 + 7,\n  UNW_VE_V8   = 64 + 8,\n  UNW_VE_V9   = 64 + 9,\n  UNW_VE_V10  = 64 + 10,\n  UNW_VE_V11  = 64 + 11,\n  UNW_VE_V12  = 64 + 12,\n  UNW_VE_V13  = 64 + 13,\n  UNW_VE_V14  = 64 + 14,\n  UNW_VE_V15  = 64 + 15,\n  UNW_VE_V16  = 64 + 16,\n  UNW_VE_V17  = 64 + 17,\n  UNW_VE_V18  = 64 + 18,\n  UNW_VE_V19  = 64 + 19,\n  UNW_VE_V20  = 64 + 20,\n  UNW_VE_V21  = 64 + 21,\n  UNW_VE_V22  = 64 + 22,\n  UNW_VE_V23  = 64 + 23,\n  UNW_VE_V24  = 64 + 24,\n  UNW_VE_V25  = 64 + 25,\n  UNW_VE_V26  = 64 + 26,\n  UNW_VE_V27  = 64 + 27,\n  UNW_VE_V28  = 64 + 28,\n  UNW_VE_V29  = 64 + 29,\n  UNW_VE_V30  = 64 + 30,\n  UNW_VE_V31  = 64 + 31,\n  UNW_VE_V32  = 64 + 32,\n  UNW_VE_V33  = 64 + 33,\n  UNW_VE_V34  = 64 + 34,\n  UNW_VE_V35  = 64 + 35,\n  UNW_VE_V36  = 64 + 36,\n  UNW_VE_V37  = 64 + 37,\n  UNW_VE_V38  = 64 + 38,\n  UNW_VE_V39  = 64 + 39,\n  UNW_VE_V40  = 64 + 40,\n  UNW_VE_V41  = 64 + 41,\n  UNW_VE_V42  = 64 + 42,\n  UNW_VE_V43  = 64 + 43,\n  UNW_VE_V44  = 64 + 44,\n  UNW_VE_V45  = 64 + 45,\n  UNW_VE_V46  = 64 + 46,\n  UNW_VE_V47  = 64 + 47,\n  UNW_VE_V48  = 64 + 48,\n  UNW_VE_V49  = 64 + 49,\n  UNW_VE_V50  = 64 + 50,\n  UNW_VE_V51  = 64 + 51,\n  UNW_VE_V52  = 64 + 52,\n  UNW_VE_V53  = 64 + 53,\n  UNW_VE_V54  = 64 + 54,\n  UNW_VE_V55  = 64 + 55,\n  UNW_VE_V56  = 64 + 56,\n  UNW_VE_V57  = 64 + 57,\n  UNW_VE_V58  = 64 + 58,\n  UNW_VE_V59  = 64 + 59,\n  UNW_VE_V60  = 64 + 60,\n  UNW_VE_V61  = 64 + 61,\n  UNW_VE_V62  = 64 + 62,\n  UNW_VE_V63  = 64 + 63,\n  UNW_VE_VM0  = 128 + 0,\n  UNW_VE_VM1  = 128 + 1,\n  UNW_VE_VM2  = 128 + 2,\n  UNW_VE_VM3  = 128 + 3,\n  UNW_VE_VM4  = 128 + 4,\n  UNW_VE_VM5  = 128 + 5,\n  UNW_VE_VM6  = 128 + 6,\n  UNW_VE_VM7  = 128 + 7,\n  UNW_VE_VM8  = 128 + 8,\n  UNW_VE_VM9  = 128 + 9,\n  UNW_VE_VM10 = 128 + 10,\n  UNW_VE_VM11 = 128 + 11,\n  UNW_VE_VM12 = 128 + 12,\n  UNW_VE_VM13 = 128 + 13,\n  UNW_VE_VM14 = 128 + 14,\n  UNW_VE_VM15 = 128 + 15, // = 143\n\n  // Following registers don't have DWARF register numbers.\n  UNW_VE_VIXR = 144,\n  UNW_VE_VL   = 145,\n};\n\n#endif\n"}, "1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/libunwind/src/AddressSpace.hpp", "content": "//===------------------------- AddressSpace.hpp ---------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//\n// Abstracts accessing local vs remote address spaces.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef __ADDRESSSPACE_HPP__\n#define __ADDRESSSPACE_HPP__\n\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"libunwind.h\"\n#include \"config.h\"\n#include \"dwarf2.h\"\n#include \"EHHeaderParser.hpp\"\n#include \"Registers.hpp\"\n\n#ifndef _LIBUNWIND_USE_DLADDR\n  #if !defined(_LIBUNWIND_IS_BAREMETAL) && !defined(_WIN32)\n    #define _LIBUNWIND_USE_DLADDR 1\n  #else\n    #define _LIBUNWIND_USE_DLADDR 0\n  #endif\n#endif\n\n#if _LIBUNWIND_USE_DLADDR\n#include <dlfcn.h>\n#if defined(__ELF__) && defined(_LIBUNWIND_LINK_DL_LIB)\n#pragma comment(lib, \"dl\")\n#endif\n#endif\n\n#if defined(_LIBUNWIND_ARM_EHABI)\nstruct EHABIIndexEntry {\n  uint32_t functionOffset;\n  uint32_t data;\n};\n#endif\n\n#ifdef __APPLE__\n\n  struct dyld_unwind_sections\n  {\n    const struct mach_header*   mh;\n    const void*                 dwarf_section;\n    uintptr_t                   dwarf_section_length;\n    const void*                 compact_unwind_section;\n    uintptr_t                   compact_unwind_section_length;\n  };\n\n  // In 10.7.0 or later, libSystem.dylib implements this function.\n  extern \"C\" bool _dyld_find_unwind_sections(void *, dyld_unwind_sections *);\n\n#elif defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND) && defined(_LIBUNWIND_IS_BAREMETAL)\n\n// When statically linked on bare-metal, the symbols for the EH table are looked\n// up without going through the dynamic loader.\n\n// The following linker script may be used to produce the necessary sections and symbols.\n// Unless the --eh-frame-hdr linker option is provided, the section is not generated\n// and does not take space in the output file.\n//\n//   .eh_frame :\n//   {\n//       __eh_frame_start = .;\n//       KEEP(*(.eh_frame))\n//       __eh_frame_end = .;\n//   }\n//\n//   .eh_frame_hdr :\n//   {\n//       KEEP(*(.eh_frame_hdr))\n//   }\n//\n//   __eh_frame_hdr_start = SIZEOF(.eh_frame_hdr) > 0 ? ADDR(.eh_frame_hdr) : 0;\n//   __eh_frame_hdr_end = SIZEOF(.eh_frame_hdr) > 0 ? . : 0;\n\nextern char __eh_frame_start;\nextern char __eh_frame_end;\n\n#if defined(_LIBUNWIND_SUPPORT_DWARF_INDEX)\nextern char __eh_frame_hdr_start;\nextern char __eh_frame_hdr_end;\n#endif\n\n#elif defined(_LIBUNWIND_ARM_EHABI) && defined(_LIBUNWIND_IS_BAREMETAL)\n\n// When statically linked on bare-metal, the symbols for the EH table are looked\n// up without going through the dynamic loader.\nextern char __exidx_start;\nextern char __exidx_end;\n\n#elif defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND) && defined(_WIN32)\n\n#include <windows.h>\n#include <psapi.h>\n\n#elif defined(_LIBUNWIND_USE_DL_ITERATE_PHDR) ||                               \\\n      defined(_LIBUNWIND_USE_DL_UNWIND_FIND_EXIDX)\n\n#include <link.h>\n\n#endif\n\nnamespace libunwind {\n\n/// Used by findUnwindSections() to return info about needed sections.\nstruct UnwindInfoSections {\n#if defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND) ||                                \\\n    defined(_LIBUNWIND_SUPPORT_COMPACT_UNWIND) ||                              \\\n    defined(_LIBUNWIND_USE_DL_ITERATE_PHDR)\n  // No dso_base for SEH.\n  uintptr_t       dso_base;\n#endif\n#if defined(_LIBUNWIND_USE_DL_ITERATE_PHDR)\n  uintptr_t       text_segment_length;\n#endif\n#if defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND)\n  uintptr_t       dwarf_section;\n  uintptr_t       dwarf_section_length;\n#endif\n#if defined(_LIBUNWIND_SUPPORT_DWARF_INDEX)\n  uintptr_t       dwarf_index_section;\n  uintptr_t       dwarf_index_section_length;\n#endif\n#if defined(_LIBUNWIND_SUPPORT_COMPACT_UNWIND)\n  uintptr_t       compact_unwind_section;\n  uintptr_t       compact_unwind_section_length;\n#endif\n#if defined(_LIBUNWIND_ARM_EHABI)\n  uintptr_t       arm_section;\n  uintptr_t       arm_section_length;\n#endif\n};\n\n\n/// LocalAddressSpace is used as a template parameter to UnwindCursor when\n/// unwinding a thread in the same process.  The wrappers compile away,\n/// making local unwinds fast.\nclass _LIBUNWIND_HIDDEN LocalAddressSpace {\npublic:\n  typedef uintptr_t pint_t;\n  typedef intptr_t  sint_t;\n  uint8_t         get8(pint_t addr) {\n    uint8_t val;\n    memcpy(&val, (void *)addr, sizeof(val));\n    return val;\n  }\n  uint16_t         get16(pint_t addr) {\n    uint16_t val;\n    memcpy(&val, (void *)addr, sizeof(val));\n    return val;\n  }\n  uint32_t         get32(pint_t addr) {\n    uint32_t val;\n    memcpy(&val, (void *)addr, sizeof(val));\n    return val;\n  }\n  uint64_t         get64(pint_t addr) {\n    uint64_t val;\n    memcpy(&val, (void *)addr, sizeof(val));\n    return val;\n  }\n  double           getDouble(pint_t addr) {\n    double val;\n    memcpy(&val, (void *)addr, sizeof(val));\n    return val;\n  }\n  v128             getVector(pint_t addr) {\n    v128 val;\n    memcpy(&val, (void *)addr, sizeof(val));\n    return val;\n  }\n  uintptr_t       getP(pint_t addr);\n  uint64_t        getRegister(pint_t addr);\n  static uint64_t getULEB128(pint_t &addr, pint_t end);\n  static int64_t  getSLEB128(pint_t &addr, pint_t end);\n\n  pint_t getEncodedP(pint_t &addr, pint_t end, uint8_t encoding,\n                     pint_t datarelBase = 0);\n  bool findFunctionName(pint_t addr, char *buf, size_t bufLen,\n                        unw_word_t *offset);\n  bool findUnwindSections(pint_t targetAddr, UnwindInfoSections &info);\n  bool findOtherFDE(pint_t targetAddr, pint_t &fde);\n\n  static LocalAddressSpace sThisAddressSpace;\n};\n\ninline uintptr_t LocalAddressSpace::getP(pint_t addr) {\n#if __SIZEOF_POINTER__ == 8\n  return get64(addr);\n#else\n  return get32(addr);\n#endif\n}\n\ninline uint64_t LocalAddressSpace::getRegister(pint_t addr) {\n#if __SIZEOF_POINTER__ == 8 || defined(__mips64)\n  return get64(addr);\n#else\n  return get32(addr);\n#endif\n}\n\n/// Read a ULEB128 into a 64-bit word.\ninline uint64_t LocalAddressSpace::getULEB128(pint_t &addr, pint_t end) {\n  const uint8_t *p = (uint8_t *)addr;\n  const uint8_t *pend = (uint8_t *)end;\n  uint64_t result = 0;\n  int bit = 0;\n  do {\n    uint64_t b;\n\n    if (p == pend)\n      _LIBUNWIND_ABORT(\"truncated uleb128 expression\");\n\n    b = *p & 0x7f;\n\n    if (bit >= 64 || b << bit >> bit != b) {\n      _LIBUNWIND_ABORT(\"malformed uleb128 expression\");\n    } else {\n      result |= b << bit;\n      bit += 7;\n    }\n  } while (*p++ >= 0x80);\n  addr = (pint_t) p;\n  return result;\n}\n\n/// Read a SLEB128 into a 64-bit word.\ninline int64_t LocalAddressSpace::getSLEB128(pint_t &addr, pint_t end) {\n  const uint8_t *p = (uint8_t *)addr;\n  const uint8_t *pend = (uint8_t *)end;\n  int64_t result = 0;\n  int bit = 0;\n  uint8_t byte;\n  do {\n    if (p == pend)\n      _LIBUNWIND_ABORT(\"truncated sleb128 expression\");\n    byte = *p++;\n    result |= (uint64_t)(byte & 0x7f) << bit;\n    bit += 7;\n  } while (byte & 0x80);\n  // sign extend negative numbers\n  if ((byte & 0x40) != 0 && bit < 64)\n    result |= (-1ULL) << bit;\n  addr = (pint_t) p;\n  return result;\n}\n\ninline LocalAddressSpace::pint_t\nLocalAddressSpace::getEncodedP(pint_t &addr, pint_t end, uint8_t encoding,\n                               pint_t datarelBase) {\n  pint_t startAddr = addr;\n  const uint8_t *p = (uint8_t *)addr;\n  pint_t result;\n\n  // first get value\n  switch (encoding & 0x0F) {\n  case DW_EH_PE_ptr:\n    result = getP(addr);\n    p += sizeof(pint_t);\n    addr = (pint_t) p;\n    break;\n  case DW_EH_PE_uleb128:\n    result = (pint_t)getULEB128(addr, end);\n    break;\n  case DW_EH_PE_udata2:\n    result = get16(addr);\n    p += 2;\n    addr = (pint_t) p;\n    break;\n  case DW_EH_PE_udata4:\n    result = get32(addr);\n    p += 4;\n    addr = (pint_t) p;\n    break;\n  case DW_EH_PE_udata8:\n    result = (pint_t)get64(addr);\n    p += 8;\n    addr = (pint_t) p;\n    break;\n  case DW_EH_PE_sleb128:\n    result = (pint_t)getSLEB128(addr, end);\n    break;\n  case DW_EH_PE_sdata2:\n    // Sign extend from signed 16-bit value.\n    result = (pint_t)(int16_t)get16(addr);\n    p += 2;\n    addr = (pint_t) p;\n    break;\n  case DW_EH_PE_sdata4:\n    // Sign extend from signed 32-bit value.\n    result = (pint_t)(int32_t)get32(addr);\n    p += 4;\n    addr = (pint_t) p;\n    break;\n  case DW_EH_PE_sdata8:\n    result = (pint_t)get64(addr);\n    p += 8;\n    addr = (pint_t) p;\n    break;\n  default:\n    _LIBUNWIND_ABORT(\"unknown pointer encoding\");\n  }\n\n  // then add relative offset\n  switch (encoding & 0x70) {\n  case DW_EH_PE_absptr:\n    // do nothing\n    break;\n  case DW_EH_PE_pcrel:\n    result += startAddr;\n    break;\n  case DW_EH_PE_textrel:\n    _LIBUNWIND_ABORT(\"DW_EH_PE_textrel pointer encoding not supported\");\n    break;\n  case DW_EH_PE_datarel:\n    // DW_EH_PE_datarel is only valid in a few places, so the parameter has a\n    // default value of 0, and we abort in the event that someone calls this\n    // function with a datarelBase of 0 and DW_EH_PE_datarel encoding.\n    if (datarelBase == 0)\n      _LIBUNWIND_ABORT(\"DW_EH_PE_datarel is invalid with a datarelBase of 0\");\n    result += datarelBase;\n    break;\n  case DW_EH_PE_funcrel:\n    _LIBUNWIND_ABORT(\"DW_EH_PE_funcrel pointer encoding not supported\");\n    break;\n  case DW_EH_PE_aligned:\n    _LIBUNWIND_ABORT(\"DW_EH_PE_aligned pointer encoding not supported\");\n    break;\n  default:\n    _LIBUNWIND_ABORT(\"unknown pointer encoding\");\n    break;\n  }\n\n  if (encoding & DW_EH_PE_indirect)\n    result = getP(result);\n\n  return result;\n}\n\n#if defined(_LIBUNWIND_USE_DL_ITERATE_PHDR)\n\n// The ElfW() macro for pointer-size independent ELF header traversal is not\n// provided by <link.h> on some systems (e.g., FreeBSD). On these systems the\n// data structures are just called Elf_XXX. Define ElfW() locally.\n#if !defined(ElfW)\n  #define ElfW(type) Elf_##type\n#endif\n#if !defined(Elf_Half)\n  typedef ElfW(Half) Elf_Half;\n#endif\n#if !defined(Elf_Phdr)\n  typedef ElfW(Phdr) Elf_Phdr;\n#endif\n#if !defined(Elf_Addr)\n  typedef ElfW(Addr) Elf_Addr;\n#endif\n\nstatic Elf_Addr calculateImageBase(struct dl_phdr_info *pinfo) {\n  Elf_Addr image_base = pinfo->dlpi_addr;\n#if defined(__ANDROID__) && __ANDROID_API__ < 18\n  if (image_base == 0) {\n    // Normally, an image base of 0 indicates a non-PIE executable. On\n    // versions of Android prior to API 18, the dynamic linker reported a\n    // dlpi_addr of 0 for PIE executables. Compute the true image base\n    // using the PT_PHDR segment.\n    // See https://github.com/android/ndk/issues/505.\n    for (Elf_Half i = 0; i < pinfo->dlpi_phnum; i++) {\n      const Elf_Phdr *phdr = &pinfo->dlpi_phdr[i];\n      if (phdr->p_type == PT_PHDR) {\n        image_base = reinterpret_cast<Elf_Addr>(pinfo->dlpi_phdr) -\n          phdr->p_vaddr;\n        break;\n      }\n    }\n  }\n#endif\n  return image_base;\n}\n\nstruct _LIBUNWIND_HIDDEN dl_iterate_cb_data {\n  LocalAddressSpace *addressSpace;\n  UnwindInfoSections *sects;\n  uintptr_t targetAddr;\n};\n\n#if defined(_LIBUNWIND_USE_FRAME_HEADER_CACHE)\n#include \"FrameHeaderCache.hpp\"\n\n// Typically there is one cache per process, but when libunwind is built as a\n// hermetic static library, then each shared object may have its own cache.\nstatic FrameHeaderCache TheFrameHeaderCache;\n#endif\n\nstatic bool checkAddrInSegment(const Elf_Phdr *phdr, size_t image_base,\n                               dl_iterate_cb_data *cbdata) {\n  if (phdr->p_type == PT_LOAD) {\n    uintptr_t begin = image_base + phdr->p_vaddr;\n    uintptr_t end = begin + phdr->p_memsz;\n    if (cbdata->targetAddr >= begin && cbdata->targetAddr < end) {\n      cbdata->sects->dso_base = begin;\n      cbdata->sects->text_segment_length = phdr->p_memsz;\n      return true;\n    }\n  }\n  return false;\n}\n\nstatic bool checkForUnwindInfoSegment(const Elf_Phdr *phdr, size_t image_base,\n                                      dl_iterate_cb_data *cbdata) {\n#if defined(_LIBUNWIND_SUPPORT_DWARF_INDEX)\n  if (phdr->p_type == PT_GNU_EH_FRAME) {\n    EHHeaderParser<LocalAddressSpace>::EHHeaderInfo hdrInfo;\n    uintptr_t eh_frame_hdr_start = image_base + phdr->p_vaddr;\n    cbdata->sects->dwarf_index_section = eh_frame_hdr_start;\n    cbdata->sects->dwarf_index_section_length = phdr->p_memsz;\n    if (EHHeaderParser<LocalAddressSpace>::decodeEHHdr(\n            *cbdata->addressSpace, eh_frame_hdr_start, phdr->p_memsz,\n            hdrInfo)) {\n      // .eh_frame_hdr records the start of .eh_frame, but not its size.\n      // Rely on a zero terminator to find the end of the section.\n      cbdata->sects->dwarf_section = hdrInfo.eh_frame_ptr;\n      cbdata->sects->dwarf_section_length = UINTPTR_MAX;\n      return true;\n    }\n  }\n  return false;\n#elif defined(_LIBUNWIND_ARM_EHABI)\n  if (phdr->p_type == PT_ARM_EXIDX) {\n    uintptr_t exidx_start = image_base + phdr->p_vaddr;\n    cbdata->sects->arm_section = exidx_start;\n    cbdata->sects->arm_section_length = phdr->p_memsz;\n    return true;\n  }\n  return false;\n#else\n#error Need one of _LIBUNWIND_SUPPORT_DWARF_INDEX or _LIBUNWIND_ARM_EHABI\n#endif\n}\n\nstatic int findUnwindSectionsByPhdr(struct dl_phdr_info *pinfo,\n                                    size_t pinfo_size, void *data) {\n  auto cbdata = static_cast<dl_iterate_cb_data *>(data);\n  if (pinfo->dlpi_phnum == 0 || cbdata->targetAddr < pinfo->dlpi_addr)\n    return 0;\n#if defined(_LIBUNWIND_USE_FRAME_HEADER_CACHE)\n  if (TheFrameHeaderCache.find(pinfo, pinfo_size, data))\n    return 1;\n#else\n  // Avoid warning about unused variable.\n  (void)pinfo_size;\n#endif\n\n  Elf_Addr image_base = calculateImageBase(pinfo);\n\n  // Most shared objects seen in this callback function likely don't contain the\n  // target address, so optimize for that. Scan for a matching PT_LOAD segment\n  // first and bail when it isn't found.\n  bool found_text = false;\n  for (Elf_Half i = 0; i < pinfo->dlpi_phnum; ++i) {\n    if (checkAddrInSegment(&pinfo->dlpi_phdr[i], image_base, cbdata)) {\n      found_text = true;\n      break;\n    }\n  }\n  if (!found_text)\n    return 0;\n\n  // PT_GNU_EH_FRAME and PT_ARM_EXIDX are usually near the end. Iterate\n  // backward.\n  bool found_unwind = false;\n  for (Elf_Half i = pinfo->dlpi_phnum; i > 0; i--) {\n    const Elf_Phdr *phdr = &pinfo->dlpi_phdr[i - 1];\n    if (checkForUnwindInfoSegment(phdr, image_base, cbdata)) {\n      found_unwind = true;\n      break;\n    }\n  }\n  if (!found_unwind)\n    return 0;\n\n#if defined(_LIBUNWIND_USE_FRAME_HEADER_CACHE)\n  TheFrameHeaderCache.add(cbdata->sects);\n#endif\n  return 1;\n}\n\n#endif  // defined(_LIBUNWIND_USE_DL_ITERATE_PHDR)\n\n\ninline bool LocalAddressSpace::findUnwindSections(pint_t targetAddr,\n                                                  UnwindInfoSections &info) {\n#ifdef __APPLE__\n  dyld_unwind_sections dyldInfo;\n  if (_dyld_find_unwind_sections((void *)targetAddr, &dyldInfo)) {\n    info.dso_base                      = (uintptr_t)dyldInfo.mh;\n #if defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND)\n    info.dwarf_section                 = (uintptr_t)dyldInfo.dwarf_section;\n    info.dwarf_section_length          = dyldInfo.dwarf_section_length;\n #endif\n    info.compact_unwind_section        = (uintptr_t)dyldInfo.compact_unwind_section;\n    info.compact_unwind_section_length = dyldInfo.compact_unwind_section_length;\n    return true;\n  }\n#elif defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND) && defined(_LIBUNWIND_IS_BAREMETAL)\n  info.dso_base = 0;\n  // Bare metal is statically linked, so no need to ask the dynamic loader\n  info.dwarf_section_length = (uintptr_t)(&__eh_frame_end - &__eh_frame_start);\n  info.dwarf_section =        (uintptr_t)(&__eh_frame_start);\n  _LIBUNWIND_TRACE_UNWINDING(\"findUnwindSections: section %p length %p\",\n                             (void *)info.dwarf_section, (void *)info.dwarf_section_length);\n#if defined(_LIBUNWIND_SUPPORT_DWARF_INDEX)\n  info.dwarf_index_section =        (uintptr_t)(&__eh_frame_hdr_start);\n  info.dwarf_index_section_length = (uintptr_t)(&__eh_frame_hdr_end - &__eh_frame_hdr_start);\n  _LIBUNWIND_TRACE_UNWINDING(\"findUnwindSections: index section %p length %p\",\n                             (void *)info.dwarf_index_section, (void *)info.dwarf_index_section_length);\n#endif\n  if (info.dwarf_section_length)\n    return true;\n#elif defined(_LIBUNWIND_ARM_EHABI) && defined(_LIBUNWIND_IS_BAREMETAL)\n  // Bare metal is statically linked, so no need to ask the dynamic loader\n  info.arm_section =        (uintptr_t)(&__exidx_start);\n  info.arm_section_length = (uintptr_t)(&__exidx_end - &__exidx_start);\n  _LIBUNWIND_TRACE_UNWINDING(\"findUnwindSections: section %p length %p\",\n                             (void *)info.arm_section, (void *)info.arm_section_length);\n  if (info.arm_section && info.arm_section_length)\n    return true;\n#elif defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND) && defined(_WIN32)\n  HMODULE mods[1024];\n  HANDLE process = GetCurrentProcess();\n  DWORD needed;\n\n  if (!EnumProcessModules(process, mods, sizeof(mods), &needed)) {\n    DWORD err = GetLastError();\n    _LIBUNWIND_TRACE_UNWINDING(\"findUnwindSections: EnumProcessModules failed, \"\n                               \"returned error %d\", (int)err);\n    return false;\n  }\n\n  for (unsigned i = 0; i < (needed / sizeof(HMODULE)); i++) {\n    PIMAGE_DOS_HEADER pidh = (PIMAGE_DOS_HEADER)mods[i];\n    PIMAGE_NT_HEADERS pinh = (PIMAGE_NT_HEADERS)((BYTE *)pidh + pidh->e_lfanew);\n    PIMAGE_FILE_HEADER pifh = (PIMAGE_FILE_HEADER)&pinh->FileHeader;\n    PIMAGE_SECTION_HEADER pish = IMAGE_FIRST_SECTION(pinh);\n    bool found_obj = false;\n    bool found_hdr = false;\n\n    info.dso_base = (uintptr_t)mods[i];\n    for (unsigned j = 0; j < pifh->NumberOfSections; j++, pish++) {\n      uintptr_t begin = pish->VirtualAddress + (uintptr_t)mods[i];\n      uintptr_t end = begin + pish->Misc.VirtualSize;\n      if (!strncmp((const char *)pish->Name, \".text\",\n                   IMAGE_SIZEOF_SHORT_NAME)) {\n        if (targetAddr >= begin && targetAddr < end)\n          found_obj = true;\n      } else if (!strncmp((const char *)pish->Name, \".eh_frame\",\n                          IMAGE_SIZEOF_SHORT_NAME)) {\n        info.dwarf_section = begin;\n        info.dwarf_section_length = pish->Misc.VirtualSize;\n        found_hdr = true;\n      }\n      if (found_obj && found_hdr)\n        return true;\n    }\n  }\n  return false;\n#elif defined(_LIBUNWIND_SUPPORT_SEH_UNWIND) && defined(_WIN32)\n  // Don't even bother, since Windows has functions that do all this stuff\n  // for us.\n  (void)targetAddr;\n  (void)info;\n  return true;\n#elif defined(_LIBUNWIND_USE_DL_UNWIND_FIND_EXIDX)\n  int length = 0;\n  info.arm_section =\n      (uintptr_t)dl_unwind_find_exidx((_Unwind_Ptr)targetAddr, &length);\n  info.arm_section_length = (uintptr_t)length * sizeof(EHABIIndexEntry);\n  if (info.arm_section && info.arm_section_length)\n    return true;\n#elif defined(_LIBUNWIND_USE_DL_ITERATE_PHDR)\n  dl_iterate_cb_data cb_data = {this, &info, targetAddr};\n  int found = dl_iterate_phdr(findUnwindSectionsByPhdr, &cb_data);\n  return static_cast<bool>(found);\n#endif\n\n  return false;\n}\n\n\ninline bool LocalAddressSpace::findOtherFDE(pint_t targetAddr, pint_t &fde) {\n  // TO DO: if OS has way to dynamically register FDEs, check that.\n  (void)targetAddr;\n  (void)fde;\n  return false;\n}\n\ninline bool LocalAddressSpace::findFunctionName(pint_t addr, char *buf,\n                                                size_t bufLen,\n                                                unw_word_t *offset) {\n#if _LIBUNWIND_USE_DLADDR\n  Dl_info dyldInfo;\n  if (dladdr((void *)addr, &dyldInfo)) {\n    if (dyldInfo.dli_sname != NULL) {\n      snprintf(buf, bufLen, \"%s\", dyldInfo.dli_sname);\n      *offset = (addr - (pint_t) dyldInfo.dli_saddr);\n      return true;\n    }\n  }\n#else\n  (void)addr;\n  (void)buf;\n  (void)bufLen;\n  (void)offset;\n#endif\n  return false;\n}\n\n} // namespace libunwind\n\n#endif // __ADDRESSSPACE_HPP__\n"}, "2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/libunwind/src/DwarfParser.hpp", "content": "//===--------------------------- DwarfParser.hpp --------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//\n//  Parses DWARF CFIs (FDEs and CIEs).\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef __DWARF_PARSER_HPP__\n#define __DWARF_PARSER_HPP__\n\n#include <inttypes.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"libunwind.h\"\n#include \"dwarf2.h\"\n#include \"Registers.hpp\"\n\n#include \"config.h\"\n\nnamespace libunwind {\n\n/// CFI_Parser does basic parsing of a CFI (Call Frame Information) records.\n/// See DWARF Spec for details:\n///    http://refspecs.linuxbase.org/LSB_3.1.0/LSB-Core-generic/LSB-Core-generic/ehframechpt.html\n///\ntemplate <typename A>\nclass CFI_Parser {\npublic:\n  typedef typename A::pint_t pint_t;\n\n  /// Information encoded in a CIE (Common Information Entry)\n  struct CIE_Info {\n    pint_t    cieStart;\n    pint_t    cieLength;\n    pint_t    cieInstructions;\n    uint8_t   pointerEncoding;\n    uint8_t   lsdaEncoding;\n    uint8_t   personalityEncoding;\n    uint8_t   personalityOffsetInCIE;\n    pint_t    personality;\n    uint32_t  codeAlignFactor;\n    int       dataAlignFactor;\n    bool      isSignalFrame;\n    bool      fdesHaveAugmentationData;\n    uint8_t   returnAddressRegister;\n#if defined(_LIBUNWIND_TARGET_AARCH64)\n    bool      addressesSignedWithBKey;\n#endif\n  };\n\n  /// Information about an FDE (Frame Description Entry)\n  struct FDE_Info {\n    pint_t  fdeStart;\n    pint_t  fdeLength;\n    pint_t  fdeInstructions;\n    pint_t  pcStart;\n    pint_t  pcEnd;\n    pint_t  lsda;\n  };\n\n  enum {\n    kMaxRegisterNumber = _LIBUNWIND_HIGHEST_DWARF_REGISTER\n  };\n  enum RegisterSavedWhere {\n    kRegisterUnused,\n    kRegisterUndefined,\n    kRegisterInCFA,\n    kRegisterOffsetFromCFA,\n    kRegisterInRegister,\n    kRegisterAtExpression,\n    kRegisterIsExpression\n  };\n  struct RegisterLocation {\n    RegisterSavedWhere location;\n    bool initialStateSaved;\n    int64_t value;\n  };\n  /// Information about a frame layout and registers saved determined\n  /// by \"running\" the DWARF FDE \"instructions\"\n  struct PrologInfo {\n    uint32_t          cfaRegister;\n    int32_t           cfaRegisterOffset;  // CFA = (cfaRegister)+cfaRegisterOffset\n    int64_t           cfaExpression;      // CFA = expression\n    uint32_t          spExtraArgSize;\n    RegisterLocation  savedRegisters[kMaxRegisterNumber + 1];\n    enum class InitializeTime { kLazy, kNormal };\n\n    // When saving registers, this data structure is lazily initialized.\n    PrologInfo(InitializeTime IT = InitializeTime::kNormal) {\n      if (IT == InitializeTime::kNormal)\n        memset(this, 0, sizeof(*this));\n    }\n    void checkSaveRegister(uint64_t reg, PrologInfo &initialState) {\n      if (!savedRegisters[reg].initialStateSaved) {\n        initialState.savedRegisters[reg] = savedRegisters[reg];\n        savedRegisters[reg].initialStateSaved = true;\n      }\n    }\n    void setRegister(uint64_t reg, RegisterSavedWhere newLocation,\n                     int64_t newValue, PrologInfo &initialState) {\n      checkSaveRegister(reg, initialState);\n      savedRegisters[reg].location = newLocation;\n      savedRegisters[reg].value = newValue;\n    }\n    void setRegisterLocation(uint64_t reg, RegisterSavedWhere newLocation,\n                             PrologInfo &initialState) {\n      checkSaveRegister(reg, initialState);\n      savedRegisters[reg].location = newLocation;\n    }\n    void setRegisterValue(uint64_t reg, int64_t newValue,\n                          PrologInfo &initialState) {\n      checkSaveRegister(reg, initialState);\n      savedRegisters[reg].value = newValue;\n    }\n    void restoreRegisterToInitialState(uint64_t reg, PrologInfo &initialState) {\n      if (savedRegisters[reg].initialStateSaved)\n        savedRegisters[reg] = initialState.savedRegisters[reg];\n      // else the register still holds its initial state\n    }\n  };\n\n  struct PrologInfoStackEntry {\n    PrologInfoStackEntry(PrologInfoStackEntry *n, const PrologInfo &i)\n        : next(n), info(i) {}\n    PrologInfoStackEntry *next;\n    PrologInfo info;\n  };\n\n  struct RememberStack {\n    PrologInfoStackEntry *entry;\n    RememberStack() : entry(nullptr) {}\n    ~RememberStack() {\n#if defined(_LIBUNWIND_REMEMBER_CLEANUP_NEEDED)\n      // Clean up rememberStack. Even in the case where every\n      // DW_CFA_remember_state is paired with a DW_CFA_restore_state,\n      // parseInstructions can skip restore opcodes if it reaches the target PC\n      // and stops interpreting, so we have to make sure we don't leak memory.\n      while (entry) {\n        PrologInfoStackEntry *next = entry->next;\n        _LIBUNWIND_REMEMBER_FREE(entry);\n        entry = next;\n      }\n#endif\n    }\n  };\n\n  static bool findFDE(A &addressSpace, pint_t pc, pint_t ehSectionStart,\n                      uintptr_t sectionLength, pint_t fdeHint, FDE_Info *fdeInfo,\n                      CIE_Info *cieInfo);\n  static const char *decodeFDE(A &addressSpace, pint_t fdeStart,\n                               FDE_Info *fdeInfo, CIE_Info *cieInfo);\n  static bool parseFDEInstructions(A &addressSpace, const FDE_Info &fdeInfo,\n                                   const CIE_Info &cieInfo, pint_t upToPC,\n                                   int arch, PrologInfo *results);\n\n  static const char *parseCIE(A &addressSpace, pint_t cie, CIE_Info *cieInfo);\n};\n\n/// Parse a FDE into a CIE_Info and an FDE_Info\ntemplate <typename A>\nconst char *CFI_Parser<A>::decodeFDE(A &addressSpace, pint_t fdeStart,\n                                     FDE_Info *fdeInfo, CIE_Info *cieInfo) {\n  pint_t p = fdeStart;\n  pint_t cfiLength = (pint_t)addressSpace.get32(p);\n  p += 4;\n  if (cfiLength == 0xffffffff) {\n    // 0xffffffff means length is really next 8 bytes\n    cfiLength = (pint_t)addressSpace.get64(p);\n    p += 8;\n  }\n  if (cfiLength == 0)\n    return \"FDE has zero length\"; // zero terminator\n  uint32_t ciePointer = addressSpace.get32(p);\n  if (ciePointer == 0)\n    return \"FDE is really a CIE\"; // this is a CIE not an FDE\n  pint_t nextCFI = p + cfiLength;\n  pint_t cieStart = p - ciePointer;\n  const char *err = parseCIE(addressSpace, cieStart, cieInfo);\n  if (err != NULL)\n    return err;\n  p += 4;\n  // Parse pc begin and range.\n  pint_t pcStart =\n      addressSpace.getEncodedP(p, nextCFI, cieInfo->pointerEncoding);\n  pint_t pcRange =\n      addressSpace.getEncodedP(p, nextCFI, cieInfo->pointerEncoding & 0x0F);\n  // Parse rest of info.\n  fdeInfo->lsda = 0;\n  // Check for augmentation length.\n  if (cieInfo->fdesHaveAugmentationData) {\n    pint_t augLen = (pint_t)addressSpace.getULEB128(p, nextCFI);\n    pint_t endOfAug = p + augLen;\n    if (cieInfo->lsdaEncoding != DW_EH_PE_omit) {\n      // Peek at value (without indirection).  Zero means no LSDA.\n      pint_t lsdaStart = p;\n      if (addressSpace.getEncodedP(p, nextCFI, cieInfo->lsdaEncoding & 0x0F) !=\n          0) {\n        // Reset pointer and re-parse LSDA address.\n        p = lsdaStart;\n        fdeInfo->lsda =\n            addressSpace.getEncodedP(p, nextCFI, cieInfo->lsdaEncoding);\n      }\n    }\n    p = endOfAug;\n  }\n  fdeInfo->fdeStart = fdeStart;\n  fdeInfo->fdeLength = nextCFI - fdeStart;\n  fdeInfo->fdeInstructions = p;\n  fdeInfo->pcStart = pcStart;\n  fdeInfo->pcEnd = pcStart + pcRange;\n  return NULL; // success\n}\n\n/// Scan an eh_frame section to find an FDE for a pc\ntemplate <typename A>\nbool CFI_Parser<A>::findFDE(A &addressSpace, pint_t pc, pint_t ehSectionStart,\n                            uintptr_t sectionLength, pint_t fdeHint,\n                            FDE_Info *fdeInfo, CIE_Info *cieInfo) {\n  //fprintf(stderr, \"findFDE(0x%llX)\\n\", (long long)pc);\n  pint_t p = (fdeHint != 0) ? fdeHint : ehSectionStart;\n  const pint_t ehSectionEnd = (sectionLength == UINTPTR_MAX)\n                                  ? static_cast<pint_t>(-1)\n                                  : (ehSectionStart + sectionLength);\n  while (p < ehSectionEnd) {\n    pint_t currentCFI = p;\n    //fprintf(stderr, \"findFDE() CFI at 0x%llX\\n\", (long long)p);\n    pint_t cfiLength = addressSpace.get32(p);\n    p += 4;\n    if (cfiLength == 0xffffffff) {\n      // 0xffffffff means length is really next 8 bytes\n      cfiLength = (pint_t)addressSpace.get64(p);\n      p += 8;\n    }\n    if (cfiLength == 0)\n      return false; // zero terminator\n    uint32_t id = addressSpace.get32(p);\n    if (id == 0) {\n      // Skip over CIEs.\n      p += cfiLength;\n    } else {\n      // Process FDE to see if it covers pc.\n      pint_t nextCFI = p + cfiLength;\n      uint32_t ciePointer = addressSpace.get32(p);\n      pint_t cieStart = p - ciePointer;\n      // Validate pointer to CIE is within section.\n      if ((ehSectionStart <= cieStart) && (cieStart < ehSectionEnd)) {\n        if (parseCIE(addressSpace, cieStart, cieInfo) == NULL) {\n          p += 4;\n          // Parse pc begin and range.\n          pint_t pcStart =\n              addressSpace.getEncodedP(p, nextCFI, cieInfo->pointerEncoding);\n          pint_t pcRange = addressSpace.getEncodedP(\n              p, nextCFI, cieInfo->pointerEncoding & 0x0F);\n          // Test if pc is within the function this FDE covers.\n          if ((pcStart < pc) && (pc <= pcStart + pcRange)) {\n            // parse rest of info\n            fdeInfo->lsda = 0;\n            // check for augmentation length\n            if (cieInfo->fdesHaveAugmentationData) {\n              pint_t augLen = (pint_t)addressSpace.getULEB128(p, nextCFI);\n              pint_t endOfAug = p + augLen;\n              if (cieInfo->lsdaEncoding != DW_EH_PE_omit) {\n                // Peek at value (without indirection).  Zero means no LSDA.\n                pint_t lsdaStart = p;\n                if (addressSpace.getEncodedP(\n                        p, nextCFI, cieInfo->lsdaEncoding & 0x0F) != 0) {\n                  // Reset pointer and re-parse LSDA address.\n                  p = lsdaStart;\n                  fdeInfo->lsda = addressSpace\n                      .getEncodedP(p, nextCFI, cieInfo->lsdaEncoding);\n                }\n              }\n              p = endOfAug;\n            }\n            fdeInfo->fdeStart = currentCFI;\n            fdeInfo->fdeLength = nextCFI - currentCFI;\n            fdeInfo->fdeInstructions = p;\n            fdeInfo->pcStart = pcStart;\n            fdeInfo->pcEnd = pcStart + pcRange;\n            return true;\n          } else {\n            // pc is not in begin/range, skip this FDE\n          }\n        } else {\n          // Malformed CIE, now augmentation describing pc range encoding.\n        }\n      } else {\n        // malformed FDE.  CIE is bad\n      }\n      p = nextCFI;\n    }\n  }\n  return false;\n}\n\n/// Extract info from a CIE\ntemplate <typename A>\nconst char *CFI_Parser<A>::parseCIE(A &addressSpace, pint_t cie,\n                                    CIE_Info *cieInfo) {\n  cieInfo->pointerEncoding = 0;\n  cieInfo->lsdaEncoding = DW_EH_PE_omit;\n  cieInfo->personalityEncoding = 0;\n  cieInfo->personalityOffsetInCIE = 0;\n  cieInfo->personality = 0;\n  cieInfo->codeAlignFactor = 0;\n  cieInfo->dataAlignFactor = 0;\n  cieInfo->isSignalFrame = false;\n  cieInfo->fdesHaveAugmentationData = false;\n#if defined(_LIBUNWIND_TARGET_AARCH64)\n  cieInfo->addressesSignedWithBKey = false;\n#endif\n  cieInfo->cieStart = cie;\n  pint_t p = cie;\n  pint_t cieLength = (pint_t)addressSpace.get32(p);\n  p += 4;\n  pint_t cieContentEnd = p + cieLength;\n  if (cieLength == 0xffffffff) {\n    // 0xffffffff means length is really next 8 bytes\n    cieLength = (pint_t)addressSpace.get64(p);\n    p += 8;\n    cieContentEnd = p + cieLength;\n  }\n  if (cieLength == 0)\n    return NULL;\n  // CIE ID is always 0\n  if (addressSpace.get32(p) != 0)\n    return \"CIE ID is not zero\";\n  p += 4;\n  // Version is always 1 or 3\n  uint8_t version = addressSpace.get8(p);\n  if ((version != 1) && (version != 3))\n    return \"CIE version is not 1 or 3\";\n  ++p;\n  // save start of augmentation string and find end\n  pint_t strStart = p;\n  while (addressSpace.get8(p) != 0)\n    ++p;\n  ++p;\n  // parse code aligment factor\n  cieInfo->codeAlignFactor = (uint32_t)addressSpace.getULEB128(p, cieContentEnd);\n  // parse data alignment factor\n  cieInfo->dataAlignFactor = (int)addressSpace.getSLEB128(p, cieContentEnd);\n  // parse return address register\n  uint64_t raReg = (version == 1) ? addressSpace.get8(p++)\n                                  : addressSpace.getULEB128(p, cieContentEnd);\n  assert(raReg < 255 && \"return address register too large\");\n  cieInfo->returnAddressRegister = (uint8_t)raReg;\n  // parse augmentation data based on augmentation string\n  const char *result = NULL;\n  if (addressSpace.get8(strStart) == 'z') {\n    // parse augmentation data length\n    addressSpace.getULEB128(p, cieContentEnd);\n    for (pint_t s = strStart; addressSpace.get8(s) != '\\0'; ++s) {\n      switch (addressSpace.get8(s)) {\n      case 'z':\n        cieInfo->fdesHaveAugmentationData = true;\n        break;\n      case 'P':\n        cieInfo->personalityEncoding = addressSpace.get8(p);\n        ++p;\n        cieInfo->personalityOffsetInCIE = (uint8_t)(p - cie);\n        cieInfo->personality = addressSpace\n            .getEncodedP(p, cieContentEnd, cieInfo->personalityEncoding);\n        break;\n      case 'L':\n        cieInfo->lsdaEncoding = addressSpace.get8(p);\n        ++p;\n        break;\n      case 'R':\n        cieInfo->pointerEncoding = addressSpace.get8(p);\n        ++p;\n        break;\n      case 'S':\n        cieInfo->isSignalFrame = true;\n        break;\n#if defined(_LIBUNWIND_TARGET_AARCH64)\n      case 'B':\n        cieInfo->addressesSignedWithBKey = true;\n        break;\n#endif\n      default:\n        // ignore unknown letters\n        break;\n      }\n    }\n  }\n  cieInfo->cieLength = cieContentEnd - cieInfo->cieStart;\n  cieInfo->cieInstructions = p;\n  return result;\n}\n\n\n/// \"run\" the DWARF instructions and create the abstact PrologInfo for an FDE\ntemplate <typename A>\nbool CFI_Parser<A>::parseFDEInstructions(A &addressSpace,\n                                         const FDE_Info &fdeInfo,\n                                         const CIE_Info &cieInfo, pint_t upToPC,\n                                         int arch, PrologInfo *results) {\n  // Alloca is used for the allocation of the rememberStack entries. It removes\n  // the dependency on new/malloc but the below for loop can not be refactored\n  // into functions. Entry could be saved during the processing of a CIE and\n  // restored by an FDE.\n  RememberStack rememberStack;\n\n  struct ParseInfo {\n    pint_t instructions;\n    pint_t instructionsEnd;\n    pint_t pcoffset;\n  };\n\n  ParseInfo parseInfoArray[] = {\n      {cieInfo.cieInstructions, cieInfo.cieStart + cieInfo.cieLength,\n       (pint_t)(-1)},\n      {fdeInfo.fdeInstructions, fdeInfo.fdeStart + fdeInfo.fdeLength,\n       upToPC - fdeInfo.pcStart}};\n\n  for (const auto &info : parseInfoArray) {\n    pint_t p = info.instructions;\n    pint_t instructionsEnd = info.instructionsEnd;\n    pint_t pcoffset = info.pcoffset;\n    pint_t codeOffset = 0;\n\n    // initialState initialized as registers in results are modified. Use\n    // PrologInfo accessor functions to avoid reading uninitialized data.\n    PrologInfo initialState(PrologInfo::InitializeTime::kLazy);\n\n    _LIBUNWIND_TRACE_DWARF(\"parseFDEInstructions(instructions=0x%0\" PRIx64\n                           \")\\n\",\n                           static_cast<uint64_t>(instructionsEnd));\n\n    // see DWARF Spec, section 6.4.2 for details on unwind opcodes\n    while ((p < instructionsEnd) && (codeOffset < pcoffset)) {\n      uint64_t reg;\n      uint64_t reg2;\n      int64_t offset;\n      uint64_t length;\n      uint8_t opcode = addressSpace.get8(p);\n      uint8_t operand;\n\n      ++p;\n      switch (opcode) {\n      case DW_CFA_nop:\n        _LIBUNWIND_TRACE_DWARF(\"DW_CFA_nop\\n\");\n        break;\n      case DW_CFA_set_loc:\n        codeOffset = addressSpace.getEncodedP(p, instructionsEnd,\n                                              cieInfo.pointerEncoding);\n        _LIBUNWIND_TRACE_DWARF(\"DW_CFA_set_loc\\n\");\n        break;\n      case DW_CFA_advance_loc1:\n        codeOffset += (addressSpace.get8(p) * cieInfo.codeAlignFactor);\n        p += 1;\n        _LIBUNWIND_TRACE_DWARF(\"DW_CFA_advance_loc1: new offset=%\" PRIu64 \"\\n\",\n                               static_cast<uint64_t>(codeOffset));\n        break;\n      case DW_CFA_advance_loc2:\n        codeOffset += (addressSpace.get16(p) * cieInfo.codeAlignFactor);\n        p += 2;\n        _LIBUNWIND_TRACE_DWARF(\"DW_CFA_advance_loc2: new offset=%\" PRIu64 \"\\n\",\n                               static_cast<uint64_t>(codeOffset));\n        break;\n      case DW_CFA_advance_loc4:\n        codeOffset += (addressSpace.get32(p) * cieInfo.codeAlignFactor);\n        p += 4;\n        _LIBUNWIND_TRACE_DWARF(\"DW_CFA_advance_loc4: new offset=%\" PRIu64 \"\\n\",\n                               static_cast<uint64_t>(codeOffset));\n        break;\n      case DW_CFA_offset_extended:\n        reg = addressSpace.getULEB128(p, instructionsEnd);\n        offset = (int64_t)addressSpace.getULEB128(p, instructionsEnd) *\n                 cieInfo.dataAlignFactor;\n        if (reg > kMaxRegisterNumber) {\n          _LIBUNWIND_LOG0(\n              \"malformed DW_CFA_offset_extended DWARF unwind, reg too big\");\n          return false;\n        }\n        results->setRegister(reg, kRegisterInCFA, offset, initialState);\n        _LIBUNWIND_TRACE_DWARF(\"DW_CFA_offset_extended(reg=%\" PRIu64 \", \"\n                               \"offset=%\" PRId64 \")\\n\",\n                               reg, offset);\n        break;\n      case DW_CFA_restore_extended:\n        reg = addressSpace.getULEB128(p, instructionsEnd);\n        if (reg > kMaxRegisterNumber) {\n          _LIBUNWIND_LOG0(\n              \"malformed DW_CFA_restore_extended DWARF unwind, reg too big\");\n          return false;\n        }\n        results->restoreRegisterToInitialState(reg, initialState);\n        _LIBUNWIND_TRACE_DWARF(\"DW_CFA_restore_extended(reg=%\" PRIu64 \")\\n\",\n                               reg);\n        break;\n      case DW_CFA_undefined:\n        reg = addressSpace.getULEB128(p, instructionsEnd);\n        if (reg > kMaxRegisterNumber) {\n          _LIBUNWIND_LOG0(\n              \"malformed DW_CFA_undefined DWARF unwind, reg too big\");\n          return false;\n        }\n        results->setRegisterLocation(reg, kRegisterUndefined, initialState);\n        _LIBUNWIND_TRACE_DWARF(\"DW_CFA_undefined(reg=%\" PRIu64 \")\\n\", reg);\n        break;\n      case DW_CFA_same_value:\n        reg = addressSpace.getULEB128(p, instructionsEnd);\n        if (reg > kMaxRegisterNumber) {\n          _LIBUNWIND_LOG0(\n              \"malformed DW_CFA_same_value DWARF unwind, reg too big\");\n          return false;\n        }\n        // <rdar://problem/8456377> DW_CFA_same_value unsupported\n        // \"same value\" means register was stored in frame, but its current\n        // value has not changed, so no need to restore from frame.\n        // We model this as if the register was never saved.\n        results->setRegisterLocation(reg, kRegisterUnused, initialState);\n        _LIBUNWIND_TRACE_DWARF(\"DW_CFA_same_value(reg=%\" PRIu64 \")\\n\", reg);\n        break;\n      case DW_CFA_register:\n        reg = addressSpace.getULEB128(p, instructionsEnd);\n        reg2 = addressSpace.getULEB128(p, instructionsEnd);\n        if (reg > kMaxRegisterNumber) {\n          _LIBUNWIND_LOG0(\n              \"malformed DW_CFA_register DWARF unwind, reg too big\");\n          return false;\n        }\n        if (reg2 > kMaxRegisterNumber) {\n          _LIBUNWIND_LOG0(\n              \"malformed DW_CFA_register DWARF unwind, reg2 too big\");\n          return false;\n        }\n        results->setRegister(reg, kRegisterInRegister, (int64_t)reg2,\n                             initialState);\n        _LIBUNWIND_TRACE_DWARF(\n            \"DW_CFA_register(reg=%\" PRIu64 \", reg2=%\" PRIu64 \")\\n\", reg, reg2);\n        break;\n      case DW_CFA_remember_state: {\n        // Avoid operator new because that would be an upward dependency.\n        // Avoid malloc because it needs heap allocation.\n        PrologInfoStackEntry *entry =\n            (PrologInfoStackEntry *)_LIBUNWIND_REMEMBER_ALLOC(\n                sizeof(PrologInfoStackEntry));\n        if (entry != NULL) {\n          entry->next = rememberStack.entry;\n          entry->info = *results;\n          rememberStack.entry = entry;\n        } else {\n          return false;\n        }\n        _LIBUNWIND_TRACE_DWARF(\"DW_CFA_remember_state\\n\");\n        break;\n      }\n      case DW_CFA_restore_state:\n        if (rememberStack.entry != NULL) {\n          PrologInfoStackEntry *top = rememberStack.entry;\n          *results = top->info;\n          rememberStack.entry = top->next;\n          _LIBUNWIND_REMEMBER_FREE(top);\n        } else {\n          return false;\n        }\n        _LIBUNWIND_TRACE_DWARF(\"DW_CFA_restore_state\\n\");\n        break;\n      case DW_CFA_def_cfa:\n        reg = addressSpace.getULEB128(p, instructionsEnd);\n        offset = (int64_t)addressSpace.getULEB128(p, instructionsEnd);\n        if (reg > kMaxRegisterNumber) {\n          _LIBUNWIND_LOG0(\"malformed DW_CFA_def_cfa DWARF unwind, reg too big\");\n          return false;\n        }\n        results->cfaRegister = (uint32_t)reg;\n        results->cfaRegisterOffset = (int32_t)offset;\n        _LIBUNWIND_TRACE_DWARF(\"DW_CFA_def_cfa(reg=%\" PRIu64 \", offset=%\" PRIu64\n                               \")\\n\",\n                               reg, offset);\n        break;\n      case DW_CFA_def_cfa_register:\n        reg = addressSpace.getULEB128(p, instructionsEnd);\n        if (reg > kMaxRegisterNumber) {\n          _LIBUNWIND_LOG0(\n              \"malformed DW_CFA_def_cfa_register DWARF unwind, reg too big\");\n          return false;\n        }\n        results->cfaRegister = (uint32_t)reg;\n        _LIBUNWIND_TRACE_DWARF(\"DW_CFA_def_cfa_register(%\" PRIu64 \")\\n\", reg);\n        break;\n      case DW_CFA_def_cfa_offset:\n        results->cfaRegisterOffset =\n            (int32_t)addressSpace.getULEB128(p, instructionsEnd);\n        _LIBUNWIND_TRACE_DWARF(\"DW_CFA_def_cfa_offset(%d)\\n\",\n                               results->cfaRegisterOffset);\n        break;\n      case DW_CFA_def_cfa_expression:\n        results->cfaRegister = 0;\n        results->cfaExpression = (int64_t)p;\n        length = addressSpace.getULEB128(p, instructionsEnd);\n        assert(length < static_cast<pint_t>(~0) && \"pointer overflow\");\n        p += static_cast<pint_t>(length);\n        _LIBUNWIND_TRACE_DWARF(\"DW_CFA_def_cfa_expression(expression=0x%\" PRIx64\n                               \", length=%\" PRIu64 \")\\n\",\n                               results->cfaExpression, length);\n        break;\n      case DW_CFA_expression:\n        reg = addressSpace.getULEB128(p, instructionsEnd);\n        if (reg > kMaxRegisterNumber) {\n          _LIBUNWIND_LOG0(\n              \"malformed DW_CFA_expression DWARF unwind, reg too big\");\n          return false;\n        }\n        results->setRegister(reg, kRegisterAtExpression, (int64_t)p,\n                             initialState);\n        length = addressSpace.getULEB128(p, instructionsEnd);\n        assert(length < static_cast<pint_t>(~0) && \"pointer overflow\");\n        p += static_cast<pint_t>(length);\n        _LIBUNWIND_TRACE_DWARF(\"DW_CFA_expression(reg=%\" PRIu64 \", \"\n                               \"expression=0x%\" PRIx64 \", \"\n                               \"length=%\" PRIu64 \")\\n\",\n                               reg, results->savedRegisters[reg].value, length);\n        break;\n      case DW_CFA_offset_extended_sf:\n        reg = addressSpace.getULEB128(p, instructionsEnd);\n        if (reg > kMaxRegisterNumber) {\n          _LIBUNWIND_LOG0(\n              \"malformed DW_CFA_offset_extended_sf DWARF unwind, reg too big\");\n          return false;\n        }\n        offset = addressSpace.getSLEB128(p, instructionsEnd) *\n                 cieInfo.dataAlignFactor;\n        results->setRegister(reg, kRegisterInCFA, offset, initialState);\n        _LIBUNWIND_TRACE_DWARF(\"DW_CFA_offset_extended_sf(reg=%\" PRIu64 \", \"\n                               \"offset=%\" PRId64 \")\\n\",\n                               reg, offset);\n        break;\n      case DW_CFA_def_cfa_sf:\n        reg = addressSpace.getULEB128(p, instructionsEnd);\n        offset = addressSpace.getSLEB128(p, instructionsEnd) *\n                 cieInfo.dataAlignFactor;\n        if (reg > kMaxRegisterNumber) {\n          _LIBUNWIND_LOG0(\n              \"malformed DW_CFA_def_cfa_sf DWARF unwind, reg too big\");\n          return false;\n        }\n        results->cfaRegister = (uint32_t)reg;\n        results->cfaRegisterOffset = (int32_t)offset;\n        _LIBUNWIND_TRACE_DWARF(\"DW_CFA_def_cfa_sf(reg=%\" PRIu64 \", \"\n                               \"offset=%\" PRId64 \")\\n\",\n                               reg, offset);\n        break;\n      case DW_CFA_def_cfa_offset_sf:\n        results->cfaRegisterOffset =\n            (int32_t)(addressSpace.getSLEB128(p, instructionsEnd) *\n                      cieInfo.dataAlignFactor);\n        _LIBUNWIND_TRACE_DWARF(\"DW_CFA_def_cfa_offset_sf(%d)\\n\",\n                               results->cfaRegisterOffset);\n        break;\n      case DW_CFA_val_offset:\n        reg = addressSpace.getULEB128(p, instructionsEnd);\n        if (reg > kMaxRegisterNumber) {\n          _LIBUNWIND_LOG(\n              \"malformed DW_CFA_val_offset DWARF unwind, reg (%\" PRIu64\n              \") out of range\\n\",\n              reg);\n          return false;\n        }\n        offset = (int64_t)addressSpace.getULEB128(p, instructionsEnd) *\n                 cieInfo.dataAlignFactor;\n        results->setRegister(reg, kRegisterOffsetFromCFA, offset, initialState);\n        _LIBUNWIND_TRACE_DWARF(\"DW_CFA_val_offset(reg=%\" PRIu64 \", \"\n                               \"offset=%\" PRId64 \"\\n\",\n                               reg, offset);\n        break;\n      case DW_CFA_val_offset_sf:\n        reg = addressSpace.getULEB128(p, instructionsEnd);\n        if (reg > kMaxRegisterNumber) {\n          _LIBUNWIND_LOG0(\n              \"malformed DW_CFA_val_offset_sf DWARF unwind, reg too big\");\n          return false;\n        }\n        offset = addressSpace.getSLEB128(p, instructionsEnd) *\n                 cieInfo.dataAlignFactor;\n        results->setRegister(reg, kRegisterOffsetFromCFA, offset, initialState);\n        _LIBUNWIND_TRACE_DWARF(\"DW_CFA_val_offset_sf(reg=%\" PRIu64 \", \"\n                               \"offset=%\" PRId64 \"\\n\",\n                               reg, offset);\n        break;\n      case DW_CFA_val_expression:\n        reg = addressSpace.getULEB128(p, instructionsEnd);\n        if (reg > kMaxRegisterNumber) {\n          _LIBUNWIND_LOG0(\n              \"malformed DW_CFA_val_expression DWARF unwind, reg too big\");\n          return false;\n        }\n        results->setRegister(reg, kRegisterIsExpression, (int64_t)p,\n                             initialState);\n        length = addressSpace.getULEB128(p, instructionsEnd);\n        assert(length < static_cast<pint_t>(~0) && \"pointer overflow\");\n        p += static_cast<pint_t>(length);\n        _LIBUNWIND_TRACE_DWARF(\"DW_CFA_val_expression(reg=%\" PRIu64 \", \"\n                               \"expression=0x%\" PRIx64 \", length=%\" PRIu64\n                               \")\\n\",\n                               reg, results->savedRegisters[reg].value, length);\n        break;\n      case DW_CFA_GNU_args_size:\n        length = addressSpace.getULEB128(p, instructionsEnd);\n        results->spExtraArgSize = (uint32_t)length;\n        _LIBUNWIND_TRACE_DWARF(\"DW_CFA_GNU_args_size(%\" PRIu64 \")\\n\", length);\n        break;\n      case DW_CFA_GNU_negative_offset_extended:\n        reg = addressSpace.getULEB128(p, instructionsEnd);\n        if (reg > kMaxRegisterNumber) {\n          _LIBUNWIND_LOG0(\"malformed DW_CFA_GNU_negative_offset_extended DWARF \"\n                          \"unwind, reg too big\");\n          return false;\n        }\n        offset = (int64_t)addressSpace.getULEB128(p, instructionsEnd) *\n                 cieInfo.dataAlignFactor;\n        results->setRegister(reg, kRegisterInCFA, -offset, initialState);\n        _LIBUNWIND_TRACE_DWARF(\n            \"DW_CFA_GNU_negative_offset_extended(%\" PRId64 \")\\n\", offset);\n        break;\n\n#if defined(_LIBUNWIND_TARGET_AARCH64) || defined(_LIBUNWIND_TARGET_SPARC)\n        // The same constant is used to represent different instructions on\n        // AArch64 (negate_ra_state) and SPARC (window_save).\n        static_assert(DW_CFA_AARCH64_negate_ra_state == DW_CFA_GNU_window_save,\n                      \"uses the same constant\");\n      case DW_CFA_AARCH64_negate_ra_state:\n        switch (arch) {\n#if defined(_LIBUNWIND_TARGET_AARCH64)\n        case REGISTERS_ARM64: {\n          int64_t value =\n              results->savedRegisters[UNW_ARM64_RA_SIGN_STATE].value ^ 0x1;\n          results->setRegisterValue(UNW_ARM64_RA_SIGN_STATE, value,\n                                    initialState);\n          _LIBUNWIND_TRACE_DWARF(\"DW_CFA_AARCH64_negate_ra_state\\n\");\n        } break;\n#endif\n\n#if defined(_LIBUNWIND_TARGET_SPARC)\n        // case DW_CFA_GNU_window_save:\n        case REGISTERS_SPARC:\n          _LIBUNWIND_TRACE_DWARF(\"DW_CFA_GNU_window_save()\\n\");\n          for (reg = UNW_SPARC_O0; reg <= UNW_SPARC_O7; reg++) {\n            results->setRegister(reg, kRegisterInRegister,\n                                 ((int64_t)reg - UNW_SPARC_O0) + UNW_SPARC_I0,\n                                 initialState);\n          }\n\n          for (reg = UNW_SPARC_L0; reg <= UNW_SPARC_I7; reg++) {\n            results->setRegister(reg, kRegisterInCFA,\n                                 ((int64_t)reg - UNW_SPARC_L0) * 4,\n                                 initialState);\n          }\n          break;\n#endif\n        }\n        break;\n#else\n        (void)arch;\n#endif\n\n      default:\n        operand = opcode & 0x3F;\n        switch (opcode & 0xC0) {\n        case DW_CFA_offset:\n          reg = operand;\n          if (reg > kMaxRegisterNumber) {\n            _LIBUNWIND_LOG(\"malformed DW_CFA_offset DWARF unwind, reg (%\" PRIu64\n                           \") out of range\",\n                           reg);\n            return false;\n          }\n          offset = (int64_t)addressSpace.getULEB128(p, instructionsEnd) *\n                   cieInfo.dataAlignFactor;\n          results->setRegister(reg, kRegisterInCFA, offset, initialState);\n          _LIBUNWIND_TRACE_DWARF(\"DW_CFA_offset(reg=%d, offset=%\" PRId64 \")\\n\",\n                                 operand, offset);\n          break;\n        case DW_CFA_advance_loc:\n          codeOffset += operand * cieInfo.codeAlignFactor;\n          _LIBUNWIND_TRACE_DWARF(\"DW_CFA_advance_loc: new offset=%\" PRIu64 \"\\n\",\n                                 static_cast<uint64_t>(codeOffset));\n          break;\n        case DW_CFA_restore:\n          reg = operand;\n          if (reg > kMaxRegisterNumber) {\n            _LIBUNWIND_LOG(\n                \"malformed DW_CFA_restore DWARF unwind, reg (%\" PRIu64\n                \") out of range\",\n                reg);\n            return false;\n          }\n          results->restoreRegisterToInitialState(reg, initialState);\n          _LIBUNWIND_TRACE_DWARF(\"DW_CFA_restore(reg=%\" PRIu64 \")\\n\",\n                                 static_cast<uint64_t>(operand));\n          break;\n        default:\n          _LIBUNWIND_TRACE_DWARF(\"unknown CFA opcode 0x%02X\\n\", opcode);\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n} // namespace libunwind\n\n#endif // __DWARF_PARSER_HPP__\n"}, "3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/libunwind/src/EHHeaderParser.hpp", "content": "//===------------------------- EHHeaderParser.hpp -------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//\n//  Parses ELF .eh_frame_hdr sections.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef __EHHEADERPARSER_HPP__\n#define __EHHEADERPARSER_HPP__\n\n#include \"libunwind.h\"\n\n#include \"DwarfParser.hpp\"\n\nnamespace libunwind {\n\n/// \\brief EHHeaderParser does basic parsing of an ELF .eh_frame_hdr section.\n///\n/// See DWARF spec for details:\n///    http://refspecs.linuxbase.org/LSB_3.1.0/LSB-Core-generic/LSB-Core-generic/ehframechpt.html\n///\ntemplate <typename A> class EHHeaderParser {\npublic:\n  typedef typename A::pint_t pint_t;\n\n  /// Information encoded in the EH frame header.\n  struct EHHeaderInfo {\n    pint_t eh_frame_ptr;\n    size_t fde_count;\n    pint_t table;\n    uint8_t table_enc;\n  };\n\n  static bool decodeEHHdr(A &addressSpace, pint_t ehHdrStart, pint_t ehHdrEnd,\n                          EHHeaderInfo &ehHdrInfo);\n  static bool findFDE(A &addressSpace, pint_t pc, pint_t ehHdrStart,\n                      uint32_t sectionLength,\n                      typename CFI_Parser<A>::FDE_Info *fdeInfo,\n                      typename CFI_Parser<A>::CIE_Info *cieInfo);\n\nprivate:\n  static bool decodeTableEntry(A &addressSpace, pint_t &tableEntry,\n                               pint_t ehHdrStart, pint_t ehHdrEnd,\n                               uint8_t tableEnc,\n                               typename CFI_Parser<A>::FDE_Info *fdeInfo,\n                               typename CFI_Parser<A>::CIE_Info *cieInfo);\n  static size_t getTableEntrySize(uint8_t tableEnc);\n};\n\ntemplate <typename A>\nbool EHHeaderParser<A>::decodeEHHdr(A &addressSpace, pint_t ehHdrStart,\n                                    pint_t ehHdrEnd, EHHeaderInfo &ehHdrInfo) {\n  pint_t p = ehHdrStart;\n  uint8_t version = addressSpace.get8(p++);\n  if (version != 1) {\n    _LIBUNWIND_LOG0(\"Unsupported .eh_frame_hdr version\");\n    return false;\n  }\n\n  uint8_t eh_frame_ptr_enc = addressSpace.get8(p++);\n  uint8_t fde_count_enc = addressSpace.get8(p++);\n  ehHdrInfo.table_enc = addressSpace.get8(p++);\n\n  ehHdrInfo.eh_frame_ptr =\n      addressSpace.getEncodedP(p, ehHdrEnd, eh_frame_ptr_enc, ehHdrStart);\n  ehHdrInfo.fde_count =\n      fde_count_enc == DW_EH_PE_omit\n          ? 0\n          : addressSpace.getEncodedP(p, ehHdrEnd, fde_count_enc, ehHdrStart);\n  ehHdrInfo.table = p;\n\n  return true;\n}\n\ntemplate <typename A>\nbool EHHeaderParser<A>::decodeTableEntry(\n    A &addressSpace, pint_t &tableEntry, pint_t ehHdrStart, pint_t ehHdrEnd,\n    uint8_t tableEnc, typename CFI_Parser<A>::FDE_Info *fdeInfo,\n    typename CFI_Parser<A>::CIE_Info *cieInfo) {\n  // Have to decode the whole FDE for the PC range anyway, so just throw away\n  // the PC start.\n  addressSpace.getEncodedP(tableEntry, ehHdrEnd, tableEnc, ehHdrStart);\n  pint_t fde =\n      addressSpace.getEncodedP(tableEntry, ehHdrEnd, tableEnc, ehHdrStart);\n  const char *message =\n      CFI_Parser<A>::decodeFDE(addressSpace, fde, fdeInfo, cieInfo);\n  if (message != NULL) {\n    _LIBUNWIND_DEBUG_LOG(\"EHHeaderParser::decodeTableEntry: bad fde: %s\",\n                         message);\n    return false;\n  }\n\n  return true;\n}\n\ntemplate <typename A>\nbool EHHeaderParser<A>::findFDE(A &addressSpace, pint_t pc, pint_t ehHdrStart,\n                                uint32_t sectionLength,\n                                typename CFI_Parser<A>::FDE_Info *fdeInfo,\n                                typename CFI_Parser<A>::CIE_Info *cieInfo) {\n  pint_t ehHdrEnd = ehHdrStart + sectionLength;\n\n  EHHeaderParser<A>::EHHeaderInfo hdrInfo;\n  if (!EHHeaderParser<A>::decodeEHHdr(addressSpace, ehHdrStart, ehHdrEnd,\n                                      hdrInfo))\n    return false;\n\n  if (hdrInfo.fde_count == 0) return false;\n\n  size_t tableEntrySize = getTableEntrySize(hdrInfo.table_enc);\n  pint_t tableEntry;\n\n  size_t low = 0;\n  for (size_t len = hdrInfo.fde_count; len > 1;) {\n    size_t mid = low + (len / 2);\n    tableEntry = hdrInfo.table + mid * tableEntrySize;\n    pint_t start = addressSpace.getEncodedP(tableEntry, ehHdrEnd,\n                                            hdrInfo.table_enc, ehHdrStart);\n\n    if (start == pc) {\n      low = mid;\n      break;\n    } else if (start < pc) {\n      low = mid;\n      len -= (len / 2);\n    } else {\n      len /= 2;\n    }\n  }\n\n  tableEntry = hdrInfo.table + low * tableEntrySize;\n  if (decodeTableEntry(addressSpace, tableEntry, ehHdrStart, ehHdrEnd,\n                       hdrInfo.table_enc, fdeInfo, cieInfo)) {\n    if (pc >= fdeInfo->pcStart && pc < fdeInfo->pcEnd)\n      return true;\n  }\n\n  return false;\n}\n\ntemplate <typename A>\nsize_t EHHeaderParser<A>::getTableEntrySize(uint8_t tableEnc) {\n  switch (tableEnc & 0x0f) {\n  case DW_EH_PE_sdata2:\n  case DW_EH_PE_udata2:\n    return 4;\n  case DW_EH_PE_sdata4:\n  case DW_EH_PE_udata4:\n    return 8;\n  case DW_EH_PE_sdata8:\n  case DW_EH_PE_udata8:\n    return 16;\n  case DW_EH_PE_sleb128:\n  case DW_EH_PE_uleb128:\n    _LIBUNWIND_ABORT(\"Can't binary search on variable length encoded data.\");\n  case DW_EH_PE_omit:\n    return 0;\n  default:\n    _LIBUNWIND_ABORT(\"Unknown DWARF encoding for search table.\");\n  }\n}\n\n}\n\n#endif\n"}, "4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/libunwind/src/RWMutex.hpp", "content": "//===----------------------------- Registers.hpp --------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//\n// Abstract interface to shared reader/writer log, hiding platform and\n// configuration differences.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef __RWMUTEX_HPP__\n#define __RWMUTEX_HPP__\n\n#if defined(_WIN32)\n#include <windows.h>\n#elif !defined(_LIBUNWIND_HAS_NO_THREADS)\n#include <pthread.h>\n#if defined(__ELF__) && defined(_LIBUNWIND_LINK_PTHREAD_LIB)\n#pragma comment(lib, \"pthread\")\n#endif\n#endif\n\nnamespace libunwind {\n\n#if defined(_LIBUNWIND_HAS_NO_THREADS)\n\nclass _LIBUNWIND_HIDDEN RWMutex {\npublic:\n  bool lock_shared() { return true; }\n  bool unlock_shared() { return true; }\n  bool lock() { return true; }\n  bool unlock() { return true; }\n};\n\n#elif defined(_WIN32)\n\nclass _LIBUNWIND_HIDDEN RWMutex {\npublic:\n  bool lock_shared() {\n    AcquireSRWLockShared(&_lock);\n    return true;\n  }\n  bool unlock_shared() {\n    ReleaseSRWLockShared(&_lock);\n    return true;\n  }\n  bool lock() {\n    AcquireSRWLockExclusive(&_lock);\n    return true;\n  }\n  bool unlock() {\n    ReleaseSRWLockExclusive(&_lock);\n    return true;\n  }\n\nprivate:\n  SRWLOCK _lock = SRWLOCK_INIT;\n};\n\n#elif !defined(LIBUNWIND_USE_WEAK_PTHREAD)\n\nclass _LIBUNWIND_HIDDEN RWMutex {\npublic:\n  bool lock_shared() { return pthread_rwlock_rdlock(&_lock) == 0;  }\n  bool unlock_shared() { return pthread_rwlock_unlock(&_lock) == 0; }\n  bool lock() { return pthread_rwlock_wrlock(&_lock) == 0; }\n  bool unlock() { return pthread_rwlock_unlock(&_lock) == 0; }\n\nprivate:\n  pthread_rwlock_t _lock = PTHREAD_RWLOCK_INITIALIZER;\n};\n\n#else\n\nextern \"C\" int __attribute__((weak))\npthread_create(pthread_t *thread, const pthread_attr_t *attr,\n               void *(*start_routine)(void *), void *arg);\nextern \"C\" int __attribute__((weak))\npthread_rwlock_rdlock(pthread_rwlock_t *lock);\nextern \"C\" int __attribute__((weak))\npthread_rwlock_wrlock(pthread_rwlock_t *lock);\nextern \"C\" int __attribute__((weak))\npthread_rwlock_unlock(pthread_rwlock_t *lock);\n\n// Calls to the locking functions are gated on pthread_create, and not the\n// functions themselves, because the data structure should only be locked if\n// another thread has been created. This is what similar libraries do.\n\nclass _LIBUNWIND_HIDDEN RWMutex {\npublic:\n  bool lock_shared() {\n    return !pthread_create || (pthread_rwlock_rdlock(&_lock) == 0);\n  }\n  bool unlock_shared() {\n    return !pthread_create || (pthread_rwlock_unlock(&_lock) == 0);\n  }\n  bool lock() {\n    return !pthread_create || (pthread_rwlock_wrlock(&_lock) == 0);\n  }\n  bool unlock() {\n    return !pthread_create || (pthread_rwlock_unlock(&_lock) == 0);\n  }\n\nprivate:\n  pthread_rwlock_t _lock = PTHREAD_RWLOCK_INITIALIZER;\n};\n\n#endif\n\n} // namespace libunwind\n\n#endif // __RWMUTEX_HPP__\n"}, "5": {"id": 5, "path": "/home/vsts/work/1/llvm-project/libunwind/src/Registers.hpp", "content": "//===----------------------------- Registers.hpp --------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//\n//  Models register sets for supported processors.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef __REGISTERS_HPP__\n#define __REGISTERS_HPP__\n\n#include <stdint.h>\n#include <string.h>\n\n#include \"libunwind.h\"\n#include \"config.h\"\n\nnamespace libunwind {\n\n// For emulating 128-bit registers\nstruct v128 { uint32_t vec[4]; };\n\nenum {\n  REGISTERS_X86,\n  REGISTERS_X86_64,\n  REGISTERS_PPC,\n  REGISTERS_PPC64,\n  REGISTERS_ARM64,\n  REGISTERS_ARM,\n  REGISTERS_OR1K,\n  REGISTERS_MIPS_O32,\n  REGISTERS_MIPS_NEWABI,\n  REGISTERS_SPARC,\n  REGISTERS_HEXAGON,\n  REGISTERS_RISCV,\n  REGISTERS_VE,\n};\n\n#if defined(_LIBUNWIND_TARGET_I386)\nclass _LIBUNWIND_HIDDEN Registers_x86;\nextern \"C\" void __libunwind_Registers_x86_jumpto(Registers_x86 *);\n/// Registers_x86 holds the register state of a thread in a 32-bit intel\n/// process.\nclass _LIBUNWIND_HIDDEN Registers_x86 {\npublic:\n  Registers_x86();\n  Registers_x86(const void *registers);\n\n  bool        validRegister(int num) const;\n  uint32_t    getRegister(int num) const;\n  void        setRegister(int num, uint32_t value);\n  bool        validFloatRegister(int) const { return false; }\n  double      getFloatRegister(int num) const;\n  void        setFloatRegister(int num, double value);\n  bool        validVectorRegister(int) const { return false; }\n  v128        getVectorRegister(int num) const;\n  void        setVectorRegister(int num, v128 value);\n  static const char *getRegisterName(int num);\n  void        jumpto() { __libunwind_Registers_x86_jumpto(this); }\n  static int  lastDwarfRegNum() { return _LIBUNWIND_HIGHEST_DWARF_REGISTER_X86; }\n  static int  getArch() { return REGISTERS_X86; }\n\n  uint32_t  getSP() const          { return _registers.__esp; }\n  void      setSP(uint32_t value)  { _registers.__esp = value; }\n  uint32_t  getIP() const          { return _registers.__eip; }\n  void      setIP(uint32_t value)  { _registers.__eip = value; }\n  uint32_t  getEBP() const         { return _registers.__ebp; }\n  void      setEBP(uint32_t value) { _registers.__ebp = value; }\n  uint32_t  getEBX() const         { return _registers.__ebx; }\n  void      setEBX(uint32_t value) { _registers.__ebx = value; }\n  uint32_t  getECX() const         { return _registers.__ecx; }\n  void      setECX(uint32_t value) { _registers.__ecx = value; }\n  uint32_t  getEDX() const         { return _registers.__edx; }\n  void      setEDX(uint32_t value) { _registers.__edx = value; }\n  uint32_t  getESI() const         { return _registers.__esi; }\n  void      setESI(uint32_t value) { _registers.__esi = value; }\n  uint32_t  getEDI() const         { return _registers.__edi; }\n  void      setEDI(uint32_t value) { _registers.__edi = value; }\n\nprivate:\n  struct GPRs {\n    unsigned int __eax;\n    unsigned int __ebx;\n    unsigned int __ecx;\n    unsigned int __edx;\n    unsigned int __edi;\n    unsigned int __esi;\n    unsigned int __ebp;\n    unsigned int __esp;\n    unsigned int __ss;\n    unsigned int __eflags;\n    unsigned int __eip;\n    unsigned int __cs;\n    unsigned int __ds;\n    unsigned int __es;\n    unsigned int __fs;\n    unsigned int __gs;\n  };\n\n  GPRs _registers;\n};\n\ninline Registers_x86::Registers_x86(const void *registers) {\n  static_assert((check_fit<Registers_x86, unw_context_t>::does_fit),\n                \"x86 registers do not fit into unw_context_t\");\n  memcpy(&_registers, registers, sizeof(_registers));\n}\n\ninline Registers_x86::Registers_x86() {\n  memset(&_registers, 0, sizeof(_registers));\n}\n\ninline bool Registers_x86::validRegister(int regNum) const {\n  if (regNum == UNW_REG_IP)\n    return true;\n  if (regNum == UNW_REG_SP)\n    return true;\n  if (regNum < 0)\n    return false;\n  if (regNum > 7)\n    return false;\n  return true;\n}\n\ninline uint32_t Registers_x86::getRegister(int regNum) const {\n  switch (regNum) {\n  case UNW_REG_IP:\n    return _registers.__eip;\n  case UNW_REG_SP:\n    return _registers.__esp;\n  case UNW_X86_EAX:\n    return _registers.__eax;\n  case UNW_X86_ECX:\n    return _registers.__ecx;\n  case UNW_X86_EDX:\n    return _registers.__edx;\n  case UNW_X86_EBX:\n    return _registers.__ebx;\n#if !defined(__APPLE__)\n  case UNW_X86_ESP:\n#else\n  case UNW_X86_EBP:\n#endif\n    return _registers.__ebp;\n#if !defined(__APPLE__)\n  case UNW_X86_EBP:\n#else\n  case UNW_X86_ESP:\n#endif\n    return _registers.__esp;\n  case UNW_X86_ESI:\n    return _registers.__esi;\n  case UNW_X86_EDI:\n    return _registers.__edi;\n  }\n  _LIBUNWIND_ABORT(\"unsupported x86 register\");\n}\n\ninline void Registers_x86::setRegister(int regNum, uint32_t value) {\n  switch (regNum) {\n  case UNW_REG_IP:\n    _registers.__eip = value;\n    return;\n  case UNW_REG_SP:\n    _registers.__esp = value;\n    return;\n  case UNW_X86_EAX:\n    _registers.__eax = value;\n    return;\n  case UNW_X86_ECX:\n    _registers.__ecx = value;\n    return;\n  case UNW_X86_EDX:\n    _registers.__edx = value;\n    return;\n  case UNW_X86_EBX:\n    _registers.__ebx = value;\n    return;\n#if !defined(__APPLE__)\n  case UNW_X86_ESP:\n#else\n  case UNW_X86_EBP:\n#endif\n    _registers.__ebp = value;\n    return;\n#if !defined(__APPLE__)\n  case UNW_X86_EBP:\n#else\n  case UNW_X86_ESP:\n#endif\n    _registers.__esp = value;\n    return;\n  case UNW_X86_ESI:\n    _registers.__esi = value;\n    return;\n  case UNW_X86_EDI:\n    _registers.__edi = value;\n    return;\n  }\n  _LIBUNWIND_ABORT(\"unsupported x86 register\");\n}\n\ninline const char *Registers_x86::getRegisterName(int regNum) {\n  switch (regNum) {\n  case UNW_REG_IP:\n    return \"ip\";\n  case UNW_REG_SP:\n    return \"esp\";\n  case UNW_X86_EAX:\n    return \"eax\";\n  case UNW_X86_ECX:\n    return \"ecx\";\n  case UNW_X86_EDX:\n    return \"edx\";\n  case UNW_X86_EBX:\n    return \"ebx\";\n  case UNW_X86_EBP:\n    return \"ebp\";\n  case UNW_X86_ESP:\n    return \"esp\";\n  case UNW_X86_ESI:\n    return \"esi\";\n  case UNW_X86_EDI:\n    return \"edi\";\n  default:\n    return \"unknown register\";\n  }\n}\n\ninline double Registers_x86::getFloatRegister(int) const {\n  _LIBUNWIND_ABORT(\"no x86 float registers\");\n}\n\ninline void Registers_x86::setFloatRegister(int, double) {\n  _LIBUNWIND_ABORT(\"no x86 float registers\");\n}\n\ninline v128 Registers_x86::getVectorRegister(int) const {\n  _LIBUNWIND_ABORT(\"no x86 vector registers\");\n}\n\ninline void Registers_x86::setVectorRegister(int, v128) {\n  _LIBUNWIND_ABORT(\"no x86 vector registers\");\n}\n#endif // _LIBUNWIND_TARGET_I386\n\n\n#if defined(_LIBUNWIND_TARGET_X86_64)\n/// Registers_x86_64  holds the register state of a thread in a 64-bit intel\n/// process.\nclass _LIBUNWIND_HIDDEN Registers_x86_64;\nextern \"C\" void __libunwind_Registers_x86_64_jumpto(Registers_x86_64 *);\nclass _LIBUNWIND_HIDDEN Registers_x86_64 {\npublic:\n  Registers_x86_64();\n  Registers_x86_64(const void *registers);\n\n  bool        validRegister(int num) const;\n  uint64_t    getRegister(int num) const;\n  void        setRegister(int num, uint64_t value);\n  bool        validFloatRegister(int) const { return false; }\n  double      getFloatRegister(int num) const;\n  void        setFloatRegister(int num, double value);\n  bool        validVectorRegister(int) const;\n  v128        getVectorRegister(int num) const;\n  void        setVectorRegister(int num, v128 value);\n  static const char *getRegisterName(int num);\n  void        jumpto() { __libunwind_Registers_x86_64_jumpto(this); }\n  static int  lastDwarfRegNum() { return _LIBUNWIND_HIGHEST_DWARF_REGISTER_X86_64; }\n  static int  getArch() { return REGISTERS_X86_64; }\n\n  uint64_t  getSP() const          { return _registers.__rsp; }\n  void      setSP(uint64_t value)  { _registers.__rsp = value; }\n  uint64_t  getIP() const          { return _registers.__rip; }\n  void      setIP(uint64_t value)  { _registers.__rip = value; }\n  uint64_t  getRBP() const         { return _registers.__rbp; }\n  void      setRBP(uint64_t value) { _registers.__rbp = value; }\n  uint64_t  getRBX() const         { return _registers.__rbx; }\n  void      setRBX(uint64_t value) { _registers.__rbx = value; }\n  uint64_t  getR12() const         { return _registers.__r12; }\n  void      setR12(uint64_t value) { _registers.__r12 = value; }\n  uint64_t  getR13() const         { return _registers.__r13; }\n  void      setR13(uint64_t value) { _registers.__r13 = value; }\n  uint64_t  getR14() const         { return _registers.__r14; }\n  void      setR14(uint64_t value) { _registers.__r14 = value; }\n  uint64_t  getR15() const         { return _registers.__r15; }\n  void      setR15(uint64_t value) { _registers.__r15 = value; }\n\nprivate:\n  struct GPRs {\n    uint64_t __rax;\n    uint64_t __rbx;\n    uint64_t __rcx;\n    uint64_t __rdx;\n    uint64_t __rdi;\n    uint64_t __rsi;\n    uint64_t __rbp;\n    uint64_t __rsp;\n    uint64_t __r8;\n    uint64_t __r9;\n    uint64_t __r10;\n    uint64_t __r11;\n    uint64_t __r12;\n    uint64_t __r13;\n    uint64_t __r14;\n    uint64_t __r15;\n    uint64_t __rip;\n    uint64_t __rflags;\n    uint64_t __cs;\n    uint64_t __fs;\n    uint64_t __gs;\n#if defined(_WIN64)\n    uint64_t __padding; // 16-byte align\n#endif\n  };\n  GPRs _registers;\n#if defined(_WIN64)\n  v128 _xmm[16];\n#endif\n};\n\ninline Registers_x86_64::Registers_x86_64(const void *registers) {\n  static_assert((check_fit<Registers_x86_64, unw_context_t>::does_fit),\n                \"x86_64 registers do not fit into unw_context_t\");\n  memcpy(&_registers, registers, sizeof(_registers));\n}\n\ninline Registers_x86_64::Registers_x86_64() {\n  memset(&_registers, 0, sizeof(_registers));\n}\n\ninline bool Registers_x86_64::validRegister(int regNum) const {\n  if (regNum == UNW_REG_IP)\n    return true;\n  if (regNum == UNW_REG_SP)\n    return true;\n  if (regNum < 0)\n    return false;\n  if (regNum > 15)\n    return false;\n  return true;\n}\n\ninline uint64_t Registers_x86_64::getRegister(int regNum) const {\n  switch (regNum) {\n  case UNW_REG_IP:\n    return _registers.__rip;\n  case UNW_REG_SP:\n    return _registers.__rsp;\n  case UNW_X86_64_RAX:\n    return _registers.__rax;\n  case UNW_X86_64_RDX:\n    return _registers.__rdx;\n  case UNW_X86_64_RCX:\n    return _registers.__rcx;\n  case UNW_X86_64_RBX:\n    return _registers.__rbx;\n  case UNW_X86_64_RSI:\n    return _registers.__rsi;\n  case UNW_X86_64_RDI:\n    return _registers.__rdi;\n  case UNW_X86_64_RBP:\n    return _registers.__rbp;\n  case UNW_X86_64_RSP:\n    return _registers.__rsp;\n  case UNW_X86_64_R8:\n    return _registers.__r8;\n  case UNW_X86_64_R9:\n    return _registers.__r9;\n  case UNW_X86_64_R10:\n    return _registers.__r10;\n  case UNW_X86_64_R11:\n    return _registers.__r11;\n  case UNW_X86_64_R12:\n    return _registers.__r12;\n  case UNW_X86_64_R13:\n    return _registers.__r13;\n  case UNW_X86_64_R14:\n    return _registers.__r14;\n  case UNW_X86_64_R15:\n    return _registers.__r15;\n  }\n  _LIBUNWIND_ABORT(\"unsupported x86_64 register\");\n}\n\ninline void Registers_x86_64::setRegister(int regNum, uint64_t value) {\n  switch (regNum) {\n  case UNW_REG_IP:\n    _registers.__rip = value;\n    return;\n  case UNW_REG_SP:\n    _registers.__rsp = value;\n    return;\n  case UNW_X86_64_RAX:\n    _registers.__rax = value;\n    return;\n  case UNW_X86_64_RDX:\n    _registers.__rdx = value;\n    return;\n  case UNW_X86_64_RCX:\n    _registers.__rcx = value;\n    return;\n  case UNW_X86_64_RBX:\n    _registers.__rbx = value;\n    return;\n  case UNW_X86_64_RSI:\n    _registers.__rsi = value;\n    return;\n  case UNW_X86_64_RDI:\n    _registers.__rdi = value;\n    return;\n  case UNW_X86_64_RBP:\n    _registers.__rbp = value;\n    return;\n  case UNW_X86_64_RSP:\n    _registers.__rsp = value;\n    return;\n  case UNW_X86_64_R8:\n    _registers.__r8 = value;\n    return;\n  case UNW_X86_64_R9:\n    _registers.__r9 = value;\n    return;\n  case UNW_X86_64_R10:\n    _registers.__r10 = value;\n    return;\n  case UNW_X86_64_R11:\n    _registers.__r11 = value;\n    return;\n  case UNW_X86_64_R12:\n    _registers.__r12 = value;\n    return;\n  case UNW_X86_64_R13:\n    _registers.__r13 = value;\n    return;\n  case UNW_X86_64_R14:\n    _registers.__r14 = value;\n    return;\n  case UNW_X86_64_R15:\n    _registers.__r15 = value;\n    return;\n  }\n  _LIBUNWIND_ABORT(\"unsupported x86_64 register\");\n}\n\ninline const char *Registers_x86_64::getRegisterName(int regNum) {\n  switch (regNum) {\n  case UNW_REG_IP:\n    return \"rip\";\n  case UNW_REG_SP:\n    return \"rsp\";\n  case UNW_X86_64_RAX:\n    return \"rax\";\n  case UNW_X86_64_RDX:\n    return \"rdx\";\n  case UNW_X86_64_RCX:\n    return \"rcx\";\n  case UNW_X86_64_RBX:\n    return \"rbx\";\n  case UNW_X86_64_RSI:\n    return \"rsi\";\n  case UNW_X86_64_RDI:\n    return \"rdi\";\n  case UNW_X86_64_RBP:\n    return \"rbp\";\n  case UNW_X86_64_RSP:\n    return \"rsp\";\n  case UNW_X86_64_R8:\n    return \"r8\";\n  case UNW_X86_64_R9:\n    return \"r9\";\n  case UNW_X86_64_R10:\n    return \"r10\";\n  case UNW_X86_64_R11:\n    return \"r11\";\n  case UNW_X86_64_R12:\n    return \"r12\";\n  case UNW_X86_64_R13:\n    return \"r13\";\n  case UNW_X86_64_R14:\n    return \"r14\";\n  case UNW_X86_64_R15:\n    return \"r15\";\n  case UNW_X86_64_XMM0:\n    return \"xmm0\";\n  case UNW_X86_64_XMM1:\n    return \"xmm1\";\n  case UNW_X86_64_XMM2:\n    return \"xmm2\";\n  case UNW_X86_64_XMM3:\n    return \"xmm3\";\n  case UNW_X86_64_XMM4:\n    return \"xmm4\";\n  case UNW_X86_64_XMM5:\n    return \"xmm5\";\n  case UNW_X86_64_XMM6:\n    return \"xmm6\";\n  case UNW_X86_64_XMM7:\n    return \"xmm7\";\n  case UNW_X86_64_XMM8:\n    return \"xmm8\";\n  case UNW_X86_64_XMM9:\n    return \"xmm9\";\n  case UNW_X86_64_XMM10:\n    return \"xmm10\";\n  case UNW_X86_64_XMM11:\n    return \"xmm11\";\n  case UNW_X86_64_XMM12:\n    return \"xmm12\";\n  case UNW_X86_64_XMM13:\n    return \"xmm13\";\n  case UNW_X86_64_XMM14:\n    return \"xmm14\";\n  case UNW_X86_64_XMM15:\n    return \"xmm15\";\n  default:\n    return \"unknown register\";\n  }\n}\n\ninline double Registers_x86_64::getFloatRegister(int) const {\n  _LIBUNWIND_ABORT(\"no x86_64 float registers\");\n}\n\ninline void Registers_x86_64::setFloatRegister(int, double) {\n  _LIBUNWIND_ABORT(\"no x86_64 float registers\");\n}\n\ninline bool Registers_x86_64::validVectorRegister(int regNum) const {\n#if defined(_WIN64)\n  if (regNum < UNW_X86_64_XMM0)\n    return false;\n  if (regNum > UNW_X86_64_XMM15)\n    return false;\n  return true;\n#else\n  (void)regNum; // suppress unused parameter warning\n  return false;\n#endif\n}\n\ninline v128 Registers_x86_64::getVectorRegister(int regNum) const {\n#if defined(_WIN64)\n  assert(validVectorRegister(regNum));\n  return _xmm[regNum - UNW_X86_64_XMM0];\n#else\n  (void)regNum; // suppress unused parameter warning\n  _LIBUNWIND_ABORT(\"no x86_64 vector registers\");\n#endif\n}\n\ninline void Registers_x86_64::setVectorRegister(int regNum, v128 value) {\n#if defined(_WIN64)\n  assert(validVectorRegister(regNum));\n  _xmm[regNum - UNW_X86_64_XMM0] = value;\n#else\n  (void)regNum; (void)value; // suppress unused parameter warnings\n  _LIBUNWIND_ABORT(\"no x86_64 vector registers\");\n#endif\n}\n#endif // _LIBUNWIND_TARGET_X86_64\n\n\n#if defined(_LIBUNWIND_TARGET_PPC)\n/// Registers_ppc holds the register state of a thread in a 32-bit PowerPC\n/// process.\nclass _LIBUNWIND_HIDDEN Registers_ppc {\npublic:\n  Registers_ppc();\n  Registers_ppc(const void *registers);\n\n  bool        validRegister(int num) const;\n  uint32_t    getRegister(int num) const;\n  void        setRegister(int num, uint32_t value);\n  bool        validFloatRegister(int num) const;\n  double      getFloatRegister(int num) const;\n  void        setFloatRegister(int num, double value);\n  bool        validVectorRegister(int num) const;\n  v128        getVectorRegister(int num) const;\n  void        setVectorRegister(int num, v128 value);\n  static const char *getRegisterName(int num);\n  void        jumpto();\n  static int  lastDwarfRegNum() { return _LIBUNWIND_HIGHEST_DWARF_REGISTER_PPC; }\n  static int  getArch() { return REGISTERS_PPC; }\n\n  uint64_t  getSP() const         { return _registers.__r1; }\n  void      setSP(uint32_t value) { _registers.__r1 = value; }\n  uint64_t  getIP() const         { return _registers.__srr0; }\n  void      setIP(uint32_t value) { _registers.__srr0 = value; }\n\nprivate:\n  struct ppc_thread_state_t {\n    unsigned int __srr0; /* Instruction address register (PC) */\n    unsigned int __srr1; /* Machine state register (supervisor) */\n    unsigned int __r0;\n    unsigned int __r1;\n    unsigned int __r2;\n    unsigned int __r3;\n    unsigned int __r4;\n    unsigned int __r5;\n    unsigned int __r6;\n    unsigned int __r7;\n    unsigned int __r8;\n    unsigned int __r9;\n    unsigned int __r10;\n    unsigned int __r11;\n    unsigned int __r12;\n    unsigned int __r13;\n    unsigned int __r14;\n    unsigned int __r15;\n    unsigned int __r16;\n    unsigned int __r17;\n    unsigned int __r18;\n    unsigned int __r19;\n    unsigned int __r20;\n    unsigned int __r21;\n    unsigned int __r22;\n    unsigned int __r23;\n    unsigned int __r24;\n    unsigned int __r25;\n    unsigned int __r26;\n    unsigned int __r27;\n    unsigned int __r28;\n    unsigned int __r29;\n    unsigned int __r30;\n    unsigned int __r31;\n    unsigned int __cr;     /* Condition register */\n    unsigned int __xer;    /* User's integer exception register */\n    unsigned int __lr;     /* Link register */\n    unsigned int __ctr;    /* Count register */\n    unsigned int __mq;     /* MQ register (601 only) */\n    unsigned int __vrsave; /* Vector Save Register */\n  };\n\n  struct ppc_float_state_t {\n    double __fpregs[32];\n\n    unsigned int __fpscr_pad; /* fpscr is 64 bits, 32 bits of rubbish */\n    unsigned int __fpscr;     /* floating point status register */\n  };\n\n  ppc_thread_state_t _registers;\n  ppc_float_state_t  _floatRegisters;\n  v128               _vectorRegisters[32]; // offset 424\n};\n\ninline Registers_ppc::Registers_ppc(const void *registers) {\n  static_assert((check_fit<Registers_ppc, unw_context_t>::does_fit),\n                \"ppc registers do not fit into unw_context_t\");\n  memcpy(&_registers, static_cast<const uint8_t *>(registers),\n         sizeof(_registers));\n  static_assert(sizeof(ppc_thread_state_t) == 160,\n                \"expected float register offset to be 160\");\n  memcpy(&_floatRegisters,\n         static_cast<const uint8_t *>(registers) + sizeof(ppc_thread_state_t),\n         sizeof(_floatRegisters));\n  static_assert(sizeof(ppc_thread_state_t) + sizeof(ppc_float_state_t) == 424,\n                \"expected vector register offset to be 424 bytes\");\n  memcpy(_vectorRegisters,\n         static_cast<const uint8_t *>(registers) + sizeof(ppc_thread_state_t) +\n             sizeof(ppc_float_state_t),\n         sizeof(_vectorRegisters));\n}\n\ninline Registers_ppc::Registers_ppc() {\n  memset(&_registers, 0, sizeof(_registers));\n  memset(&_floatRegisters, 0, sizeof(_floatRegisters));\n  memset(&_vectorRegisters, 0, sizeof(_vectorRegisters));\n}\n\ninline bool Registers_ppc::validRegister(int regNum) const {\n  if (regNum == UNW_REG_IP)\n    return true;\n  if (regNum == UNW_REG_SP)\n    return true;\n  if (regNum == UNW_PPC_VRSAVE)\n    return true;\n  if (regNum < 0)\n    return false;\n  if (regNum <= UNW_PPC_R31)\n    return true;\n  if (regNum == UNW_PPC_MQ)\n    return true;\n  if (regNum == UNW_PPC_LR)\n    return true;\n  if (regNum == UNW_PPC_CTR)\n    return true;\n  if ((UNW_PPC_CR0 <= regNum) && (regNum <= UNW_PPC_CR7))\n    return true;\n  return false;\n}\n\ninline uint32_t Registers_ppc::getRegister(int regNum) const {\n  switch (regNum) {\n  case UNW_REG_IP:\n    return _registers.__srr0;\n  case UNW_REG_SP:\n    return _registers.__r1;\n  case UNW_PPC_R0:\n    return _registers.__r0;\n  case UNW_PPC_R1:\n    return _registers.__r1;\n  case UNW_PPC_R2:\n    return _registers.__r2;\n  case UNW_PPC_R3:\n    return _registers.__r3;\n  case UNW_PPC_R4:\n    return _registers.__r4;\n  case UNW_PPC_R5:\n    return _registers.__r5;\n  case UNW_PPC_R6:\n    return _registers.__r6;\n  case UNW_PPC_R7:\n    return _registers.__r7;\n  case UNW_PPC_R8:\n    return _registers.__r8;\n  case UNW_PPC_R9:\n    return _registers.__r9;\n  case UNW_PPC_R10:\n    return _registers.__r10;\n  case UNW_PPC_R11:\n    return _registers.__r11;\n  case UNW_PPC_R12:\n    return _registers.__r12;\n  case UNW_PPC_R13:\n    return _registers.__r13;\n  case UNW_PPC_R14:\n    return _registers.__r14;\n  case UNW_PPC_R15:\n    return _registers.__r15;\n  case UNW_PPC_R16:\n    return _registers.__r16;\n  case UNW_PPC_R17:\n    return _registers.__r17;\n  case UNW_PPC_R18:\n    return _registers.__r18;\n  case UNW_PPC_R19:\n    return _registers.__r19;\n  case UNW_PPC_R20:\n    return _registers.__r20;\n  case UNW_PPC_R21:\n    return _registers.__r21;\n  case UNW_PPC_R22:\n    return _registers.__r22;\n  case UNW_PPC_R23:\n    return _registers.__r23;\n  case UNW_PPC_R24:\n    return _registers.__r24;\n  case UNW_PPC_R25:\n    return _registers.__r25;\n  case UNW_PPC_R26:\n    return _registers.__r26;\n  case UNW_PPC_R27:\n    return _registers.__r27;\n  case UNW_PPC_R28:\n    return _registers.__r28;\n  case UNW_PPC_R29:\n    return _registers.__r29;\n  case UNW_PPC_R30:\n    return _registers.__r30;\n  case UNW_PPC_R31:\n    return _registers.__r31;\n  case UNW_PPC_LR:\n    return _registers.__lr;\n  case UNW_PPC_CR0:\n    return (_registers.__cr & 0xF0000000);\n  case UNW_PPC_CR1:\n    return (_registers.__cr & 0x0F000000);\n  case UNW_PPC_CR2:\n    return (_registers.__cr & 0x00F00000);\n  case UNW_PPC_CR3:\n    return (_registers.__cr & 0x000F0000);\n  case UNW_PPC_CR4:\n    return (_registers.__cr & 0x0000F000);\n  case UNW_PPC_CR5:\n    return (_registers.__cr & 0x00000F00);\n  case UNW_PPC_CR6:\n    return (_registers.__cr & 0x000000F0);\n  case UNW_PPC_CR7:\n    return (_registers.__cr & 0x0000000F);\n  case UNW_PPC_VRSAVE:\n    return _registers.__vrsave;\n  }\n  _LIBUNWIND_ABORT(\"unsupported ppc register\");\n}\n\ninline void Registers_ppc::setRegister(int regNum, uint32_t value) {\n  //fprintf(stderr, \"Registers_ppc::setRegister(%d, 0x%08X)\\n\", regNum, value);\n  switch (regNum) {\n  case UNW_REG_IP:\n    _registers.__srr0 = value;\n    return;\n  case UNW_REG_SP:\n    _registers.__r1 = value;\n    return;\n  case UNW_PPC_R0:\n    _registers.__r0 = value;\n    return;\n  case UNW_PPC_R1:\n    _registers.__r1 = value;\n    return;\n  case UNW_PPC_R2:\n    _registers.__r2 = value;\n    return;\n  case UNW_PPC_R3:\n    _registers.__r3 = value;\n    return;\n  case UNW_PPC_R4:\n    _registers.__r4 = value;\n    return;\n  case UNW_PPC_R5:\n    _registers.__r5 = value;\n    return;\n  case UNW_PPC_R6:\n    _registers.__r6 = value;\n    return;\n  case UNW_PPC_R7:\n    _registers.__r7 = value;\n    return;\n  case UNW_PPC_R8:\n    _registers.__r8 = value;\n    return;\n  case UNW_PPC_R9:\n    _registers.__r9 = value;\n    return;\n  case UNW_PPC_R10:\n    _registers.__r10 = value;\n    return;\n  case UNW_PPC_R11:\n    _registers.__r11 = value;\n    return;\n  case UNW_PPC_R12:\n    _registers.__r12 = value;\n    return;\n  case UNW_PPC_R13:\n    _registers.__r13 = value;\n    return;\n  case UNW_PPC_R14:\n    _registers.__r14 = value;\n    return;\n  case UNW_PPC_R15:\n    _registers.__r15 = value;\n    return;\n  case UNW_PPC_R16:\n    _registers.__r16 = value;\n    return;\n  case UNW_PPC_R17:\n    _registers.__r17 = value;\n    return;\n  case UNW_PPC_R18:\n    _registers.__r18 = value;\n    return;\n  case UNW_PPC_R19:\n    _registers.__r19 = value;\n    return;\n  case UNW_PPC_R20:\n    _registers.__r20 = value;\n    return;\n  case UNW_PPC_R21:\n    _registers.__r21 = value;\n    return;\n  case UNW_PPC_R22:\n    _registers.__r22 = value;\n    return;\n  case UNW_PPC_R23:\n    _registers.__r23 = value;\n    return;\n  case UNW_PPC_R24:\n    _registers.__r24 = value;\n    return;\n  case UNW_PPC_R25:\n    _registers.__r25 = value;\n    return;\n  case UNW_PPC_R26:\n    _registers.__r26 = value;\n    return;\n  case UNW_PPC_R27:\n    _registers.__r27 = value;\n    return;\n  case UNW_PPC_R28:\n    _registers.__r28 = value;\n    return;\n  case UNW_PPC_R29:\n    _registers.__r29 = value;\n    return;\n  case UNW_PPC_R30:\n    _registers.__r30 = value;\n    return;\n  case UNW_PPC_R31:\n    _registers.__r31 = value;\n    return;\n  case UNW_PPC_MQ:\n    _registers.__mq = value;\n    return;\n  case UNW_PPC_LR:\n    _registers.__lr = value;\n    return;\n  case UNW_PPC_CTR:\n    _registers.__ctr = value;\n    return;\n  case UNW_PPC_CR0:\n    _registers.__cr &= 0x0FFFFFFF;\n    _registers.__cr |= (value & 0xF0000000);\n    return;\n  case UNW_PPC_CR1:\n    _registers.__cr &= 0xF0FFFFFF;\n    _registers.__cr |= (value & 0x0F000000);\n    return;\n  case UNW_PPC_CR2:\n    _registers.__cr &= 0xFF0FFFFF;\n    _registers.__cr |= (value & 0x00F00000);\n    return;\n  case UNW_PPC_CR3:\n    _registers.__cr &= 0xFFF0FFFF;\n    _registers.__cr |= (value & 0x000F0000);\n    return;\n  case UNW_PPC_CR4:\n    _registers.__cr &= 0xFFFF0FFF;\n    _registers.__cr |= (value & 0x0000F000);\n    return;\n  case UNW_PPC_CR5:\n    _registers.__cr &= 0xFFFFF0FF;\n    _registers.__cr |= (value & 0x00000F00);\n    return;\n  case UNW_PPC_CR6:\n    _registers.__cr &= 0xFFFFFF0F;\n    _registers.__cr |= (value & 0x000000F0);\n    return;\n  case UNW_PPC_CR7:\n    _registers.__cr &= 0xFFFFFFF0;\n    _registers.__cr |= (value & 0x0000000F);\n    return;\n  case UNW_PPC_VRSAVE:\n    _registers.__vrsave = value;\n    return;\n    // not saved\n    return;\n  case UNW_PPC_XER:\n    _registers.__xer = value;\n    return;\n  case UNW_PPC_AP:\n  case UNW_PPC_VSCR:\n  case UNW_PPC_SPEFSCR:\n    // not saved\n    return;\n  }\n  _LIBUNWIND_ABORT(\"unsupported ppc register\");\n}\n\ninline bool Registers_ppc::validFloatRegister(int regNum) const {\n  if (regNum < UNW_PPC_F0)\n    return false;\n  if (regNum > UNW_PPC_F31)\n    return false;\n  return true;\n}\n\ninline double Registers_ppc::getFloatRegister(int regNum) const {\n  assert(validFloatRegister(regNum));\n  return _floatRegisters.__fpregs[regNum - UNW_PPC_F0];\n}\n\ninline void Registers_ppc::setFloatRegister(int regNum, double value) {\n  assert(validFloatRegister(regNum));\n  _floatRegisters.__fpregs[regNum - UNW_PPC_F0] = value;\n}\n\ninline bool Registers_ppc::validVectorRegister(int regNum) const {\n  if (regNum < UNW_PPC_V0)\n    return false;\n  if (regNum > UNW_PPC_V31)\n    return false;\n  return true;\n}\n\ninline v128 Registers_ppc::getVectorRegister(int regNum) const {\n  assert(validVectorRegister(regNum));\n  v128 result = _vectorRegisters[regNum - UNW_PPC_V0];\n  return result;\n}\n\ninline void Registers_ppc::setVectorRegister(int regNum, v128 value) {\n  assert(validVectorRegister(regNum));\n  _vectorRegisters[regNum - UNW_PPC_V0] = value;\n}\n\ninline const char *Registers_ppc::getRegisterName(int regNum) {\n  switch (regNum) {\n  case UNW_REG_IP:\n    return \"ip\";\n  case UNW_REG_SP:\n    return \"sp\";\n  case UNW_PPC_R0:\n    return \"r0\";\n  case UNW_PPC_R1:\n    return \"r1\";\n  case UNW_PPC_R2:\n    return \"r2\";\n  case UNW_PPC_R3:\n    return \"r3\";\n  case UNW_PPC_R4:\n    return \"r4\";\n  case UNW_PPC_R5:\n    return \"r5\";\n  case UNW_PPC_R6:\n    return \"r6\";\n  case UNW_PPC_R7:\n    return \"r7\";\n  case UNW_PPC_R8:\n    return \"r8\";\n  case UNW_PPC_R9:\n    return \"r9\";\n  case UNW_PPC_R10:\n    return \"r10\";\n  case UNW_PPC_R11:\n    return \"r11\";\n  case UNW_PPC_R12:\n    return \"r12\";\n  case UNW_PPC_R13:\n    return \"r13\";\n  case UNW_PPC_R14:\n    return \"r14\";\n  case UNW_PPC_R15:\n    return \"r15\";\n  case UNW_PPC_R16:\n    return \"r16\";\n  case UNW_PPC_R17:\n    return \"r17\";\n  case UNW_PPC_R18:\n    return \"r18\";\n  case UNW_PPC_R19:\n    return \"r19\";\n  case UNW_PPC_R20:\n    return \"r20\";\n  case UNW_PPC_R21:\n    return \"r21\";\n  case UNW_PPC_R22:\n    return \"r22\";\n  case UNW_PPC_R23:\n    return \"r23\";\n  case UNW_PPC_R24:\n    return \"r24\";\n  case UNW_PPC_R25:\n    return \"r25\";\n  case UNW_PPC_R26:\n    return \"r26\";\n  case UNW_PPC_R27:\n    return \"r27\";\n  case UNW_PPC_R28:\n    return \"r28\";\n  case UNW_PPC_R29:\n    return \"r29\";\n  case UNW_PPC_R30:\n    return \"r30\";\n  case UNW_PPC_R31:\n    return \"r31\";\n  case UNW_PPC_F0:\n    return \"fp0\";\n  case UNW_PPC_F1:\n    return \"fp1\";\n  case UNW_PPC_F2:\n    return \"fp2\";\n  case UNW_PPC_F3:\n    return \"fp3\";\n  case UNW_PPC_F4:\n    return \"fp4\";\n  case UNW_PPC_F5:\n    return \"fp5\";\n  case UNW_PPC_F6:\n    return \"fp6\";\n  case UNW_PPC_F7:\n    return \"fp7\";\n  case UNW_PPC_F8:\n    return \"fp8\";\n  case UNW_PPC_F9:\n    return \"fp9\";\n  case UNW_PPC_F10:\n    return \"fp10\";\n  case UNW_PPC_F11:\n    return \"fp11\";\n  case UNW_PPC_F12:\n    return \"fp12\";\n  case UNW_PPC_F13:\n    return \"fp13\";\n  case UNW_PPC_F14:\n    return \"fp14\";\n  case UNW_PPC_F15:\n    return \"fp15\";\n  case UNW_PPC_F16:\n    return \"fp16\";\n  case UNW_PPC_F17:\n    return \"fp17\";\n  case UNW_PPC_F18:\n    return \"fp18\";\n  case UNW_PPC_F19:\n    return \"fp19\";\n  case UNW_PPC_F20:\n    return \"fp20\";\n  case UNW_PPC_F21:\n    return \"fp21\";\n  case UNW_PPC_F22:\n    return \"fp22\";\n  case UNW_PPC_F23:\n    return \"fp23\";\n  case UNW_PPC_F24:\n    return \"fp24\";\n  case UNW_PPC_F25:\n    return \"fp25\";\n  case UNW_PPC_F26:\n    return \"fp26\";\n  case UNW_PPC_F27:\n    return \"fp27\";\n  case UNW_PPC_F28:\n    return \"fp28\";\n  case UNW_PPC_F29:\n    return \"fp29\";\n  case UNW_PPC_F30:\n    return \"fp30\";\n  case UNW_PPC_F31:\n    return \"fp31\";\n  case UNW_PPC_LR:\n    return \"lr\";\n  default:\n    return \"unknown register\";\n  }\n\n}\n#endif // _LIBUNWIND_TARGET_PPC\n\n#if defined(_LIBUNWIND_TARGET_PPC64)\n/// Registers_ppc64 holds the register state of a thread in a 64-bit PowerPC\n/// process.\nclass _LIBUNWIND_HIDDEN Registers_ppc64 {\npublic:\n  Registers_ppc64();\n  Registers_ppc64(const void *registers);\n\n  bool        validRegister(int num) const;\n  uint64_t    getRegister(int num) const;\n  void        setRegister(int num, uint64_t value);\n  bool        validFloatRegister(int num) const;\n  double      getFloatRegister(int num) const;\n  void        setFloatRegister(int num, double value);\n  bool        validVectorRegister(int num) const;\n  v128        getVectorRegister(int num) const;\n  void        setVectorRegister(int num, v128 value);\n  static const char *getRegisterName(int num);\n  void        jumpto();\n  static int  lastDwarfRegNum() { return _LIBUNWIND_HIGHEST_DWARF_REGISTER_PPC64; }\n  static int  getArch() { return REGISTERS_PPC64; }\n\n  uint64_t  getSP() const         { return _registers.__r1; }\n  void      setSP(uint64_t value) { _registers.__r1 = value; }\n  uint64_t  getIP() const         { return _registers.__srr0; }\n  void      setIP(uint64_t value) { _registers.__srr0 = value; }\n\nprivate:\n  struct ppc64_thread_state_t {\n    uint64_t __srr0;    // Instruction address register (PC)\n    uint64_t __srr1;    // Machine state register (supervisor)\n    uint64_t __r0;\n    uint64_t __r1;\n    uint64_t __r2;\n    uint64_t __r3;\n    uint64_t __r4;\n    uint64_t __r5;\n    uint64_t __r6;\n    uint64_t __r7;\n    uint64_t __r8;\n    uint64_t __r9;\n    uint64_t __r10;\n    uint64_t __r11;\n    uint64_t __r12;\n    uint64_t __r13;\n    uint64_t __r14;\n    uint64_t __r15;\n    uint64_t __r16;\n    uint64_t __r17;\n    uint64_t __r18;\n    uint64_t __r19;\n    uint64_t __r20;\n    uint64_t __r21;\n    uint64_t __r22;\n    uint64_t __r23;\n    uint64_t __r24;\n    uint64_t __r25;\n    uint64_t __r26;\n    uint64_t __r27;\n    uint64_t __r28;\n    uint64_t __r29;\n    uint64_t __r30;\n    uint64_t __r31;\n    uint64_t __cr;      // Condition register\n    uint64_t __xer;     // User's integer exception register\n    uint64_t __lr;      // Link register\n    uint64_t __ctr;     // Count register\n    uint64_t __vrsave;  // Vector Save Register\n  };\n\n  union ppc64_vsr_t {\n    struct asfloat_s {\n      double f;\n      uint64_t v2;\n    } asfloat;\n    v128 v;\n  };\n\n  ppc64_thread_state_t _registers;\n  ppc64_vsr_t          _vectorScalarRegisters[64];\n\n  static int getVectorRegNum(int num);\n};\n\ninline Registers_ppc64::Registers_ppc64(const void *registers) {\n  static_assert((check_fit<Registers_ppc64, unw_context_t>::does_fit),\n                \"ppc64 registers do not fit into unw_context_t\");\n  memcpy(&_registers, static_cast<const uint8_t *>(registers),\n         sizeof(_registers));\n  static_assert(sizeof(_registers) == 312,\n                \"expected vector scalar register offset to be 312\");\n  memcpy(&_vectorScalarRegisters,\n         static_cast<const uint8_t *>(registers) + sizeof(_registers),\n         sizeof(_vectorScalarRegisters));\n  static_assert(sizeof(_registers) +\n                sizeof(_vectorScalarRegisters) == 1336,\n                \"expected vector register offset to be 1336 bytes\");\n}\n\ninline Registers_ppc64::Registers_ppc64() {\n  memset(&_registers, 0, sizeof(_registers));\n  memset(&_vectorScalarRegisters, 0, sizeof(_vectorScalarRegisters));\n}\n\ninline bool Registers_ppc64::validRegister(int regNum) const {\n  switch (regNum) {\n  case UNW_REG_IP:\n  case UNW_REG_SP:\n  case UNW_PPC64_XER:\n  case UNW_PPC64_LR:\n  case UNW_PPC64_CTR:\n  case UNW_PPC64_VRSAVE:\n      return true;\n  }\n\n  if (regNum >= UNW_PPC64_R0 && regNum <= UNW_PPC64_R31)\n    return true;\n  if (regNum >= UNW_PPC64_CR0 && regNum <= UNW_PPC64_CR7)\n    return true;\n\n  return false;\n}\n\ninline uint64_t Registers_ppc64::getRegister(int regNum) const {\n  switch (regNum) {\n  case UNW_REG_IP:\n    return _registers.__srr0;\n  case UNW_PPC64_R0:\n    return _registers.__r0;\n  case UNW_PPC64_R1:\n  case UNW_REG_SP:\n    return _registers.__r1;\n  case UNW_PPC64_R2:\n    return _registers.__r2;\n  case UNW_PPC64_R3:\n    return _registers.__r3;\n  case UNW_PPC64_R4:\n    return _registers.__r4;\n  case UNW_PPC64_R5:\n    return _registers.__r5;\n  case UNW_PPC64_R6:\n    return _registers.__r6;\n  case UNW_PPC64_R7:\n    return _registers.__r7;\n  case UNW_PPC64_R8:\n    return _registers.__r8;\n  case UNW_PPC64_R9:\n    return _registers.__r9;\n  case UNW_PPC64_R10:\n    return _registers.__r10;\n  case UNW_PPC64_R11:\n    return _registers.__r11;\n  case UNW_PPC64_R12:\n    return _registers.__r12;\n  case UNW_PPC64_R13:\n    return _registers.__r13;\n  case UNW_PPC64_R14:\n    return _registers.__r14;\n  case UNW_PPC64_R15:\n    return _registers.__r15;\n  case UNW_PPC64_R16:\n    return _registers.__r16;\n  case UNW_PPC64_R17:\n    return _registers.__r17;\n  case UNW_PPC64_R18:\n    return _registers.__r18;\n  case UNW_PPC64_R19:\n    return _registers.__r19;\n  case UNW_PPC64_R20:\n    return _registers.__r20;\n  case UNW_PPC64_R21:\n    return _registers.__r21;\n  case UNW_PPC64_R22:\n    return _registers.__r22;\n  case UNW_PPC64_R23:\n    return _registers.__r23;\n  case UNW_PPC64_R24:\n    return _registers.__r24;\n  case UNW_PPC64_R25:\n    return _registers.__r25;\n  case UNW_PPC64_R26:\n    return _registers.__r26;\n  case UNW_PPC64_R27:\n    return _registers.__r27;\n  case UNW_PPC64_R28:\n    return _registers.__r28;\n  case UNW_PPC64_R29:\n    return _registers.__r29;\n  case UNW_PPC64_R30:\n    return _registers.__r30;\n  case UNW_PPC64_R31:\n    return _registers.__r31;\n  case UNW_PPC64_CR0:\n    return (_registers.__cr & 0xF0000000);\n  case UNW_PPC64_CR1:\n    return (_registers.__cr & 0x0F000000);\n  case UNW_PPC64_CR2:\n    return (_registers.__cr & 0x00F00000);\n  case UNW_PPC64_CR3:\n    return (_registers.__cr & 0x000F0000);\n  case UNW_PPC64_CR4:\n    return (_registers.__cr & 0x0000F000);\n  case UNW_PPC64_CR5:\n    return (_registers.__cr & 0x00000F00);\n  case UNW_PPC64_CR6:\n    return (_registers.__cr & 0x000000F0);\n  case UNW_PPC64_CR7:\n    return (_registers.__cr & 0x0000000F);\n  case UNW_PPC64_XER:\n    return _registers.__xer;\n  case UNW_PPC64_LR:\n    return _registers.__lr;\n  case UNW_PPC64_CTR:\n    return _registers.__ctr;\n  case UNW_PPC64_VRSAVE:\n    return _registers.__vrsave;\n  }\n  _LIBUNWIND_ABORT(\"unsupported ppc64 register\");\n}\n\ninline void Registers_ppc64::setRegister(int regNum, uint64_t value) {\n  switch (regNum) {\n  case UNW_REG_IP:\n    _registers.__srr0 = value;\n    return;\n  case UNW_PPC64_R0:\n    _registers.__r0 = value;\n    return;\n  case UNW_PPC64_R1:\n  case UNW_REG_SP:\n    _registers.__r1 = value;\n    return;\n  case UNW_PPC64_R2:\n    _registers.__r2 = value;\n    return;\n  case UNW_PPC64_R3:\n    _registers.__r3 = value;\n    return;\n  case UNW_PPC64_R4:\n    _registers.__r4 = value;\n    return;\n  case UNW_PPC64_R5:\n    _registers.__r5 = value;\n    return;\n  case UNW_PPC64_R6:\n    _registers.__r6 = value;\n    return;\n  case UNW_PPC64_R7:\n    _registers.__r7 = value;\n    return;\n  case UNW_PPC64_R8:\n    _registers.__r8 = value;\n    return;\n  case UNW_PPC64_R9:\n    _registers.__r9 = value;\n    return;\n  case UNW_PPC64_R10:\n    _registers.__r10 = value;\n    return;\n  case UNW_PPC64_R11:\n    _registers.__r11 = value;\n    return;\n  case UNW_PPC64_R12:\n    _registers.__r12 = value;\n    return;\n  case UNW_PPC64_R13:\n    _registers.__r13 = value;\n    return;\n  case UNW_PPC64_R14:\n    _registers.__r14 = value;\n    return;\n  case UNW_PPC64_R15:\n    _registers.__r15 = value;\n    return;\n  case UNW_PPC64_R16:\n    _registers.__r16 = value;\n    return;\n  case UNW_PPC64_R17:\n    _registers.__r17 = value;\n    return;\n  case UNW_PPC64_R18:\n    _registers.__r18 = value;\n    return;\n  case UNW_PPC64_R19:\n    _registers.__r19 = value;\n    return;\n  case UNW_PPC64_R20:\n    _registers.__r20 = value;\n    return;\n  case UNW_PPC64_R21:\n    _registers.__r21 = value;\n    return;\n  case UNW_PPC64_R22:\n    _registers.__r22 = value;\n    return;\n  case UNW_PPC64_R23:\n    _registers.__r23 = value;\n    return;\n  case UNW_PPC64_R24:\n    _registers.__r24 = value;\n    return;\n  case UNW_PPC64_R25:\n    _registers.__r25 = value;\n    return;\n  case UNW_PPC64_R26:\n    _registers.__r26 = value;\n    return;\n  case UNW_PPC64_R27:\n    _registers.__r27 = value;\n    return;\n  case UNW_PPC64_R28:\n    _registers.__r28 = value;\n    return;\n  case UNW_PPC64_R29:\n    _registers.__r29 = value;\n    return;\n  case UNW_PPC64_R30:\n    _registers.__r30 = value;\n    return;\n  case UNW_PPC64_R31:\n    _registers.__r31 = value;\n    return;\n  case UNW_PPC64_CR0:\n    _registers.__cr &= 0x0FFFFFFF;\n    _registers.__cr |= (value & 0xF0000000);\n    return;\n  case UNW_PPC64_CR1:\n    _registers.__cr &= 0xF0FFFFFF;\n    _registers.__cr |= (value & 0x0F000000);\n    return;\n  case UNW_PPC64_CR2:\n    _registers.__cr &= 0xFF0FFFFF;\n    _registers.__cr |= (value & 0x00F00000);\n    return;\n  case UNW_PPC64_CR3:\n    _registers.__cr &= 0xFFF0FFFF;\n    _registers.__cr |= (value & 0x000F0000);\n    return;\n  case UNW_PPC64_CR4:\n    _registers.__cr &= 0xFFFF0FFF;\n    _registers.__cr |= (value & 0x0000F000);\n    return;\n  case UNW_PPC64_CR5:\n    _registers.__cr &= 0xFFFFF0FF;\n    _registers.__cr |= (value & 0x00000F00);\n    return;\n  case UNW_PPC64_CR6:\n    _registers.__cr &= 0xFFFFFF0F;\n    _registers.__cr |= (value & 0x000000F0);\n    return;\n  case UNW_PPC64_CR7:\n    _registers.__cr &= 0xFFFFFFF0;\n    _registers.__cr |= (value & 0x0000000F);\n    return;\n  case UNW_PPC64_XER:\n    _registers.__xer = value;\n    return;\n  case UNW_PPC64_LR:\n    _registers.__lr = value;\n    return;\n  case UNW_PPC64_CTR:\n    _registers.__ctr = value;\n    return;\n  case UNW_PPC64_VRSAVE:\n    _registers.__vrsave = value;\n    return;\n  }\n  _LIBUNWIND_ABORT(\"unsupported ppc64 register\");\n}\n\ninline bool Registers_ppc64::validFloatRegister(int regNum) const {\n  return regNum >= UNW_PPC64_F0 && regNum <= UNW_PPC64_F31;\n}\n\ninline double Registers_ppc64::getFloatRegister(int regNum) const {\n  assert(validFloatRegister(regNum));\n  return _vectorScalarRegisters[regNum - UNW_PPC64_F0].asfloat.f;\n}\n\ninline void Registers_ppc64::setFloatRegister(int regNum, double value) {\n  assert(validFloatRegister(regNum));\n  _vectorScalarRegisters[regNum - UNW_PPC64_F0].asfloat.f = value;\n}\n\ninline bool Registers_ppc64::validVectorRegister(int regNum) const {\n#if defined(__VSX__)\n  if (regNum >= UNW_PPC64_VS0 && regNum <= UNW_PPC64_VS31)\n    return true;\n  if (regNum >= UNW_PPC64_VS32 && regNum <= UNW_PPC64_VS63)\n    return true;\n#elif defined(__ALTIVEC__)\n  if (regNum >= UNW_PPC64_V0 && regNum <= UNW_PPC64_V31)\n    return true;\n#endif\n  return false;\n}\n\ninline int Registers_ppc64::getVectorRegNum(int num)\n{\n  if (num >= UNW_PPC64_VS0 && num <= UNW_PPC64_VS31)\n    return num - UNW_PPC64_VS0;\n  else\n    return num - UNW_PPC64_VS32 + 32;\n}\n\ninline v128 Registers_ppc64::getVectorRegister(int regNum) const {\n  assert(validVectorRegister(regNum));\n  return _vectorScalarRegisters[getVectorRegNum(regNum)].v;\n}\n\ninline void Registers_ppc64::setVectorRegister(int regNum, v128 value) {\n  assert(validVectorRegister(regNum));\n  _vectorScalarRegisters[getVectorRegNum(regNum)].v = value;\n}\n\ninline const char *Registers_ppc64::getRegisterName(int regNum) {\n  switch (regNum) {\n  case UNW_REG_IP:\n    return \"ip\";\n  case UNW_REG_SP:\n    return \"sp\";\n  case UNW_PPC64_R0:\n    return \"r0\";\n  case UNW_PPC64_R1:\n    return \"r1\";\n  case UNW_PPC64_R2:\n    return \"r2\";\n  case UNW_PPC64_R3:\n    return \"r3\";\n  case UNW_PPC64_R4:\n    return \"r4\";\n  case UNW_PPC64_R5:\n    return \"r5\";\n  case UNW_PPC64_R6:\n    return \"r6\";\n  case UNW_PPC64_R7:\n    return \"r7\";\n  case UNW_PPC64_R8:\n    return \"r8\";\n  case UNW_PPC64_R9:\n    return \"r9\";\n  case UNW_PPC64_R10:\n    return \"r10\";\n  case UNW_PPC64_R11:\n    return \"r11\";\n  case UNW_PPC64_R12:\n    return \"r12\";\n  case UNW_PPC64_R13:\n    return \"r13\";\n  case UNW_PPC64_R14:\n    return \"r14\";\n  case UNW_PPC64_R15:\n    return \"r15\";\n  case UNW_PPC64_R16:\n    return \"r16\";\n  case UNW_PPC64_R17:\n    return \"r17\";\n  case UNW_PPC64_R18:\n    return \"r18\";\n  case UNW_PPC64_R19:\n    return \"r19\";\n  case UNW_PPC64_R20:\n    return \"r20\";\n  case UNW_PPC64_R21:\n    return \"r21\";\n  case UNW_PPC64_R22:\n    return \"r22\";\n  case UNW_PPC64_R23:\n    return \"r23\";\n  case UNW_PPC64_R24:\n    return \"r24\";\n  case UNW_PPC64_R25:\n    return \"r25\";\n  case UNW_PPC64_R26:\n    return \"r26\";\n  case UNW_PPC64_R27:\n    return \"r27\";\n  case UNW_PPC64_R28:\n    return \"r28\";\n  case UNW_PPC64_R29:\n    return \"r29\";\n  case UNW_PPC64_R30:\n    return \"r30\";\n  case UNW_PPC64_R31:\n    return \"r31\";\n  case UNW_PPC64_CR0:\n    return \"cr0\";\n  case UNW_PPC64_CR1:\n    return \"cr1\";\n  case UNW_PPC64_CR2:\n    return \"cr2\";\n  case UNW_PPC64_CR3:\n    return \"cr3\";\n  case UNW_PPC64_CR4:\n    return \"cr4\";\n  case UNW_PPC64_CR5:\n    return \"cr5\";\n  case UNW_PPC64_CR6:\n    return \"cr6\";\n  case UNW_PPC64_CR7:\n    return \"cr7\";\n  case UNW_PPC64_XER:\n    return \"xer\";\n  case UNW_PPC64_LR:\n    return \"lr\";\n  case UNW_PPC64_CTR:\n    return \"ctr\";\n  case UNW_PPC64_VRSAVE:\n    return \"vrsave\";\n  case UNW_PPC64_F0:\n    return \"fp0\";\n  case UNW_PPC64_F1:\n    return \"fp1\";\n  case UNW_PPC64_F2:\n    return \"fp2\";\n  case UNW_PPC64_F3:\n    return \"fp3\";\n  case UNW_PPC64_F4:\n    return \"fp4\";\n  case UNW_PPC64_F5:\n    return \"fp5\";\n  case UNW_PPC64_F6:\n    return \"fp6\";\n  case UNW_PPC64_F7:\n    return \"fp7\";\n  case UNW_PPC64_F8:\n    return \"fp8\";\n  case UNW_PPC64_F9:\n    return \"fp9\";\n  case UNW_PPC64_F10:\n    return \"fp10\";\n  case UNW_PPC64_F11:\n    return \"fp11\";\n  case UNW_PPC64_F12:\n    return \"fp12\";\n  case UNW_PPC64_F13:\n    return \"fp13\";\n  case UNW_PPC64_F14:\n    return \"fp14\";\n  case UNW_PPC64_F15:\n    return \"fp15\";\n  case UNW_PPC64_F16:\n    return \"fp16\";\n  case UNW_PPC64_F17:\n    return \"fp17\";\n  case UNW_PPC64_F18:\n    return \"fp18\";\n  case UNW_PPC64_F19:\n    return \"fp19\";\n  case UNW_PPC64_F20:\n    return \"fp20\";\n  case UNW_PPC64_F21:\n    return \"fp21\";\n  case UNW_PPC64_F22:\n    return \"fp22\";\n  case UNW_PPC64_F23:\n    return \"fp23\";\n  case UNW_PPC64_F24:\n    return \"fp24\";\n  case UNW_PPC64_F25:\n    return \"fp25\";\n  case UNW_PPC64_F26:\n    return \"fp26\";\n  case UNW_PPC64_F27:\n    return \"fp27\";\n  case UNW_PPC64_F28:\n    return \"fp28\";\n  case UNW_PPC64_F29:\n    return \"fp29\";\n  case UNW_PPC64_F30:\n    return \"fp30\";\n  case UNW_PPC64_F31:\n    return \"fp31\";\n  case UNW_PPC64_V0:\n    return \"v0\";\n  case UNW_PPC64_V1:\n    return \"v1\";\n  case UNW_PPC64_V2:\n    return \"v2\";\n  case UNW_PPC64_V3:\n    return \"v3\";\n  case UNW_PPC64_V4:\n    return \"v4\";\n  case UNW_PPC64_V5:\n    return \"v5\";\n  case UNW_PPC64_V6:\n    return \"v6\";\n  case UNW_PPC64_V7:\n    return \"v7\";\n  case UNW_PPC64_V8:\n    return \"v8\";\n  case UNW_PPC64_V9:\n    return \"v9\";\n  case UNW_PPC64_V10:\n    return \"v10\";\n  case UNW_PPC64_V11:\n    return \"v11\";\n  case UNW_PPC64_V12:\n    return \"v12\";\n  case UNW_PPC64_V13:\n    return \"v13\";\n  case UNW_PPC64_V14:\n    return \"v14\";\n  case UNW_PPC64_V15:\n    return \"v15\";\n  case UNW_PPC64_V16:\n    return \"v16\";\n  case UNW_PPC64_V17:\n    return \"v17\";\n  case UNW_PPC64_V18:\n    return \"v18\";\n  case UNW_PPC64_V19:\n    return \"v19\";\n  case UNW_PPC64_V20:\n    return \"v20\";\n  case UNW_PPC64_V21:\n    return \"v21\";\n  case UNW_PPC64_V22:\n    return \"v22\";\n  case UNW_PPC64_V23:\n    return \"v23\";\n  case UNW_PPC64_V24:\n    return \"v24\";\n  case UNW_PPC64_V25:\n    return \"v25\";\n  case UNW_PPC64_V26:\n    return \"v26\";\n  case UNW_PPC64_V27:\n    return \"v27\";\n  case UNW_PPC64_V28:\n    return \"v28\";\n  case UNW_PPC64_V29:\n    return \"v29\";\n  case UNW_PPC64_V30:\n    return \"v30\";\n  case UNW_PPC64_V31:\n    return \"v31\";\n  }\n  return \"unknown register\";\n}\n#endif // _LIBUNWIND_TARGET_PPC64\n\n\n#if defined(_LIBUNWIND_TARGET_AARCH64)\n/// Registers_arm64  holds the register state of a thread in a 64-bit arm\n/// process.\nclass _LIBUNWIND_HIDDEN Registers_arm64;\nextern \"C\" void __libunwind_Registers_arm64_jumpto(Registers_arm64 *);\nclass _LIBUNWIND_HIDDEN Registers_arm64 {\npublic:\n  Registers_arm64();\n  Registers_arm64(const void *registers);\n\n  bool        validRegister(int num) const;\n  uint64_t    getRegister(int num) const;\n  void        setRegister(int num, uint64_t value);\n  bool        validFloatRegister(int num) const;\n  double      getFloatRegister(int num) const;\n  void        setFloatRegister(int num, double value);\n  bool        validVectorRegister(int num) const;\n  v128        getVectorRegister(int num) const;\n  void        setVectorRegister(int num, v128 value);\n  static const char *getRegisterName(int num);\n  void        jumpto() { __libunwind_Registers_arm64_jumpto(this); }\n  static int  lastDwarfRegNum() { return _LIBUNWIND_HIGHEST_DWARF_REGISTER_ARM64; }\n  static int  getArch() { return REGISTERS_ARM64; }\n\n  uint64_t  getSP() const         { return _registers.__sp; }\n  void      setSP(uint64_t value) { _registers.__sp = value; }\n  uint64_t  getIP() const         { return _registers.__pc; }\n  void      setIP(uint64_t value) { _registers.__pc = value; }\n  uint64_t  getFP() const         { return _registers.__fp; }\n  void      setFP(uint64_t value) { _registers.__fp = value; }\n\nprivate:\n  struct GPRs {\n    uint64_t __x[29]; // x0-x28\n    uint64_t __fp;    // Frame pointer x29\n    uint64_t __lr;    // Link register x30\n    uint64_t __sp;    // Stack pointer x31\n    uint64_t __pc;    // Program counter\n    uint64_t __ra_sign_state; // RA sign state register\n  };\n\n  GPRs    _registers;\n  double  _vectorHalfRegisters[32];\n  // Currently only the lower double in 128-bit vectore registers\n  // is perserved during unwinding.  We could define new register\n  // numbers (> 96) which mean whole vector registers, then this\n  // struct would need to change to contain whole vector registers.\n};\n\ninline Registers_arm64::Registers_arm64(const void *registers) {\n  static_assert((check_fit<Registers_arm64, unw_context_t>::does_fit),\n                \"arm64 registers do not fit into unw_context_t\");\n  memcpy(&_registers, registers, sizeof(_registers));\n  static_assert(sizeof(GPRs) == 0x110,\n                \"expected VFP registers to be at offset 272\");\n  memcpy(_vectorHalfRegisters,\n         static_cast<const uint8_t *>(registers) + sizeof(GPRs),\n         sizeof(_vectorHalfRegisters));\n}\n\ninline Registers_arm64::Registers_arm64() {\n  memset(&_registers, 0, sizeof(_registers));\n  memset(&_vectorHalfRegisters, 0, sizeof(_vectorHalfRegisters));\n}\n\ninline bool Registers_arm64::validRegister(int regNum) const {\n  if (regNum == UNW_REG_IP)\n    return true;\n  if (regNum == UNW_REG_SP)\n    return true;\n  if (regNum < 0)\n    return false;\n  if (regNum > 95)\n    return false;\n  if (regNum == UNW_ARM64_RA_SIGN_STATE)\n    return true;\n  if ((regNum > 32) && (regNum < 64))\n    return false;\n  return true;\n}\n\ninline uint64_t Registers_arm64::getRegister(int regNum) const {\n  if (regNum == UNW_REG_IP || regNum == UNW_ARM64_PC)\n    return _registers.__pc;\n  if (regNum == UNW_REG_SP || regNum == UNW_ARM64_SP)\n    return _registers.__sp;\n  if (regNum == UNW_ARM64_RA_SIGN_STATE)\n    return _registers.__ra_sign_state;\n  if (regNum == UNW_ARM64_FP)\n    return _registers.__fp;\n  if (regNum == UNW_ARM64_LR)\n    return _registers.__lr;\n  if ((regNum >= 0) && (regNum < 29))\n    return _registers.__x[regNum];\n  _LIBUNWIND_ABORT(\"unsupported arm64 register\");\n}\n\ninline void Registers_arm64::setRegister(int regNum, uint64_t value) {\n  if (regNum == UNW_REG_IP || regNum == UNW_ARM64_PC)\n    _registers.__pc = value;\n  else if (regNum == UNW_REG_SP || regNum == UNW_ARM64_SP)\n    _registers.__sp = value;\n  else if (regNum == UNW_ARM64_RA_SIGN_STATE)\n    _registers.__ra_sign_state = value;\n  else if (regNum == UNW_ARM64_FP)\n    _registers.__fp = value;\n  else if (regNum == UNW_ARM64_LR)\n    _registers.__lr = value;\n  else if ((regNum >= 0) && (regNum < 29))\n    _registers.__x[regNum] = value;\n  else\n    _LIBUNWIND_ABORT(\"unsupported arm64 register\");\n}\n\ninline const char *Registers_arm64::getRegisterName(int regNum) {\n  switch (regNum) {\n  case UNW_REG_IP:\n    return \"pc\";\n  case UNW_REG_SP:\n    return \"sp\";\n  case UNW_ARM64_X0:\n    return \"x0\";\n  case UNW_ARM64_X1:\n    return \"x1\";\n  case UNW_ARM64_X2:\n    return \"x2\";\n  case UNW_ARM64_X3:\n    return \"x3\";\n  case UNW_ARM64_X4:\n    return \"x4\";\n  case UNW_ARM64_X5:\n    return \"x5\";\n  case UNW_ARM64_X6:\n    return \"x6\";\n  case UNW_ARM64_X7:\n    return \"x7\";\n  case UNW_ARM64_X8:\n    return \"x8\";\n  case UNW_ARM64_X9:\n    return \"x9\";\n  case UNW_ARM64_X10:\n    return \"x10\";\n  case UNW_ARM64_X11:\n    return \"x11\";\n  case UNW_ARM64_X12:\n    return \"x12\";\n  case UNW_ARM64_X13:\n    return \"x13\";\n  case UNW_ARM64_X14:\n    return \"x14\";\n  case UNW_ARM64_X15:\n    return \"x15\";\n  case UNW_ARM64_X16:\n    return \"x16\";\n  case UNW_ARM64_X17:\n    return \"x17\";\n  case UNW_ARM64_X18:\n    return \"x18\";\n  case UNW_ARM64_X19:\n    return \"x19\";\n  case UNW_ARM64_X20:\n    return \"x20\";\n  case UNW_ARM64_X21:\n    return \"x21\";\n  case UNW_ARM64_X22:\n    return \"x22\";\n  case UNW_ARM64_X23:\n    return \"x23\";\n  case UNW_ARM64_X24:\n    return \"x24\";\n  case UNW_ARM64_X25:\n    return \"x25\";\n  case UNW_ARM64_X26:\n    return \"x26\";\n  case UNW_ARM64_X27:\n    return \"x27\";\n  case UNW_ARM64_X28:\n    return \"x28\";\n  case UNW_ARM64_FP:\n    return \"fp\";\n  case UNW_ARM64_LR:\n    return \"lr\";\n  case UNW_ARM64_SP:\n    return \"sp\";\n  case UNW_ARM64_PC:\n    return \"pc\";\n  case UNW_ARM64_D0:\n    return \"d0\";\n  case UNW_ARM64_D1:\n    return \"d1\";\n  case UNW_ARM64_D2:\n    return \"d2\";\n  case UNW_ARM64_D3:\n    return \"d3\";\n  case UNW_ARM64_D4:\n    return \"d4\";\n  case UNW_ARM64_D5:\n    return \"d5\";\n  case UNW_ARM64_D6:\n    return \"d6\";\n  case UNW_ARM64_D7:\n    return \"d7\";\n  case UNW_ARM64_D8:\n    return \"d8\";\n  case UNW_ARM64_D9:\n    return \"d9\";\n  case UNW_ARM64_D10:\n    return \"d10\";\n  case UNW_ARM64_D11:\n    return \"d11\";\n  case UNW_ARM64_D12:\n    return \"d12\";\n  case UNW_ARM64_D13:\n    return \"d13\";\n  case UNW_ARM64_D14:\n    return \"d14\";\n  case UNW_ARM64_D15:\n    return \"d15\";\n  case UNW_ARM64_D16:\n    return \"d16\";\n  case UNW_ARM64_D17:\n    return \"d17\";\n  case UNW_ARM64_D18:\n    return \"d18\";\n  case UNW_ARM64_D19:\n    return \"d19\";\n  case UNW_ARM64_D20:\n    return \"d20\";\n  case UNW_ARM64_D21:\n    return \"d21\";\n  case UNW_ARM64_D22:\n    return \"d22\";\n  case UNW_ARM64_D23:\n    return \"d23\";\n  case UNW_ARM64_D24:\n    return \"d24\";\n  case UNW_ARM64_D25:\n    return \"d25\";\n  case UNW_ARM64_D26:\n    return \"d26\";\n  case UNW_ARM64_D27:\n    return \"d27\";\n  case UNW_ARM64_D28:\n    return \"d28\";\n  case UNW_ARM64_D29:\n    return \"d29\";\n  case UNW_ARM64_D30:\n    return \"d30\";\n  case UNW_ARM64_D31:\n    return \"d31\";\n  default:\n    return \"unknown register\";\n  }\n}\n\ninline bool Registers_arm64::validFloatRegister(int regNum) const {\n  if (regNum < UNW_ARM64_D0)\n    return false;\n  if (regNum > UNW_ARM64_D31)\n    return false;\n  return true;\n}\n\ninline double Registers_arm64::getFloatRegister(int regNum) const {\n  assert(validFloatRegister(regNum));\n  return _vectorHalfRegisters[regNum - UNW_ARM64_D0];\n}\n\ninline void Registers_arm64::setFloatRegister(int regNum, double value) {\n  assert(validFloatRegister(regNum));\n  _vectorHalfRegisters[regNum - UNW_ARM64_D0] = value;\n}\n\ninline bool Registers_arm64::validVectorRegister(int) const {\n  return false;\n}\n\ninline v128 Registers_arm64::getVectorRegister(int) const {\n  _LIBUNWIND_ABORT(\"no arm64 vector register support yet\");\n}\n\ninline void Registers_arm64::setVectorRegister(int, v128) {\n  _LIBUNWIND_ABORT(\"no arm64 vector register support yet\");\n}\n#endif // _LIBUNWIND_TARGET_AARCH64\n\n#if defined(_LIBUNWIND_TARGET_ARM)\n/// Registers_arm holds the register state of a thread in a 32-bit arm\n/// process.\n///\n/// NOTE: Assumes VFPv3. On ARM processors without a floating point unit,\n/// this uses more memory than required.\nclass _LIBUNWIND_HIDDEN Registers_arm {\npublic:\n  Registers_arm();\n  Registers_arm(const void *registers);\n\n  bool        validRegister(int num) const;\n  uint32_t    getRegister(int num) const;\n  void        setRegister(int num, uint32_t value);\n  bool        validFloatRegister(int num) const;\n  unw_fpreg_t getFloatRegister(int num);\n  void        setFloatRegister(int num, unw_fpreg_t value);\n  bool        validVectorRegister(int num) const;\n  v128        getVectorRegister(int num) const;\n  void        setVectorRegister(int num, v128 value);\n  static const char *getRegisterName(int num);\n  void        jumpto() {\n    restoreSavedFloatRegisters();\n    restoreCoreAndJumpTo();\n  }\n  static int  lastDwarfRegNum() { return _LIBUNWIND_HIGHEST_DWARF_REGISTER_ARM; }\n  static int  getArch() { return REGISTERS_ARM; }\n\n  uint32_t  getSP() const         { return _registers.__sp; }\n  void      setSP(uint32_t value) { _registers.__sp = value; }\n  uint32_t  getIP() const         { return _registers.__pc; }\n  void      setIP(uint32_t value) { _registers.__pc = value; }\n\n  void saveVFPAsX() {\n    assert(_use_X_for_vfp_save || !_saved_vfp_d0_d15);\n    _use_X_for_vfp_save = true;\n  }\n\n  void restoreSavedFloatRegisters() {\n    if (_saved_vfp_d0_d15) {\n      if (_use_X_for_vfp_save)\n        restoreVFPWithFLDMX(_vfp_d0_d15_pad);\n      else\n        restoreVFPWithFLDMD(_vfp_d0_d15_pad);\n    }\n    if (_saved_vfp_d16_d31)\n      restoreVFPv3(_vfp_d16_d31);\n#if defined(__ARM_WMMX)\n    if (_saved_iwmmx)\n      restoreiWMMX(_iwmmx);\n    if (_saved_iwmmx_control)\n      restoreiWMMXControl(_iwmmx_control);\n#endif\n  }\n\nprivate:\n  struct GPRs {\n    uint32_t __r[13]; // r0-r12\n    uint32_t __sp;    // Stack pointer r13\n    uint32_t __lr;    // Link register r14\n    uint32_t __pc;    // Program counter r15\n  };\n\n  static void saveVFPWithFSTMD(void*);\n  static void saveVFPWithFSTMX(void*);\n  static void saveVFPv3(void*);\n  static void restoreVFPWithFLDMD(void*);\n  static void restoreVFPWithFLDMX(void*);\n  static void restoreVFPv3(void*);\n#if defined(__ARM_WMMX)\n  static void saveiWMMX(void*);\n  static void saveiWMMXControl(uint32_t*);\n  static void restoreiWMMX(void*);\n  static void restoreiWMMXControl(uint32_t*);\n#endif\n  void restoreCoreAndJumpTo();\n\n  // ARM registers\n  GPRs _registers;\n\n  // We save floating point registers lazily because we can't know ahead of\n  // time which ones are used. See EHABI #4.7.\n\n  // Whether D0-D15 are saved in the FTSMX instead of FSTMD format.\n  //\n  // See EHABI #7.5 that explains how matching instruction sequences for load\n  // and store need to be used to correctly restore the exact register bits.\n  bool _use_X_for_vfp_save;\n  // Whether VFP D0-D15 are saved.\n  bool _saved_vfp_d0_d15;\n  // Whether VFPv3 D16-D31 are saved.\n  bool _saved_vfp_d16_d31;\n  // VFP registers D0-D15, + padding if saved using FSTMX\n  unw_fpreg_t _vfp_d0_d15_pad[17];\n  // VFPv3 registers D16-D31, always saved using FSTMD\n  unw_fpreg_t _vfp_d16_d31[16];\n#if defined(__ARM_WMMX)\n  // Whether iWMMX data registers are saved.\n  bool _saved_iwmmx;\n  // Whether iWMMX control registers are saved.\n  mutable bool _saved_iwmmx_control;\n  // iWMMX registers\n  unw_fpreg_t _iwmmx[16];\n  // iWMMX control registers\n  mutable uint32_t _iwmmx_control[4];\n#endif\n};\n\ninline Registers_arm::Registers_arm(const void *registers)\n  : _use_X_for_vfp_save(false),\n    _saved_vfp_d0_d15(false),\n    _saved_vfp_d16_d31(false) {\n  static_assert((check_fit<Registers_arm, unw_context_t>::does_fit),\n                \"arm registers do not fit into unw_context_t\");\n  // See __unw_getcontext() note about data.\n  memcpy(&_registers, registers, sizeof(_registers));\n  memset(&_vfp_d0_d15_pad, 0, sizeof(_vfp_d0_d15_pad));\n  memset(&_vfp_d16_d31, 0, sizeof(_vfp_d16_d31));\n#if defined(__ARM_WMMX)\n  _saved_iwmmx = false;\n  _saved_iwmmx_control = false;\n  memset(&_iwmmx, 0, sizeof(_iwmmx));\n  memset(&_iwmmx_control, 0, sizeof(_iwmmx_control));\n#endif\n}\n\ninline Registers_arm::Registers_arm()\n  : _use_X_for_vfp_save(false),\n    _saved_vfp_d0_d15(false),\n    _saved_vfp_d16_d31(false) {\n  memset(&_registers, 0, sizeof(_registers));\n  memset(&_vfp_d0_d15_pad, 0, sizeof(_vfp_d0_d15_pad));\n  memset(&_vfp_d16_d31, 0, sizeof(_vfp_d16_d31));\n#if defined(__ARM_WMMX)\n  _saved_iwmmx = false;\n  _saved_iwmmx_control = false;\n  memset(&_iwmmx, 0, sizeof(_iwmmx));\n  memset(&_iwmmx_control, 0, sizeof(_iwmmx_control));\n#endif\n}\n\ninline bool Registers_arm::validRegister(int regNum) const {\n  // Returns true for all non-VFP registers supported by the EHABI\n  // virtual register set (VRS).\n  if (regNum == UNW_REG_IP)\n    return true;\n\n  if (regNum == UNW_REG_SP)\n    return true;\n\n  if (regNum >= UNW_ARM_R0 && regNum <= UNW_ARM_R15)\n    return true;\n\n#if defined(__ARM_WMMX)\n  if (regNum >= UNW_ARM_WC0 && regNum <= UNW_ARM_WC3)\n    return true;\n#endif\n\n  return false;\n}\n\ninline uint32_t Registers_arm::getRegister(int regNum) const {\n  if (regNum == UNW_REG_SP || regNum == UNW_ARM_SP)\n    return _registers.__sp;\n\n  if (regNum == UNW_ARM_LR)\n    return _registers.__lr;\n\n  if (regNum == UNW_REG_IP || regNum == UNW_ARM_IP)\n    return _registers.__pc;\n\n  if (regNum >= UNW_ARM_R0 && regNum <= UNW_ARM_R12)\n    return _registers.__r[regNum];\n\n#if defined(__ARM_WMMX)\n  if (regNum >= UNW_ARM_WC0 && regNum <= UNW_ARM_WC3) {\n    if (!_saved_iwmmx_control) {\n      _saved_iwmmx_control = true;\n      saveiWMMXControl(_iwmmx_control);\n    }\n    return _iwmmx_control[regNum - UNW_ARM_WC0];\n  }\n#endif\n\n  _LIBUNWIND_ABORT(\"unsupported arm register\");\n}\n\ninline void Registers_arm::setRegister(int regNum, uint32_t value) {\n  if (regNum == UNW_REG_SP || regNum == UNW_ARM_SP) {\n    _registers.__sp = value;\n    return;\n  }\n\n  if (regNum == UNW_ARM_LR) {\n    _registers.__lr = value;\n    return;\n  }\n\n  if (regNum == UNW_REG_IP || regNum == UNW_ARM_IP) {\n    _registers.__pc = value;\n    return;\n  }\n\n  if (regNum >= UNW_ARM_R0 && regNum <= UNW_ARM_R12) {\n    _registers.__r[regNum] = value;\n    return;\n  }\n\n#if defined(__ARM_WMMX)\n  if (regNum >= UNW_ARM_WC0 && regNum <= UNW_ARM_WC3) {\n    if (!_saved_iwmmx_control) {\n      _saved_iwmmx_control = true;\n      saveiWMMXControl(_iwmmx_control);\n    }\n    _iwmmx_control[regNum - UNW_ARM_WC0] = value;\n    return;\n  }\n#endif\n\n  _LIBUNWIND_ABORT(\"unsupported arm register\");\n}\n\ninline const char *Registers_arm::getRegisterName(int regNum) {\n  switch (regNum) {\n  case UNW_REG_IP:\n  case UNW_ARM_IP: // UNW_ARM_R15 is alias\n    return \"pc\";\n  case UNW_ARM_LR: // UNW_ARM_R14 is alias\n    return \"lr\";\n  case UNW_REG_SP:\n  case UNW_ARM_SP: // UNW_ARM_R13 is alias\n    return \"sp\";\n  case UNW_ARM_R0:\n    return \"r0\";\n  case UNW_ARM_R1:\n    return \"r1\";\n  case UNW_ARM_R2:\n    return \"r2\";\n  case UNW_ARM_R3:\n    return \"r3\";\n  case UNW_ARM_R4:\n    return \"r4\";\n  case UNW_ARM_R5:\n    return \"r5\";\n  case UNW_ARM_R6:\n    return \"r6\";\n  case UNW_ARM_R7:\n    return \"r7\";\n  case UNW_ARM_R8:\n    return \"r8\";\n  case UNW_ARM_R9:\n    return \"r9\";\n  case UNW_ARM_R10:\n    return \"r10\";\n  case UNW_ARM_R11:\n    return \"r11\";\n  case UNW_ARM_R12:\n    return \"r12\";\n  case UNW_ARM_S0:\n    return \"s0\";\n  case UNW_ARM_S1:\n    return \"s1\";\n  case UNW_ARM_S2:\n    return \"s2\";\n  case UNW_ARM_S3:\n    return \"s3\";\n  case UNW_ARM_S4:\n    return \"s4\";\n  case UNW_ARM_S5:\n    return \"s5\";\n  case UNW_ARM_S6:\n    return \"s6\";\n  case UNW_ARM_S7:\n    return \"s7\";\n  case UNW_ARM_S8:\n    return \"s8\";\n  case UNW_ARM_S9:\n    return \"s9\";\n  case UNW_ARM_S10:\n    return \"s10\";\n  case UNW_ARM_S11:\n    return \"s11\";\n  case UNW_ARM_S12:\n    return \"s12\";\n  case UNW_ARM_S13:\n    return \"s13\";\n  case UNW_ARM_S14:\n    return \"s14\";\n  case UNW_ARM_S15:\n    return \"s15\";\n  case UNW_ARM_S16:\n    return \"s16\";\n  case UNW_ARM_S17:\n    return \"s17\";\n  case UNW_ARM_S18:\n    return \"s18\";\n  case UNW_ARM_S19:\n    return \"s19\";\n  case UNW_ARM_S20:\n    return \"s20\";\n  case UNW_ARM_S21:\n    return \"s21\";\n  case UNW_ARM_S22:\n    return \"s22\";\n  case UNW_ARM_S23:\n    return \"s23\";\n  case UNW_ARM_S24:\n    return \"s24\";\n  case UNW_ARM_S25:\n    return \"s25\";\n  case UNW_ARM_S26:\n    return \"s26\";\n  case UNW_ARM_S27:\n    return \"s27\";\n  case UNW_ARM_S28:\n    return \"s28\";\n  case UNW_ARM_S29:\n    return \"s29\";\n  case UNW_ARM_S30:\n    return \"s30\";\n  case UNW_ARM_S31:\n    return \"s31\";\n  case UNW_ARM_D0:\n    return \"d0\";\n  case UNW_ARM_D1:\n    return \"d1\";\n  case UNW_ARM_D2:\n    return \"d2\";\n  case UNW_ARM_D3:\n    return \"d3\";\n  case UNW_ARM_D4:\n    return \"d4\";\n  case UNW_ARM_D5:\n    return \"d5\";\n  case UNW_ARM_D6:\n    return \"d6\";\n  case UNW_ARM_D7:\n    return \"d7\";\n  case UNW_ARM_D8:\n    return \"d8\";\n  case UNW_ARM_D9:\n    return \"d9\";\n  case UNW_ARM_D10:\n    return \"d10\";\n  case UNW_ARM_D11:\n    return \"d11\";\n  case UNW_ARM_D12:\n    return \"d12\";\n  case UNW_ARM_D13:\n    return \"d13\";\n  case UNW_ARM_D14:\n    return \"d14\";\n  case UNW_ARM_D15:\n    return \"d15\";\n  case UNW_ARM_D16:\n    return \"d16\";\n  case UNW_ARM_D17:\n    return \"d17\";\n  case UNW_ARM_D18:\n    return \"d18\";\n  case UNW_ARM_D19:\n    return \"d19\";\n  case UNW_ARM_D20:\n    return \"d20\";\n  case UNW_ARM_D21:\n    return \"d21\";\n  case UNW_ARM_D22:\n    return \"d22\";\n  case UNW_ARM_D23:\n    return \"d23\";\n  case UNW_ARM_D24:\n    return \"d24\";\n  case UNW_ARM_D25:\n    return \"d25\";\n  case UNW_ARM_D26:\n    return \"d26\";\n  case UNW_ARM_D27:\n    return \"d27\";\n  case UNW_ARM_D28:\n    return \"d28\";\n  case UNW_ARM_D29:\n    return \"d29\";\n  case UNW_ARM_D30:\n    return \"d30\";\n  case UNW_ARM_D31:\n    return \"d31\";\n  default:\n    return \"unknown register\";\n  }\n}\n\ninline bool Registers_arm::validFloatRegister(int regNum) const {\n  // NOTE: Consider the intel MMX registers floating points so the\n  // __unw_get_fpreg can be used to transmit the 64-bit data back.\n  return ((regNum >= UNW_ARM_D0) && (regNum <= UNW_ARM_D31))\n#if defined(__ARM_WMMX)\n      || ((regNum >= UNW_ARM_WR0) && (regNum <= UNW_ARM_WR15))\n#endif\n      ;\n}\n\ninline unw_fpreg_t Registers_arm::getFloatRegister(int regNum) {\n  if (regNum >= UNW_ARM_D0 && regNum <= UNW_ARM_D15) {\n    if (!_saved_vfp_d0_d15) {\n      _saved_vfp_d0_d15 = true;\n      if (_use_X_for_vfp_save)\n        saveVFPWithFSTMX(_vfp_d0_d15_pad);\n      else\n        saveVFPWithFSTMD(_vfp_d0_d15_pad);\n    }\n    return _vfp_d0_d15_pad[regNum - UNW_ARM_D0];\n  }\n\n  if (regNum >= UNW_ARM_D16 && regNum <= UNW_ARM_D31) {\n    if (!_saved_vfp_d16_d31) {\n      _saved_vfp_d16_d31 = true;\n      saveVFPv3(_vfp_d16_d31);\n    }\n    return _vfp_d16_d31[regNum - UNW_ARM_D16];\n  }\n\n#if defined(__ARM_WMMX)\n  if (regNum >= UNW_ARM_WR0 && regNum <= UNW_ARM_WR15) {\n    if (!_saved_iwmmx) {\n      _saved_iwmmx = true;\n      saveiWMMX(_iwmmx);\n    }\n    return _iwmmx[regNum - UNW_ARM_WR0];\n  }\n#endif\n\n  _LIBUNWIND_ABORT(\"Unknown ARM float register\");\n}\n\ninline void Registers_arm::setFloatRegister(int regNum, unw_fpreg_t value) {\n  if (regNum >= UNW_ARM_D0 && regNum <= UNW_ARM_D15) {\n    if (!_saved_vfp_d0_d15) {\n      _saved_vfp_d0_d15 = true;\n      if (_use_X_for_vfp_save)\n        saveVFPWithFSTMX(_vfp_d0_d15_pad);\n      else\n        saveVFPWithFSTMD(_vfp_d0_d15_pad);\n    }\n    _vfp_d0_d15_pad[regNum - UNW_ARM_D0] = value;\n    return;\n  }\n\n  if (regNum >= UNW_ARM_D16 && regNum <= UNW_ARM_D31) {\n    if (!_saved_vfp_d16_d31) {\n      _saved_vfp_d16_d31 = true;\n      saveVFPv3(_vfp_d16_d31);\n    }\n    _vfp_d16_d31[regNum - UNW_ARM_D16] = value;\n    return;\n  }\n\n#if defined(__ARM_WMMX)\n  if (regNum >= UNW_ARM_WR0 && regNum <= UNW_ARM_WR15) {\n    if (!_saved_iwmmx) {\n      _saved_iwmmx = true;\n      saveiWMMX(_iwmmx);\n    }\n    _iwmmx[regNum - UNW_ARM_WR0] = value;\n    return;\n  }\n#endif\n\n  _LIBUNWIND_ABORT(\"Unknown ARM float register\");\n}\n\ninline bool Registers_arm::validVectorRegister(int) const {\n  return false;\n}\n\ninline v128 Registers_arm::getVectorRegister(int) const {\n  _LIBUNWIND_ABORT(\"ARM vector support not implemented\");\n}\n\ninline void Registers_arm::setVectorRegister(int, v128) {\n  _LIBUNWIND_ABORT(\"ARM vector support not implemented\");\n}\n#endif // _LIBUNWIND_TARGET_ARM\n\n\n#if defined(_LIBUNWIND_TARGET_OR1K)\n/// Registers_or1k holds the register state of a thread in an OpenRISC1000\n/// process.\nclass _LIBUNWIND_HIDDEN Registers_or1k {\npublic:\n  Registers_or1k();\n  Registers_or1k(const void *registers);\n\n  bool        validRegister(int num) const;\n  uint32_t    getRegister(int num) const;\n  void        setRegister(int num, uint32_t value);\n  bool        validFloatRegister(int num) const;\n  double      getFloatRegister(int num) const;\n  void        setFloatRegister(int num, double value);\n  bool        validVectorRegister(int num) const;\n  v128        getVectorRegister(int num) const;\n  void        setVectorRegister(int num, v128 value);\n  static const char *getRegisterName(int num);\n  void        jumpto();\n  static int  lastDwarfRegNum() { return _LIBUNWIND_HIGHEST_DWARF_REGISTER_OR1K; }\n  static int  getArch() { return REGISTERS_OR1K; }\n\n  uint64_t  getSP() const         { return _registers.__r[1]; }\n  void      setSP(uint32_t value) { _registers.__r[1] = value; }\n  uint64_t  getIP() const         { return _registers.__pc; }\n  void      setIP(uint32_t value) { _registers.__pc = value; }\n\nprivate:\n  struct or1k_thread_state_t {\n    unsigned int __r[32]; // r0-r31\n    unsigned int __pc;    // Program counter\n    unsigned int __epcr;  // Program counter at exception\n  };\n\n  or1k_thread_state_t _registers;\n};\n\ninline Registers_or1k::Registers_or1k(const void *registers) {\n  static_assert((check_fit<Registers_or1k, unw_context_t>::does_fit),\n                \"or1k registers do not fit into unw_context_t\");\n  memcpy(&_registers, static_cast<const uint8_t *>(registers),\n         sizeof(_registers));\n}\n\ninline Registers_or1k::Registers_or1k() {\n  memset(&_registers, 0, sizeof(_registers));\n}\n\ninline bool Registers_or1k::validRegister(int regNum) const {\n  if (regNum == UNW_REG_IP)\n    return true;\n  if (regNum == UNW_REG_SP)\n    return true;\n  if (regNum < 0)\n    return false;\n  if (regNum <= UNW_OR1K_R31)\n    return true;\n  if (regNum == UNW_OR1K_EPCR)\n    return true;\n  return false;\n}\n\ninline uint32_t Registers_or1k::getRegister(int regNum) const {\n  if (regNum >= UNW_OR1K_R0 && regNum <= UNW_OR1K_R31)\n    return _registers.__r[regNum - UNW_OR1K_R0];\n\n  switch (regNum) {\n  case UNW_REG_IP:\n    return _registers.__pc;\n  case UNW_REG_SP:\n    return _registers.__r[1];\n  case UNW_OR1K_EPCR:\n    return _registers.__epcr;\n  }\n  _LIBUNWIND_ABORT(\"unsupported or1k register\");\n}\n\ninline void Registers_or1k::setRegister(int regNum, uint32_t value) {\n  if (regNum >= UNW_OR1K_R0 && regNum <= UNW_OR1K_R31) {\n    _registers.__r[regNum - UNW_OR1K_R0] = value;\n    return;\n  }\n\n  switch (regNum) {\n  case UNW_REG_IP:\n    _registers.__pc = value;\n    return;\n  case UNW_REG_SP:\n    _registers.__r[1] = value;\n    return;\n  case UNW_OR1K_EPCR:\n    _registers.__epcr = value;\n    return;\n  }\n  _LIBUNWIND_ABORT(\"unsupported or1k register\");\n}\n\ninline bool Registers_or1k::validFloatRegister(int /* regNum */) const {\n  return false;\n}\n\ninline double Registers_or1k::getFloatRegister(int /* regNum */) const {\n  _LIBUNWIND_ABORT(\"or1k float support not implemented\");\n}\n\ninline void Registers_or1k::setFloatRegister(int /* regNum */,\n                                             double /* value */) {\n  _LIBUNWIND_ABORT(\"or1k float support not implemented\");\n}\n\ninline bool Registers_or1k::validVectorRegister(int /* regNum */) const {\n  return false;\n}\n\ninline v128 Registers_or1k::getVectorRegister(int /* regNum */) const {\n  _LIBUNWIND_ABORT(\"or1k vector support not implemented\");\n}\n\ninline void Registers_or1k::setVectorRegister(int /* regNum */, v128 /* value */) {\n  _LIBUNWIND_ABORT(\"or1k vector support not implemented\");\n}\n\ninline const char *Registers_or1k::getRegisterName(int regNum) {\n  switch (regNum) {\n  case UNW_OR1K_R0:\n    return \"r0\";\n  case UNW_OR1K_R1:\n    return \"r1\";\n  case UNW_OR1K_R2:\n    return \"r2\";\n  case UNW_OR1K_R3:\n    return \"r3\";\n  case UNW_OR1K_R4:\n    return \"r4\";\n  case UNW_OR1K_R5:\n    return \"r5\";\n  case UNW_OR1K_R6:\n    return \"r6\";\n  case UNW_OR1K_R7:\n    return \"r7\";\n  case UNW_OR1K_R8:\n    return \"r8\";\n  case UNW_OR1K_R9:\n    return \"r9\";\n  case UNW_OR1K_R10:\n    return \"r10\";\n  case UNW_OR1K_R11:\n    return \"r11\";\n  case UNW_OR1K_R12:\n    return \"r12\";\n  case UNW_OR1K_R13:\n    return \"r13\";\n  case UNW_OR1K_R14:\n    return \"r14\";\n  case UNW_OR1K_R15:\n    return \"r15\";\n  case UNW_OR1K_R16:\n    return \"r16\";\n  case UNW_OR1K_R17:\n    return \"r17\";\n  case UNW_OR1K_R18:\n    return \"r18\";\n  case UNW_OR1K_R19:\n    return \"r19\";\n  case UNW_OR1K_R20:\n    return \"r20\";\n  case UNW_OR1K_R21:\n    return \"r21\";\n  case UNW_OR1K_R22:\n    return \"r22\";\n  case UNW_OR1K_R23:\n    return \"r23\";\n  case UNW_OR1K_R24:\n    return \"r24\";\n  case UNW_OR1K_R25:\n    return \"r25\";\n  case UNW_OR1K_R26:\n    return \"r26\";\n  case UNW_OR1K_R27:\n    return \"r27\";\n  case UNW_OR1K_R28:\n    return \"r28\";\n  case UNW_OR1K_R29:\n    return \"r29\";\n  case UNW_OR1K_R30:\n    return \"r30\";\n  case UNW_OR1K_R31:\n    return \"r31\";\n  case UNW_OR1K_EPCR:\n    return \"EPCR\";\n  default:\n    return \"unknown register\";\n  }\n\n}\n#endif // _LIBUNWIND_TARGET_OR1K\n\n#if defined(_LIBUNWIND_TARGET_MIPS_O32)\n/// Registers_mips_o32 holds the register state of a thread in a 32-bit MIPS\n/// process.\nclass _LIBUNWIND_HIDDEN Registers_mips_o32 {\npublic:\n  Registers_mips_o32();\n  Registers_mips_o32(const void *registers);\n\n  bool        validRegister(int num) const;\n  uint32_t    getRegister(int num) const;\n  void        setRegister(int num, uint32_t value);\n  bool        validFloatRegister(int num) const;\n  double      getFloatRegister(int num) const;\n  void        setFloatRegister(int num, double value);\n  bool        validVectorRegister(int num) const;\n  v128        getVectorRegister(int num) const;\n  void        setVectorRegister(int num, v128 value);\n  static const char *getRegisterName(int num);\n  void        jumpto();\n  static int  lastDwarfRegNum() { return _LIBUNWIND_HIGHEST_DWARF_REGISTER_MIPS; }\n  static int  getArch() { return REGISTERS_MIPS_O32; }\n\n  uint32_t  getSP() const         { return _registers.__r[29]; }\n  void      setSP(uint32_t value) { _registers.__r[29] = value; }\n  uint32_t  getIP() const         { return _registers.__pc; }\n  void      setIP(uint32_t value) { _registers.__pc = value; }\n\nprivate:\n  struct mips_o32_thread_state_t {\n    uint32_t __r[32];\n    uint32_t __pc;\n    uint32_t __hi;\n    uint32_t __lo;\n  };\n\n  mips_o32_thread_state_t _registers;\n#ifdef __mips_hard_float\n  /// O32 with 32-bit floating point registers only uses half of this\n  /// space.  However, using the same layout for 32-bit vs 64-bit\n  /// floating point registers results in a single context size for\n  /// O32 with hard float.\n  uint32_t _padding;\n  double _floats[32];\n#endif\n};\n\ninline Registers_mips_o32::Registers_mips_o32(const void *registers) {\n  static_assert((check_fit<Registers_mips_o32, unw_context_t>::does_fit),\n                \"mips_o32 registers do not fit into unw_context_t\");\n  memcpy(&_registers, static_cast<const uint8_t *>(registers),\n         sizeof(_registers));\n}\n\ninline Registers_mips_o32::Registers_mips_o32() {\n  memset(&_registers, 0, sizeof(_registers));\n}\n\ninline bool Registers_mips_o32::validRegister(int regNum) const {\n  if (regNum == UNW_REG_IP)\n    return true;\n  if (regNum == UNW_REG_SP)\n    return true;\n  if (regNum < 0)\n    return false;\n  if (regNum <= UNW_MIPS_R31)\n    return true;\n#if __mips_isa_rev != 6\n  if (regNum == UNW_MIPS_HI)\n    return true;\n  if (regNum == UNW_MIPS_LO)\n    return true;\n#endif\n#if defined(__mips_hard_float) && __mips_fpr == 32\n  if (regNum >= UNW_MIPS_F0 && regNum <= UNW_MIPS_F31)\n    return true;\n#endif\n  // FIXME: DSP accumulator registers, MSA registers\n  return false;\n}\n\ninline uint32_t Registers_mips_o32::getRegister(int regNum) const {\n  if (regNum >= UNW_MIPS_R0 && regNum <= UNW_MIPS_R31)\n    return _registers.__r[regNum - UNW_MIPS_R0];\n#if defined(__mips_hard_float) && __mips_fpr == 32\n  if (regNum >= UNW_MIPS_F0 && regNum <= UNW_MIPS_F31) {\n    uint32_t *p;\n\n    if (regNum % 2 == 0)\n      p = (uint32_t *)&_floats[regNum - UNW_MIPS_F0];\n    else\n      p = (uint32_t *)&_floats[(regNum - 1) - UNW_MIPS_F0] + 1;\n    return *p;\n  }\n#endif\n\n  switch (regNum) {\n  case UNW_REG_IP:\n    return _registers.__pc;\n  case UNW_REG_SP:\n    return _registers.__r[29];\n  case UNW_MIPS_HI:\n    return _registers.__hi;\n  case UNW_MIPS_LO:\n    return _registers.__lo;\n  }\n  _LIBUNWIND_ABORT(\"unsupported mips_o32 register\");\n}\n\ninline void Registers_mips_o32::setRegister(int regNum, uint32_t value) {\n  if (regNum >= UNW_MIPS_R0 && regNum <= UNW_MIPS_R31) {\n    _registers.__r[regNum - UNW_MIPS_R0] = value;\n    return;\n  }\n#if defined(__mips_hard_float) && __mips_fpr == 32\n  if (regNum >= UNW_MIPS_F0 && regNum <= UNW_MIPS_F31) {\n    uint32_t *p;\n\n    if (regNum % 2 == 0)\n      p = (uint32_t *)&_floats[regNum - UNW_MIPS_F0];\n    else\n      p = (uint32_t *)&_floats[(regNum - 1) - UNW_MIPS_F0] + 1;\n    *p = value;\n    return;\n  }\n#endif\n\n  switch (regNum) {\n  case UNW_REG_IP:\n    _registers.__pc = value;\n    return;\n  case UNW_REG_SP:\n    _registers.__r[29] = value;\n    return;\n  case UNW_MIPS_HI:\n    _registers.__hi = value;\n    return;\n  case UNW_MIPS_LO:\n    _registers.__lo = value;\n    return;\n  }\n  _LIBUNWIND_ABORT(\"unsupported mips_o32 register\");\n}\n\ninline bool Registers_mips_o32::validFloatRegister(int regNum) const {\n#if defined(__mips_hard_float) && __mips_fpr == 64\n  if (regNum >= UNW_MIPS_F0 && regNum <= UNW_MIPS_F31)\n    return true;\n#else\n  (void)regNum;\n#endif\n  return false;\n}\n\ninline double Registers_mips_o32::getFloatRegister(int regNum) const {\n#if defined(__mips_hard_float) && __mips_fpr == 64\n  assert(validFloatRegister(regNum));\n  return _floats[regNum - UNW_MIPS_F0];\n#else\n  (void)regNum;\n  _LIBUNWIND_ABORT(\"mips_o32 float support not implemented\");\n#endif\n}\n\ninline void Registers_mips_o32::setFloatRegister(int regNum,\n                                                 double value) {\n#if defined(__mips_hard_float) && __mips_fpr == 64\n  assert(validFloatRegister(regNum));\n  _floats[regNum - UNW_MIPS_F0] = value;\n#else\n  (void)regNum;\n  (void)value;\n  _LIBUNWIND_ABORT(\"mips_o32 float support not implemented\");\n#endif\n}\n\ninline bool Registers_mips_o32::validVectorRegister(int /* regNum */) const {\n  return false;\n}\n\ninline v128 Registers_mips_o32::getVectorRegister(int /* regNum */) const {\n  _LIBUNWIND_ABORT(\"mips_o32 vector support not implemented\");\n}\n\ninline void Registers_mips_o32::setVectorRegister(int /* regNum */, v128 /* value */) {\n  _LIBUNWIND_ABORT(\"mips_o32 vector support not implemented\");\n}\n\ninline const char *Registers_mips_o32::getRegisterName(int regNum) {\n  switch (regNum) {\n  case UNW_MIPS_R0:\n    return \"$0\";\n  case UNW_MIPS_R1:\n    return \"$1\";\n  case UNW_MIPS_R2:\n    return \"$2\";\n  case UNW_MIPS_R3:\n    return \"$3\";\n  case UNW_MIPS_R4:\n    return \"$4\";\n  case UNW_MIPS_R5:\n    return \"$5\";\n  case UNW_MIPS_R6:\n    return \"$6\";\n  case UNW_MIPS_R7:\n    return \"$7\";\n  case UNW_MIPS_R8:\n    return \"$8\";\n  case UNW_MIPS_R9:\n    return \"$9\";\n  case UNW_MIPS_R10:\n    return \"$10\";\n  case UNW_MIPS_R11:\n    return \"$11\";\n  case UNW_MIPS_R12:\n    return \"$12\";\n  case UNW_MIPS_R13:\n    return \"$13\";\n  case UNW_MIPS_R14:\n    return \"$14\";\n  case UNW_MIPS_R15:\n    return \"$15\";\n  case UNW_MIPS_R16:\n    return \"$16\";\n  case UNW_MIPS_R17:\n    return \"$17\";\n  case UNW_MIPS_R18:\n    return \"$18\";\n  case UNW_MIPS_R19:\n    return \"$19\";\n  case UNW_MIPS_R20:\n    return \"$20\";\n  case UNW_MIPS_R21:\n    return \"$21\";\n  case UNW_MIPS_R22:\n    return \"$22\";\n  case UNW_MIPS_R23:\n    return \"$23\";\n  case UNW_MIPS_R24:\n    return \"$24\";\n  case UNW_MIPS_R25:\n    return \"$25\";\n  case UNW_MIPS_R26:\n    return \"$26\";\n  case UNW_MIPS_R27:\n    return \"$27\";\n  case UNW_MIPS_R28:\n    return \"$28\";\n  case UNW_MIPS_R29:\n    return \"$29\";\n  case UNW_MIPS_R30:\n    return \"$30\";\n  case UNW_MIPS_R31:\n    return \"$31\";\n  case UNW_MIPS_F0:\n    return \"$f0\";\n  case UNW_MIPS_F1:\n    return \"$f1\";\n  case UNW_MIPS_F2:\n    return \"$f2\";\n  case UNW_MIPS_F3:\n    return \"$f3\";\n  case UNW_MIPS_F4:\n    return \"$f4\";\n  case UNW_MIPS_F5:\n    return \"$f5\";\n  case UNW_MIPS_F6:\n    return \"$f6\";\n  case UNW_MIPS_F7:\n    return \"$f7\";\n  case UNW_MIPS_F8:\n    return \"$f8\";\n  case UNW_MIPS_F9:\n    return \"$f9\";\n  case UNW_MIPS_F10:\n    return \"$f10\";\n  case UNW_MIPS_F11:\n    return \"$f11\";\n  case UNW_MIPS_F12:\n    return \"$f12\";\n  case UNW_MIPS_F13:\n    return \"$f13\";\n  case UNW_MIPS_F14:\n    return \"$f14\";\n  case UNW_MIPS_F15:\n    return \"$f15\";\n  case UNW_MIPS_F16:\n    return \"$f16\";\n  case UNW_MIPS_F17:\n    return \"$f17\";\n  case UNW_MIPS_F18:\n    return \"$f18\";\n  case UNW_MIPS_F19:\n    return \"$f19\";\n  case UNW_MIPS_F20:\n    return \"$f20\";\n  case UNW_MIPS_F21:\n    return \"$f21\";\n  case UNW_MIPS_F22:\n    return \"$f22\";\n  case UNW_MIPS_F23:\n    return \"$f23\";\n  case UNW_MIPS_F24:\n    return \"$f24\";\n  case UNW_MIPS_F25:\n    return \"$f25\";\n  case UNW_MIPS_F26:\n    return \"$f26\";\n  case UNW_MIPS_F27:\n    return \"$f27\";\n  case UNW_MIPS_F28:\n    return \"$f28\";\n  case UNW_MIPS_F29:\n    return \"$f29\";\n  case UNW_MIPS_F30:\n    return \"$f30\";\n  case UNW_MIPS_F31:\n    return \"$f31\";\n  case UNW_MIPS_HI:\n    return \"$hi\";\n  case UNW_MIPS_LO:\n    return \"$lo\";\n  default:\n    return \"unknown register\";\n  }\n}\n#endif // _LIBUNWIND_TARGET_MIPS_O32\n\n#if defined(_LIBUNWIND_TARGET_MIPS_NEWABI)\n/// Registers_mips_newabi holds the register state of a thread in a\n/// MIPS process using NEWABI (the N32 or N64 ABIs).\nclass _LIBUNWIND_HIDDEN Registers_mips_newabi {\npublic:\n  Registers_mips_newabi();\n  Registers_mips_newabi(const void *registers);\n\n  bool        validRegister(int num) const;\n  uint64_t    getRegister(int num) const;\n  void        setRegister(int num, uint64_t value);\n  bool        validFloatRegister(int num) const;\n  double      getFloatRegister(int num) const;\n  void        setFloatRegister(int num, double value);\n  bool        validVectorRegister(int num) const;\n  v128        getVectorRegister(int num) const;\n  void        setVectorRegister(int num, v128 value);\n  static const char *getRegisterName(int num);\n  void        jumpto();\n  static int  lastDwarfRegNum() { return _LIBUNWIND_HIGHEST_DWARF_REGISTER_MIPS; }\n  static int  getArch() { return REGISTERS_MIPS_NEWABI; }\n\n  uint64_t  getSP() const         { return _registers.__r[29]; }\n  void      setSP(uint64_t value) { _registers.__r[29] = value; }\n  uint64_t  getIP() const         { return _registers.__pc; }\n  void      setIP(uint64_t value) { _registers.__pc = value; }\n\nprivate:\n  struct mips_newabi_thread_state_t {\n    uint64_t __r[32];\n    uint64_t __pc;\n    uint64_t __hi;\n    uint64_t __lo;\n  };\n\n  mips_newabi_thread_state_t _registers;\n#ifdef __mips_hard_float\n  double _floats[32];\n#endif\n};\n\ninline Registers_mips_newabi::Registers_mips_newabi(const void *registers) {\n  static_assert((check_fit<Registers_mips_newabi, unw_context_t>::does_fit),\n                \"mips_newabi registers do not fit into unw_context_t\");\n  memcpy(&_registers, static_cast<const uint8_t *>(registers),\n         sizeof(_registers));\n}\n\ninline Registers_mips_newabi::Registers_mips_newabi() {\n  memset(&_registers, 0, sizeof(_registers));\n}\n\ninline bool Registers_mips_newabi::validRegister(int regNum) const {\n  if (regNum == UNW_REG_IP)\n    return true;\n  if (regNum == UNW_REG_SP)\n    return true;\n  if (regNum < 0)\n    return false;\n  if (regNum <= UNW_MIPS_R31)\n    return true;\n#if __mips_isa_rev != 6\n  if (regNum == UNW_MIPS_HI)\n    return true;\n  if (regNum == UNW_MIPS_LO)\n    return true;\n#endif\n  // FIXME: Hard float, DSP accumulator registers, MSA registers\n  return false;\n}\n\ninline uint64_t Registers_mips_newabi::getRegister(int regNum) const {\n  if (regNum >= UNW_MIPS_R0 && regNum <= UNW_MIPS_R31)\n    return _registers.__r[regNum - UNW_MIPS_R0];\n\n  switch (regNum) {\n  case UNW_REG_IP:\n    return _registers.__pc;\n  case UNW_REG_SP:\n    return _registers.__r[29];\n  case UNW_MIPS_HI:\n    return _registers.__hi;\n  case UNW_MIPS_LO:\n    return _registers.__lo;\n  }\n  _LIBUNWIND_ABORT(\"unsupported mips_newabi register\");\n}\n\ninline void Registers_mips_newabi::setRegister(int regNum, uint64_t value) {\n  if (regNum >= UNW_MIPS_R0 && regNum <= UNW_MIPS_R31) {\n    _registers.__r[regNum - UNW_MIPS_R0] = value;\n    return;\n  }\n\n  switch (regNum) {\n  case UNW_REG_IP:\n    _registers.__pc = value;\n    return;\n  case UNW_REG_SP:\n    _registers.__r[29] = value;\n    return;\n  case UNW_MIPS_HI:\n    _registers.__hi = value;\n    return;\n  case UNW_MIPS_LO:\n    _registers.__lo = value;\n    return;\n  }\n  _LIBUNWIND_ABORT(\"unsupported mips_newabi register\");\n}\n\ninline bool Registers_mips_newabi::validFloatRegister(int regNum) const {\n#ifdef __mips_hard_float\n  if (regNum >= UNW_MIPS_F0 && regNum <= UNW_MIPS_F31)\n    return true;\n#else\n  (void)regNum;\n#endif\n  return false;\n}\n\ninline double Registers_mips_newabi::getFloatRegister(int regNum) const {\n#ifdef __mips_hard_float\n  assert(validFloatRegister(regNum));\n  return _floats[regNum - UNW_MIPS_F0];\n#else\n  (void)regNum;\n  _LIBUNWIND_ABORT(\"mips_newabi float support not implemented\");\n#endif\n}\n\ninline void Registers_mips_newabi::setFloatRegister(int regNum,\n                                                    double value) {\n#ifdef __mips_hard_float\n  assert(validFloatRegister(regNum));\n  _floats[regNum - UNW_MIPS_F0] = value;\n#else\n  (void)regNum;\n  (void)value;\n  _LIBUNWIND_ABORT(\"mips_newabi float support not implemented\");\n#endif\n}\n\ninline bool Registers_mips_newabi::validVectorRegister(int /* regNum */) const {\n  return false;\n}\n\ninline v128 Registers_mips_newabi::getVectorRegister(int /* regNum */) const {\n  _LIBUNWIND_ABORT(\"mips_newabi vector support not implemented\");\n}\n\ninline void Registers_mips_newabi::setVectorRegister(int /* regNum */, v128 /* value */) {\n  _LIBUNWIND_ABORT(\"mips_newabi vector support not implemented\");\n}\n\ninline const char *Registers_mips_newabi::getRegisterName(int regNum) {\n  switch (regNum) {\n  case UNW_MIPS_R0:\n    return \"$0\";\n  case UNW_MIPS_R1:\n    return \"$1\";\n  case UNW_MIPS_R2:\n    return \"$2\";\n  case UNW_MIPS_R3:\n    return \"$3\";\n  case UNW_MIPS_R4:\n    return \"$4\";\n  case UNW_MIPS_R5:\n    return \"$5\";\n  case UNW_MIPS_R6:\n    return \"$6\";\n  case UNW_MIPS_R7:\n    return \"$7\";\n  case UNW_MIPS_R8:\n    return \"$8\";\n  case UNW_MIPS_R9:\n    return \"$9\";\n  case UNW_MIPS_R10:\n    return \"$10\";\n  case UNW_MIPS_R11:\n    return \"$11\";\n  case UNW_MIPS_R12:\n    return \"$12\";\n  case UNW_MIPS_R13:\n    return \"$13\";\n  case UNW_MIPS_R14:\n    return \"$14\";\n  case UNW_MIPS_R15:\n    return \"$15\";\n  case UNW_MIPS_R16:\n    return \"$16\";\n  case UNW_MIPS_R17:\n    return \"$17\";\n  case UNW_MIPS_R18:\n    return \"$18\";\n  case UNW_MIPS_R19:\n    return \"$19\";\n  case UNW_MIPS_R20:\n    return \"$20\";\n  case UNW_MIPS_R21:\n    return \"$21\";\n  case UNW_MIPS_R22:\n    return \"$22\";\n  case UNW_MIPS_R23:\n    return \"$23\";\n  case UNW_MIPS_R24:\n    return \"$24\";\n  case UNW_MIPS_R25:\n    return \"$25\";\n  case UNW_MIPS_R26:\n    return \"$26\";\n  case UNW_MIPS_R27:\n    return \"$27\";\n  case UNW_MIPS_R28:\n    return \"$28\";\n  case UNW_MIPS_R29:\n    return \"$29\";\n  case UNW_MIPS_R30:\n    return \"$30\";\n  case UNW_MIPS_R31:\n    return \"$31\";\n  case UNW_MIPS_F0:\n    return \"$f0\";\n  case UNW_MIPS_F1:\n    return \"$f1\";\n  case UNW_MIPS_F2:\n    return \"$f2\";\n  case UNW_MIPS_F3:\n    return \"$f3\";\n  case UNW_MIPS_F4:\n    return \"$f4\";\n  case UNW_MIPS_F5:\n    return \"$f5\";\n  case UNW_MIPS_F6:\n    return \"$f6\";\n  case UNW_MIPS_F7:\n    return \"$f7\";\n  case UNW_MIPS_F8:\n    return \"$f8\";\n  case UNW_MIPS_F9:\n    return \"$f9\";\n  case UNW_MIPS_F10:\n    return \"$f10\";\n  case UNW_MIPS_F11:\n    return \"$f11\";\n  case UNW_MIPS_F12:\n    return \"$f12\";\n  case UNW_MIPS_F13:\n    return \"$f13\";\n  case UNW_MIPS_F14:\n    return \"$f14\";\n  case UNW_MIPS_F15:\n    return \"$f15\";\n  case UNW_MIPS_F16:\n    return \"$f16\";\n  case UNW_MIPS_F17:\n    return \"$f17\";\n  case UNW_MIPS_F18:\n    return \"$f18\";\n  case UNW_MIPS_F19:\n    return \"$f19\";\n  case UNW_MIPS_F20:\n    return \"$f20\";\n  case UNW_MIPS_F21:\n    return \"$f21\";\n  case UNW_MIPS_F22:\n    return \"$f22\";\n  case UNW_MIPS_F23:\n    return \"$f23\";\n  case UNW_MIPS_F24:\n    return \"$f24\";\n  case UNW_MIPS_F25:\n    return \"$f25\";\n  case UNW_MIPS_F26:\n    return \"$f26\";\n  case UNW_MIPS_F27:\n    return \"$f27\";\n  case UNW_MIPS_F28:\n    return \"$f28\";\n  case UNW_MIPS_F29:\n    return \"$f29\";\n  case UNW_MIPS_F30:\n    return \"$f30\";\n  case UNW_MIPS_F31:\n    return \"$f31\";\n  case UNW_MIPS_HI:\n    return \"$hi\";\n  case UNW_MIPS_LO:\n    return \"$lo\";\n  default:\n    return \"unknown register\";\n  }\n}\n#endif // _LIBUNWIND_TARGET_MIPS_NEWABI\n\n#if defined(_LIBUNWIND_TARGET_SPARC)\n/// Registers_sparc holds the register state of a thread in a 32-bit Sparc\n/// process.\nclass _LIBUNWIND_HIDDEN Registers_sparc {\npublic:\n  Registers_sparc();\n  Registers_sparc(const void *registers);\n\n  bool        validRegister(int num) const;\n  uint32_t    getRegister(int num) const;\n  void        setRegister(int num, uint32_t value);\n  bool        validFloatRegister(int num) const;\n  double      getFloatRegister(int num) const;\n  void        setFloatRegister(int num, double value);\n  bool        validVectorRegister(int num) const;\n  v128        getVectorRegister(int num) const;\n  void        setVectorRegister(int num, v128 value);\n  static const char *getRegisterName(int num);\n  void        jumpto();\n  static int  lastDwarfRegNum() { return _LIBUNWIND_HIGHEST_DWARF_REGISTER_SPARC; }\n  static int  getArch() { return REGISTERS_SPARC; }\n\n  uint64_t  getSP() const         { return _registers.__regs[UNW_SPARC_O6]; }\n  void      setSP(uint32_t value) { _registers.__regs[UNW_SPARC_O6] = value; }\n  uint64_t  getIP() const         { return _registers.__regs[UNW_SPARC_O7]; }\n  void      setIP(uint32_t value) { _registers.__regs[UNW_SPARC_O7] = value; }\n\nprivate:\n  struct sparc_thread_state_t {\n    unsigned int __regs[32];\n  };\n\n  sparc_thread_state_t _registers;\n};\n\ninline Registers_sparc::Registers_sparc(const void *registers) {\n  static_assert((check_fit<Registers_sparc, unw_context_t>::does_fit),\n                \"sparc registers do not fit into unw_context_t\");\n  memcpy(&_registers, static_cast<const uint8_t *>(registers),\n         sizeof(_registers));\n}\n\ninline Registers_sparc::Registers_sparc() {\n  memset(&_registers, 0, sizeof(_registers));\n}\n\ninline bool Registers_sparc::validRegister(int regNum) const {\n  if (regNum == UNW_REG_IP)\n    return true;\n  if (regNum == UNW_REG_SP)\n    return true;\n  if (regNum < 0)\n    return false;\n  if (regNum <= UNW_SPARC_I7)\n    return true;\n  return false;\n}\n\ninline uint32_t Registers_sparc::getRegister(int regNum) const {\n  if ((UNW_SPARC_G0 <= regNum) && (regNum <= UNW_SPARC_I7)) {\n    return _registers.__regs[regNum];\n  }\n\n  switch (regNum) {\n  case UNW_REG_IP:\n    return _registers.__regs[UNW_SPARC_O7];\n  case UNW_REG_SP:\n    return _registers.__regs[UNW_SPARC_O6];\n  }\n  _LIBUNWIND_ABORT(\"unsupported sparc register\");\n}\n\ninline void Registers_sparc::setRegister(int regNum, uint32_t value) {\n  if ((UNW_SPARC_G0 <= regNum) && (regNum <= UNW_SPARC_I7)) {\n    _registers.__regs[regNum] = value;\n    return;\n  }\n\n  switch (regNum) {\n  case UNW_REG_IP:\n    _registers.__regs[UNW_SPARC_O7] = value;\n    return;\n  case UNW_REG_SP:\n    _registers.__regs[UNW_SPARC_O6] = value;\n    return;\n  }\n  _LIBUNWIND_ABORT(\"unsupported sparc register\");\n}\n\ninline bool Registers_sparc::validFloatRegister(int) const { return false; }\n\ninline double Registers_sparc::getFloatRegister(int) const {\n  _LIBUNWIND_ABORT(\"no Sparc float registers\");\n}\n\ninline void Registers_sparc::setFloatRegister(int, double) {\n  _LIBUNWIND_ABORT(\"no Sparc float registers\");\n}\n\ninline bool Registers_sparc::validVectorRegister(int) const { return false; }\n\ninline v128 Registers_sparc::getVectorRegister(int) const {\n  _LIBUNWIND_ABORT(\"no Sparc vector registers\");\n}\n\ninline void Registers_sparc::setVectorRegister(int, v128) {\n  _LIBUNWIND_ABORT(\"no Sparc vector registers\");\n}\n\ninline const char *Registers_sparc::getRegisterName(int regNum) {\n  switch (regNum) {\n  case UNW_REG_IP:\n    return \"pc\";\n  case UNW_SPARC_G0:\n    return \"g0\";\n  case UNW_SPARC_G1:\n    return \"g1\";\n  case UNW_SPARC_G2:\n    return \"g2\";\n  case UNW_SPARC_G3:\n    return \"g3\";\n  case UNW_SPARC_G4:\n    return \"g4\";\n  case UNW_SPARC_G5:\n    return \"g5\";\n  case UNW_SPARC_G6:\n    return \"g6\";\n  case UNW_SPARC_G7:\n    return \"g7\";\n  case UNW_SPARC_O0:\n    return \"o0\";\n  case UNW_SPARC_O1:\n    return \"o1\";\n  case UNW_SPARC_O2:\n    return \"o2\";\n  case UNW_SPARC_O3:\n    return \"o3\";\n  case UNW_SPARC_O4:\n    return \"o4\";\n  case UNW_SPARC_O5:\n    return \"o5\";\n  case UNW_REG_SP:\n  case UNW_SPARC_O6:\n    return \"sp\";\n  case UNW_SPARC_O7:\n    return \"o7\";\n  case UNW_SPARC_L0:\n    return \"l0\";\n  case UNW_SPARC_L1:\n    return \"l1\";\n  case UNW_SPARC_L2:\n    return \"l2\";\n  case UNW_SPARC_L3:\n    return \"l3\";\n  case UNW_SPARC_L4:\n    return \"l4\";\n  case UNW_SPARC_L5:\n    return \"l5\";\n  case UNW_SPARC_L6:\n    return \"l6\";\n  case UNW_SPARC_L7:\n    return \"l7\";\n  case UNW_SPARC_I0:\n    return \"i0\";\n  case UNW_SPARC_I1:\n    return \"i1\";\n  case UNW_SPARC_I2:\n    return \"i2\";\n  case UNW_SPARC_I3:\n    return \"i3\";\n  case UNW_SPARC_I4:\n    return \"i4\";\n  case UNW_SPARC_I5:\n    return \"i5\";\n  case UNW_SPARC_I6:\n    return \"fp\";\n  case UNW_SPARC_I7:\n    return \"i7\";\n  default:\n    return \"unknown register\";\n  }\n}\n#endif // _LIBUNWIND_TARGET_SPARC\n\n#if defined(_LIBUNWIND_TARGET_HEXAGON)\n/// Registers_hexagon holds the register state of a thread in a Hexagon QDSP6\n/// process.\nclass _LIBUNWIND_HIDDEN Registers_hexagon {\npublic:\n  Registers_hexagon();\n  Registers_hexagon(const void *registers);\n\n  bool        validRegister(int num) const;\n  uint32_t    getRegister(int num) const;\n  void        setRegister(int num, uint32_t value);\n  bool        validFloatRegister(int num) const;\n  double      getFloatRegister(int num) const;\n  void        setFloatRegister(int num, double value);\n  bool        validVectorRegister(int num) const;\n  v128        getVectorRegister(int num) const;\n  void        setVectorRegister(int num, v128 value);\n  const char *getRegisterName(int num);\n  void        jumpto();\n  static int  lastDwarfRegNum() { return _LIBUNWIND_HIGHEST_DWARF_REGISTER_HEXAGON; }\n  static int  getArch() { return REGISTERS_HEXAGON; }\n\n  uint32_t  getSP() const         { return _registers.__r[UNW_HEXAGON_R29]; }\n  void      setSP(uint32_t value) { _registers.__r[UNW_HEXAGON_R29] = value; }\n  uint32_t  getIP() const         { return _registers.__r[UNW_HEXAGON_PC]; }\n  void      setIP(uint32_t value) { _registers.__r[UNW_HEXAGON_PC] = value; }\n\nprivate:\n  struct hexagon_thread_state_t {\n    unsigned int __r[35];\n  };\n\n  hexagon_thread_state_t _registers;\n};\n\ninline Registers_hexagon::Registers_hexagon(const void *registers) {\n  static_assert((check_fit<Registers_hexagon, unw_context_t>::does_fit),\n                \"hexagon registers do not fit into unw_context_t\");\n  memcpy(&_registers, static_cast<const uint8_t *>(registers),\n         sizeof(_registers));\n}\n\ninline Registers_hexagon::Registers_hexagon() {\n  memset(&_registers, 0, sizeof(_registers));\n}\n\ninline bool Registers_hexagon::validRegister(int regNum) const {\n  if (regNum <= UNW_HEXAGON_R31)\n    return true;\n  return false;\n}\n\ninline uint32_t Registers_hexagon::getRegister(int regNum) const {\n  if (regNum >= UNW_HEXAGON_R0 && regNum <= UNW_HEXAGON_R31)\n    return _registers.__r[regNum - UNW_HEXAGON_R0];\n\n  switch (regNum) {\n  case UNW_REG_IP:\n    return _registers.__r[UNW_HEXAGON_PC];\n  case UNW_REG_SP:\n    return _registers.__r[UNW_HEXAGON_R29];\n  }\n  _LIBUNWIND_ABORT(\"unsupported hexagon register\");\n}\n\ninline void Registers_hexagon::setRegister(int regNum, uint32_t value) {\n  if (regNum >= UNW_HEXAGON_R0 && regNum <= UNW_HEXAGON_R31) {\n    _registers.__r[regNum - UNW_HEXAGON_R0] = value;\n    return;\n  }\n\n  switch (regNum) {\n  case UNW_REG_IP:\n    _registers.__r[UNW_HEXAGON_PC] = value;\n    return;\n  case UNW_REG_SP:\n    _registers.__r[UNW_HEXAGON_R29] = value;\n    return;\n  }\n  _LIBUNWIND_ABORT(\"unsupported hexagon register\");\n}\n\ninline bool Registers_hexagon::validFloatRegister(int /* regNum */) const {\n  return false;\n}\n\ninline double Registers_hexagon::getFloatRegister(int /* regNum */) const {\n  _LIBUNWIND_ABORT(\"hexagon float support not implemented\");\n}\n\ninline void Registers_hexagon::setFloatRegister(int /* regNum */,\n                                             double /* value */) {\n  _LIBUNWIND_ABORT(\"hexagon float support not implemented\");\n}\n\ninline bool Registers_hexagon::validVectorRegister(int /* regNum */) const {\n  return false;\n}\n\ninline v128 Registers_hexagon::getVectorRegister(int /* regNum */) const {\n  _LIBUNWIND_ABORT(\"hexagon vector support not implemented\");\n}\n\ninline void Registers_hexagon::setVectorRegister(int /* regNum */, v128 /* value */) {\n  _LIBUNWIND_ABORT(\"hexagon vector support not implemented\");\n}\n\ninline const char *Registers_hexagon::getRegisterName(int regNum) {\n  switch (regNum) {\n  case UNW_HEXAGON_R0:\n    return \"r0\";\n  case UNW_HEXAGON_R1:\n    return \"r1\";\n  case UNW_HEXAGON_R2:\n    return \"r2\";\n  case UNW_HEXAGON_R3:\n    return \"r3\";\n  case UNW_HEXAGON_R4:\n    return \"r4\";\n  case UNW_HEXAGON_R5:\n    return \"r5\";\n  case UNW_HEXAGON_R6:\n    return \"r6\";\n  case UNW_HEXAGON_R7:\n    return \"r7\";\n  case UNW_HEXAGON_R8:\n    return \"r8\";\n  case UNW_HEXAGON_R9:\n    return \"r9\";\n  case UNW_HEXAGON_R10:\n    return \"r10\";\n  case UNW_HEXAGON_R11:\n    return \"r11\";\n  case UNW_HEXAGON_R12:\n    return \"r12\";\n  case UNW_HEXAGON_R13:\n    return \"r13\";\n  case UNW_HEXAGON_R14:\n    return \"r14\";\n  case UNW_HEXAGON_R15:\n    return \"r15\";\n  case UNW_HEXAGON_R16:\n    return \"r16\";\n  case UNW_HEXAGON_R17:\n    return \"r17\";\n  case UNW_HEXAGON_R18:\n    return \"r18\";\n  case UNW_HEXAGON_R19:\n    return \"r19\";\n  case UNW_HEXAGON_R20:\n    return \"r20\";\n  case UNW_HEXAGON_R21:\n    return \"r21\";\n  case UNW_HEXAGON_R22:\n    return \"r22\";\n  case UNW_HEXAGON_R23:\n    return \"r23\";\n  case UNW_HEXAGON_R24:\n    return \"r24\";\n  case UNW_HEXAGON_R25:\n    return \"r25\";\n  case UNW_HEXAGON_R26:\n    return \"r26\";\n  case UNW_HEXAGON_R27:\n    return \"r27\";\n  case UNW_HEXAGON_R28:\n    return \"r28\";\n  case UNW_HEXAGON_R29:\n    return \"r29\";\n  case UNW_HEXAGON_R30:\n    return \"r30\";\n  case UNW_HEXAGON_R31:\n    return \"r31\";\n  default:\n    return \"unknown register\";\n  }\n\n}\n#endif // _LIBUNWIND_TARGET_HEXAGON\n\n\n#if defined(_LIBUNWIND_TARGET_RISCV)\n/// Registers_riscv holds the register state of a thread in a RISC-V\n/// process.\n\n// This check makes it safe when LIBUNWIND_ENABLE_CROSS_UNWINDING enabled.\n# ifdef __riscv\n#  if __riscv_xlen == 32\ntypedef uint32_t reg_t;\n#  elif __riscv_xlen == 64\ntypedef uint64_t reg_t;\n#  else\n#   error \"Unsupported __riscv_xlen\"\n#  endif\n\n#  if defined(__riscv_flen)\n#   if __riscv_flen == 64\ntypedef double fp_t;\n#   elif __riscv_flen == 32\ntypedef float fp_t;\n#   else\n#    error \"Unsupported __riscv_flen\"\n#   endif\n#  else\n// This is just for supressing undeclared error of fp_t.\ntypedef double fp_t;\n#  endif\n# else\n// Use Max possible width when cross unwinding\ntypedef uint64_t reg_t;\ntypedef double fp_t;\n# define __riscv_xlen 64\n# define __riscv_flen 64\n#endif\n\n/// Registers_riscv holds the register state of a thread.\nclass _LIBUNWIND_HIDDEN Registers_riscv {\npublic:\n  Registers_riscv();\n  Registers_riscv(const void *registers);\n\n  bool        validRegister(int num) const;\n  reg_t       getRegister(int num) const;\n  void        setRegister(int num, reg_t value);\n  bool        validFloatRegister(int num) const;\n  fp_t        getFloatRegister(int num) const;\n  void        setFloatRegister(int num, fp_t value);\n  bool        validVectorRegister(int num) const;\n  v128        getVectorRegister(int num) const;\n  void        setVectorRegister(int num, v128 value);\n  static const char *getRegisterName(int num);\n  void        jumpto();\n  static int  lastDwarfRegNum() { return _LIBUNWIND_HIGHEST_DWARF_REGISTER_RISCV; }\n  static int  getArch() { return REGISTERS_RISCV; }\n\n  reg_t       getSP() const { return _registers[2]; }\n  void        setSP(reg_t value) { _registers[2] = value; }\n  reg_t       getIP() const { return _registers[0]; }\n  void        setIP(reg_t value) { _registers[0] = value; }\n\nprivate:\n  // _registers[0] holds the pc\n  reg_t _registers[32];\n# if defined(__riscv_flen)\n  fp_t _floats[32];\n# endif\n};\n\ninline Registers_riscv::Registers_riscv(const void *registers) {\n  static_assert((check_fit<Registers_riscv, unw_context_t>::does_fit),\n                \"riscv registers do not fit into unw_context_t\");\n  memcpy(&_registers, registers, sizeof(_registers));\n# if __riscv_xlen == 32\n  static_assert(sizeof(_registers) == 0x80,\n                \"expected float registers to be at offset 128\");\n# elif __riscv_xlen == 64\n  static_assert(sizeof(_registers) == 0x100,\n                \"expected float registers to be at offset 256\");\n# else\n# error \"Unexpected float registers.\"\n# endif\n\n# if defined(__riscv_flen)\n  memcpy(_floats,\n         static_cast<const uint8_t *>(registers) + sizeof(_registers),\n         sizeof(_floats));\n# endif\n}\n\ninline Registers_riscv::Registers_riscv() {\n  memset(&_registers, 0, sizeof(_registers));\n# if defined(__riscv_flen)\n  memset(&_floats, 0, sizeof(_floats));\n# endif\n}\n\ninline bool Registers_riscv::validRegister(int regNum) const {\n  if (regNum == UNW_REG_IP)\n    return true;\n  if (regNum == UNW_REG_SP)\n    return true;\n  if (regNum < 0)\n    return false;\n  if (regNum > UNW_RISCV_F31)\n    return false;\n  return true;\n}\n\ninline reg_t Registers_riscv::getRegister(int regNum) const {\n  if (regNum == UNW_REG_IP)\n    return _registers[0];\n  if (regNum == UNW_REG_SP)\n    return _registers[2];\n  if (regNum == UNW_RISCV_X0)\n    return 0;\n  if ((regNum > 0) && (regNum < 32))\n    return _registers[regNum];\n  _LIBUNWIND_ABORT(\"unsupported riscv register\");\n}\n\ninline void Registers_riscv::setRegister(int regNum, reg_t value) {\n  if (regNum == UNW_REG_IP)\n    _registers[0] = value;\n  else if (regNum == UNW_REG_SP)\n    _registers[2] = value;\n  else if (regNum == UNW_RISCV_X0)\n    /* x0 is hardwired to zero */\n    return;\n  else if ((regNum > 0) && (regNum < 32))\n    _registers[regNum] = value;\n  else\n    _LIBUNWIND_ABORT(\"unsupported riscv register\");\n}\n\ninline const char *Registers_riscv::getRegisterName(int regNum) {\n  switch (regNum) {\n  case UNW_REG_IP:\n    return \"pc\";\n  case UNW_REG_SP:\n    return \"sp\";\n  case UNW_RISCV_X0:\n    return \"zero\";\n  case UNW_RISCV_X1:\n    return \"ra\";\n  case UNW_RISCV_X2:\n    return \"sp\";\n  case UNW_RISCV_X3:\n    return \"gp\";\n  case UNW_RISCV_X4:\n    return \"tp\";\n  case UNW_RISCV_X5:\n    return \"t0\";\n  case UNW_RISCV_X6:\n    return \"t1\";\n  case UNW_RISCV_X7:\n    return \"t2\";\n  case UNW_RISCV_X8:\n    return \"s0\";\n  case UNW_RISCV_X9:\n    return \"s1\";\n  case UNW_RISCV_X10:\n    return \"a0\";\n  case UNW_RISCV_X11:\n    return \"a1\";\n  case UNW_RISCV_X12:\n    return \"a2\";\n  case UNW_RISCV_X13:\n    return \"a3\";\n  case UNW_RISCV_X14:\n    return \"a4\";\n  case UNW_RISCV_X15:\n    return \"a5\";\n  case UNW_RISCV_X16:\n    return \"a6\";\n  case UNW_RISCV_X17:\n    return \"a7\";\n  case UNW_RISCV_X18:\n    return \"s2\";\n  case UNW_RISCV_X19:\n    return \"s3\";\n  case UNW_RISCV_X20:\n    return \"s4\";\n  case UNW_RISCV_X21:\n    return \"s5\";\n  case UNW_RISCV_X22:\n    return \"s6\";\n  case UNW_RISCV_X23:\n    return \"s7\";\n  case UNW_RISCV_X24:\n    return \"s8\";\n  case UNW_RISCV_X25:\n    return \"s9\";\n  case UNW_RISCV_X26:\n    return \"s10\";\n  case UNW_RISCV_X27:\n    return \"s11\";\n  case UNW_RISCV_X28:\n    return \"t3\";\n  case UNW_RISCV_X29:\n    return \"t4\";\n  case UNW_RISCV_X30:\n    return \"t5\";\n  case UNW_RISCV_X31:\n    return \"t6\";\n  case UNW_RISCV_F0:\n    return \"ft0\";\n  case UNW_RISCV_F1:\n    return \"ft1\";\n  case UNW_RISCV_F2:\n    return \"ft2\";\n  case UNW_RISCV_F3:\n    return \"ft3\";\n  case UNW_RISCV_F4:\n    return \"ft4\";\n  case UNW_RISCV_F5:\n    return \"ft5\";\n  case UNW_RISCV_F6:\n    return \"ft6\";\n  case UNW_RISCV_F7:\n    return \"ft7\";\n  case UNW_RISCV_F8:\n    return \"fs0\";\n  case UNW_RISCV_F9:\n    return \"fs1\";\n  case UNW_RISCV_F10:\n    return \"fa0\";\n  case UNW_RISCV_F11:\n    return \"fa1\";\n  case UNW_RISCV_F12:\n    return \"fa2\";\n  case UNW_RISCV_F13:\n    return \"fa3\";\n  case UNW_RISCV_F14:\n    return \"fa4\";\n  case UNW_RISCV_F15:\n    return \"fa5\";\n  case UNW_RISCV_F16:\n    return \"fa6\";\n  case UNW_RISCV_F17:\n    return \"fa7\";\n  case UNW_RISCV_F18:\n    return \"fs2\";\n  case UNW_RISCV_F19:\n    return \"fs3\";\n  case UNW_RISCV_F20:\n    return \"fs4\";\n  case UNW_RISCV_F21:\n    return \"fs5\";\n  case UNW_RISCV_F22:\n    return \"fs6\";\n  case UNW_RISCV_F23:\n    return \"fs7\";\n  case UNW_RISCV_F24:\n    return \"fs8\";\n  case UNW_RISCV_F25:\n    return \"fs9\";\n  case UNW_RISCV_F26:\n    return \"fs10\";\n  case UNW_RISCV_F27:\n    return \"fs11\";\n  case UNW_RISCV_F28:\n    return \"ft8\";\n  case UNW_RISCV_F29:\n    return \"ft9\";\n  case UNW_RISCV_F30:\n    return \"ft10\";\n  case UNW_RISCV_F31:\n    return \"ft11\";\n  default:\n    return \"unknown register\";\n  }\n}\n\ninline bool Registers_riscv::validFloatRegister(int regNum) const {\n# if defined(__riscv_flen)\n  if (regNum < UNW_RISCV_F0)\n    return false;\n  if (regNum > UNW_RISCV_F31)\n    return false;\n  return true;\n# else\n  (void)regNum;\n  return false;\n# endif\n}\n\ninline fp_t Registers_riscv::getFloatRegister(int regNum) const {\n# if defined(__riscv_flen)\n  assert(validFloatRegister(regNum));\n  return _floats[regNum - UNW_RISCV_F0];\n# else\n  (void)regNum;\n  _LIBUNWIND_ABORT(\"libunwind not built with float support\");\n# endif\n}\n\ninline void Registers_riscv::setFloatRegister(int regNum, fp_t value) {\n# if defined(__riscv_flen)\n  assert(validFloatRegister(regNum));\n  _floats[regNum - UNW_RISCV_F0] = value;\n# else\n  (void)regNum;\n  (void)value;\n  _LIBUNWIND_ABORT(\"libunwind not built with float support\");\n# endif\n}\n\ninline bool Registers_riscv::validVectorRegister(int) const {\n  return false;\n}\n\ninline v128 Registers_riscv::getVectorRegister(int) const {\n  _LIBUNWIND_ABORT(\"no riscv vector register support yet\");\n}\n\ninline void Registers_riscv::setVectorRegister(int, v128) {\n  _LIBUNWIND_ABORT(\"no riscv vector register support yet\");\n}\n#endif // _LIBUNWIND_TARGET_RISCV\n\n#if defined(_LIBUNWIND_TARGET_VE)\n/// Registers_ve holds the register state of a thread in a VE process.\nclass _LIBUNWIND_HIDDEN Registers_ve {\npublic:\n  Registers_ve();\n  Registers_ve(const void *registers);\n\n  bool        validRegister(int num) const;\n  uint64_t    getRegister(int num) const;\n  void        setRegister(int num, uint64_t value);\n  bool        validFloatRegister(int num) const;\n  double      getFloatRegister(int num) const;\n  void        setFloatRegister(int num, double value);\n  bool        validVectorRegister(int num) const;\n  v128        getVectorRegister(int num) const;\n  void        setVectorRegister(int num, v128 value);\n  static const char *getRegisterName(int num);\n  void        jumpto();\n  static int  lastDwarfRegNum() { return _LIBUNWIND_HIGHEST_DWARF_REGISTER_VE; }\n  static int  getArch() { return REGISTERS_VE; }\n\n  uint64_t  getSP() const         { return _registers.__s[11]; }\n  void      setSP(uint64_t value) { _registers.__s[11] = value; }\n  uint64_t  getIP() const         { return _registers.__ic; }\n  void      setIP(uint64_t value) { _registers.__ic = value; }\n\nprivate:\n  // FIXME: Need to store not only scalar registers but also vector and vector\n  // mask registers.  VEOS uses mcontext_t defined in ucontext.h.  It takes\n  // 524288 bytes (65536*8 bytes), though.  Currently, we use libunwind for\n  // SjLj exception support only, so Registers_ve is not implemented completely.\n  struct ve_thread_state_t {\n    uint64_t __s[64]; // s0-s64\n    uint64_t __ic;    // Instruction counter (IC)\n    uint64_t __vixr;  // Vector Index Register\n    uint64_t __vl;    // Vector Length Register\n  };\n\n  ve_thread_state_t _registers; // total 67 registers\n\n  // Currently no vector register is preserved.\n};\n\ninline Registers_ve::Registers_ve(const void *registers) {\n  static_assert((check_fit<Registers_ve, unw_context_t>::does_fit),\n                \"ve registers do not fit into unw_context_t\");\n  memcpy(&_registers, static_cast<const uint8_t *>(registers),\n         sizeof(_registers));\n  static_assert(sizeof(_registers) == 536,\n                \"expected vector register offset to be 536\");\n}\n\ninline Registers_ve::Registers_ve() {\n  memset(&_registers, 0, sizeof(_registers));\n}\n\ninline bool Registers_ve::validRegister(int regNum) const {\n  if (regNum >= UNW_VE_S0 && regNum <= UNW_VE_S63)\n    return true;\n\n  switch (regNum) {\n  case UNW_REG_IP:\n  case UNW_REG_SP:\n  case UNW_VE_VIXR:\n  case UNW_VE_VL:\n    return true;\n  default:\n    return false;\n  }\n}\n\ninline uint64_t Registers_ve::getRegister(int regNum) const {\n  if (regNum >= UNW_VE_S0 && regNum <= UNW_VE_S63)\n    return _registers.__s[regNum - UNW_VE_S0];\n\n  switch (regNum) {\n  case UNW_REG_IP:\n    return _registers.__ic;\n  case UNW_REG_SP:\n    return _registers.__s[11];\n  case UNW_VE_VIXR:\n    return _registers.__vixr;\n  case UNW_VE_VL:\n    return _registers.__vl;\n  }\n  _LIBUNWIND_ABORT(\"unsupported ve register\");\n}\n\ninline void Registers_ve::setRegister(int regNum, uint64_t value) {\n  if (regNum >= UNW_VE_S0 && regNum <= UNW_VE_S63) {\n    _registers.__s[regNum - UNW_VE_S0] = value;\n    return;\n  }\n\n  switch (regNum) {\n  case UNW_REG_IP:\n    _registers.__ic = value;\n    return;\n  case UNW_REG_SP:\n    _registers.__s[11] = value;\n    return;\n  case UNW_VE_VIXR:\n    _registers.__vixr = value;\n    return;\n  case UNW_VE_VL:\n    _registers.__vl = value;\n    return;\n  }\n  _LIBUNWIND_ABORT(\"unsupported ve register\");\n}\n\ninline bool Registers_ve::validFloatRegister(int /* regNum */) const {\n  return false;\n}\n\ninline double Registers_ve::getFloatRegister(int /* regNum */) const {\n  _LIBUNWIND_ABORT(\"VE doesn't have float registers\");\n}\n\ninline void Registers_ve::setFloatRegister(int /* regNum */,\n                                           double /* value */) {\n  _LIBUNWIND_ABORT(\"VE doesn't have float registers\");\n}\n\ninline bool Registers_ve::validVectorRegister(int /* regNum */) const {\n  return false;\n}\n\ninline v128 Registers_ve::getVectorRegister(int /* regNum */) const {\n  _LIBUNWIND_ABORT(\"VE vector support not implemented\");\n}\n\ninline void Registers_ve::setVectorRegister(int /* regNum */,\n                                            v128 /* value */) {\n  _LIBUNWIND_ABORT(\"VE vector support not implemented\");\n}\n\ninline const char *Registers_ve::getRegisterName(int regNum) {\n  switch (regNum) {\n  case UNW_REG_IP:\n    return \"ip\";\n  case UNW_REG_SP:\n    return \"sp\";\n  case UNW_VE_VIXR:\n    return \"vixr\";\n  case UNW_VE_VL:\n    return \"vl\";\n  case UNW_VE_S0:\n    return \"s0\";\n  case UNW_VE_S1:\n    return \"s1\";\n  case UNW_VE_S2:\n    return \"s2\";\n  case UNW_VE_S3:\n    return \"s3\";\n  case UNW_VE_S4:\n    return \"s4\";\n  case UNW_VE_S5:\n    return \"s5\";\n  case UNW_VE_S6:\n    return \"s6\";\n  case UNW_VE_S7:\n    return \"s7\";\n  case UNW_VE_S8:\n    return \"s8\";\n  case UNW_VE_S9:\n    return \"s9\";\n  case UNW_VE_S10:\n    return \"s10\";\n  case UNW_VE_S11:\n    return \"s11\";\n  case UNW_VE_S12:\n    return \"s12\";\n  case UNW_VE_S13:\n    return \"s13\";\n  case UNW_VE_S14:\n    return \"s14\";\n  case UNW_VE_S15:\n    return \"s15\";\n  case UNW_VE_S16:\n    return \"s16\";\n  case UNW_VE_S17:\n    return \"s17\";\n  case UNW_VE_S18:\n    return \"s18\";\n  case UNW_VE_S19:\n    return \"s19\";\n  case UNW_VE_S20:\n    return \"s20\";\n  case UNW_VE_S21:\n    return \"s21\";\n  case UNW_VE_S22:\n    return \"s22\";\n  case UNW_VE_S23:\n    return \"s23\";\n  case UNW_VE_S24:\n    return \"s24\";\n  case UNW_VE_S25:\n    return \"s25\";\n  case UNW_VE_S26:\n    return \"s26\";\n  case UNW_VE_S27:\n    return \"s27\";\n  case UNW_VE_S28:\n    return \"s28\";\n  case UNW_VE_S29:\n    return \"s29\";\n  case UNW_VE_S30:\n    return \"s30\";\n  case UNW_VE_S31:\n    return \"s31\";\n  case UNW_VE_S32:\n    return \"s32\";\n  case UNW_VE_S33:\n    return \"s33\";\n  case UNW_VE_S34:\n    return \"s34\";\n  case UNW_VE_S35:\n    return \"s35\";\n  case UNW_VE_S36:\n    return \"s36\";\n  case UNW_VE_S37:\n    return \"s37\";\n  case UNW_VE_S38:\n    return \"s38\";\n  case UNW_VE_S39:\n    return \"s39\";\n  case UNW_VE_S40:\n    return \"s40\";\n  case UNW_VE_S41:\n    return \"s41\";\n  case UNW_VE_S42:\n    return \"s42\";\n  case UNW_VE_S43:\n    return \"s43\";\n  case UNW_VE_S44:\n    return \"s44\";\n  case UNW_VE_S45:\n    return \"s45\";\n  case UNW_VE_S46:\n    return \"s46\";\n  case UNW_VE_S47:\n    return \"s47\";\n  case UNW_VE_S48:\n    return \"s48\";\n  case UNW_VE_S49:\n    return \"s49\";\n  case UNW_VE_S50:\n    return \"s50\";\n  case UNW_VE_S51:\n    return \"s51\";\n  case UNW_VE_S52:\n    return \"s52\";\n  case UNW_VE_S53:\n    return \"s53\";\n  case UNW_VE_S54:\n    return \"s54\";\n  case UNW_VE_S55:\n    return \"s55\";\n  case UNW_VE_S56:\n    return \"s56\";\n  case UNW_VE_S57:\n    return \"s57\";\n  case UNW_VE_S58:\n    return \"s58\";\n  case UNW_VE_S59:\n    return \"s59\";\n  case UNW_VE_S60:\n    return \"s60\";\n  case UNW_VE_S61:\n    return \"s61\";\n  case UNW_VE_S62:\n    return \"s62\";\n  case UNW_VE_S63:\n    return \"s63\";\n  case UNW_VE_V0:\n    return \"v0\";\n  case UNW_VE_V1:\n    return \"v1\";\n  case UNW_VE_V2:\n    return \"v2\";\n  case UNW_VE_V3:\n    return \"v3\";\n  case UNW_VE_V4:\n    return \"v4\";\n  case UNW_VE_V5:\n    return \"v5\";\n  case UNW_VE_V6:\n    return \"v6\";\n  case UNW_VE_V7:\n    return \"v7\";\n  case UNW_VE_V8:\n    return \"v8\";\n  case UNW_VE_V9:\n    return \"v9\";\n  case UNW_VE_V10:\n    return \"v10\";\n  case UNW_VE_V11:\n    return \"v11\";\n  case UNW_VE_V12:\n    return \"v12\";\n  case UNW_VE_V13:\n    return \"v13\";\n  case UNW_VE_V14:\n    return \"v14\";\n  case UNW_VE_V15:\n    return \"v15\";\n  case UNW_VE_V16:\n    return \"v16\";\n  case UNW_VE_V17:\n    return \"v17\";\n  case UNW_VE_V18:\n    return \"v18\";\n  case UNW_VE_V19:\n    return \"v19\";\n  case UNW_VE_V20:\n    return \"v20\";\n  case UNW_VE_V21:\n    return \"v21\";\n  case UNW_VE_V22:\n    return \"v22\";\n  case UNW_VE_V23:\n    return \"v23\";\n  case UNW_VE_V24:\n    return \"v24\";\n  case UNW_VE_V25:\n    return \"v25\";\n  case UNW_VE_V26:\n    return \"v26\";\n  case UNW_VE_V27:\n    return \"v27\";\n  case UNW_VE_V28:\n    return \"v28\";\n  case UNW_VE_V29:\n    return \"v29\";\n  case UNW_VE_V30:\n    return \"v30\";\n  case UNW_VE_V31:\n    return \"v31\";\n  case UNW_VE_V32:\n    return \"v32\";\n  case UNW_VE_V33:\n    return \"v33\";\n  case UNW_VE_V34:\n    return \"v34\";\n  case UNW_VE_V35:\n    return \"v35\";\n  case UNW_VE_V36:\n    return \"v36\";\n  case UNW_VE_V37:\n    return \"v37\";\n  case UNW_VE_V38:\n    return \"v38\";\n  case UNW_VE_V39:\n    return \"v39\";\n  case UNW_VE_V40:\n    return \"v40\";\n  case UNW_VE_V41:\n    return \"v41\";\n  case UNW_VE_V42:\n    return \"v42\";\n  case UNW_VE_V43:\n    return \"v43\";\n  case UNW_VE_V44:\n    return \"v44\";\n  case UNW_VE_V45:\n    return \"v45\";\n  case UNW_VE_V46:\n    return \"v46\";\n  case UNW_VE_V47:\n    return \"v47\";\n  case UNW_VE_V48:\n    return \"v48\";\n  case UNW_VE_V49:\n    return \"v49\";\n  case UNW_VE_V50:\n    return \"v50\";\n  case UNW_VE_V51:\n    return \"v51\";\n  case UNW_VE_V52:\n    return \"v52\";\n  case UNW_VE_V53:\n    return \"v53\";\n  case UNW_VE_V54:\n    return \"v54\";\n  case UNW_VE_V55:\n    return \"v55\";\n  case UNW_VE_V56:\n    return \"v56\";\n  case UNW_VE_V57:\n    return \"v57\";\n  case UNW_VE_V58:\n    return \"v58\";\n  case UNW_VE_V59:\n    return \"v59\";\n  case UNW_VE_V60:\n    return \"v60\";\n  case UNW_VE_V61:\n    return \"v61\";\n  case UNW_VE_V62:\n    return \"v62\";\n  case UNW_VE_V63:\n    return \"v63\";\n  case UNW_VE_VM0:\n    return \"vm0\";\n  case UNW_VE_VM1:\n    return \"vm1\";\n  case UNW_VE_VM2:\n    return \"vm2\";\n  case UNW_VE_VM3:\n    return \"vm3\";\n  case UNW_VE_VM4:\n    return \"vm4\";\n  case UNW_VE_VM5:\n    return \"vm5\";\n  case UNW_VE_VM6:\n    return \"vm6\";\n  case UNW_VE_VM7:\n    return \"vm7\";\n  case UNW_VE_VM8:\n    return \"vm8\";\n  case UNW_VE_VM9:\n    return \"vm9\";\n  case UNW_VE_VM10:\n    return \"vm10\";\n  case UNW_VE_VM11:\n    return \"vm11\";\n  case UNW_VE_VM12:\n    return \"vm12\";\n  case UNW_VE_VM13:\n    return \"vm13\";\n  case UNW_VE_VM14:\n    return \"vm14\";\n  case UNW_VE_VM15:\n    return \"vm15\";\n  }\n  return \"unknown register\";\n}\n#endif // _LIBUNWIND_TARGET_VE\n\n} // namespace libunwind\n\n#endif // __REGISTERS_HPP__\n"}, "6": {"id": 6, "path": "/home/vsts/work/1/llvm-project/libunwind/src/UnwindCursor.hpp", "content": "//===------------------------- UnwindCursor.hpp ---------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//\n// C++ interface to lower levels of libunwind\n//===----------------------------------------------------------------------===//\n\n#ifndef __UNWINDCURSOR_HPP__\n#define __UNWINDCURSOR_HPP__\n\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unwind.h>\n\n#ifdef _WIN32\n  #include <windows.h>\n  #include <ntverp.h>\n#endif\n#ifdef __APPLE__\n  #include <mach-o/dyld.h>\n#endif\n\n#if defined(_LIBUNWIND_SUPPORT_SEH_UNWIND)\n// Provide a definition for the DISPATCHER_CONTEXT struct for old (Win7 and\n// earlier) SDKs.\n// MinGW-w64 has always provided this struct.\n  #if defined(_WIN32) && defined(_LIBUNWIND_TARGET_X86_64) && \\\n      !defined(__MINGW32__) && VER_PRODUCTBUILD < 8000\nstruct _DISPATCHER_CONTEXT {\n  ULONG64 ControlPc;\n  ULONG64 ImageBase;\n  PRUNTIME_FUNCTION FunctionEntry;\n  ULONG64 EstablisherFrame;\n  ULONG64 TargetIp;\n  PCONTEXT ContextRecord;\n  PEXCEPTION_ROUTINE LanguageHandler;\n  PVOID HandlerData;\n  PUNWIND_HISTORY_TABLE HistoryTable;\n  ULONG ScopeIndex;\n  ULONG Fill0;\n};\n  #endif\n\nstruct UNWIND_INFO {\n  uint8_t Version : 3;\n  uint8_t Flags : 5;\n  uint8_t SizeOfProlog;\n  uint8_t CountOfCodes;\n  uint8_t FrameRegister : 4;\n  uint8_t FrameOffset : 4;\n  uint16_t UnwindCodes[2];\n};\n\nextern \"C\" _Unwind_Reason_Code __libunwind_seh_personality(\n    int, _Unwind_Action, uint64_t, _Unwind_Exception *,\n    struct _Unwind_Context *);\n\n#endif\n\n#include \"config.h\"\n\n#include \"AddressSpace.hpp\"\n#include \"CompactUnwinder.hpp\"\n#include \"config.h\"\n#include \"DwarfInstructions.hpp\"\n#include \"EHHeaderParser.hpp\"\n#include \"libunwind.h\"\n#include \"Registers.hpp\"\n#include \"RWMutex.hpp\"\n#include \"Unwind-EHABI.h\"\n\nnamespace libunwind {\n\n#if defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND)\n/// Cache of recently found FDEs.\ntemplate <typename A>\nclass _LIBUNWIND_HIDDEN DwarfFDECache {\n  typedef typename A::pint_t pint_t;\npublic:\n  static constexpr pint_t kSearchAll = static_cast<pint_t>(-1);\n  static pint_t findFDE(pint_t mh, pint_t pc);\n  static void add(pint_t mh, pint_t ip_start, pint_t ip_end, pint_t fde);\n  static void removeAllIn(pint_t mh);\n  static void iterateCacheEntries(void (*func)(unw_word_t ip_start,\n                                               unw_word_t ip_end,\n                                               unw_word_t fde, unw_word_t mh));\n\nprivate:\n\n  struct entry {\n    pint_t mh;\n    pint_t ip_start;\n    pint_t ip_end;\n    pint_t fde;\n  };\n\n  // These fields are all static to avoid needing an initializer.\n  // There is only one instance of this class per process.\n  static RWMutex _lock;\n#ifdef __APPLE__\n  static void dyldUnloadHook(const struct mach_header *mh, intptr_t slide);\n  static bool _registeredForDyldUnloads;\n#endif\n  static entry *_buffer;\n  static entry *_bufferUsed;\n  static entry *_bufferEnd;\n  static entry _initialBuffer[64];\n};\n\ntemplate <typename A>\ntypename DwarfFDECache<A>::entry *\nDwarfFDECache<A>::_buffer = _initialBuffer;\n\ntemplate <typename A>\ntypename DwarfFDECache<A>::entry *\nDwarfFDECache<A>::_bufferUsed = _initialBuffer;\n\ntemplate <typename A>\ntypename DwarfFDECache<A>::entry *\nDwarfFDECache<A>::_bufferEnd = &_initialBuffer[64];\n\ntemplate <typename A>\ntypename DwarfFDECache<A>::entry DwarfFDECache<A>::_initialBuffer[64];\n\ntemplate <typename A>\nRWMutex DwarfFDECache<A>::_lock;\n\n#ifdef __APPLE__\ntemplate <typename A>\nbool DwarfFDECache<A>::_registeredForDyldUnloads = false;\n#endif\n\ntemplate <typename A>\ntypename A::pint_t DwarfFDECache<A>::findFDE(pint_t mh, pint_t pc) {\n  pint_t result = 0;\n  _LIBUNWIND_LOG_IF_FALSE(_lock.lock_shared());\n  for (entry *p = _buffer; p < _bufferUsed; ++p) {\n    if ((mh == p->mh) || (mh == kSearchAll)) {\n      if ((p->ip_start <= pc) && (pc < p->ip_end)) {\n        result = p->fde;\n        break;\n      }\n    }\n  }\n  _LIBUNWIND_LOG_IF_FALSE(_lock.unlock_shared());\n  return result;\n}\n\ntemplate <typename A>\nvoid DwarfFDECache<A>::add(pint_t mh, pint_t ip_start, pint_t ip_end,\n                           pint_t fde) {\n#if !defined(_LIBUNWIND_NO_HEAP)\n  _LIBUNWIND_LOG_IF_FALSE(_lock.lock());\n  if (_bufferUsed >= _bufferEnd) {\n    size_t oldSize = (size_t)(_bufferEnd - _buffer);\n    size_t newSize = oldSize * 4;\n    // Can't use operator new (we are below it).\n    entry *newBuffer = (entry *)malloc(newSize * sizeof(entry));\n    memcpy(newBuffer, _buffer, oldSize * sizeof(entry));\n    if (_buffer != _initialBuffer)\n      free(_buffer);\n    _buffer = newBuffer;\n    _bufferUsed = &newBuffer[oldSize];\n    _bufferEnd = &newBuffer[newSize];\n  }\n  _bufferUsed->mh = mh;\n  _bufferUsed->ip_start = ip_start;\n  _bufferUsed->ip_end = ip_end;\n  _bufferUsed->fde = fde;\n  ++_bufferUsed;\n#ifdef __APPLE__\n  if (!_registeredForDyldUnloads) {\n    _dyld_register_func_for_remove_image(&dyldUnloadHook);\n    _registeredForDyldUnloads = true;\n  }\n#endif\n  _LIBUNWIND_LOG_IF_FALSE(_lock.unlock());\n#endif\n}\n\ntemplate <typename A>\nvoid DwarfFDECache<A>::removeAllIn(pint_t mh) {\n  _LIBUNWIND_LOG_IF_FALSE(_lock.lock());\n  entry *d = _buffer;\n  for (const entry *s = _buffer; s < _bufferUsed; ++s) {\n    if (s->mh != mh) {\n      if (d != s)\n        *d = *s;\n      ++d;\n    }\n  }\n  _bufferUsed = d;\n  _LIBUNWIND_LOG_IF_FALSE(_lock.unlock());\n}\n\n#ifdef __APPLE__\ntemplate <typename A>\nvoid DwarfFDECache<A>::dyldUnloadHook(const struct mach_header *mh, intptr_t ) {\n  removeAllIn((pint_t) mh);\n}\n#endif\n\ntemplate <typename A>\nvoid DwarfFDECache<A>::iterateCacheEntries(void (*func)(\n    unw_word_t ip_start, unw_word_t ip_end, unw_word_t fde, unw_word_t mh)) {\n  _LIBUNWIND_LOG_IF_FALSE(_lock.lock());\n  for (entry *p = _buffer; p < _bufferUsed; ++p) {\n    (*func)(p->ip_start, p->ip_end, p->fde, p->mh);\n  }\n  _LIBUNWIND_LOG_IF_FALSE(_lock.unlock());\n}\n#endif // defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND)\n\n\n#define arrayoffsetof(type, index, field) ((size_t)(&((type *)0)[index].field))\n\n#if defined(_LIBUNWIND_SUPPORT_COMPACT_UNWIND)\ntemplate <typename A> class UnwindSectionHeader {\npublic:\n  UnwindSectionHeader(A &addressSpace, typename A::pint_t addr)\n      : _addressSpace(addressSpace), _addr(addr) {}\n\n  uint32_t version() const {\n    return _addressSpace.get32(_addr +\n                               offsetof(unwind_info_section_header, version));\n  }\n  uint32_t commonEncodingsArraySectionOffset() const {\n    return _addressSpace.get32(_addr +\n                               offsetof(unwind_info_section_header,\n                                        commonEncodingsArraySectionOffset));\n  }\n  uint32_t commonEncodingsArrayCount() const {\n    return _addressSpace.get32(_addr + offsetof(unwind_info_section_header,\n                                                commonEncodingsArrayCount));\n  }\n  uint32_t personalityArraySectionOffset() const {\n    return _addressSpace.get32(_addr + offsetof(unwind_info_section_header,\n                                                personalityArraySectionOffset));\n  }\n  uint32_t personalityArrayCount() const {\n    return _addressSpace.get32(\n        _addr + offsetof(unwind_info_section_header, personalityArrayCount));\n  }\n  uint32_t indexSectionOffset() const {\n    return _addressSpace.get32(\n        _addr + offsetof(unwind_info_section_header, indexSectionOffset));\n  }\n  uint32_t indexCount() const {\n    return _addressSpace.get32(\n        _addr + offsetof(unwind_info_section_header, indexCount));\n  }\n\nprivate:\n  A                     &_addressSpace;\n  typename A::pint_t     _addr;\n};\n\ntemplate <typename A> class UnwindSectionIndexArray {\npublic:\n  UnwindSectionIndexArray(A &addressSpace, typename A::pint_t addr)\n      : _addressSpace(addressSpace), _addr(addr) {}\n\n  uint32_t functionOffset(uint32_t index) const {\n    return _addressSpace.get32(\n        _addr + arrayoffsetof(unwind_info_section_header_index_entry, index,\n                              functionOffset));\n  }\n  uint32_t secondLevelPagesSectionOffset(uint32_t index) const {\n    return _addressSpace.get32(\n        _addr + arrayoffsetof(unwind_info_section_header_index_entry, index,\n                              secondLevelPagesSectionOffset));\n  }\n  uint32_t lsdaIndexArraySectionOffset(uint32_t index) const {\n    return _addressSpace.get32(\n        _addr + arrayoffsetof(unwind_info_section_header_index_entry, index,\n                              lsdaIndexArraySectionOffset));\n  }\n\nprivate:\n  A                   &_addressSpace;\n  typename A::pint_t   _addr;\n};\n\ntemplate <typename A> class UnwindSectionRegularPageHeader {\npublic:\n  UnwindSectionRegularPageHeader(A &addressSpace, typename A::pint_t addr)\n      : _addressSpace(addressSpace), _addr(addr) {}\n\n  uint32_t kind() const {\n    return _addressSpace.get32(\n        _addr + offsetof(unwind_info_regular_second_level_page_header, kind));\n  }\n  uint16_t entryPageOffset() const {\n    return _addressSpace.get16(\n        _addr + offsetof(unwind_info_regular_second_level_page_header,\n                         entryPageOffset));\n  }\n  uint16_t entryCount() const {\n    return _addressSpace.get16(\n        _addr +\n        offsetof(unwind_info_regular_second_level_page_header, entryCount));\n  }\n\nprivate:\n  A &_addressSpace;\n  typename A::pint_t _addr;\n};\n\ntemplate <typename A> class UnwindSectionRegularArray {\npublic:\n  UnwindSectionRegularArray(A &addressSpace, typename A::pint_t addr)\n      : _addressSpace(addressSpace), _addr(addr) {}\n\n  uint32_t functionOffset(uint32_t index) const {\n    return _addressSpace.get32(\n        _addr + arrayoffsetof(unwind_info_regular_second_level_entry, index,\n                              functionOffset));\n  }\n  uint32_t encoding(uint32_t index) const {\n    return _addressSpace.get32(\n        _addr +\n        arrayoffsetof(unwind_info_regular_second_level_entry, index, encoding));\n  }\n\nprivate:\n  A &_addressSpace;\n  typename A::pint_t _addr;\n};\n\ntemplate <typename A> class UnwindSectionCompressedPageHeader {\npublic:\n  UnwindSectionCompressedPageHeader(A &addressSpace, typename A::pint_t addr)\n      : _addressSpace(addressSpace), _addr(addr) {}\n\n  uint32_t kind() const {\n    return _addressSpace.get32(\n        _addr +\n        offsetof(unwind_info_compressed_second_level_page_header, kind));\n  }\n  uint16_t entryPageOffset() const {\n    return _addressSpace.get16(\n        _addr + offsetof(unwind_info_compressed_second_level_page_header,\n                         entryPageOffset));\n  }\n  uint16_t entryCount() const {\n    return _addressSpace.get16(\n        _addr +\n        offsetof(unwind_info_compressed_second_level_page_header, entryCount));\n  }\n  uint16_t encodingsPageOffset() const {\n    return _addressSpace.get16(\n        _addr + offsetof(unwind_info_compressed_second_level_page_header,\n                         encodingsPageOffset));\n  }\n  uint16_t encodingsCount() const {\n    return _addressSpace.get16(\n        _addr + offsetof(unwind_info_compressed_second_level_page_header,\n                         encodingsCount));\n  }\n\nprivate:\n  A &_addressSpace;\n  typename A::pint_t _addr;\n};\n\ntemplate <typename A> class UnwindSectionCompressedArray {\npublic:\n  UnwindSectionCompressedArray(A &addressSpace, typename A::pint_t addr)\n      : _addressSpace(addressSpace), _addr(addr) {}\n\n  uint32_t functionOffset(uint32_t index) const {\n    return UNWIND_INFO_COMPRESSED_ENTRY_FUNC_OFFSET(\n        _addressSpace.get32(_addr + index * sizeof(uint32_t)));\n  }\n  uint16_t encodingIndex(uint32_t index) const {\n    return UNWIND_INFO_COMPRESSED_ENTRY_ENCODING_INDEX(\n        _addressSpace.get32(_addr + index * sizeof(uint32_t)));\n  }\n\nprivate:\n  A &_addressSpace;\n  typename A::pint_t _addr;\n};\n\ntemplate <typename A> class UnwindSectionLsdaArray {\npublic:\n  UnwindSectionLsdaArray(A &addressSpace, typename A::pint_t addr)\n      : _addressSpace(addressSpace), _addr(addr) {}\n\n  uint32_t functionOffset(uint32_t index) const {\n    return _addressSpace.get32(\n        _addr + arrayoffsetof(unwind_info_section_header_lsda_index_entry,\n                              index, functionOffset));\n  }\n  uint32_t lsdaOffset(uint32_t index) const {\n    return _addressSpace.get32(\n        _addr + arrayoffsetof(unwind_info_section_header_lsda_index_entry,\n                              index, lsdaOffset));\n  }\n\nprivate:\n  A                   &_addressSpace;\n  typename A::pint_t   _addr;\n};\n#endif // defined(_LIBUNWIND_SUPPORT_COMPACT_UNWIND)\n\nclass _LIBUNWIND_HIDDEN AbstractUnwindCursor {\npublic:\n  // NOTE: provide a class specific placement deallocation function (S5.3.4 p20)\n  // This avoids an unnecessary dependency to libc++abi.\n  void operator delete(void *, size_t) {}\n\n  virtual ~AbstractUnwindCursor() {}\n  virtual bool validReg(int) { _LIBUNWIND_ABORT(\"validReg not implemented\"); }\n  virtual unw_word_t getReg(int) { _LIBUNWIND_ABORT(\"getReg not implemented\"); }\n  virtual void setReg(int, unw_word_t) {\n    _LIBUNWIND_ABORT(\"setReg not implemented\");\n  }\n  virtual bool validFloatReg(int) {\n    _LIBUNWIND_ABORT(\"validFloatReg not implemented\");\n  }\n  virtual unw_fpreg_t getFloatReg(int) {\n    _LIBUNWIND_ABORT(\"getFloatReg not implemented\");\n  }\n  virtual void setFloatReg(int, unw_fpreg_t) {\n    _LIBUNWIND_ABORT(\"setFloatReg not implemented\");\n  }\n  virtual int step() { _LIBUNWIND_ABORT(\"step not implemented\"); }\n  virtual void getInfo(unw_proc_info_t *) {\n    _LIBUNWIND_ABORT(\"getInfo not implemented\");\n  }\n  virtual void jumpto() { _LIBUNWIND_ABORT(\"jumpto not implemented\"); }\n  virtual bool isSignalFrame() {\n    _LIBUNWIND_ABORT(\"isSignalFrame not implemented\");\n  }\n  virtual bool getFunctionName(char *, size_t, unw_word_t *) {\n    _LIBUNWIND_ABORT(\"getFunctionName not implemented\");\n  }\n  virtual void setInfoBasedOnIPRegister(bool = false) {\n    _LIBUNWIND_ABORT(\"setInfoBasedOnIPRegister not implemented\");\n  }\n  virtual const char *getRegisterName(int) {\n    _LIBUNWIND_ABORT(\"getRegisterName not implemented\");\n  }\n#ifdef __arm__\n  virtual void saveVFPAsX() { _LIBUNWIND_ABORT(\"saveVFPAsX not implemented\"); }\n#endif\n};\n\n#if defined(_LIBUNWIND_SUPPORT_SEH_UNWIND) && defined(_WIN32)\n\n/// \\c UnwindCursor contains all state (including all register values) during\n/// an unwind.  This is normally stack-allocated inside a unw_cursor_t.\ntemplate <typename A, typename R>\nclass UnwindCursor : public AbstractUnwindCursor {\n  typedef typename A::pint_t pint_t;\npublic:\n                      UnwindCursor(unw_context_t *context, A &as);\n                      UnwindCursor(CONTEXT *context, A &as);\n                      UnwindCursor(A &as, void *threadArg);\n  virtual             ~UnwindCursor() {}\n  virtual bool        validReg(int);\n  virtual unw_word_t  getReg(int);\n  virtual void        setReg(int, unw_word_t);\n  virtual bool        validFloatReg(int);\n  virtual unw_fpreg_t getFloatReg(int);\n  virtual void        setFloatReg(int, unw_fpreg_t);\n  virtual int         step();\n  virtual void        getInfo(unw_proc_info_t *);\n  virtual void        jumpto();\n  virtual bool        isSignalFrame();\n  virtual bool        getFunctionName(char *buf, size_t len, unw_word_t *off);\n  virtual void        setInfoBasedOnIPRegister(bool isReturnAddress = false);\n  virtual const char *getRegisterName(int num);\n#ifdef __arm__\n  virtual void        saveVFPAsX();\n#endif\n\n  DISPATCHER_CONTEXT *getDispatcherContext() { return &_dispContext; }\n  void setDispatcherContext(DISPATCHER_CONTEXT *disp) { _dispContext = *disp; }\n\n  // libunwind does not and should not depend on C++ library which means that we\n  // need our own defition of inline placement new.\n  static void *operator new(size_t, UnwindCursor<A, R> *p) { return p; }\n\nprivate:\n\n  pint_t getLastPC() const { return _dispContext.ControlPc; }\n  void setLastPC(pint_t pc) { _dispContext.ControlPc = pc; }\n  RUNTIME_FUNCTION *lookUpSEHUnwindInfo(pint_t pc, pint_t *base) {\n    _dispContext.FunctionEntry = RtlLookupFunctionEntry(pc,\n                                                        &_dispContext.ImageBase,\n                                                        _dispContext.HistoryTable);\n    *base = _dispContext.ImageBase;\n    return _dispContext.FunctionEntry;\n  }\n  bool getInfoFromSEH(pint_t pc);\n  int stepWithSEHData() {\n    _dispContext.LanguageHandler = RtlVirtualUnwind(UNW_FLAG_UHANDLER,\n                                                    _dispContext.ImageBase,\n                                                    _dispContext.ControlPc,\n                                                    _dispContext.FunctionEntry,\n                                                    _dispContext.ContextRecord,\n                                                    &_dispContext.HandlerData,\n                                                    &_dispContext.EstablisherFrame,\n                                                    NULL);\n    // Update some fields of the unwind info now, since we have them.\n    _info.lsda = reinterpret_cast<unw_word_t>(_dispContext.HandlerData);\n    if (_dispContext.LanguageHandler) {\n      _info.handler = reinterpret_cast<unw_word_t>(__libunwind_seh_personality);\n    } else\n      _info.handler = 0;\n    return UNW_STEP_SUCCESS;\n  }\n\n  A                   &_addressSpace;\n  unw_proc_info_t      _info;\n  DISPATCHER_CONTEXT   _dispContext;\n  CONTEXT              _msContext;\n  UNWIND_HISTORY_TABLE _histTable;\n  bool                 _unwindInfoMissing;\n};\n\n\ntemplate <typename A, typename R>\nUnwindCursor<A, R>::UnwindCursor(unw_context_t *context, A &as)\n    : _addressSpace(as), _unwindInfoMissing(false) {\n  static_assert((check_fit<UnwindCursor<A, R>, unw_cursor_t>::does_fit),\n                \"UnwindCursor<> does not fit in unw_cursor_t\");\n  static_assert((alignof(UnwindCursor<A, R>) <= alignof(unw_cursor_t)),\n                \"UnwindCursor<> requires more alignment than unw_cursor_t\");\n  memset(&_info, 0, sizeof(_info));\n  memset(&_histTable, 0, sizeof(_histTable));\n  _dispContext.ContextRecord = &_msContext;\n  _dispContext.HistoryTable = &_histTable;\n  // Initialize MS context from ours.\n  R r(context);\n  _msContext.ContextFlags = CONTEXT_CONTROL|CONTEXT_INTEGER|CONTEXT_FLOATING_POINT;\n#if defined(_LIBUNWIND_TARGET_X86_64)\n  _msContext.Rax = r.getRegister(UNW_X86_64_RAX);\n  _msContext.Rcx = r.getRegister(UNW_X86_64_RCX);\n  _msContext.Rdx = r.getRegister(UNW_X86_64_RDX);\n  _msContext.Rbx = r.getRegister(UNW_X86_64_RBX);\n  _msContext.Rsp = r.getRegister(UNW_X86_64_RSP);\n  _msContext.Rbp = r.getRegister(UNW_X86_64_RBP);\n  _msContext.Rsi = r.getRegister(UNW_X86_64_RSI);\n  _msContext.Rdi = r.getRegister(UNW_X86_64_RDI);\n  _msContext.R8 = r.getRegister(UNW_X86_64_R8);\n  _msContext.R9 = r.getRegister(UNW_X86_64_R9);\n  _msContext.R10 = r.getRegister(UNW_X86_64_R10);\n  _msContext.R11 = r.getRegister(UNW_X86_64_R11);\n  _msContext.R12 = r.getRegister(UNW_X86_64_R12);\n  _msContext.R13 = r.getRegister(UNW_X86_64_R13);\n  _msContext.R14 = r.getRegister(UNW_X86_64_R14);\n  _msContext.R15 = r.getRegister(UNW_X86_64_R15);\n  _msContext.Rip = r.getRegister(UNW_REG_IP);\n  union {\n    v128 v;\n    M128A m;\n  } t;\n  t.v = r.getVectorRegister(UNW_X86_64_XMM0);\n  _msContext.Xmm0 = t.m;\n  t.v = r.getVectorRegister(UNW_X86_64_XMM1);\n  _msContext.Xmm1 = t.m;\n  t.v = r.getVectorRegister(UNW_X86_64_XMM2);\n  _msContext.Xmm2 = t.m;\n  t.v = r.getVectorRegister(UNW_X86_64_XMM3);\n  _msContext.Xmm3 = t.m;\n  t.v = r.getVectorRegister(UNW_X86_64_XMM4);\n  _msContext.Xmm4 = t.m;\n  t.v = r.getVectorRegister(UNW_X86_64_XMM5);\n  _msContext.Xmm5 = t.m;\n  t.v = r.getVectorRegister(UNW_X86_64_XMM6);\n  _msContext.Xmm6 = t.m;\n  t.v = r.getVectorRegister(UNW_X86_64_XMM7);\n  _msContext.Xmm7 = t.m;\n  t.v = r.getVectorRegister(UNW_X86_64_XMM8);\n  _msContext.Xmm8 = t.m;\n  t.v = r.getVectorRegister(UNW_X86_64_XMM9);\n  _msContext.Xmm9 = t.m;\n  t.v = r.getVectorRegister(UNW_X86_64_XMM10);\n  _msContext.Xmm10 = t.m;\n  t.v = r.getVectorRegister(UNW_X86_64_XMM11);\n  _msContext.Xmm11 = t.m;\n  t.v = r.getVectorRegister(UNW_X86_64_XMM12);\n  _msContext.Xmm12 = t.m;\n  t.v = r.getVectorRegister(UNW_X86_64_XMM13);\n  _msContext.Xmm13 = t.m;\n  t.v = r.getVectorRegister(UNW_X86_64_XMM14);\n  _msContext.Xmm14 = t.m;\n  t.v = r.getVectorRegister(UNW_X86_64_XMM15);\n  _msContext.Xmm15 = t.m;\n#elif defined(_LIBUNWIND_TARGET_ARM)\n  _msContext.R0 = r.getRegister(UNW_ARM_R0);\n  _msContext.R1 = r.getRegister(UNW_ARM_R1);\n  _msContext.R2 = r.getRegister(UNW_ARM_R2);\n  _msContext.R3 = r.getRegister(UNW_ARM_R3);\n  _msContext.R4 = r.getRegister(UNW_ARM_R4);\n  _msContext.R5 = r.getRegister(UNW_ARM_R5);\n  _msContext.R6 = r.getRegister(UNW_ARM_R6);\n  _msContext.R7 = r.getRegister(UNW_ARM_R7);\n  _msContext.R8 = r.getRegister(UNW_ARM_R8);\n  _msContext.R9 = r.getRegister(UNW_ARM_R9);\n  _msContext.R10 = r.getRegister(UNW_ARM_R10);\n  _msContext.R11 = r.getRegister(UNW_ARM_R11);\n  _msContext.R12 = r.getRegister(UNW_ARM_R12);\n  _msContext.Sp = r.getRegister(UNW_ARM_SP);\n  _msContext.Lr = r.getRegister(UNW_ARM_LR);\n  _msContext.Pc = r.getRegister(UNW_ARM_IP);\n  for (int i = UNW_ARM_D0; i <= UNW_ARM_D31; ++i) {\n    union {\n      uint64_t w;\n      double d;\n    } d;\n    d.d = r.getFloatRegister(i);\n    _msContext.D[i - UNW_ARM_D0] = d.w;\n  }\n#elif defined(_LIBUNWIND_TARGET_AARCH64)\n  for (int i = UNW_ARM64_X0; i <= UNW_ARM64_X30; ++i)\n    _msContext.X[i - UNW_ARM64_X0] = r.getRegister(i);\n  _msContext.Sp = r.getRegister(UNW_REG_SP);\n  _msContext.Pc = r.getRegister(UNW_REG_IP);\n  for (int i = UNW_ARM64_D0; i <= UNW_ARM64_D31; ++i)\n    _msContext.V[i - UNW_ARM64_D0].D[0] = r.getFloatRegister(i);\n#endif\n}\n\ntemplate <typename A, typename R>\nUnwindCursor<A, R>::UnwindCursor(CONTEXT *context, A &as)\n    : _addressSpace(as), _unwindInfoMissing(false) {\n  static_assert((check_fit<UnwindCursor<A, R>, unw_cursor_t>::does_fit),\n                \"UnwindCursor<> does not fit in unw_cursor_t\");\n  memset(&_info, 0, sizeof(_info));\n  memset(&_histTable, 0, sizeof(_histTable));\n  _dispContext.ContextRecord = &_msContext;\n  _dispContext.HistoryTable = &_histTable;\n  _msContext = *context;\n}\n\n\ntemplate <typename A, typename R>\nbool UnwindCursor<A, R>::validReg(int regNum) {\n  if (regNum == UNW_REG_IP || regNum == UNW_REG_SP) return true;\n#if defined(_LIBUNWIND_TARGET_X86_64)\n  if (regNum >= UNW_X86_64_RAX && regNum <= UNW_X86_64_R15) return true;\n#elif defined(_LIBUNWIND_TARGET_ARM)\n  if (regNum >= UNW_ARM_R0 && regNum <= UNW_ARM_R15) return true;\n#elif defined(_LIBUNWIND_TARGET_AARCH64)\n  if (regNum >= UNW_ARM64_X0 && regNum <= UNW_ARM64_X30) return true;\n#endif\n  return false;\n}\n\ntemplate <typename A, typename R>\nunw_word_t UnwindCursor<A, R>::getReg(int regNum) {\n  switch (regNum) {\n#if defined(_LIBUNWIND_TARGET_X86_64)\n  case UNW_REG_IP: return _msContext.Rip;\n  case UNW_X86_64_RAX: return _msContext.Rax;\n  case UNW_X86_64_RDX: return _msContext.Rdx;\n  case UNW_X86_64_RCX: return _msContext.Rcx;\n  case UNW_X86_64_RBX: return _msContext.Rbx;\n  case UNW_REG_SP:\n  case UNW_X86_64_RSP: return _msContext.Rsp;\n  case UNW_X86_64_RBP: return _msContext.Rbp;\n  case UNW_X86_64_RSI: return _msContext.Rsi;\n  case UNW_X86_64_RDI: return _msContext.Rdi;\n  case UNW_X86_64_R8: return _msContext.R8;\n  case UNW_X86_64_R9: return _msContext.R9;\n  case UNW_X86_64_R10: return _msContext.R10;\n  case UNW_X86_64_R11: return _msContext.R11;\n  case UNW_X86_64_R12: return _msContext.R12;\n  case UNW_X86_64_R13: return _msContext.R13;\n  case UNW_X86_64_R14: return _msContext.R14;\n  case UNW_X86_64_R15: return _msContext.R15;\n#elif defined(_LIBUNWIND_TARGET_ARM)\n  case UNW_ARM_R0: return _msContext.R0;\n  case UNW_ARM_R1: return _msContext.R1;\n  case UNW_ARM_R2: return _msContext.R2;\n  case UNW_ARM_R3: return _msContext.R3;\n  case UNW_ARM_R4: return _msContext.R4;\n  case UNW_ARM_R5: return _msContext.R5;\n  case UNW_ARM_R6: return _msContext.R6;\n  case UNW_ARM_R7: return _msContext.R7;\n  case UNW_ARM_R8: return _msContext.R8;\n  case UNW_ARM_R9: return _msContext.R9;\n  case UNW_ARM_R10: return _msContext.R10;\n  case UNW_ARM_R11: return _msContext.R11;\n  case UNW_ARM_R12: return _msContext.R12;\n  case UNW_REG_SP:\n  case UNW_ARM_SP: return _msContext.Sp;\n  case UNW_ARM_LR: return _msContext.Lr;\n  case UNW_REG_IP:\n  case UNW_ARM_IP: return _msContext.Pc;\n#elif defined(_LIBUNWIND_TARGET_AARCH64)\n  case UNW_REG_SP: return _msContext.Sp;\n  case UNW_REG_IP: return _msContext.Pc;\n  default: return _msContext.X[regNum - UNW_ARM64_X0];\n#endif\n  }\n  _LIBUNWIND_ABORT(\"unsupported register\");\n}\n\ntemplate <typename A, typename R>\nvoid UnwindCursor<A, R>::setReg(int regNum, unw_word_t value) {\n  switch (regNum) {\n#if defined(_LIBUNWIND_TARGET_X86_64)\n  case UNW_REG_IP: _msContext.Rip = value; break;\n  case UNW_X86_64_RAX: _msContext.Rax = value; break;\n  case UNW_X86_64_RDX: _msContext.Rdx = value; break;\n  case UNW_X86_64_RCX: _msContext.Rcx = value; break;\n  case UNW_X86_64_RBX: _msContext.Rbx = value; break;\n  case UNW_REG_SP:\n  case UNW_X86_64_RSP: _msContext.Rsp = value; break;\n  case UNW_X86_64_RBP: _msContext.Rbp = value; break;\n  case UNW_X86_64_RSI: _msContext.Rsi = value; break;\n  case UNW_X86_64_RDI: _msContext.Rdi = value; break;\n  case UNW_X86_64_R8: _msContext.R8 = value; break;\n  case UNW_X86_64_R9: _msContext.R9 = value; break;\n  case UNW_X86_64_R10: _msContext.R10 = value; break;\n  case UNW_X86_64_R11: _msContext.R11 = value; break;\n  case UNW_X86_64_R12: _msContext.R12 = value; break;\n  case UNW_X86_64_R13: _msContext.R13 = value; break;\n  case UNW_X86_64_R14: _msContext.R14 = value; break;\n  case UNW_X86_64_R15: _msContext.R15 = value; break;\n#elif defined(_LIBUNWIND_TARGET_ARM)\n  case UNW_ARM_R0: _msContext.R0 = value; break;\n  case UNW_ARM_R1: _msContext.R1 = value; break;\n  case UNW_ARM_R2: _msContext.R2 = value; break;\n  case UNW_ARM_R3: _msContext.R3 = value; break;\n  case UNW_ARM_R4: _msContext.R4 = value; break;\n  case UNW_ARM_R5: _msContext.R5 = value; break;\n  case UNW_ARM_R6: _msContext.R6 = value; break;\n  case UNW_ARM_R7: _msContext.R7 = value; break;\n  case UNW_ARM_R8: _msContext.R8 = value; break;\n  case UNW_ARM_R9: _msContext.R9 = value; break;\n  case UNW_ARM_R10: _msContext.R10 = value; break;\n  case UNW_ARM_R11: _msContext.R11 = value; break;\n  case UNW_ARM_R12: _msContext.R12 = value; break;\n  case UNW_REG_SP:\n  case UNW_ARM_SP: _msContext.Sp = value; break;\n  case UNW_ARM_LR: _msContext.Lr = value; break;\n  case UNW_REG_IP:\n  case UNW_ARM_IP: _msContext.Pc = value; break;\n#elif defined(_LIBUNWIND_TARGET_AARCH64)\n  case UNW_REG_SP: _msContext.Sp = value; break;\n  case UNW_REG_IP: _msContext.Pc = value; break;\n  case UNW_ARM64_X0:\n  case UNW_ARM64_X1:\n  case UNW_ARM64_X2:\n  case UNW_ARM64_X3:\n  case UNW_ARM64_X4:\n  case UNW_ARM64_X5:\n  case UNW_ARM64_X6:\n  case UNW_ARM64_X7:\n  case UNW_ARM64_X8:\n  case UNW_ARM64_X9:\n  case UNW_ARM64_X10:\n  case UNW_ARM64_X11:\n  case UNW_ARM64_X12:\n  case UNW_ARM64_X13:\n  case UNW_ARM64_X14:\n  case UNW_ARM64_X15:\n  case UNW_ARM64_X16:\n  case UNW_ARM64_X17:\n  case UNW_ARM64_X18:\n  case UNW_ARM64_X19:\n  case UNW_ARM64_X20:\n  case UNW_ARM64_X21:\n  case UNW_ARM64_X22:\n  case UNW_ARM64_X23:\n  case UNW_ARM64_X24:\n  case UNW_ARM64_X25:\n  case UNW_ARM64_X26:\n  case UNW_ARM64_X27:\n  case UNW_ARM64_X28:\n  case UNW_ARM64_FP:\n  case UNW_ARM64_LR: _msContext.X[regNum - UNW_ARM64_X0] = value; break;\n#endif\n  default:\n    _LIBUNWIND_ABORT(\"unsupported register\");\n  }\n}\n\ntemplate <typename A, typename R>\nbool UnwindCursor<A, R>::validFloatReg(int regNum) {\n#if defined(_LIBUNWIND_TARGET_ARM)\n  if (regNum >= UNW_ARM_S0 && regNum <= UNW_ARM_S31) return true;\n  if (regNum >= UNW_ARM_D0 && regNum <= UNW_ARM_D31) return true;\n#elif defined(_LIBUNWIND_TARGET_AARCH64)\n  if (regNum >= UNW_ARM64_D0 && regNum <= UNW_ARM64_D31) return true;\n#else\n  (void)regNum;\n#endif\n  return false;\n}\n\ntemplate <typename A, typename R>\nunw_fpreg_t UnwindCursor<A, R>::getFloatReg(int regNum) {\n#if defined(_LIBUNWIND_TARGET_ARM)\n  if (regNum >= UNW_ARM_S0 && regNum <= UNW_ARM_S31) {\n    union {\n      uint32_t w;\n      float f;\n    } d;\n    d.w = _msContext.S[regNum - UNW_ARM_S0];\n    return d.f;\n  }\n  if (regNum >= UNW_ARM_D0 && regNum <= UNW_ARM_D31) {\n    union {\n      uint64_t w;\n      double d;\n    } d;\n    d.w = _msContext.D[regNum - UNW_ARM_D0];\n    return d.d;\n  }\n  _LIBUNWIND_ABORT(\"unsupported float register\");\n#elif defined(_LIBUNWIND_TARGET_AARCH64)\n  return _msContext.V[regNum - UNW_ARM64_D0].D[0];\n#else\n  (void)regNum;\n  _LIBUNWIND_ABORT(\"float registers unimplemented\");\n#endif\n}\n\ntemplate <typename A, typename R>\nvoid UnwindCursor<A, R>::setFloatReg(int regNum, unw_fpreg_t value) {\n#if defined(_LIBUNWIND_TARGET_ARM)\n  if (regNum >= UNW_ARM_S0 && regNum <= UNW_ARM_S31) {\n    union {\n      uint32_t w;\n      float f;\n    } d;\n    d.f = value;\n    _msContext.S[regNum - UNW_ARM_S0] = d.w;\n  }\n  if (regNum >= UNW_ARM_D0 && regNum <= UNW_ARM_D31) {\n    union {\n      uint64_t w;\n      double d;\n    } d;\n    d.d = value;\n    _msContext.D[regNum - UNW_ARM_D0] = d.w;\n  }\n  _LIBUNWIND_ABORT(\"unsupported float register\");\n#elif defined(_LIBUNWIND_TARGET_AARCH64)\n  _msContext.V[regNum - UNW_ARM64_D0].D[0] = value;\n#else\n  (void)regNum;\n  (void)value;\n  _LIBUNWIND_ABORT(\"float registers unimplemented\");\n#endif\n}\n\ntemplate <typename A, typename R> void UnwindCursor<A, R>::jumpto() {\n  RtlRestoreContext(&_msContext, nullptr);\n}\n\n#ifdef __arm__\ntemplate <typename A, typename R> void UnwindCursor<A, R>::saveVFPAsX() {}\n#endif\n\ntemplate <typename A, typename R>\nconst char *UnwindCursor<A, R>::getRegisterName(int regNum) {\n  return R::getRegisterName(regNum);\n}\n\ntemplate <typename A, typename R> bool UnwindCursor<A, R>::isSignalFrame() {\n  return false;\n}\n\n#else  // !defined(_LIBUNWIND_SUPPORT_SEH_UNWIND) || !defined(_WIN32)\n\n/// UnwindCursor contains all state (including all register values) during\n/// an unwind.  This is normally stack allocated inside a unw_cursor_t.\ntemplate <typename A, typename R>\nclass UnwindCursor : public AbstractUnwindCursor{\n  typedef typename A::pint_t pint_t;\npublic:\n                      UnwindCursor(unw_context_t *context, A &as);\n                      UnwindCursor(A &as, void *threadArg);\n  virtual             ~UnwindCursor() {}\n  virtual bool        validReg(int);\n  virtual unw_word_t  getReg(int);\n  virtual void        setReg(int, unw_word_t);\n  virtual bool        validFloatReg(int);\n  virtual unw_fpreg_t getFloatReg(int);\n  virtual void        setFloatReg(int, unw_fpreg_t);\n  virtual int         step();\n  virtual void        getInfo(unw_proc_info_t *);\n  virtual void        jumpto();\n  virtual bool        isSignalFrame();\n  virtual bool        getFunctionName(char *buf, size_t len, unw_word_t *off);\n  virtual void        setInfoBasedOnIPRegister(bool isReturnAddress = false);\n  virtual const char *getRegisterName(int num);\n#ifdef __arm__\n  virtual void        saveVFPAsX();\n#endif\n\n  // libunwind does not and should not depend on C++ library which means that we\n  // need our own defition of inline placement new.\n  static void *operator new(size_t, UnwindCursor<A, R> *p) { return p; }\n\nprivate:\n\n#if defined(_LIBUNWIND_ARM_EHABI)\n  bool getInfoFromEHABISection(pint_t pc, const UnwindInfoSections &sects);\n\n  int stepWithEHABI() {\n    size_t len = 0;\n    size_t off = 0;\n    // FIXME: Calling decode_eht_entry() here is violating the libunwind\n    // abstraction layer.\n    const uint32_t *ehtp =\n        decode_eht_entry(reinterpret_cast<const uint32_t *>(_info.unwind_info),\n                         &off, &len);\n    if (_Unwind_VRS_Interpret((_Unwind_Context *)this, ehtp, off, len) !=\n            _URC_CONTINUE_UNWIND)\n      return UNW_STEP_END;\n    return UNW_STEP_SUCCESS;\n  }\n#endif\n\n#if defined(_LIBUNWIND_TARGET_LINUX) && defined(_LIBUNWIND_TARGET_AARCH64)\n  bool setInfoForSigReturn() {\n    R dummy;\n    return setInfoForSigReturn(dummy);\n  }\n  int stepThroughSigReturn() {\n    R dummy;\n    return stepThroughSigReturn(dummy);\n  }\n  bool setInfoForSigReturn(Registers_arm64 &);\n  int stepThroughSigReturn(Registers_arm64 &);\n  template <typename Registers> bool setInfoForSigReturn(Registers &) {\n    return false;\n  }\n  template <typename Registers> int stepThroughSigReturn(Registers &) {\n    return UNW_STEP_END;\n  }\n#endif\n\n#if defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND)\n  bool getInfoFromFdeCie(const typename CFI_Parser<A>::FDE_Info &fdeInfo,\n                         const typename CFI_Parser<A>::CIE_Info &cieInfo,\n                         pint_t pc, uintptr_t dso_base);\n  bool getInfoFromDwarfSection(pint_t pc, const UnwindInfoSections &sects,\n                                            uint32_t fdeSectionOffsetHint=0);\n  int stepWithDwarfFDE() {\n    return DwarfInstructions<A, R>::stepWithDwarf(_addressSpace,\n                                              (pint_t)this->getReg(UNW_REG_IP),\n                                              (pint_t)_info.unwind_info,\n                                              _registers, _isSignalFrame);\n  }\n#endif\n\n#if defined(_LIBUNWIND_SUPPORT_COMPACT_UNWIND)\n  bool getInfoFromCompactEncodingSection(pint_t pc,\n                                            const UnwindInfoSections &sects);\n  int stepWithCompactEncoding() {\n  #if defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND)\n    if ( compactSaysUseDwarf() )\n      return stepWithDwarfFDE();\n  #endif\n    R dummy;\n    return stepWithCompactEncoding(dummy);\n  }\n\n#if defined(_LIBUNWIND_TARGET_X86_64)\n  int stepWithCompactEncoding(Registers_x86_64 &) {\n    return CompactUnwinder_x86_64<A>::stepWithCompactEncoding(\n        _info.format, _info.start_ip, _addressSpace, _registers);\n  }\n#endif\n\n#if defined(_LIBUNWIND_TARGET_I386)\n  int stepWithCompactEncoding(Registers_x86 &) {\n    return CompactUnwinder_x86<A>::stepWithCompactEncoding(\n        _info.format, (uint32_t)_info.start_ip, _addressSpace, _registers);\n  }\n#endif\n\n#if defined(_LIBUNWIND_TARGET_PPC)\n  int stepWithCompactEncoding(Registers_ppc &) {\n    return UNW_EINVAL;\n  }\n#endif\n\n#if defined(_LIBUNWIND_TARGET_PPC64)\n  int stepWithCompactEncoding(Registers_ppc64 &) {\n    return UNW_EINVAL;\n  }\n#endif\n\n\n#if defined(_LIBUNWIND_TARGET_AARCH64)\n  int stepWithCompactEncoding(Registers_arm64 &) {\n    return CompactUnwinder_arm64<A>::stepWithCompactEncoding(\n        _info.format, _info.start_ip, _addressSpace, _registers);\n  }\n#endif\n\n#if defined(_LIBUNWIND_TARGET_MIPS_O32)\n  int stepWithCompactEncoding(Registers_mips_o32 &) {\n    return UNW_EINVAL;\n  }\n#endif\n\n#if defined(_LIBUNWIND_TARGET_MIPS_NEWABI)\n  int stepWithCompactEncoding(Registers_mips_newabi &) {\n    return UNW_EINVAL;\n  }\n#endif\n\n#if defined(_LIBUNWIND_TARGET_SPARC)\n  int stepWithCompactEncoding(Registers_sparc &) { return UNW_EINVAL; }\n#endif\n\n#if defined (_LIBUNWIND_TARGET_RISCV)\n  int stepWithCompactEncoding(Registers_riscv &) {\n    return UNW_EINVAL;\n  }\n#endif\n\n  bool compactSaysUseDwarf(uint32_t *offset=NULL) const {\n    R dummy;\n    return compactSaysUseDwarf(dummy, offset);\n  }\n\n#if defined(_LIBUNWIND_TARGET_X86_64)\n  bool compactSaysUseDwarf(Registers_x86_64 &, uint32_t *offset) const {\n    if ((_info.format & UNWIND_X86_64_MODE_MASK) == UNWIND_X86_64_MODE_DWARF) {\n      if (offset)\n        *offset = (_info.format & UNWIND_X86_64_DWARF_SECTION_OFFSET);\n      return true;\n    }\n    return false;\n  }\n#endif\n\n#if defined(_LIBUNWIND_TARGET_I386)\n  bool compactSaysUseDwarf(Registers_x86 &, uint32_t *offset) const {\n    if ((_info.format & UNWIND_X86_MODE_MASK) == UNWIND_X86_MODE_DWARF) {\n      if (offset)\n        *offset = (_info.format & UNWIND_X86_DWARF_SECTION_OFFSET);\n      return true;\n    }\n    return false;\n  }\n#endif\n\n#if defined(_LIBUNWIND_TARGET_PPC)\n  bool compactSaysUseDwarf(Registers_ppc &, uint32_t *) const {\n    return true;\n  }\n#endif\n\n#if defined(_LIBUNWIND_TARGET_PPC64)\n  bool compactSaysUseDwarf(Registers_ppc64 &, uint32_t *) const {\n    return true;\n  }\n#endif\n\n#if defined(_LIBUNWIND_TARGET_AARCH64)\n  bool compactSaysUseDwarf(Registers_arm64 &, uint32_t *offset) const {\n    if ((_info.format & UNWIND_ARM64_MODE_MASK) == UNWIND_ARM64_MODE_DWARF) {\n      if (offset)\n        *offset = (_info.format & UNWIND_ARM64_DWARF_SECTION_OFFSET);\n      return true;\n    }\n    return false;\n  }\n#endif\n\n#if defined(_LIBUNWIND_TARGET_MIPS_O32)\n  bool compactSaysUseDwarf(Registers_mips_o32 &, uint32_t *) const {\n    return true;\n  }\n#endif\n\n#if defined(_LIBUNWIND_TARGET_MIPS_NEWABI)\n  bool compactSaysUseDwarf(Registers_mips_newabi &, uint32_t *) const {\n    return true;\n  }\n#endif\n\n#if defined(_LIBUNWIND_TARGET_SPARC)\n  bool compactSaysUseDwarf(Registers_sparc &, uint32_t *) const { return true; }\n#endif\n\n#if defined (_LIBUNWIND_TARGET_RISCV)\n  bool compactSaysUseDwarf(Registers_riscv &, uint32_t *) const {\n    return true;\n  }\n#endif\n\n#endif // defined(_LIBUNWIND_SUPPORT_COMPACT_UNWIND)\n\n#if defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND)\n  compact_unwind_encoding_t dwarfEncoding() const {\n    R dummy;\n    return dwarfEncoding(dummy);\n  }\n\n#if defined(_LIBUNWIND_TARGET_X86_64)\n  compact_unwind_encoding_t dwarfEncoding(Registers_x86_64 &) const {\n    return UNWIND_X86_64_MODE_DWARF;\n  }\n#endif\n\n#if defined(_LIBUNWIND_TARGET_I386)\n  compact_unwind_encoding_t dwarfEncoding(Registers_x86 &) const {\n    return UNWIND_X86_MODE_DWARF;\n  }\n#endif\n\n#if defined(_LIBUNWIND_TARGET_PPC)\n  compact_unwind_encoding_t dwarfEncoding(Registers_ppc &) const {\n    return 0;\n  }\n#endif\n\n#if defined(_LIBUNWIND_TARGET_PPC64)\n  compact_unwind_encoding_t dwarfEncoding(Registers_ppc64 &) const {\n    return 0;\n  }\n#endif\n\n#if defined(_LIBUNWIND_TARGET_AARCH64)\n  compact_unwind_encoding_t dwarfEncoding(Registers_arm64 &) const {\n    return UNWIND_ARM64_MODE_DWARF;\n  }\n#endif\n\n#if defined(_LIBUNWIND_TARGET_ARM)\n  compact_unwind_encoding_t dwarfEncoding(Registers_arm &) const {\n    return 0;\n  }\n#endif\n\n#if defined (_LIBUNWIND_TARGET_OR1K)\n  compact_unwind_encoding_t dwarfEncoding(Registers_or1k &) const {\n    return 0;\n  }\n#endif\n\n#if defined (_LIBUNWIND_TARGET_HEXAGON)\n  compact_unwind_encoding_t dwarfEncoding(Registers_hexagon &) const {\n    return 0;\n  }\n#endif\n\n#if defined (_LIBUNWIND_TARGET_MIPS_O32)\n  compact_unwind_encoding_t dwarfEncoding(Registers_mips_o32 &) const {\n    return 0;\n  }\n#endif\n\n#if defined (_LIBUNWIND_TARGET_MIPS_NEWABI)\n  compact_unwind_encoding_t dwarfEncoding(Registers_mips_newabi &) const {\n    return 0;\n  }\n#endif\n\n#if defined(_LIBUNWIND_TARGET_SPARC)\n  compact_unwind_encoding_t dwarfEncoding(Registers_sparc &) const { return 0; }\n#endif\n\n#if defined (_LIBUNWIND_TARGET_RISCV)\n  compact_unwind_encoding_t dwarfEncoding(Registers_riscv &) const {\n    return 0;\n  }\n#endif\n\n#endif // defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND)\n\n#if defined(_LIBUNWIND_SUPPORT_SEH_UNWIND)\n  // For runtime environments using SEH unwind data without Windows runtime\n  // support.\n  pint_t getLastPC() const { /* FIXME: Implement */ return 0; }\n  void setLastPC(pint_t pc) { /* FIXME: Implement */ }\n  RUNTIME_FUNCTION *lookUpSEHUnwindInfo(pint_t pc, pint_t *base) {\n    /* FIXME: Implement */\n    *base = 0;\n    return nullptr;\n  }\n  bool getInfoFromSEH(pint_t pc);\n  int stepWithSEHData() { /* FIXME: Implement */ return 0; }\n#endif // defined(_LIBUNWIND_SUPPORT_SEH_UNWIND)\n\n\n  A               &_addressSpace;\n  R                _registers;\n  unw_proc_info_t  _info;\n  bool             _unwindInfoMissing;\n  bool             _isSignalFrame;\n#if defined(_LIBUNWIND_TARGET_LINUX) && defined(_LIBUNWIND_TARGET_AARCH64)\n  bool             _isSigReturn = false;\n#endif\n};\n\n\ntemplate <typename A, typename R>\nUnwindCursor<A, R>::UnwindCursor(unw_context_t *context, A &as)\n    : _addressSpace(as), _registers(context), _unwindInfoMissing(false),\n      _isSignalFrame(false) {\n  static_assert((check_fit<UnwindCursor<A, R>, unw_cursor_t>::does_fit),\n                \"UnwindCursor<> does not fit in unw_cursor_t\");\n  static_assert((alignof(UnwindCursor<A, R>) <= alignof(unw_cursor_t)),\n                \"UnwindCursor<> requires more alignment than unw_cursor_t\");\n  memset(&_info, 0, sizeof(_info));\n}\n\ntemplate <typename A, typename R>\nUnwindCursor<A, R>::UnwindCursor(A &as, void *)\n    : _addressSpace(as), _unwindInfoMissing(false), _isSignalFrame(false) {\n  memset(&_info, 0, sizeof(_info));\n  // FIXME\n  // fill in _registers from thread arg\n}\n\n\ntemplate <typename A, typename R>\nbool UnwindCursor<A, R>::validReg(int regNum) {\n  return _registers.validRegister(regNum);\n}\n\ntemplate <typename A, typename R>\nunw_word_t UnwindCursor<A, R>::getReg(int regNum) {\n  return _registers.getRegister(regNum);\n}\n\ntemplate <typename A, typename R>\nvoid UnwindCursor<A, R>::setReg(int regNum, unw_word_t value) {\n  _registers.setRegister(regNum, (typename A::pint_t)value);\n}\n\ntemplate <typename A, typename R>\nbool UnwindCursor<A, R>::validFloatReg(int regNum) {\n  return _registers.validFloatRegister(regNum);\n}\n\ntemplate <typename A, typename R>\nunw_fpreg_t UnwindCursor<A, R>::getFloatReg(int regNum) {\n  return _registers.getFloatRegister(regNum);\n}\n\ntemplate <typename A, typename R>\nvoid UnwindCursor<A, R>::setFloatReg(int regNum, unw_fpreg_t value) {\n  _registers.setFloatRegister(regNum, value);\n}\n\ntemplate <typename A, typename R> void UnwindCursor<A, R>::jumpto() {\n  _registers.jumpto();\n}\n\n#ifdef __arm__\ntemplate <typename A, typename R> void UnwindCursor<A, R>::saveVFPAsX() {\n  _registers.saveVFPAsX();\n}\n#endif\n\ntemplate <typename A, typename R>\nconst char *UnwindCursor<A, R>::getRegisterName(int regNum) {\n  return _registers.getRegisterName(regNum);\n}\n\ntemplate <typename A, typename R> bool UnwindCursor<A, R>::isSignalFrame() {\n  return _isSignalFrame;\n}\n\n#endif // defined(_LIBUNWIND_SUPPORT_SEH_UNWIND)\n\n#if defined(_LIBUNWIND_ARM_EHABI)\ntemplate<typename A>\nstruct EHABISectionIterator {\n  typedef EHABISectionIterator _Self;\n\n  typedef typename A::pint_t value_type;\n  typedef typename A::pint_t* pointer;\n  typedef typename A::pint_t& reference;\n  typedef size_t size_type;\n  typedef size_t difference_type;\n\n  static _Self begin(A& addressSpace, const UnwindInfoSections& sects) {\n    return _Self(addressSpace, sects, 0);\n  }\n  static _Self end(A& addressSpace, const UnwindInfoSections& sects) {\n    return _Self(addressSpace, sects,\n                 sects.arm_section_length / sizeof(EHABIIndexEntry));\n  }\n\n  EHABISectionIterator(A& addressSpace, const UnwindInfoSections& sects, size_t i)\n      : _i(i), _addressSpace(&addressSpace), _sects(&sects) {}\n\n  _Self& operator++() { ++_i; return *this; }\n  _Self& operator+=(size_t a) { _i += a; return *this; }\n  _Self& operator--() { assert(_i > 0); --_i; return *this; }\n  _Self& operator-=(size_t a) { assert(_i >= a); _i -= a; return *this; }\n\n  _Self operator+(size_t a) { _Self out = *this; out._i += a; return out; }\n  _Self operator-(size_t a) { assert(_i >= a); _Self out = *this; out._i -= a; return out; }\n\n  size_t operator-(const _Self& other) const { return _i - other._i; }\n\n  bool operator==(const _Self& other) const {\n    assert(_addressSpace == other._addressSpace);\n    assert(_sects == other._sects);\n    return _i == other._i;\n  }\n\n  bool operator!=(const _Self& other) const {\n    assert(_addressSpace == other._addressSpace);\n    assert(_sects == other._sects);\n    return _i != other._i;\n  }\n\n  typename A::pint_t operator*() const { return functionAddress(); }\n\n  typename A::pint_t functionAddress() const {\n    typename A::pint_t indexAddr = _sects->arm_section + arrayoffsetof(\n        EHABIIndexEntry, _i, functionOffset);\n    return indexAddr + signExtendPrel31(_addressSpace->get32(indexAddr));\n  }\n\n  typename A::pint_t dataAddress() {\n    typename A::pint_t indexAddr = _sects->arm_section + arrayoffsetof(\n        EHABIIndexEntry, _i, data);\n    return indexAddr;\n  }\n\n private:\n  size_t _i;\n  A* _addressSpace;\n  const UnwindInfoSections* _sects;\n};\n\nnamespace {\n\ntemplate <typename A>\nEHABISectionIterator<A> EHABISectionUpperBound(\n    EHABISectionIterator<A> first,\n    EHABISectionIterator<A> last,\n    typename A::pint_t value) {\n  size_t len = last - first;\n  while (len > 0) {\n    size_t l2 = len / 2;\n    EHABISectionIterator<A> m = first + l2;\n    if (value < *m) {\n        len = l2;\n    } else {\n        first = ++m;\n        len -= l2 + 1;\n    }\n  }\n  return first;\n}\n\n}\n\ntemplate <typename A, typename R>\nbool UnwindCursor<A, R>::getInfoFromEHABISection(\n    pint_t pc,\n    const UnwindInfoSections &sects) {\n  EHABISectionIterator<A> begin =\n      EHABISectionIterator<A>::begin(_addressSpace, sects);\n  EHABISectionIterator<A> end =\n      EHABISectionIterator<A>::end(_addressSpace, sects);\n  if (begin == end)\n    return false;\n\n  EHABISectionIterator<A> itNextPC = EHABISectionUpperBound(begin, end, pc);\n  if (itNextPC == begin)\n    return false;\n  EHABISectionIterator<A> itThisPC = itNextPC - 1;\n\n  pint_t thisPC = itThisPC.functionAddress();\n  // If an exception is thrown from a function, corresponding to the last entry\n  // in the table, we don't really know the function extent and have to choose a\n  // value for nextPC. Choosing max() will allow the range check during trace to\n  // succeed.\n  pint_t nextPC = (itNextPC == end) ? UINTPTR_MAX : itNextPC.functionAddress();\n  pint_t indexDataAddr = itThisPC.dataAddress();\n\n  if (indexDataAddr == 0)\n    return false;\n\n  uint32_t indexData = _addressSpace.get32(indexDataAddr);\n  if (indexData == UNW_EXIDX_CANTUNWIND)\n    return false;\n\n  // If the high bit is set, the exception handling table entry is inline inside\n  // the index table entry on the second word (aka |indexDataAddr|). Otherwise,\n  // the table points at an offset in the exception handling table (section 5\n  // EHABI).\n  pint_t exceptionTableAddr;\n  uint32_t exceptionTableData;\n  bool isSingleWordEHT;\n  if (indexData & 0x80000000) {\n    exceptionTableAddr = indexDataAddr;\n    // TODO(ajwong): Should this data be 0?\n    exceptionTableData = indexData;\n    isSingleWordEHT = true;\n  } else {\n    exceptionTableAddr = indexDataAddr + signExtendPrel31(indexData);\n    exceptionTableData = _addressSpace.get32(exceptionTableAddr);\n    isSingleWordEHT = false;\n  }\n\n  // Now we know the 3 things:\n  //   exceptionTableAddr -- exception handler table entry.\n  //   exceptionTableData -- the data inside the first word of the eht entry.\n  //   isSingleWordEHT -- whether the entry is in the index.\n  unw_word_t personalityRoutine = 0xbadf00d;\n  bool scope32 = false;\n  uintptr_t lsda;\n\n  // If the high bit in the exception handling table entry is set, the entry is\n  // in compact form (section 6.3 EHABI).\n  if (exceptionTableData & 0x80000000) {\n    // Grab the index of the personality routine from the compact form.\n    uint32_t choice = (exceptionTableData & 0x0f000000) >> 24;\n    uint32_t extraWords = 0;\n    switch (choice) {\n      case 0:\n        personalityRoutine = (unw_word_t) &__aeabi_unwind_cpp_pr0;\n        extraWords = 0;\n        scope32 = false;\n        lsda = isSingleWordEHT ? 0 : (exceptionTableAddr + 4);\n        break;\n      case 1:\n        personalityRoutine = (unw_word_t) &__aeabi_unwind_cpp_pr1;\n        extraWords = (exceptionTableData & 0x00ff0000) >> 16;\n        scope32 = false;\n        lsda = exceptionTableAddr + (extraWords + 1) * 4;\n        break;\n      case 2:\n        personalityRoutine = (unw_word_t) &__aeabi_unwind_cpp_pr2;\n        extraWords = (exceptionTableData & 0x00ff0000) >> 16;\n        scope32 = true;\n        lsda = exceptionTableAddr + (extraWords + 1) * 4;\n        break;\n      default:\n        _LIBUNWIND_ABORT(\"unknown personality routine\");\n        return false;\n    }\n\n    if (isSingleWordEHT) {\n      if (extraWords != 0) {\n        _LIBUNWIND_ABORT(\"index inlined table detected but pr function \"\n                         \"requires extra words\");\n        return false;\n      }\n    }\n  } else {\n    pint_t personalityAddr =\n        exceptionTableAddr + signExtendPrel31(exceptionTableData);\n    personalityRoutine = personalityAddr;\n\n    // ARM EHABI # 6.2, # 9.2\n    //\n    //  +---- ehtp\n    //  v\n    // +--------------------------------------+\n    // | +--------+--------+--------+-------+ |\n    // | |0| prel31 to personalityRoutine   | |\n    // | +--------+--------+--------+-------+ |\n    // | |      N |      unwind opcodes     | |  <-- UnwindData\n    // | +--------+--------+--------+-------+ |\n    // | | Word 2        unwind opcodes     | |\n    // | +--------+--------+--------+-------+ |\n    // | ...                                  |\n    // | +--------+--------+--------+-------+ |\n    // | | Word N        unwind opcodes     | |\n    // | +--------+--------+--------+-------+ |\n    // | | LSDA                             | |  <-- lsda\n    // | | ...                              | |\n    // | +--------+--------+--------+-------+ |\n    // +--------------------------------------+\n\n    uint32_t *UnwindData = reinterpret_cast<uint32_t*>(exceptionTableAddr) + 1;\n    uint32_t FirstDataWord = *UnwindData;\n    size_t N = ((FirstDataWord >> 24) & 0xff);\n    size_t NDataWords = N + 1;\n    lsda = reinterpret_cast<uintptr_t>(UnwindData + NDataWords);\n  }\n\n  _info.start_ip = thisPC;\n  _info.end_ip = nextPC;\n  _info.handler = personalityRoutine;\n  _info.unwind_info = exceptionTableAddr;\n  _info.lsda = lsda;\n  // flags is pr_cache.additional. See EHABI #7.2 for definition of bit 0.\n  _info.flags = (isSingleWordEHT ? 1 : 0) | (scope32 ? 0x2 : 0);  // Use enum?\n\n  return true;\n}\n#endif\n\n#if defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND)\ntemplate <typename A, typename R>\nbool UnwindCursor<A, R>::getInfoFromFdeCie(\n    const typename CFI_Parser<A>::FDE_Info &fdeInfo,\n    const typename CFI_Parser<A>::CIE_Info &cieInfo, pint_t pc,\n    uintptr_t dso_base) {\n  typename CFI_Parser<A>::PrologInfo prolog;\n  if (CFI_Parser<A>::parseFDEInstructions(_addressSpace, fdeInfo, cieInfo, pc,\n                                          R::getArch(), &prolog)) {\n    // Save off parsed FDE info\n    _info.start_ip          = fdeInfo.pcStart;\n    _info.end_ip            = fdeInfo.pcEnd;\n    _info.lsda              = fdeInfo.lsda;\n    _info.handler           = cieInfo.personality;\n    // Some frameless functions need SP altered when resuming in function, so\n    // propagate spExtraArgSize.\n    _info.gp                = prolog.spExtraArgSize;\n    _info.flags             = 0;\n    _info.format            = dwarfEncoding();\n    _info.unwind_info       = fdeInfo.fdeStart;\n    _info.unwind_info_size  = static_cast<uint32_t>(fdeInfo.fdeLength);\n    _info.extra             = static_cast<unw_word_t>(dso_base);\n    return true;\n  }\n  return false;\n}\n\ntemplate <typename A, typename R>\nbool UnwindCursor<A, R>::getInfoFromDwarfSection(pint_t pc,\n                                                const UnwindInfoSections &sects,\n                                                uint32_t fdeSectionOffsetHint) {\n  typename CFI_Parser<A>::FDE_Info fdeInfo;\n  typename CFI_Parser<A>::CIE_Info cieInfo;\n  bool foundFDE = false;\n  bool foundInCache = false;\n  // If compact encoding table gave offset into dwarf section, go directly there\n  if (fdeSectionOffsetHint != 0) {\n    foundFDE = CFI_Parser<A>::findFDE(_addressSpace, pc, sects.dwarf_section,\n                                    sects.dwarf_section_length,\n                                    sects.dwarf_section + fdeSectionOffsetHint,\n                                    &fdeInfo, &cieInfo);\n  }\n#if defined(_LIBUNWIND_SUPPORT_DWARF_INDEX)\n  if (!foundFDE && (sects.dwarf_index_section != 0)) {\n    foundFDE = EHHeaderParser<A>::findFDE(\n        _addressSpace, pc, sects.dwarf_index_section,\n        (uint32_t)sects.dwarf_index_section_length, &fdeInfo, &cieInfo);\n  }\n#endif\n  if (!foundFDE) {\n    // otherwise, search cache of previously found FDEs.\n    pint_t cachedFDE = DwarfFDECache<A>::findFDE(sects.dso_base, pc);\n    if (cachedFDE != 0) {\n      foundFDE =\n          CFI_Parser<A>::findFDE(_addressSpace, pc, sects.dwarf_section,\n                                 sects.dwarf_section_length,\n                                 cachedFDE, &fdeInfo, &cieInfo);\n      foundInCache = foundFDE;\n    }\n  }\n  if (!foundFDE) {\n    // Still not found, do full scan of __eh_frame section.\n    foundFDE = CFI_Parser<A>::findFDE(_addressSpace, pc, sects.dwarf_section,\n                                      sects.dwarf_section_length, 0,\n                                      &fdeInfo, &cieInfo);\n  }\n  if (foundFDE) {\n    if (getInfoFromFdeCie(fdeInfo, cieInfo, pc, sects.dso_base)) {\n      // Add to cache (to make next lookup faster) if we had no hint\n      // and there was no index.\n      if (!foundInCache && (fdeSectionOffsetHint == 0)) {\n  #if defined(_LIBUNWIND_SUPPORT_DWARF_INDEX)\n        if (sects.dwarf_index_section == 0)\n  #endif\n        DwarfFDECache<A>::add(sects.dso_base, fdeInfo.pcStart, fdeInfo.pcEnd,\n                              fdeInfo.fdeStart);\n      }\n      return true;\n    }\n  }\n  //_LIBUNWIND_DEBUG_LOG(\"can't find/use FDE for pc=0x%llX\", (uint64_t)pc);\n  return false;\n}\n#endif // defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND)\n\n\n#if defined(_LIBUNWIND_SUPPORT_COMPACT_UNWIND)\ntemplate <typename A, typename R>\nbool UnwindCursor<A, R>::getInfoFromCompactEncodingSection(pint_t pc,\n                                              const UnwindInfoSections &sects) {\n  const bool log = false;\n  if (log)\n    fprintf(stderr, \"getInfoFromCompactEncodingSection(pc=0x%llX, mh=0x%llX)\\n\",\n            (uint64_t)pc, (uint64_t)sects.dso_base);\n\n  const UnwindSectionHeader<A> sectionHeader(_addressSpace,\n                                                sects.compact_unwind_section);\n  if (sectionHeader.version() != UNWIND_SECTION_VERSION)\n    return false;\n\n  // do a binary search of top level index to find page with unwind info\n  pint_t targetFunctionOffset = pc - sects.dso_base;\n  const UnwindSectionIndexArray<A> topIndex(_addressSpace,\n                                           sects.compact_unwind_section\n                                         + sectionHeader.indexSectionOffset());\n  uint32_t low = 0;\n  uint32_t high = sectionHeader.indexCount();\n  uint32_t last = high - 1;\n  while (low < high) {\n    uint32_t mid = (low + high) / 2;\n    //if ( log ) fprintf(stderr, \"\\tmid=%d, low=%d, high=%d, *mid=0x%08X\\n\",\n    //mid, low, high, topIndex.functionOffset(mid));\n    if (topIndex.functionOffset(mid) <= targetFunctionOffset) {\n      if ((mid == last) ||\n          (topIndex.functionOffset(mid + 1) > targetFunctionOffset)) {\n        low = mid;\n        break;\n      } else {\n        low = mid + 1;\n      }\n    } else {\n      high = mid;\n    }\n  }\n  const uint32_t firstLevelFunctionOffset = topIndex.functionOffset(low);\n  const uint32_t firstLevelNextPageFunctionOffset =\n      topIndex.functionOffset(low + 1);\n  const pint_t secondLevelAddr =\n      sects.compact_unwind_section + topIndex.secondLevelPagesSectionOffset(low);\n  const pint_t lsdaArrayStartAddr =\n      sects.compact_unwind_section + topIndex.lsdaIndexArraySectionOffset(low);\n  const pint_t lsdaArrayEndAddr =\n      sects.compact_unwind_section + topIndex.lsdaIndexArraySectionOffset(low+1);\n  if (log)\n    fprintf(stderr, \"\\tfirst level search for result index=%d \"\n                    \"to secondLevelAddr=0x%llX\\n\",\n                    low, (uint64_t) secondLevelAddr);\n  // do a binary search of second level page index\n  uint32_t encoding = 0;\n  pint_t funcStart = 0;\n  pint_t funcEnd = 0;\n  pint_t lsda = 0;\n  pint_t personality = 0;\n  uint32_t pageKind = _addressSpace.get32(secondLevelAddr);\n  if (pageKind == UNWIND_SECOND_LEVEL_REGULAR) {\n    // regular page\n    UnwindSectionRegularPageHeader<A> pageHeader(_addressSpace,\n                                                 secondLevelAddr);\n    UnwindSectionRegularArray<A> pageIndex(\n        _addressSpace, secondLevelAddr + pageHeader.entryPageOffset());\n    // binary search looks for entry with e where index[e].offset <= pc <\n    // index[e+1].offset\n    if (log)\n      fprintf(stderr, \"\\tbinary search for targetFunctionOffset=0x%08llX in \"\n                      \"regular page starting at secondLevelAddr=0x%llX\\n\",\n              (uint64_t) targetFunctionOffset, (uint64_t) secondLevelAddr);\n    low = 0;\n    high = pageHeader.entryCount();\n    while (low < high) {\n      uint32_t mid = (low + high) / 2;\n      if (pageIndex.functionOffset(mid) <= targetFunctionOffset) {\n        if (mid == (uint32_t)(pageHeader.entryCount() - 1)) {\n          // at end of table\n          low = mid;\n          funcEnd = firstLevelNextPageFunctionOffset + sects.dso_base;\n          break;\n        } else if (pageIndex.functionOffset(mid + 1) > targetFunctionOffset) {\n          // next is too big, so we found it\n          low = mid;\n          funcEnd = pageIndex.functionOffset(low + 1) + sects.dso_base;\n          break;\n        } else {\n          low = mid + 1;\n        }\n      } else {\n        high = mid;\n      }\n    }\n    encoding = pageIndex.encoding(low);\n    funcStart = pageIndex.functionOffset(low) + sects.dso_base;\n    if (pc < funcStart) {\n      if (log)\n        fprintf(\n            stderr,\n            \"\\tpc not in table, pc=0x%llX, funcStart=0x%llX, funcEnd=0x%llX\\n\",\n            (uint64_t) pc, (uint64_t) funcStart, (uint64_t) funcEnd);\n      return false;\n    }\n    if (pc > funcEnd) {\n      if (log)\n        fprintf(\n            stderr,\n            \"\\tpc not in table, pc=0x%llX, funcStart=0x%llX, funcEnd=0x%llX\\n\",\n            (uint64_t) pc, (uint64_t) funcStart, (uint64_t) funcEnd);\n      return false;\n    }\n  } else if (pageKind == UNWIND_SECOND_LEVEL_COMPRESSED) {\n    // compressed page\n    UnwindSectionCompressedPageHeader<A> pageHeader(_addressSpace,\n                                                    secondLevelAddr);\n    UnwindSectionCompressedArray<A> pageIndex(\n        _addressSpace, secondLevelAddr + pageHeader.entryPageOffset());\n    const uint32_t targetFunctionPageOffset =\n        (uint32_t)(targetFunctionOffset - firstLevelFunctionOffset);\n    // binary search looks for entry with e where index[e].offset <= pc <\n    // index[e+1].offset\n    if (log)\n      fprintf(stderr, \"\\tbinary search of compressed page starting at \"\n                      \"secondLevelAddr=0x%llX\\n\",\n              (uint64_t) secondLevelAddr);\n    low = 0;\n    last = pageHeader.entryCount() - 1;\n    high = pageHeader.entryCount();\n    while (low < high) {\n      uint32_t mid = (low + high) / 2;\n      if (pageIndex.functionOffset(mid) <= targetFunctionPageOffset) {\n        if ((mid == last) ||\n            (pageIndex.functionOffset(mid + 1) > targetFunctionPageOffset)) {\n          low = mid;\n          break;\n        } else {\n          low = mid + 1;\n        }\n      } else {\n        high = mid;\n      }\n    }\n    funcStart = pageIndex.functionOffset(low) + firstLevelFunctionOffset\n                                                              + sects.dso_base;\n    if (low < last)\n      funcEnd =\n          pageIndex.functionOffset(low + 1) + firstLevelFunctionOffset\n                                                              + sects.dso_base;\n    else\n      funcEnd = firstLevelNextPageFunctionOffset + sects.dso_base;\n    if (pc < funcStart) {\n      _LIBUNWIND_DEBUG_LOG(\"malformed __unwind_info, pc=0x%llX not in second  \"\n                           \"level compressed unwind table. funcStart=0x%llX\",\n                            (uint64_t) pc, (uint64_t) funcStart);\n      return false;\n    }\n    if (pc > funcEnd) {\n      _LIBUNWIND_DEBUG_LOG(\"malformed __unwind_info, pc=0x%llX not in second  \"\n                          \"level compressed unwind table. funcEnd=0x%llX\",\n                           (uint64_t) pc, (uint64_t) funcEnd);\n      return false;\n    }\n    uint16_t encodingIndex = pageIndex.encodingIndex(low);\n    if (encodingIndex < sectionHeader.commonEncodingsArrayCount()) {\n      // encoding is in common table in section header\n      encoding = _addressSpace.get32(\n          sects.compact_unwind_section +\n          sectionHeader.commonEncodingsArraySectionOffset() +\n          encodingIndex * sizeof(uint32_t));\n    } else {\n      // encoding is in page specific table\n      uint16_t pageEncodingIndex =\n          encodingIndex - (uint16_t)sectionHeader.commonEncodingsArrayCount();\n      encoding = _addressSpace.get32(secondLevelAddr +\n                                     pageHeader.encodingsPageOffset() +\n                                     pageEncodingIndex * sizeof(uint32_t));\n    }\n  } else {\n    _LIBUNWIND_DEBUG_LOG(\"malformed __unwind_info at 0x%0llX bad second \"\n                         \"level page\",\n                          (uint64_t) sects.compact_unwind_section);\n    return false;\n  }\n\n  // look up LSDA, if encoding says function has one\n  if (encoding & UNWIND_HAS_LSDA) {\n    UnwindSectionLsdaArray<A> lsdaIndex(_addressSpace, lsdaArrayStartAddr);\n    uint32_t funcStartOffset = (uint32_t)(funcStart - sects.dso_base);\n    low = 0;\n    high = (uint32_t)(lsdaArrayEndAddr - lsdaArrayStartAddr) /\n                    sizeof(unwind_info_section_header_lsda_index_entry);\n    // binary search looks for entry with exact match for functionOffset\n    if (log)\n      fprintf(stderr,\n              \"\\tbinary search of lsda table for targetFunctionOffset=0x%08X\\n\",\n              funcStartOffset);\n    while (low < high) {\n      uint32_t mid = (low + high) / 2;\n      if (lsdaIndex.functionOffset(mid) == funcStartOffset) {\n        lsda = lsdaIndex.lsdaOffset(mid) + sects.dso_base;\n        break;\n      } else if (lsdaIndex.functionOffset(mid) < funcStartOffset) {\n        low = mid + 1;\n      } else {\n        high = mid;\n      }\n    }\n    if (lsda == 0) {\n      _LIBUNWIND_DEBUG_LOG(\"found encoding 0x%08X with HAS_LSDA bit set for \"\n                    \"pc=0x%0llX, but lsda table has no entry\",\n                    encoding, (uint64_t) pc);\n      return false;\n    }\n  }\n\n  // extract personality routine, if encoding says function has one\n  uint32_t personalityIndex = (encoding & UNWIND_PERSONALITY_MASK) >>\n                              (__builtin_ctz(UNWIND_PERSONALITY_MASK));\n  if (personalityIndex != 0) {\n    --personalityIndex; // change 1-based to zero-based index\n    if (personalityIndex >= sectionHeader.personalityArrayCount()) {\n      _LIBUNWIND_DEBUG_LOG(\"found encoding 0x%08X with personality index %d,  \"\n                            \"but personality table has only %d entries\",\n                            encoding, personalityIndex,\n                            sectionHeader.personalityArrayCount());\n      return false;\n    }\n    int32_t personalityDelta = (int32_t)_addressSpace.get32(\n        sects.compact_unwind_section +\n        sectionHeader.personalityArraySectionOffset() +\n        personalityIndex * sizeof(uint32_t));\n    pint_t personalityPointer = sects.dso_base + (pint_t)personalityDelta;\n    personality = _addressSpace.getP(personalityPointer);\n    if (log)\n      fprintf(stderr, \"getInfoFromCompactEncodingSection(pc=0x%llX), \"\n                      \"personalityDelta=0x%08X, personality=0x%08llX\\n\",\n              (uint64_t) pc, personalityDelta, (uint64_t) personality);\n  }\n\n  if (log)\n    fprintf(stderr, \"getInfoFromCompactEncodingSection(pc=0x%llX), \"\n                    \"encoding=0x%08X, lsda=0x%08llX for funcStart=0x%llX\\n\",\n            (uint64_t) pc, encoding, (uint64_t) lsda, (uint64_t) funcStart);\n  _info.start_ip = funcStart;\n  _info.end_ip = funcEnd;\n  _info.lsda = lsda;\n  _info.handler = personality;\n  _info.gp = 0;\n  _info.flags = 0;\n  _info.format = encoding;\n  _info.unwind_info = 0;\n  _info.unwind_info_size = 0;\n  _info.extra = sects.dso_base;\n  return true;\n}\n#endif // defined(_LIBUNWIND_SUPPORT_COMPACT_UNWIND)\n\n\n#if defined(_LIBUNWIND_SUPPORT_SEH_UNWIND)\ntemplate <typename A, typename R>\nbool UnwindCursor<A, R>::getInfoFromSEH(pint_t pc) {\n  pint_t base;\n  RUNTIME_FUNCTION *unwindEntry = lookUpSEHUnwindInfo(pc, &base);\n  if (!unwindEntry) {\n    _LIBUNWIND_DEBUG_LOG(\"\\tpc not in table, pc=0x%llX\", (uint64_t) pc);\n    return false;\n  }\n  _info.gp = 0;\n  _info.flags = 0;\n  _info.format = 0;\n  _info.unwind_info_size = sizeof(RUNTIME_FUNCTION);\n  _info.unwind_info = reinterpret_cast<unw_word_t>(unwindEntry);\n  _info.extra = base;\n  _info.start_ip = base + unwindEntry->BeginAddress;\n#ifdef _LIBUNWIND_TARGET_X86_64\n  _info.end_ip = base + unwindEntry->EndAddress;\n  // Only fill in the handler and LSDA if they're stale.\n  if (pc != getLastPC()) {\n    UNWIND_INFO *xdata = reinterpret_cast<UNWIND_INFO *>(base + unwindEntry->UnwindData);\n    if (xdata->Flags & (UNW_FLAG_EHANDLER|UNW_FLAG_UHANDLER)) {\n      // The personality is given in the UNWIND_INFO itself. The LSDA immediately\n      // follows the UNWIND_INFO. (This follows how both Clang and MSVC emit\n      // these structures.)\n      // N.B. UNWIND_INFO structs are DWORD-aligned.\n      uint32_t lastcode = (xdata->CountOfCodes + 1) & ~1;\n      const uint32_t *handler = reinterpret_cast<uint32_t *>(&xdata->UnwindCodes[lastcode]);\n      _info.lsda = reinterpret_cast<unw_word_t>(handler+1);\n      if (*handler) {\n        _info.handler = reinterpret_cast<unw_word_t>(__libunwind_seh_personality);\n      } else\n        _info.handler = 0;\n    } else {\n      _info.lsda = 0;\n      _info.handler = 0;\n    }\n  }\n#elif defined(_LIBUNWIND_TARGET_ARM)\n  _info.end_ip = _info.start_ip + unwindEntry->FunctionLength;\n  _info.lsda = 0; // FIXME\n  _info.handler = 0; // FIXME\n#endif\n  setLastPC(pc);\n  return true;\n}\n#endif\n\n\ntemplate <typename A, typename R>\nvoid UnwindCursor<A, R>::setInfoBasedOnIPRegister(bool isReturnAddress) {\n#if defined(_LIBUNWIND_TARGET_LINUX) && defined(_LIBUNWIND_TARGET_AARCH64)\n  _isSigReturn = false;\n#endif\n\n  pint_t pc = static_cast<pint_t>(this->getReg(UNW_REG_IP));\n#if defined(_LIBUNWIND_ARM_EHABI)\n  // Remove the thumb bit so the IP represents the actual instruction address.\n  // This matches the behaviour of _Unwind_GetIP on arm.\n  pc &= (pint_t)~0x1;\n#endif\n\n  // Exit early if at the top of the stack.\n  if (pc == 0) {\n    _unwindInfoMissing = true;\n    return;\n  }\n\n  // If the last line of a function is a \"throw\" the compiler sometimes\n  // emits no instructions after the call to __cxa_throw.  This means\n  // the return address is actually the start of the next function.\n  // To disambiguate this, back up the pc when we know it is a return\n  // address.\n  if (isReturnAddress)\n    --pc;\n\n  // Ask address space object to find unwind sections for this pc.\n  UnwindInfoSections sects;\n  if (_addressSpace.findUnwindSections(pc, sects)) {\n#if defined(_LIBUNWIND_SUPPORT_COMPACT_UNWIND)\n    // If there is a compact unwind encoding table, look there first.\n    if (sects.compact_unwind_section != 0) {\n      if (this->getInfoFromCompactEncodingSection(pc, sects)) {\n  #if defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND)\n        // Found info in table, done unless encoding says to use dwarf.\n        uint32_t dwarfOffset;\n        if ((sects.dwarf_section != 0) && compactSaysUseDwarf(&dwarfOffset)) {\n          if (this->getInfoFromDwarfSection(pc, sects, dwarfOffset)) {\n            // found info in dwarf, done\n            return;\n          }\n        }\n  #endif\n        // If unwind table has entry, but entry says there is no unwind info,\n        // record that we have no unwind info.\n        if (_info.format == 0)\n          _unwindInfoMissing = true;\n        return;\n      }\n    }\n#endif // defined(_LIBUNWIND_SUPPORT_COMPACT_UNWIND)\n\n#if defined(_LIBUNWIND_SUPPORT_SEH_UNWIND)\n    // If there is SEH unwind info, look there next.\n    if (this->getInfoFromSEH(pc))\n      return;\n#endif\n\n#if defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND)\n    // If there is dwarf unwind info, look there next.\n    if (sects.dwarf_section != 0) {\n      if (this->getInfoFromDwarfSection(pc, sects)) {\n        // found info in dwarf, done\n        return;\n      }\n    }\n#endif\n\n#if defined(_LIBUNWIND_ARM_EHABI)\n    // If there is ARM EHABI unwind info, look there next.\n    if (sects.arm_section != 0 && this->getInfoFromEHABISection(pc, sects))\n      return;\n#endif\n  }\n\n#if defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND)\n  // There is no static unwind info for this pc. Look to see if an FDE was\n  // dynamically registered for it.\n  pint_t cachedFDE = DwarfFDECache<A>::findFDE(DwarfFDECache<A>::kSearchAll,\n                                               pc);\n  if (cachedFDE != 0) {\n    typename CFI_Parser<A>::FDE_Info fdeInfo;\n    typename CFI_Parser<A>::CIE_Info cieInfo;\n    if (!CFI_Parser<A>::decodeFDE(_addressSpace, cachedFDE, &fdeInfo, &cieInfo))\n      if (getInfoFromFdeCie(fdeInfo, cieInfo, pc, 0))\n        return;\n  }\n\n  // Lastly, ask AddressSpace object about platform specific ways to locate\n  // other FDEs.\n  pint_t fde;\n  if (_addressSpace.findOtherFDE(pc, fde)) {\n    typename CFI_Parser<A>::FDE_Info fdeInfo;\n    typename CFI_Parser<A>::CIE_Info cieInfo;\n    if (!CFI_Parser<A>::decodeFDE(_addressSpace, fde, &fdeInfo, &cieInfo)) {\n      // Double check this FDE is for a function that includes the pc.\n      if ((fdeInfo.pcStart <= pc) && (pc < fdeInfo.pcEnd))\n        if (getInfoFromFdeCie(fdeInfo, cieInfo, pc, 0))\n          return;\n    }\n  }\n#endif // #if defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND)\n\n#if defined(_LIBUNWIND_TARGET_LINUX) && defined(_LIBUNWIND_TARGET_AARCH64)\n  if (setInfoForSigReturn())\n    return;\n#endif\n\n  // no unwind info, flag that we can't reliably unwind\n  _unwindInfoMissing = true;\n}\n\n#if defined(_LIBUNWIND_TARGET_LINUX) && defined(_LIBUNWIND_TARGET_AARCH64)\ntemplate <typename A, typename R>\nbool UnwindCursor<A, R>::setInfoForSigReturn(Registers_arm64 &) {\n  // Look for the sigreturn trampoline. The trampoline's body is two\n  // specific instructions (see below). Typically the trampoline comes from the\n  // vDSO[1] (i.e. the __kernel_rt_sigreturn function). A libc might provide its\n  // own restorer function, though, or user-mode QEMU might write a trampoline\n  // onto the stack.\n  //\n  // This special code path is a fallback that is only used if the trampoline\n  // lacks proper (e.g. DWARF) unwind info. On AArch64, a new DWARF register\n  // constant for the PC needs to be defined before DWARF can handle a signal\n  // trampoline. This code may segfault if the target PC is unreadable, e.g.:\n  //  - The PC points at a function compiled without unwind info, and which is\n  //    part of an execute-only mapping (e.g. using -Wl,--execute-only).\n  //  - The PC is invalid and happens to point to unreadable or unmapped memory.\n  //\n  // [1] https://github.com/torvalds/linux/blob/master/arch/arm64/kernel/vdso/sigreturn.S\n  const pint_t pc = static_cast<pint_t>(this->getReg(UNW_REG_IP));\n  // Look for instructions: mov x8, #0x8b; svc #0x0\n  if (_addressSpace.get32(pc) == 0xd2801168 &&\n      _addressSpace.get32(pc + 4) == 0xd4000001) {\n    _info = {};\n    _isSigReturn = true;\n    return true;\n  }\n  return false;\n}\n\ntemplate <typename A, typename R>\nint UnwindCursor<A, R>::stepThroughSigReturn(Registers_arm64 &) {\n  // In the signal trampoline frame, sp points to an rt_sigframe[1], which is:\n  //  - 128-byte siginfo struct\n  //  - ucontext struct:\n  //     - 8-byte long (uc_flags)\n  //     - 8-byte pointer (uc_link)\n  //     - 24-byte stack_t\n  //     - 128-byte signal set\n  //     - 8 bytes of padding because sigcontext has 16-byte alignment\n  //     - sigcontext/mcontext_t\n  // [1] https://github.com/torvalds/linux/blob/master/arch/arm64/kernel/signal.c\n  const pint_t kOffsetSpToSigcontext = (128 + 8 + 8 + 24 + 128 + 8); // 304\n\n  // Offsets from sigcontext to each register.\n  const pint_t kOffsetGprs = 8; // offset to \"__u64 regs[31]\" field\n  const pint_t kOffsetSp = 256; // offset to \"__u64 sp\" field\n  const pint_t kOffsetPc = 264; // offset to \"__u64 pc\" field\n\n  pint_t sigctx = _registers.getSP() + kOffsetSpToSigcontext;\n\n  for (int i = 0; i <= 30; ++i) {\n    uint64_t value = _addressSpace.get64(sigctx + kOffsetGprs +\n                                         static_cast<pint_t>(i * 8));\n    _registers.setRegister(UNW_ARM64_X0 + i, value);\n  }\n  _registers.setSP(_addressSpace.get64(sigctx + kOffsetSp));\n  _registers.setIP(_addressSpace.get64(sigctx + kOffsetPc));\n  _isSignalFrame = true;\n  return UNW_STEP_SUCCESS;\n}\n#endif // defined(_LIBUNWIND_TARGET_LINUX) && defined(_LIBUNWIND_TARGET_AARCH64)\n\ntemplate <typename A, typename R>\nint UnwindCursor<A, R>::step() {\n  // Bottom of stack is defined is when unwind info cannot be found.\n  if (_unwindInfoMissing)\n    return UNW_STEP_END;\n\n  // Use unwinding info to modify register set as if function returned.\n  int result;\n#if defined(_LIBUNWIND_TARGET_LINUX) && defined(_LIBUNWIND_TARGET_AARCH64)\n  if (_isSigReturn) {\n    result = this->stepThroughSigReturn();\n  } else\n#endif\n  {\n#if defined(_LIBUNWIND_SUPPORT_COMPACT_UNWIND)\n    result = this->stepWithCompactEncoding();\n#elif defined(_LIBUNWIND_SUPPORT_SEH_UNWIND)\n    result = this->stepWithSEHData();\n#elif defined(_LIBUNWIND_SUPPORT_DWARF_UNWIND)\n    result = this->stepWithDwarfFDE();\n#elif defined(_LIBUNWIND_ARM_EHABI)\n    result = this->stepWithEHABI();\n#else\n  #error Need _LIBUNWIND_SUPPORT_COMPACT_UNWIND or \\\n              _LIBUNWIND_SUPPORT_SEH_UNWIND or \\\n              _LIBUNWIND_SUPPORT_DWARF_UNWIND or \\\n              _LIBUNWIND_ARM_EHABI\n#endif\n  }\n\n  // update info based on new PC\n  if (result == UNW_STEP_SUCCESS) {\n    this->setInfoBasedOnIPRegister(true);\n    if (_unwindInfoMissing)\n      return UNW_STEP_END;\n  }\n\n  return result;\n}\n\ntemplate <typename A, typename R>\nvoid UnwindCursor<A, R>::getInfo(unw_proc_info_t *info) {\n  if (_unwindInfoMissing)\n    memset(info, 0, sizeof(*info));\n  else\n    *info = _info;\n}\n\ntemplate <typename A, typename R>\nbool UnwindCursor<A, R>::getFunctionName(char *buf, size_t bufLen,\n                                                           unw_word_t *offset) {\n  return _addressSpace.findFunctionName((pint_t)this->getReg(UNW_REG_IP),\n                                         buf, bufLen, offset);\n}\n\n} // namespace libunwind\n\n#endif // __UNWINDCURSOR_HPP__\n"}}, "reports": [{"events": [{"location": {"col": 8, "file": 0, "line": 90}, "message": "'unw_proc_info_t' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/libunwind/include/libunwind.h", "reportHash": "3c4c13499c9d6822bc2077a8b4e4f3d2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 1, "line": 116}, "message": "'UnwindInfoSections' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/libunwind/src/AddressSpace.hpp", "reportHash": "ff8cea219dca2aa34b8a31b98d045ac8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 25, "file": 1, "line": 148}, "message": "'LocalAddressSpace' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/libunwind/src/AddressSpace.hpp", "reportHash": "558adbbbb9c018ca055d1c5f2c99919f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 2, "line": 38}, "message": "'CIE_Info' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/libunwind/src/DwarfParser.hpp", "reportHash": "679c169d3e1c9a05c6be4817f754b867", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 2, "line": 58}, "message": "'FDE_Info' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/libunwind/src/DwarfParser.hpp", "reportHash": "b0badb7a22c9daa539e8a249b6851dce", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 2, "line": 79}, "message": "'RegisterLocation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/libunwind/src/DwarfParser.hpp", "reportHash": "22436f8bd750d816aa15b915f2afad57", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 2, "line": 86}, "message": "'PrologInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/libunwind/src/DwarfParser.hpp", "reportHash": "84b44b98cbe40147f01101a31792651d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 3, "line": 31}, "message": "'EHHeaderInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/libunwind/src/EHHeaderParser.hpp", "reportHash": "64f631964d08006319ef2637df0bd5cf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 25, "file": 4, "line": 64}, "message": "'RWMutex' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/libunwind/src/RWMutex.hpp", "reportHash": "01506d6050cd89afcb69c2c402b04243", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 25, "file": 5, "line": 256}, "message": "'Registers_x86_64' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/libunwind/src/Registers.hpp", "reportHash": "e30110d2130e2e0bbfa1cf9408b07da5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 5, "line": 293}, "message": "'GPRs' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/libunwind/src/Registers.hpp", "reportHash": "c3d66510f921f9f983f9d154cbd9b910", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 6, "line": 94}, "message": "'entry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/libunwind/src/UnwindCursor.hpp", "reportHash": "f8a6299f6f1e800c6bf576b8314d3c7b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
