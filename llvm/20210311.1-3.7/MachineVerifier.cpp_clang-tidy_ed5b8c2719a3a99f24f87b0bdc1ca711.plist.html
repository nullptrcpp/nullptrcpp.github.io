<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"34": {"id": 34, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h", "content": "//===- llvm/CodeGen/LiveInterval.h - Interval representation ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements the LiveRange and LiveInterval classes.  Given some\n// numbering of each the machine instructions an interval [i, j) is said to be a\n// live range for register v if there is no instruction with number j' >= j\n// such that v is live at j' and there is no instruction with number i' < i such\n// that v is live at i'. In this implementation ranges can have holes,\n// i.e. a range might look like [1,20), [50,65), [1000,1001).  Each\n// individual segment is represented as an instance of LiveRange::Segment,\n// and the whole range is represented as an instance of LiveRange.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_LIVEINTERVAL_H\n#define LLVM_CODEGEN_LIVEINTERVAL_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/IntEqClasses.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/CodeGen/Register.h\"\n#include \"llvm/CodeGen/SlotIndexes.h\"\n#include \"llvm/MC/LaneBitmask.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <functional>\n#include <memory>\n#include <set>\n#include <tuple>\n#include <utility>\n\nnamespace llvm {\n\n  class CoalescerPair;\n  class LiveIntervals;\n  class MachineRegisterInfo;\n  class raw_ostream;\n\n  /// VNInfo - Value Number Information.\n  /// This class holds information about a machine level values, including\n  /// definition and use points.\n  ///\n  class VNInfo {\n  public:\n    using Allocator = BumpPtrAllocator;\n\n    /// The ID number of this value.\n    unsigned id;\n\n    /// The index of the defining instruction.\n    SlotIndex def;\n\n    /// VNInfo constructor.\n    VNInfo(unsigned i, SlotIndex d) : id(i), def(d) {}\n\n    /// VNInfo constructor, copies values from orig, except for the value number.\n    VNInfo(unsigned i, const VNInfo &orig) : id(i), def(orig.def) {}\n\n    /// Copy from the parameter into this VNInfo.\n    void copyFrom(VNInfo &src) {\n      def = src.def;\n    }\n\n    /// Returns true if this value is defined by a PHI instruction (or was,\n    /// PHI instructions may have been eliminated).\n    /// PHI-defs begin at a block boundary, all other defs begin at register or\n    /// EC slots.\n    bool isPHIDef() const { return def.isBlock(); }\n\n    /// Returns true if this value is unused.\n    bool isUnused() const { return !def.isValid(); }\n\n    /// Mark this value as unused.\n    void markUnused() { def = SlotIndex(); }\n  };\n\n  /// Result of a LiveRange query. This class hides the implementation details\n  /// of live ranges, and it should be used as the primary interface for\n  /// examining live ranges around instructions.\n  class LiveQueryResult {\n    VNInfo *const EarlyVal;\n    VNInfo *const LateVal;\n    const SlotIndex EndPoint;\n    const bool Kill;\n\n  public:\n    LiveQueryResult(VNInfo *EarlyVal, VNInfo *LateVal, SlotIndex EndPoint,\n                    bool Kill)\n      : EarlyVal(EarlyVal), LateVal(LateVal), EndPoint(EndPoint), Kill(Kill)\n    {}\n\n    /// Return the value that is live-in to the instruction. This is the value\n    /// that will be read by the instruction's use operands. Return NULL if no\n    /// value is live-in.\n    VNInfo *valueIn() const {\n      return EarlyVal;\n    }\n\n    /// Return true if the live-in value is killed by this instruction. This\n    /// means that either the live range ends at the instruction, or it changes\n    /// value.\n    bool isKill() const {\n      return Kill;\n    }\n\n    /// Return true if this instruction has a dead def.\n    bool isDeadDef() const {\n      return EndPoint.isDead();\n    }\n\n    /// Return the value leaving the instruction, if any. This can be a\n    /// live-through value, or a live def. A dead def returns NULL.\n    VNInfo *valueOut() const {\n      return isDeadDef() ? nullptr : LateVal;\n    }\n\n    /// Returns the value alive at the end of the instruction, if any. This can\n    /// be a live-through value, a live def or a dead def.\n    VNInfo *valueOutOrDead() const {\n      return LateVal;\n    }\n\n    /// Return the value defined by this instruction, if any. This includes\n    /// dead defs, it is the value created by the instruction's def operands.\n    VNInfo *valueDefined() const {\n      return EarlyVal == LateVal ? nullptr : LateVal;\n    }\n\n    /// Return the end point of the last live range segment to interact with\n    /// the instruction, if any.\n    ///\n    /// The end point is an invalid SlotIndex only if the live range doesn't\n    /// intersect the instruction at all.\n    ///\n    /// The end point may be at or past the end of the instruction's basic\n    /// block. That means the value was live out of the block.\n    SlotIndex endPoint() const {\n      return EndPoint;\n    }\n  };\n\n  /// This class represents the liveness of a register, stack slot, etc.\n  /// It manages an ordered list of Segment objects.\n  /// The Segments are organized in a static single assignment form: At places\n  /// where a new value is defined or different values reach a CFG join a new\n  /// segment with a new value number is used.\n  class LiveRange {\n  public:\n    /// This represents a simple continuous liveness interval for a value.\n    /// The start point is inclusive, the end point exclusive. These intervals\n    /// are rendered as [start,end).\n    struct Segment {\n      SlotIndex start;  // Start point of the interval (inclusive)\n      SlotIndex end;    // End point of the interval (exclusive)\n      VNInfo *valno = nullptr; // identifier for the value contained in this\n                               // segment.\n\n      Segment() = default;\n\n      Segment(SlotIndex S, SlotIndex E, VNInfo *V)\n        : start(S), end(E), valno(V) {\n        assert(S < E && \"Cannot create empty or backwards segment\");\n      }\n\n      /// Return true if the index is covered by this segment.\n      bool contains(SlotIndex I) const {\n        return start <= I && I < end;\n      }\n\n      /// Return true if the given interval, [S, E), is covered by this segment.\n      bool containsInterval(SlotIndex S, SlotIndex E) const {\n        assert((S < E) && \"Backwards interval?\");\n        return (start <= S && S < end) && (start < E && E <= end);\n      }\n\n      bool operator<(const Segment &Other) const {\n        return std::tie(start, end) < std::tie(Other.start, Other.end);\n      }\n      bool operator==(const Segment &Other) const {\n        return start == Other.start && end == Other.end;\n      }\n\n      bool operator!=(const Segment &Other) const {\n        return !(*this == Other);\n      }\n\n      void dump() const;\n    };\n\n    using Segments = SmallVector<Segment, 2>;\n    using VNInfoList = SmallVector<VNInfo *, 2>;\n\n    Segments segments;   // the liveness segments\n    VNInfoList valnos;   // value#'s\n\n    // The segment set is used temporarily to accelerate initial computation\n    // of live ranges of physical registers in computeRegUnitRange.\n    // After that the set is flushed to the segment vector and deleted.\n    using SegmentSet = std::set<Segment>;\n    std::unique_ptr<SegmentSet> segmentSet;\n\n    using iterator = Segments::iterator;\n    using const_iterator = Segments::const_iterator;\n\n    iterator begin() { return segments.begin(); }\n    iterator end()   { return segments.end(); }\n\n    const_iterator begin() const { return segments.begin(); }\n    const_iterator end() const  { return segments.end(); }\n\n    using vni_iterator = VNInfoList::iterator;\n    using const_vni_iterator = VNInfoList::const_iterator;\n\n    vni_iterator vni_begin() { return valnos.begin(); }\n    vni_iterator vni_end()   { return valnos.end(); }\n\n    const_vni_iterator vni_begin() const { return valnos.begin(); }\n    const_vni_iterator vni_end() const   { return valnos.end(); }\n\n    /// Constructs a new LiveRange object.\n    LiveRange(bool UseSegmentSet = false)\n        : segmentSet(UseSegmentSet ? std::make_unique<SegmentSet>()\n                                   : nullptr) {}\n\n    /// Constructs a new LiveRange object by copying segments and valnos from\n    /// another LiveRange.\n    LiveRange(const LiveRange &Other, BumpPtrAllocator &Allocator) {\n      assert(Other.segmentSet == nullptr &&\n             \"Copying of LiveRanges with active SegmentSets is not supported\");\n      assign(Other, Allocator);\n    }\n\n    /// Copies values numbers and live segments from \\p Other into this range.\n    void assign(const LiveRange &Other, BumpPtrAllocator &Allocator) {\n      if (this == &Other)\n        return;\n\n      assert(Other.segmentSet == nullptr &&\n             \"Copying of LiveRanges with active SegmentSets is not supported\");\n      // Duplicate valnos.\n      for (const VNInfo *VNI : Other.valnos)\n        createValueCopy(VNI, Allocator);\n      // Now we can copy segments and remap their valnos.\n      for (const Segment &S : Other.segments)\n        segments.push_back(Segment(S.start, S.end, valnos[S.valno->id]));\n    }\n\n    /// advanceTo - Advance the specified iterator to point to the Segment\n    /// containing the specified position, or end() if the position is past the\n    /// end of the range.  If no Segment contains this position, but the\n    /// position is in a hole, this method returns an iterator pointing to the\n    /// Segment immediately after the hole.\n    iterator advanceTo(iterator I, SlotIndex Pos) {\n      assert(I != end());\n      if (Pos >= endIndex())\n        return end();\n      while (I->end <= Pos) ++I;\n      return I;\n    }\n\n    const_iterator advanceTo(const_iterator I, SlotIndex Pos) const {\n      assert(I != end());\n      if (Pos >= endIndex())\n        return end();\n      while (I->end <= Pos) ++I;\n      return I;\n    }\n\n    /// find - Return an iterator pointing to the first segment that ends after\n    /// Pos, or end(). This is the same as advanceTo(begin(), Pos), but faster\n    /// when searching large ranges.\n    ///\n    /// If Pos is contained in a Segment, that segment is returned.\n    /// If Pos is in a hole, the following Segment is returned.\n    /// If Pos is beyond endIndex, end() is returned.\n    iterator find(SlotIndex Pos);\n\n    const_iterator find(SlotIndex Pos) const {\n      return const_cast<LiveRange*>(this)->find(Pos);\n    }\n\n    void clear() {\n      valnos.clear();\n      segments.clear();\n    }\n\n    size_t size() const {\n      return segments.size();\n    }\n\n    bool hasAtLeastOneValue() const { return !valnos.empty(); }\n\n    bool containsOneValue() const { return valnos.size() == 1; }\n\n    unsigned getNumValNums() const { return (unsigned)valnos.size(); }\n\n    /// getValNumInfo - Returns pointer to the specified val#.\n    ///\n    inline VNInfo *getValNumInfo(unsigned ValNo) {\n      return valnos[ValNo];\n    }\n    inline const VNInfo *getValNumInfo(unsigned ValNo) const {\n      return valnos[ValNo];\n    }\n\n    /// containsValue - Returns true if VNI belongs to this range.\n    bool containsValue(const VNInfo *VNI) const {\n      return VNI && VNI->id < getNumValNums() && VNI == getValNumInfo(VNI->id);\n    }\n\n    /// getNextValue - Create a new value number and return it.  MIIdx specifies\n    /// the instruction that defines the value number.\n    VNInfo *getNextValue(SlotIndex def, VNInfo::Allocator &VNInfoAllocator) {\n      VNInfo *VNI =\n        new (VNInfoAllocator) VNInfo((unsigned)valnos.size(), def);\n      valnos.push_back(VNI);\n      return VNI;\n    }\n\n    /// createDeadDef - Make sure the range has a value defined at Def.\n    /// If one already exists, return it. Otherwise allocate a new value and\n    /// add liveness for a dead def.\n    VNInfo *createDeadDef(SlotIndex Def, VNInfo::Allocator &VNIAlloc);\n\n    /// Create a def of value @p VNI. Return @p VNI. If there already exists\n    /// a definition at VNI->def, the value defined there must be @p VNI.\n    VNInfo *createDeadDef(VNInfo *VNI);\n\n    /// Create a copy of the given value. The new value will be identical except\n    /// for the Value number.\n    VNInfo *createValueCopy(const VNInfo *orig,\n                            VNInfo::Allocator &VNInfoAllocator) {\n      VNInfo *VNI =\n        new (VNInfoAllocator) VNInfo((unsigned)valnos.size(), *orig);\n      valnos.push_back(VNI);\n      return VNI;\n    }\n\n    /// RenumberValues - Renumber all values in order of appearance and remove\n    /// unused values.\n    void RenumberValues();\n\n    /// MergeValueNumberInto - This method is called when two value numbers\n    /// are found to be equivalent.  This eliminates V1, replacing all\n    /// segments with the V1 value number with the V2 value number.  This can\n    /// cause merging of V1/V2 values numbers and compaction of the value space.\n    VNInfo* MergeValueNumberInto(VNInfo *V1, VNInfo *V2);\n\n    /// Merge all of the live segments of a specific val# in RHS into this live\n    /// range as the specified value number. The segments in RHS are allowed\n    /// to overlap with segments in the current range, it will replace the\n    /// value numbers of the overlaped live segments with the specified value\n    /// number.\n    void MergeSegmentsInAsValue(const LiveRange &RHS, VNInfo *LHSValNo);\n\n    /// MergeValueInAsValue - Merge all of the segments of a specific val#\n    /// in RHS into this live range as the specified value number.\n    /// The segments in RHS are allowed to overlap with segments in the\n    /// current range, but only if the overlapping segments have the\n    /// specified value number.\n    void MergeValueInAsValue(const LiveRange &RHS,\n                             const VNInfo *RHSValNo, VNInfo *LHSValNo);\n\n    bool empty() const { return segments.empty(); }\n\n    /// beginIndex - Return the lowest numbered slot covered.\n    SlotIndex beginIndex() const {\n      assert(!empty() && \"Call to beginIndex() on empty range.\");\n      return segments.front().start;\n    }\n\n    /// endNumber - return the maximum point of the range of the whole,\n    /// exclusive.\n    SlotIndex endIndex() const {\n      assert(!empty() && \"Call to endIndex() on empty range.\");\n      return segments.back().end;\n    }\n\n    bool expiredAt(SlotIndex index) const {\n      return index >= endIndex();\n    }\n\n    bool liveAt(SlotIndex index) const {\n      const_iterator r = find(index);\n      return r != end() && r->start <= index;\n    }\n\n    /// Return the segment that contains the specified index, or null if there\n    /// is none.\n    const Segment *getSegmentContaining(SlotIndex Idx) const {\n      const_iterator I = FindSegmentContaining(Idx);\n      return I == end() ? nullptr : &*I;\n    }\n\n    /// Return the live segment that contains the specified index, or null if\n    /// there is none.\n    Segment *getSegmentContaining(SlotIndex Idx) {\n      iterator I = FindSegmentContaining(Idx);\n      return I == end() ? nullptr : &*I;\n    }\n\n    /// getVNInfoAt - Return the VNInfo that is live at Idx, or NULL.\n    VNInfo *getVNInfoAt(SlotIndex Idx) const {\n      const_iterator I = FindSegmentContaining(Idx);\n      return I == end() ? nullptr : I->valno;\n    }\n\n    /// getVNInfoBefore - Return the VNInfo that is live up to but not\n    /// necessarilly including Idx, or NULL. Use this to find the reaching def\n    /// used by an instruction at this SlotIndex position.\n    VNInfo *getVNInfoBefore(SlotIndex Idx) const {\n      const_iterator I = FindSegmentContaining(Idx.getPrevSlot());\n      return I == end() ? nullptr : I->valno;\n    }\n\n    /// Return an iterator to the segment that contains the specified index, or\n    /// end() if there is none.\n    iterator FindSegmentContaining(SlotIndex Idx) {\n      iterator I = find(Idx);\n      return I != end() && I->start <= Idx ? I : end();\n    }\n\n    const_iterator FindSegmentContaining(SlotIndex Idx) const {\n      const_iterator I = find(Idx);\n      return I != end() && I->start <= Idx ? I : end();\n    }\n\n    /// overlaps - Return true if the intersection of the two live ranges is\n    /// not empty.\n    bool overlaps(const LiveRange &other) const {\n      if (other.empty())\n        return false;\n      return overlapsFrom(other, other.begin());\n    }\n\n    /// overlaps - Return true if the two ranges have overlapping segments\n    /// that are not coalescable according to CP.\n    ///\n    /// Overlapping segments where one range is defined by a coalescable\n    /// copy are allowed.\n    bool overlaps(const LiveRange &Other, const CoalescerPair &CP,\n                  const SlotIndexes&) const;\n\n    /// overlaps - Return true if the live range overlaps an interval specified\n    /// by [Start, End).\n    bool overlaps(SlotIndex Start, SlotIndex End) const;\n\n    /// overlapsFrom - Return true if the intersection of the two live ranges\n    /// is not empty.  The specified iterator is a hint that we can begin\n    /// scanning the Other range starting at I.\n    bool overlapsFrom(const LiveRange &Other, const_iterator StartPos) const;\n\n    /// Returns true if all segments of the @p Other live range are completely\n    /// covered by this live range.\n    /// Adjacent live ranges do not affect the covering:the liverange\n    /// [1,5](5,10] covers (3,7].\n    bool covers(const LiveRange &Other) const;\n\n    /// Add the specified Segment to this range, merging segments as\n    /// appropriate.  This returns an iterator to the inserted segment (which\n    /// may have grown since it was inserted).\n    iterator addSegment(Segment S);\n\n    /// Attempt to extend a value defined after @p StartIdx to include @p Use.\n    /// Both @p StartIdx and @p Use should be in the same basic block. In case\n    /// of subranges, an extension could be prevented by an explicit \"undef\"\n    /// caused by a <def,read-undef> on a non-overlapping lane. The list of\n    /// location of such \"undefs\" should be provided in @p Undefs.\n    /// The return value is a pair: the first element is VNInfo of the value\n    /// that was extended (possibly nullptr), the second is a boolean value\n    /// indicating whether an \"undef\" was encountered.\n    /// If this range is live before @p Use in the basic block that starts at\n    /// @p StartIdx, and there is no intervening \"undef\", extend it to be live\n    /// up to @p Use, and return the pair {value, false}. If there is no\n    /// segment before @p Use and there is no \"undef\" between @p StartIdx and\n    /// @p Use, return {nullptr, false}. If there is an \"undef\" before @p Use,\n    /// return {nullptr, true}.\n    std::pair<VNInfo*,bool> extendInBlock(ArrayRef<SlotIndex> Undefs,\n        SlotIndex StartIdx, SlotIndex Kill);\n\n    /// Simplified version of the above \"extendInBlock\", which assumes that\n    /// no register lanes are undefined by <def,read-undef> operands.\n    /// If this range is live before @p Use in the basic block that starts\n    /// at @p StartIdx, extend it to be live up to @p Use, and return the\n    /// value. If there is no segment before @p Use, return nullptr.\n    VNInfo *extendInBlock(SlotIndex StartIdx, SlotIndex Kill);\n\n    /// join - Join two live ranges (this, and other) together.  This applies\n    /// mappings to the value numbers in the LHS/RHS ranges as specified.  If\n    /// the ranges are not joinable, this aborts.\n    void join(LiveRange &Other,\n              const int *ValNoAssignments,\n              const int *RHSValNoAssignments,\n              SmallVectorImpl<VNInfo *> &NewVNInfo);\n\n    /// True iff this segment is a single segment that lies between the\n    /// specified boundaries, exclusively. Vregs live across a backedge are not\n    /// considered local. The boundaries are expected to lie within an extended\n    /// basic block, so vregs that are not live out should contain no holes.\n    bool isLocal(SlotIndex Start, SlotIndex End) const {\n      return beginIndex() > Start.getBaseIndex() &&\n        endIndex() < End.getBoundaryIndex();\n    }\n\n    /// Remove the specified segment from this range.  Note that the segment\n    /// must be a single Segment in its entirety.\n    void removeSegment(SlotIndex Start, SlotIndex End,\n                       bool RemoveDeadValNo = false);\n\n    void removeSegment(Segment S, bool RemoveDeadValNo = false) {\n      removeSegment(S.start, S.end, RemoveDeadValNo);\n    }\n\n    /// Remove segment pointed to by iterator @p I from this range.  This does\n    /// not remove dead value numbers.\n    iterator removeSegment(iterator I) {\n      return segments.erase(I);\n    }\n\n    /// Query Liveness at Idx.\n    /// The sub-instruction slot of Idx doesn't matter, only the instruction\n    /// it refers to is considered.\n    LiveQueryResult Query(SlotIndex Idx) const {\n      // Find the segment that enters the instruction.\n      const_iterator I = find(Idx.getBaseIndex());\n      const_iterator E = end();\n      if (I == E)\n        return LiveQueryResult(nullptr, nullptr, SlotIndex(), false);\n\n      // Is this an instruction live-in segment?\n      // If Idx is the start index of a basic block, include live-in segments\n      // that start at Idx.getBaseIndex().\n      VNInfo *EarlyVal = nullptr;\n      VNInfo *LateVal  = nullptr;\n      SlotIndex EndPoint;\n      bool Kill = false;\n      if (I->start <= Idx.getBaseIndex()) {\n        EarlyVal = I->valno;\n        EndPoint = I->end;\n        // Move to the potentially live-out segment.\n        if (SlotIndex::isSameInstr(Idx, I->end)) {\n          Kill = true;\n          if (++I == E)\n            return LiveQueryResult(EarlyVal, LateVal, EndPoint, Kill);\n        }\n        // Special case: A PHIDef value can have its def in the middle of a\n        // segment if the value happens to be live out of the layout\n        // predecessor.\n        // Such a value is not live-in.\n        if (EarlyVal->def == Idx.getBaseIndex())\n          EarlyVal = nullptr;\n      }\n      // I now points to the segment that may be live-through, or defined by\n      // this instr. Ignore segments starting after the current instr.\n      if (!SlotIndex::isEarlierInstr(Idx, I->start)) {\n        LateVal = I->valno;\n        EndPoint = I->end;\n      }\n      return LiveQueryResult(EarlyVal, LateVal, EndPoint, Kill);\n    }\n\n    /// removeValNo - Remove all the segments defined by the specified value#.\n    /// Also remove the value# from value# list.\n    void removeValNo(VNInfo *ValNo);\n\n    /// Returns true if the live range is zero length, i.e. no live segments\n    /// span instructions. It doesn't pay to spill such a range.\n    bool isZeroLength(SlotIndexes *Indexes) const {\n      for (const Segment &S : segments)\n        if (Indexes->getNextNonNullIndex(S.start).getBaseIndex() <\n            S.end.getBaseIndex())\n          return false;\n      return true;\n    }\n\n    // Returns true if any segment in the live range contains any of the\n    // provided slot indexes.  Slots which occur in holes between\n    // segments will not cause the function to return true.\n    bool isLiveAtIndexes(ArrayRef<SlotIndex> Slots) const;\n\n    bool operator<(const LiveRange& other) const {\n      const SlotIndex &thisIndex = beginIndex();\n      const SlotIndex &otherIndex = other.beginIndex();\n      return thisIndex < otherIndex;\n    }\n\n    /// Returns true if there is an explicit \"undef\" between @p Begin\n    /// @p End.\n    bool isUndefIn(ArrayRef<SlotIndex> Undefs, SlotIndex Begin,\n                   SlotIndex End) const {\n      return llvm::any_of(Undefs, [Begin, End](SlotIndex Idx) -> bool {\n        return Begin <= Idx && Idx < End;\n      });\n    }\n\n    /// Flush segment set into the regular segment vector.\n    /// The method is to be called after the live range\n    /// has been created, if use of the segment set was\n    /// activated in the constructor of the live range.\n    void flushSegmentSet();\n\n    /// Stores indexes from the input index sequence R at which this LiveRange\n    /// is live to the output O iterator.\n    /// R is a range of _ascending sorted_ _random_ access iterators\n    /// to the input indexes. Indexes stored at O are ascending sorted so it\n    /// can be used directly in the subsequent search (for example for\n    /// subranges). Returns true if found at least one index.\n    template <typename Range, typename OutputIt>\n    bool findIndexesLiveAt(Range &&R, OutputIt O) const {\n      assert(llvm::is_sorted(R));\n      auto Idx = R.begin(), EndIdx = R.end();\n      auto Seg = segments.begin(), EndSeg = segments.end();\n      bool Found = false;\n      while (Idx != EndIdx && Seg != EndSeg) {\n        // if the Seg is lower find first segment that is above Idx using binary\n        // search\n        if (Seg->end <= *Idx) {\n          Seg = std::upper_bound(\n              ++Seg, EndSeg, *Idx,\n              [=](std::remove_reference_t<decltype(*Idx)> V,\n                  const std::remove_reference_t<decltype(*Seg)> &S) {\n                return V < S.end;\n              });\n          if (Seg == EndSeg)\n            break;\n        }\n        auto NotLessStart = std::lower_bound(Idx, EndIdx, Seg->start);\n        if (NotLessStart == EndIdx)\n          break;\n        auto NotLessEnd = std::lower_bound(NotLessStart, EndIdx, Seg->end);\n        if (NotLessEnd != NotLessStart) {\n          Found = true;\n          O = std::copy(NotLessStart, NotLessEnd, O);\n        }\n        Idx = NotLessEnd;\n        ++Seg;\n      }\n      return Found;\n    }\n\n    void print(raw_ostream &OS) const;\n    void dump() const;\n\n    /// Walk the range and assert if any invariants fail to hold.\n    ///\n    /// Note that this is a no-op when asserts are disabled.\n#ifdef NDEBUG\n    void verify() const {}\n#else\n    void verify() const;\n#endif\n\n  protected:\n    /// Append a segment to the list of segments.\n    void append(const LiveRange::Segment S);\n\n  private:\n    friend class LiveRangeUpdater;\n    void addSegmentToSet(Segment S);\n    void markValNoForDeletion(VNInfo *V);\n  };\n\n  inline raw_ostream &operator<<(raw_ostream &OS, const LiveRange &LR) {\n    LR.print(OS);\n    return OS;\n  }\n\n  /// LiveInterval - This class represents the liveness of a register,\n  /// or stack slot.\n  class LiveInterval : public LiveRange {\n  public:\n    using super = LiveRange;\n\n    /// A live range for subregisters. The LaneMask specifies which parts of the\n    /// super register are covered by the interval.\n    /// (@sa TargetRegisterInfo::getSubRegIndexLaneMask()).\n    class SubRange : public LiveRange {\n    public:\n      SubRange *Next = nullptr;\n      LaneBitmask LaneMask;\n\n      /// Constructs a new SubRange object.\n      SubRange(LaneBitmask LaneMask) : LaneMask(LaneMask) {}\n\n      /// Constructs a new SubRange object by copying liveness from @p Other.\n      SubRange(LaneBitmask LaneMask, const LiveRange &Other,\n               BumpPtrAllocator &Allocator)\n        : LiveRange(Other, Allocator), LaneMask(LaneMask) {}\n\n      void print(raw_ostream &OS) const;\n      void dump() const;\n    };\n\n  private:\n    SubRange *SubRanges = nullptr; ///< Single linked list of subregister live\n                                   /// ranges.\n    const Register Reg; // the register or stack slot of this interval.\n    float Weight = 0.0; // weight of this interval\n\n  public:\n    Register reg() const { return Reg; }\n    float weight() const { return Weight; }\n    void incrementWeight(float Inc) { Weight += Inc; }\n    void setWeight(float Value) { Weight = Value; }\n\n    LiveInterval(unsigned Reg, float Weight) : Reg(Reg), Weight(Weight) {}\n\n    ~LiveInterval() {\n      clearSubRanges();\n    }\n\n    template<typename T>\n    class SingleLinkedListIterator {\n      T *P;\n\n    public:\n      SingleLinkedListIterator<T>(T *P) : P(P) {}\n\n      SingleLinkedListIterator<T> &operator++() {\n        P = P->Next;\n        return *this;\n      }\n      SingleLinkedListIterator<T> operator++(int) {\n        SingleLinkedListIterator res = *this;\n        ++*this;\n        return res;\n      }\n      bool operator!=(const SingleLinkedListIterator<T> &Other) const {\n        return P != Other.operator->();\n      }\n      bool operator==(const SingleLinkedListIterator<T> &Other) const {\n        return P == Other.operator->();\n      }\n      T &operator*() const {\n        return *P;\n      }\n      T *operator->() const {\n        return P;\n      }\n    };\n\n    using subrange_iterator = SingleLinkedListIterator<SubRange>;\n    using const_subrange_iterator = SingleLinkedListIterator<const SubRange>;\n\n    subrange_iterator subrange_begin() {\n      return subrange_iterator(SubRanges);\n    }\n    subrange_iterator subrange_end() {\n      return subrange_iterator(nullptr);\n    }\n\n    const_subrange_iterator subrange_begin() const {\n      return const_subrange_iterator(SubRanges);\n    }\n    const_subrange_iterator subrange_end() const {\n      return const_subrange_iterator(nullptr);\n    }\n\n    iterator_range<subrange_iterator> subranges() {\n      return make_range(subrange_begin(), subrange_end());\n    }\n\n    iterator_range<const_subrange_iterator> subranges() const {\n      return make_range(subrange_begin(), subrange_end());\n    }\n\n    /// Creates a new empty subregister live range. The range is added at the\n    /// beginning of the subrange list; subrange iterators stay valid.\n    SubRange *createSubRange(BumpPtrAllocator &Allocator,\n                             LaneBitmask LaneMask) {\n      SubRange *Range = new (Allocator) SubRange(LaneMask);\n      appendSubRange(Range);\n      return Range;\n    }\n\n    /// Like createSubRange() but the new range is filled with a copy of the\n    /// liveness information in @p CopyFrom.\n    SubRange *createSubRangeFrom(BumpPtrAllocator &Allocator,\n                                 LaneBitmask LaneMask,\n                                 const LiveRange &CopyFrom) {\n      SubRange *Range = new (Allocator) SubRange(LaneMask, CopyFrom, Allocator);\n      appendSubRange(Range);\n      return Range;\n    }\n\n    /// Returns true if subregister liveness information is available.\n    bool hasSubRanges() const {\n      return SubRanges != nullptr;\n    }\n\n    /// Removes all subregister liveness information.\n    void clearSubRanges();\n\n    /// Removes all subranges without any segments (subranges without segments\n    /// are not considered valid and should only exist temporarily).\n    void removeEmptySubRanges();\n\n    /// getSize - Returns the sum of sizes of all the LiveRange's.\n    ///\n    unsigned getSize() const;\n\n    /// isSpillable - Can this interval be spilled?\n    bool isSpillable() const { return Weight != huge_valf; }\n\n    /// markNotSpillable - Mark interval as not spillable\n    void markNotSpillable() { Weight = huge_valf; }\n\n    /// For a given lane mask @p LaneMask, compute indexes at which the\n    /// lane is marked undefined by subregister <def,read-undef> definitions.\n    void computeSubRangeUndefs(SmallVectorImpl<SlotIndex> &Undefs,\n                               LaneBitmask LaneMask,\n                               const MachineRegisterInfo &MRI,\n                               const SlotIndexes &Indexes) const;\n\n    /// Refines the subranges to support \\p LaneMask. This may only be called\n    /// for LI.hasSubrange()==true. Subregister ranges are split or created\n    /// until \\p LaneMask can be matched exactly. \\p Mod is executed on the\n    /// matching subranges.\n    ///\n    /// Example:\n    ///    Given an interval with subranges with lanemasks L0F00, L00F0 and\n    ///    L000F, refining for mask L0018. Will split the L00F0 lane into\n    ///    L00E0 and L0010 and the L000F lane into L0007 and L0008. The Mod\n    ///    function will be applied to the L0010 and L0008 subranges.\n    ///\n    /// \\p Indexes and \\p TRI are required to clean up the VNIs that\n    /// don't define the related lane masks after they get shrunk. E.g.,\n    /// when L000F gets split into L0007 and L0008 maybe only a subset\n    /// of the VNIs that defined L000F defines L0007.\n    ///\n    /// The clean up of the VNIs need to look at the actual instructions\n    /// to decide what is or is not live at a definition point. If the\n    /// update of the subranges occurs while the IR does not reflect these\n    /// changes, \\p ComposeSubRegIdx can be used to specify how the\n    /// definition are going to be rewritten.\n    /// E.g., let say we want to merge:\n    ///     V1.sub1:<2 x s32> = COPY V2.sub3:<4 x s32>\n    /// We do that by choosing a class where sub1:<2 x s32> and sub3:<4 x s32>\n    /// overlap, i.e., by choosing a class where we can find \"offset + 1 == 3\".\n    /// Put differently we align V2's sub3 with V1's sub1:\n    /// V2: sub0 sub1 sub2 sub3\n    /// V1: <offset>  sub0 sub1\n    ///\n    /// This offset will look like a composed subregidx in the the class:\n    ///     V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>\n    /// =>  V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>\n    ///\n    /// Now if we didn't rewrite the uses and def of V1, all the checks for V1\n    /// need to account for this offset.\n    /// This happens during coalescing where we update the live-ranges while\n    /// still having the old IR around because updating the IR on-the-fly\n    /// would actually clobber some information on how the live-ranges that\n    /// are being updated look like.\n    void refineSubRanges(BumpPtrAllocator &Allocator, LaneBitmask LaneMask,\n                         std::function<void(LiveInterval::SubRange &)> Apply,\n                         const SlotIndexes &Indexes,\n                         const TargetRegisterInfo &TRI,\n                         unsigned ComposeSubRegIdx = 0);\n\n    bool operator<(const LiveInterval& other) const {\n      const SlotIndex &thisIndex = beginIndex();\n      const SlotIndex &otherIndex = other.beginIndex();\n      return std::tie(thisIndex, Reg) < std::tie(otherIndex, other.Reg);\n    }\n\n    void print(raw_ostream &OS) const;\n    void dump() const;\n\n    /// Walks the interval and assert if any invariants fail to hold.\n    ///\n    /// Note that this is a no-op when asserts are disabled.\n#ifdef NDEBUG\n    void verify(const MachineRegisterInfo *MRI = nullptr) const {}\n#else\n    void verify(const MachineRegisterInfo *MRI = nullptr) const;\n#endif\n\n  private:\n    /// Appends @p Range to SubRanges list.\n    void appendSubRange(SubRange *Range) {\n      Range->Next = SubRanges;\n      SubRanges = Range;\n    }\n\n    /// Free memory held by SubRange.\n    void freeSubRange(SubRange *S);\n  };\n\n  inline raw_ostream &operator<<(raw_ostream &OS,\n                                 const LiveInterval::SubRange &SR) {\n    SR.print(OS);\n    return OS;\n  }\n\n  inline raw_ostream &operator<<(raw_ostream &OS, const LiveInterval &LI) {\n    LI.print(OS);\n    return OS;\n  }\n\n  raw_ostream &operator<<(raw_ostream &OS, const LiveRange::Segment &S);\n\n  inline bool operator<(SlotIndex V, const LiveRange::Segment &S) {\n    return V < S.start;\n  }\n\n  inline bool operator<(const LiveRange::Segment &S, SlotIndex V) {\n    return S.start < V;\n  }\n\n  /// Helper class for performant LiveRange bulk updates.\n  ///\n  /// Calling LiveRange::addSegment() repeatedly can be expensive on large\n  /// live ranges because segments after the insertion point may need to be\n  /// shifted. The LiveRangeUpdater class can defer the shifting when adding\n  /// many segments in order.\n  ///\n  /// The LiveRange will be in an invalid state until flush() is called.\n  class LiveRangeUpdater {\n    LiveRange *LR;\n    SlotIndex LastStart;\n    LiveRange::iterator WriteI;\n    LiveRange::iterator ReadI;\n    SmallVector<LiveRange::Segment, 16> Spills;\n    void mergeSpills();\n\n  public:\n    /// Create a LiveRangeUpdater for adding segments to LR.\n    /// LR will temporarily be in an invalid state until flush() is called.\n    LiveRangeUpdater(LiveRange *lr = nullptr) : LR(lr) {}\n\n    ~LiveRangeUpdater() { flush(); }\n\n    /// Add a segment to LR and coalesce when possible, just like\n    /// LR.addSegment(). Segments should be added in increasing start order for\n    /// best performance.\n    void add(LiveRange::Segment);\n\n    void add(SlotIndex Start, SlotIndex End, VNInfo *VNI) {\n      add(LiveRange::Segment(Start, End, VNI));\n    }\n\n    /// Return true if the LR is currently in an invalid state, and flush()\n    /// needs to be called.\n    bool isDirty() const { return LastStart.isValid(); }\n\n    /// Flush the updater state to LR so it is valid and contains all added\n    /// segments.\n    void flush();\n\n    /// Select a different destination live range.\n    void setDest(LiveRange *lr) {\n      if (LR != lr && isDirty())\n        flush();\n      LR = lr;\n    }\n\n    /// Get the current destination live range.\n    LiveRange *getDest() const { return LR; }\n\n    void dump() const;\n    void print(raw_ostream&) const;\n  };\n\n  inline raw_ostream &operator<<(raw_ostream &OS, const LiveRangeUpdater &X) {\n    X.print(OS);\n    return OS;\n  }\n\n  /// ConnectedVNInfoEqClasses - Helper class that can divide VNInfos in a\n  /// LiveInterval into equivalence clases of connected components. A\n  /// LiveInterval that has multiple connected components can be broken into\n  /// multiple LiveIntervals.\n  ///\n  /// Given a LiveInterval that may have multiple connected components, run:\n  ///\n  ///   unsigned numComps = ConEQ.Classify(LI);\n  ///   if (numComps > 1) {\n  ///     // allocate numComps-1 new LiveIntervals into LIS[1..]\n  ///     ConEQ.Distribute(LIS);\n  /// }\n\n  class ConnectedVNInfoEqClasses {\n    LiveIntervals &LIS;\n    IntEqClasses EqClass;\n\n  public:\n    explicit ConnectedVNInfoEqClasses(LiveIntervals &lis) : LIS(lis) {}\n\n    /// Classify the values in \\p LR into connected components.\n    /// Returns the number of connected components.\n    unsigned Classify(const LiveRange &LR);\n\n    /// getEqClass - Classify creates equivalence classes numbered 0..N. Return\n    /// the equivalence class assigned the VNI.\n    unsigned getEqClass(const VNInfo *VNI) const { return EqClass[VNI->id]; }\n\n    /// Distribute values in \\p LI into a separate LiveIntervals\n    /// for each connected component. LIV must have an empty LiveInterval for\n    /// each additional connected component. The first connected component is\n    /// left in \\p LI.\n    void Distribute(LiveInterval &LI, LiveInterval *LIV[],\n                    MachineRegisterInfo &MRI);\n  };\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_LIVEINTERVAL_H\n"}, "35": {"id": 35, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h", "content": "//===- LiveRangeCalc.h - Calculate live ranges -----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// The LiveRangeCalc class can be used to implement the computation of\n// live ranges from scratch.\n// It caches information about values in the CFG to speed up repeated\n// operations on the same live range.  The cache can be shared by\n// non-overlapping live ranges. SplitKit uses that when computing the live\n// range of split products.\n//\n// A low-level interface is available to clients that know where a variable is\n// live, but don't know which value it has as every point.  LiveRangeCalc will\n// propagate values down the dominator tree, and even insert PHI-defs where\n// needed. SplitKit uses this faster interface when possible.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_LIVERANGECALC_H\n#define LLVM_CODEGEN_LIVERANGECALC_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/BitVector.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/IndexedMap.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/CodeGen/LiveInterval.h\"\n#include \"llvm/CodeGen/MachineBasicBlock.h\"\n#include \"llvm/CodeGen/SlotIndexes.h\"\n#include \"llvm/MC/LaneBitmask.h\"\n#include <utility>\n\nnamespace llvm {\n\ntemplate <class NodeT> class DomTreeNodeBase;\nclass MachineDominatorTree;\nclass MachineFunction;\nclass MachineRegisterInfo;\n\nusing MachineDomTreeNode = DomTreeNodeBase<MachineBasicBlock>;\n\nclass LiveRangeCalc {\n  const MachineFunction *MF = nullptr;\n  const MachineRegisterInfo *MRI = nullptr;\n  SlotIndexes *Indexes = nullptr;\n  MachineDominatorTree *DomTree = nullptr;\n  VNInfo::Allocator *Alloc = nullptr;\n\n  /// LiveOutPair - A value and the block that defined it.  The domtree node is\n  /// redundant, it can be computed as: MDT[Indexes.getMBBFromIndex(VNI->def)].\n  using LiveOutPair = std::pair<VNInfo *, MachineDomTreeNode *>;\n\n  /// LiveOutMap - Map basic blocks to the value leaving the block.\n  using LiveOutMap = IndexedMap<LiveOutPair, MBB2NumberFunctor>;\n\n  /// Bit vector of active entries in LiveOut, also used as a visited set by\n  /// findReachingDefs.  One entry per basic block, indexed by block number.\n  /// This is kept as a separate bit vector because it can be cleared quickly\n  /// when switching live ranges.\n  BitVector Seen;\n\n  /// Map LiveRange to sets of blocks (represented by bit vectors) that\n  /// in the live range are defined on entry and undefined on entry.\n  /// A block is defined on entry if there is a path from at least one of\n  /// the defs in the live range to the entry of the block, and conversely,\n  /// a block is undefined on entry, if there is no such path (i.e. no\n  /// definition reaches the entry of the block). A single LiveRangeCalc\n  /// object is used to track live-out information for multiple registers\n  /// in live range splitting (which is ok, since the live ranges of these\n  /// registers do not overlap), but the defined/undefined information must\n  /// be kept separate for each individual range.\n  /// By convention, EntryInfoMap[&LR] = { Defined, Undefined }.\n  using EntryInfoMap = DenseMap<LiveRange *, std::pair<BitVector, BitVector>>;\n  EntryInfoMap EntryInfos;\n\n  /// Map each basic block where a live range is live out to the live-out value\n  /// and its defining block.\n  ///\n  /// For every basic block, MBB, one of these conditions shall be true:\n  ///\n  ///  1. !Seen.count(MBB->getNumber())\n  ///     Blocks without a Seen bit are ignored.\n  ///  2. LiveOut[MBB].second.getNode() == MBB\n  ///     The live-out value is defined in MBB.\n  ///  3. forall P in preds(MBB): LiveOut[P] == LiveOut[MBB]\n  ///     The live-out value passses through MBB. All predecessors must carry\n  ///     the same value.\n  ///\n  /// The domtree node may be null, it can be computed.\n  ///\n  /// The map can be shared by multiple live ranges as long as no two are\n  /// live-out of the same block.\n  LiveOutMap Map;\n\n  /// LiveInBlock - Information about a basic block where a live range is known\n  /// to be live-in, but the value has not yet been determined.\n  struct LiveInBlock {\n    // The live range set that is live-in to this block.  The algorithms can\n    // handle multiple non-overlapping live ranges simultaneously.\n    LiveRange &LR;\n\n    // DomNode - Dominator tree node for the block.\n    // Cleared when the final value has been determined and LI has been updated.\n    MachineDomTreeNode *DomNode;\n\n    // Position in block where the live-in range ends, or SlotIndex() if the\n    // range passes through the block.  When the final value has been\n    // determined, the range from the block start to Kill will be added to LI.\n    SlotIndex Kill;\n\n    // Live-in value filled in by updateSSA once it is known.\n    VNInfo *Value = nullptr;\n\n    LiveInBlock(LiveRange &LR, MachineDomTreeNode *node, SlotIndex kill)\n        : LR(LR), DomNode(node), Kill(kill) {}\n  };\n\n  /// LiveIn - Work list of blocks where the live-in value has yet to be\n  /// determined.  This list is typically computed by findReachingDefs() and\n  /// used as a work list by updateSSA().  The low-level interface may also be\n  /// used to add entries directly.\n  SmallVector<LiveInBlock, 16> LiveIn;\n\n  /// Check if the entry to block @p MBB can be reached by any of the defs\n  /// in @p LR. Return true if none of the defs reach the entry to @p MBB.\n  bool isDefOnEntry(LiveRange &LR, ArrayRef<SlotIndex> Undefs,\n                    MachineBasicBlock &MBB, BitVector &DefOnEntry,\n                    BitVector &UndefOnEntry);\n\n  /// Find the set of defs that can reach @p Kill. @p Kill must belong to\n  /// @p UseMBB.\n  ///\n  /// If exactly one def can reach @p UseMBB, and the def dominates @p Kill,\n  /// all paths from the def to @p UseMBB are added to @p LR, and the function\n  /// returns true.\n  ///\n  /// If multiple values can reach @p UseMBB, the blocks that need @p LR to be\n  /// live in are added to the LiveIn array, and the function returns false.\n  ///\n  /// The array @p Undef provides the locations where the range @p LR becomes\n  /// undefined by <def,read-undef> operands on other subranges. If @p Undef\n  /// is non-empty and @p Kill is jointly dominated only by the entries of\n  /// @p Undef, the function returns false.\n  ///\n  /// PhysReg, when set, is used to verify live-in lists on basic blocks.\n  bool findReachingDefs(LiveRange &LR, MachineBasicBlock &UseMBB, SlotIndex Use,\n                        unsigned PhysReg, ArrayRef<SlotIndex> Undefs);\n\n  /// updateSSA - Compute the values that will be live in to all requested\n  /// blocks in LiveIn.  Create PHI-def values as required to preserve SSA form.\n  ///\n  /// Every live-in block must be jointly dominated by the added live-out\n  /// blocks.  No values are read from the live ranges.\n  void updateSSA();\n\n  /// Transfer information from the LiveIn vector to the live ranges and update\n  /// the given @p LiveOuts.\n  void updateFromLiveIns();\n\nprotected:\n  /// Some getters to expose in a read-only way some private fields to\n  /// subclasses.\n  const MachineFunction *getMachineFunction() { return MF; }\n  const MachineRegisterInfo *getRegInfo() const { return MRI; }\n  SlotIndexes *getIndexes() { return Indexes; }\n  MachineDominatorTree *getDomTree() { return DomTree; }\n  VNInfo::Allocator *getVNAlloc() { return Alloc; }\n\n  /// Reset Map and Seen fields.\n  void resetLiveOutMap();\n\npublic:\n  LiveRangeCalc() = default;\n\n  //===--------------------------------------------------------------------===//\n  // High-level interface.\n  //===--------------------------------------------------------------------===//\n  //\n  // Calculate live ranges from scratch.\n  //\n\n  /// reset - Prepare caches for a new set of non-overlapping live ranges.  The\n  /// caches must be reset before attempting calculations with a live range\n  /// that may overlap a previously computed live range, and before the first\n  /// live range in a function.  If live ranges are not known to be\n  /// non-overlapping, call reset before each.\n  void reset(const MachineFunction *mf, SlotIndexes *SI,\n             MachineDominatorTree *MDT, VNInfo::Allocator *VNIA);\n\n  //===--------------------------------------------------------------------===//\n  // Mid-level interface.\n  //===--------------------------------------------------------------------===//\n  //\n  // Modify existing live ranges.\n  //\n\n  /// Extend the live range of @p LR to reach @p Use.\n  ///\n  /// The existing values in @p LR must be live so they jointly dominate @p Use.\n  /// If @p Use is not dominated by a single existing value, PHI-defs are\n  /// inserted as required to preserve SSA form.\n  ///\n  /// PhysReg, when set, is used to verify live-in lists on basic blocks.\n  void extend(LiveRange &LR, SlotIndex Use, unsigned PhysReg,\n              ArrayRef<SlotIndex> Undefs);\n\n  //===--------------------------------------------------------------------===//\n  // Low-level interface.\n  //===--------------------------------------------------------------------===//\n  //\n  // These functions can be used to compute live ranges where the live-in and\n  // live-out blocks are already known, but the SSA value in each block is\n  // unknown.\n  //\n  // After calling reset(), add known live-out values and known live-in blocks.\n  // Then call calculateValues() to compute the actual value that is\n  // live-in to each block, and add liveness to the live ranges.\n  //\n\n  /// setLiveOutValue - Indicate that VNI is live out from MBB.  The\n  /// calculateValues() function will not add liveness for MBB, the caller\n  /// should take care of that.\n  ///\n  /// VNI may be null only if MBB is a live-through block also passed to\n  /// addLiveInBlock().\n  void setLiveOutValue(MachineBasicBlock *MBB, VNInfo *VNI) {\n    Seen.set(MBB->getNumber());\n    Map[MBB] = LiveOutPair(VNI, nullptr);\n  }\n\n  /// addLiveInBlock - Add a block with an unknown live-in value.  This\n  /// function can only be called once per basic block.  Once the live-in value\n  /// has been determined, calculateValues() will add liveness to LI.\n  ///\n  /// @param LR      The live range that is live-in to the block.\n  /// @param DomNode The domtree node for the block.\n  /// @param Kill    Index in block where LI is killed.  If the value is\n  ///                live-through, set Kill = SLotIndex() and also call\n  ///                setLiveOutValue(MBB, 0).\n  void addLiveInBlock(LiveRange &LR, MachineDomTreeNode *DomNode,\n                      SlotIndex Kill = SlotIndex()) {\n    LiveIn.push_back(LiveInBlock(LR, DomNode, Kill));\n  }\n\n  /// calculateValues - Calculate the value that will be live-in to each block\n  /// added with addLiveInBlock.  Add PHI-def values as needed to preserve SSA\n  /// form.  Add liveness to all live-in blocks up to the Kill point, or the\n  /// whole block for live-through blocks.\n  ///\n  /// Every predecessor of a live-in block must have been given a value with\n  /// setLiveOutValue, the value may be null for live-trough blocks.\n  void calculateValues();\n\n  /// A diagnostic function to check if the end of the block @p MBB is\n  /// jointly dominated by the blocks corresponding to the slot indices\n  /// in @p Defs. This function is mainly for use in self-verification\n  /// checks.\n  LLVM_ATTRIBUTE_UNUSED\n  static bool isJointlyDominated(const MachineBasicBlock *MBB,\n                                 ArrayRef<SlotIndex> Defs,\n                                 const SlotIndexes &Indexes);\n};\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_LIVERANGECALC_H\n"}, "49": {"id": 49, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h", "content": "//===- StackMaps.h - StackMaps ----------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_STACKMAPS_H\n#define LLVM_CODEGEN_STACKMAPS_H\n\n#include \"llvm/ADT/MapVector.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/CodeGen/MachineInstr.h\"\n#include \"llvm/IR/CallingConv.h\"\n#include \"llvm/MC/MCSymbol.h\"\n#include \"llvm/Support/Debug.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <vector>\n\nnamespace llvm {\n\nclass AsmPrinter;\nclass MCExpr;\nclass MCStreamer;\nclass raw_ostream;\nclass TargetRegisterInfo;\n\n/// MI-level stackmap operands.\n///\n/// MI stackmap operations take the form:\n/// <id>, <numBytes>, live args...\nclass StackMapOpers {\npublic:\n  /// Enumerate the meta operands.\n  enum { IDPos, NBytesPos };\n\nprivate:\n  const MachineInstr* MI;\n\npublic:\n  explicit StackMapOpers(const MachineInstr *MI);\n\n  /// Return the ID for the given stackmap\n  uint64_t getID() const { return MI->getOperand(IDPos).getImm(); }\n\n  /// Return the number of patchable bytes the given stackmap should emit.\n  uint32_t getNumPatchBytes() const {\n    return MI->getOperand(NBytesPos).getImm();\n  }\n\n  /// Get the operand index of the variable list of non-argument operands.\n  /// These hold the \"live state\".\n  unsigned getVarIdx() const {\n    // Skip ID, nShadowBytes.\n    return 2;\n  }\n};\n\n/// MI-level patchpoint operands.\n///\n/// MI patchpoint operations take the form:\n/// [<def>], <id>, <numBytes>, <target>, <numArgs>, <cc>, ...\n///\n/// IR patchpoint intrinsics do not have the <cc> operand because calling\n/// convention is part of the subclass data.\n///\n/// SD patchpoint nodes do not have a def operand because it is part of the\n/// SDValue.\n///\n/// Patchpoints following the anyregcc convention are handled specially. For\n/// these, the stack map also records the location of the return value and\n/// arguments.\nclass PatchPointOpers {\npublic:\n  /// Enumerate the meta operands.\n  enum { IDPos, NBytesPos, TargetPos, NArgPos, CCPos, MetaEnd };\n\nprivate:\n  const MachineInstr *MI;\n  bool HasDef;\n\n  unsigned getMetaIdx(unsigned Pos = 0) const {\n    assert(Pos < MetaEnd && \"Meta operand index out of range.\");\n    return (HasDef ? 1 : 0) + Pos;\n  }\n\n  const MachineOperand &getMetaOper(unsigned Pos) const {\n    return MI->getOperand(getMetaIdx(Pos));\n  }\n\npublic:\n  explicit PatchPointOpers(const MachineInstr *MI);\n\n  bool isAnyReg() const { return (getCallingConv() == CallingConv::AnyReg); }\n  bool hasDef() const { return HasDef; }\n\n  /// Return the ID for the given patchpoint.\n  uint64_t getID() const { return getMetaOper(IDPos).getImm(); }\n\n  /// Return the number of patchable bytes the given patchpoint should emit.\n  uint32_t getNumPatchBytes() const {\n    return getMetaOper(NBytesPos).getImm();\n  }\n\n  /// Returns the target of the underlying call.\n  const MachineOperand &getCallTarget() const {\n    return getMetaOper(TargetPos);\n  }\n\n  /// Returns the calling convention\n  CallingConv::ID getCallingConv() const {\n    return getMetaOper(CCPos).getImm();\n  }\n\n  unsigned getArgIdx() const { return getMetaIdx() + MetaEnd; }\n\n  /// Return the number of call arguments\n  uint32_t getNumCallArgs() const {\n    return MI->getOperand(getMetaIdx(NArgPos)).getImm();\n  }\n\n  /// Get the operand index of the variable list of non-argument operands.\n  /// These hold the \"live state\".\n  unsigned getVarIdx() const {\n    return getMetaIdx() + MetaEnd + getNumCallArgs();\n  }\n\n  /// Get the index at which stack map locations will be recorded.\n  /// Arguments are not recorded unless the anyregcc convention is used.\n  unsigned getStackMapStartIdx() const {\n    if (isAnyReg())\n      return getArgIdx();\n    return getVarIdx();\n  }\n\n  /// Get the next scratch register operand index.\n  unsigned getNextScratchIdx(unsigned StartIdx = 0) const;\n};\n\n/// MI-level Statepoint operands\n///\n/// Statepoint operands take the form:\n///   <id>, <num patch bytes >, <num call arguments>, <call target>,\n///   [call arguments...],\n///   <StackMaps::ConstantOp>, <calling convention>,\n///   <StackMaps::ConstantOp>, <statepoint flags>,\n///   <StackMaps::ConstantOp>, <num deopt args>, [deopt args...],\n///   <StackMaps::ConstantOp>, <num gc pointer args>, [gc pointer args...],\n///   <StackMaps::ConstantOp>, <num gc allocas>, [gc allocas args...],\n///   <StackMaps::ConstantOp>, <num  entries in gc map>, [base/derived pairs]\n///   base/derived pairs in gc map are logical indices into <gc pointer args>\n///   section.\n///   All gc pointers assigned to VRegs produce new value (in form of MI Def\n///   operand) and are tied to it.\nclass StatepointOpers {\n  // TODO:: we should change the STATEPOINT representation so that CC and\n  // Flags should be part of meta operands, with args and deopt operands, and\n  // gc operands all prefixed by their length and a type code. This would be\n  // much more consistent.\n\n  // These values are absolute offsets into the operands of the statepoint\n  // instruction.\n  enum { IDPos, NBytesPos, NCallArgsPos, CallTargetPos, MetaEnd };\n\n  // These values are relative offsets from the start of the statepoint meta\n  // arguments (i.e. the end of the call arguments).\n  enum { CCOffset = 1, FlagsOffset = 3, NumDeoptOperandsOffset = 5 };\n\npublic:\n  explicit StatepointOpers(const MachineInstr *MI) : MI(MI) {\n    NumDefs = MI->getNumDefs();\n  }\n\n  /// Get index of statepoint ID operand.\n  unsigned getIDPos() const { return NumDefs + IDPos; }\n\n  /// Get index of Num Patch Bytes operand.\n  unsigned getNBytesPos() const { return NumDefs + NBytesPos; }\n\n  /// Get index of Num Call Arguments operand.\n  unsigned getNCallArgsPos() const { return NumDefs + NCallArgsPos; }\n\n  /// Get starting index of non call related arguments\n  /// (calling convention, statepoint flags, vm state and gc state).\n  unsigned getVarIdx() const {\n    return MI->getOperand(NumDefs + NCallArgsPos).getImm() + MetaEnd + NumDefs;\n  }\n\n  /// Get index of Calling Convention operand.\n  unsigned getCCIdx() const { return getVarIdx() + CCOffset; }\n\n  /// Get index of Flags operand.\n  unsigned getFlagsIdx() const { return getVarIdx() + FlagsOffset; }\n\n  /// Get index of Number Deopt Arguments operand.\n  unsigned getNumDeoptArgsIdx() const {\n    return getVarIdx() + NumDeoptOperandsOffset;\n  }\n\n  /// Return the ID for the given statepoint.\n  uint64_t getID() const { return MI->getOperand(NumDefs + IDPos).getImm(); }\n\n  /// Return the number of patchable bytes the given statepoint should emit.\n  uint32_t getNumPatchBytes() const {\n    return MI->getOperand(NumDefs + NBytesPos).getImm();\n  }\n\n  /// Return the target of the underlying call.\n  const MachineOperand &getCallTarget() const {\n    return MI->getOperand(NumDefs + CallTargetPos);\n  }\n\n  /// Return the calling convention.\n  CallingConv::ID getCallingConv() const {\n    return MI->getOperand(getCCIdx()).getImm();\n  }\n\n  /// Return the statepoint flags.\n  uint64_t getFlags() const { return MI->getOperand(getFlagsIdx()).getImm(); }\n\n  uint64_t getNumDeoptArgs() const {\n    return MI->getOperand(getNumDeoptArgsIdx()).getImm();\n  }\n\n  /// Get index of number of gc map entries.\n  unsigned getNumGcMapEntriesIdx();\n\n  /// Get index of number of gc allocas.\n  unsigned getNumAllocaIdx();\n\n  /// Get index of number of GC pointers.\n  unsigned getNumGCPtrIdx();\n\n  /// Get index of first GC pointer operand of -1 if there are none.\n  int getFirstGCPtrIdx();\n\n  /// Get vector of base/derived pairs from statepoint.\n  /// Elements are indices into GC Pointer operand list (logical).\n  /// Returns number of elements in GCMap.\n  unsigned\n  getGCPointerMap(SmallVectorImpl<std::pair<unsigned, unsigned>> &GCMap);\n\nprivate:\n  const MachineInstr *MI;\n  unsigned NumDefs;\n};\n\nclass StackMaps {\npublic:\n  struct Location {\n    enum LocationType {\n      Unprocessed,\n      Register,\n      Direct,\n      Indirect,\n      Constant,\n      ConstantIndex\n    };\n    LocationType Type = Unprocessed;\n    unsigned Size = 0;\n    unsigned Reg = 0;\n    int64_t Offset = 0;\n\n    Location() = default;\n    Location(LocationType Type, unsigned Size, unsigned Reg, int64_t Offset)\n        : Type(Type), Size(Size), Reg(Reg), Offset(Offset) {}\n  };\n\n  struct LiveOutReg {\n    unsigned short Reg = 0;\n    unsigned short DwarfRegNum = 0;\n    unsigned short Size = 0;\n\n    LiveOutReg() = default;\n    LiveOutReg(unsigned short Reg, unsigned short DwarfRegNum,\n               unsigned short Size)\n        : Reg(Reg), DwarfRegNum(DwarfRegNum), Size(Size) {}\n  };\n\n  // OpTypes are used to encode information about the following logical\n  // operand (which may consist of several MachineOperands) for the\n  // OpParser.\n  using OpType = enum { DirectMemRefOp, IndirectMemRefOp, ConstantOp };\n\n  StackMaps(AsmPrinter &AP);\n\n  /// Get index of next meta operand.\n  /// Similar to parseOperand, but does not actually parses operand meaning.\n  static unsigned getNextMetaArgIdx(const MachineInstr *MI, unsigned CurIdx);\n\n  void reset() {\n    CSInfos.clear();\n    ConstPool.clear();\n    FnInfos.clear();\n  }\n\n  using LocationVec = SmallVector<Location, 8>;\n  using LiveOutVec = SmallVector<LiveOutReg, 8>;\n  using ConstantPool = MapVector<uint64_t, uint64_t>;\n\n  struct FunctionInfo {\n    uint64_t StackSize = 0;\n    uint64_t RecordCount = 1;\n\n    FunctionInfo() = default;\n    explicit FunctionInfo(uint64_t StackSize) : StackSize(StackSize) {}\n  };\n\n  struct CallsiteInfo {\n    const MCExpr *CSOffsetExpr = nullptr;\n    uint64_t ID = 0;\n    LocationVec Locations;\n    LiveOutVec LiveOuts;\n\n    CallsiteInfo() = default;\n    CallsiteInfo(const MCExpr *CSOffsetExpr, uint64_t ID,\n                 LocationVec &&Locations, LiveOutVec &&LiveOuts)\n        : CSOffsetExpr(CSOffsetExpr), ID(ID), Locations(std::move(Locations)),\n          LiveOuts(std::move(LiveOuts)) {}\n  };\n\n  using FnInfoMap = MapVector<const MCSymbol *, FunctionInfo>;\n  using CallsiteInfoList = std::vector<CallsiteInfo>;\n\n  /// Generate a stackmap record for a stackmap instruction.\n  ///\n  /// MI must be a raw STACKMAP, not a PATCHPOINT.\n  void recordStackMap(const MCSymbol &L,\n                      const MachineInstr &MI);\n\n  /// Generate a stackmap record for a patchpoint instruction.\n  void recordPatchPoint(const MCSymbol &L,\n                        const MachineInstr &MI);\n\n  /// Generate a stackmap record for a statepoint instruction.\n  void recordStatepoint(const MCSymbol &L,\n                        const MachineInstr &MI);\n\n  /// If there is any stack map data, create a stack map section and serialize\n  /// the map info into it. This clears the stack map data structures\n  /// afterwards.\n  void serializeToStackMapSection();\n\n  /// Get call site info.\n  CallsiteInfoList &getCSInfos() { return CSInfos; }\n\n  /// Get function info.\n  FnInfoMap &getFnInfos() { return FnInfos; }\n\nprivate:\n  static const char *WSMP;\n\n  AsmPrinter &AP;\n  CallsiteInfoList CSInfos;\n  ConstantPool ConstPool;\n  FnInfoMap FnInfos;\n\n  MachineInstr::const_mop_iterator\n  parseOperand(MachineInstr::const_mop_iterator MOI,\n               MachineInstr::const_mop_iterator MOE, LocationVec &Locs,\n               LiveOutVec &LiveOuts) const;\n\n  /// Specialized parser of statepoint operands.\n  /// They do not directly correspond to StackMap record entries.\n  void parseStatepointOpers(const MachineInstr &MI,\n                            MachineInstr::const_mop_iterator MOI,\n                            MachineInstr::const_mop_iterator MOE,\n                            LocationVec &Locations, LiveOutVec &LiveOuts);\n\n  /// Create a live-out register record for the given register @p Reg.\n  LiveOutReg createLiveOutReg(unsigned Reg,\n                              const TargetRegisterInfo *TRI) const;\n\n  /// Parse the register live-out mask and return a vector of live-out\n  /// registers that need to be recorded in the stackmap.\n  LiveOutVec parseRegisterLiveOutMask(const uint32_t *Mask) const;\n\n  /// Record the locations of the operands of the provided instruction in a\n  /// record keyed by the provided label.  For instructions w/AnyReg calling\n  /// convention the return register is also recorded if requested.  For\n  /// STACKMAP, and PATCHPOINT the label is expected to immediately *preceed*\n  /// lowering of the MI to MCInsts.  For STATEPOINT, it expected to\n  /// immediately *follow*.  It's not clear this difference was intentional,\n  /// but it exists today.  \n  void recordStackMapOpers(const MCSymbol &L,\n                           const MachineInstr &MI, uint64_t ID,\n                           MachineInstr::const_mop_iterator MOI,\n                           MachineInstr::const_mop_iterator MOE,\n                           bool recordResult = false);\n\n  /// Emit the stackmap header.\n  void emitStackmapHeader(MCStreamer &OS);\n\n  /// Emit the function frame record for each function.\n  void emitFunctionFrameRecords(MCStreamer &OS);\n\n  /// Emit the constant pool.\n  void emitConstantPoolEntries(MCStreamer &OS);\n\n  /// Emit the callsite info for each stackmap/patchpoint intrinsic call.\n  void emitCallsiteEntries(MCStreamer &OS);\n\n  void print(raw_ostream &OS);\n  void debug() { print(dbgs()); }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_STACKMAPS_H\n"}, "96": {"id": 96, "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp", "content": "//===- MachineVerifier.cpp - Machine Code Verifier ------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Pass to verify generated machine code. The following is checked:\n//\n// Operand counts: All explicit operands must be present.\n//\n// Register classes: All physical and virtual register operands must be\n// compatible with the register class required by the instruction descriptor.\n//\n// Register live intervals: Registers must be defined only once, and must be\n// defined before use.\n//\n// The machine code verifier is enabled with the command-line option\n// -verify-machineinstrs.\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/ADT/BitVector.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/DepthFirstIterator.h\"\n#include \"llvm/ADT/PostOrderIterator.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SetOperations.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/Analysis/EHPersonalities.h\"\n#include \"llvm/CodeGen/GlobalISel/RegisterBank.h\"\n#include \"llvm/CodeGen/LiveInterval.h\"\n#include \"llvm/CodeGen/LiveIntervalCalc.h\"\n#include \"llvm/CodeGen/LiveIntervals.h\"\n#include \"llvm/CodeGen/LiveStacks.h\"\n#include \"llvm/CodeGen/LiveVariables.h\"\n#include \"llvm/CodeGen/MachineBasicBlock.h\"\n#include \"llvm/CodeGen/MachineFrameInfo.h\"\n#include \"llvm/CodeGen/MachineFunction.h\"\n#include \"llvm/CodeGen/MachineFunctionPass.h\"\n#include \"llvm/CodeGen/MachineInstr.h\"\n#include \"llvm/CodeGen/MachineInstrBundle.h\"\n#include \"llvm/CodeGen/MachineMemOperand.h\"\n#include \"llvm/CodeGen/MachineOperand.h\"\n#include \"llvm/CodeGen/MachineRegisterInfo.h\"\n#include \"llvm/CodeGen/PseudoSourceValue.h\"\n#include \"llvm/CodeGen/SlotIndexes.h\"\n#include \"llvm/CodeGen/StackMaps.h\"\n#include \"llvm/CodeGen/TargetInstrInfo.h\"\n#include \"llvm/CodeGen/TargetOpcodes.h\"\n#include \"llvm/CodeGen/TargetRegisterInfo.h\"\n#include \"llvm/CodeGen/TargetSubtargetInfo.h\"\n#include \"llvm/IR/BasicBlock.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/InlineAsm.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/InitializePasses.h\"\n#include \"llvm/MC/LaneBitmask.h\"\n#include \"llvm/MC/MCAsmInfo.h\"\n#include \"llvm/MC/MCInstrDesc.h\"\n#include \"llvm/MC/MCRegisterInfo.h\"\n#include \"llvm/MC/MCTargetOptions.h\"\n#include \"llvm/Pass.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/LowLevelTypeImpl.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include \"llvm/Target/TargetMachine.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <string>\n#include <utility>\n\nusing namespace llvm;\n\nnamespace {\n\n  struct MachineVerifier {\n    MachineVerifier(Pass *pass, const char *b) : PASS(pass), Banner(b) {}\n\n    unsigned verify(const MachineFunction &MF);\n\n    Pass *const PASS;\n    const char *Banner;\n    const MachineFunction *MF;\n    const TargetMachine *TM;\n    const TargetInstrInfo *TII;\n    const TargetRegisterInfo *TRI;\n    const MachineRegisterInfo *MRI;\n\n    unsigned foundErrors;\n\n    // Avoid querying the MachineFunctionProperties for each operand.\n    bool isFunctionRegBankSelected;\n    bool isFunctionSelected;\n\n    using RegVector = SmallVector<Register, 16>;\n    using RegMaskVector = SmallVector<const uint32_t *, 4>;\n    using RegSet = DenseSet<Register>;\n    using RegMap = DenseMap<Register, const MachineInstr *>;\n    using BlockSet = SmallPtrSet<const MachineBasicBlock *, 8>;\n\n    const MachineInstr *FirstNonPHI;\n    const MachineInstr *FirstTerminator;\n    BlockSet FunctionBlocks;\n\n    BitVector regsReserved;\n    RegSet regsLive;\n    RegVector regsDefined, regsDead, regsKilled;\n    RegMaskVector regMasks;\n\n    SlotIndex lastIndex;\n\n    // Add Reg and any sub-registers to RV\n    void addRegWithSubRegs(RegVector &RV, Register Reg) {\n      RV.push_back(Reg);\n      if (Reg.isPhysical())\n        append_range(RV, TRI->subregs(Reg.asMCReg()));\n    }\n\n    struct BBInfo {\n      // Is this MBB reachable from the MF entry point?\n      bool reachable = false;\n\n      // Vregs that must be live in because they are used without being\n      // defined. Map value is the user. vregsLiveIn doesn't include regs\n      // that only are used by PHI nodes.\n      RegMap vregsLiveIn;\n\n      // Regs killed in MBB. They may be defined again, and will then be in both\n      // regsKilled and regsLiveOut.\n      RegSet regsKilled;\n\n      // Regs defined in MBB and live out. Note that vregs passing through may\n      // be live out without being mentioned here.\n      RegSet regsLiveOut;\n\n      // Vregs that pass through MBB untouched. This set is disjoint from\n      // regsKilled and regsLiveOut.\n      RegSet vregsPassed;\n\n      // Vregs that must pass through MBB because they are needed by a successor\n      // block. This set is disjoint from regsLiveOut.\n      RegSet vregsRequired;\n\n      // Set versions of block's predecessor and successor lists.\n      BlockSet Preds, Succs;\n\n      BBInfo() = default;\n\n      // Add register to vregsRequired if it belongs there. Return true if\n      // anything changed.\n      bool addRequired(Register Reg) {\n        if (!Reg.isVirtual())\n          return false;\n        if (regsLiveOut.count(Reg))\n          return false;\n        return vregsRequired.insert(Reg).second;\n      }\n\n      // Same for a full set.\n      bool addRequired(const RegSet &RS) {\n        bool Changed = false;\n        for (Register Reg : RS)\n          Changed |= addRequired(Reg);\n        return Changed;\n      }\n\n      // Same for a full map.\n      bool addRequired(const RegMap &RM) {\n        bool Changed = false;\n        for (const auto &I : RM)\n          Changed |= addRequired(I.first);\n        return Changed;\n      }\n\n      // Live-out registers are either in regsLiveOut or vregsPassed.\n      bool isLiveOut(Register Reg) const {\n        return regsLiveOut.count(Reg) || vregsPassed.count(Reg);\n      }\n    };\n\n    // Extra register info per MBB.\n    DenseMap<const MachineBasicBlock*, BBInfo> MBBInfoMap;\n\n    bool isReserved(Register Reg) {\n      return Reg.id() < regsReserved.size() && regsReserved.test(Reg.id());\n    }\n\n    bool isAllocatable(Register Reg) const {\n      return Reg.id() < TRI->getNumRegs() && TRI->isInAllocatableClass(Reg) &&\n             !regsReserved.test(Reg.id());\n    }\n\n    // Analysis information if available\n    LiveVariables *LiveVars;\n    LiveIntervals *LiveInts;\n    LiveStacks *LiveStks;\n    SlotIndexes *Indexes;\n\n    void visitMachineFunctionBefore();\n    void visitMachineBasicBlockBefore(const MachineBasicBlock *MBB);\n    void visitMachineBundleBefore(const MachineInstr *MI);\n\n    bool verifyVectorElementMatch(LLT Ty0, LLT Ty1, const MachineInstr *MI);\n    void verifyPreISelGenericInstruction(const MachineInstr *MI);\n    void visitMachineInstrBefore(const MachineInstr *MI);\n    void visitMachineOperand(const MachineOperand *MO, unsigned MONum);\n    void visitMachineBundleAfter(const MachineInstr *MI);\n    void visitMachineBasicBlockAfter(const MachineBasicBlock *MBB);\n    void visitMachineFunctionAfter();\n\n    void report(const char *msg, const MachineFunction *MF);\n    void report(const char *msg, const MachineBasicBlock *MBB);\n    void report(const char *msg, const MachineInstr *MI);\n    void report(const char *msg, const MachineOperand *MO, unsigned MONum,\n                LLT MOVRegType = LLT{});\n    void report(const Twine &Msg, const MachineInstr *MI);\n\n    void report_context(const LiveInterval &LI) const;\n    void report_context(const LiveRange &LR, Register VRegUnit,\n                        LaneBitmask LaneMask) const;\n    void report_context(const LiveRange::Segment &S) const;\n    void report_context(const VNInfo &VNI) const;\n    void report_context(SlotIndex Pos) const;\n    void report_context(MCPhysReg PhysReg) const;\n    void report_context_liverange(const LiveRange &LR) const;\n    void report_context_lanemask(LaneBitmask LaneMask) const;\n    void report_context_vreg(Register VReg) const;\n    void report_context_vreg_regunit(Register VRegOrUnit) const;\n\n    void verifyInlineAsm(const MachineInstr *MI);\n\n    void checkLiveness(const MachineOperand *MO, unsigned MONum);\n    void checkLivenessAtUse(const MachineOperand *MO, unsigned MONum,\n                            SlotIndex UseIdx, const LiveRange &LR,\n                            Register VRegOrUnit,\n                            LaneBitmask LaneMask = LaneBitmask::getNone());\n    void checkLivenessAtDef(const MachineOperand *MO, unsigned MONum,\n                            SlotIndex DefIdx, const LiveRange &LR,\n                            Register VRegOrUnit, bool SubRangeCheck = false,\n                            LaneBitmask LaneMask = LaneBitmask::getNone());\n\n    void markReachable(const MachineBasicBlock *MBB);\n    void calcRegsPassed();\n    void checkPHIOps(const MachineBasicBlock &MBB);\n\n    void calcRegsRequired();\n    void verifyLiveVariables();\n    void verifyLiveIntervals();\n    void verifyLiveInterval(const LiveInterval&);\n    void verifyLiveRangeValue(const LiveRange &, const VNInfo *, Register,\n                              LaneBitmask);\n    void verifyLiveRangeSegment(const LiveRange &,\n                                const LiveRange::const_iterator I, Register,\n                                LaneBitmask);\n    void verifyLiveRange(const LiveRange &, Register,\n                         LaneBitmask LaneMask = LaneBitmask::getNone());\n\n    void verifyStackFrame();\n\n    void verifySlotIndexes() const;\n    void verifyProperties(const MachineFunction &MF);\n  };\n\n  struct MachineVerifierPass : public MachineFunctionPass {\n    static char ID; // Pass ID, replacement for typeid\n\n    const std::string Banner;\n\n    MachineVerifierPass(std::string banner = std::string())\n      : MachineFunctionPass(ID), Banner(std::move(banner)) {\n        initializeMachineVerifierPassPass(*PassRegistry::getPassRegistry());\n      }\n\n    void getAnalysisUsage(AnalysisUsage &AU) const override {\n      AU.setPreservesAll();\n      MachineFunctionPass::getAnalysisUsage(AU);\n    }\n\n    bool runOnMachineFunction(MachineFunction &MF) override {\n      unsigned FoundErrors = MachineVerifier(this, Banner.c_str()).verify(MF);\n      if (FoundErrors)\n        report_fatal_error(\"Found \"+Twine(FoundErrors)+\" machine code errors.\");\n      return false;\n    }\n  };\n\n} // end anonymous namespace\n\nchar MachineVerifierPass::ID = 0;\n\nINITIALIZE_PASS(MachineVerifierPass, \"machineverifier\",\n                \"Verify generated machine code\", false, false)\n\nFunctionPass *llvm::createMachineVerifierPass(const std::string &Banner) {\n  return new MachineVerifierPass(Banner);\n}\n\nvoid llvm::verifyMachineFunction(MachineFunctionAnalysisManager *,\n                                 const std::string &Banner,\n                                 const MachineFunction &MF) {\n  // TODO: Use MFAM after porting below analyses.\n  // LiveVariables *LiveVars;\n  // LiveIntervals *LiveInts;\n  // LiveStacks *LiveStks;\n  // SlotIndexes *Indexes;\n  unsigned FoundErrors = MachineVerifier(nullptr, Banner.c_str()).verify(MF);\n  if (FoundErrors)\n    report_fatal_error(\"Found \" + Twine(FoundErrors) + \" machine code errors.\");\n}\n\nbool MachineFunction::verify(Pass *p, const char *Banner, bool AbortOnErrors)\n    const {\n  MachineFunction &MF = const_cast<MachineFunction&>(*this);\n  unsigned FoundErrors = MachineVerifier(p, Banner).verify(MF);\n  if (AbortOnErrors && FoundErrors)\n    report_fatal_error(\"Found \"+Twine(FoundErrors)+\" machine code errors.\");\n  return FoundErrors == 0;\n}\n\nvoid MachineVerifier::verifySlotIndexes() const {\n  if (Indexes == nullptr)\n    return;\n\n  // Ensure the IdxMBB list is sorted by slot indexes.\n  SlotIndex Last;\n  for (SlotIndexes::MBBIndexIterator I = Indexes->MBBIndexBegin(),\n       E = Indexes->MBBIndexEnd(); I != E; ++I) {\n    assert(!Last.isValid() || I->first > Last);\n    Last = I->first;\n  }\n}\n\nvoid MachineVerifier::verifyProperties(const MachineFunction &MF) {\n  // If a pass has introduced virtual registers without clearing the\n  // NoVRegs property (or set it without allocating the vregs)\n  // then report an error.\n  if (MF.getProperties().hasProperty(\n          MachineFunctionProperties::Property::NoVRegs) &&\n      MRI->getNumVirtRegs())\n    report(\"Function has NoVRegs property but there are VReg operands\", &MF);\n}\n\nunsigned MachineVerifier::verify(const MachineFunction &MF) {\n  foundErrors = 0;\n\n  this->MF = &MF;\n  TM = &MF.getTarget();\n  TII = MF.getSubtarget().getInstrInfo();\n  TRI = MF.getSubtarget().getRegisterInfo();\n  MRI = &MF.getRegInfo();\n\n  const bool isFunctionFailedISel = MF.getProperties().hasProperty(\n      MachineFunctionProperties::Property::FailedISel);\n\n  // If we're mid-GlobalISel and we already triggered the fallback path then\n  // it's expected that the MIR is somewhat broken but that's ok since we'll\n  // reset it and clear the FailedISel attribute in ResetMachineFunctions.\n  if (isFunctionFailedISel)\n    return foundErrors;\n\n  isFunctionRegBankSelected = MF.getProperties().hasProperty(\n      MachineFunctionProperties::Property::RegBankSelected);\n  isFunctionSelected = MF.getProperties().hasProperty(\n      MachineFunctionProperties::Property::Selected);\n\n  LiveVars = nullptr;\n  LiveInts = nullptr;\n  LiveStks = nullptr;\n  Indexes = nullptr;\n  if (PASS) {\n    LiveInts = PASS->getAnalysisIfAvailable<LiveIntervals>();\n    // We don't want to verify LiveVariables if LiveIntervals is available.\n    if (!LiveInts)\n      LiveVars = PASS->getAnalysisIfAvailable<LiveVariables>();\n    LiveStks = PASS->getAnalysisIfAvailable<LiveStacks>();\n    Indexes = PASS->getAnalysisIfAvailable<SlotIndexes>();\n  }\n\n  verifySlotIndexes();\n\n  verifyProperties(MF);\n\n  visitMachineFunctionBefore();\n  for (const MachineBasicBlock &MBB : MF) {\n    visitMachineBasicBlockBefore(&MBB);\n    // Keep track of the current bundle header.\n    const MachineInstr *CurBundle = nullptr;\n    // Do we expect the next instruction to be part of the same bundle?\n    bool InBundle = false;\n\n    for (const MachineInstr &MI : MBB.instrs()) {\n      if (MI.getParent() != &MBB) {\n        report(\"Bad instruction parent pointer\", &MBB);\n        errs() << \"Instruction: \" << MI;\n        continue;\n      }\n\n      // Check for consistent bundle flags.\n      if (InBundle && !MI.isBundledWithPred())\n        report(\"Missing BundledPred flag, \"\n               \"BundledSucc was set on predecessor\",\n               &MI);\n      if (!InBundle && MI.isBundledWithPred())\n        report(\"BundledPred flag is set, \"\n               \"but BundledSucc not set on predecessor\",\n               &MI);\n\n      // Is this a bundle header?\n      if (!MI.isInsideBundle()) {\n        if (CurBundle)\n          visitMachineBundleAfter(CurBundle);\n        CurBundle = &MI;\n        visitMachineBundleBefore(CurBundle);\n      } else if (!CurBundle)\n        report(\"No bundle header\", &MI);\n      visitMachineInstrBefore(&MI);\n      for (unsigned I = 0, E = MI.getNumOperands(); I != E; ++I) {\n        const MachineOperand &Op = MI.getOperand(I);\n        if (Op.getParent() != &MI) {\n          // Make sure to use correct addOperand / RemoveOperand / ChangeTo\n          // functions when replacing operands of a MachineInstr.\n          report(\"Instruction has operand with wrong parent set\", &MI);\n        }\n\n        visitMachineOperand(&Op, I);\n      }\n\n      // Was this the last bundled instruction?\n      InBundle = MI.isBundledWithSucc();\n    }\n    if (CurBundle)\n      visitMachineBundleAfter(CurBundle);\n    if (InBundle)\n      report(\"BundledSucc flag set on last instruction in block\", &MBB.back());\n    visitMachineBasicBlockAfter(&MBB);\n  }\n  visitMachineFunctionAfter();\n\n  // Clean up.\n  regsLive.clear();\n  regsDefined.clear();\n  regsDead.clear();\n  regsKilled.clear();\n  regMasks.clear();\n  MBBInfoMap.clear();\n\n  return foundErrors;\n}\n\nvoid MachineVerifier::report(const char *msg, const MachineFunction *MF) {\n  assert(MF);\n  errs() << '\\n';\n  if (!foundErrors++) {\n    if (Banner)\n      errs() << \"# \" << Banner << '\\n';\n    if (LiveInts != nullptr)\n      LiveInts->print(errs());\n    else\n      MF->print(errs(), Indexes);\n  }\n  errs() << \"*** Bad machine code: \" << msg << \" ***\\n\"\n      << \"- function:    \" << MF->getName() << \"\\n\";\n}\n\nvoid MachineVerifier::report(const char *msg, const MachineBasicBlock *MBB) {\n  assert(MBB);\n  report(msg, MBB->getParent());\n  errs() << \"- basic block: \" << printMBBReference(*MBB) << ' '\n         << MBB->getName() << \" (\" << (const void *)MBB << ')';\n  if (Indexes)\n    errs() << \" [\" << Indexes->getMBBStartIdx(MBB)\n        << ';' <<  Indexes->getMBBEndIdx(MBB) << ')';\n  errs() << '\\n';\n}\n\nvoid MachineVerifier::report(const char *msg, const MachineInstr *MI) {\n  assert(MI);\n  report(msg, MI->getParent());\n  errs() << \"- instruction: \";\n  if (Indexes && Indexes->hasIndex(*MI))\n    errs() << Indexes->getInstructionIndex(*MI) << '\\t';\n  MI->print(errs(), /*IsStandalone=*/true);\n}\n\nvoid MachineVerifier::report(const char *msg, const MachineOperand *MO,\n                             unsigned MONum, LLT MOVRegType) {\n  assert(MO);\n  report(msg, MO->getParent());\n  errs() << \"- operand \" << MONum << \":   \";\n  MO->print(errs(), MOVRegType, TRI);\n  errs() << \"\\n\";\n}\n\nvoid MachineVerifier::report(const Twine &Msg, const MachineInstr *MI) {\n  report(Msg.str().c_str(), MI);\n}\n\nvoid MachineVerifier::report_context(SlotIndex Pos) const {\n  errs() << \"- at:          \" << Pos << '\\n';\n}\n\nvoid MachineVerifier::report_context(const LiveInterval &LI) const {\n  errs() << \"- interval:    \" << LI << '\\n';\n}\n\nvoid MachineVerifier::report_context(const LiveRange &LR, Register VRegUnit,\n                                     LaneBitmask LaneMask) const {\n  report_context_liverange(LR);\n  report_context_vreg_regunit(VRegUnit);\n  if (LaneMask.any())\n    report_context_lanemask(LaneMask);\n}\n\nvoid MachineVerifier::report_context(const LiveRange::Segment &S) const {\n  errs() << \"- segment:     \" << S << '\\n';\n}\n\nvoid MachineVerifier::report_context(const VNInfo &VNI) const {\n  errs() << \"- ValNo:       \" << VNI.id << \" (def \" << VNI.def << \")\\n\";\n}\n\nvoid MachineVerifier::report_context_liverange(const LiveRange &LR) const {\n  errs() << \"- liverange:   \" << LR << '\\n';\n}\n\nvoid MachineVerifier::report_context(MCPhysReg PReg) const {\n  errs() << \"- p. register: \" << printReg(PReg, TRI) << '\\n';\n}\n\nvoid MachineVerifier::report_context_vreg(Register VReg) const {\n  errs() << \"- v. register: \" << printReg(VReg, TRI) << '\\n';\n}\n\nvoid MachineVerifier::report_context_vreg_regunit(Register VRegOrUnit) const {\n  if (Register::isVirtualRegister(VRegOrUnit)) {\n    report_context_vreg(VRegOrUnit);\n  } else {\n    errs() << \"- regunit:     \" << printRegUnit(VRegOrUnit, TRI) << '\\n';\n  }\n}\n\nvoid MachineVerifier::report_context_lanemask(LaneBitmask LaneMask) const {\n  errs() << \"- lanemask:    \" << PrintLaneMask(LaneMask) << '\\n';\n}\n\nvoid MachineVerifier::markReachable(const MachineBasicBlock *MBB) {\n  BBInfo &MInfo = MBBInfoMap[MBB];\n  if (!MInfo.reachable) {\n    MInfo.reachable = true;\n    for (const MachineBasicBlock *Succ : MBB->successors())\n      markReachable(Succ);\n  }\n}\n\nvoid MachineVerifier::visitMachineFunctionBefore() {\n  lastIndex = SlotIndex();\n  regsReserved = MRI->reservedRegsFrozen() ? MRI->getReservedRegs()\n                                           : TRI->getReservedRegs(*MF);\n\n  if (!MF->empty())\n    markReachable(&MF->front());\n\n  // Build a set of the basic blocks in the function.\n  FunctionBlocks.clear();\n  for (const auto &MBB : *MF) {\n    FunctionBlocks.insert(&MBB);\n    BBInfo &MInfo = MBBInfoMap[&MBB];\n\n    MInfo.Preds.insert(MBB.pred_begin(), MBB.pred_end());\n    if (MInfo.Preds.size() != MBB.pred_size())\n      report(\"MBB has duplicate entries in its predecessor list.\", &MBB);\n\n    MInfo.Succs.insert(MBB.succ_begin(), MBB.succ_end());\n    if (MInfo.Succs.size() != MBB.succ_size())\n      report(\"MBB has duplicate entries in its successor list.\", &MBB);\n  }\n\n  // Check that the register use lists are sane.\n  MRI->verifyUseLists();\n\n  if (!MF->empty())\n    verifyStackFrame();\n}\n\nvoid\nMachineVerifier::visitMachineBasicBlockBefore(const MachineBasicBlock *MBB) {\n  FirstTerminator = nullptr;\n  FirstNonPHI = nullptr;\n\n  if (!MF->getProperties().hasProperty(\n      MachineFunctionProperties::Property::NoPHIs) && MRI->tracksLiveness()) {\n    // If this block has allocatable physical registers live-in, check that\n    // it is an entry block or landing pad.\n    for (const auto &LI : MBB->liveins()) {\n      if (isAllocatable(LI.PhysReg) && !MBB->isEHPad() &&\n          MBB->getIterator() != MBB->getParent()->begin()) {\n        report(\"MBB has allocatable live-in, but isn't entry or landing-pad.\", MBB);\n        report_context(LI.PhysReg);\n      }\n    }\n  }\n\n  // Count the number of landing pad successors.\n  SmallPtrSet<const MachineBasicBlock*, 4> LandingPadSuccs;\n  for (const auto *succ : MBB->successors()) {\n    if (succ->isEHPad())\n      LandingPadSuccs.insert(succ);\n    if (!FunctionBlocks.count(succ))\n      report(\"MBB has successor that isn't part of the function.\", MBB);\n    if (!MBBInfoMap[succ].Preds.count(MBB)) {\n      report(\"Inconsistent CFG\", MBB);\n      errs() << \"MBB is not in the predecessor list of the successor \"\n             << printMBBReference(*succ) << \".\\n\";\n    }\n  }\n\n  // Check the predecessor list.\n  for (const MachineBasicBlock *Pred : MBB->predecessors()) {\n    if (!FunctionBlocks.count(Pred))\n      report(\"MBB has predecessor that isn't part of the function.\", MBB);\n    if (!MBBInfoMap[Pred].Succs.count(MBB)) {\n      report(\"Inconsistent CFG\", MBB);\n      errs() << \"MBB is not in the successor list of the predecessor \"\n             << printMBBReference(*Pred) << \".\\n\";\n    }\n  }\n\n  const MCAsmInfo *AsmInfo = TM->getMCAsmInfo();\n  const BasicBlock *BB = MBB->getBasicBlock();\n  const Function &F = MF->getFunction();\n  if (LandingPadSuccs.size() > 1 &&\n      !(AsmInfo &&\n        AsmInfo->getExceptionHandlingType() == ExceptionHandling::SjLj &&\n        BB && isa<SwitchInst>(BB->getTerminator())) &&\n      !isScopedEHPersonality(classifyEHPersonality(F.getPersonalityFn())))\n    report(\"MBB has more than one landing pad successor\", MBB);\n\n  // Call analyzeBranch. If it succeeds, there several more conditions to check.\n  MachineBasicBlock *TBB = nullptr, *FBB = nullptr;\n  SmallVector<MachineOperand, 4> Cond;\n  if (!TII->analyzeBranch(*const_cast<MachineBasicBlock *>(MBB), TBB, FBB,\n                          Cond)) {\n    // Ok, analyzeBranch thinks it knows what's going on with this block. Let's\n    // check whether its answers match up with reality.\n    if (!TBB && !FBB) {\n      // Block falls through to its successor.\n      if (!MBB->empty() && MBB->back().isBarrier() &&\n          !TII->isPredicated(MBB->back())) {\n        report(\"MBB exits via unconditional fall-through but ends with a \"\n               \"barrier instruction!\", MBB);\n      }\n      if (!Cond.empty()) {\n        report(\"MBB exits via unconditional fall-through but has a condition!\",\n               MBB);\n      }\n    } else if (TBB && !FBB && Cond.empty()) {\n      // Block unconditionally branches somewhere.\n      if (MBB->empty()) {\n        report(\"MBB exits via unconditional branch but doesn't contain \"\n               \"any instructions!\", MBB);\n      } else if (!MBB->back().isBarrier()) {\n        report(\"MBB exits via unconditional branch but doesn't end with a \"\n               \"barrier instruction!\", MBB);\n      } else if (!MBB->back().isTerminator()) {\n        report(\"MBB exits via unconditional branch but the branch isn't a \"\n               \"terminator instruction!\", MBB);\n      }\n    } else if (TBB && !FBB && !Cond.empty()) {\n      // Block conditionally branches somewhere, otherwise falls through.\n      if (MBB->empty()) {\n        report(\"MBB exits via conditional branch/fall-through but doesn't \"\n               \"contain any instructions!\", MBB);\n      } else if (MBB->back().isBarrier()) {\n        report(\"MBB exits via conditional branch/fall-through but ends with a \"\n               \"barrier instruction!\", MBB);\n      } else if (!MBB->back().isTerminator()) {\n        report(\"MBB exits via conditional branch/fall-through but the branch \"\n               \"isn't a terminator instruction!\", MBB);\n      }\n    } else if (TBB && FBB) {\n      // Block conditionally branches somewhere, otherwise branches\n      // somewhere else.\n      if (MBB->empty()) {\n        report(\"MBB exits via conditional branch/branch but doesn't \"\n               \"contain any instructions!\", MBB);\n      } else if (!MBB->back().isBarrier()) {\n        report(\"MBB exits via conditional branch/branch but doesn't end with a \"\n               \"barrier instruction!\", MBB);\n      } else if (!MBB->back().isTerminator()) {\n        report(\"MBB exits via conditional branch/branch but the branch \"\n               \"isn't a terminator instruction!\", MBB);\n      }\n      if (Cond.empty()) {\n        report(\"MBB exits via conditional branch/branch but there's no \"\n               \"condition!\", MBB);\n      }\n    } else {\n      report(\"analyzeBranch returned invalid data!\", MBB);\n    }\n\n    // Now check that the successors match up with the answers reported by\n    // analyzeBranch.\n    if (TBB && !MBB->isSuccessor(TBB))\n      report(\"MBB exits via jump or conditional branch, but its target isn't a \"\n             \"CFG successor!\",\n             MBB);\n    if (FBB && !MBB->isSuccessor(FBB))\n      report(\"MBB exits via conditional branch, but its target isn't a CFG \"\n             \"successor!\",\n             MBB);\n\n    // There might be a fallthrough to the next block if there's either no\n    // unconditional true branch, or if there's a condition, and one of the\n    // branches is missing.\n    bool Fallthrough = !TBB || (!Cond.empty() && !FBB);\n\n    // A conditional fallthrough must be an actual CFG successor, not\n    // unreachable. (Conversely, an unconditional fallthrough might not really\n    // be a successor, because the block might end in unreachable.)\n    if (!Cond.empty() && !FBB) {\n      MachineFunction::const_iterator MBBI = std::next(MBB->getIterator());\n      if (MBBI == MF->end()) {\n        report(\"MBB conditionally falls through out of function!\", MBB);\n      } else if (!MBB->isSuccessor(&*MBBI))\n        report(\"MBB exits via conditional branch/fall-through but the CFG \"\n               \"successors don't match the actual successors!\",\n               MBB);\n    }\n\n    // Verify that there aren't any extra un-accounted-for successors.\n    for (const MachineBasicBlock *SuccMBB : MBB->successors()) {\n      // If this successor is one of the branch targets, it's okay.\n      if (SuccMBB == TBB || SuccMBB == FBB)\n        continue;\n      // If we might have a fallthrough, and the successor is the fallthrough\n      // block, that's also ok.\n      if (Fallthrough && SuccMBB == MBB->getNextNode())\n        continue;\n      // Also accept successors which are for exception-handling or might be\n      // inlineasm_br targets.\n      if (SuccMBB->isEHPad() || SuccMBB->isInlineAsmBrIndirectTarget())\n        continue;\n      report(\"MBB has unexpected successors which are not branch targets, \"\n             \"fallthrough, EHPads, or inlineasm_br targets.\",\n             MBB);\n    }\n  }\n\n  regsLive.clear();\n  if (MRI->tracksLiveness()) {\n    for (const auto &LI : MBB->liveins()) {\n      if (!Register::isPhysicalRegister(LI.PhysReg)) {\n        report(\"MBB live-in list contains non-physical register\", MBB);\n        continue;\n      }\n      for (const MCPhysReg &SubReg : TRI->subregs_inclusive(LI.PhysReg))\n        regsLive.insert(SubReg);\n    }\n  }\n\n  const MachineFrameInfo &MFI = MF->getFrameInfo();\n  BitVector PR = MFI.getPristineRegs(*MF);\n  for (unsigned I : PR.set_bits()) {\n    for (const MCPhysReg &SubReg : TRI->subregs_inclusive(I))\n      regsLive.insert(SubReg);\n  }\n\n  regsKilled.clear();\n  regsDefined.clear();\n\n  if (Indexes)\n    lastIndex = Indexes->getMBBStartIdx(MBB);\n}\n\n// This function gets called for all bundle headers, including normal\n// stand-alone unbundled instructions.\nvoid MachineVerifier::visitMachineBundleBefore(const MachineInstr *MI) {\n  if (Indexes && Indexes->hasIndex(*MI)) {\n    SlotIndex idx = Indexes->getInstructionIndex(*MI);\n    if (!(idx > lastIndex)) {\n      report(\"Instruction index out of order\", MI);\n      errs() << \"Last instruction was at \" << lastIndex << '\\n';\n    }\n    lastIndex = idx;\n  }\n\n  // Ensure non-terminators don't follow terminators.\n  if (MI->isTerminator()) {\n    if (!FirstTerminator)\n      FirstTerminator = MI;\n  } else if (FirstTerminator) {\n    report(\"Non-terminator instruction after the first terminator\", MI);\n    errs() << \"First terminator was:\\t\" << *FirstTerminator;\n  }\n}\n\n// The operands on an INLINEASM instruction must follow a template.\n// Verify that the flag operands make sense.\nvoid MachineVerifier::verifyInlineAsm(const MachineInstr *MI) {\n  // The first two operands on INLINEASM are the asm string and global flags.\n  if (MI->getNumOperands() < 2) {\n    report(\"Too few operands on inline asm\", MI);\n    return;\n  }\n  if (!MI->getOperand(0).isSymbol())\n    report(\"Asm string must be an external symbol\", MI);\n  if (!MI->getOperand(1).isImm())\n    report(\"Asm flags must be an immediate\", MI);\n  // Allowed flags are Extra_HasSideEffects = 1, Extra_IsAlignStack = 2,\n  // Extra_AsmDialect = 4, Extra_MayLoad = 8, and Extra_MayStore = 16,\n  // and Extra_IsConvergent = 32.\n  if (!isUInt<6>(MI->getOperand(1).getImm()))\n    report(\"Unknown asm flags\", &MI->getOperand(1), 1);\n\n  static_assert(InlineAsm::MIOp_FirstOperand == 2, \"Asm format changed\");\n\n  unsigned OpNo = InlineAsm::MIOp_FirstOperand;\n  unsigned NumOps;\n  for (unsigned e = MI->getNumOperands(); OpNo < e; OpNo += NumOps) {\n    const MachineOperand &MO = MI->getOperand(OpNo);\n    // There may be implicit ops after the fixed operands.\n    if (!MO.isImm())\n      break;\n    NumOps = 1 + InlineAsm::getNumOperandRegisters(MO.getImm());\n  }\n\n  if (OpNo > MI->getNumOperands())\n    report(\"Missing operands in last group\", MI);\n\n  // An optional MDNode follows the groups.\n  if (OpNo < MI->getNumOperands() && MI->getOperand(OpNo).isMetadata())\n    ++OpNo;\n\n  // All trailing operands must be implicit registers.\n  for (unsigned e = MI->getNumOperands(); OpNo < e; ++OpNo) {\n    const MachineOperand &MO = MI->getOperand(OpNo);\n    if (!MO.isReg() || !MO.isImplicit())\n      report(\"Expected implicit register after groups\", &MO, OpNo);\n  }\n}\n\n/// Check that types are consistent when two operands need to have the same\n/// number of vector elements.\n/// \\return true if the types are valid.\nbool MachineVerifier::verifyVectorElementMatch(LLT Ty0, LLT Ty1,\n                                               const MachineInstr *MI) {\n  if (Ty0.isVector() != Ty1.isVector()) {\n    report(\"operand types must be all-vector or all-scalar\", MI);\n    // Generally we try to report as many issues as possible at once, but in\n    // this case it's not clear what should we be comparing the size of the\n    // scalar with: the size of the whole vector or its lane. Instead of\n    // making an arbitrary choice and emitting not so helpful message, let's\n    // avoid the extra noise and stop here.\n    return false;\n  }\n\n  if (Ty0.isVector() && Ty0.getNumElements() != Ty1.getNumElements()) {\n    report(\"operand types must preserve number of vector elements\", MI);\n    return false;\n  }\n\n  return true;\n}\n\nvoid MachineVerifier::verifyPreISelGenericInstruction(const MachineInstr *MI) {\n  if (isFunctionSelected)\n    report(\"Unexpected generic instruction in a Selected function\", MI);\n\n  const MCInstrDesc &MCID = MI->getDesc();\n  unsigned NumOps = MI->getNumOperands();\n\n  // Branches must reference a basic block if they are not indirect\n  if (MI->isBranch() && !MI->isIndirectBranch()) {\n    bool HasMBB = false;\n    for (const MachineOperand &Op : MI->operands()) {\n      if (Op.isMBB()) {\n        HasMBB = true;\n        break;\n      }\n    }\n\n    if (!HasMBB) {\n      report(\"Branch instruction is missing a basic block operand or \"\n             \"isIndirectBranch property\",\n             MI);\n    }\n  }\n\n  // Check types.\n  SmallVector<LLT, 4> Types;\n  for (unsigned I = 0, E = std::min(MCID.getNumOperands(), NumOps);\n       I != E; ++I) {\n    if (!MCID.OpInfo[I].isGenericType())\n      continue;\n    // Generic instructions specify type equality constraints between some of\n    // their operands. Make sure these are consistent.\n    size_t TypeIdx = MCID.OpInfo[I].getGenericTypeIndex();\n    Types.resize(std::max(TypeIdx + 1, Types.size()));\n\n    const MachineOperand *MO = &MI->getOperand(I);\n    if (!MO->isReg()) {\n      report(\"generic instruction must use register operands\", MI);\n      continue;\n    }\n\n    LLT OpTy = MRI->getType(MO->getReg());\n    // Don't report a type mismatch if there is no actual mismatch, only a\n    // type missing, to reduce noise:\n    if (OpTy.isValid()) {\n      // Only the first valid type for a type index will be printed: don't\n      // overwrite it later so it's always clear which type was expected:\n      if (!Types[TypeIdx].isValid())\n        Types[TypeIdx] = OpTy;\n      else if (Types[TypeIdx] != OpTy)\n        report(\"Type mismatch in generic instruction\", MO, I, OpTy);\n    } else {\n      // Generic instructions must have types attached to their operands.\n      report(\"Generic instruction is missing a virtual register type\", MO, I);\n    }\n  }\n\n  // Generic opcodes must not have physical register operands.\n  for (unsigned I = 0; I < MI->getNumOperands(); ++I) {\n    const MachineOperand *MO = &MI->getOperand(I);\n    if (MO->isReg() && Register::isPhysicalRegister(MO->getReg()))\n      report(\"Generic instruction cannot have physical register\", MO, I);\n  }\n\n  // Avoid out of bounds in checks below. This was already reported earlier.\n  if (MI->getNumOperands() < MCID.getNumOperands())\n    return;\n\n  StringRef ErrorInfo;\n  if (!TII->verifyInstruction(*MI, ErrorInfo))\n    report(ErrorInfo.data(), MI);\n\n  // Verify properties of various specific instruction types\n  unsigned Opc = MI->getOpcode();\n  switch (Opc) {\n  case TargetOpcode::G_ASSERT_SEXT:\n  case TargetOpcode::G_ASSERT_ZEXT: {\n    std::string OpcName =\n        Opc == TargetOpcode::G_ASSERT_ZEXT ? \"G_ASSERT_ZEXT\" : \"G_ASSERT_SEXT\";\n    if (!MI->getOperand(2).isImm()) {\n      report(Twine(OpcName, \" expects an immediate operand #2\"), MI);\n      break;\n    }\n\n    Register Dst = MI->getOperand(0).getReg();\n    Register Src = MI->getOperand(1).getReg();\n    LLT SrcTy = MRI->getType(Src);\n    int64_t Imm = MI->getOperand(2).getImm();\n    if (Imm <= 0) {\n      report(Twine(OpcName, \" size must be >= 1\"), MI);\n      break;\n    }\n\n    if (Imm >= SrcTy.getScalarSizeInBits()) {\n      report(Twine(OpcName, \" size must be less than source bit width\"), MI);\n      break;\n    }\n\n    if (MRI->getRegBankOrNull(Src) != MRI->getRegBankOrNull(Dst)) {\n      report(\n          Twine(OpcName, \" source and destination register banks must match\"),\n          MI);\n      break;\n    }\n\n    if (MRI->getRegClassOrNull(Src) != MRI->getRegClassOrNull(Dst))\n      report(\n          Twine(OpcName, \" source and destination register classes must match\"),\n          MI);\n\n    break;\n  }\n\n  case TargetOpcode::G_CONSTANT:\n  case TargetOpcode::G_FCONSTANT: {\n    LLT DstTy = MRI->getType(MI->getOperand(0).getReg());\n    if (DstTy.isVector())\n      report(\"Instruction cannot use a vector result type\", MI);\n\n    if (MI->getOpcode() == TargetOpcode::G_CONSTANT) {\n      if (!MI->getOperand(1).isCImm()) {\n        report(\"G_CONSTANT operand must be cimm\", MI);\n        break;\n      }\n\n      const ConstantInt *CI = MI->getOperand(1).getCImm();\n      if (CI->getBitWidth() != DstTy.getSizeInBits())\n        report(\"inconsistent constant size\", MI);\n    } else {\n      if (!MI->getOperand(1).isFPImm()) {\n        report(\"G_FCONSTANT operand must be fpimm\", MI);\n        break;\n      }\n      const ConstantFP *CF = MI->getOperand(1).getFPImm();\n\n      if (APFloat::getSizeInBits(CF->getValueAPF().getSemantics()) !=\n          DstTy.getSizeInBits()) {\n        report(\"inconsistent constant size\", MI);\n      }\n    }\n\n    break;\n  }\n  case TargetOpcode::G_LOAD:\n  case TargetOpcode::G_STORE:\n  case TargetOpcode::G_ZEXTLOAD:\n  case TargetOpcode::G_SEXTLOAD: {\n    LLT ValTy = MRI->getType(MI->getOperand(0).getReg());\n    LLT PtrTy = MRI->getType(MI->getOperand(1).getReg());\n    if (!PtrTy.isPointer())\n      report(\"Generic memory instruction must access a pointer\", MI);\n\n    // Generic loads and stores must have a single MachineMemOperand\n    // describing that access.\n    if (!MI->hasOneMemOperand()) {\n      report(\"Generic instruction accessing memory must have one mem operand\",\n             MI);\n    } else {\n      const MachineMemOperand &MMO = **MI->memoperands_begin();\n      if (MI->getOpcode() == TargetOpcode::G_ZEXTLOAD ||\n          MI->getOpcode() == TargetOpcode::G_SEXTLOAD) {\n        if (MMO.getSizeInBits() >= ValTy.getSizeInBits())\n          report(\"Generic extload must have a narrower memory type\", MI);\n      } else if (MI->getOpcode() == TargetOpcode::G_LOAD) {\n        if (MMO.getSize() > ValTy.getSizeInBytes())\n          report(\"load memory size cannot exceed result size\", MI);\n      } else if (MI->getOpcode() == TargetOpcode::G_STORE) {\n        if (ValTy.getSizeInBytes() < MMO.getSize())\n          report(\"store memory size cannot exceed value size\", MI);\n      }\n    }\n\n    break;\n  }\n  case TargetOpcode::G_PHI: {\n    LLT DstTy = MRI->getType(MI->getOperand(0).getReg());\n    if (!DstTy.isValid() || !all_of(drop_begin(MI->operands()),\n                                    [this, &DstTy](const MachineOperand &MO) {\n                                      if (!MO.isReg())\n                                        return true;\n                                      LLT Ty = MRI->getType(MO.getReg());\n                                      if (!Ty.isValid() || (Ty != DstTy))\n                                        return false;\n                                      return true;\n                                    }))\n      report(\"Generic Instruction G_PHI has operands with incompatible/missing \"\n             \"types\",\n             MI);\n    break;\n  }\n  case TargetOpcode::G_BITCAST: {\n    LLT DstTy = MRI->getType(MI->getOperand(0).getReg());\n    LLT SrcTy = MRI->getType(MI->getOperand(1).getReg());\n    if (!DstTy.isValid() || !SrcTy.isValid())\n      break;\n\n    if (SrcTy.isPointer() != DstTy.isPointer())\n      report(\"bitcast cannot convert between pointers and other types\", MI);\n\n    if (SrcTy.getSizeInBits() != DstTy.getSizeInBits())\n      report(\"bitcast sizes must match\", MI);\n\n    if (SrcTy == DstTy)\n      report(\"bitcast must change the type\", MI);\n\n    break;\n  }\n  case TargetOpcode::G_INTTOPTR:\n  case TargetOpcode::G_PTRTOINT:\n  case TargetOpcode::G_ADDRSPACE_CAST: {\n    LLT DstTy = MRI->getType(MI->getOperand(0).getReg());\n    LLT SrcTy = MRI->getType(MI->getOperand(1).getReg());\n    if (!DstTy.isValid() || !SrcTy.isValid())\n      break;\n\n    verifyVectorElementMatch(DstTy, SrcTy, MI);\n\n    DstTy = DstTy.getScalarType();\n    SrcTy = SrcTy.getScalarType();\n\n    if (MI->getOpcode() == TargetOpcode::G_INTTOPTR) {\n      if (!DstTy.isPointer())\n        report(\"inttoptr result type must be a pointer\", MI);\n      if (SrcTy.isPointer())\n        report(\"inttoptr source type must not be a pointer\", MI);\n    } else if (MI->getOpcode() == TargetOpcode::G_PTRTOINT) {\n      if (!SrcTy.isPointer())\n        report(\"ptrtoint source type must be a pointer\", MI);\n      if (DstTy.isPointer())\n        report(\"ptrtoint result type must not be a pointer\", MI);\n    } else {\n      assert(MI->getOpcode() == TargetOpcode::G_ADDRSPACE_CAST);\n      if (!SrcTy.isPointer() || !DstTy.isPointer())\n        report(\"addrspacecast types must be pointers\", MI);\n      else {\n        if (SrcTy.getAddressSpace() == DstTy.getAddressSpace())\n          report(\"addrspacecast must convert different address spaces\", MI);\n      }\n    }\n\n    break;\n  }\n  case TargetOpcode::G_PTR_ADD: {\n    LLT DstTy = MRI->getType(MI->getOperand(0).getReg());\n    LLT PtrTy = MRI->getType(MI->getOperand(1).getReg());\n    LLT OffsetTy = MRI->getType(MI->getOperand(2).getReg());\n    if (!DstTy.isValid() || !PtrTy.isValid() || !OffsetTy.isValid())\n      break;\n\n    if (!PtrTy.getScalarType().isPointer())\n      report(\"gep first operand must be a pointer\", MI);\n\n    if (OffsetTy.getScalarType().isPointer())\n      report(\"gep offset operand must not be a pointer\", MI);\n\n    // TODO: Is the offset allowed to be a scalar with a vector?\n    break;\n  }\n  case TargetOpcode::G_PTRMASK: {\n    LLT DstTy = MRI->getType(MI->getOperand(0).getReg());\n    LLT SrcTy = MRI->getType(MI->getOperand(1).getReg());\n    LLT MaskTy = MRI->getType(MI->getOperand(2).getReg());\n    if (!DstTy.isValid() || !SrcTy.isValid() || !MaskTy.isValid())\n      break;\n\n    if (!DstTy.getScalarType().isPointer())\n      report(\"ptrmask result type must be a pointer\", MI);\n\n    if (!MaskTy.getScalarType().isScalar())\n      report(\"ptrmask mask type must be an integer\", MI);\n\n    verifyVectorElementMatch(DstTy, MaskTy, MI);\n    break;\n  }\n  case TargetOpcode::G_SEXT:\n  case TargetOpcode::G_ZEXT:\n  case TargetOpcode::G_ANYEXT:\n  case TargetOpcode::G_TRUNC:\n  case TargetOpcode::G_FPEXT:\n  case TargetOpcode::G_FPTRUNC: {\n    // Number of operands and presense of types is already checked (and\n    // reported in case of any issues), so no need to report them again. As\n    // we're trying to report as many issues as possible at once, however, the\n    // instructions aren't guaranteed to have the right number of operands or\n    // types attached to them at this point\n    assert(MCID.getNumOperands() == 2 && \"Expected 2 operands G_*{EXT,TRUNC}\");\n    LLT DstTy = MRI->getType(MI->getOperand(0).getReg());\n    LLT SrcTy = MRI->getType(MI->getOperand(1).getReg());\n    if (!DstTy.isValid() || !SrcTy.isValid())\n      break;\n\n    LLT DstElTy = DstTy.getScalarType();\n    LLT SrcElTy = SrcTy.getScalarType();\n    if (DstElTy.isPointer() || SrcElTy.isPointer())\n      report(\"Generic extend/truncate can not operate on pointers\", MI);\n\n    verifyVectorElementMatch(DstTy, SrcTy, MI);\n\n    unsigned DstSize = DstElTy.getSizeInBits();\n    unsigned SrcSize = SrcElTy.getSizeInBits();\n    switch (MI->getOpcode()) {\n    default:\n      if (DstSize <= SrcSize)\n        report(\"Generic extend has destination type no larger than source\", MI);\n      break;\n    case TargetOpcode::G_TRUNC:\n    case TargetOpcode::G_FPTRUNC:\n      if (DstSize >= SrcSize)\n        report(\"Generic truncate has destination type no smaller than source\",\n               MI);\n      break;\n    }\n    break;\n  }\n  case TargetOpcode::G_SELECT: {\n    LLT SelTy = MRI->getType(MI->getOperand(0).getReg());\n    LLT CondTy = MRI->getType(MI->getOperand(1).getReg());\n    if (!SelTy.isValid() || !CondTy.isValid())\n      break;\n\n    // Scalar condition select on a vector is valid.\n    if (CondTy.isVector())\n      verifyVectorElementMatch(SelTy, CondTy, MI);\n    break;\n  }\n  case TargetOpcode::G_MERGE_VALUES: {\n    // G_MERGE_VALUES should only be used to merge scalars into a larger scalar,\n    // e.g. s2N = MERGE sN, sN\n    // Merging multiple scalars into a vector is not allowed, should use\n    // G_BUILD_VECTOR for that.\n    LLT DstTy = MRI->getType(MI->getOperand(0).getReg());\n    LLT SrcTy = MRI->getType(MI->getOperand(1).getReg());\n    if (DstTy.isVector() || SrcTy.isVector())\n      report(\"G_MERGE_VALUES cannot operate on vectors\", MI);\n\n    const unsigned NumOps = MI->getNumOperands();\n    if (DstTy.getSizeInBits() != SrcTy.getSizeInBits() * (NumOps - 1))\n      report(\"G_MERGE_VALUES result size is inconsistent\", MI);\n\n    for (unsigned I = 2; I != NumOps; ++I) {\n      if (MRI->getType(MI->getOperand(I).getReg()) != SrcTy)\n        report(\"G_MERGE_VALUES source types do not match\", MI);\n    }\n\n    break;\n  }\n  case TargetOpcode::G_UNMERGE_VALUES: {\n    LLT DstTy = MRI->getType(MI->getOperand(0).getReg());\n    LLT SrcTy = MRI->getType(MI->getOperand(MI->getNumOperands()-1).getReg());\n    // For now G_UNMERGE can split vectors.\n    for (unsigned i = 0; i < MI->getNumOperands()-1; ++i) {\n      if (MRI->getType(MI->getOperand(i).getReg()) != DstTy)\n        report(\"G_UNMERGE_VALUES destination types do not match\", MI);\n    }\n    if (SrcTy.getSizeInBits() !=\n        (DstTy.getSizeInBits() * (MI->getNumOperands() - 1))) {\n      report(\"G_UNMERGE_VALUES source operand does not cover dest operands\",\n             MI);\n    }\n    break;\n  }\n  case TargetOpcode::G_BUILD_VECTOR: {\n    // Source types must be scalars, dest type a vector. Total size of scalars\n    // must match the dest vector size.\n    LLT DstTy = MRI->getType(MI->getOperand(0).getReg());\n    LLT SrcEltTy = MRI->getType(MI->getOperand(1).getReg());\n    if (!DstTy.isVector() || SrcEltTy.isVector()) {\n      report(\"G_BUILD_VECTOR must produce a vector from scalar operands\", MI);\n      break;\n    }\n\n    if (DstTy.getElementType() != SrcEltTy)\n      report(\"G_BUILD_VECTOR result element type must match source type\", MI);\n\n    if (DstTy.getNumElements() != MI->getNumOperands() - 1)\n      report(\"G_BUILD_VECTOR must have an operand for each elemement\", MI);\n\n    for (unsigned i = 2; i < MI->getNumOperands(); ++i) {\n      if (MRI->getType(MI->getOperand(1).getReg()) !=\n          MRI->getType(MI->getOperand(i).getReg()))\n        report(\"G_BUILD_VECTOR source operand types are not homogeneous\", MI);\n    }\n\n    break;\n  }\n  case TargetOpcode::G_BUILD_VECTOR_TRUNC: {\n    // Source types must be scalars, dest type a vector. Scalar types must be\n    // larger than the dest vector elt type, as this is a truncating operation.\n    LLT DstTy = MRI->getType(MI->getOperand(0).getReg());\n    LLT SrcEltTy = MRI->getType(MI->getOperand(1).getReg());\n    if (!DstTy.isVector() || SrcEltTy.isVector())\n      report(\"G_BUILD_VECTOR_TRUNC must produce a vector from scalar operands\",\n             MI);\n    for (unsigned i = 2; i < MI->getNumOperands(); ++i) {\n      if (MRI->getType(MI->getOperand(1).getReg()) !=\n          MRI->getType(MI->getOperand(i).getReg()))\n        report(\"G_BUILD_VECTOR_TRUNC source operand types are not homogeneous\",\n               MI);\n    }\n    if (SrcEltTy.getSizeInBits() <= DstTy.getElementType().getSizeInBits())\n      report(\"G_BUILD_VECTOR_TRUNC source operand types are not larger than \"\n             \"dest elt type\",\n             MI);\n    break;\n  }\n  case TargetOpcode::G_CONCAT_VECTORS: {\n    // Source types should be vectors, and total size should match the dest\n    // vector size.\n    LLT DstTy = MRI->getType(MI->getOperand(0).getReg());\n    LLT SrcTy = MRI->getType(MI->getOperand(1).getReg());\n    if (!DstTy.isVector() || !SrcTy.isVector())\n      report(\"G_CONCAT_VECTOR requires vector source and destination operands\",\n             MI);\n\n    if (MI->getNumOperands() < 3)\n      report(\"G_CONCAT_VECTOR requires at least 2 source operands\", MI);\n\n    for (unsigned i = 2; i < MI->getNumOperands(); ++i) {\n      if (MRI->getType(MI->getOperand(1).getReg()) !=\n          MRI->getType(MI->getOperand(i).getReg()))\n        report(\"G_CONCAT_VECTOR source operand types are not homogeneous\", MI);\n    }\n    if (DstTy.getNumElements() !=\n        SrcTy.getNumElements() * (MI->getNumOperands() - 1))\n      report(\"G_CONCAT_VECTOR num dest and source elements should match\", MI);\n    break;\n  }\n  case TargetOpcode::G_ICMP:\n  case TargetOpcode::G_FCMP: {\n    LLT DstTy = MRI->getType(MI->getOperand(0).getReg());\n    LLT SrcTy = MRI->getType(MI->getOperand(2).getReg());\n\n    if ((DstTy.isVector() != SrcTy.isVector()) ||\n        (DstTy.isVector() && DstTy.getNumElements() != SrcTy.getNumElements()))\n      report(\"Generic vector icmp/fcmp must preserve number of lanes\", MI);\n\n    break;\n  }\n  case TargetOpcode::G_EXTRACT: {\n    const MachineOperand &SrcOp = MI->getOperand(1);\n    if (!SrcOp.isReg()) {\n      report(\"extract source must be a register\", MI);\n      break;\n    }\n\n    const MachineOperand &OffsetOp = MI->getOperand(2);\n    if (!OffsetOp.isImm()) {\n      report(\"extract offset must be a constant\", MI);\n      break;\n    }\n\n    unsigned DstSize = MRI->getType(MI->getOperand(0).getReg()).getSizeInBits();\n    unsigned SrcSize = MRI->getType(SrcOp.getReg()).getSizeInBits();\n    if (SrcSize == DstSize)\n      report(\"extract source must be larger than result\", MI);\n\n    if (DstSize + OffsetOp.getImm() > SrcSize)\n      report(\"extract reads past end of register\", MI);\n    break;\n  }\n  case TargetOpcode::G_INSERT: {\n    const MachineOperand &SrcOp = MI->getOperand(2);\n    if (!SrcOp.isReg()) {\n      report(\"insert source must be a register\", MI);\n      break;\n    }\n\n    const MachineOperand &OffsetOp = MI->getOperand(3);\n    if (!OffsetOp.isImm()) {\n      report(\"insert offset must be a constant\", MI);\n      break;\n    }\n\n    unsigned DstSize = MRI->getType(MI->getOperand(0).getReg()).getSizeInBits();\n    unsigned SrcSize = MRI->getType(SrcOp.getReg()).getSizeInBits();\n\n    if (DstSize <= SrcSize)\n      report(\"inserted size must be smaller than total register\", MI);\n\n    if (SrcSize + OffsetOp.getImm() > DstSize)\n      report(\"insert writes past end of register\", MI);\n\n    break;\n  }\n  case TargetOpcode::G_JUMP_TABLE: {\n    if (!MI->getOperand(1).isJTI())\n      report(\"G_JUMP_TABLE source operand must be a jump table index\", MI);\n    LLT DstTy = MRI->getType(MI->getOperand(0).getReg());\n    if (!DstTy.isPointer())\n      report(\"G_JUMP_TABLE dest operand must have a pointer type\", MI);\n    break;\n  }\n  case TargetOpcode::G_BRJT: {\n    if (!MRI->getType(MI->getOperand(0).getReg()).isPointer())\n      report(\"G_BRJT src operand 0 must be a pointer type\", MI);\n\n    if (!MI->getOperand(1).isJTI())\n      report(\"G_BRJT src operand 1 must be a jump table index\", MI);\n\n    const auto &IdxOp = MI->getOperand(2);\n    if (!IdxOp.isReg() || MRI->getType(IdxOp.getReg()).isPointer())\n      report(\"G_BRJT src operand 2 must be a scalar reg type\", MI);\n    break;\n  }\n  case TargetOpcode::G_INTRINSIC:\n  case TargetOpcode::G_INTRINSIC_W_SIDE_EFFECTS: {\n    // TODO: Should verify number of def and use operands, but the current\n    // interface requires passing in IR types for mangling.\n    const MachineOperand &IntrIDOp = MI->getOperand(MI->getNumExplicitDefs());\n    if (!IntrIDOp.isIntrinsicID()) {\n      report(\"G_INTRINSIC first src operand must be an intrinsic ID\", MI);\n      break;\n    }\n\n    bool NoSideEffects = MI->getOpcode() == TargetOpcode::G_INTRINSIC;\n    unsigned IntrID = IntrIDOp.getIntrinsicID();\n    if (IntrID != 0 && IntrID < Intrinsic::num_intrinsics) {\n      AttributeList Attrs\n        = Intrinsic::getAttributes(MF->getFunction().getContext(),\n                                   static_cast<Intrinsic::ID>(IntrID));\n      bool DeclHasSideEffects = !Attrs.hasFnAttribute(Attribute::ReadNone);\n      if (NoSideEffects && DeclHasSideEffects) {\n        report(\"G_INTRINSIC used with intrinsic that accesses memory\", MI);\n        break;\n      }\n      if (!NoSideEffects && !DeclHasSideEffects) {\n        report(\"G_INTRINSIC_W_SIDE_EFFECTS used with readnone intrinsic\", MI);\n        break;\n      }\n    }\n\n    break;\n  }\n  case TargetOpcode::G_SEXT_INREG: {\n    if (!MI->getOperand(2).isImm()) {\n      report(\"G_SEXT_INREG expects an immediate operand #2\", MI);\n      break;\n    }\n\n    LLT SrcTy = MRI->getType(MI->getOperand(1).getReg());\n    int64_t Imm = MI->getOperand(2).getImm();\n    if (Imm <= 0)\n      report(\"G_SEXT_INREG size must be >= 1\", MI);\n    if (Imm >= SrcTy.getScalarSizeInBits())\n      report(\"G_SEXT_INREG size must be less than source bit width\", MI);\n    break;\n  }\n  case TargetOpcode::G_SHUFFLE_VECTOR: {\n    const MachineOperand &MaskOp = MI->getOperand(3);\n    if (!MaskOp.isShuffleMask()) {\n      report(\"Incorrect mask operand type for G_SHUFFLE_VECTOR\", MI);\n      break;\n    }\n\n    LLT DstTy = MRI->getType(MI->getOperand(0).getReg());\n    LLT Src0Ty = MRI->getType(MI->getOperand(1).getReg());\n    LLT Src1Ty = MRI->getType(MI->getOperand(2).getReg());\n\n    if (Src0Ty != Src1Ty)\n      report(\"Source operands must be the same type\", MI);\n\n    if (Src0Ty.getScalarType() != DstTy.getScalarType())\n      report(\"G_SHUFFLE_VECTOR cannot change element type\", MI);\n\n    // Don't check that all operands are vector because scalars are used in\n    // place of 1 element vectors.\n    int SrcNumElts = Src0Ty.isVector() ? Src0Ty.getNumElements() : 1;\n    int DstNumElts = DstTy.isVector() ? DstTy.getNumElements() : 1;\n\n    ArrayRef<int> MaskIdxes = MaskOp.getShuffleMask();\n\n    if (static_cast<int>(MaskIdxes.size()) != DstNumElts)\n      report(\"Wrong result type for shufflemask\", MI);\n\n    for (int Idx : MaskIdxes) {\n      if (Idx < 0)\n        continue;\n\n      if (Idx >= 2 * SrcNumElts)\n        report(\"Out of bounds shuffle index\", MI);\n    }\n\n    break;\n  }\n  case TargetOpcode::G_DYN_STACKALLOC: {\n    const MachineOperand &DstOp = MI->getOperand(0);\n    const MachineOperand &AllocOp = MI->getOperand(1);\n    const MachineOperand &AlignOp = MI->getOperand(2);\n\n    if (!DstOp.isReg() || !MRI->getType(DstOp.getReg()).isPointer()) {\n      report(\"dst operand 0 must be a pointer type\", MI);\n      break;\n    }\n\n    if (!AllocOp.isReg() || !MRI->getType(AllocOp.getReg()).isScalar()) {\n      report(\"src operand 1 must be a scalar reg type\", MI);\n      break;\n    }\n\n    if (!AlignOp.isImm()) {\n      report(\"src operand 2 must be an immediate type\", MI);\n      break;\n    }\n    break;\n  }\n  case TargetOpcode::G_MEMCPY:\n  case TargetOpcode::G_MEMMOVE: {\n    ArrayRef<MachineMemOperand *> MMOs = MI->memoperands();\n    if (MMOs.size() != 2) {\n      report(\"memcpy/memmove must have 2 memory operands\", MI);\n      break;\n    }\n\n    if ((!MMOs[0]->isStore() || MMOs[0]->isLoad()) ||\n        (MMOs[1]->isStore() || !MMOs[1]->isLoad())) {\n      report(\"wrong memory operand types\", MI);\n      break;\n    }\n\n    if (MMOs[0]->getSize() != MMOs[1]->getSize())\n      report(\"inconsistent memory operand sizes\", MI);\n\n    LLT DstPtrTy = MRI->getType(MI->getOperand(0).getReg());\n    LLT SrcPtrTy = MRI->getType(MI->getOperand(1).getReg());\n\n    if (!DstPtrTy.isPointer() || !SrcPtrTy.isPointer()) {\n      report(\"memory instruction operand must be a pointer\", MI);\n      break;\n    }\n\n    if (DstPtrTy.getAddressSpace() != MMOs[0]->getAddrSpace())\n      report(\"inconsistent store address space\", MI);\n    if (SrcPtrTy.getAddressSpace() != MMOs[1]->getAddrSpace())\n      report(\"inconsistent load address space\", MI);\n\n    break;\n  }\n  case TargetOpcode::G_MEMSET: {\n    ArrayRef<MachineMemOperand *> MMOs = MI->memoperands();\n    if (MMOs.size() != 1) {\n      report(\"memset must have 1 memory operand\", MI);\n      break;\n    }\n\n    if ((!MMOs[0]->isStore() || MMOs[0]->isLoad())) {\n      report(\"memset memory operand must be a store\", MI);\n      break;\n    }\n\n    LLT DstPtrTy = MRI->getType(MI->getOperand(0).getReg());\n    if (!DstPtrTy.isPointer()) {\n      report(\"memset operand must be a pointer\", MI);\n      break;\n    }\n\n    if (DstPtrTy.getAddressSpace() != MMOs[0]->getAddrSpace())\n      report(\"inconsistent memset address space\", MI);\n\n    break;\n  }\n  case TargetOpcode::G_VECREDUCE_SEQ_FADD:\n  case TargetOpcode::G_VECREDUCE_SEQ_FMUL: {\n    LLT DstTy = MRI->getType(MI->getOperand(0).getReg());\n    LLT Src1Ty = MRI->getType(MI->getOperand(1).getReg());\n    LLT Src2Ty = MRI->getType(MI->getOperand(2).getReg());\n    if (!DstTy.isScalar())\n      report(\"Vector reduction requires a scalar destination type\", MI);\n    if (!Src1Ty.isScalar())\n      report(\"Sequential FADD/FMUL vector reduction requires a scalar 1st operand\", MI);\n    if (!Src2Ty.isVector())\n      report(\"Sequential FADD/FMUL vector reduction must have a vector 2nd operand\", MI);\n    break;\n  }\n  case TargetOpcode::G_VECREDUCE_FADD:\n  case TargetOpcode::G_VECREDUCE_FMUL:\n  case TargetOpcode::G_VECREDUCE_FMAX:\n  case TargetOpcode::G_VECREDUCE_FMIN:\n  case TargetOpcode::G_VECREDUCE_ADD:\n  case TargetOpcode::G_VECREDUCE_MUL:\n  case TargetOpcode::G_VECREDUCE_AND:\n  case TargetOpcode::G_VECREDUCE_OR:\n  case TargetOpcode::G_VECREDUCE_XOR:\n  case TargetOpcode::G_VECREDUCE_SMAX:\n  case TargetOpcode::G_VECREDUCE_SMIN:\n  case TargetOpcode::G_VECREDUCE_UMAX:\n  case TargetOpcode::G_VECREDUCE_UMIN: {\n    LLT DstTy = MRI->getType(MI->getOperand(0).getReg());\n    LLT SrcTy = MRI->getType(MI->getOperand(1).getReg());\n    if (!DstTy.isScalar())\n      report(\"Vector reduction requires a scalar destination type\", MI);\n    if (!SrcTy.isVector())\n      report(\"Vector reduction requires vector source=\", MI);\n    break;\n  }\n  default:\n    break;\n  }\n}\n\nvoid MachineVerifier::visitMachineInstrBefore(const MachineInstr *MI) {\n  const MCInstrDesc &MCID = MI->getDesc();\n  if (MI->getNumOperands() < MCID.getNumOperands()) {\n    report(\"Too few operands\", MI);\n    errs() << MCID.getNumOperands() << \" operands expected, but \"\n           << MI->getNumOperands() << \" given.\\n\";\n  }\n\n  if (MI->isPHI()) {\n    if (MF->getProperties().hasProperty(\n            MachineFunctionProperties::Property::NoPHIs))\n      report(\"Found PHI instruction with NoPHIs property set\", MI);\n\n    if (FirstNonPHI)\n      report(\"Found PHI instruction after non-PHI\", MI);\n  } else if (FirstNonPHI == nullptr)\n    FirstNonPHI = MI;\n\n  // Check the tied operands.\n  if (MI->isInlineAsm())\n    verifyInlineAsm(MI);\n\n  // Check that unspillable terminators define a reg and have at most one use.\n  if (TII->isUnspillableTerminator(MI)) {\n    if (!MI->getOperand(0).isReg() || !MI->getOperand(0).isDef())\n      report(\"Unspillable Terminator does not define a reg\", MI);\n    Register Def = MI->getOperand(0).getReg();\n    if (Def.isVirtual() &&\n        std::distance(MRI->use_nodbg_begin(Def), MRI->use_nodbg_end()) > 1)\n      report(\"Unspillable Terminator expected to have at most one use!\", MI);\n  }\n\n  // A fully-formed DBG_VALUE must have a location. Ignore partially formed\n  // DBG_VALUEs: these are convenient to use in tests, but should never get\n  // generated.\n  if (MI->isDebugValue() && MI->getNumOperands() == 4)\n    if (!MI->getDebugLoc())\n      report(\"Missing DebugLoc for debug instruction\", MI);\n\n  // Meta instructions should never be the subject of debug value tracking,\n  // they don't create a value in the output program at all.\n  if (MI->isMetaInstruction() && MI->peekDebugInstrNum())\n    report(\"Metadata instruction should not have a value tracking number\", MI);\n\n  // Check the MachineMemOperands for basic consistency.\n  for (MachineMemOperand *Op : MI->memoperands()) {\n    if (Op->isLoad() && !MI->mayLoad())\n      report(\"Missing mayLoad flag\", MI);\n    if (Op->isStore() && !MI->mayStore())\n      report(\"Missing mayStore flag\", MI);\n  }\n\n  // Debug values must not have a slot index.\n  // Other instructions must have one, unless they are inside a bundle.\n  if (LiveInts) {\n    bool mapped = !LiveInts->isNotInMIMap(*MI);\n    if (MI->isDebugInstr()) {\n      if (mapped)\n        report(\"Debug instruction has a slot index\", MI);\n    } else if (MI->isInsideBundle()) {\n      if (mapped)\n        report(\"Instruction inside bundle has a slot index\", MI);\n    } else {\n      if (!mapped)\n        report(\"Missing slot index\", MI);\n    }\n  }\n\n  unsigned Opc = MCID.getOpcode();\n  if (isPreISelGenericOpcode(Opc) || isPreISelGenericOptimizationHint(Opc)) {\n    verifyPreISelGenericInstruction(MI);\n    return;\n  }\n\n  StringRef ErrorInfo;\n  if (!TII->verifyInstruction(*MI, ErrorInfo))\n    report(ErrorInfo.data(), MI);\n\n  // Verify properties of various specific instruction types\n  switch (MI->getOpcode()) {\n  case TargetOpcode::COPY: {\n    if (foundErrors)\n      break;\n    const MachineOperand &DstOp = MI->getOperand(0);\n    const MachineOperand &SrcOp = MI->getOperand(1);\n    LLT DstTy = MRI->getType(DstOp.getReg());\n    LLT SrcTy = MRI->getType(SrcOp.getReg());\n    if (SrcTy.isValid() && DstTy.isValid()) {\n      // If both types are valid, check that the types are the same.\n      if (SrcTy != DstTy) {\n        report(\"Copy Instruction is illegal with mismatching types\", MI);\n        errs() << \"Def = \" << DstTy << \", Src = \" << SrcTy << \"\\n\";\n      }\n    }\n    if (SrcTy.isValid() || DstTy.isValid()) {\n      // If one of them have valid types, let's just check they have the same\n      // size.\n      unsigned SrcSize = TRI->getRegSizeInBits(SrcOp.getReg(), *MRI);\n      unsigned DstSize = TRI->getRegSizeInBits(DstOp.getReg(), *MRI);\n      assert(SrcSize && \"Expecting size here\");\n      assert(DstSize && \"Expecting size here\");\n      if (SrcSize != DstSize)\n        if (!DstOp.getSubReg() && !SrcOp.getSubReg()) {\n          report(\"Copy Instruction is illegal with mismatching sizes\", MI);\n          errs() << \"Def Size = \" << DstSize << \", Src Size = \" << SrcSize\n                 << \"\\n\";\n        }\n    }\n    break;\n  }\n  case TargetOpcode::STATEPOINT: {\n    StatepointOpers SO(MI);\n    if (!MI->getOperand(SO.getIDPos()).isImm() ||\n        !MI->getOperand(SO.getNBytesPos()).isImm() ||\n        !MI->getOperand(SO.getNCallArgsPos()).isImm()) {\n      report(\"meta operands to STATEPOINT not constant!\", MI);\n      break;\n    }\n\n    auto VerifyStackMapConstant = [&](unsigned Offset) {\n      if (Offset >= MI->getNumOperands()) {\n        report(\"stack map constant to STATEPOINT is out of range!\", MI);\n        return;\n      }\n      if (!MI->getOperand(Offset - 1).isImm() ||\n          MI->getOperand(Offset - 1).getImm() != StackMaps::ConstantOp ||\n          !MI->getOperand(Offset).isImm())\n        report(\"stack map constant to STATEPOINT not well formed!\", MI);\n    };\n    VerifyStackMapConstant(SO.getCCIdx());\n    VerifyStackMapConstant(SO.getFlagsIdx());\n    VerifyStackMapConstant(SO.getNumDeoptArgsIdx());\n    VerifyStackMapConstant(SO.getNumGCPtrIdx());\n    VerifyStackMapConstant(SO.getNumAllocaIdx());\n    VerifyStackMapConstant(SO.getNumGcMapEntriesIdx());\n\n    // Verify that all explicit statepoint defs are tied to gc operands as\n    // they are expected to be a relocation of gc operands.\n    unsigned FirstGCPtrIdx = SO.getFirstGCPtrIdx();\n    unsigned LastGCPtrIdx = SO.getNumAllocaIdx() - 2;\n    for (unsigned Idx = 0; Idx < MI->getNumDefs(); Idx++) {\n      unsigned UseOpIdx;\n      if (!MI->isRegTiedToUseOperand(Idx, &UseOpIdx)) {\n        report(\"STATEPOINT defs expected to be tied\", MI);\n        break;\n      }\n      if (UseOpIdx < FirstGCPtrIdx || UseOpIdx > LastGCPtrIdx) {\n        report(\"STATEPOINT def tied to non-gc operand\", MI);\n        break;\n      }\n    }\n\n    // TODO: verify we have properly encoded deopt arguments\n  } break;\n  }\n}\n\nvoid\nMachineVerifier::visitMachineOperand(const MachineOperand *MO, unsigned MONum) {\n  const MachineInstr *MI = MO->getParent();\n  const MCInstrDesc &MCID = MI->getDesc();\n  unsigned NumDefs = MCID.getNumDefs();\n  if (MCID.getOpcode() == TargetOpcode::PATCHPOINT)\n    NumDefs = (MONum == 0 && MO->isReg()) ? NumDefs : 0;\n\n  // The first MCID.NumDefs operands must be explicit register defines\n  if (MONum < NumDefs) {\n    const MCOperandInfo &MCOI = MCID.OpInfo[MONum];\n    if (!MO->isReg())\n      report(\"Explicit definition must be a register\", MO, MONum);\n    else if (!MO->isDef() && !MCOI.isOptionalDef())\n      report(\"Explicit definition marked as use\", MO, MONum);\n    else if (MO->isImplicit())\n      report(\"Explicit definition marked as implicit\", MO, MONum);\n  } else if (MONum < MCID.getNumOperands()) {\n    const MCOperandInfo &MCOI = MCID.OpInfo[MONum];\n    // Don't check if it's the last operand in a variadic instruction. See,\n    // e.g., LDM_RET in the arm back end. Check non-variadic operands only.\n    bool IsOptional = MI->isVariadic() && MONum == MCID.getNumOperands() - 1;\n    if (!IsOptional) {\n      if (MO->isReg()) {\n        if (MO->isDef() && !MCOI.isOptionalDef() && !MCID.variadicOpsAreDefs())\n          report(\"Explicit operand marked as def\", MO, MONum);\n        if (MO->isImplicit())\n          report(\"Explicit operand marked as implicit\", MO, MONum);\n      }\n\n      // Check that an instruction has register operands only as expected.\n      if (MCOI.OperandType == MCOI::OPERAND_REGISTER &&\n          !MO->isReg() && !MO->isFI())\n        report(\"Expected a register operand.\", MO, MONum);\n      if (MO->isReg()) {\n        if (MCOI.OperandType == MCOI::OPERAND_IMMEDIATE ||\n            (MCOI.OperandType == MCOI::OPERAND_PCREL &&\n             !TII->isPCRelRegisterOperandLegal(*MO)))\n          report(\"Expected a non-register operand.\", MO, MONum);\n      }\n    }\n\n    int TiedTo = MCID.getOperandConstraint(MONum, MCOI::TIED_TO);\n    if (TiedTo != -1) {\n      if (!MO->isReg())\n        report(\"Tied use must be a register\", MO, MONum);\n      else if (!MO->isTied())\n        report(\"Operand should be tied\", MO, MONum);\n      else if (unsigned(TiedTo) != MI->findTiedOperandIdx(MONum))\n        report(\"Tied def doesn't match MCInstrDesc\", MO, MONum);\n      else if (Register::isPhysicalRegister(MO->getReg())) {\n        const MachineOperand &MOTied = MI->getOperand(TiedTo);\n        if (!MOTied.isReg())\n          report(\"Tied counterpart must be a register\", &MOTied, TiedTo);\n        else if (Register::isPhysicalRegister(MOTied.getReg()) &&\n                 MO->getReg() != MOTied.getReg())\n          report(\"Tied physical registers must match.\", &MOTied, TiedTo);\n      }\n    } else if (MO->isReg() && MO->isTied())\n      report(\"Explicit operand should not be tied\", MO, MONum);\n  } else {\n    // ARM adds %reg0 operands to indicate predicates. We'll allow that.\n    if (MO->isReg() && !MO->isImplicit() && !MI->isVariadic() && MO->getReg())\n      report(\"Extra explicit operand on non-variadic instruction\", MO, MONum);\n  }\n\n  switch (MO->getType()) {\n  case MachineOperand::MO_Register: {\n    const Register Reg = MO->getReg();\n    if (!Reg)\n      return;\n    if (MRI->tracksLiveness() && !MI->isDebugValue())\n      checkLiveness(MO, MONum);\n\n    // Verify the consistency of tied operands.\n    if (MO->isTied()) {\n      unsigned OtherIdx = MI->findTiedOperandIdx(MONum);\n      const MachineOperand &OtherMO = MI->getOperand(OtherIdx);\n      if (!OtherMO.isReg())\n        report(\"Must be tied to a register\", MO, MONum);\n      if (!OtherMO.isTied())\n        report(\"Missing tie flags on tied operand\", MO, MONum);\n      if (MI->findTiedOperandIdx(OtherIdx) != MONum)\n        report(\"Inconsistent tie links\", MO, MONum);\n      if (MONum < MCID.getNumDefs()) {\n        if (OtherIdx < MCID.getNumOperands()) {\n          if (-1 == MCID.getOperandConstraint(OtherIdx, MCOI::TIED_TO))\n            report(\"Explicit def tied to explicit use without tie constraint\",\n                   MO, MONum);\n        } else {\n          if (!OtherMO.isImplicit())\n            report(\"Explicit def should be tied to implicit use\", MO, MONum);\n        }\n      }\n    }\n\n    // Verify two-address constraints after the twoaddressinstruction pass.\n    // Both twoaddressinstruction pass and phi-node-elimination pass call\n    // MRI->leaveSSA() to set MF as NoSSA, we should do the verification after\n    // twoaddressinstruction pass not after phi-node-elimination pass. So we\n    // shouldn't use the NoSSA as the condition, we should based on\n    // TiedOpsRewritten property to verify two-address constraints, this\n    // property will be set in twoaddressinstruction pass.\n    unsigned DefIdx;\n    if (MF->getProperties().hasProperty(\n            MachineFunctionProperties::Property::TiedOpsRewritten) &&\n        MO->isUse() && MI->isRegTiedToDefOperand(MONum, &DefIdx) &&\n        Reg != MI->getOperand(DefIdx).getReg())\n      report(\"Two-address instruction operands must be identical\", MO, MONum);\n\n    // Check register classes.\n    unsigned SubIdx = MO->getSubReg();\n\n    if (Register::isPhysicalRegister(Reg)) {\n      if (SubIdx) {\n        report(\"Illegal subregister index for physical register\", MO, MONum);\n        return;\n      }\n      if (MONum < MCID.getNumOperands()) {\n        if (const TargetRegisterClass *DRC =\n              TII->getRegClass(MCID, MONum, TRI, *MF)) {\n          if (!DRC->contains(Reg)) {\n            report(\"Illegal physical register for instruction\", MO, MONum);\n            errs() << printReg(Reg, TRI) << \" is not a \"\n                   << TRI->getRegClassName(DRC) << \" register.\\n\";\n          }\n        }\n      }\n      if (MO->isRenamable()) {\n        if (MRI->isReserved(Reg)) {\n          report(\"isRenamable set on reserved register\", MO, MONum);\n          return;\n        }\n      }\n      if (MI->isDebugValue() && MO->isUse() && !MO->isDebug()) {\n        report(\"Use-reg is not IsDebug in a DBG_VALUE\", MO, MONum);\n        return;\n      }\n    } else {\n      // Virtual register.\n      const TargetRegisterClass *RC = MRI->getRegClassOrNull(Reg);\n      if (!RC) {\n        // This is a generic virtual register.\n\n        // Do not allow undef uses for generic virtual registers. This ensures\n        // getVRegDef can never fail and return null on a generic register.\n        //\n        // FIXME: This restriction should probably be broadened to all SSA\n        // MIR. However, DetectDeadLanes/ProcessImplicitDefs technically still\n        // run on the SSA function just before phi elimination.\n        if (MO->isUndef())\n          report(\"Generic virtual register use cannot be undef\", MO, MONum);\n\n        // If we're post-Select, we can't have gvregs anymore.\n        if (isFunctionSelected) {\n          report(\"Generic virtual register invalid in a Selected function\",\n                 MO, MONum);\n          return;\n        }\n\n        // The gvreg must have a type and it must not have a SubIdx.\n        LLT Ty = MRI->getType(Reg);\n        if (!Ty.isValid()) {\n          report(\"Generic virtual register must have a valid type\", MO,\n                 MONum);\n          return;\n        }\n\n        const RegisterBank *RegBank = MRI->getRegBankOrNull(Reg);\n\n        // If we're post-RegBankSelect, the gvreg must have a bank.\n        if (!RegBank && isFunctionRegBankSelected) {\n          report(\"Generic virtual register must have a bank in a \"\n                 \"RegBankSelected function\",\n                 MO, MONum);\n          return;\n        }\n\n        // Make sure the register fits into its register bank if any.\n        if (RegBank && Ty.isValid() &&\n            RegBank->getSize() < Ty.getSizeInBits()) {\n          report(\"Register bank is too small for virtual register\", MO,\n                 MONum);\n          errs() << \"Register bank \" << RegBank->getName() << \" too small(\"\n                 << RegBank->getSize() << \") to fit \" << Ty.getSizeInBits()\n                 << \"-bits\\n\";\n          return;\n        }\n        if (SubIdx)  {\n          report(\"Generic virtual register does not allow subregister index\", MO,\n                 MONum);\n          return;\n        }\n\n        // If this is a target specific instruction and this operand\n        // has register class constraint, the virtual register must\n        // comply to it.\n        if (!isPreISelGenericOpcode(MCID.getOpcode()) &&\n            MONum < MCID.getNumOperands() &&\n            TII->getRegClass(MCID, MONum, TRI, *MF)) {\n          report(\"Virtual register does not match instruction constraint\", MO,\n                 MONum);\n          errs() << \"Expect register class \"\n                 << TRI->getRegClassName(\n                        TII->getRegClass(MCID, MONum, TRI, *MF))\n                 << \" but got nothing\\n\";\n          return;\n        }\n\n        break;\n      }\n      if (SubIdx) {\n        const TargetRegisterClass *SRC =\n          TRI->getSubClassWithSubReg(RC, SubIdx);\n        if (!SRC) {\n          report(\"Invalid subregister index for virtual register\", MO, MONum);\n          errs() << \"Register class \" << TRI->getRegClassName(RC)\n              << \" does not support subreg index \" << SubIdx << \"\\n\";\n          return;\n        }\n        if (RC != SRC) {\n          report(\"Invalid register class for subregister index\", MO, MONum);\n          errs() << \"Register class \" << TRI->getRegClassName(RC)\n              << \" does not fully support subreg index \" << SubIdx << \"\\n\";\n          return;\n        }\n      }\n      if (MONum < MCID.getNumOperands()) {\n        if (const TargetRegisterClass *DRC =\n              TII->getRegClass(MCID, MONum, TRI, *MF)) {\n          if (SubIdx) {\n            const TargetRegisterClass *SuperRC =\n                TRI->getLargestLegalSuperClass(RC, *MF);\n            if (!SuperRC) {\n              report(\"No largest legal super class exists.\", MO, MONum);\n              return;\n            }\n            DRC = TRI->getMatchingSuperRegClass(SuperRC, DRC, SubIdx);\n            if (!DRC) {\n              report(\"No matching super-reg register class.\", MO, MONum);\n              return;\n            }\n          }\n          if (!RC->hasSuperClassEq(DRC)) {\n            report(\"Illegal virtual register for instruction\", MO, MONum);\n            errs() << \"Expected a \" << TRI->getRegClassName(DRC)\n                << \" register, but got a \" << TRI->getRegClassName(RC)\n                << \" register\\n\";\n          }\n        }\n      }\n    }\n    break;\n  }\n\n  case MachineOperand::MO_RegisterMask:\n    regMasks.push_back(MO->getRegMask());\n    break;\n\n  case MachineOperand::MO_MachineBasicBlock:\n    if (MI->isPHI() && !MO->getMBB()->isSuccessor(MI->getParent()))\n      report(\"PHI operand is not in the CFG\", MO, MONum);\n    break;\n\n  case MachineOperand::MO_FrameIndex:\n    if (LiveStks && LiveStks->hasInterval(MO->getIndex()) &&\n        LiveInts && !LiveInts->isNotInMIMap(*MI)) {\n      int FI = MO->getIndex();\n      LiveInterval &LI = LiveStks->getInterval(FI);\n      SlotIndex Idx = LiveInts->getInstructionIndex(*MI);\n\n      bool stores = MI->mayStore();\n      bool loads = MI->mayLoad();\n      // For a memory-to-memory move, we need to check if the frame\n      // index is used for storing or loading, by inspecting the\n      // memory operands.\n      if (stores && loads) {\n        for (auto *MMO : MI->memoperands()) {\n          const PseudoSourceValue *PSV = MMO->getPseudoValue();\n          if (PSV == nullptr) continue;\n          const FixedStackPseudoSourceValue *Value =\n            dyn_cast<FixedStackPseudoSourceValue>(PSV);\n          if (Value == nullptr) continue;\n          if (Value->getFrameIndex() != FI) continue;\n\n          if (MMO->isStore())\n            loads = false;\n          else\n            stores = false;\n          break;\n        }\n        if (loads == stores)\n          report(\"Missing fixed stack memoperand.\", MI);\n      }\n      if (loads && !LI.liveAt(Idx.getRegSlot(true))) {\n        report(\"Instruction loads from dead spill slot\", MO, MONum);\n        errs() << \"Live stack: \" << LI << '\\n';\n      }\n      if (stores && !LI.liveAt(Idx.getRegSlot())) {\n        report(\"Instruction stores to dead spill slot\", MO, MONum);\n        errs() << \"Live stack: \" << LI << '\\n';\n      }\n    }\n    break;\n\n  default:\n    break;\n  }\n}\n\nvoid MachineVerifier::checkLivenessAtUse(const MachineOperand *MO,\n                                         unsigned MONum, SlotIndex UseIdx,\n                                         const LiveRange &LR,\n                                         Register VRegOrUnit,\n                                         LaneBitmask LaneMask) {\n  LiveQueryResult LRQ = LR.Query(UseIdx);\n  // Check if we have a segment at the use, note however that we only need one\n  // live subregister range, the others may be dead.\n  if (!LRQ.valueIn() && LaneMask.none()) {\n    report(\"No live segment at use\", MO, MONum);\n    report_context_liverange(LR);\n    report_context_vreg_regunit(VRegOrUnit);\n    report_context(UseIdx);\n  }\n  if (MO->isKill() && !LRQ.isKill()) {\n    report(\"Live range continues after kill flag\", MO, MONum);\n    report_context_liverange(LR);\n    report_context_vreg_regunit(VRegOrUnit);\n    if (LaneMask.any())\n      report_context_lanemask(LaneMask);\n    report_context(UseIdx);\n  }\n}\n\nvoid MachineVerifier::checkLivenessAtDef(const MachineOperand *MO,\n                                         unsigned MONum, SlotIndex DefIdx,\n                                         const LiveRange &LR,\n                                         Register VRegOrUnit,\n                                         bool SubRangeCheck,\n                                         LaneBitmask LaneMask) {\n  if (const VNInfo *VNI = LR.getVNInfoAt(DefIdx)) {\n    assert(VNI && \"NULL valno is not allowed\");\n    if (VNI->def != DefIdx) {\n      report(\"Inconsistent valno->def\", MO, MONum);\n      report_context_liverange(LR);\n      report_context_vreg_regunit(VRegOrUnit);\n      if (LaneMask.any())\n        report_context_lanemask(LaneMask);\n      report_context(*VNI);\n      report_context(DefIdx);\n    }\n  } else {\n    report(\"No live segment at def\", MO, MONum);\n    report_context_liverange(LR);\n    report_context_vreg_regunit(VRegOrUnit);\n    if (LaneMask.any())\n      report_context_lanemask(LaneMask);\n    report_context(DefIdx);\n  }\n  // Check that, if the dead def flag is present, LiveInts agree.\n  if (MO->isDead()) {\n    LiveQueryResult LRQ = LR.Query(DefIdx);\n    if (!LRQ.isDeadDef()) {\n      assert(Register::isVirtualRegister(VRegOrUnit) &&\n             \"Expecting a virtual register.\");\n      // A dead subreg def only tells us that the specific subreg is dead. There\n      // could be other non-dead defs of other subregs, or we could have other\n      // parts of the register being live through the instruction. So unless we\n      // are checking liveness for a subrange it is ok for the live range to\n      // continue, given that we have a dead def of a subregister.\n      if (SubRangeCheck || MO->getSubReg() == 0) {\n        report(\"Live range continues after dead def flag\", MO, MONum);\n        report_context_liverange(LR);\n        report_context_vreg_regunit(VRegOrUnit);\n        if (LaneMask.any())\n          report_context_lanemask(LaneMask);\n      }\n    }\n  }\n}\n\nvoid MachineVerifier::checkLiveness(const MachineOperand *MO, unsigned MONum) {\n  const MachineInstr *MI = MO->getParent();\n  const Register Reg = MO->getReg();\n\n  // Both use and def operands can read a register.\n  if (MO->readsReg()) {\n    if (MO->isKill())\n      addRegWithSubRegs(regsKilled, Reg);\n\n    // Check that LiveVars knows this kill.\n    if (LiveVars && Register::isVirtualRegister(Reg) && MO->isKill()) {\n      LiveVariables::VarInfo &VI = LiveVars->getVarInfo(Reg);\n      if (!is_contained(VI.Kills, MI))\n        report(\"Kill missing from LiveVariables\", MO, MONum);\n    }\n\n    // Check LiveInts liveness and kill.\n    if (LiveInts && !LiveInts->isNotInMIMap(*MI)) {\n      SlotIndex UseIdx = LiveInts->getInstructionIndex(*MI);\n      // Check the cached regunit intervals.\n      if (Reg.isPhysical() && !isReserved(Reg)) {\n        for (MCRegUnitIterator Units(Reg.asMCReg(), TRI); Units.isValid();\n             ++Units) {\n          if (MRI->isReservedRegUnit(*Units))\n            continue;\n          if (const LiveRange *LR = LiveInts->getCachedRegUnit(*Units))\n            checkLivenessAtUse(MO, MONum, UseIdx, *LR, *Units);\n        }\n      }\n\n      if (Register::isVirtualRegister(Reg)) {\n        if (LiveInts->hasInterval(Reg)) {\n          // This is a virtual register interval.\n          const LiveInterval &LI = LiveInts->getInterval(Reg);\n          checkLivenessAtUse(MO, MONum, UseIdx, LI, Reg);\n\n          if (LI.hasSubRanges() && !MO->isDef()) {\n            unsigned SubRegIdx = MO->getSubReg();\n            LaneBitmask MOMask = SubRegIdx != 0\n                               ? TRI->getSubRegIndexLaneMask(SubRegIdx)\n                               : MRI->getMaxLaneMaskForVReg(Reg);\n            LaneBitmask LiveInMask;\n            for (const LiveInterval::SubRange &SR : LI.subranges()) {\n              if ((MOMask & SR.LaneMask).none())\n                continue;\n              checkLivenessAtUse(MO, MONum, UseIdx, SR, Reg, SR.LaneMask);\n              LiveQueryResult LRQ = SR.Query(UseIdx);\n              if (LRQ.valueIn())\n                LiveInMask |= SR.LaneMask;\n            }\n            // At least parts of the register has to be live at the use.\n            if ((LiveInMask & MOMask).none()) {\n              report(\"No live subrange at use\", MO, MONum);\n              report_context(LI);\n              report_context(UseIdx);\n            }\n          }\n        } else {\n          report(\"Virtual register has no live interval\", MO, MONum);\n        }\n      }\n    }\n\n    // Use of a dead register.\n    if (!regsLive.count(Reg)) {\n      if (Register::isPhysicalRegister(Reg)) {\n        // Reserved registers may be used even when 'dead'.\n        bool Bad = !isReserved(Reg);\n        // We are fine if just any subregister has a defined value.\n        if (Bad) {\n\n          for (const MCPhysReg &SubReg : TRI->subregs(Reg)) {\n            if (regsLive.count(SubReg)) {\n              Bad = false;\n              break;\n            }\n          }\n        }\n        // If there is an additional implicit-use of a super register we stop\n        // here. By definition we are fine if the super register is not\n        // (completely) dead, if the complete super register is dead we will\n        // get a report for its operand.\n        if (Bad) {\n          for (const MachineOperand &MOP : MI->uses()) {\n            if (!MOP.isReg() || !MOP.isImplicit())\n              continue;\n\n            if (!Register::isPhysicalRegister(MOP.getReg()))\n              continue;\n\n            if (llvm::is_contained(TRI->subregs(MOP.getReg()), Reg))\n              Bad = false;\n          }\n        }\n        if (Bad)\n          report(\"Using an undefined physical register\", MO, MONum);\n      } else if (MRI->def_empty(Reg)) {\n        report(\"Reading virtual register without a def\", MO, MONum);\n      } else {\n        BBInfo &MInfo = MBBInfoMap[MI->getParent()];\n        // We don't know which virtual registers are live in, so only complain\n        // if vreg was killed in this MBB. Otherwise keep track of vregs that\n        // must be live in. PHI instructions are handled separately.\n        if (MInfo.regsKilled.count(Reg))\n          report(\"Using a killed virtual register\", MO, MONum);\n        else if (!MI->isPHI())\n          MInfo.vregsLiveIn.insert(std::make_pair(Reg, MI));\n      }\n    }\n  }\n\n  if (MO->isDef()) {\n    // Register defined.\n    // TODO: verify that earlyclobber ops are not used.\n    if (MO->isDead())\n      addRegWithSubRegs(regsDead, Reg);\n    else\n      addRegWithSubRegs(regsDefined, Reg);\n\n    // Verify SSA form.\n    if (MRI->isSSA() && Register::isVirtualRegister(Reg) &&\n        std::next(MRI->def_begin(Reg)) != MRI->def_end())\n      report(\"Multiple virtual register defs in SSA form\", MO, MONum);\n\n    // Check LiveInts for a live segment, but only for virtual registers.\n    if (LiveInts && !LiveInts->isNotInMIMap(*MI)) {\n      SlotIndex DefIdx = LiveInts->getInstructionIndex(*MI);\n      DefIdx = DefIdx.getRegSlot(MO->isEarlyClobber());\n\n      if (Register::isVirtualRegister(Reg)) {\n        if (LiveInts->hasInterval(Reg)) {\n          const LiveInterval &LI = LiveInts->getInterval(Reg);\n          checkLivenessAtDef(MO, MONum, DefIdx, LI, Reg);\n\n          if (LI.hasSubRanges()) {\n            unsigned SubRegIdx = MO->getSubReg();\n            LaneBitmask MOMask = SubRegIdx != 0\n              ? TRI->getSubRegIndexLaneMask(SubRegIdx)\n              : MRI->getMaxLaneMaskForVReg(Reg);\n            for (const LiveInterval::SubRange &SR : LI.subranges()) {\n              if ((SR.LaneMask & MOMask).none())\n                continue;\n              checkLivenessAtDef(MO, MONum, DefIdx, SR, Reg, true, SR.LaneMask);\n            }\n          }\n        } else {\n          report(\"Virtual register has no Live interval\", MO, MONum);\n        }\n      }\n    }\n  }\n}\n\n// This function gets called after visiting all instructions in a bundle. The\n// argument points to the bundle header.\n// Normal stand-alone instructions are also considered 'bundles', and this\n// function is called for all of them.\nvoid MachineVerifier::visitMachineBundleAfter(const MachineInstr *MI) {\n  BBInfo &MInfo = MBBInfoMap[MI->getParent()];\n  set_union(MInfo.regsKilled, regsKilled);\n  set_subtract(regsLive, regsKilled); regsKilled.clear();\n  // Kill any masked registers.\n  while (!regMasks.empty()) {\n    const uint32_t *Mask = regMasks.pop_back_val();\n    for (Register Reg : regsLive)\n      if (Reg.isPhysical() &&\n          MachineOperand::clobbersPhysReg(Mask, Reg.asMCReg()))\n        regsDead.push_back(Reg);\n  }\n  set_subtract(regsLive, regsDead);   regsDead.clear();\n  set_union(regsLive, regsDefined);   regsDefined.clear();\n}\n\nvoid\nMachineVerifier::visitMachineBasicBlockAfter(const MachineBasicBlock *MBB) {\n  MBBInfoMap[MBB].regsLiveOut = regsLive;\n  regsLive.clear();\n\n  if (Indexes) {\n    SlotIndex stop = Indexes->getMBBEndIdx(MBB);\n    if (!(stop > lastIndex)) {\n      report(\"Block ends before last instruction index\", MBB);\n      errs() << \"Block ends at \" << stop\n          << \" last instruction was at \" << lastIndex << '\\n';\n    }\n    lastIndex = stop;\n  }\n}\n\nnamespace {\n// This implements a set of registers that serves as a filter: can filter other\n// sets by passing through elements not in the filter and blocking those that\n// are. Any filter implicitly includes the full set of physical registers upon\n// creation, thus filtering them all out. The filter itself as a set only grows,\n// and needs to be as efficient as possible.\nstruct VRegFilter {\n  // Add elements to the filter itself. \\pre Input set \\p FromRegSet must have\n  // no duplicates. Both virtual and physical registers are fine.\n  template <typename RegSetT> void add(const RegSetT &FromRegSet) {\n    SmallVector<Register, 0> VRegsBuffer;\n    filterAndAdd(FromRegSet, VRegsBuffer);\n  }\n  // Filter \\p FromRegSet through the filter and append passed elements into \\p\n  // ToVRegs. All elements appended are then added to the filter itself.\n  // \\returns true if anything changed.\n  template <typename RegSetT>\n  bool filterAndAdd(const RegSetT &FromRegSet,\n                    SmallVectorImpl<Register> &ToVRegs) {\n    unsigned SparseUniverse = Sparse.size();\n    unsigned NewSparseUniverse = SparseUniverse;\n    unsigned NewDenseSize = Dense.size();\n    size_t Begin = ToVRegs.size();\n    for (Register Reg : FromRegSet) {\n      if (!Reg.isVirtual())\n        continue;\n      unsigned Index = Register::virtReg2Index(Reg);\n      if (Index < SparseUniverseMax) {\n        if (Index < SparseUniverse && Sparse.test(Index))\n          continue;\n        NewSparseUniverse = std::max(NewSparseUniverse, Index + 1);\n      } else {\n        if (Dense.count(Reg))\n          continue;\n        ++NewDenseSize;\n      }\n      ToVRegs.push_back(Reg);\n    }\n    size_t End = ToVRegs.size();\n    if (Begin == End)\n      return false;\n    // Reserving space in sets once performs better than doing so continuously\n    // and pays easily for double look-ups (even in Dense with SparseUniverseMax\n    // tuned all the way down) and double iteration (the second one is over a\n    // SmallVector, which is a lot cheaper compared to DenseSet or BitVector).\n    Sparse.resize(NewSparseUniverse);\n    Dense.reserve(NewDenseSize);\n    for (unsigned I = Begin; I < End; ++I) {\n      Register Reg = ToVRegs[I];\n      unsigned Index = Register::virtReg2Index(Reg);\n      if (Index < SparseUniverseMax)\n        Sparse.set(Index);\n      else\n        Dense.insert(Reg);\n    }\n    return true;\n  }\n\nprivate:\n  static constexpr unsigned SparseUniverseMax = 10 * 1024 * 8;\n  // VRegs indexed within SparseUniverseMax are tracked by Sparse, those beyound\n  // are tracked by Dense. The only purpose of the threashold and the Dense set\n  // is to have a reasonably growing memory usage in pathological cases (large\n  // number of very sparse VRegFilter instances live at the same time). In\n  // practice even in the worst-by-execution time cases having all elements\n  // tracked by Sparse (very large SparseUniverseMax scenario) tends to be more\n  // space efficient than if tracked by Dense. The threashold is set to keep the\n  // worst-case memory usage within 2x of figures determined empirically for\n  // \"all Dense\" scenario in such worst-by-execution-time cases.\n  BitVector Sparse;\n  DenseSet<unsigned> Dense;\n};\n\n// Implements both a transfer function and a (binary, in-place) join operator\n// for a dataflow over register sets with set union join and filtering transfer\n// (out_b = in_b \\ filter_b). filter_b is expected to be set-up ahead of time.\n// Maintains out_b as its state, allowing for O(n) iteration over it at any\n// time, where n is the size of the set (as opposed to O(U) where U is the\n// universe). filter_b implicitly contains all physical registers at all times.\nclass FilteringVRegSet {\n  VRegFilter Filter;\n  SmallVector<Register, 0> VRegs;\n\npublic:\n  // Set-up the filter_b. \\pre Input register set \\p RS must have no duplicates.\n  // Both virtual and physical registers are fine.\n  template <typename RegSetT> void addToFilter(const RegSetT &RS) {\n    Filter.add(RS);\n  }\n  // Passes \\p RS through the filter_b (transfer function) and adds what's left\n  // to itself (out_b).\n  template <typename RegSetT> bool add(const RegSetT &RS) {\n    // Double-duty the Filter: to maintain VRegs a set (and the join operation\n    // a set union) just add everything being added here to the Filter as well.\n    return Filter.filterAndAdd(RS, VRegs);\n  }\n  using const_iterator = decltype(VRegs)::const_iterator;\n  const_iterator begin() const { return VRegs.begin(); }\n  const_iterator end() const { return VRegs.end(); }\n  size_t size() const { return VRegs.size(); }\n};\n} // namespace\n\n// Calculate the largest possible vregsPassed sets. These are the registers that\n// can pass through an MBB live, but may not be live every time. It is assumed\n// that all vregsPassed sets are empty before the call.\nvoid MachineVerifier::calcRegsPassed() {\n  if (MF->empty())\n    // ReversePostOrderTraversal doesn't handle empty functions.\n    return;\n\n  for (const MachineBasicBlock *MB :\n       ReversePostOrderTraversal<const MachineFunction *>(MF)) {\n    FilteringVRegSet VRegs;\n    BBInfo &Info = MBBInfoMap[MB];\n    assert(Info.reachable);\n\n    VRegs.addToFilter(Info.regsKilled);\n    VRegs.addToFilter(Info.regsLiveOut);\n    for (const MachineBasicBlock *Pred : MB->predecessors()) {\n      const BBInfo &PredInfo = MBBInfoMap[Pred];\n      if (!PredInfo.reachable)\n        continue;\n\n      VRegs.add(PredInfo.regsLiveOut);\n      VRegs.add(PredInfo.vregsPassed);\n    }\n    Info.vregsPassed.reserve(VRegs.size());\n    Info.vregsPassed.insert(VRegs.begin(), VRegs.end());\n  }\n}\n\n// Calculate the set of virtual registers that must be passed through each basic\n// block in order to satisfy the requirements of successor blocks. This is very\n// similar to calcRegsPassed, only backwards.\nvoid MachineVerifier::calcRegsRequired() {\n  // First push live-in regs to predecessors' vregsRequired.\n  SmallPtrSet<const MachineBasicBlock*, 8> todo;\n  for (const auto &MBB : *MF) {\n    BBInfo &MInfo = MBBInfoMap[&MBB];\n    for (const MachineBasicBlock *Pred : MBB.predecessors()) {\n      BBInfo &PInfo = MBBInfoMap[Pred];\n      if (PInfo.addRequired(MInfo.vregsLiveIn))\n        todo.insert(Pred);\n    }\n\n    // Handle the PHI node.\n    for (const MachineInstr &MI : MBB.phis()) {\n      for (unsigned i = 1, e = MI.getNumOperands(); i != e; i += 2) {\n        // Skip those Operands which are undef regs or not regs.\n        if (!MI.getOperand(i).isReg() || !MI.getOperand(i).readsReg())\n          continue;\n\n        // Get register and predecessor for one PHI edge.\n        Register Reg = MI.getOperand(i).getReg();\n        const MachineBasicBlock *Pred = MI.getOperand(i + 1).getMBB();\n\n        BBInfo &PInfo = MBBInfoMap[Pred];\n        if (PInfo.addRequired(Reg))\n          todo.insert(Pred);\n      }\n    }\n  }\n\n  // Iteratively push vregsRequired to predecessors. This will converge to the\n  // same final state regardless of DenseSet iteration order.\n  while (!todo.empty()) {\n    const MachineBasicBlock *MBB = *todo.begin();\n    todo.erase(MBB);\n    BBInfo &MInfo = MBBInfoMap[MBB];\n    for (const MachineBasicBlock *Pred : MBB->predecessors()) {\n      if (Pred == MBB)\n        continue;\n      BBInfo &SInfo = MBBInfoMap[Pred];\n      if (SInfo.addRequired(MInfo.vregsRequired))\n        todo.insert(Pred);\n    }\n  }\n}\n\n// Check PHI instructions at the beginning of MBB. It is assumed that\n// calcRegsPassed has been run so BBInfo::isLiveOut is valid.\nvoid MachineVerifier::checkPHIOps(const MachineBasicBlock &MBB) {\n  BBInfo &MInfo = MBBInfoMap[&MBB];\n\n  SmallPtrSet<const MachineBasicBlock*, 8> seen;\n  for (const MachineInstr &Phi : MBB) {\n    if (!Phi.isPHI())\n      break;\n    seen.clear();\n\n    const MachineOperand &MODef = Phi.getOperand(0);\n    if (!MODef.isReg() || !MODef.isDef()) {\n      report(\"Expected first PHI operand to be a register def\", &MODef, 0);\n      continue;\n    }\n    if (MODef.isTied() || MODef.isImplicit() || MODef.isInternalRead() ||\n        MODef.isEarlyClobber() || MODef.isDebug())\n      report(\"Unexpected flag on PHI operand\", &MODef, 0);\n    Register DefReg = MODef.getReg();\n    if (!Register::isVirtualRegister(DefReg))\n      report(\"Expected first PHI operand to be a virtual register\", &MODef, 0);\n\n    for (unsigned I = 1, E = Phi.getNumOperands(); I != E; I += 2) {\n      const MachineOperand &MO0 = Phi.getOperand(I);\n      if (!MO0.isReg()) {\n        report(\"Expected PHI operand to be a register\", &MO0, I);\n        continue;\n      }\n      if (MO0.isImplicit() || MO0.isInternalRead() || MO0.isEarlyClobber() ||\n          MO0.isDebug() || MO0.isTied())\n        report(\"Unexpected flag on PHI operand\", &MO0, I);\n\n      const MachineOperand &MO1 = Phi.getOperand(I + 1);\n      if (!MO1.isMBB()) {\n        report(\"Expected PHI operand to be a basic block\", &MO1, I + 1);\n        continue;\n      }\n\n      const MachineBasicBlock &Pre = *MO1.getMBB();\n      if (!Pre.isSuccessor(&MBB)) {\n        report(\"PHI input is not a predecessor block\", &MO1, I + 1);\n        continue;\n      }\n\n      if (MInfo.reachable) {\n        seen.insert(&Pre);\n        BBInfo &PrInfo = MBBInfoMap[&Pre];\n        if (!MO0.isUndef() && PrInfo.reachable &&\n            !PrInfo.isLiveOut(MO0.getReg()))\n          report(\"PHI operand is not live-out from predecessor\", &MO0, I);\n      }\n    }\n\n    // Did we see all predecessors?\n    if (MInfo.reachable) {\n      for (MachineBasicBlock *Pred : MBB.predecessors()) {\n        if (!seen.count(Pred)) {\n          report(\"Missing PHI operand\", &Phi);\n          errs() << printMBBReference(*Pred)\n                 << \" is a predecessor according to the CFG.\\n\";\n        }\n      }\n    }\n  }\n}\n\nvoid MachineVerifier::visitMachineFunctionAfter() {\n  calcRegsPassed();\n\n  for (const MachineBasicBlock &MBB : *MF)\n    checkPHIOps(MBB);\n\n  // Now check liveness info if available\n  calcRegsRequired();\n\n  // Check for killed virtual registers that should be live out.\n  for (const auto &MBB : *MF) {\n    BBInfo &MInfo = MBBInfoMap[&MBB];\n    for (Register VReg : MInfo.vregsRequired)\n      if (MInfo.regsKilled.count(VReg)) {\n        report(\"Virtual register killed in block, but needed live out.\", &MBB);\n        errs() << \"Virtual register \" << printReg(VReg)\n               << \" is used after the block.\\n\";\n      }\n  }\n\n  if (!MF->empty()) {\n    BBInfo &MInfo = MBBInfoMap[&MF->front()];\n    for (Register VReg : MInfo.vregsRequired) {\n      report(\"Virtual register defs don't dominate all uses.\", MF);\n      report_context_vreg(VReg);\n    }\n  }\n\n  if (LiveVars)\n    verifyLiveVariables();\n  if (LiveInts)\n    verifyLiveIntervals();\n\n  // Check live-in list of each MBB. If a register is live into MBB, check\n  // that the register is in regsLiveOut of each predecessor block. Since\n  // this must come from a definition in the predecesssor or its live-in\n  // list, this will catch a live-through case where the predecessor does not\n  // have the register in its live-in list.  This currently only checks\n  // registers that have no aliases, are not allocatable and are not\n  // reserved, which could mean a condition code register for instance.\n  if (MRI->tracksLiveness())\n    for (const auto &MBB : *MF)\n      for (MachineBasicBlock::RegisterMaskPair P : MBB.liveins()) {\n        MCPhysReg LiveInReg = P.PhysReg;\n        bool hasAliases = MCRegAliasIterator(LiveInReg, TRI, false).isValid();\n        if (hasAliases || isAllocatable(LiveInReg) || isReserved(LiveInReg))\n          continue;\n        for (const MachineBasicBlock *Pred : MBB.predecessors()) {\n          BBInfo &PInfo = MBBInfoMap[Pred];\n          if (!PInfo.regsLiveOut.count(LiveInReg)) {\n            report(\"Live in register not found to be live out from predecessor.\",\n                   &MBB);\n            errs() << TRI->getName(LiveInReg)\n                   << \" not found to be live out from \"\n                   << printMBBReference(*Pred) << \"\\n\";\n          }\n        }\n      }\n\n  for (auto CSInfo : MF->getCallSitesInfo())\n    if (!CSInfo.first->isCall())\n      report(\"Call site info referencing instruction that is not call\", MF);\n\n  // If there's debug-info, check that we don't have any duplicate value\n  // tracking numbers.\n  if (MF->getFunction().getSubprogram()) {\n    DenseSet<unsigned> SeenNumbers;\n    for (auto &MBB : *MF) {\n      for (auto &MI : MBB) {\n        if (auto Num = MI.peekDebugInstrNum()) {\n          auto Result = SeenNumbers.insert((unsigned)Num);\n          if (!Result.second)\n            report(\"Instruction has a duplicated value tracking number\", &MI);\n        }\n      }\n    }\n  }\n}\n\nvoid MachineVerifier::verifyLiveVariables() {\n  assert(LiveVars && \"Don't call verifyLiveVariables without LiveVars\");\n  for (unsigned I = 0, E = MRI->getNumVirtRegs(); I != E; ++I) {\n    Register Reg = Register::index2VirtReg(I);\n    LiveVariables::VarInfo &VI = LiveVars->getVarInfo(Reg);\n    for (const auto &MBB : *MF) {\n      BBInfo &MInfo = MBBInfoMap[&MBB];\n\n      // Our vregsRequired should be identical to LiveVariables' AliveBlocks\n      if (MInfo.vregsRequired.count(Reg)) {\n        if (!VI.AliveBlocks.test(MBB.getNumber())) {\n          report(\"LiveVariables: Block missing from AliveBlocks\", &MBB);\n          errs() << \"Virtual register \" << printReg(Reg)\n                 << \" must be live through the block.\\n\";\n        }\n      } else {\n        if (VI.AliveBlocks.test(MBB.getNumber())) {\n          report(\"LiveVariables: Block should not be in AliveBlocks\", &MBB);\n          errs() << \"Virtual register \" << printReg(Reg)\n                 << \" is not needed live through the block.\\n\";\n        }\n      }\n    }\n  }\n}\n\nvoid MachineVerifier::verifyLiveIntervals() {\n  assert(LiveInts && \"Don't call verifyLiveIntervals without LiveInts\");\n  for (unsigned I = 0, E = MRI->getNumVirtRegs(); I != E; ++I) {\n    Register Reg = Register::index2VirtReg(I);\n\n    // Spilling and splitting may leave unused registers around. Skip them.\n    if (MRI->reg_nodbg_empty(Reg))\n      continue;\n\n    if (!LiveInts->hasInterval(Reg)) {\n      report(\"Missing live interval for virtual register\", MF);\n      errs() << printReg(Reg, TRI) << \" still has defs or uses\\n\";\n      continue;\n    }\n\n    const LiveInterval &LI = LiveInts->getInterval(Reg);\n    assert(Reg == LI.reg() && \"Invalid reg to interval mapping\");\n    verifyLiveInterval(LI);\n  }\n\n  // Verify all the cached regunit intervals.\n  for (unsigned i = 0, e = TRI->getNumRegUnits(); i != e; ++i)\n    if (const LiveRange *LR = LiveInts->getCachedRegUnit(i))\n      verifyLiveRange(*LR, i);\n}\n\nvoid MachineVerifier::verifyLiveRangeValue(const LiveRange &LR,\n                                           const VNInfo *VNI, Register Reg,\n                                           LaneBitmask LaneMask) {\n  if (VNI->isUnused())\n    return;\n\n  const VNInfo *DefVNI = LR.getVNInfoAt(VNI->def);\n\n  if (!DefVNI) {\n    report(\"Value not live at VNInfo def and not marked unused\", MF);\n    report_context(LR, Reg, LaneMask);\n    report_context(*VNI);\n    return;\n  }\n\n  if (DefVNI != VNI) {\n    report(\"Live segment at def has different VNInfo\", MF);\n    report_context(LR, Reg, LaneMask);\n    report_context(*VNI);\n    return;\n  }\n\n  const MachineBasicBlock *MBB = LiveInts->getMBBFromIndex(VNI->def);\n  if (!MBB) {\n    report(\"Invalid VNInfo definition index\", MF);\n    report_context(LR, Reg, LaneMask);\n    report_context(*VNI);\n    return;\n  }\n\n  if (VNI->isPHIDef()) {\n    if (VNI->def != LiveInts->getMBBStartIdx(MBB)) {\n      report(\"PHIDef VNInfo is not defined at MBB start\", MBB);\n      report_context(LR, Reg, LaneMask);\n      report_context(*VNI);\n    }\n    return;\n  }\n\n  // Non-PHI def.\n  const MachineInstr *MI = LiveInts->getInstructionFromIndex(VNI->def);\n  if (!MI) {\n    report(\"No instruction at VNInfo def index\", MBB);\n    report_context(LR, Reg, LaneMask);\n    report_context(*VNI);\n    return;\n  }\n\n  if (Reg != 0) {\n    bool hasDef = false;\n    bool isEarlyClobber = false;\n    for (ConstMIBundleOperands MOI(*MI); MOI.isValid(); ++MOI) {\n      if (!MOI->isReg() || !MOI->isDef())\n        continue;\n      if (Register::isVirtualRegister(Reg)) {\n        if (MOI->getReg() != Reg)\n          continue;\n      } else {\n        if (!Register::isPhysicalRegister(MOI->getReg()) ||\n            !TRI->hasRegUnit(MOI->getReg(), Reg))\n          continue;\n      }\n      if (LaneMask.any() &&\n          (TRI->getSubRegIndexLaneMask(MOI->getSubReg()) & LaneMask).none())\n        continue;\n      hasDef = true;\n      if (MOI->isEarlyClobber())\n        isEarlyClobber = true;\n    }\n\n    if (!hasDef) {\n      report(\"Defining instruction does not modify register\", MI);\n      report_context(LR, Reg, LaneMask);\n      report_context(*VNI);\n    }\n\n    // Early clobber defs begin at USE slots, but other defs must begin at\n    // DEF slots.\n    if (isEarlyClobber) {\n      if (!VNI->def.isEarlyClobber()) {\n        report(\"Early clobber def must be at an early-clobber slot\", MBB);\n        report_context(LR, Reg, LaneMask);\n        report_context(*VNI);\n      }\n    } else if (!VNI->def.isRegister()) {\n      report(\"Non-PHI, non-early clobber def must be at a register slot\", MBB);\n      report_context(LR, Reg, LaneMask);\n      report_context(*VNI);\n    }\n  }\n}\n\nvoid MachineVerifier::verifyLiveRangeSegment(const LiveRange &LR,\n                                             const LiveRange::const_iterator I,\n                                             Register Reg,\n                                             LaneBitmask LaneMask) {\n  const LiveRange::Segment &S = *I;\n  const VNInfo *VNI = S.valno;\n  assert(VNI && \"Live segment has no valno\");\n\n  if (VNI->id >= LR.getNumValNums() || VNI != LR.getValNumInfo(VNI->id)) {\n    report(\"Foreign valno in live segment\", MF);\n    report_context(LR, Reg, LaneMask);\n    report_context(S);\n    report_context(*VNI);\n  }\n\n  if (VNI->isUnused()) {\n    report(\"Live segment valno is marked unused\", MF);\n    report_context(LR, Reg, LaneMask);\n    report_context(S);\n  }\n\n  const MachineBasicBlock *MBB = LiveInts->getMBBFromIndex(S.start);\n  if (!MBB) {\n    report(\"Bad start of live segment, no basic block\", MF);\n    report_context(LR, Reg, LaneMask);\n    report_context(S);\n    return;\n  }\n  SlotIndex MBBStartIdx = LiveInts->getMBBStartIdx(MBB);\n  if (S.start != MBBStartIdx && S.start != VNI->def) {\n    report(\"Live segment must begin at MBB entry or valno def\", MBB);\n    report_context(LR, Reg, LaneMask);\n    report_context(S);\n  }\n\n  const MachineBasicBlock *EndMBB =\n    LiveInts->getMBBFromIndex(S.end.getPrevSlot());\n  if (!EndMBB) {\n    report(\"Bad end of live segment, no basic block\", MF);\n    report_context(LR, Reg, LaneMask);\n    report_context(S);\n    return;\n  }\n\n  // No more checks for live-out segments.\n  if (S.end == LiveInts->getMBBEndIdx(EndMBB))\n    return;\n\n  // RegUnit intervals are allowed dead phis.\n  if (!Register::isVirtualRegister(Reg) && VNI->isPHIDef() &&\n      S.start == VNI->def && S.end == VNI->def.getDeadSlot())\n    return;\n\n  // The live segment is ending inside EndMBB\n  const MachineInstr *MI =\n    LiveInts->getInstructionFromIndex(S.end.getPrevSlot());\n  if (!MI) {\n    report(\"Live segment doesn't end at a valid instruction\", EndMBB);\n    report_context(LR, Reg, LaneMask);\n    report_context(S);\n    return;\n  }\n\n  // The block slot must refer to a basic block boundary.\n  if (S.end.isBlock()) {\n    report(\"Live segment ends at B slot of an instruction\", EndMBB);\n    report_context(LR, Reg, LaneMask);\n    report_context(S);\n  }\n\n  if (S.end.isDead()) {\n    // Segment ends on the dead slot.\n    // That means there must be a dead def.\n    if (!SlotIndex::isSameInstr(S.start, S.end)) {\n      report(\"Live segment ending at dead slot spans instructions\", EndMBB);\n      report_context(LR, Reg, LaneMask);\n      report_context(S);\n    }\n  }\n\n  // A live segment can only end at an early-clobber slot if it is being\n  // redefined by an early-clobber def.\n  if (S.end.isEarlyClobber()) {\n    if (I+1 == LR.end() || (I+1)->start != S.end) {\n      report(\"Live segment ending at early clobber slot must be \"\n             \"redefined by an EC def in the same instruction\", EndMBB);\n      report_context(LR, Reg, LaneMask);\n      report_context(S);\n    }\n  }\n\n  // The following checks only apply to virtual registers. Physreg liveness\n  // is too weird to check.\n  if (Register::isVirtualRegister(Reg)) {\n    // A live segment can end with either a redefinition, a kill flag on a\n    // use, or a dead flag on a def.\n    bool hasRead = false;\n    bool hasSubRegDef = false;\n    bool hasDeadDef = false;\n    for (ConstMIBundleOperands MOI(*MI); MOI.isValid(); ++MOI) {\n      if (!MOI->isReg() || MOI->getReg() != Reg)\n        continue;\n      unsigned Sub = MOI->getSubReg();\n      LaneBitmask SLM = Sub != 0 ? TRI->getSubRegIndexLaneMask(Sub)\n                                 : LaneBitmask::getAll();\n      if (MOI->isDef()) {\n        if (Sub != 0) {\n          hasSubRegDef = true;\n          // An operand %0:sub0 reads %0:sub1..n. Invert the lane\n          // mask for subregister defs. Read-undef defs will be handled by\n          // readsReg below.\n          SLM = ~SLM;\n        }\n        if (MOI->isDead())\n          hasDeadDef = true;\n      }\n      if (LaneMask.any() && (LaneMask & SLM).none())\n        continue;\n      if (MOI->readsReg())\n        hasRead = true;\n    }\n    if (S.end.isDead()) {\n      // Make sure that the corresponding machine operand for a \"dead\" live\n      // range has the dead flag. We cannot perform this check for subregister\n      // liveranges as partially dead values are allowed.\n      if (LaneMask.none() && !hasDeadDef) {\n        report(\"Instruction ending live segment on dead slot has no dead flag\",\n               MI);\n        report_context(LR, Reg, LaneMask);\n        report_context(S);\n      }\n    } else {\n      if (!hasRead) {\n        // When tracking subregister liveness, the main range must start new\n        // values on partial register writes, even if there is no read.\n        if (!MRI->shouldTrackSubRegLiveness(Reg) || LaneMask.any() ||\n            !hasSubRegDef) {\n          report(\"Instruction ending live segment doesn't read the register\",\n                 MI);\n          report_context(LR, Reg, LaneMask);\n          report_context(S);\n        }\n      }\n    }\n  }\n\n  // Now check all the basic blocks in this live segment.\n  MachineFunction::const_iterator MFI = MBB->getIterator();\n  // Is this live segment the beginning of a non-PHIDef VN?\n  if (S.start == VNI->def && !VNI->isPHIDef()) {\n    // Not live-in to any blocks.\n    if (MBB == EndMBB)\n      return;\n    // Skip this block.\n    ++MFI;\n  }\n\n  SmallVector<SlotIndex, 4> Undefs;\n  if (LaneMask.any()) {\n    LiveInterval &OwnerLI = LiveInts->getInterval(Reg);\n    OwnerLI.computeSubRangeUndefs(Undefs, LaneMask, *MRI, *Indexes);\n  }\n\n  while (true) {\n    assert(LiveInts->isLiveInToMBB(LR, &*MFI));\n    // We don't know how to track physregs into a landing pad.\n    if (!Register::isVirtualRegister(Reg) && MFI->isEHPad()) {\n      if (&*MFI == EndMBB)\n        break;\n      ++MFI;\n      continue;\n    }\n\n    // Is VNI a PHI-def in the current block?\n    bool IsPHI = VNI->isPHIDef() &&\n      VNI->def == LiveInts->getMBBStartIdx(&*MFI);\n\n    // Check that VNI is live-out of all predecessors.\n    for (const MachineBasicBlock *Pred : MFI->predecessors()) {\n      SlotIndex PEnd = LiveInts->getMBBEndIdx(Pred);\n      const VNInfo *PVNI = LR.getVNInfoBefore(PEnd);\n\n      // All predecessors must have a live-out value. However for a phi\n      // instruction with subregister intervals\n      // only one of the subregisters (not necessarily the current one) needs to\n      // be defined.\n      if (!PVNI && (LaneMask.none() || !IsPHI)) {\n        if (LiveRangeCalc::isJointlyDominated(Pred, Undefs, *Indexes))\n          continue;\n        report(\"Register not marked live out of predecessor\", Pred);\n        report_context(LR, Reg, LaneMask);\n        report_context(*VNI);\n        errs() << \" live into \" << printMBBReference(*MFI) << '@'\n               << LiveInts->getMBBStartIdx(&*MFI) << \", not live before \"\n               << PEnd << '\\n';\n        continue;\n      }\n\n      // Only PHI-defs can take different predecessor values.\n      if (!IsPHI && PVNI != VNI) {\n        report(\"Different value live out of predecessor\", Pred);\n        report_context(LR, Reg, LaneMask);\n        errs() << \"Valno #\" << PVNI->id << \" live out of \"\n               << printMBBReference(*Pred) << '@' << PEnd << \"\\nValno #\"\n               << VNI->id << \" live into \" << printMBBReference(*MFI) << '@'\n               << LiveInts->getMBBStartIdx(&*MFI) << '\\n';\n      }\n    }\n    if (&*MFI == EndMBB)\n      break;\n    ++MFI;\n  }\n}\n\nvoid MachineVerifier::verifyLiveRange(const LiveRange &LR, Register Reg,\n                                      LaneBitmask LaneMask) {\n  for (const VNInfo *VNI : LR.valnos)\n    verifyLiveRangeValue(LR, VNI, Reg, LaneMask);\n\n  for (LiveRange::const_iterator I = LR.begin(), E = LR.end(); I != E; ++I)\n    verifyLiveRangeSegment(LR, I, Reg, LaneMask);\n}\n\nvoid MachineVerifier::verifyLiveInterval(const LiveInterval &LI) {\n  Register Reg = LI.reg();\n  assert(Register::isVirtualRegister(Reg));\n  verifyLiveRange(LI, Reg);\n\n  LaneBitmask Mask;\n  LaneBitmask MaxMask = MRI->getMaxLaneMaskForVReg(Reg);\n  for (const LiveInterval::SubRange &SR : LI.subranges()) {\n    if ((Mask & SR.LaneMask).any()) {\n      report(\"Lane masks of sub ranges overlap in live interval\", MF);\n      report_context(LI);\n    }\n    if ((SR.LaneMask & ~MaxMask).any()) {\n      report(\"Subrange lanemask is invalid\", MF);\n      report_context(LI);\n    }\n    if (SR.empty()) {\n      report(\"Subrange must not be empty\", MF);\n      report_context(SR, LI.reg(), SR.LaneMask);\n    }\n    Mask |= SR.LaneMask;\n    verifyLiveRange(SR, LI.reg(), SR.LaneMask);\n    if (!LI.covers(SR)) {\n      report(\"A Subrange is not covered by the main range\", MF);\n      report_context(LI);\n    }\n  }\n\n  // Check the LI only has one connected component.\n  ConnectedVNInfoEqClasses ConEQ(*LiveInts);\n  unsigned NumComp = ConEQ.Classify(LI);\n  if (NumComp > 1) {\n    report(\"Multiple connected components in live interval\", MF);\n    report_context(LI);\n    for (unsigned comp = 0; comp != NumComp; ++comp) {\n      errs() << comp << \": valnos\";\n      for (const VNInfo *I : LI.valnos)\n        if (comp == ConEQ.getEqClass(I))\n          errs() << ' ' << I->id;\n      errs() << '\\n';\n    }\n  }\n}\n\nnamespace {\n\n  // FrameSetup and FrameDestroy can have zero adjustment, so using a single\n  // integer, we can't tell whether it is a FrameSetup or FrameDestroy if the\n  // value is zero.\n  // We use a bool plus an integer to capture the stack state.\n  struct StackStateOfBB {\n    StackStateOfBB() = default;\n    StackStateOfBB(int EntryVal, int ExitVal, bool EntrySetup, bool ExitSetup) :\n      EntryValue(EntryVal), ExitValue(ExitVal), EntryIsSetup(EntrySetup),\n      ExitIsSetup(ExitSetup) {}\n\n    // Can be negative, which means we are setting up a frame.\n    int EntryValue = 0;\n    int ExitValue = 0;\n    bool EntryIsSetup = false;\n    bool ExitIsSetup = false;\n  };\n\n} // end anonymous namespace\n\n/// Make sure on every path through the CFG, a FrameSetup <n> is always followed\n/// by a FrameDestroy <n>, stack adjustments are identical on all\n/// CFG edges to a merge point, and frame is destroyed at end of a return block.\nvoid MachineVerifier::verifyStackFrame() {\n  unsigned FrameSetupOpcode   = TII->getCallFrameSetupOpcode();\n  unsigned FrameDestroyOpcode = TII->getCallFrameDestroyOpcode();\n  if (FrameSetupOpcode == ~0u && FrameDestroyOpcode == ~0u)\n    return;\n\n  SmallVector<StackStateOfBB, 8> SPState;\n  SPState.resize(MF->getNumBlockIDs());\n  df_iterator_default_set<const MachineBasicBlock*> Reachable;\n\n  // Visit the MBBs in DFS order.\n  for (df_ext_iterator<const MachineFunction *,\n                       df_iterator_default_set<const MachineBasicBlock *>>\n       DFI = df_ext_begin(MF, Reachable), DFE = df_ext_end(MF, Reachable);\n       DFI != DFE; ++DFI) {\n    const MachineBasicBlock *MBB = *DFI;\n\n    StackStateOfBB BBState;\n    // Check the exit state of the DFS stack predecessor.\n    if (DFI.getPathLength() >= 2) {\n      const MachineBasicBlock *StackPred = DFI.getPath(DFI.getPathLength() - 2);\n      assert(Reachable.count(StackPred) &&\n             \"DFS stack predecessor is already visited.\\n\");\n      BBState.EntryValue = SPState[StackPred->getNumber()].ExitValue;\n      BBState.EntryIsSetup = SPState[StackPred->getNumber()].ExitIsSetup;\n      BBState.ExitValue = BBState.EntryValue;\n      BBState.ExitIsSetup = BBState.EntryIsSetup;\n    }\n\n    // Update stack state by checking contents of MBB.\n    for (const auto &I : *MBB) {\n      if (I.getOpcode() == FrameSetupOpcode) {\n        if (BBState.ExitIsSetup)\n          report(\"FrameSetup is after another FrameSetup\", &I);\n        BBState.ExitValue -= TII->getFrameTotalSize(I);\n        BBState.ExitIsSetup = true;\n      }\n\n      if (I.getOpcode() == FrameDestroyOpcode) {\n        int Size = TII->getFrameTotalSize(I);\n        if (!BBState.ExitIsSetup)\n          report(\"FrameDestroy is not after a FrameSetup\", &I);\n        int AbsSPAdj = BBState.ExitValue < 0 ? -BBState.ExitValue :\n                                               BBState.ExitValue;\n        if (BBState.ExitIsSetup && AbsSPAdj != Size) {\n          report(\"FrameDestroy <n> is after FrameSetup <m>\", &I);\n          errs() << \"FrameDestroy <\" << Size << \"> is after FrameSetup <\"\n              << AbsSPAdj << \">.\\n\";\n        }\n        BBState.ExitValue += Size;\n        BBState.ExitIsSetup = false;\n      }\n    }\n    SPState[MBB->getNumber()] = BBState;\n\n    // Make sure the exit state of any predecessor is consistent with the entry\n    // state.\n    for (const MachineBasicBlock *Pred : MBB->predecessors()) {\n      if (Reachable.count(Pred) &&\n          (SPState[Pred->getNumber()].ExitValue != BBState.EntryValue ||\n           SPState[Pred->getNumber()].ExitIsSetup != BBState.EntryIsSetup)) {\n        report(\"The exit stack state of a predecessor is inconsistent.\", MBB);\n        errs() << \"Predecessor \" << printMBBReference(*Pred)\n               << \" has exit state (\" << SPState[Pred->getNumber()].ExitValue\n               << \", \" << SPState[Pred->getNumber()].ExitIsSetup << \"), while \"\n               << printMBBReference(*MBB) << \" has entry state (\"\n               << BBState.EntryValue << \", \" << BBState.EntryIsSetup << \").\\n\";\n      }\n    }\n\n    // Make sure the entry state of any successor is consistent with the exit\n    // state.\n    for (const MachineBasicBlock *Succ : MBB->successors()) {\n      if (Reachable.count(Succ) &&\n          (SPState[Succ->getNumber()].EntryValue != BBState.ExitValue ||\n           SPState[Succ->getNumber()].EntryIsSetup != BBState.ExitIsSetup)) {\n        report(\"The entry stack state of a successor is inconsistent.\", MBB);\n        errs() << \"Successor \" << printMBBReference(*Succ)\n               << \" has entry state (\" << SPState[Succ->getNumber()].EntryValue\n               << \", \" << SPState[Succ->getNumber()].EntryIsSetup << \"), while \"\n               << printMBBReference(*MBB) << \" has exit state (\"\n               << BBState.ExitValue << \", \" << BBState.ExitIsSetup << \").\\n\";\n      }\n    }\n\n    // Make sure a basic block with return ends with zero stack adjustment.\n    if (!MBB->empty() && MBB->back().isReturn()) {\n      if (BBState.ExitIsSetup)\n        report(\"A return block ends with a FrameSetup.\", MBB);\n      if (BBState.ExitValue)\n        report(\"A return block ends with a nonzero stack adjustment.\", MBB);\n    }\n  }\n}\n"}}, "reports": [{"events": [{"location": {"col": 9, "file": 34, "line": 53}, "message": "'VNInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h", "reportHash": "8be9dca1a31aac5fa65ddb8062b3fec1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 34, "line": 992}, "message": "'ConnectedVNInfoEqClasses' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h", "reportHash": "1233903657ade5e7c98b7cc051b86334", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 35, "line": 46}, "message": "'LiveRangeCalc' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h", "reportHash": "ce3ca34d77c09da39fb706c413d17c83", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 35, "line": 101}, "message": "'LiveInBlock' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h", "reportHash": "801b8fe138c8992712d54d82284f61c7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 49, "line": 158}, "message": "'StatepointOpers' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h", "reportHash": "8885a906682e6e5890bea04b3083a8f0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 96, "line": 86}, "message": "'MachineVerifier' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp", "reportHash": "c3bb2f2c894fbd1b9630b222c62c0662", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 96, "line": 274}, "message": "'MachineVerifierPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp", "reportHash": "bf5aaf7f9d9e052c5da3d4c9d2789152", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 96, "line": 2307}, "message": "'VRegFilter' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp", "reportHash": "e271e82dc1d7e393ea75c90f1fbffb51", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 96, "line": 2380}, "message": "'FilteringVRegSet' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp", "reportHash": "b6a67c78ea76b1f500ab41b217f0107a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
