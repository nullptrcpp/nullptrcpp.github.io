<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "content": "//===- llvm/ADT/DenseMap.h - Dense probed hash table ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the DenseMap class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_DENSEMAP_H\n#define LLVM_ADT_DENSEMAP_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/EpochTracker.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/MemAlloc.h\"\n#include \"llvm/Support/ReverseIteration.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstring>\n#include <initializer_list>\n#include <iterator>\n#include <new>\n#include <type_traits>\n#include <utility>\n\nnamespace llvm {\n\nnamespace detail {\n\n// We extend a pair to allow users to override the bucket type with their own\n// implementation without requiring two members.\ntemplate <typename KeyT, typename ValueT>\nstruct DenseMapPair : public std::pair<KeyT, ValueT> {\n  using std::pair<KeyT, ValueT>::pair;\n\n  KeyT &getFirst() { return std::pair<KeyT, ValueT>::first; }\n  const KeyT &getFirst() const { return std::pair<KeyT, ValueT>::first; }\n  ValueT &getSecond() { return std::pair<KeyT, ValueT>::second; }\n  const ValueT &getSecond() const { return std::pair<KeyT, ValueT>::second; }\n};\n\n} // end namespace detail\n\ntemplate <typename KeyT, typename ValueT,\n          typename KeyInfoT = DenseMapInfo<KeyT>,\n          typename Bucket = llvm::detail::DenseMapPair<KeyT, ValueT>,\n          bool IsConst = false>\nclass DenseMapIterator;\n\ntemplate <typename DerivedT, typename KeyT, typename ValueT, typename KeyInfoT,\n          typename BucketT>\nclass DenseMapBase : public DebugEpochBase {\n  template <typename T>\n  using const_arg_type_t = typename const_pointer_or_const_ref<T>::type;\n\npublic:\n  using size_type = unsigned;\n  using key_type = KeyT;\n  using mapped_type = ValueT;\n  using value_type = BucketT;\n\n  using iterator = DenseMapIterator<KeyT, ValueT, KeyInfoT, BucketT>;\n  using const_iterator =\n      DenseMapIterator<KeyT, ValueT, KeyInfoT, BucketT, true>;\n\n  inline iterator begin() {\n    // When the map is empty, avoid the overhead of advancing/retreating past\n    // empty buckets.\n    if (empty())\n      return end();\n    if (shouldReverseIterate<KeyT>())\n      return makeIterator(getBucketsEnd() - 1, getBuckets(), *this);\n    return makeIterator(getBuckets(), getBucketsEnd(), *this);\n  }\n  inline iterator end() {\n    return makeIterator(getBucketsEnd(), getBucketsEnd(), *this, true);\n  }\n  inline const_iterator begin() const {\n    if (empty())\n      return end();\n    if (shouldReverseIterate<KeyT>())\n      return makeConstIterator(getBucketsEnd() - 1, getBuckets(), *this);\n    return makeConstIterator(getBuckets(), getBucketsEnd(), *this);\n  }\n  inline const_iterator end() const {\n    return makeConstIterator(getBucketsEnd(), getBucketsEnd(), *this, true);\n  }\n\n  LLVM_NODISCARD bool empty() const {\n    return getNumEntries() == 0;\n  }\n  unsigned size() const { return getNumEntries(); }\n\n  /// Grow the densemap so that it can contain at least \\p NumEntries items\n  /// before resizing again.\n  void reserve(size_type NumEntries) {\n    auto NumBuckets = getMinBucketToReserveForEntries(NumEntries);\n    incrementEpoch();\n    if (NumBuckets > getNumBuckets())\n      grow(NumBuckets);\n  }\n\n  void clear() {\n    incrementEpoch();\n    if (getNumEntries() == 0 && getNumTombstones() == 0) return;\n\n    // If the capacity of the array is huge, and the # elements used is small,\n    // shrink the array.\n    if (getNumEntries() * 4 < getNumBuckets() && getNumBuckets() > 64) {\n      shrink_and_clear();\n      return;\n    }\n\n    const KeyT EmptyKey = getEmptyKey(), TombstoneKey = getTombstoneKey();\n    if (std::is_trivially_destructible<ValueT>::value) {\n      // Use a simpler loop when values don't need destruction.\n      for (BucketT *P = getBuckets(), *E = getBucketsEnd(); P != E; ++P)\n        P->getFirst() = EmptyKey;\n    } else {\n      unsigned NumEntries = getNumEntries();\n      for (BucketT *P = getBuckets(), *E = getBucketsEnd(); P != E; ++P) {\n        if (!KeyInfoT::isEqual(P->getFirst(), EmptyKey)) {\n          if (!KeyInfoT::isEqual(P->getFirst(), TombstoneKey)) {\n            P->getSecond().~ValueT();\n            --NumEntries;\n          }\n          P->getFirst() = EmptyKey;\n        }\n      }\n      assert(NumEntries == 0 && \"Node count imbalance!\");\n    }\n    setNumEntries(0);\n    setNumTombstones(0);\n  }\n\n  /// Return 1 if the specified key is in the map, 0 otherwise.\n  size_type count(const_arg_type_t<KeyT> Val) const {\n    const BucketT *TheBucket;\n    return LookupBucketFor(Val, TheBucket) ? 1 : 0;\n  }\n\n  iterator find(const_arg_type_t<KeyT> Val) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeIterator(TheBucket,\n                          shouldReverseIterate<KeyT>() ? getBuckets()\n                                                       : getBucketsEnd(),\n                          *this, true);\n    return end();\n  }\n  const_iterator find(const_arg_type_t<KeyT> Val) const {\n    const BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeConstIterator(TheBucket,\n                               shouldReverseIterate<KeyT>() ? getBuckets()\n                                                            : getBucketsEnd(),\n                               *this, true);\n    return end();\n  }\n\n  /// Alternate version of find() which allows a different, and possibly\n  /// less expensive, key type.\n  /// The DenseMapInfo is responsible for supplying methods\n  /// getHashValue(LookupKeyT) and isEqual(LookupKeyT, KeyT) for each key\n  /// type used.\n  template<class LookupKeyT>\n  iterator find_as(const LookupKeyT &Val) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeIterator(TheBucket,\n                          shouldReverseIterate<KeyT>() ? getBuckets()\n                                                       : getBucketsEnd(),\n                          *this, true);\n    return end();\n  }\n  template<class LookupKeyT>\n  const_iterator find_as(const LookupKeyT &Val) const {\n    const BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeConstIterator(TheBucket,\n                               shouldReverseIterate<KeyT>() ? getBuckets()\n                                                            : getBucketsEnd(),\n                               *this, true);\n    return end();\n  }\n\n  /// lookup - Return the entry for the specified key, or a default\n  /// constructed value if no such entry exists.\n  ValueT lookup(const_arg_type_t<KeyT> Val) const {\n    const BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return TheBucket->getSecond();\n    return ValueT();\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // If the key is already in the map, it returns false and doesn't update the\n  // value.\n  std::pair<iterator, bool> insert(const std::pair<KeyT, ValueT> &KV) {\n    return try_emplace(KV.first, KV.second);\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // If the key is already in the map, it returns false and doesn't update the\n  // value.\n  std::pair<iterator, bool> insert(std::pair<KeyT, ValueT> &&KV) {\n    return try_emplace(std::move(KV.first), std::move(KV.second));\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // The value is constructed in-place if the key is not in the map, otherwise\n  // it is not moved.\n  template <typename... Ts>\n  std::pair<iterator, bool> try_emplace(KeyT &&Key, Ts &&... Args) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return std::make_pair(makeIterator(TheBucket,\n                                         shouldReverseIterate<KeyT>()\n                                             ? getBuckets()\n                                             : getBucketsEnd(),\n                                         *this, true),\n                            false); // Already in map.\n\n    // Otherwise, insert the new element.\n    TheBucket =\n        InsertIntoBucket(TheBucket, std::move(Key), std::forward<Ts>(Args)...);\n    return std::make_pair(makeIterator(TheBucket,\n                                       shouldReverseIterate<KeyT>()\n                                           ? getBuckets()\n                                           : getBucketsEnd(),\n                                       *this, true),\n                          true);\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // The value is constructed in-place if the key is not in the map, otherwise\n  // it is not moved.\n  template <typename... Ts>\n  std::pair<iterator, bool> try_emplace(const KeyT &Key, Ts &&... Args) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return std::make_pair(makeIterator(TheBucket,\n                                         shouldReverseIterate<KeyT>()\n                                             ? getBuckets()\n                                             : getBucketsEnd(),\n                                         *this, true),\n                            false); // Already in map.\n\n    // Otherwise, insert the new element.\n    TheBucket = InsertIntoBucket(TheBucket, Key, std::forward<Ts>(Args)...);\n    return std::make_pair(makeIterator(TheBucket,\n                                       shouldReverseIterate<KeyT>()\n                                           ? getBuckets()\n                                           : getBucketsEnd(),\n                                       *this, true),\n                          true);\n  }\n\n  /// Alternate version of insert() which allows a different, and possibly\n  /// less expensive, key type.\n  /// The DenseMapInfo is responsible for supplying methods\n  /// getHashValue(LookupKeyT) and isEqual(LookupKeyT, KeyT) for each key\n  /// type used.\n  template <typename LookupKeyT>\n  std::pair<iterator, bool> insert_as(std::pair<KeyT, ValueT> &&KV,\n                                      const LookupKeyT &Val) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return std::make_pair(makeIterator(TheBucket,\n                                         shouldReverseIterate<KeyT>()\n                                             ? getBuckets()\n                                             : getBucketsEnd(),\n                                         *this, true),\n                            false); // Already in map.\n\n    // Otherwise, insert the new element.\n    TheBucket = InsertIntoBucketWithLookup(TheBucket, std::move(KV.first),\n                                           std::move(KV.second), Val);\n    return std::make_pair(makeIterator(TheBucket,\n                                       shouldReverseIterate<KeyT>()\n                                           ? getBuckets()\n                                           : getBucketsEnd(),\n                                       *this, true),\n                          true);\n  }\n\n  /// insert - Range insertion of pairs.\n  template<typename InputIt>\n  void insert(InputIt I, InputIt E) {\n    for (; I != E; ++I)\n      insert(*I);\n  }\n\n  bool erase(const KeyT &Val) {\n    BucketT *TheBucket;\n    if (!LookupBucketFor(Val, TheBucket))\n      return false; // not in map.\n\n    TheBucket->getSecond().~ValueT();\n    TheBucket->getFirst() = getTombstoneKey();\n    decrementNumEntries();\n    incrementNumTombstones();\n    return true;\n  }\n  void erase(iterator I) {\n    BucketT *TheBucket = &*I;\n    TheBucket->getSecond().~ValueT();\n    TheBucket->getFirst() = getTombstoneKey();\n    decrementNumEntries();\n    incrementNumTombstones();\n  }\n\n  value_type& FindAndConstruct(const KeyT &Key) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return *TheBucket;\n\n    return *InsertIntoBucket(TheBucket, Key);\n  }\n\n  ValueT &operator[](const KeyT &Key) {\n    return FindAndConstruct(Key).second;\n  }\n\n  value_type& FindAndConstruct(KeyT &&Key) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return *TheBucket;\n\n    return *InsertIntoBucket(TheBucket, std::move(Key));\n  }\n\n  ValueT &operator[](KeyT &&Key) {\n    return FindAndConstruct(std::move(Key)).second;\n  }\n\n  /// isPointerIntoBucketsArray - Return true if the specified pointer points\n  /// somewhere into the DenseMap's array of buckets (i.e. either to a key or\n  /// value in the DenseMap).\n  bool isPointerIntoBucketsArray(const void *Ptr) const {\n    return Ptr >= getBuckets() && Ptr < getBucketsEnd();\n  }\n\n  /// getPointerIntoBucketsArray() - Return an opaque pointer into the buckets\n  /// array.  In conjunction with the previous method, this can be used to\n  /// determine whether an insertion caused the DenseMap to reallocate.\n  const void *getPointerIntoBucketsArray() const { return getBuckets(); }\n\nprotected:\n  DenseMapBase() = default;\n\n  void destroyAll() {\n    if (getNumBuckets() == 0) // Nothing to do.\n      return;\n\n    const KeyT EmptyKey = getEmptyKey(), TombstoneKey = getTombstoneKey();\n    for (BucketT *P = getBuckets(), *E = getBucketsEnd(); P != E; ++P) {\n      if (!KeyInfoT::isEqual(P->getFirst(), EmptyKey) &&\n          !KeyInfoT::isEqual(P->getFirst(), TombstoneKey))\n        P->getSecond().~ValueT();\n      P->getFirst().~KeyT();\n    }\n  }\n\n  void initEmpty() {\n    setNumEntries(0);\n    setNumTombstones(0);\n\n    assert((getNumBuckets() & (getNumBuckets()-1)) == 0 &&\n           \"# initial buckets must be a power of two!\");\n    const KeyT EmptyKey = getEmptyKey();\n    for (BucketT *B = getBuckets(), *E = getBucketsEnd(); B != E; ++B)\n      ::new (&B->getFirst()) KeyT(EmptyKey);\n  }\n\n  /// Returns the number of buckets to allocate to ensure that the DenseMap can\n  /// accommodate \\p NumEntries without need to grow().\n  unsigned getMinBucketToReserveForEntries(unsigned NumEntries) {\n    // Ensure that \"NumEntries * 4 < NumBuckets * 3\"\n    if (NumEntries == 0)\n      return 0;\n    // +1 is required because of the strict equality.\n    // For example if NumEntries is 48, we need to return 401.\n    return NextPowerOf2(NumEntries * 4 / 3 + 1);\n  }\n\n  void moveFromOldBuckets(BucketT *OldBucketsBegin, BucketT *OldBucketsEnd) {\n    initEmpty();\n\n    // Insert all the old elements.\n    const KeyT EmptyKey = getEmptyKey();\n    const KeyT TombstoneKey = getTombstoneKey();\n    for (BucketT *B = OldBucketsBegin, *E = OldBucketsEnd; B != E; ++B) {\n      if (!KeyInfoT::isEqual(B->getFirst(), EmptyKey) &&\n          !KeyInfoT::isEqual(B->getFirst(), TombstoneKey)) {\n        // Insert the key/value into the new table.\n        BucketT *DestBucket;\n        bool FoundVal = LookupBucketFor(B->getFirst(), DestBucket);\n        (void)FoundVal; // silence warning.\n        assert(!FoundVal && \"Key already in new map?\");\n        DestBucket->getFirst() = std::move(B->getFirst());\n        ::new (&DestBucket->getSecond()) ValueT(std::move(B->getSecond()));\n        incrementNumEntries();\n\n        // Free the value.\n        B->getSecond().~ValueT();\n      }\n      B->getFirst().~KeyT();\n    }\n  }\n\n  template <typename OtherBaseT>\n  void copyFrom(\n      const DenseMapBase<OtherBaseT, KeyT, ValueT, KeyInfoT, BucketT> &other) {\n    assert(&other != this);\n    assert(getNumBuckets() == other.getNumBuckets());\n\n    setNumEntries(other.getNumEntries());\n    setNumTombstones(other.getNumTombstones());\n\n    if (std::is_trivially_copyable<KeyT>::value &&\n        std::is_trivially_copyable<ValueT>::value)\n      memcpy(reinterpret_cast<void *>(getBuckets()), other.getBuckets(),\n             getNumBuckets() * sizeof(BucketT));\n    else\n      for (size_t i = 0; i < getNumBuckets(); ++i) {\n        ::new (&getBuckets()[i].getFirst())\n            KeyT(other.getBuckets()[i].getFirst());\n        if (!KeyInfoT::isEqual(getBuckets()[i].getFirst(), getEmptyKey()) &&\n            !KeyInfoT::isEqual(getBuckets()[i].getFirst(), getTombstoneKey()))\n          ::new (&getBuckets()[i].getSecond())\n              ValueT(other.getBuckets()[i].getSecond());\n      }\n  }\n\n  static unsigned getHashValue(const KeyT &Val) {\n    return KeyInfoT::getHashValue(Val);\n  }\n\n  template<typename LookupKeyT>\n  static unsigned getHashValue(const LookupKeyT &Val) {\n    return KeyInfoT::getHashValue(Val);\n  }\n\n  static const KeyT getEmptyKey() {\n    static_assert(std::is_base_of<DenseMapBase, DerivedT>::value,\n                  \"Must pass the derived type to this template!\");\n    return KeyInfoT::getEmptyKey();\n  }\n\n  static const KeyT getTombstoneKey() {\n    return KeyInfoT::getTombstoneKey();\n  }\n\nprivate:\n  iterator makeIterator(BucketT *P, BucketT *E,\n                        DebugEpochBase &Epoch,\n                        bool NoAdvance=false) {\n    if (shouldReverseIterate<KeyT>()) {\n      BucketT *B = P == getBucketsEnd() ? getBuckets() : P + 1;\n      return iterator(B, E, Epoch, NoAdvance);\n    }\n    return iterator(P, E, Epoch, NoAdvance);\n  }\n\n  const_iterator makeConstIterator(const BucketT *P, const BucketT *E,\n                                   const DebugEpochBase &Epoch,\n                                   const bool NoAdvance=false) const {\n    if (shouldReverseIterate<KeyT>()) {\n      const BucketT *B = P == getBucketsEnd() ? getBuckets() : P + 1;\n      return const_iterator(B, E, Epoch, NoAdvance);\n    }\n    return const_iterator(P, E, Epoch, NoAdvance);\n  }\n\n  unsigned getNumEntries() const {\n    return static_cast<const DerivedT *>(this)->getNumEntries();\n  }\n\n  void setNumEntries(unsigned Num) {\n    static_cast<DerivedT *>(this)->setNumEntries(Num);\n  }\n\n  void incrementNumEntries() {\n    setNumEntries(getNumEntries() + 1);\n  }\n\n  void decrementNumEntries() {\n    setNumEntries(getNumEntries() - 1);\n  }\n\n  unsigned getNumTombstones() const {\n    return static_cast<const DerivedT *>(this)->getNumTombstones();\n  }\n\n  void setNumTombstones(unsigned Num) {\n    static_cast<DerivedT *>(this)->setNumTombstones(Num);\n  }\n\n  void incrementNumTombstones() {\n    setNumTombstones(getNumTombstones() + 1);\n  }\n\n  void decrementNumTombstones() {\n    setNumTombstones(getNumTombstones() - 1);\n  }\n\n  const BucketT *getBuckets() const {\n    return static_cast<const DerivedT *>(this)->getBuckets();\n  }\n\n  BucketT *getBuckets() {\n    return static_cast<DerivedT *>(this)->getBuckets();\n  }\n\n  unsigned getNumBuckets() const {\n    return static_cast<const DerivedT *>(this)->getNumBuckets();\n  }\n\n  BucketT *getBucketsEnd() {\n    return getBuckets() + getNumBuckets();\n  }\n\n  const BucketT *getBucketsEnd() const {\n    return getBuckets() + getNumBuckets();\n  }\n\n  void grow(unsigned AtLeast) {\n    static_cast<DerivedT *>(this)->grow(AtLeast);\n  }\n\n  void shrink_and_clear() {\n    static_cast<DerivedT *>(this)->shrink_and_clear();\n  }\n\n  template <typename KeyArg, typename... ValueArgs>\n  BucketT *InsertIntoBucket(BucketT *TheBucket, KeyArg &&Key,\n                            ValueArgs &&... Values) {\n    TheBucket = InsertIntoBucketImpl(Key, Key, TheBucket);\n\n    TheBucket->getFirst() = std::forward<KeyArg>(Key);\n    ::new (&TheBucket->getSecond()) ValueT(std::forward<ValueArgs>(Values)...);\n    return TheBucket;\n  }\n\n  template <typename LookupKeyT>\n  BucketT *InsertIntoBucketWithLookup(BucketT *TheBucket, KeyT &&Key,\n                                      ValueT &&Value, LookupKeyT &Lookup) {\n    TheBucket = InsertIntoBucketImpl(Key, Lookup, TheBucket);\n\n    TheBucket->getFirst() = std::move(Key);\n    ::new (&TheBucket->getSecond()) ValueT(std::move(Value));\n    return TheBucket;\n  }\n\n  template <typename LookupKeyT>\n  BucketT *InsertIntoBucketImpl(const KeyT &Key, const LookupKeyT &Lookup,\n                                BucketT *TheBucket) {\n    incrementEpoch();\n\n    // If the load of the hash table is more than 3/4, or if fewer than 1/8 of\n    // the buckets are empty (meaning that many are filled with tombstones),\n    // grow the table.\n    //\n    // The later case is tricky.  For example, if we had one empty bucket with\n    // tons of tombstones, failing lookups (e.g. for insertion) would have to\n    // probe almost the entire table until it found the empty bucket.  If the\n    // table completely filled with tombstones, no lookup would ever succeed,\n    // causing infinite loops in lookup.\n    unsigned NewNumEntries = getNumEntries() + 1;\n    unsigned NumBuckets = getNumBuckets();\n    if (LLVM_UNLIKELY(NewNumEntries * 4 >= NumBuckets * 3)) {\n      this->grow(NumBuckets * 2);\n      LookupBucketFor(Lookup, TheBucket);\n      NumBuckets = getNumBuckets();\n    } else if (LLVM_UNLIKELY(NumBuckets-(NewNumEntries+getNumTombstones()) <=\n                             NumBuckets/8)) {\n      this->grow(NumBuckets);\n      LookupBucketFor(Lookup, TheBucket);\n    }\n    assert(TheBucket);\n\n    // Only update the state after we've grown our bucket space appropriately\n    // so that when growing buckets we have self-consistent entry count.\n    incrementNumEntries();\n\n    // If we are writing over a tombstone, remember this.\n    const KeyT EmptyKey = getEmptyKey();\n    if (!KeyInfoT::isEqual(TheBucket->getFirst(), EmptyKey))\n      decrementNumTombstones();\n\n    return TheBucket;\n  }\n\n  /// LookupBucketFor - Lookup the appropriate bucket for Val, returning it in\n  /// FoundBucket.  If the bucket contains the key and a value, this returns\n  /// true, otherwise it returns a bucket with an empty marker or tombstone and\n  /// returns false.\n  template<typename LookupKeyT>\n  bool LookupBucketFor(const LookupKeyT &Val,\n                       const BucketT *&FoundBucket) const {\n    const BucketT *BucketsPtr = getBuckets();\n    const unsigned NumBuckets = getNumBuckets();\n\n    if (NumBuckets == 0) {\n      FoundBucket = nullptr;\n      return false;\n    }\n\n    // FoundTombstone - Keep track of whether we find a tombstone while probing.\n    const BucketT *FoundTombstone = nullptr;\n    const KeyT EmptyKey = getEmptyKey();\n    const KeyT TombstoneKey = getTombstoneKey();\n    assert(!KeyInfoT::isEqual(Val, EmptyKey) &&\n           !KeyInfoT::isEqual(Val, TombstoneKey) &&\n           \"Empty/Tombstone value shouldn't be inserted into map!\");\n\n    unsigned BucketNo = getHashValue(Val) & (NumBuckets-1);\n    unsigned ProbeAmt = 1;\n    while (true) {\n      const BucketT *ThisBucket = BucketsPtr + BucketNo;\n      // Found Val's bucket?  If so, return it.\n      if (LLVM_LIKELY(KeyInfoT::isEqual(Val, ThisBucket->getFirst()))) {\n        FoundBucket = ThisBucket;\n        return true;\n      }\n\n      // If we found an empty bucket, the key doesn't exist in the set.\n      // Insert it and return the default value.\n      if (LLVM_LIKELY(KeyInfoT::isEqual(ThisBucket->getFirst(), EmptyKey))) {\n        // If we've already seen a tombstone while probing, fill it in instead\n        // of the empty bucket we eventually probed to.\n        FoundBucket = FoundTombstone ? FoundTombstone : ThisBucket;\n        return false;\n      }\n\n      // If this is a tombstone, remember it.  If Val ends up not in the map, we\n      // prefer to return it than something that would require more probing.\n      if (KeyInfoT::isEqual(ThisBucket->getFirst(), TombstoneKey) &&\n          !FoundTombstone)\n        FoundTombstone = ThisBucket;  // Remember the first tombstone found.\n\n      // Otherwise, it's a hash collision or a tombstone, continue quadratic\n      // probing.\n      BucketNo += ProbeAmt++;\n      BucketNo &= (NumBuckets-1);\n    }\n  }\n\n  template <typename LookupKeyT>\n  bool LookupBucketFor(const LookupKeyT &Val, BucketT *&FoundBucket) {\n    const BucketT *ConstFoundBucket;\n    bool Result = const_cast<const DenseMapBase *>(this)\n      ->LookupBucketFor(Val, ConstFoundBucket);\n    FoundBucket = const_cast<BucketT *>(ConstFoundBucket);\n    return Result;\n  }\n\npublic:\n  /// Return the approximate size (in bytes) of the actual map.\n  /// This is just the raw memory used by DenseMap.\n  /// If entries are pointers to objects, the size of the referenced objects\n  /// are not included.\n  size_t getMemorySize() const {\n    return getNumBuckets() * sizeof(BucketT);\n  }\n};\n\n/// Equality comparison for DenseMap.\n///\n/// Iterates over elements of LHS confirming that each (key, value) pair in LHS\n/// is also in RHS, and that no additional pairs are in RHS.\n/// Equivalent to N calls to RHS.find and N value comparisons. Amortized\n/// complexity is linear, worst case is O(N^2) (if every hash collides).\ntemplate <typename DerivedT, typename KeyT, typename ValueT, typename KeyInfoT,\n          typename BucketT>\nbool operator==(\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &LHS,\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &RHS) {\n  if (LHS.size() != RHS.size())\n    return false;\n\n  for (auto &KV : LHS) {\n    auto I = RHS.find(KV.first);\n    if (I == RHS.end() || I->second != KV.second)\n      return false;\n  }\n\n  return true;\n}\n\n/// Inequality comparison for DenseMap.\n///\n/// Equivalent to !(LHS == RHS). See operator== for performance notes.\ntemplate <typename DerivedT, typename KeyT, typename ValueT, typename KeyInfoT,\n          typename BucketT>\nbool operator!=(\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &LHS,\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &RHS) {\n  return !(LHS == RHS);\n}\n\ntemplate <typename KeyT, typename ValueT,\n          typename KeyInfoT = DenseMapInfo<KeyT>,\n          typename BucketT = llvm::detail::DenseMapPair<KeyT, ValueT>>\nclass DenseMap : public DenseMapBase<DenseMap<KeyT, ValueT, KeyInfoT, BucketT>,\n                                     KeyT, ValueT, KeyInfoT, BucketT> {\n  friend class DenseMapBase<DenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  // Lift some types from the dependent base class into this class for\n  // simplicity of referring to them.\n  using BaseT = DenseMapBase<DenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  BucketT *Buckets;\n  unsigned NumEntries;\n  unsigned NumTombstones;\n  unsigned NumBuckets;\n\npublic:\n  /// Create a DenseMap with an optional \\p InitialReserve that guarantee that\n  /// this number of elements can be inserted in the map without grow()\n  explicit DenseMap(unsigned InitialReserve = 0) { init(InitialReserve); }\n\n  DenseMap(const DenseMap &other) : BaseT() {\n    init(0);\n    copyFrom(other);\n  }\n\n  DenseMap(DenseMap &&other) : BaseT() {\n    init(0);\n    swap(other);\n  }\n\n  template<typename InputIt>\n  DenseMap(const InputIt &I, const InputIt &E) {\n    init(std::distance(I, E));\n    this->insert(I, E);\n  }\n\n  DenseMap(std::initializer_list<typename BaseT::value_type> Vals) {\n    init(Vals.size());\n    this->insert(Vals.begin(), Vals.end());\n  }\n\n  ~DenseMap() {\n    this->destroyAll();\n    deallocate_buffer(Buckets, sizeof(BucketT) * NumBuckets, alignof(BucketT));\n  }\n\n  void swap(DenseMap& RHS) {\n    this->incrementEpoch();\n    RHS.incrementEpoch();\n    std::swap(Buckets, RHS.Buckets);\n    std::swap(NumEntries, RHS.NumEntries);\n    std::swap(NumTombstones, RHS.NumTombstones);\n    std::swap(NumBuckets, RHS.NumBuckets);\n  }\n\n  DenseMap& operator=(const DenseMap& other) {\n    if (&other != this)\n      copyFrom(other);\n    return *this;\n  }\n\n  DenseMap& operator=(DenseMap &&other) {\n    this->destroyAll();\n    deallocate_buffer(Buckets, sizeof(BucketT) * NumBuckets, alignof(BucketT));\n    init(0);\n    swap(other);\n    return *this;\n  }\n\n  void copyFrom(const DenseMap& other) {\n    this->destroyAll();\n    deallocate_buffer(Buckets, sizeof(BucketT) * NumBuckets, alignof(BucketT));\n    if (allocateBuckets(other.NumBuckets)) {\n      this->BaseT::copyFrom(other);\n    } else {\n      NumEntries = 0;\n      NumTombstones = 0;\n    }\n  }\n\n  void init(unsigned InitNumEntries) {\n    auto InitBuckets = BaseT::getMinBucketToReserveForEntries(InitNumEntries);\n    if (allocateBuckets(InitBuckets)) {\n      this->BaseT::initEmpty();\n    } else {\n      NumEntries = 0;\n      NumTombstones = 0;\n    }\n  }\n\n  void grow(unsigned AtLeast) {\n    unsigned OldNumBuckets = NumBuckets;\n    BucketT *OldBuckets = Buckets;\n\n    allocateBuckets(std::max<unsigned>(64, static_cast<unsigned>(NextPowerOf2(AtLeast-1))));\n    assert(Buckets);\n    if (!OldBuckets) {\n      this->BaseT::initEmpty();\n      return;\n    }\n\n    this->moveFromOldBuckets(OldBuckets, OldBuckets+OldNumBuckets);\n\n    // Free the old table.\n    deallocate_buffer(OldBuckets, sizeof(BucketT) * OldNumBuckets,\n                      alignof(BucketT));\n  }\n\n  void shrink_and_clear() {\n    unsigned OldNumBuckets = NumBuckets;\n    unsigned OldNumEntries = NumEntries;\n    this->destroyAll();\n\n    // Reduce the number of buckets.\n    unsigned NewNumBuckets = 0;\n    if (OldNumEntries)\n      NewNumBuckets = std::max(64, 1 << (Log2_32_Ceil(OldNumEntries) + 1));\n    if (NewNumBuckets == NumBuckets) {\n      this->BaseT::initEmpty();\n      return;\n    }\n\n    deallocate_buffer(Buckets, sizeof(BucketT) * OldNumBuckets,\n                      alignof(BucketT));\n    init(NewNumBuckets);\n  }\n\nprivate:\n  unsigned getNumEntries() const {\n    return NumEntries;\n  }\n\n  void setNumEntries(unsigned Num) {\n    NumEntries = Num;\n  }\n\n  unsigned getNumTombstones() const {\n    return NumTombstones;\n  }\n\n  void setNumTombstones(unsigned Num) {\n    NumTombstones = Num;\n  }\n\n  BucketT *getBuckets() const {\n    return Buckets;\n  }\n\n  unsigned getNumBuckets() const {\n    return NumBuckets;\n  }\n\n  bool allocateBuckets(unsigned Num) {\n    NumBuckets = Num;\n    if (NumBuckets == 0) {\n      Buckets = nullptr;\n      return false;\n    }\n\n    Buckets = static_cast<BucketT *>(\n        allocate_buffer(sizeof(BucketT) * NumBuckets, alignof(BucketT)));\n    return true;\n  }\n};\n\ntemplate <typename KeyT, typename ValueT, unsigned InlineBuckets = 4,\n          typename KeyInfoT = DenseMapInfo<KeyT>,\n          typename BucketT = llvm::detail::DenseMapPair<KeyT, ValueT>>\nclass SmallDenseMap\n    : public DenseMapBase<\n          SmallDenseMap<KeyT, ValueT, InlineBuckets, KeyInfoT, BucketT>, KeyT,\n          ValueT, KeyInfoT, BucketT> {\n  friend class DenseMapBase<SmallDenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  // Lift some types from the dependent base class into this class for\n  // simplicity of referring to them.\n  using BaseT = DenseMapBase<SmallDenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  static_assert(isPowerOf2_64(InlineBuckets),\n                \"InlineBuckets must be a power of 2.\");\n\n  unsigned Small : 1;\n  unsigned NumEntries : 31;\n  unsigned NumTombstones;\n\n  struct LargeRep {\n    BucketT *Buckets;\n    unsigned NumBuckets;\n  };\n\n  /// A \"union\" of an inline bucket array and the struct representing\n  /// a large bucket. This union will be discriminated by the 'Small' bit.\n  AlignedCharArrayUnion<BucketT[InlineBuckets], LargeRep> storage;\n\npublic:\n  explicit SmallDenseMap(unsigned NumInitBuckets = 0) {\n    init(NumInitBuckets);\n  }\n\n  SmallDenseMap(const SmallDenseMap &other) : BaseT() {\n    init(0);\n    copyFrom(other);\n  }\n\n  SmallDenseMap(SmallDenseMap &&other) : BaseT() {\n    init(0);\n    swap(other);\n  }\n\n  template<typename InputIt>\n  SmallDenseMap(const InputIt &I, const InputIt &E) {\n    init(NextPowerOf2(std::distance(I, E)));\n    this->insert(I, E);\n  }\n\n  ~SmallDenseMap() {\n    this->destroyAll();\n    deallocateBuckets();\n  }\n\n  void swap(SmallDenseMap& RHS) {\n    unsigned TmpNumEntries = RHS.NumEntries;\n    RHS.NumEntries = NumEntries;\n    NumEntries = TmpNumEntries;\n    std::swap(NumTombstones, RHS.NumTombstones);\n\n    const KeyT EmptyKey = this->getEmptyKey();\n    const KeyT TombstoneKey = this->getTombstoneKey();\n    if (Small && RHS.Small) {\n      // If we're swapping inline bucket arrays, we have to cope with some of\n      // the tricky bits of DenseMap's storage system: the buckets are not\n      // fully initialized. Thus we swap every key, but we may have\n      // a one-directional move of the value.\n      for (unsigned i = 0, e = InlineBuckets; i != e; ++i) {\n        BucketT *LHSB = &getInlineBuckets()[i],\n                *RHSB = &RHS.getInlineBuckets()[i];\n        bool hasLHSValue = (!KeyInfoT::isEqual(LHSB->getFirst(), EmptyKey) &&\n                            !KeyInfoT::isEqual(LHSB->getFirst(), TombstoneKey));\n        bool hasRHSValue = (!KeyInfoT::isEqual(RHSB->getFirst(), EmptyKey) &&\n                            !KeyInfoT::isEqual(RHSB->getFirst(), TombstoneKey));\n        if (hasLHSValue && hasRHSValue) {\n          // Swap together if we can...\n          std::swap(*LHSB, *RHSB);\n          continue;\n        }\n        // Swap separately and handle any asymmetry.\n        std::swap(LHSB->getFirst(), RHSB->getFirst());\n        if (hasLHSValue) {\n          ::new (&RHSB->getSecond()) ValueT(std::move(LHSB->getSecond()));\n          LHSB->getSecond().~ValueT();\n        } else if (hasRHSValue) {\n          ::new (&LHSB->getSecond()) ValueT(std::move(RHSB->getSecond()));\n          RHSB->getSecond().~ValueT();\n        }\n      }\n      return;\n    }\n    if (!Small && !RHS.Small) {\n      std::swap(getLargeRep()->Buckets, RHS.getLargeRep()->Buckets);\n      std::swap(getLargeRep()->NumBuckets, RHS.getLargeRep()->NumBuckets);\n      return;\n    }\n\n    SmallDenseMap &SmallSide = Small ? *this : RHS;\n    SmallDenseMap &LargeSide = Small ? RHS : *this;\n\n    // First stash the large side's rep and move the small side across.\n    LargeRep TmpRep = std::move(*LargeSide.getLargeRep());\n    LargeSide.getLargeRep()->~LargeRep();\n    LargeSide.Small = true;\n    // This is similar to the standard move-from-old-buckets, but the bucket\n    // count hasn't actually rotated in this case. So we have to carefully\n    // move construct the keys and values into their new locations, but there\n    // is no need to re-hash things.\n    for (unsigned i = 0, e = InlineBuckets; i != e; ++i) {\n      BucketT *NewB = &LargeSide.getInlineBuckets()[i],\n              *OldB = &SmallSide.getInlineBuckets()[i];\n      ::new (&NewB->getFirst()) KeyT(std::move(OldB->getFirst()));\n      OldB->getFirst().~KeyT();\n      if (!KeyInfoT::isEqual(NewB->getFirst(), EmptyKey) &&\n          !KeyInfoT::isEqual(NewB->getFirst(), TombstoneKey)) {\n        ::new (&NewB->getSecond()) ValueT(std::move(OldB->getSecond()));\n        OldB->getSecond().~ValueT();\n      }\n    }\n\n    // The hard part of moving the small buckets across is done, just move\n    // the TmpRep into its new home.\n    SmallSide.Small = false;\n    new (SmallSide.getLargeRep()) LargeRep(std::move(TmpRep));\n  }\n\n  SmallDenseMap& operator=(const SmallDenseMap& other) {\n    if (&other != this)\n      copyFrom(other);\n    return *this;\n  }\n\n  SmallDenseMap& operator=(SmallDenseMap &&other) {\n    this->destroyAll();\n    deallocateBuckets();\n    init(0);\n    swap(other);\n    return *this;\n  }\n\n  void copyFrom(const SmallDenseMap& other) {\n    this->destroyAll();\n    deallocateBuckets();\n    Small = true;\n    if (other.getNumBuckets() > InlineBuckets) {\n      Small = false;\n      new (getLargeRep()) LargeRep(allocateBuckets(other.getNumBuckets()));\n    }\n    this->BaseT::copyFrom(other);\n  }\n\n  void init(unsigned InitBuckets) {\n    Small = true;\n    if (InitBuckets > InlineBuckets) {\n      Small = false;\n      new (getLargeRep()) LargeRep(allocateBuckets(InitBuckets));\n    }\n    this->BaseT::initEmpty();\n  }\n\n  void grow(unsigned AtLeast) {\n    if (AtLeast > InlineBuckets)\n      AtLeast = std::max<unsigned>(64, NextPowerOf2(AtLeast-1));\n\n    if (Small) {\n      // First move the inline buckets into a temporary storage.\n      AlignedCharArrayUnion<BucketT[InlineBuckets]> TmpStorage;\n      BucketT *TmpBegin = reinterpret_cast<BucketT *>(&TmpStorage);\n      BucketT *TmpEnd = TmpBegin;\n\n      // Loop over the buckets, moving non-empty, non-tombstones into the\n      // temporary storage. Have the loop move the TmpEnd forward as it goes.\n      const KeyT EmptyKey = this->getEmptyKey();\n      const KeyT TombstoneKey = this->getTombstoneKey();\n      for (BucketT *P = getBuckets(), *E = P + InlineBuckets; P != E; ++P) {\n        if (!KeyInfoT::isEqual(P->getFirst(), EmptyKey) &&\n            !KeyInfoT::isEqual(P->getFirst(), TombstoneKey)) {\n          assert(size_t(TmpEnd - TmpBegin) < InlineBuckets &&\n                 \"Too many inline buckets!\");\n          ::new (&TmpEnd->getFirst()) KeyT(std::move(P->getFirst()));\n          ::new (&TmpEnd->getSecond()) ValueT(std::move(P->getSecond()));\n          ++TmpEnd;\n          P->getSecond().~ValueT();\n        }\n        P->getFirst().~KeyT();\n      }\n\n      // AtLeast == InlineBuckets can happen if there are many tombstones,\n      // and grow() is used to remove them. Usually we always switch to the\n      // large rep here.\n      if (AtLeast > InlineBuckets) {\n        Small = false;\n        new (getLargeRep()) LargeRep(allocateBuckets(AtLeast));\n      }\n      this->moveFromOldBuckets(TmpBegin, TmpEnd);\n      return;\n    }\n\n    LargeRep OldRep = std::move(*getLargeRep());\n    getLargeRep()->~LargeRep();\n    if (AtLeast <= InlineBuckets) {\n      Small = true;\n    } else {\n      new (getLargeRep()) LargeRep(allocateBuckets(AtLeast));\n    }\n\n    this->moveFromOldBuckets(OldRep.Buckets, OldRep.Buckets+OldRep.NumBuckets);\n\n    // Free the old table.\n    deallocate_buffer(OldRep.Buckets, sizeof(BucketT) * OldRep.NumBuckets,\n                      alignof(BucketT));\n  }\n\n  void shrink_and_clear() {\n    unsigned OldSize = this->size();\n    this->destroyAll();\n\n    // Reduce the number of buckets.\n    unsigned NewNumBuckets = 0;\n    if (OldSize) {\n      NewNumBuckets = 1 << (Log2_32_Ceil(OldSize) + 1);\n      if (NewNumBuckets > InlineBuckets && NewNumBuckets < 64u)\n        NewNumBuckets = 64;\n    }\n    if ((Small && NewNumBuckets <= InlineBuckets) ||\n        (!Small && NewNumBuckets == getLargeRep()->NumBuckets)) {\n      this->BaseT::initEmpty();\n      return;\n    }\n\n    deallocateBuckets();\n    init(NewNumBuckets);\n  }\n\nprivate:\n  unsigned getNumEntries() const {\n    return NumEntries;\n  }\n\n  void setNumEntries(unsigned Num) {\n    // NumEntries is hardcoded to be 31 bits wide.\n    assert(Num < (1U << 31) && \"Cannot support more than 1<<31 entries\");\n    NumEntries = Num;\n  }\n\n  unsigned getNumTombstones() const {\n    return NumTombstones;\n  }\n\n  void setNumTombstones(unsigned Num) {\n    NumTombstones = Num;\n  }\n\n  const BucketT *getInlineBuckets() const {\n    assert(Small);\n    // Note that this cast does not violate aliasing rules as we assert that\n    // the memory's dynamic type is the small, inline bucket buffer, and the\n    // 'storage' is a POD containing a char buffer.\n    return reinterpret_cast<const BucketT *>(&storage);\n  }\n\n  BucketT *getInlineBuckets() {\n    return const_cast<BucketT *>(\n      const_cast<const SmallDenseMap *>(this)->getInlineBuckets());\n  }\n\n  const LargeRep *getLargeRep() const {\n    assert(!Small);\n    // Note, same rule about aliasing as with getInlineBuckets.\n    return reinterpret_cast<const LargeRep *>(&storage);\n  }\n\n  LargeRep *getLargeRep() {\n    return const_cast<LargeRep *>(\n      const_cast<const SmallDenseMap *>(this)->getLargeRep());\n  }\n\n  const BucketT *getBuckets() const {\n    return Small ? getInlineBuckets() : getLargeRep()->Buckets;\n  }\n\n  BucketT *getBuckets() {\n    return const_cast<BucketT *>(\n      const_cast<const SmallDenseMap *>(this)->getBuckets());\n  }\n\n  unsigned getNumBuckets() const {\n    return Small ? InlineBuckets : getLargeRep()->NumBuckets;\n  }\n\n  void deallocateBuckets() {\n    if (Small)\n      return;\n\n    deallocate_buffer(getLargeRep()->Buckets,\n                      sizeof(BucketT) * getLargeRep()->NumBuckets,\n                      alignof(BucketT));\n    getLargeRep()->~LargeRep();\n  }\n\n  LargeRep allocateBuckets(unsigned Num) {\n    assert(Num > InlineBuckets && \"Must allocate more buckets than are inline\");\n    LargeRep Rep = {static_cast<BucketT *>(allocate_buffer(\n                        sizeof(BucketT) * Num, alignof(BucketT))),\n                    Num};\n    return Rep;\n  }\n};\n\ntemplate <typename KeyT, typename ValueT, typename KeyInfoT, typename Bucket,\n          bool IsConst>\nclass DenseMapIterator : DebugEpochBase::HandleBase {\n  friend class DenseMapIterator<KeyT, ValueT, KeyInfoT, Bucket, true>;\n  friend class DenseMapIterator<KeyT, ValueT, KeyInfoT, Bucket, false>;\n\npublic:\n  using difference_type = ptrdiff_t;\n  using value_type =\n      typename std::conditional<IsConst, const Bucket, Bucket>::type;\n  using pointer = value_type *;\n  using reference = value_type &;\n  using iterator_category = std::forward_iterator_tag;\n\nprivate:\n  pointer Ptr = nullptr;\n  pointer End = nullptr;\n\npublic:\n  DenseMapIterator() = default;\n\n  DenseMapIterator(pointer Pos, pointer E, const DebugEpochBase &Epoch,\n                   bool NoAdvance = false)\n      : DebugEpochBase::HandleBase(&Epoch), Ptr(Pos), End(E) {\n    assert(isHandleInSync() && \"invalid construction!\");\n\n    if (NoAdvance) return;\n    if (shouldReverseIterate<KeyT>()) {\n      RetreatPastEmptyBuckets();\n      return;\n    }\n    AdvancePastEmptyBuckets();\n  }\n\n  // Converting ctor from non-const iterators to const iterators. SFINAE'd out\n  // for const iterator destinations so it doesn't end up as a user defined copy\n  // constructor.\n  template <bool IsConstSrc,\n            typename = std::enable_if_t<!IsConstSrc && IsConst>>\n  DenseMapIterator(\n      const DenseMapIterator<KeyT, ValueT, KeyInfoT, Bucket, IsConstSrc> &I)\n      : DebugEpochBase::HandleBase(I), Ptr(I.Ptr), End(I.End) {}\n\n  reference operator*() const {\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    assert(Ptr != End && \"dereferencing end() iterator\");\n    if (shouldReverseIterate<KeyT>())\n      return Ptr[-1];\n    return *Ptr;\n  }\n  pointer operator->() const {\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    assert(Ptr != End && \"dereferencing end() iterator\");\n    if (shouldReverseIterate<KeyT>())\n      return &(Ptr[-1]);\n    return Ptr;\n  }\n\n  friend bool operator==(const DenseMapIterator &LHS,\n                         const DenseMapIterator &RHS) {\n    assert((!LHS.Ptr || LHS.isHandleInSync()) && \"handle not in sync!\");\n    assert((!RHS.Ptr || RHS.isHandleInSync()) && \"handle not in sync!\");\n    assert(LHS.getEpochAddress() == RHS.getEpochAddress() &&\n           \"comparing incomparable iterators!\");\n    return LHS.Ptr == RHS.Ptr;\n  }\n\n  friend bool operator!=(const DenseMapIterator &LHS,\n                         const DenseMapIterator &RHS) {\n    return !(LHS == RHS);\n  }\n\n  inline DenseMapIterator& operator++() {  // Preincrement\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    assert(Ptr != End && \"incrementing end() iterator\");\n    if (shouldReverseIterate<KeyT>()) {\n      --Ptr;\n      RetreatPastEmptyBuckets();\n      return *this;\n    }\n    ++Ptr;\n    AdvancePastEmptyBuckets();\n    return *this;\n  }\n  DenseMapIterator operator++(int) {  // Postincrement\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    DenseMapIterator tmp = *this; ++*this; return tmp;\n  }\n\nprivate:\n  void AdvancePastEmptyBuckets() {\n    assert(Ptr <= End);\n    const KeyT Empty = KeyInfoT::getEmptyKey();\n    const KeyT Tombstone = KeyInfoT::getTombstoneKey();\n\n    while (Ptr != End && (KeyInfoT::isEqual(Ptr->getFirst(), Empty) ||\n                          KeyInfoT::isEqual(Ptr->getFirst(), Tombstone)))\n      ++Ptr;\n  }\n\n  void RetreatPastEmptyBuckets() {\n    assert(Ptr >= End);\n    const KeyT Empty = KeyInfoT::getEmptyKey();\n    const KeyT Tombstone = KeyInfoT::getTombstoneKey();\n\n    while (Ptr != End && (KeyInfoT::isEqual(Ptr[-1].getFirst(), Empty) ||\n                          KeyInfoT::isEqual(Ptr[-1].getFirst(), Tombstone)))\n      --Ptr;\n  }\n};\n\ntemplate <typename KeyT, typename ValueT, typename KeyInfoT>\ninline size_t capacity_in_bytes(const DenseMap<KeyT, ValueT, KeyInfoT> &X) {\n  return X.getMemorySize();\n}\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_DENSEMAP_H\n"}, "14": {"id": 14, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/MSF/MSFCommon.h", "content": "//===- MSFCommon.h - Common types and functions for MSF files ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_MSF_MSFCOMMON_H\n#define LLVM_DEBUGINFO_MSF_MSFCOMMON_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/BitVector.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include <cstdint>\n#include <vector>\n\nnamespace llvm {\nnamespace msf {\n\nstatic const char Magic[] = {'M',  'i',  'c',    'r', 'o', 's',  'o',  'f',\n                             't',  ' ',  'C',    '/', 'C', '+',  '+',  ' ',\n                             'M',  'S',  'F',    ' ', '7', '.',  '0',  '0',\n                             '\\r', '\\n', '\\x1a', 'D', 'S', '\\0', '\\0', '\\0'};\n\n// The superblock is overlaid at the beginning of the file (offset 0).\n// It starts with a magic header and is followed by information which\n// describes the layout of the file system.\nstruct SuperBlock {\n  char MagicBytes[sizeof(Magic)];\n  // The file system is split into a variable number of fixed size elements.\n  // These elements are referred to as blocks.  The size of a block may vary\n  // from system to system.\n  support::ulittle32_t BlockSize;\n  // The index of the free block map.\n  support::ulittle32_t FreeBlockMapBlock;\n  // This contains the number of blocks resident in the file system.  In\n  // practice, NumBlocks * BlockSize is equivalent to the size of the MSF\n  // file.\n  support::ulittle32_t NumBlocks;\n  // This contains the number of bytes which make up the directory.\n  support::ulittle32_t NumDirectoryBytes;\n  // This field's purpose is not yet known.\n  support::ulittle32_t Unknown1;\n  // This contains the block # of the block map.\n  support::ulittle32_t BlockMapAddr;\n};\n\nstruct MSFLayout {\n  MSFLayout() = default;\n\n  uint32_t mainFpmBlock() const {\n    assert(SB->FreeBlockMapBlock == 1 || SB->FreeBlockMapBlock == 2);\n    return SB->FreeBlockMapBlock;\n  }\n\n  uint32_t alternateFpmBlock() const {\n    // If mainFpmBlock is 1, this is 2.  If mainFpmBlock is 2, this is 1.\n    return 3U - mainFpmBlock();\n  }\n\n  const SuperBlock *SB = nullptr;\n  BitVector FreePageMap;\n  ArrayRef<support::ulittle32_t> DirectoryBlocks;\n  ArrayRef<support::ulittle32_t> StreamSizes;\n  std::vector<ArrayRef<support::ulittle32_t>> StreamMap;\n};\n\n/// Describes the layout of a stream in an MSF layout.  A \"stream\" here\n/// is defined as any logical unit of data which may be arranged inside the MSF\n/// file as a sequence of (possibly discontiguous) blocks.  When we want to read\n/// from a particular MSF Stream, we fill out a stream layout structure and the\n/// reader uses it to determine which blocks in the underlying MSF file contain\n/// the data, so that it can be pieced together in the right order.\nclass MSFStreamLayout {\npublic:\n  uint32_t Length;\n  std::vector<support::ulittle32_t> Blocks;\n};\n\n/// Determine the layout of the FPM stream, given the MSF layout.  An FPM\n/// stream spans 1 or more blocks, each at equally spaced intervals throughout\n/// the file.\nMSFStreamLayout getFpmStreamLayout(const MSFLayout &Msf,\n                                   bool IncludeUnusedFpmData = false,\n                                   bool AltFpm = false);\n\ninline bool isValidBlockSize(uint32_t Size) {\n  switch (Size) {\n  case 512:\n  case 1024:\n  case 2048:\n  case 4096:\n    return true;\n  }\n  return false;\n}\n\n// Super Block, Fpm0, Fpm1, and Block Map\ninline uint32_t getMinimumBlockCount() { return 4; }\n\n// Super Block, Fpm0, and Fpm1 are reserved.  The Block Map, although required\n// need not be at block 3.\ninline uint32_t getFirstUnreservedBlock() { return 3; }\n\ninline uint64_t bytesToBlocks(uint64_t NumBytes, uint64_t BlockSize) {\n  return divideCeil(NumBytes, BlockSize);\n}\n\ninline uint64_t blockToOffset(uint64_t BlockNumber, uint64_t BlockSize) {\n  return BlockNumber * BlockSize;\n}\n\ninline uint32_t getFpmIntervalLength(const MSFLayout &L) {\n  return L.SB->BlockSize;\n}\n\n/// Given an MSF with the specified block size and number of blocks, determine\n/// how many pieces the specified Fpm is split into.\n/// \\p BlockSize - the block size of the MSF\n/// \\p NumBlocks - the total number of blocks in the MSF\n/// \\p IncludeUnusedFpmData - When true, this will count every block that is\n///    both in the file and matches the form of an FPM block, even if some of\n///    those FPM blocks are unused (a single FPM block can describe the\n///    allocation status of up to 32,767 blocks, although one appears only\n///    every 4,096 blocks).  So there are 8x as many blocks that match the\n///    form as there are blocks that are necessary to describe the allocation\n///    status of the file.  When this parameter is false, these extraneous\n///    trailing blocks are not counted.\ninline uint32_t getNumFpmIntervals(uint32_t BlockSize, uint32_t NumBlocks,\n                                   bool IncludeUnusedFpmData, int FpmNumber) {\n  assert(FpmNumber == 1 || FpmNumber == 2);\n  if (IncludeUnusedFpmData) {\n    // This calculation determines how many times a number of the form\n    // BlockSize * k + N appears in the range [0, NumBlocks).  We only need to\n    // do this when unused data is included, since the number of blocks dwarfs\n    // the number of fpm blocks.\n    return divideCeil(NumBlocks - FpmNumber, BlockSize);\n  }\n\n  // We want the minimum number of intervals required, where each interval can\n  // represent BlockSize * 8 blocks.\n  return divideCeil(NumBlocks, 8 * BlockSize);\n}\n\ninline uint32_t getNumFpmIntervals(const MSFLayout &L,\n                                   bool IncludeUnusedFpmData = false,\n                                   bool AltFpm = false) {\n  return getNumFpmIntervals(L.SB->BlockSize, L.SB->NumBlocks,\n                            IncludeUnusedFpmData,\n                            AltFpm ? L.alternateFpmBlock() : L.mainFpmBlock());\n}\n\nError validateSuperBlock(const SuperBlock &SB);\n\n} // end namespace msf\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_MSF_MSFCOMMON_H\n"}, "15": {"id": 15, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/MSF/MappedBlockStream.h", "content": "//==- MappedBlockStream.h - Discontiguous stream data in an MSF --*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_DEBUGINFO_MSF_MAPPEDBLOCKSTREAM_H\n#define LLVM_DEBUGINFO_MSF_MAPPEDBLOCKSTREAM_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/DebugInfo/MSF/MSFCommon.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/BinaryStream.h\"\n#include \"llvm/Support/BinaryStreamRef.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/Error.h\"\n#include <cstdint>\n#include <memory>\n#include <vector>\n\nnamespace llvm {\nnamespace msf {\n\n/// MappedBlockStream represents data stored in an MSF file into chunks of a\n/// particular size (called the Block Size), and whose chunks may not be\n/// necessarily contiguous.  The arrangement of these chunks MSF the file\n/// is described by some other metadata contained within the MSF file.  In\n/// the case of a standard MSF Stream, the layout of the stream's blocks\n/// is described by the MSF \"directory\", but in the case of the directory\n/// itself, the layout is described by an array at a fixed location within\n/// the MSF.  MappedBlockStream provides methods for reading from and writing\n/// to one of these streams transparently, as if it were a contiguous sequence\n/// of bytes.\nclass MappedBlockStream : public BinaryStream {\n  friend class WritableMappedBlockStream;\n\npublic:\n  static std::unique_ptr<MappedBlockStream>\n  createStream(uint32_t BlockSize, const MSFStreamLayout &Layout,\n               BinaryStreamRef MsfData, BumpPtrAllocator &Allocator);\n\n  static std::unique_ptr<MappedBlockStream>\n  createIndexedStream(const MSFLayout &Layout, BinaryStreamRef MsfData,\n                      uint32_t StreamIndex, BumpPtrAllocator &Allocator);\n\n  static std::unique_ptr<MappedBlockStream>\n  createFpmStream(const MSFLayout &Layout, BinaryStreamRef MsfData,\n                  BumpPtrAllocator &Allocator);\n\n  static std::unique_ptr<MappedBlockStream>\n  createDirectoryStream(const MSFLayout &Layout, BinaryStreamRef MsfData,\n                        BumpPtrAllocator &Allocator);\n\n  support::endianness getEndian() const override {\n    return support::little;\n  }\n\n  Error readBytes(uint32_t Offset, uint32_t Size,\n                  ArrayRef<uint8_t> &Buffer) override;\n  Error readLongestContiguousChunk(uint32_t Offset,\n                                   ArrayRef<uint8_t> &Buffer) override;\n\n  uint32_t getLength() override;\n\n  BumpPtrAllocator &getAllocator() { return Allocator; }\n\n  void invalidateCache();\n\n  uint32_t getBlockSize() const { return BlockSize; }\n  uint32_t getNumBlocks() const { return StreamLayout.Blocks.size(); }\n  uint32_t getStreamLength() const { return StreamLayout.Length; }\n\nprotected:\n  MappedBlockStream(uint32_t BlockSize, const MSFStreamLayout &StreamLayout,\n                    BinaryStreamRef MsfData, BumpPtrAllocator &Allocator);\n\nprivate:\n  const MSFStreamLayout &getStreamLayout() const { return StreamLayout; }\n  void fixCacheAfterWrite(uint32_t Offset, ArrayRef<uint8_t> Data) const;\n\n  Error readBytes(uint32_t Offset, MutableArrayRef<uint8_t> Buffer);\n  bool tryReadContiguously(uint32_t Offset, uint32_t Size,\n                           ArrayRef<uint8_t> &Buffer);\n\n  const uint32_t BlockSize;\n  const MSFStreamLayout StreamLayout;\n  BinaryStreamRef MsfData;\n\n  using CacheEntry = MutableArrayRef<uint8_t>;\n\n  // We just store the allocator by reference.  We use this to allocate\n  // contiguous memory for things like arrays or strings that cross a block\n  // boundary, and this memory is expected to outlive the stream.  For example,\n  // someone could create a stream, read some stuff, then close the stream, and\n  // we would like outstanding references to fields to remain valid since the\n  // entire file is mapped anyway.  Because of that, the user must supply the\n  // allocator to allocate broken records from.\n  BumpPtrAllocator &Allocator;\n  DenseMap<uint32_t, std::vector<CacheEntry>> CacheMap;\n};\n\nclass WritableMappedBlockStream : public WritableBinaryStream {\npublic:\n  static std::unique_ptr<WritableMappedBlockStream>\n  createStream(uint32_t BlockSize, const MSFStreamLayout &Layout,\n               WritableBinaryStreamRef MsfData, BumpPtrAllocator &Allocator);\n\n  static std::unique_ptr<WritableMappedBlockStream>\n  createIndexedStream(const MSFLayout &Layout, WritableBinaryStreamRef MsfData,\n                      uint32_t StreamIndex, BumpPtrAllocator &Allocator);\n\n  static std::unique_ptr<WritableMappedBlockStream>\n  createDirectoryStream(const MSFLayout &Layout,\n                        WritableBinaryStreamRef MsfData,\n                        BumpPtrAllocator &Allocator);\n\n  static std::unique_ptr<WritableMappedBlockStream>\n  createFpmStream(const MSFLayout &Layout, WritableBinaryStreamRef MsfData,\n                  BumpPtrAllocator &Allocator, bool AltFpm = false);\n\n  support::endianness getEndian() const override {\n    return support::little;\n  }\n\n  Error readBytes(uint32_t Offset, uint32_t Size,\n                  ArrayRef<uint8_t> &Buffer) override;\n  Error readLongestContiguousChunk(uint32_t Offset,\n                                   ArrayRef<uint8_t> &Buffer) override;\n  uint32_t getLength() override;\n\n  Error writeBytes(uint32_t Offset, ArrayRef<uint8_t> Buffer) override;\n\n  Error commit() override;\n\n  const MSFStreamLayout &getStreamLayout() const {\n    return ReadInterface.getStreamLayout();\n  }\n\n  uint32_t getBlockSize() const { return ReadInterface.getBlockSize(); }\n  uint32_t getNumBlocks() const { return ReadInterface.getNumBlocks(); }\n  uint32_t getStreamLength() const { return ReadInterface.getStreamLength(); }\n\nprotected:\n  WritableMappedBlockStream(uint32_t BlockSize,\n                            const MSFStreamLayout &StreamLayout,\n                            WritableBinaryStreamRef MsfData,\n                            BumpPtrAllocator &Allocator);\n\nprivate:\n  MappedBlockStream ReadInterface;\n  WritableBinaryStreamRef WriteInterface;\n};\n\n} // end namespace pdb\n} // end namespace llvm\n\n#endif // LLVM_DEBUGINFO_MSF_MAPPEDBLOCKSTREAM_H\n"}, "22": {"id": 22, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BinaryStreamRef.h", "content": "//===- BinaryStreamRef.h - A copyable reference to a stream -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_BINARYSTREAMREF_H\n#define LLVM_SUPPORT_BINARYSTREAMREF_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/Support/BinaryStream.h\"\n#include \"llvm/Support/BinaryStreamError.h\"\n#include \"llvm/Support/Error.h\"\n#include <algorithm>\n#include <cstdint>\n#include <memory>\n\nnamespace llvm {\n\n/// Common stuff for mutable and immutable StreamRefs.\ntemplate <class RefType, class StreamType> class BinaryStreamRefBase {\nprotected:\n  BinaryStreamRefBase() = default;\n  explicit BinaryStreamRefBase(StreamType &BorrowedImpl)\n      : BorrowedImpl(&BorrowedImpl), ViewOffset(0) {\n    if (!(BorrowedImpl.getFlags() & BSF_Append))\n      Length = BorrowedImpl.getLength();\n  }\n\n  BinaryStreamRefBase(std::shared_ptr<StreamType> SharedImpl, uint32_t Offset,\n                      Optional<uint32_t> Length)\n      : SharedImpl(SharedImpl), BorrowedImpl(SharedImpl.get()),\n        ViewOffset(Offset), Length(Length) {}\n  BinaryStreamRefBase(StreamType &BorrowedImpl, uint32_t Offset,\n                      Optional<uint32_t> Length)\n      : BorrowedImpl(&BorrowedImpl), ViewOffset(Offset), Length(Length) {}\n  BinaryStreamRefBase(const BinaryStreamRefBase &Other) = default;\n  BinaryStreamRefBase &operator=(const BinaryStreamRefBase &Other) = default;\n\n  BinaryStreamRefBase &operator=(BinaryStreamRefBase &&Other) = default;\n  BinaryStreamRefBase(BinaryStreamRefBase &&Other) = default;\n\npublic:\n  llvm::support::endianness getEndian() const {\n    return BorrowedImpl->getEndian();\n  }\n\n  uint32_t getLength() const {\n    if (Length.hasValue())\n      return *Length;\n\n    return BorrowedImpl ? (BorrowedImpl->getLength() - ViewOffset) : 0;\n  }\n\n  /// Return a new BinaryStreamRef with the first \\p N elements removed.  If\n  /// this BinaryStreamRef is length-tracking, then the resulting one will be\n  /// too.\n  RefType drop_front(uint32_t N) const {\n    if (!BorrowedImpl)\n      return RefType();\n\n    N = std::min(N, getLength());\n    RefType Result(static_cast<const RefType &>(*this));\n    if (N == 0)\n      return Result;\n\n    Result.ViewOffset += N;\n    if (Result.Length.hasValue())\n      *Result.Length -= N;\n    return Result;\n  }\n\n  /// Return a new BinaryStreamRef with the last \\p N elements removed.  If\n  /// this BinaryStreamRef is length-tracking and \\p N is greater than 0, then\n  /// this BinaryStreamRef will no longer length-track.\n  RefType drop_back(uint32_t N) const {\n    if (!BorrowedImpl)\n      return RefType();\n\n    RefType Result(static_cast<const RefType &>(*this));\n    N = std::min(N, getLength());\n\n    if (N == 0)\n      return Result;\n\n    // Since we're dropping non-zero bytes from the end, stop length-tracking\n    // by setting the length of the resulting StreamRef to an explicit value.\n    if (!Result.Length.hasValue())\n      Result.Length = getLength();\n\n    *Result.Length -= N;\n    return Result;\n  }\n\n  /// Return a new BinaryStreamRef with only the first \\p N elements remaining.\n  RefType keep_front(uint32_t N) const {\n    assert(N <= getLength());\n    return drop_back(getLength() - N);\n  }\n\n  /// Return a new BinaryStreamRef with only the last \\p N elements remaining.\n  RefType keep_back(uint32_t N) const {\n    assert(N <= getLength());\n    return drop_front(getLength() - N);\n  }\n\n  /// Return a new BinaryStreamRef with the first and last \\p N elements\n  /// removed.\n  RefType drop_symmetric(uint32_t N) const {\n    return drop_front(N).drop_back(N);\n  }\n\n  /// Return a new BinaryStreamRef with the first \\p Offset elements removed,\n  /// and retaining exactly \\p Len elements.\n  RefType slice(uint32_t Offset, uint32_t Len) const {\n    return drop_front(Offset).keep_front(Len);\n  }\n\n  bool valid() const { return BorrowedImpl != nullptr; }\n\n  friend bool operator==(const RefType &LHS, const RefType &RHS) {\n    if (LHS.BorrowedImpl != RHS.BorrowedImpl)\n      return false;\n    if (LHS.ViewOffset != RHS.ViewOffset)\n      return false;\n    if (LHS.Length != RHS.Length)\n      return false;\n    return true;\n  }\n\nprotected:\n  Error checkOffsetForRead(uint32_t Offset, uint32_t DataSize) const {\n    if (Offset > getLength())\n      return make_error<BinaryStreamError>(stream_error_code::invalid_offset);\n    if (getLength() < DataSize + Offset)\n      return make_error<BinaryStreamError>(stream_error_code::stream_too_short);\n    return Error::success();\n  }\n\n  std::shared_ptr<StreamType> SharedImpl;\n  StreamType *BorrowedImpl = nullptr;\n  uint32_t ViewOffset = 0;\n  Optional<uint32_t> Length;\n};\n\n/// BinaryStreamRef is to BinaryStream what ArrayRef is to an Array.  It\n/// provides copy-semantics and read only access to a \"window\" of the underlying\n/// BinaryStream. Note that BinaryStreamRef is *not* a BinaryStream.  That is to\n/// say, it does not inherit and override the methods of BinaryStream.  In\n/// general, you should not pass around pointers or references to BinaryStreams\n/// and use inheritance to achieve polymorphism.  Instead, you should pass\n/// around BinaryStreamRefs by value and achieve polymorphism that way.\nclass BinaryStreamRef\n    : public BinaryStreamRefBase<BinaryStreamRef, BinaryStream> {\n  friend BinaryStreamRefBase<BinaryStreamRef, BinaryStream>;\n  friend class WritableBinaryStreamRef;\n  BinaryStreamRef(std::shared_ptr<BinaryStream> Impl, uint32_t ViewOffset,\n                  Optional<uint32_t> Length)\n      : BinaryStreamRefBase(Impl, ViewOffset, Length) {}\n\npublic:\n  BinaryStreamRef() = default;\n  BinaryStreamRef(BinaryStream &Stream);\n  BinaryStreamRef(BinaryStream &Stream, uint32_t Offset,\n                  Optional<uint32_t> Length);\n  explicit BinaryStreamRef(ArrayRef<uint8_t> Data,\n                           llvm::support::endianness Endian);\n  explicit BinaryStreamRef(StringRef Data, llvm::support::endianness Endian);\n\n  BinaryStreamRef(const BinaryStreamRef &Other) = default;\n  BinaryStreamRef &operator=(const BinaryStreamRef &Other) = default;\n  BinaryStreamRef(BinaryStreamRef &&Other) = default;\n  BinaryStreamRef &operator=(BinaryStreamRef &&Other) = default;\n\n  // Use BinaryStreamRef.slice() instead.\n  BinaryStreamRef(BinaryStreamRef &S, uint32_t Offset,\n                  uint32_t Length) = delete;\n\n  /// Given an Offset into this StreamRef and a Size, return a reference to a\n  /// buffer owned by the stream.\n  ///\n  /// \\returns a success error code if the entire range of data is within the\n  /// bounds of this BinaryStreamRef's view and the implementation could read\n  /// the data, and an appropriate error code otherwise.\n  Error readBytes(uint32_t Offset, uint32_t Size,\n                  ArrayRef<uint8_t> &Buffer) const;\n\n  /// Given an Offset into this BinaryStreamRef, return a reference to the\n  /// largest buffer the stream could support without necessitating a copy.\n  ///\n  /// \\returns a success error code if implementation could read the data,\n  /// and an appropriate error code otherwise.\n  Error readLongestContiguousChunk(uint32_t Offset,\n                                   ArrayRef<uint8_t> &Buffer) const;\n};\n\nstruct BinarySubstreamRef {\n  uint32_t Offset = 0;        // Offset in the parent stream\n  BinaryStreamRef StreamData; // Stream Data\n\n  BinarySubstreamRef slice(uint32_t Off, uint32_t Size) const {\n    BinaryStreamRef SubSub = StreamData.slice(Off, Size);\n    return {Off + Offset, SubSub};\n  }\n  BinarySubstreamRef drop_front(uint32_t N) const {\n    return slice(N, size() - N);\n  }\n  BinarySubstreamRef keep_front(uint32_t N) const { return slice(0, N); }\n\n  std::pair<BinarySubstreamRef, BinarySubstreamRef>\n  split(uint32_t Off) const {\n    return std::make_pair(keep_front(Off), drop_front(Off));\n  }\n\n  uint32_t size() const { return StreamData.getLength(); }\n  bool empty() const { return size() == 0; }\n};\n\nclass WritableBinaryStreamRef\n    : public BinaryStreamRefBase<WritableBinaryStreamRef,\n                                 WritableBinaryStream> {\n  friend BinaryStreamRefBase<WritableBinaryStreamRef, WritableBinaryStream>;\n  WritableBinaryStreamRef(std::shared_ptr<WritableBinaryStream> Impl,\n                          uint32_t ViewOffset, Optional<uint32_t> Length)\n      : BinaryStreamRefBase(Impl, ViewOffset, Length) {}\n\n  Error checkOffsetForWrite(uint32_t Offset, uint32_t DataSize) const {\n    if (!(BorrowedImpl->getFlags() & BSF_Append))\n      return checkOffsetForRead(Offset, DataSize);\n\n    if (Offset > getLength())\n      return make_error<BinaryStreamError>(stream_error_code::invalid_offset);\n    return Error::success();\n  }\n\npublic:\n  WritableBinaryStreamRef() = default;\n  WritableBinaryStreamRef(WritableBinaryStream &Stream);\n  WritableBinaryStreamRef(WritableBinaryStream &Stream, uint32_t Offset,\n                          Optional<uint32_t> Length);\n  explicit WritableBinaryStreamRef(MutableArrayRef<uint8_t> Data,\n                                   llvm::support::endianness Endian);\n  WritableBinaryStreamRef(const WritableBinaryStreamRef &Other) = default;\n  WritableBinaryStreamRef &\n  operator=(const WritableBinaryStreamRef &Other) = default;\n\n  WritableBinaryStreamRef(WritableBinaryStreamRef &&Other) = default;\n  WritableBinaryStreamRef &operator=(WritableBinaryStreamRef &&Other) = default;\n\n  // Use WritableBinaryStreamRef.slice() instead.\n  WritableBinaryStreamRef(WritableBinaryStreamRef &S, uint32_t Offset,\n                          uint32_t Length) = delete;\n\n  /// Given an Offset into this WritableBinaryStreamRef and some input data,\n  /// writes the data to the underlying stream.\n  ///\n  /// \\returns a success error code if the data could fit within the underlying\n  /// stream at the specified location and the implementation could write the\n  /// data, and an appropriate error code otherwise.\n  Error writeBytes(uint32_t Offset, ArrayRef<uint8_t> Data) const;\n\n  /// Conver this WritableBinaryStreamRef to a read-only BinaryStreamRef.\n  operator BinaryStreamRef() const;\n\n  /// For buffered streams, commits changes to the backing store.\n  Error commit();\n};\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_BINARYSTREAMREF_H\n"}, "32": {"id": 32, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Testing/Support/SupportHelpers.h", "content": "//===- Testing/Support/SupportHelpers.h -----------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TESTING_SUPPORT_SUPPORTHELPERS_H\n#define LLVM_TESTING_SUPPORT_SUPPORTHELPERS_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/FileSystem.h\"\n#include \"llvm/Support/Path.h\"\n#include \"llvm/Support/raw_os_ostream.h\"\n#include \"gmock/gmock-matchers.h\"\n#include \"gtest/gtest-printers.h\"\n\n#include <string>\n\nnamespace llvm {\nnamespace detail {\nstruct ErrorHolder {\n  std::vector<std::shared_ptr<ErrorInfoBase>> Infos;\n\n  bool Success() const { return Infos.empty(); }\n};\n\ntemplate <typename T> struct ExpectedHolder : public ErrorHolder {\n  ExpectedHolder(ErrorHolder Err, Expected<T> &Exp)\n      : ErrorHolder(std::move(Err)), Exp(Exp) {}\n\n  Expected<T> &Exp;\n};\n\ninline void PrintTo(const ErrorHolder &Err, std::ostream *Out) {\n  raw_os_ostream OS(*Out);\n  OS << (Err.Success() ? \"succeeded\" : \"failed\");\n  if (!Err.Success()) {\n    const char *Delim = \"  (\";\n    for (const auto &Info : Err.Infos) {\n      OS << Delim;\n      Delim = \"; \";\n      Info->log(OS);\n    }\n    OS << \")\";\n  }\n}\n\ntemplate <typename T>\nvoid PrintTo(const ExpectedHolder<T> &Item, std::ostream *Out) {\n  if (Item.Success()) {\n    *Out << \"succeeded with value \" << ::testing::PrintToString(*Item.Exp);\n  } else {\n    PrintTo(static_cast<const ErrorHolder &>(Item), Out);\n  }\n}\n\ntemplate <class InnerMatcher> class ValueIsMatcher {\npublic:\n  explicit ValueIsMatcher(InnerMatcher ValueMatcher)\n      : ValueMatcher(ValueMatcher) {}\n\n  template <class T>\n  operator ::testing::Matcher<const llvm::Optional<T> &>() const {\n    return ::testing::MakeMatcher(\n        new Impl<T>(::testing::SafeMatcherCast<T>(ValueMatcher)));\n  }\n\n  template <class T>\n  class Impl : public ::testing::MatcherInterface<const llvm::Optional<T> &> {\n  public:\n    explicit Impl(const ::testing::Matcher<T> &ValueMatcher)\n        : ValueMatcher(ValueMatcher) {}\n\n    bool MatchAndExplain(const llvm::Optional<T> &Input,\n                         testing::MatchResultListener *L) const override {\n      return Input && ValueMatcher.MatchAndExplain(Input.getValue(), L);\n    }\n\n    void DescribeTo(std::ostream *OS) const override {\n      *OS << \"has a value that \";\n      ValueMatcher.DescribeTo(OS);\n    }\n    void DescribeNegationTo(std::ostream *OS) const override {\n      *OS << \"does not have a value that \";\n      ValueMatcher.DescribeTo(OS);\n    }\n\n  private:\n    testing::Matcher<T> ValueMatcher;\n  };\n\nprivate:\n  InnerMatcher ValueMatcher;\n};\n} // namespace detail\n\n/// Matches an llvm::Optional<T> with a value that conforms to an inner matcher.\n/// To match llvm::None you could use Eq(llvm::None).\ntemplate <class InnerMatcher>\ndetail::ValueIsMatcher<InnerMatcher> ValueIs(const InnerMatcher &ValueMatcher) {\n  return detail::ValueIsMatcher<InnerMatcher>(ValueMatcher);\n}\nnamespace unittest {\n\nSmallString<128> getInputFileDirectory(const char *Argv0);\n\n/// A RAII object that creates a temporary directory upon initialization and\n/// removes it upon destruction.\nclass TempDir {\n  SmallString<128> Path;\n\npublic:\n  /// Creates a managed temporary directory.\n  ///\n  /// @param Name The name of the directory to create.\n  /// @param Unique If true, the directory will be created using\n  ///               llvm::sys::fs::createUniqueDirectory.\n  explicit TempDir(StringRef Name, bool Unique = false) {\n    std::error_code EC;\n    if (Unique) {\n      EC = llvm::sys::fs::createUniqueDirectory(Name, Path);\n      if (!EC) {\n        // Resolve any symlinks in the new directory.\n        std::string UnresolvedPath(Path.str());\n        EC = llvm::sys::fs::real_path(UnresolvedPath, Path);\n      }\n    } else {\n      Path = Name;\n      EC = llvm::sys::fs::create_directory(Path);\n    }\n    if (EC)\n      Path.clear();\n    EXPECT_FALSE(EC) << EC.message();\n  }\n\n  ~TempDir() {\n    if (!Path.empty()) {\n      EXPECT_FALSE(llvm::sys::fs::remove_directories(Path.str()));\n    }\n  }\n\n  TempDir(const TempDir &) = delete;\n  TempDir &operator=(const TempDir &) = delete;\n\n  TempDir(TempDir &&) = default;\n  TempDir &operator=(TempDir &&) = default;\n\n  /// The path to the temporary directory.\n  StringRef path() const { return Path; }\n\n  /// The null-terminated C string pointing to the path.\n  const char *c_str() { return Path.c_str(); }\n\n  /// Creates a new path by appending the argument to the path of the managed\n  /// directory using the native path separator.\n  SmallString<128> path(StringRef component) const {\n    SmallString<128> Result(Path);\n    SmallString<128> ComponentToAppend(component);\n    llvm::sys::path::native(ComponentToAppend);\n    llvm::sys::path::append(Result, Twine(ComponentToAppend));\n    return Result;\n  }\n};\n\n/// A RAII object that creates a link upon initialization and\n/// removes it upon destruction.\n///\n/// The link may be a soft or a hard link, depending on the platform.\nclass TempLink {\n  SmallString<128> Path;\n\npublic:\n  /// Creates a managed link at path Link pointing to Target.\n  TempLink(StringRef Target, StringRef Link) {\n    Path = Link;\n    std::error_code EC = sys::fs::create_link(Target, Link);\n    if (EC)\n      Path.clear();\n    EXPECT_FALSE(EC);\n  }\n  ~TempLink() {\n    if (!Path.empty()) {\n      EXPECT_FALSE(llvm::sys::fs::remove(Path.str()));\n    }\n  }\n\n  TempLink(const TempLink &) = delete;\n  TempLink &operator=(const TempLink &) = delete;\n\n  TempLink(TempLink &&) = default;\n  TempLink &operator=(TempLink &&) = default;\n\n  /// The path to the link.\n  StringRef path() const { return Path; }\n};\n\n/// A RAII object that creates a file upon initialization and\n/// removes it upon destruction.\nclass TempFile {\n  SmallString<128> Path;\n\npublic:\n  /// Creates a managed file.\n  ///\n  /// @param Name The name of the file to create.\n  /// @param Contents The string to write to the file.\n  /// @param Unique If true, the file will be created using\n  ///               llvm::sys::fs::createTemporaryFile.\n  TempFile(StringRef Name, StringRef Suffix = \"\", StringRef Contents = \"\",\n           bool Unique = false) {\n    std::error_code EC;\n    int fd;\n    if (Unique) {\n      EC = llvm::sys::fs::createTemporaryFile(Name, Suffix, fd, Path);\n    } else {\n      Path = Name;\n      if (!Suffix.empty()) {\n        Path.append(\".\");\n        Path.append(Suffix);\n      }\n      EC = llvm::sys::fs::openFileForWrite(Path, fd);\n    }\n    EXPECT_FALSE(EC);\n    raw_fd_ostream OS(fd, /*shouldClose*/ true);\n    OS << Contents;\n    OS.flush();\n    EXPECT_FALSE(OS.error());\n    if (EC || OS.error())\n      Path.clear();\n  }\n  ~TempFile() {\n    if (!Path.empty()) {\n      EXPECT_FALSE(llvm::sys::fs::remove(Path.str()));\n    }\n  }\n\n  /// The path to the file.\n  StringRef path() const { return Path; }\n};\n\n} // namespace unittest\n} // namespace llvm\n\n#endif\n"}, "33": {"id": 33, "path": "/home/vsts/work/1/llvm-project/llvm/unittests/DebugInfo/MSF/MappedBlockStreamTest.cpp", "content": "//===- llvm/unittest/DebugInfo/MSF/MappedBlockStreamTest.cpp --------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/DebugInfo/MSF/MappedBlockStream.h\"\n#include \"llvm/Support/BinaryByteStream.h\"\n#include \"llvm/Support/BinaryStreamReader.h\"\n#include \"llvm/Support/BinaryStreamRef.h\"\n#include \"llvm/Support/BinaryStreamWriter.h\"\n#include \"llvm/Testing/Support/Error.h\"\n\n#include \"gmock/gmock.h\"\n#include \"gtest/gtest.h\"\n\n\nusing namespace llvm;\nusing namespace llvm::msf;\nusing namespace llvm::support;\n\nnamespace {\n\nstatic const uint32_t BlocksAry[] = {0, 1, 2, 5, 4, 3, 6, 7, 8, 9};\nstatic uint8_t DataAry[] = {'A', 'B', 'C', 'F', 'E', 'D', 'G', 'H', 'I', 'J'};\n\nclass DiscontiguousStream : public WritableBinaryStream {\npublic:\n  DiscontiguousStream(ArrayRef<uint32_t> Blocks, MutableArrayRef<uint8_t> Data)\n      : Blocks(Blocks.begin(), Blocks.end()), Data(Data.begin(), Data.end()) {}\n\n  uint32_t block_size() const { return 1; }\n  uint32_t block_count() const { return Blocks.size(); }\n\n  endianness getEndian() const override { return little; }\n\n  Error readBytes(uint32_t Offset, uint32_t Size,\n                  ArrayRef<uint8_t> &Buffer) override {\n    if (auto EC = checkOffsetForRead(Offset, Size))\n      return EC;\n    Buffer = Data.slice(Offset, Size);\n    return Error::success();\n  }\n\n  Error readLongestContiguousChunk(uint32_t Offset,\n                                   ArrayRef<uint8_t> &Buffer) override {\n    if (auto EC = checkOffsetForRead(Offset, 1))\n      return EC;\n    Buffer = Data.drop_front(Offset);\n    return Error::success();\n  }\n\n  uint32_t getLength() override { return Data.size(); }\n\n  Error writeBytes(uint32_t Offset, ArrayRef<uint8_t> SrcData) override {\n    if (auto EC = checkOffsetForWrite(Offset, SrcData.size()))\n      return EC;\n    ::memcpy(&Data[Offset], SrcData.data(), SrcData.size());\n    return Error::success();\n  }\n  Error commit() override { return Error::success(); }\n\n  MSFStreamLayout layout() const {\n    return MSFStreamLayout{static_cast<uint32_t>(Data.size()), Blocks};\n  }\n\n  BumpPtrAllocator Allocator;\n\nprivate:\n  std::vector<support::ulittle32_t> Blocks;\n  MutableArrayRef<uint8_t> Data;\n};\n\nTEST(MappedBlockStreamTest, NumBlocks) {\n  DiscontiguousStream F(BlocksAry, DataAry);\n  auto S = MappedBlockStream::createStream(F.block_size(), F.layout(), F,\n                                           F.Allocator);\n  EXPECT_EQ(F.block_size(), S->getBlockSize());\n  EXPECT_EQ(F.layout().Blocks.size(), S->getNumBlocks());\n}\n\n// Tests that a read which is entirely contained within a single block works\n// and does not allocate.\nTEST(MappedBlockStreamTest, ReadBeyondEndOfStreamRef) {\n  DiscontiguousStream F(BlocksAry, DataAry);\n  auto S = MappedBlockStream::createStream(F.block_size(), F.layout(), F,\n                                           F.Allocator);\n\n  BinaryStreamReader R(*S);\n  BinaryStreamRef SR;\n  EXPECT_THAT_ERROR(R.readStreamRef(SR, 0U), Succeeded());\n  ArrayRef<uint8_t> Buffer;\n  EXPECT_THAT_ERROR(SR.readBytes(0U, 1U, Buffer), Failed());\n  EXPECT_THAT_ERROR(R.readStreamRef(SR, 1U), Succeeded());\n  EXPECT_THAT_ERROR(SR.readBytes(1U, 1U, Buffer), Failed());\n}\n\n// Tests that a read which outputs into a full destination buffer works and\n// does not fail due to the length of the output buffer.\nTEST(MappedBlockStreamTest, ReadOntoNonEmptyBuffer) {\n  DiscontiguousStream F(BlocksAry, DataAry);\n  auto S = MappedBlockStream::createStream(F.block_size(), F.layout(), F,\n                                           F.Allocator);\n\n  BinaryStreamReader R(*S);\n  StringRef Str = \"ZYXWVUTSRQPONMLKJIHGFEDCBA\";\n  EXPECT_THAT_ERROR(R.readFixedString(Str, 1), Succeeded());\n  EXPECT_EQ(Str, StringRef(\"A\"));\n  EXPECT_EQ(0U, F.Allocator.getBytesAllocated());\n}\n\n// Tests that a read which crosses a block boundary, but where the subsequent\n// blocks are still contiguous in memory to the previous block works and does\n// not allocate memory.\nTEST(MappedBlockStreamTest, ZeroCopyReadContiguousBreak) {\n  DiscontiguousStream F(BlocksAry, DataAry);\n  auto S = MappedBlockStream::createStream(F.block_size(), F.layout(), F,\n                                           F.Allocator);\n  BinaryStreamReader R(*S);\n  StringRef Str;\n  EXPECT_THAT_ERROR(R.readFixedString(Str, 2), Succeeded());\n  EXPECT_EQ(Str, StringRef(\"AB\"));\n  EXPECT_EQ(0U, F.Allocator.getBytesAllocated());\n\n  R.setOffset(6);\n  EXPECT_THAT_ERROR(R.readFixedString(Str, 4), Succeeded());\n  EXPECT_EQ(Str, StringRef(\"GHIJ\"));\n  EXPECT_EQ(0U, F.Allocator.getBytesAllocated());\n}\n\n// Tests that a read which crosses a block boundary and cannot be referenced\n// contiguously works and allocates only the precise amount of bytes\n// requested.\nTEST(MappedBlockStreamTest, CopyReadNonContiguousBreak) {\n  DiscontiguousStream F(BlocksAry, DataAry);\n  auto S = MappedBlockStream::createStream(F.block_size(), F.layout(), F,\n                                           F.Allocator);\n  BinaryStreamReader R(*S);\n  StringRef Str;\n  EXPECT_THAT_ERROR(R.readFixedString(Str, 10), Succeeded());\n  EXPECT_EQ(Str, StringRef(\"ABCDEFGHIJ\"));\n  EXPECT_EQ(10U, F.Allocator.getBytesAllocated());\n}\n\n// Test that an out of bounds read which doesn't cross a block boundary\n// fails and allocates no memory.\nTEST(MappedBlockStreamTest, InvalidReadSizeNoBreak) {\n  DiscontiguousStream F(BlocksAry, DataAry);\n  auto S = MappedBlockStream::createStream(F.block_size(), F.layout(), F,\n                                           F.Allocator);\n  BinaryStreamReader R(*S);\n  StringRef Str;\n\n  R.setOffset(10);\n  EXPECT_THAT_ERROR(R.readFixedString(Str, 1), Failed());\n  EXPECT_EQ(0U, F.Allocator.getBytesAllocated());\n}\n\n// Test that an out of bounds read which crosses a contiguous block boundary\n// fails and allocates no memory.\nTEST(MappedBlockStreamTest, InvalidReadSizeContiguousBreak) {\n  DiscontiguousStream F(BlocksAry, DataAry);\n  auto S = MappedBlockStream::createStream(F.block_size(), F.layout(), F,\n                                           F.Allocator);\n  BinaryStreamReader R(*S);\n  StringRef Str;\n\n  R.setOffset(6);\n  EXPECT_THAT_ERROR(R.readFixedString(Str, 5), Failed());\n  EXPECT_EQ(0U, F.Allocator.getBytesAllocated());\n}\n\n// Test that an out of bounds read which crosses a discontiguous block\n// boundary fails and allocates no memory.\nTEST(MappedBlockStreamTest, InvalidReadSizeNonContiguousBreak) {\n  DiscontiguousStream F(BlocksAry, DataAry);\n  auto S = MappedBlockStream::createStream(F.block_size(), F.layout(), F,\n                                           F.Allocator);\n  BinaryStreamReader R(*S);\n  StringRef Str;\n\n  EXPECT_THAT_ERROR(R.readFixedString(Str, 11), Failed());\n  EXPECT_EQ(0U, F.Allocator.getBytesAllocated());\n}\n\n// Tests that a read which is entirely contained within a single block but\n// beyond the end of a StreamRef fails.\nTEST(MappedBlockStreamTest, ZeroCopyReadNoBreak) {\n  DiscontiguousStream F(BlocksAry, DataAry);\n  auto S = MappedBlockStream::createStream(F.block_size(), F.layout(), F,\n                                           F.Allocator);\n  BinaryStreamReader R(*S);\n  StringRef Str;\n  EXPECT_THAT_ERROR(R.readFixedString(Str, 1), Succeeded());\n  EXPECT_EQ(Str, StringRef(\"A\"));\n  EXPECT_EQ(0U, F.Allocator.getBytesAllocated());\n}\n\n// Tests that a read which is not aligned on the same boundary as a previous\n// cached request, but which is known to overlap that request, shares the\n// previous allocation.\nTEST(MappedBlockStreamTest, UnalignedOverlappingRead) {\n  DiscontiguousStream F(BlocksAry, DataAry);\n  auto S = MappedBlockStream::createStream(F.block_size(), F.layout(), F,\n                                           F.Allocator);\n  BinaryStreamReader R(*S);\n  StringRef Str1;\n  StringRef Str2;\n  EXPECT_THAT_ERROR(R.readFixedString(Str1, 7), Succeeded());\n  EXPECT_EQ(Str1, StringRef(\"ABCDEFG\"));\n  EXPECT_EQ(7U, F.Allocator.getBytesAllocated());\n\n  R.setOffset(2);\n  EXPECT_THAT_ERROR(R.readFixedString(Str2, 3), Succeeded());\n  EXPECT_EQ(Str2, StringRef(\"CDE\"));\n  EXPECT_EQ(Str1.data() + 2, Str2.data());\n  EXPECT_EQ(7U, F.Allocator.getBytesAllocated());\n}\n\n// Tests that a read which is not aligned on the same boundary as a previous\n// cached request, but which only partially overlaps a previous cached request,\n// still works correctly and allocates again from the shared pool.\nTEST(MappedBlockStreamTest, UnalignedOverlappingReadFail) {\n  DiscontiguousStream F(BlocksAry, DataAry);\n  auto S = MappedBlockStream::createStream(F.block_size(), F.layout(), F,\n                                           F.Allocator);\n  BinaryStreamReader R(*S);\n  StringRef Str1;\n  StringRef Str2;\n  EXPECT_THAT_ERROR(R.readFixedString(Str1, 6), Succeeded());\n  EXPECT_EQ(Str1, StringRef(\"ABCDEF\"));\n  EXPECT_EQ(6U, F.Allocator.getBytesAllocated());\n\n  R.setOffset(4);\n  EXPECT_THAT_ERROR(R.readFixedString(Str2, 4), Succeeded());\n  EXPECT_EQ(Str2, StringRef(\"EFGH\"));\n  EXPECT_EQ(10U, F.Allocator.getBytesAllocated());\n}\n\nTEST(MappedBlockStreamTest, WriteBeyondEndOfStream) {\n  static uint8_t Data[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'};\n  static uint8_t LargeBuffer[] = {'0', '1', '2', '3', '4', '5',\n                                  '6', '7', '8', '9', 'A'};\n  static uint8_t SmallBuffer[] = {'0', '1', '2'};\n  static_assert(sizeof(LargeBuffer) > sizeof(Data),\n                \"LargeBuffer is not big enough\");\n\n  DiscontiguousStream F(BlocksAry, Data);\n  auto S = WritableMappedBlockStream::createStream(F.block_size(), F.layout(),\n                                                   F, F.Allocator);\n  EXPECT_THAT_ERROR(S->writeBytes(0, ArrayRef<uint8_t>(LargeBuffer)), Failed());\n  EXPECT_THAT_ERROR(S->writeBytes(0, ArrayRef<uint8_t>(SmallBuffer)),\n                    Succeeded());\n  EXPECT_THAT_ERROR(S->writeBytes(7, ArrayRef<uint8_t>(SmallBuffer)),\n                    Succeeded());\n  EXPECT_THAT_ERROR(S->writeBytes(8, ArrayRef<uint8_t>(SmallBuffer)), Failed());\n}\n\nTEST(MappedBlockStreamTest, TestWriteBytesNoBreakBoundary) {\n  static uint8_t Data[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'};\n  DiscontiguousStream F(BlocksAry, Data);\n  auto S = WritableMappedBlockStream::createStream(F.block_size(), F.layout(),\n                                                   F, F.Allocator);\n  ArrayRef<uint8_t> Buffer;\n\n  EXPECT_THAT_ERROR(S->readBytes(0, 1, Buffer), Succeeded());\n  EXPECT_EQ(Buffer, ArrayRef<uint8_t>('A'));\n  EXPECT_THAT_ERROR(S->readBytes(9, 1, Buffer), Succeeded());\n  EXPECT_EQ(Buffer, ArrayRef<uint8_t>('J'));\n\n  EXPECT_THAT_ERROR(S->writeBytes(0, ArrayRef<uint8_t>('J')), Succeeded());\n  EXPECT_THAT_ERROR(S->writeBytes(9, ArrayRef<uint8_t>('A')), Succeeded());\n\n  EXPECT_THAT_ERROR(S->readBytes(0, 1, Buffer), Succeeded());\n  EXPECT_EQ(Buffer, ArrayRef<uint8_t>('J'));\n  EXPECT_THAT_ERROR(S->readBytes(9, 1, Buffer), Succeeded());\n  EXPECT_EQ(Buffer, ArrayRef<uint8_t>('A'));\n\n  EXPECT_THAT_ERROR(S->writeBytes(0, ArrayRef<uint8_t>('A')), Succeeded());\n  EXPECT_THAT_ERROR(S->writeBytes(9, ArrayRef<uint8_t>('J')), Succeeded());\n\n  EXPECT_THAT_ERROR(S->readBytes(0, 1, Buffer), Succeeded());\n  EXPECT_EQ(Buffer, ArrayRef<uint8_t>('A'));\n  EXPECT_THAT_ERROR(S->readBytes(9, 1, Buffer), Succeeded());\n  EXPECT_EQ(Buffer, ArrayRef<uint8_t>('J'));\n}\n\nTEST(MappedBlockStreamTest, TestWriteBytesBreakBoundary) {\n  static uint8_t Data[] = {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'};\n  static uint8_t TestData[] = {'T', 'E', 'S', 'T', 'I', 'N', 'G', '.'};\n  static uint8_t Expected[] = {'T', 'E', 'S', 'N', 'I',\n                               'T', 'G', '.', '0', '0'};\n\n  DiscontiguousStream F(BlocksAry, Data);\n  auto S = WritableMappedBlockStream::createStream(F.block_size(), F.layout(),\n                                                   F, F.Allocator);\n  ArrayRef<uint8_t> Buffer;\n\n  EXPECT_THAT_ERROR(S->writeBytes(0, TestData), Succeeded());\n  // First just compare the memory, then compare the result of reading the\n  // string out.\n  EXPECT_EQ(ArrayRef<uint8_t>(Data), ArrayRef<uint8_t>(Expected));\n\n  EXPECT_THAT_ERROR(S->readBytes(0, 8, Buffer), Succeeded());\n  EXPECT_EQ(Buffer, ArrayRef<uint8_t>(TestData));\n}\n\nTEST(MappedBlockStreamTest, TestWriteThenRead) {\n  std::vector<uint8_t> DataBytes(10);\n  MutableArrayRef<uint8_t> Data(DataBytes);\n  const uint32_t Blocks[] = {2, 1, 0, 6, 3, 4, 5, 7, 9, 8};\n\n  DiscontiguousStream F(Blocks, Data);\n  auto S = WritableMappedBlockStream::createStream(F.block_size(), F.layout(),\n                                                   F, F.Allocator);\n\n  enum class MyEnum : uint32_t { Val1 = 2908234, Val2 = 120891234 };\n  using support::ulittle32_t;\n\n  uint16_t u16[] = {31468, 0};\n  uint32_t u32[] = {890723408, 0};\n  MyEnum Enum[] = {MyEnum::Val1, MyEnum::Val2};\n  StringRef ZStr[] = {\"Zero Str\", \"\"};\n  StringRef FStr[] = {\"Fixed Str\", \"\"};\n  uint8_t byteArray0[] = {'1', '2'};\n  uint8_t byteArray1[] = {'0', '0'};\n  ArrayRef<uint8_t> byteArrayRef0(byteArray0);\n  ArrayRef<uint8_t> byteArrayRef1(byteArray1);\n  ArrayRef<uint8_t> byteArray[] = {byteArrayRef0, byteArrayRef1};\n  uint32_t intArr0[] = {890723408, 29082234};\n  uint32_t intArr1[] = {890723408, 29082234};\n  ArrayRef<uint32_t> intArray[] = {intArr0, intArr1};\n\n  BinaryStreamReader Reader(*S);\n  BinaryStreamWriter Writer(*S);\n  EXPECT_THAT_ERROR(Writer.writeInteger(u16[0]), Succeeded());\n  EXPECT_THAT_ERROR(Reader.readInteger(u16[1]), Succeeded());\n  EXPECT_EQ(u16[0], u16[1]);\n  EXPECT_EQ(std::vector<uint8_t>({0, 0x7A, 0xEC, 0, 0, 0, 0, 0, 0, 0}),\n            DataBytes);\n\n  Reader.setOffset(0);\n  Writer.setOffset(0);\n  ::memset(DataBytes.data(), 0, 10);\n  EXPECT_THAT_ERROR(Writer.writeInteger(u32[0]), Succeeded());\n  EXPECT_THAT_ERROR(Reader.readInteger(u32[1]), Succeeded());\n  EXPECT_EQ(u32[0], u32[1]);\n  EXPECT_EQ(std::vector<uint8_t>({0x17, 0x5C, 0x50, 0, 0, 0, 0x35, 0, 0, 0}),\n            DataBytes);\n\n  Reader.setOffset(0);\n  Writer.setOffset(0);\n  ::memset(DataBytes.data(), 0, 10);\n  EXPECT_THAT_ERROR(Writer.writeEnum(Enum[0]), Succeeded());\n  EXPECT_THAT_ERROR(Reader.readEnum(Enum[1]), Succeeded());\n  EXPECT_EQ(Enum[0], Enum[1]);\n  EXPECT_EQ(std::vector<uint8_t>({0x2C, 0x60, 0x4A, 0, 0, 0, 0, 0, 0, 0}),\n            DataBytes);\n\n  Reader.setOffset(0);\n  Writer.setOffset(0);\n  ::memset(DataBytes.data(), 0, 10);\n  EXPECT_THAT_ERROR(Writer.writeCString(ZStr[0]), Succeeded());\n  EXPECT_THAT_ERROR(Reader.readCString(ZStr[1]), Succeeded());\n  EXPECT_EQ(ZStr[0], ZStr[1]);\n  EXPECT_EQ(\n      std::vector<uint8_t>({'r', 'e', 'Z', ' ', 'S', 't', 'o', 'r', 0, 0}),\n      DataBytes);\n\n  Reader.setOffset(0);\n  Writer.setOffset(0);\n  ::memset(DataBytes.data(), 0, 10);\n  EXPECT_THAT_ERROR(Writer.writeFixedString(FStr[0]), Succeeded());\n  EXPECT_THAT_ERROR(Reader.readFixedString(FStr[1], FStr[0].size()),\n                    Succeeded());\n  EXPECT_EQ(FStr[0], FStr[1]);\n  EXPECT_EQ(\n      std::vector<uint8_t>({'x', 'i', 'F', 'd', ' ', 'S', 'e', 't', 0, 'r'}),\n      DataBytes);\n\n  Reader.setOffset(0);\n  Writer.setOffset(0);\n  ::memset(DataBytes.data(), 0, 10);\n  EXPECT_THAT_ERROR(Writer.writeArray(byteArray[0]), Succeeded());\n  EXPECT_THAT_ERROR(Reader.readArray(byteArray[1], byteArray[0].size()),\n                    Succeeded());\n  EXPECT_EQ(byteArray[0], byteArray[1]);\n  EXPECT_EQ(std::vector<uint8_t>({0, 0x32, 0x31, 0, 0, 0, 0, 0, 0, 0}),\n            DataBytes);\n\n  Reader.setOffset(0);\n  Writer.setOffset(0);\n  ::memset(DataBytes.data(), 0, 10);\n  EXPECT_THAT_ERROR(Writer.writeArray(intArray[0]), Succeeded());\n  EXPECT_THAT_ERROR(Reader.readArray(intArray[1], intArray[0].size()),\n                    Succeeded());\n  EXPECT_EQ(intArray[0], intArray[1]);\n}\n\nTEST(MappedBlockStreamTest, TestWriteContiguousStreamRef) {\n  std::vector<uint8_t> DestDataBytes(10);\n  MutableArrayRef<uint8_t> DestData(DestDataBytes);\n  const uint32_t DestBlocks[] = {2, 1, 0, 6, 3, 4, 5, 7, 9, 8};\n\n  std::vector<uint8_t> SrcDataBytes(10);\n  MutableArrayRef<uint8_t> SrcData(SrcDataBytes);\n\n  DiscontiguousStream F(DestBlocks, DestData);\n  auto DestStream = WritableMappedBlockStream::createStream(\n      F.block_size(), F.layout(), F, F.Allocator);\n\n  // First write \"Test Str\" into the source stream.\n  MutableBinaryByteStream SourceStream(SrcData, little);\n  BinaryStreamWriter SourceWriter(SourceStream);\n  EXPECT_THAT_ERROR(SourceWriter.writeCString(\"Test Str\"), Succeeded());\n  EXPECT_EQ(SrcDataBytes, std::vector<uint8_t>(\n                              {'T', 'e', 's', 't', ' ', 'S', 't', 'r', 0, 0}));\n\n  // Then write the source stream into the dest stream.\n  BinaryStreamWriter DestWriter(*DestStream);\n  EXPECT_THAT_ERROR(DestWriter.writeStreamRef(SourceStream), Succeeded());\n  EXPECT_EQ(DestDataBytes, std::vector<uint8_t>(\n                               {'s', 'e', 'T', ' ', 'S', 't', 't', 'r', 0, 0}));\n\n  // Then read the string back out of the dest stream.\n  StringRef Result;\n  BinaryStreamReader DestReader(*DestStream);\n  EXPECT_THAT_ERROR(DestReader.readCString(Result), Succeeded());\n  EXPECT_EQ(Result, \"Test Str\");\n}\n\nTEST(MappedBlockStreamTest, TestWriteDiscontiguousStreamRef) {\n  std::vector<uint8_t> DestDataBytes(10);\n  MutableArrayRef<uint8_t> DestData(DestDataBytes);\n  const uint32_t DestBlocks[] = {2, 1, 0, 6, 3, 4, 5, 7, 9, 8};\n\n  std::vector<uint8_t> SrcDataBytes(10);\n  MutableArrayRef<uint8_t> SrcData(SrcDataBytes);\n  const uint32_t SrcBlocks[] = {1, 0, 6, 3, 4, 5, 2, 7, 8, 9};\n\n  DiscontiguousStream DestF(DestBlocks, DestData);\n  DiscontiguousStream SrcF(SrcBlocks, SrcData);\n\n  auto Dest = WritableMappedBlockStream::createStream(\n      DestF.block_size(), DestF.layout(), DestF, DestF.Allocator);\n  auto Src = WritableMappedBlockStream::createStream(\n      SrcF.block_size(), SrcF.layout(), SrcF, SrcF.Allocator);\n\n  // First write \"Test Str\" into the source stream.\n  BinaryStreamWriter SourceWriter(*Src);\n  EXPECT_THAT_ERROR(SourceWriter.writeCString(\"Test Str\"), Succeeded());\n  EXPECT_EQ(SrcDataBytes, std::vector<uint8_t>(\n                              {'e', 'T', 't', 't', ' ', 'S', 's', 'r', 0, 0}));\n\n  // Then write the source stream into the dest stream.\n  BinaryStreamWriter DestWriter(*Dest);\n  EXPECT_THAT_ERROR(DestWriter.writeStreamRef(*Src), Succeeded());\n  EXPECT_EQ(DestDataBytes, std::vector<uint8_t>(\n                               {'s', 'e', 'T', ' ', 'S', 't', 't', 'r', 0, 0}));\n\n  // Then read the string back out of the dest stream.\n  StringRef Result;\n  BinaryStreamReader DestReader(*Dest);\n  EXPECT_THAT_ERROR(DestReader.readCString(Result), Succeeded());\n  EXPECT_EQ(Result, \"Test Str\");\n}\n\nTEST(MappedBlockStreamTest, DataLivesAfterStreamDestruction) {\n  std::vector<uint8_t> DataBytes(10);\n  MutableArrayRef<uint8_t> Data(DataBytes);\n  const uint32_t Blocks[] = {2, 1, 0, 6, 3, 4, 5, 7, 9, 8};\n\n  StringRef Str[] = {\"Zero Str\", \"\"};\n\n  DiscontiguousStream F(Blocks, Data);\n  {\n    auto S = WritableMappedBlockStream::createStream(F.block_size(), F.layout(),\n                                                     F, F.Allocator);\n\n    BinaryStreamReader Reader(*S);\n    BinaryStreamWriter Writer(*S);\n    ::memset(DataBytes.data(), 0, 10);\n    EXPECT_THAT_ERROR(Writer.writeCString(Str[0]), Succeeded());\n    EXPECT_THAT_ERROR(Reader.readCString(Str[1]), Succeeded());\n    EXPECT_EQ(Str[0], Str[1]);\n  }\n\n  EXPECT_EQ(Str[0], Str[1]);\n}\n} // namespace\n\nMATCHER_P3(BlockIsFilledWith, Layout, BlockIndex, Byte, \"succeeded\") {\n  uint64_t Offset = msf::blockToOffset(BlockIndex, Layout.SB->BlockSize);\n  ArrayRef<uint8_t> BufferRef = makeArrayRef(arg);\n  BufferRef = BufferRef.slice(Offset, Layout.SB->BlockSize);\n  return llvm::all_of(BufferRef, [this](uint8_t B) { return B == Byte; });\n}\n\nnamespace {\nTEST(MappedBlockStreamTest, CreateFpmStream) {\n  BumpPtrAllocator Allocator;\n  SuperBlock SB;\n  MSFLayout L;\n  L.SB = &SB;\n\n  SB.FreeBlockMapBlock = 1;\n  SB.BlockSize = 4096;\n\n  constexpr uint32_t NumFileBlocks = 4096 * 4;\n\n  std::vector<uint8_t> MsfBuffer(NumFileBlocks * SB.BlockSize);\n  MutableBinaryByteStream MsfStream(MsfBuffer, llvm::support::little);\n\n  SB.NumBlocks = NumFileBlocks;\n  auto FpmStream =\n      WritableMappedBlockStream::createFpmStream(L, MsfStream, Allocator);\n  // 4096 * 4 / 8 = 2048 bytes of FPM data is needed to describe 4096 * 4\n  // blocks.  This translates to 1 FPM block.\n  EXPECT_EQ(2048u, FpmStream->getLength());\n  EXPECT_EQ(1u, FpmStream->getStreamLayout().Blocks.size());\n  EXPECT_EQ(1u, FpmStream->getStreamLayout().Blocks[0]);\n  // All blocks from FPM1 should be 1 initialized, and all blocks from FPM2\n  // should be 0 initialized (since we requested the main FPM, not the alt FPM)\n  for (int I = 0; I < 4; ++I) {\n    EXPECT_THAT(MsfBuffer, BlockIsFilledWith(L, 1 + I * SB.BlockSize, 0xFF));\n    EXPECT_THAT(MsfBuffer, BlockIsFilledWith(L, 2 + I * SB.BlockSize, 0));\n  }\n\n  ::memset(MsfBuffer.data(), 0, MsfBuffer.size());\n  FpmStream =\n      WritableMappedBlockStream::createFpmStream(L, MsfStream, Allocator, true);\n  // 4096 * 4 / 8 = 2048 bytes of FPM data is needed to describe 4096 * 4\n  // blocks.  This translates to 1 FPM block.\n  EXPECT_EQ(2048u, FpmStream->getLength());\n  EXPECT_EQ(1u, FpmStream->getStreamLayout().Blocks.size());\n  EXPECT_EQ(2u, FpmStream->getStreamLayout().Blocks[0]);\n  // All blocks from FPM2 should be 1 initialized, and all blocks from FPM1\n  // should be 0 initialized (since we requested the alt FPM, not the main FPM)\n  for (int I = 0; I < 4; ++I) {\n    EXPECT_THAT(MsfBuffer, BlockIsFilledWith(L, 1 + I * SB.BlockSize, 0));\n    EXPECT_THAT(MsfBuffer, BlockIsFilledWith(L, 2 + I * SB.BlockSize, 0xFF));\n  }\n}\n\n} // end anonymous namespace\n"}, "34": {"id": 34, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-actions.h", "content": "// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// This file implements some commonly used actions.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_ACTIONS_H_\n#define GMOCK_INCLUDE_GMOCK_GMOCK_ACTIONS_H_\n\n#ifndef _WIN32_WCE\n# include <errno.h>\n#endif\n\n#include <algorithm>\n#include <string>\n\n#include \"gmock/internal/gmock-internal-utils.h\"\n#include \"gmock/internal/gmock-port.h\"\n\n#if GTEST_HAS_STD_TYPE_TRAITS_  // Defined by gtest-port.h via gmock-port.h.\n#include <type_traits>\n#endif\n\nnamespace testing {\n\n// To implement an action Foo, define:\n//   1. a class FooAction that implements the ActionInterface interface, and\n//   2. a factory function that creates an Action object from a\n//      const FooAction*.\n//\n// The two-level delegation design follows that of Matcher, providing\n// consistency for extension developers.  It also eases ownership\n// management as Action objects can now be copied like plain values.\n\nnamespace internal {\n\ntemplate <typename F1, typename F2>\nclass ActionAdaptor;\n\n// BuiltInDefaultValueGetter<T, true>::Get() returns a\n// default-constructed T value.  BuiltInDefaultValueGetter<T,\n// false>::Get() crashes with an error.\n//\n// This primary template is used when kDefaultConstructible is true.\ntemplate <typename T, bool kDefaultConstructible>\nstruct BuiltInDefaultValueGetter {\n  static T Get() { return T(); }\n};\ntemplate <typename T>\nstruct BuiltInDefaultValueGetter<T, false> {\n  static T Get() {\n    Assert(false, __FILE__, __LINE__,\n           \"Default action undefined for the function return type.\");\n    return internal::Invalid<T>();\n    // The above statement will never be reached, but is required in\n    // order for this function to compile.\n  }\n};\n\n// BuiltInDefaultValue<T>::Get() returns the \"built-in\" default value\n// for type T, which is NULL when T is a raw pointer type, 0 when T is\n// a numeric type, false when T is bool, or \"\" when T is string or\n// std::string.  In addition, in C++11 and above, it turns a\n// default-constructed T value if T is default constructible.  For any\n// other type T, the built-in default T value is undefined, and the\n// function will abort the process.\ntemplate <typename T>\nclass BuiltInDefaultValue {\n public:\n#if GTEST_HAS_STD_TYPE_TRAITS_\n  // This function returns true iff type T has a built-in default value.\n  static bool Exists() {\n    return ::std::is_default_constructible<T>::value;\n  }\n\n  static T Get() {\n    return BuiltInDefaultValueGetter<\n        T, ::std::is_default_constructible<T>::value>::Get();\n  }\n\n#else  // GTEST_HAS_STD_TYPE_TRAITS_\n  // This function returns true iff type T has a built-in default value.\n  static bool Exists() {\n    return false;\n  }\n\n  static T Get() {\n    return BuiltInDefaultValueGetter<T, false>::Get();\n  }\n\n#endif  // GTEST_HAS_STD_TYPE_TRAITS_\n};\n\n// This partial specialization says that we use the same built-in\n// default value for T and const T.\ntemplate <typename T>\nclass BuiltInDefaultValue<const T> {\n public:\n  static bool Exists() { return BuiltInDefaultValue<T>::Exists(); }\n  static T Get() { return BuiltInDefaultValue<T>::Get(); }\n};\n\n// This partial specialization defines the default values for pointer\n// types.\ntemplate <typename T>\nclass BuiltInDefaultValue<T*> {\n public:\n  static bool Exists() { return true; }\n  static T* Get() { return NULL; }\n};\n\n// The following specializations define the default values for\n// specific types we care about.\n#define GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(type, value) \\\n  template <> \\\n  class BuiltInDefaultValue<type> { \\\n   public: \\\n    static bool Exists() { return true; } \\\n    static type Get() { return value; } \\\n  }\n\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(void, );  // NOLINT\n#if GTEST_HAS_GLOBAL_STRING\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(::string, \"\");\n#endif  // GTEST_HAS_GLOBAL_STRING\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(::std::string, \"\");\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(bool, false);\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned char, '\\0');\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed char, '\\0');\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(char, '\\0');\n\n// There's no need for a default action for signed wchar_t, as that\n// type is the same as wchar_t for gcc, and invalid for MSVC.\n//\n// There's also no need for a default action for unsigned wchar_t, as\n// that type is the same as unsigned int for gcc, and invalid for\n// MSVC.\n#if GMOCK_WCHAR_T_IS_NATIVE_\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(wchar_t, 0U);  // NOLINT\n#endif\n\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned short, 0U);  // NOLINT\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed short, 0);     // NOLINT\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned int, 0U);\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed int, 0);\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned long, 0UL);  // NOLINT\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed long, 0L);     // NOLINT\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(UInt64, 0);\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(Int64, 0);\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(float, 0);\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(double, 0);\n\n#undef GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_\n\n}  // namespace internal\n\n// When an unexpected function call is encountered, Google Mock will\n// let it return a default value if the user has specified one for its\n// return type, or if the return type has a built-in default value;\n// otherwise Google Mock won't know what value to return and will have\n// to abort the process.\n//\n// The DefaultValue<T> class allows a user to specify the\n// default value for a type T that is both copyable and publicly\n// destructible (i.e. anything that can be used as a function return\n// type).  The usage is:\n//\n//   // Sets the default value for type T to be foo.\n//   DefaultValue<T>::Set(foo);\ntemplate <typename T>\nclass DefaultValue {\n public:\n  // Sets the default value for type T; requires T to be\n  // copy-constructable and have a public destructor.\n  static void Set(T x) {\n    delete producer_;\n    producer_ = new FixedValueProducer(x);\n  }\n\n  // Provides a factory function to be called to generate the default value.\n  // This method can be used even if T is only move-constructible, but it is not\n  // limited to that case.\n  typedef T (*FactoryFunction)();\n  static void SetFactory(FactoryFunction factory) {\n    delete producer_;\n    producer_ = new FactoryValueProducer(factory);\n  }\n\n  // Unsets the default value for type T.\n  static void Clear() {\n    delete producer_;\n    producer_ = NULL;\n  }\n\n  // Returns true iff the user has set the default value for type T.\n  static bool IsSet() { return producer_ != NULL; }\n\n  // Returns true if T has a default return value set by the user or there\n  // exists a built-in default value.\n  static bool Exists() {\n    return IsSet() || internal::BuiltInDefaultValue<T>::Exists();\n  }\n\n  // Returns the default value for type T if the user has set one;\n  // otherwise returns the built-in default value. Requires that Exists()\n  // is true, which ensures that the return value is well-defined.\n  static T Get() {\n    return producer_ == NULL ?\n        internal::BuiltInDefaultValue<T>::Get() : producer_->Produce();\n  }\n\n private:\n  class ValueProducer {\n   public:\n    virtual ~ValueProducer() {}\n    virtual T Produce() = 0;\n  };\n\n  class FixedValueProducer : public ValueProducer {\n   public:\n    explicit FixedValueProducer(T value) : value_(value) {}\n    virtual T Produce() { return value_; }\n\n   private:\n    const T value_;\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(FixedValueProducer);\n  };\n\n  class FactoryValueProducer : public ValueProducer {\n   public:\n    explicit FactoryValueProducer(FactoryFunction factory)\n        : factory_(factory) {}\n    virtual T Produce() { return factory_(); }\n\n   private:\n    const FactoryFunction factory_;\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(FactoryValueProducer);\n  };\n\n  static ValueProducer* producer_;\n};\n\n// This partial specialization allows a user to set default values for\n// reference types.\ntemplate <typename T>\nclass DefaultValue<T&> {\n public:\n  // Sets the default value for type T&.\n  static void Set(T& x) {  // NOLINT\n    address_ = &x;\n  }\n\n  // Unsets the default value for type T&.\n  static void Clear() {\n    address_ = NULL;\n  }\n\n  // Returns true iff the user has set the default value for type T&.\n  static bool IsSet() { return address_ != NULL; }\n\n  // Returns true if T has a default return value set by the user or there\n  // exists a built-in default value.\n  static bool Exists() {\n    return IsSet() || internal::BuiltInDefaultValue<T&>::Exists();\n  }\n\n  // Returns the default value for type T& if the user has set one;\n  // otherwise returns the built-in default value if there is one;\n  // otherwise aborts the process.\n  static T& Get() {\n    return address_ == NULL ?\n        internal::BuiltInDefaultValue<T&>::Get() : *address_;\n  }\n\n private:\n  static T* address_;\n};\n\n// This specialization allows DefaultValue<void>::Get() to\n// compile.\ntemplate <>\nclass DefaultValue<void> {\n public:\n  static bool Exists() { return true; }\n  static void Get() {}\n};\n\n// Points to the user-set default value for type T.\ntemplate <typename T>\ntypename DefaultValue<T>::ValueProducer* DefaultValue<T>::producer_ = NULL;\n\n// Points to the user-set default value for type T&.\ntemplate <typename T>\nT* DefaultValue<T&>::address_ = NULL;\n\n// Implement this interface to define an action for function type F.\ntemplate <typename F>\nclass ActionInterface {\n public:\n  typedef typename internal::Function<F>::Result Result;\n  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n  ActionInterface() {}\n  virtual ~ActionInterface() {}\n\n  // Performs the action.  This method is not const, as in general an\n  // action can have side effects and be stateful.  For example, a\n  // get-the-next-element-from-the-collection action will need to\n  // remember the current element.\n  virtual Result Perform(const ArgumentTuple& args) = 0;\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ActionInterface);\n};\n\n// An Action<F> is a copyable and IMMUTABLE (except by assignment)\n// object that represents an action to be taken when a mock function\n// of type F is called.  The implementation of Action<T> is just a\n// linked_ptr to const ActionInterface<T>, so copying is fairly cheap.\n// Don't inherit from Action!\n//\n// You can view an object implementing ActionInterface<F> as a\n// concrete action (including its current state), and an Action<F>\n// object as a handle to it.\ntemplate <typename F>\nclass Action {\n public:\n  typedef typename internal::Function<F>::Result Result;\n  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n  // Constructs a null Action.  Needed for storing Action objects in\n  // STL containers.\n  Action() : impl_(NULL) {}\n\n  // Constructs an Action from its implementation.  A NULL impl is\n  // used to represent the \"do-default\" action.\n  explicit Action(ActionInterface<F>* impl) : impl_(impl) {}\n\n  // Copy constructor.\n  Action(const Action &action) = default;\n  Action &operator=(const Action &action) = default;\n\n  // This constructor allows us to turn an Action<Func> object into an\n  // Action<F>, as long as F's arguments can be implicitly converted\n  // to Func's and Func's return type can be implicitly converted to\n  // F's.\n  template <typename Func>\n  explicit Action(const Action<Func>& action);\n\n  // Returns true iff this is the DoDefault() action.\n  bool IsDoDefault() const { return impl_.get() == NULL; }\n\n  // Performs the action.  Note that this method is const even though\n  // the corresponding method in ActionInterface is not.  The reason\n  // is that a const Action<F> means that it cannot be re-bound to\n  // another concrete action, not that the concrete action it binds to\n  // cannot change state.  (Think of the difference between a const\n  // pointer and a pointer to const.)\n  Result Perform(const ArgumentTuple& args) const {\n    internal::Assert(\n        !IsDoDefault(), __FILE__, __LINE__,\n        \"You are using DoDefault() inside a composite action like \"\n        \"DoAll() or WithArgs().  This is not supported for technical \"\n        \"reasons.  Please instead spell out the default action, or \"\n        \"assign the default action to an Action variable and use \"\n        \"the variable in various places.\");\n    return impl_->Perform(args);\n  }\n\n private:\n  template <typename F1, typename F2>\n  friend class internal::ActionAdaptor;\n\n  internal::linked_ptr<ActionInterface<F> > impl_;\n};\n\n// The PolymorphicAction class template makes it easy to implement a\n// polymorphic action (i.e. an action that can be used in mock\n// functions of than one type, e.g. Return()).\n//\n// To define a polymorphic action, a user first provides a COPYABLE\n// implementation class that has a Perform() method template:\n//\n//   class FooAction {\n//    public:\n//     template <typename Result, typename ArgumentTuple>\n//     Result Perform(const ArgumentTuple& args) const {\n//       // Processes the arguments and returns a result, using\n//       // tr1::get<N>(args) to get the N-th (0-based) argument in the tuple.\n//     }\n//     ...\n//   };\n//\n// Then the user creates the polymorphic action using\n// MakePolymorphicAction(object) where object has type FooAction.  See\n// the definition of Return(void) and SetArgumentPointee<N>(value) for\n// complete examples.\ntemplate <typename Impl>\nclass PolymorphicAction {\n public:\n  explicit PolymorphicAction(const Impl& impl) : impl_(impl) {}\n\n  template <typename F>\n  operator Action<F>() const {\n    return Action<F>(new MonomorphicImpl<F>(impl_));\n  }\n\n private:\n  template <typename F>\n  class MonomorphicImpl : public ActionInterface<F> {\n   public:\n    typedef typename internal::Function<F>::Result Result;\n    typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n    explicit MonomorphicImpl(const Impl& impl) : impl_(impl) {}\n\n    virtual Result Perform(const ArgumentTuple& args) {\n      return impl_.template Perform<Result>(args);\n    }\n\n   private:\n    Impl impl_;\n\n    GTEST_DISALLOW_ASSIGN_(MonomorphicImpl);\n  };\n\n  Impl impl_;\n\n  GTEST_DISALLOW_ASSIGN_(PolymorphicAction);\n};\n\n// Creates an Action from its implementation and returns it.  The\n// created Action object owns the implementation.\ntemplate <typename F>\nAction<F> MakeAction(ActionInterface<F>* impl) {\n  return Action<F>(impl);\n}\n\n// Creates a polymorphic action from its implementation.  This is\n// easier to use than the PolymorphicAction<Impl> constructor as it\n// doesn't require you to explicitly write the template argument, e.g.\n//\n//   MakePolymorphicAction(foo);\n// vs\n//   PolymorphicAction<TypeOfFoo>(foo);\ntemplate <typename Impl>\ninline PolymorphicAction<Impl> MakePolymorphicAction(const Impl& impl) {\n  return PolymorphicAction<Impl>(impl);\n}\n\nnamespace internal {\n\n// Allows an Action<F2> object to pose as an Action<F1>, as long as F2\n// and F1 are compatible.\ntemplate <typename F1, typename F2>\nclass ActionAdaptor : public ActionInterface<F1> {\n public:\n  typedef typename internal::Function<F1>::Result Result;\n  typedef typename internal::Function<F1>::ArgumentTuple ArgumentTuple;\n\n  explicit ActionAdaptor(const Action<F2>& from) : impl_(from.impl_) {}\n\n  virtual Result Perform(const ArgumentTuple& args) {\n    return impl_->Perform(args);\n  }\n\n private:\n  const internal::linked_ptr<ActionInterface<F2> > impl_;\n\n  GTEST_DISALLOW_ASSIGN_(ActionAdaptor);\n};\n\n// Helper struct to specialize ReturnAction to execute a move instead of a copy\n// on return. Useful for move-only types, but could be used on any type.\ntemplate <typename T>\nstruct ByMoveWrapper {\n  explicit ByMoveWrapper(T value) : payload(internal::move(value)) {}\n  T payload;\n};\n\n// Implements the polymorphic Return(x) action, which can be used in\n// any function that returns the type of x, regardless of the argument\n// types.\n//\n// Note: The value passed into Return must be converted into\n// Function<F>::Result when this action is cast to Action<F> rather than\n// when that action is performed. This is important in scenarios like\n//\n// MOCK_METHOD1(Method, T(U));\n// ...\n// {\n//   Foo foo;\n//   X x(&foo);\n//   EXPECT_CALL(mock, Method(_)).WillOnce(Return(x));\n// }\n//\n// In the example above the variable x holds reference to foo which leaves\n// scope and gets destroyed.  If copying X just copies a reference to foo,\n// that copy will be left with a hanging reference.  If conversion to T\n// makes a copy of foo, the above code is safe. To support that scenario, we\n// need to make sure that the type conversion happens inside the EXPECT_CALL\n// statement, and conversion of the result of Return to Action<T(U)> is a\n// good place for that.\n//\ntemplate <typename R>\nclass ReturnAction {\n public:\n  // Constructs a ReturnAction object from the value to be returned.\n  // 'value' is passed by value instead of by const reference in order\n  // to allow Return(\"string literal\") to compile.\n  explicit ReturnAction(R value) : value_(new R(internal::move(value))) {}\n\n  // This template type conversion operator allows Return(x) to be\n  // used in ANY function that returns x's type.\n  template <typename F>\n  operator Action<F>() const {\n    // Assert statement belongs here because this is the best place to verify\n    // conditions on F. It produces the clearest error messages\n    // in most compilers.\n    // Impl really belongs in this scope as a local class but can't\n    // because MSVC produces duplicate symbols in different translation units\n    // in this case. Until MS fixes that bug we put Impl into the class scope\n    // and put the typedef both here (for use in assert statement) and\n    // in the Impl class. But both definitions must be the same.\n    typedef typename Function<F>::Result Result;\n    GTEST_COMPILE_ASSERT_(\n        !is_reference<Result>::value,\n        use_ReturnRef_instead_of_Return_to_return_a_reference);\n    return Action<F>(new Impl<R, F>(value_));\n  }\n\n private:\n  // Implements the Return(x) action for a particular function type F.\n  template <typename R_, typename F>\n  class Impl : public ActionInterface<F> {\n   public:\n    typedef typename Function<F>::Result Result;\n    typedef typename Function<F>::ArgumentTuple ArgumentTuple;\n\n    // The implicit cast is necessary when Result has more than one\n    // single-argument constructor (e.g. Result is std::vector<int>) and R\n    // has a type conversion operator template.  In that case, value_(value)\n    // won't compile as the compiler doesn't known which constructor of\n    // Result to call.  ImplicitCast_ forces the compiler to convert R to\n    // Result without considering explicit constructors, thus resolving the\n    // ambiguity. value_ is then initialized using its copy constructor.\n    explicit Impl(const linked_ptr<R>& value)\n        : value_before_cast_(*value),\n          value_(ImplicitCast_<Result>(value_before_cast_)) {}\n\n    virtual Result Perform(const ArgumentTuple&) { return value_; }\n\n   private:\n    GTEST_COMPILE_ASSERT_(!is_reference<Result>::value,\n                          Result_cannot_be_a_reference_type);\n    // We save the value before casting just in case it is being cast to a\n    // wrapper type.\n    R value_before_cast_;\n    Result value_;\n\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(Impl);\n  };\n\n  // Partially specialize for ByMoveWrapper. This version of ReturnAction will\n  // move its contents instead.\n  template <typename R_, typename F>\n  class Impl<ByMoveWrapper<R_>, F> : public ActionInterface<F> {\n   public:\n    typedef typename Function<F>::Result Result;\n    typedef typename Function<F>::ArgumentTuple ArgumentTuple;\n\n    explicit Impl(const linked_ptr<R>& wrapper)\n        : performed_(false), wrapper_(wrapper) {}\n\n    virtual Result Perform(const ArgumentTuple&) {\n      GTEST_CHECK_(!performed_)\n          << \"A ByMove() action should only be performed once.\";\n      performed_ = true;\n      return internal::move(wrapper_->payload);\n    }\n\n   private:\n    bool performed_;\n    const linked_ptr<R> wrapper_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  const linked_ptr<R> value_;\n\n  GTEST_DISALLOW_ASSIGN_(ReturnAction);\n};\n\n// Implements the ReturnNull() action.\nclass ReturnNullAction {\n public:\n  // Allows ReturnNull() to be used in any pointer-returning function. In C++11\n  // this is enforced by returning nullptr, and in non-C++11 by asserting a\n  // pointer type on compile time.\n  template <typename Result, typename ArgumentTuple>\n  static Result Perform(const ArgumentTuple&) {\n#if GTEST_LANG_CXX11\n    return nullptr;\n#else\n    GTEST_COMPILE_ASSERT_(internal::is_pointer<Result>::value,\n                          ReturnNull_can_be_used_to_return_a_pointer_only);\n    return NULL;\n#endif  // GTEST_LANG_CXX11\n  }\n};\n\n// Implements the Return() action.\nclass ReturnVoidAction {\n public:\n  // Allows Return() to be used in any void-returning function.\n  template <typename Result, typename ArgumentTuple>\n  static void Perform(const ArgumentTuple&) {\n    CompileAssertTypesEqual<void, Result>();\n  }\n};\n\n// Implements the polymorphic ReturnRef(x) action, which can be used\n// in any function that returns a reference to the type of x,\n// regardless of the argument types.\ntemplate <typename T>\nclass ReturnRefAction {\n public:\n  // Constructs a ReturnRefAction object from the reference to be returned.\n  explicit ReturnRefAction(T& ref) : ref_(ref) {}  // NOLINT\n\n  // This template type conversion operator allows ReturnRef(x) to be\n  // used in ANY function that returns a reference to x's type.\n  template <typename F>\n  operator Action<F>() const {\n    typedef typename Function<F>::Result Result;\n    // Asserts that the function return type is a reference.  This\n    // catches the user error of using ReturnRef(x) when Return(x)\n    // should be used, and generates some helpful error message.\n    GTEST_COMPILE_ASSERT_(internal::is_reference<Result>::value,\n                          use_Return_instead_of_ReturnRef_to_return_a_value);\n    return Action<F>(new Impl<F>(ref_));\n  }\n\n private:\n  // Implements the ReturnRef(x) action for a particular function type F.\n  template <typename F>\n  class Impl : public ActionInterface<F> {\n   public:\n    typedef typename Function<F>::Result Result;\n    typedef typename Function<F>::ArgumentTuple ArgumentTuple;\n\n    explicit Impl(T& ref) : ref_(ref) {}  // NOLINT\n\n    virtual Result Perform(const ArgumentTuple&) {\n      return ref_;\n    }\n\n   private:\n    T& ref_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  T& ref_;\n\n  GTEST_DISALLOW_ASSIGN_(ReturnRefAction);\n};\n\n// Implements the polymorphic ReturnRefOfCopy(x) action, which can be\n// used in any function that returns a reference to the type of x,\n// regardless of the argument types.\ntemplate <typename T>\nclass ReturnRefOfCopyAction {\n public:\n  // Constructs a ReturnRefOfCopyAction object from the reference to\n  // be returned.\n  explicit ReturnRefOfCopyAction(const T& value) : value_(value) {}  // NOLINT\n\n  // This template type conversion operator allows ReturnRefOfCopy(x) to be\n  // used in ANY function that returns a reference to x's type.\n  template <typename F>\n  operator Action<F>() const {\n    typedef typename Function<F>::Result Result;\n    // Asserts that the function return type is a reference.  This\n    // catches the user error of using ReturnRefOfCopy(x) when Return(x)\n    // should be used, and generates some helpful error message.\n    GTEST_COMPILE_ASSERT_(\n        internal::is_reference<Result>::value,\n        use_Return_instead_of_ReturnRefOfCopy_to_return_a_value);\n    return Action<F>(new Impl<F>(value_));\n  }\n\n private:\n  // Implements the ReturnRefOfCopy(x) action for a particular function type F.\n  template <typename F>\n  class Impl : public ActionInterface<F> {\n   public:\n    typedef typename Function<F>::Result Result;\n    typedef typename Function<F>::ArgumentTuple ArgumentTuple;\n\n    explicit Impl(const T& value) : value_(value) {}  // NOLINT\n\n    virtual Result Perform(const ArgumentTuple&) {\n      return value_;\n    }\n\n   private:\n    T value_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  const T value_;\n\n  GTEST_DISALLOW_ASSIGN_(ReturnRefOfCopyAction);\n};\n\n// Implements the polymorphic DoDefault() action.\nclass DoDefaultAction {\n public:\n  // This template type conversion operator allows DoDefault() to be\n  // used in any function.\n  template <typename F>\n  operator Action<F>() const { return Action<F>(NULL); }\n};\n\n// Implements the Assign action to set a given pointer referent to a\n// particular value.\ntemplate <typename T1, typename T2>\nclass AssignAction {\n public:\n  AssignAction(T1* ptr, T2 value) : ptr_(ptr), value_(value) {}\n\n  template <typename Result, typename ArgumentTuple>\n  void Perform(const ArgumentTuple& /* args */) const {\n    *ptr_ = value_;\n  }\n\n private:\n  T1* const ptr_;\n  const T2 value_;\n\n  GTEST_DISALLOW_ASSIGN_(AssignAction);\n};\n\n#if !GTEST_OS_WINDOWS_MOBILE\n\n// Implements the SetErrnoAndReturn action to simulate return from\n// various system calls and libc functions.\ntemplate <typename T>\nclass SetErrnoAndReturnAction {\n public:\n  SetErrnoAndReturnAction(int errno_value, T result)\n      : errno_(errno_value),\n        result_(result) {}\n  template <typename Result, typename ArgumentTuple>\n  Result Perform(const ArgumentTuple& /* args */) const {\n    errno = errno_;\n    return result_;\n  }\n\n private:\n  const int errno_;\n  const T result_;\n\n  GTEST_DISALLOW_ASSIGN_(SetErrnoAndReturnAction);\n};\n\n#endif  // !GTEST_OS_WINDOWS_MOBILE\n\n// Implements the SetArgumentPointee<N>(x) action for any function\n// whose N-th argument (0-based) is a pointer to x's type.  The\n// template parameter kIsProto is true iff type A is ProtocolMessage,\n// proto2::Message, or a sub-class of those.\ntemplate <size_t N, typename A, bool kIsProto>\nclass SetArgumentPointeeAction {\n public:\n  // Constructs an action that sets the variable pointed to by the\n  // N-th function argument to 'value'.\n  explicit SetArgumentPointeeAction(const A& value) : value_(value) {}\n\n  template <typename Result, typename ArgumentTuple>\n  void Perform(const ArgumentTuple& args) const {\n    CompileAssertTypesEqual<void, Result>();\n    *::testing::get<N>(args) = value_;\n  }\n\n private:\n  const A value_;\n\n  GTEST_DISALLOW_ASSIGN_(SetArgumentPointeeAction);\n};\n\ntemplate <size_t N, typename Proto>\nclass SetArgumentPointeeAction<N, Proto, true> {\n public:\n  // Constructs an action that sets the variable pointed to by the\n  // N-th function argument to 'proto'.  Both ProtocolMessage and\n  // proto2::Message have the CopyFrom() method, so the same\n  // implementation works for both.\n  explicit SetArgumentPointeeAction(const Proto& proto) : proto_(new Proto) {\n    proto_->CopyFrom(proto);\n  }\n\n  template <typename Result, typename ArgumentTuple>\n  void Perform(const ArgumentTuple& args) const {\n    CompileAssertTypesEqual<void, Result>();\n    ::testing::get<N>(args)->CopyFrom(*proto_);\n  }\n\n private:\n  const internal::linked_ptr<Proto> proto_;\n\n  GTEST_DISALLOW_ASSIGN_(SetArgumentPointeeAction);\n};\n\n// Implements the InvokeWithoutArgs(f) action.  The template argument\n// FunctionImpl is the implementation type of f, which can be either a\n// function pointer or a functor.  InvokeWithoutArgs(f) can be used as an\n// Action<F> as long as f's type is compatible with F (i.e. f can be\n// assigned to a tr1::function<F>).\ntemplate <typename FunctionImpl>\nclass InvokeWithoutArgsAction {\n public:\n  // The c'tor makes a copy of function_impl (either a function\n  // pointer or a functor).\n  explicit InvokeWithoutArgsAction(FunctionImpl function_impl)\n      : function_impl_(function_impl) {}\n\n  // Allows InvokeWithoutArgs(f) to be used as any action whose type is\n  // compatible with f.\n  template <typename Result, typename ArgumentTuple>\n  Result Perform(const ArgumentTuple&) { return function_impl_(); }\n\n private:\n  FunctionImpl function_impl_;\n\n  GTEST_DISALLOW_ASSIGN_(InvokeWithoutArgsAction);\n};\n\n// Implements the InvokeWithoutArgs(object_ptr, &Class::Method) action.\ntemplate <class Class, typename MethodPtr>\nclass InvokeMethodWithoutArgsAction {\n public:\n  InvokeMethodWithoutArgsAction(Class* obj_ptr, MethodPtr method_ptr)\n      : obj_ptr_(obj_ptr), method_ptr_(method_ptr) {}\n\n  template <typename Result, typename ArgumentTuple>\n  Result Perform(const ArgumentTuple&) const {\n    return (obj_ptr_->*method_ptr_)();\n  }\n\n private:\n  Class* const obj_ptr_;\n  const MethodPtr method_ptr_;\n\n  GTEST_DISALLOW_ASSIGN_(InvokeMethodWithoutArgsAction);\n};\n\n// Implements the IgnoreResult(action) action.\ntemplate <typename A>\nclass IgnoreResultAction {\n public:\n  explicit IgnoreResultAction(const A& action) : action_(action) {}\n\n  template <typename F>\n  operator Action<F>() const {\n    // Assert statement belongs here because this is the best place to verify\n    // conditions on F. It produces the clearest error messages\n    // in most compilers.\n    // Impl really belongs in this scope as a local class but can't\n    // because MSVC produces duplicate symbols in different translation units\n    // in this case. Until MS fixes that bug we put Impl into the class scope\n    // and put the typedef both here (for use in assert statement) and\n    // in the Impl class. But both definitions must be the same.\n    typedef typename internal::Function<F>::Result Result;\n\n    // Asserts at compile time that F returns void.\n    CompileAssertTypesEqual<void, Result>();\n\n    return Action<F>(new Impl<F>(action_));\n  }\n\n private:\n  template <typename F>\n  class Impl : public ActionInterface<F> {\n   public:\n    typedef typename internal::Function<F>::Result Result;\n    typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n    explicit Impl(const A& action) : action_(action) {}\n\n    virtual void Perform(const ArgumentTuple& args) {\n      // Performs the action and ignores its result.\n      action_.Perform(args);\n    }\n\n   private:\n    // Type OriginalFunction is the same as F except that its return\n    // type is IgnoredValue.\n    typedef typename internal::Function<F>::MakeResultIgnoredValue\n        OriginalFunction;\n\n    const Action<OriginalFunction> action_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  const A action_;\n\n  GTEST_DISALLOW_ASSIGN_(IgnoreResultAction);\n};\n\n// A ReferenceWrapper<T> object represents a reference to type T,\n// which can be either const or not.  It can be explicitly converted\n// from, and implicitly converted to, a T&.  Unlike a reference,\n// ReferenceWrapper<T> can be copied and can survive template type\n// inference.  This is used to support by-reference arguments in the\n// InvokeArgument<N>(...) action.  The idea was from \"reference\n// wrappers\" in tr1, which we don't have in our source tree yet.\ntemplate <typename T>\nclass ReferenceWrapper {\n public:\n  // Constructs a ReferenceWrapper<T> object from a T&.\n  explicit ReferenceWrapper(T& l_value) : pointer_(&l_value) {}  // NOLINT\n\n  // Allows a ReferenceWrapper<T> object to be implicitly converted to\n  // a T&.\n  operator T&() const { return *pointer_; }\n private:\n  T* pointer_;\n};\n\n// Allows the expression ByRef(x) to be printed as a reference to x.\ntemplate <typename T>\nvoid PrintTo(const ReferenceWrapper<T>& ref, ::std::ostream* os) {\n  T& value = ref;\n  UniversalPrinter<T&>::Print(value, os);\n}\n\n// Does two actions sequentially.  Used for implementing the DoAll(a1,\n// a2, ...) action.\ntemplate <typename Action1, typename Action2>\nclass DoBothAction {\n public:\n  DoBothAction(Action1 action1, Action2 action2)\n      : action1_(action1), action2_(action2) {}\n\n  // This template type conversion operator allows DoAll(a1, ..., a_n)\n  // to be used in ANY function of compatible type.\n  template <typename F>\n  operator Action<F>() const {\n    return Action<F>(new Impl<F>(action1_, action2_));\n  }\n\n private:\n  // Implements the DoAll(...) action for a particular function type F.\n  template <typename F>\n  class Impl : public ActionInterface<F> {\n   public:\n    typedef typename Function<F>::Result Result;\n    typedef typename Function<F>::ArgumentTuple ArgumentTuple;\n    typedef typename Function<F>::MakeResultVoid VoidResult;\n\n    Impl(const Action<VoidResult>& action1, const Action<F>& action2)\n        : action1_(action1), action2_(action2) {}\n\n    virtual Result Perform(const ArgumentTuple& args) {\n      action1_.Perform(args);\n      return action2_.Perform(args);\n    }\n\n   private:\n    const Action<VoidResult> action1_;\n    const Action<F> action2_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  Action1 action1_;\n  Action2 action2_;\n\n  GTEST_DISALLOW_ASSIGN_(DoBothAction);\n};\n\n}  // namespace internal\n\n// An Unused object can be implicitly constructed from ANY value.\n// This is handy when defining actions that ignore some or all of the\n// mock function arguments.  For example, given\n//\n//   MOCK_METHOD3(Foo, double(const string& label, double x, double y));\n//   MOCK_METHOD3(Bar, double(int index, double x, double y));\n//\n// instead of\n//\n//   double DistanceToOriginWithLabel(const string& label, double x, double y) {\n//     return sqrt(x*x + y*y);\n//   }\n//   double DistanceToOriginWithIndex(int index, double x, double y) {\n//     return sqrt(x*x + y*y);\n//   }\n//   ...\n//   EXEPCT_CALL(mock, Foo(\"abc\", _, _))\n//       .WillOnce(Invoke(DistanceToOriginWithLabel));\n//   EXEPCT_CALL(mock, Bar(5, _, _))\n//       .WillOnce(Invoke(DistanceToOriginWithIndex));\n//\n// you could write\n//\n//   // We can declare any uninteresting argument as Unused.\n//   double DistanceToOrigin(Unused, double x, double y) {\n//     return sqrt(x*x + y*y);\n//   }\n//   ...\n//   EXEPCT_CALL(mock, Foo(\"abc\", _, _)).WillOnce(Invoke(DistanceToOrigin));\n//   EXEPCT_CALL(mock, Bar(5, _, _)).WillOnce(Invoke(DistanceToOrigin));\ntypedef internal::IgnoredValue Unused;\n\n// This constructor allows us to turn an Action<From> object into an\n// Action<To>, as long as To's arguments can be implicitly converted\n// to From's and From's return type cann be implicitly converted to\n// To's.\ntemplate <typename To>\ntemplate <typename From>\nAction<To>::Action(const Action<From>& from)\n    : impl_(new internal::ActionAdaptor<To, From>(from)) {}\n\n// Creates an action that returns 'value'.  'value' is passed by value\n// instead of const reference - otherwise Return(\"string literal\")\n// will trigger a compiler error about using array as initializer.\ntemplate <typename R>\ninternal::ReturnAction<R> Return(R value) {\n  return internal::ReturnAction<R>(internal::move(value));\n}\n\n// Creates an action that returns NULL.\ninline PolymorphicAction<internal::ReturnNullAction> ReturnNull() {\n  return MakePolymorphicAction(internal::ReturnNullAction());\n}\n\n// Creates an action that returns from a void function.\ninline PolymorphicAction<internal::ReturnVoidAction> Return() {\n  return MakePolymorphicAction(internal::ReturnVoidAction());\n}\n\n// Creates an action that returns the reference to a variable.\ntemplate <typename R>\ninline internal::ReturnRefAction<R> ReturnRef(R& x) {  // NOLINT\n  return internal::ReturnRefAction<R>(x);\n}\n\n// Creates an action that returns the reference to a copy of the\n// argument.  The copy is created when the action is constructed and\n// lives as long as the action.\ntemplate <typename R>\ninline internal::ReturnRefOfCopyAction<R> ReturnRefOfCopy(const R& x) {\n  return internal::ReturnRefOfCopyAction<R>(x);\n}\n\n// Modifies the parent action (a Return() action) to perform a move of the\n// argument instead of a copy.\n// Return(ByMove()) actions can only be executed once and will assert this\n// invariant.\ntemplate <typename R>\ninternal::ByMoveWrapper<R> ByMove(R x) {\n  return internal::ByMoveWrapper<R>(internal::move(x));\n}\n\n// Creates an action that does the default action for the give mock function.\ninline internal::DoDefaultAction DoDefault() {\n  return internal::DoDefaultAction();\n}\n\n// Creates an action that sets the variable pointed by the N-th\n// (0-based) function argument to 'value'.\ntemplate <size_t N, typename T>\nPolymorphicAction<\n  internal::SetArgumentPointeeAction<\n    N, T, internal::IsAProtocolMessage<T>::value> >\nSetArgPointee(const T& x) {\n  return MakePolymorphicAction(internal::SetArgumentPointeeAction<\n      N, T, internal::IsAProtocolMessage<T>::value>(x));\n}\n\n#if !((GTEST_GCC_VER_ && GTEST_GCC_VER_ < 40000) || GTEST_OS_SYMBIAN)\n// This overload allows SetArgPointee() to accept a string literal.\n// GCC prior to the version 4.0 and Symbian C++ compiler cannot distinguish\n// this overload from the templated version and emit a compile error.\ntemplate <size_t N>\nPolymorphicAction<\n  internal::SetArgumentPointeeAction<N, const char*, false> >\nSetArgPointee(const char* p) {\n  return MakePolymorphicAction(internal::SetArgumentPointeeAction<\n      N, const char*, false>(p));\n}\n\ntemplate <size_t N>\nPolymorphicAction<\n  internal::SetArgumentPointeeAction<N, const wchar_t*, false> >\nSetArgPointee(const wchar_t* p) {\n  return MakePolymorphicAction(internal::SetArgumentPointeeAction<\n      N, const wchar_t*, false>(p));\n}\n#endif\n\n// The following version is DEPRECATED.\ntemplate <size_t N, typename T>\nPolymorphicAction<\n  internal::SetArgumentPointeeAction<\n    N, T, internal::IsAProtocolMessage<T>::value> >\nSetArgumentPointee(const T& x) {\n  return MakePolymorphicAction(internal::SetArgumentPointeeAction<\n      N, T, internal::IsAProtocolMessage<T>::value>(x));\n}\n\n// Creates an action that sets a pointer referent to a given value.\ntemplate <typename T1, typename T2>\nPolymorphicAction<internal::AssignAction<T1, T2> > Assign(T1* ptr, T2 val) {\n  return MakePolymorphicAction(internal::AssignAction<T1, T2>(ptr, val));\n}\n\n#if !GTEST_OS_WINDOWS_MOBILE\n\n// Creates an action that sets errno and returns the appropriate error.\ntemplate <typename T>\nPolymorphicAction<internal::SetErrnoAndReturnAction<T> >\nSetErrnoAndReturn(int errval, T result) {\n  return MakePolymorphicAction(\n      internal::SetErrnoAndReturnAction<T>(errval, result));\n}\n\n#endif  // !GTEST_OS_WINDOWS_MOBILE\n\n// Various overloads for InvokeWithoutArgs().\n\n// Creates an action that invokes 'function_impl' with no argument.\ntemplate <typename FunctionImpl>\nPolymorphicAction<internal::InvokeWithoutArgsAction<FunctionImpl> >\nInvokeWithoutArgs(FunctionImpl function_impl) {\n  return MakePolymorphicAction(\n      internal::InvokeWithoutArgsAction<FunctionImpl>(function_impl));\n}\n\n// Creates an action that invokes the given method on the given object\n// with no argument.\ntemplate <class Class, typename MethodPtr>\nPolymorphicAction<internal::InvokeMethodWithoutArgsAction<Class, MethodPtr> >\nInvokeWithoutArgs(Class* obj_ptr, MethodPtr method_ptr) {\n  return MakePolymorphicAction(\n      internal::InvokeMethodWithoutArgsAction<Class, MethodPtr>(\n          obj_ptr, method_ptr));\n}\n\n// Creates an action that performs an_action and throws away its\n// result.  In other words, it changes the return type of an_action to\n// void.  an_action MUST NOT return void, or the code won't compile.\ntemplate <typename A>\ninline internal::IgnoreResultAction<A> IgnoreResult(const A& an_action) {\n  return internal::IgnoreResultAction<A>(an_action);\n}\n\n// Creates a reference wrapper for the given L-value.  If necessary,\n// you can explicitly specify the type of the reference.  For example,\n// suppose 'derived' is an object of type Derived, ByRef(derived)\n// would wrap a Derived&.  If you want to wrap a const Base& instead,\n// where Base is a base class of Derived, just write:\n//\n//   ByRef<const Base>(derived)\ntemplate <typename T>\ninline internal::ReferenceWrapper<T> ByRef(T& l_value) {  // NOLINT\n  return internal::ReferenceWrapper<T>(l_value);\n}\n\n}  // namespace testing\n\n#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_ACTIONS_H_\n"}, "35": {"id": 35, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-cardinalities.h", "content": "// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// This file implements some commonly used cardinalities.  More\n// cardinalities can be defined by the user implementing the\n// CardinalityInterface interface if necessary.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_CARDINALITIES_H_\n#define GMOCK_INCLUDE_GMOCK_GMOCK_CARDINALITIES_H_\n\n#include <limits.h>\n#include <ostream>  // NOLINT\n#include \"gmock/internal/gmock-port.h\"\n#include \"gtest/gtest.h\"\n\nnamespace testing {\n\n// To implement a cardinality Foo, define:\n//   1. a class FooCardinality that implements the\n//      CardinalityInterface interface, and\n//   2. a factory function that creates a Cardinality object from a\n//      const FooCardinality*.\n//\n// The two-level delegation design follows that of Matcher, providing\n// consistency for extension developers.  It also eases ownership\n// management as Cardinality objects can now be copied like plain values.\n\n// The implementation of a cardinality.\nclass CardinalityInterface {\n public:\n  virtual ~CardinalityInterface() {}\n\n  // Conservative estimate on the lower/upper bound of the number of\n  // calls allowed.\n  virtual int ConservativeLowerBound() const { return 0; }\n  virtual int ConservativeUpperBound() const { return INT_MAX; }\n\n  // Returns true iff call_count calls will satisfy this cardinality.\n  virtual bool IsSatisfiedByCallCount(int call_count) const = 0;\n\n  // Returns true iff call_count calls will saturate this cardinality.\n  virtual bool IsSaturatedByCallCount(int call_count) const = 0;\n\n  // Describes self to an ostream.\n  virtual void DescribeTo(::std::ostream* os) const = 0;\n};\n\n// A Cardinality is a copyable and IMMUTABLE (except by assignment)\n// object that specifies how many times a mock function is expected to\n// be called.  The implementation of Cardinality is just a linked_ptr\n// to const CardinalityInterface, so copying is fairly cheap.\n// Don't inherit from Cardinality!\nclass GTEST_API_ Cardinality {\n public:\n  // Constructs a null cardinality.  Needed for storing Cardinality\n  // objects in STL containers.\n  Cardinality() {}\n\n  // Constructs a Cardinality from its implementation.\n  explicit Cardinality(const CardinalityInterface* impl) : impl_(impl) {}\n\n  // Conservative estimate on the lower/upper bound of the number of\n  // calls allowed.\n  int ConservativeLowerBound() const { return impl_->ConservativeLowerBound(); }\n  int ConservativeUpperBound() const { return impl_->ConservativeUpperBound(); }\n\n  // Returns true iff call_count calls will satisfy this cardinality.\n  bool IsSatisfiedByCallCount(int call_count) const {\n    return impl_->IsSatisfiedByCallCount(call_count);\n  }\n\n  // Returns true iff call_count calls will saturate this cardinality.\n  bool IsSaturatedByCallCount(int call_count) const {\n    return impl_->IsSaturatedByCallCount(call_count);\n  }\n\n  // Returns true iff call_count calls will over-saturate this\n  // cardinality, i.e. exceed the maximum number of allowed calls.\n  bool IsOverSaturatedByCallCount(int call_count) const {\n    return impl_->IsSaturatedByCallCount(call_count) &&\n        !impl_->IsSatisfiedByCallCount(call_count);\n  }\n\n  // Describes self to an ostream\n  void DescribeTo(::std::ostream* os) const { impl_->DescribeTo(os); }\n\n  // Describes the given actual call count to an ostream.\n  static void DescribeActualCallCountTo(int actual_call_count,\n                                        ::std::ostream* os);\n\n private:\n  internal::linked_ptr<const CardinalityInterface> impl_;\n};\n\n// Creates a cardinality that allows at least n calls.\nGTEST_API_ Cardinality AtLeast(int n);\n\n// Creates a cardinality that allows at most n calls.\nGTEST_API_ Cardinality AtMost(int n);\n\n// Creates a cardinality that allows any number of calls.\nGTEST_API_ Cardinality AnyNumber();\n\n// Creates a cardinality that allows between min and max calls.\nGTEST_API_ Cardinality Between(int min, int max);\n\n// Creates a cardinality that allows exactly n calls.\nGTEST_API_ Cardinality Exactly(int n);\n\n// Creates a cardinality from its implementation.\ninline Cardinality MakeCardinality(const CardinalityInterface* c) {\n  return Cardinality(c);\n}\n\n}  // namespace testing\n\n#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_CARDINALITIES_H_\n"}, "36": {"id": 36, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-generated-actions.h", "content": "// This file was GENERATED by a script.  DO NOT EDIT BY HAND!!!\n\n// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// This file implements some commonly used variadic actions.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_ACTIONS_H_\n#define GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_ACTIONS_H_\n\n#include \"gmock/gmock-actions.h\"\n#include \"gmock/internal/gmock-port.h\"\n\nnamespace testing {\nnamespace internal {\n\n// InvokeHelper<F> knows how to unpack an N-tuple and invoke an N-ary\n// function or method with the unpacked values, where F is a function\n// type that takes N arguments.\ntemplate <typename Result, typename ArgumentTuple>\nclass InvokeHelper;\n\ntemplate <typename R>\nclass InvokeHelper<R, ::testing::tuple<> > {\n public:\n  template <typename Function>\n  static R Invoke(Function function, const ::testing::tuple<>&) {\n           return function();\n  }\n\n  template <class Class, typename MethodPtr>\n  static R InvokeMethod(Class* obj_ptr,\n                        MethodPtr method_ptr,\n                        const ::testing::tuple<>&) {\n           return (obj_ptr->*method_ptr)();\n  }\n};\n\ntemplate <typename R, typename A1>\nclass InvokeHelper<R, ::testing::tuple<A1> > {\n public:\n  template <typename Function>\n  static R Invoke(Function function, const ::testing::tuple<A1>& args) {\n           return function(get<0>(args));\n  }\n\n  template <class Class, typename MethodPtr>\n  static R InvokeMethod(Class* obj_ptr,\n                        MethodPtr method_ptr,\n                        const ::testing::tuple<A1>& args) {\n           return (obj_ptr->*method_ptr)(get<0>(args));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2>\nclass InvokeHelper<R, ::testing::tuple<A1, A2> > {\n public:\n  template <typename Function>\n  static R Invoke(Function function, const ::testing::tuple<A1, A2>& args) {\n           return function(get<0>(args), get<1>(args));\n  }\n\n  template <class Class, typename MethodPtr>\n  static R InvokeMethod(Class* obj_ptr,\n                        MethodPtr method_ptr,\n                        const ::testing::tuple<A1, A2>& args) {\n           return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3>\nclass InvokeHelper<R, ::testing::tuple<A1, A2, A3> > {\n public:\n  template <typename Function>\n  static R Invoke(Function function, const ::testing::tuple<A1, A2, A3>& args) {\n           return function(get<0>(args), get<1>(args), get<2>(args));\n  }\n\n  template <class Class, typename MethodPtr>\n  static R InvokeMethod(Class* obj_ptr,\n                        MethodPtr method_ptr,\n                        const ::testing::tuple<A1, A2, A3>& args) {\n           return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args),\n               get<2>(args));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4>\nclass InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4> > {\n public:\n  template <typename Function>\n  static R Invoke(Function function, const ::testing::tuple<A1, A2, A3,\n      A4>& args) {\n           return function(get<0>(args), get<1>(args), get<2>(args),\n               get<3>(args));\n  }\n\n  template <class Class, typename MethodPtr>\n  static R InvokeMethod(Class* obj_ptr,\n                        MethodPtr method_ptr,\n                        const ::testing::tuple<A1, A2, A3, A4>& args) {\n           return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args),\n               get<2>(args), get<3>(args));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5>\nclass InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4, A5> > {\n public:\n  template <typename Function>\n  static R Invoke(Function function, const ::testing::tuple<A1, A2, A3, A4,\n      A5>& args) {\n           return function(get<0>(args), get<1>(args), get<2>(args),\n               get<3>(args), get<4>(args));\n  }\n\n  template <class Class, typename MethodPtr>\n  static R InvokeMethod(Class* obj_ptr,\n                        MethodPtr method_ptr,\n                        const ::testing::tuple<A1, A2, A3, A4, A5>& args) {\n           return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args),\n               get<2>(args), get<3>(args), get<4>(args));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6>\nclass InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4, A5, A6> > {\n public:\n  template <typename Function>\n  static R Invoke(Function function, const ::testing::tuple<A1, A2, A3, A4, A5,\n      A6>& args) {\n           return function(get<0>(args), get<1>(args), get<2>(args),\n               get<3>(args), get<4>(args), get<5>(args));\n  }\n\n  template <class Class, typename MethodPtr>\n  static R InvokeMethod(Class* obj_ptr,\n                        MethodPtr method_ptr,\n                        const ::testing::tuple<A1, A2, A3, A4, A5, A6>& args) {\n           return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args),\n               get<2>(args), get<3>(args), get<4>(args), get<5>(args));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6, typename A7>\nclass InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4, A5, A6, A7> > {\n public:\n  template <typename Function>\n  static R Invoke(Function function, const ::testing::tuple<A1, A2, A3, A4, A5,\n      A6, A7>& args) {\n           return function(get<0>(args), get<1>(args), get<2>(args),\n               get<3>(args), get<4>(args), get<5>(args), get<6>(args));\n  }\n\n  template <class Class, typename MethodPtr>\n  static R InvokeMethod(Class* obj_ptr,\n                        MethodPtr method_ptr,\n                        const ::testing::tuple<A1, A2, A3, A4, A5, A6,\n                            A7>& args) {\n           return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args),\n               get<2>(args), get<3>(args), get<4>(args), get<5>(args),\n               get<6>(args));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6, typename A7, typename A8>\nclass InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8> > {\n public:\n  template <typename Function>\n  static R Invoke(Function function, const ::testing::tuple<A1, A2, A3, A4, A5,\n      A6, A7, A8>& args) {\n           return function(get<0>(args), get<1>(args), get<2>(args),\n               get<3>(args), get<4>(args), get<5>(args), get<6>(args),\n               get<7>(args));\n  }\n\n  template <class Class, typename MethodPtr>\n  static R InvokeMethod(Class* obj_ptr,\n                        MethodPtr method_ptr,\n                        const ::testing::tuple<A1, A2, A3, A4, A5, A6, A7,\n                            A8>& args) {\n           return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args),\n               get<2>(args), get<3>(args), get<4>(args), get<5>(args),\n               get<6>(args), get<7>(args));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6, typename A7, typename A8, typename A9>\nclass InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8, A9> > {\n public:\n  template <typename Function>\n  static R Invoke(Function function, const ::testing::tuple<A1, A2, A3, A4, A5,\n      A6, A7, A8, A9>& args) {\n           return function(get<0>(args), get<1>(args), get<2>(args),\n               get<3>(args), get<4>(args), get<5>(args), get<6>(args),\n               get<7>(args), get<8>(args));\n  }\n\n  template <class Class, typename MethodPtr>\n  static R InvokeMethod(Class* obj_ptr,\n                        MethodPtr method_ptr,\n                        const ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8,\n                            A9>& args) {\n           return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args),\n               get<2>(args), get<3>(args), get<4>(args), get<5>(args),\n               get<6>(args), get<7>(args), get<8>(args));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6, typename A7, typename A8, typename A9,\n    typename A10>\nclass InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8, A9,\n    A10> > {\n public:\n  template <typename Function>\n  static R Invoke(Function function, const ::testing::tuple<A1, A2, A3, A4, A5,\n      A6, A7, A8, A9, A10>& args) {\n           return function(get<0>(args), get<1>(args), get<2>(args),\n               get<3>(args), get<4>(args), get<5>(args), get<6>(args),\n               get<7>(args), get<8>(args), get<9>(args));\n  }\n\n  template <class Class, typename MethodPtr>\n  static R InvokeMethod(Class* obj_ptr,\n                        MethodPtr method_ptr,\n                        const ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8,\n                            A9, A10>& args) {\n           return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args),\n               get<2>(args), get<3>(args), get<4>(args), get<5>(args),\n               get<6>(args), get<7>(args), get<8>(args), get<9>(args));\n  }\n};\n\n// An INTERNAL macro for extracting the type of a tuple field.  It's\n// subject to change without notice - DO NOT USE IN USER CODE!\n#define GMOCK_FIELD_(Tuple, N) \\\n    typename ::testing::tuple_element<N, Tuple>::type\n\n// SelectArgs<Result, ArgumentTuple, k1, k2, ..., k_n>::type is the\n// type of an n-ary function whose i-th (1-based) argument type is the\n// k{i}-th (0-based) field of ArgumentTuple, which must be a tuple\n// type, and whose return type is Result.  For example,\n//   SelectArgs<int, ::testing::tuple<bool, char, double, long>, 0, 3>::type\n// is int(bool, long).\n//\n// SelectArgs<Result, ArgumentTuple, k1, k2, ..., k_n>::Select(args)\n// returns the selected fields (k1, k2, ..., k_n) of args as a tuple.\n// For example,\n//   SelectArgs<int, tuple<bool, char, double>, 2, 0>::Select(\n//       ::testing::make_tuple(true, 'a', 2.5))\n// returns tuple (2.5, true).\n//\n// The numbers in list k1, k2, ..., k_n must be >= 0, where n can be\n// in the range [0, 10].  Duplicates are allowed and they don't have\n// to be in an ascending or descending order.\n\ntemplate <typename Result, typename ArgumentTuple, int k1, int k2, int k3,\n    int k4, int k5, int k6, int k7, int k8, int k9, int k10>\nclass SelectArgs {\n public:\n  typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),\n      GMOCK_FIELD_(ArgumentTuple, k2), GMOCK_FIELD_(ArgumentTuple, k3),\n      GMOCK_FIELD_(ArgumentTuple, k4), GMOCK_FIELD_(ArgumentTuple, k5),\n      GMOCK_FIELD_(ArgumentTuple, k6), GMOCK_FIELD_(ArgumentTuple, k7),\n      GMOCK_FIELD_(ArgumentTuple, k8), GMOCK_FIELD_(ArgumentTuple, k9),\n      GMOCK_FIELD_(ArgumentTuple, k10));\n  typedef typename Function<type>::ArgumentTuple SelectedArgs;\n  static SelectedArgs Select(const ArgumentTuple& args) {\n    return SelectedArgs(get<k1>(args), get<k2>(args), get<k3>(args),\n        get<k4>(args), get<k5>(args), get<k6>(args), get<k7>(args),\n        get<k8>(args), get<k9>(args), get<k10>(args));\n  }\n};\n\ntemplate <typename Result, typename ArgumentTuple>\nclass SelectArgs<Result, ArgumentTuple,\n                 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef Result type();\n  typedef typename Function<type>::ArgumentTuple SelectedArgs;\n  static SelectedArgs Select(const ArgumentTuple& /* args */) {\n    return SelectedArgs();\n  }\n};\n\ntemplate <typename Result, typename ArgumentTuple, int k1>\nclass SelectArgs<Result, ArgumentTuple,\n                 k1, -1, -1, -1, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1));\n  typedef typename Function<type>::ArgumentTuple SelectedArgs;\n  static SelectedArgs Select(const ArgumentTuple& args) {\n    return SelectedArgs(get<k1>(args));\n  }\n};\n\ntemplate <typename Result, typename ArgumentTuple, int k1, int k2>\nclass SelectArgs<Result, ArgumentTuple,\n                 k1, k2, -1, -1, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),\n      GMOCK_FIELD_(ArgumentTuple, k2));\n  typedef typename Function<type>::ArgumentTuple SelectedArgs;\n  static SelectedArgs Select(const ArgumentTuple& args) {\n    return SelectedArgs(get<k1>(args), get<k2>(args));\n  }\n};\n\ntemplate <typename Result, typename ArgumentTuple, int k1, int k2, int k3>\nclass SelectArgs<Result, ArgumentTuple,\n                 k1, k2, k3, -1, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),\n      GMOCK_FIELD_(ArgumentTuple, k2), GMOCK_FIELD_(ArgumentTuple, k3));\n  typedef typename Function<type>::ArgumentTuple SelectedArgs;\n  static SelectedArgs Select(const ArgumentTuple& args) {\n    return SelectedArgs(get<k1>(args), get<k2>(args), get<k3>(args));\n  }\n};\n\ntemplate <typename Result, typename ArgumentTuple, int k1, int k2, int k3,\n    int k4>\nclass SelectArgs<Result, ArgumentTuple,\n                 k1, k2, k3, k4, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),\n      GMOCK_FIELD_(ArgumentTuple, k2), GMOCK_FIELD_(ArgumentTuple, k3),\n      GMOCK_FIELD_(ArgumentTuple, k4));\n  typedef typename Function<type>::ArgumentTuple SelectedArgs;\n  static SelectedArgs Select(const ArgumentTuple& args) {\n    return SelectedArgs(get<k1>(args), get<k2>(args), get<k3>(args),\n        get<k4>(args));\n  }\n};\n\ntemplate <typename Result, typename ArgumentTuple, int k1, int k2, int k3,\n    int k4, int k5>\nclass SelectArgs<Result, ArgumentTuple,\n                 k1, k2, k3, k4, k5, -1, -1, -1, -1, -1> {\n public:\n  typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),\n      GMOCK_FIELD_(ArgumentTuple, k2), GMOCK_FIELD_(ArgumentTuple, k3),\n      GMOCK_FIELD_(ArgumentTuple, k4), GMOCK_FIELD_(ArgumentTuple, k5));\n  typedef typename Function<type>::ArgumentTuple SelectedArgs;\n  static SelectedArgs Select(const ArgumentTuple& args) {\n    return SelectedArgs(get<k1>(args), get<k2>(args), get<k3>(args),\n        get<k4>(args), get<k5>(args));\n  }\n};\n\ntemplate <typename Result, typename ArgumentTuple, int k1, int k2, int k3,\n    int k4, int k5, int k6>\nclass SelectArgs<Result, ArgumentTuple,\n                 k1, k2, k3, k4, k5, k6, -1, -1, -1, -1> {\n public:\n  typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),\n      GMOCK_FIELD_(ArgumentTuple, k2), GMOCK_FIELD_(ArgumentTuple, k3),\n      GMOCK_FIELD_(ArgumentTuple, k4), GMOCK_FIELD_(ArgumentTuple, k5),\n      GMOCK_FIELD_(ArgumentTuple, k6));\n  typedef typename Function<type>::ArgumentTuple SelectedArgs;\n  static SelectedArgs Select(const ArgumentTuple& args) {\n    return SelectedArgs(get<k1>(args), get<k2>(args), get<k3>(args),\n        get<k4>(args), get<k5>(args), get<k6>(args));\n  }\n};\n\ntemplate <typename Result, typename ArgumentTuple, int k1, int k2, int k3,\n    int k4, int k5, int k6, int k7>\nclass SelectArgs<Result, ArgumentTuple,\n                 k1, k2, k3, k4, k5, k6, k7, -1, -1, -1> {\n public:\n  typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),\n      GMOCK_FIELD_(ArgumentTuple, k2), GMOCK_FIELD_(ArgumentTuple, k3),\n      GMOCK_FIELD_(ArgumentTuple, k4), GMOCK_FIELD_(ArgumentTuple, k5),\n      GMOCK_FIELD_(ArgumentTuple, k6), GMOCK_FIELD_(ArgumentTuple, k7));\n  typedef typename Function<type>::ArgumentTuple SelectedArgs;\n  static SelectedArgs Select(const ArgumentTuple& args) {\n    return SelectedArgs(get<k1>(args), get<k2>(args), get<k3>(args),\n        get<k4>(args), get<k5>(args), get<k6>(args), get<k7>(args));\n  }\n};\n\ntemplate <typename Result, typename ArgumentTuple, int k1, int k2, int k3,\n    int k4, int k5, int k6, int k7, int k8>\nclass SelectArgs<Result, ArgumentTuple,\n                 k1, k2, k3, k4, k5, k6, k7, k8, -1, -1> {\n public:\n  typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),\n      GMOCK_FIELD_(ArgumentTuple, k2), GMOCK_FIELD_(ArgumentTuple, k3),\n      GMOCK_FIELD_(ArgumentTuple, k4), GMOCK_FIELD_(ArgumentTuple, k5),\n      GMOCK_FIELD_(ArgumentTuple, k6), GMOCK_FIELD_(ArgumentTuple, k7),\n      GMOCK_FIELD_(ArgumentTuple, k8));\n  typedef typename Function<type>::ArgumentTuple SelectedArgs;\n  static SelectedArgs Select(const ArgumentTuple& args) {\n    return SelectedArgs(get<k1>(args), get<k2>(args), get<k3>(args),\n        get<k4>(args), get<k5>(args), get<k6>(args), get<k7>(args),\n        get<k8>(args));\n  }\n};\n\ntemplate <typename Result, typename ArgumentTuple, int k1, int k2, int k3,\n    int k4, int k5, int k6, int k7, int k8, int k9>\nclass SelectArgs<Result, ArgumentTuple,\n                 k1, k2, k3, k4, k5, k6, k7, k8, k9, -1> {\n public:\n  typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),\n      GMOCK_FIELD_(ArgumentTuple, k2), GMOCK_FIELD_(ArgumentTuple, k3),\n      GMOCK_FIELD_(ArgumentTuple, k4), GMOCK_FIELD_(ArgumentTuple, k5),\n      GMOCK_FIELD_(ArgumentTuple, k6), GMOCK_FIELD_(ArgumentTuple, k7),\n      GMOCK_FIELD_(ArgumentTuple, k8), GMOCK_FIELD_(ArgumentTuple, k9));\n  typedef typename Function<type>::ArgumentTuple SelectedArgs;\n  static SelectedArgs Select(const ArgumentTuple& args) {\n    return SelectedArgs(get<k1>(args), get<k2>(args), get<k3>(args),\n        get<k4>(args), get<k5>(args), get<k6>(args), get<k7>(args),\n        get<k8>(args), get<k9>(args));\n  }\n};\n\n#undef GMOCK_FIELD_\n\n// Implements the WithArgs action.\ntemplate <typename InnerAction, int k1 = -1, int k2 = -1, int k3 = -1,\n    int k4 = -1, int k5 = -1, int k6 = -1, int k7 = -1, int k8 = -1,\n    int k9 = -1, int k10 = -1>\nclass WithArgsAction {\n public:\n  explicit WithArgsAction(const InnerAction& action) : action_(action) {}\n\n  template <typename F>\n  operator Action<F>() const { return MakeAction(new Impl<F>(action_)); }\n\n private:\n  template <typename F>\n  class Impl : public ActionInterface<F> {\n   public:\n    typedef typename Function<F>::Result Result;\n    typedef typename Function<F>::ArgumentTuple ArgumentTuple;\n\n    explicit Impl(const InnerAction& action) : action_(action) {}\n\n    virtual Result Perform(const ArgumentTuple& args) {\n      return action_.Perform(SelectArgs<Result, ArgumentTuple, k1, k2, k3, k4,\n          k5, k6, k7, k8, k9, k10>::Select(args));\n    }\n\n   private:\n    typedef typename SelectArgs<Result, ArgumentTuple,\n        k1, k2, k3, k4, k5, k6, k7, k8, k9, k10>::type InnerFunctionType;\n\n    Action<InnerFunctionType> action_;\n  };\n\n  const InnerAction action_;\n\n  GTEST_DISALLOW_ASSIGN_(WithArgsAction);\n};\n\n// A macro from the ACTION* family (defined later in this file)\n// defines an action that can be used in a mock function.  Typically,\n// these actions only care about a subset of the arguments of the mock\n// function.  For example, if such an action only uses the second\n// argument, it can be used in any mock function that takes >= 2\n// arguments where the type of the second argument is compatible.\n//\n// Therefore, the action implementation must be prepared to take more\n// arguments than it needs.  The ExcessiveArg type is used to\n// represent those excessive arguments.  In order to keep the compiler\n// error messages tractable, we define it in the testing namespace\n// instead of testing::internal.  However, this is an INTERNAL TYPE\n// and subject to change without notice, so a user MUST NOT USE THIS\n// TYPE DIRECTLY.\nstruct ExcessiveArg {};\n\n// A helper class needed for implementing the ACTION* macros.\ntemplate <typename Result, class Impl>\nclass ActionHelper {\n public:\n  static Result Perform(Impl* impl, const ::testing::tuple<>& args) {\n    return impl->template gmock_PerformImpl<>(args, ExcessiveArg(),\n        ExcessiveArg(), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg(), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg());\n  }\n\n  template <typename A0>\n  static Result Perform(Impl* impl, const ::testing::tuple<A0>& args) {\n    return impl->template gmock_PerformImpl<A0>(args, get<0>(args),\n        ExcessiveArg(), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg(), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg());\n  }\n\n  template <typename A0, typename A1>\n  static Result Perform(Impl* impl, const ::testing::tuple<A0, A1>& args) {\n    return impl->template gmock_PerformImpl<A0, A1>(args, get<0>(args),\n        get<1>(args), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg(), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg());\n  }\n\n  template <typename A0, typename A1, typename A2>\n  static Result Perform(Impl* impl, const ::testing::tuple<A0, A1, A2>& args) {\n    return impl->template gmock_PerformImpl<A0, A1, A2>(args, get<0>(args),\n        get<1>(args), get<2>(args), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg(), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg());\n  }\n\n  template <typename A0, typename A1, typename A2, typename A3>\n  static Result Perform(Impl* impl, const ::testing::tuple<A0, A1, A2,\n      A3>& args) {\n    return impl->template gmock_PerformImpl<A0, A1, A2, A3>(args, get<0>(args),\n        get<1>(args), get<2>(args), get<3>(args), ExcessiveArg(),\n        ExcessiveArg(), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg());\n  }\n\n  template <typename A0, typename A1, typename A2, typename A3, typename A4>\n  static Result Perform(Impl* impl, const ::testing::tuple<A0, A1, A2, A3,\n      A4>& args) {\n    return impl->template gmock_PerformImpl<A0, A1, A2, A3, A4>(args,\n        get<0>(args), get<1>(args), get<2>(args), get<3>(args), get<4>(args),\n        ExcessiveArg(), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg());\n  }\n\n  template <typename A0, typename A1, typename A2, typename A3, typename A4,\n      typename A5>\n  static Result Perform(Impl* impl, const ::testing::tuple<A0, A1, A2, A3, A4,\n      A5>& args) {\n    return impl->template gmock_PerformImpl<A0, A1, A2, A3, A4, A5>(args,\n        get<0>(args), get<1>(args), get<2>(args), get<3>(args), get<4>(args),\n        get<5>(args), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg());\n  }\n\n  template <typename A0, typename A1, typename A2, typename A3, typename A4,\n      typename A5, typename A6>\n  static Result Perform(Impl* impl, const ::testing::tuple<A0, A1, A2, A3, A4,\n      A5, A6>& args) {\n    return impl->template gmock_PerformImpl<A0, A1, A2, A3, A4, A5, A6>(args,\n        get<0>(args), get<1>(args), get<2>(args), get<3>(args), get<4>(args),\n        get<5>(args), get<6>(args), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg());\n  }\n\n  template <typename A0, typename A1, typename A2, typename A3, typename A4,\n      typename A5, typename A6, typename A7>\n  static Result Perform(Impl* impl, const ::testing::tuple<A0, A1, A2, A3, A4,\n      A5, A6, A7>& args) {\n    return impl->template gmock_PerformImpl<A0, A1, A2, A3, A4, A5, A6,\n        A7>(args, get<0>(args), get<1>(args), get<2>(args), get<3>(args),\n        get<4>(args), get<5>(args), get<6>(args), get<7>(args), ExcessiveArg(),\n        ExcessiveArg());\n  }\n\n  template <typename A0, typename A1, typename A2, typename A3, typename A4,\n      typename A5, typename A6, typename A7, typename A8>\n  static Result Perform(Impl* impl, const ::testing::tuple<A0, A1, A2, A3, A4,\n      A5, A6, A7, A8>& args) {\n    return impl->template gmock_PerformImpl<A0, A1, A2, A3, A4, A5, A6, A7,\n        A8>(args, get<0>(args), get<1>(args), get<2>(args), get<3>(args),\n        get<4>(args), get<5>(args), get<6>(args), get<7>(args), get<8>(args),\n        ExcessiveArg());\n  }\n\n  template <typename A0, typename A1, typename A2, typename A3, typename A4,\n      typename A5, typename A6, typename A7, typename A8, typename A9>\n  static Result Perform(Impl* impl, const ::testing::tuple<A0, A1, A2, A3, A4,\n      A5, A6, A7, A8, A9>& args) {\n    return impl->template gmock_PerformImpl<A0, A1, A2, A3, A4, A5, A6, A7, A8,\n        A9>(args, get<0>(args), get<1>(args), get<2>(args), get<3>(args),\n        get<4>(args), get<5>(args), get<6>(args), get<7>(args), get<8>(args),\n        get<9>(args));\n  }\n};\n\n}  // namespace internal\n\n// Various overloads for Invoke().\n\n// WithArgs<N1, N2, ..., Nk>(an_action) creates an action that passes\n// the selected arguments of the mock function to an_action and\n// performs it.  It serves as an adaptor between actions with\n// different argument lists.  C++ doesn't support default arguments for\n// function templates, so we have to overload it.\ntemplate <int k1, typename InnerAction>\ninline internal::WithArgsAction<InnerAction, k1>\nWithArgs(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction, k1>(action);\n}\n\ntemplate <int k1, int k2, typename InnerAction>\ninline internal::WithArgsAction<InnerAction, k1, k2>\nWithArgs(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction, k1, k2>(action);\n}\n\ntemplate <int k1, int k2, int k3, typename InnerAction>\ninline internal::WithArgsAction<InnerAction, k1, k2, k3>\nWithArgs(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction, k1, k2, k3>(action);\n}\n\ntemplate <int k1, int k2, int k3, int k4, typename InnerAction>\ninline internal::WithArgsAction<InnerAction, k1, k2, k3, k4>\nWithArgs(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction, k1, k2, k3, k4>(action);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, typename InnerAction>\ninline internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5>\nWithArgs(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5>(action);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, typename InnerAction>\ninline internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6>\nWithArgs(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6>(action);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, int k7,\n    typename InnerAction>\ninline internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6, k7>\nWithArgs(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6,\n      k7>(action);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, int k7, int k8,\n    typename InnerAction>\ninline internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6, k7, k8>\nWithArgs(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6, k7,\n      k8>(action);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, int k7, int k8,\n    int k9, typename InnerAction>\ninline internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6, k7, k8, k9>\nWithArgs(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6, k7, k8,\n      k9>(action);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, int k7, int k8,\n    int k9, int k10, typename InnerAction>\ninline internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6, k7, k8,\n    k9, k10>\nWithArgs(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6, k7, k8,\n      k9, k10>(action);\n}\n\n// Creates an action that does actions a1, a2, ..., sequentially in\n// each invocation.\ntemplate <typename Action1, typename Action2>\ninline internal::DoBothAction<Action1, Action2>\nDoAll(Action1 a1, Action2 a2) {\n  return internal::DoBothAction<Action1, Action2>(a1, a2);\n}\n\ntemplate <typename Action1, typename Action2, typename Action3>\ninline internal::DoBothAction<Action1, internal::DoBothAction<Action2,\n    Action3> >\nDoAll(Action1 a1, Action2 a2, Action3 a3) {\n  return DoAll(a1, DoAll(a2, a3));\n}\n\ntemplate <typename Action1, typename Action2, typename Action3,\n    typename Action4>\ninline internal::DoBothAction<Action1, internal::DoBothAction<Action2,\n    internal::DoBothAction<Action3, Action4> > >\nDoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4) {\n  return DoAll(a1, DoAll(a2, a3, a4));\n}\n\ntemplate <typename Action1, typename Action2, typename Action3,\n    typename Action4, typename Action5>\ninline internal::DoBothAction<Action1, internal::DoBothAction<Action2,\n    internal::DoBothAction<Action3, internal::DoBothAction<Action4,\n    Action5> > > >\nDoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4, Action5 a5) {\n  return DoAll(a1, DoAll(a2, a3, a4, a5));\n}\n\ntemplate <typename Action1, typename Action2, typename Action3,\n    typename Action4, typename Action5, typename Action6>\ninline internal::DoBothAction<Action1, internal::DoBothAction<Action2,\n    internal::DoBothAction<Action3, internal::DoBothAction<Action4,\n    internal::DoBothAction<Action5, Action6> > > > >\nDoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4, Action5 a5, Action6 a6) {\n  return DoAll(a1, DoAll(a2, a3, a4, a5, a6));\n}\n\ntemplate <typename Action1, typename Action2, typename Action3,\n    typename Action4, typename Action5, typename Action6, typename Action7>\ninline internal::DoBothAction<Action1, internal::DoBothAction<Action2,\n    internal::DoBothAction<Action3, internal::DoBothAction<Action4,\n    internal::DoBothAction<Action5, internal::DoBothAction<Action6,\n    Action7> > > > > >\nDoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4, Action5 a5, Action6 a6,\n    Action7 a7) {\n  return DoAll(a1, DoAll(a2, a3, a4, a5, a6, a7));\n}\n\ntemplate <typename Action1, typename Action2, typename Action3,\n    typename Action4, typename Action5, typename Action6, typename Action7,\n    typename Action8>\ninline internal::DoBothAction<Action1, internal::DoBothAction<Action2,\n    internal::DoBothAction<Action3, internal::DoBothAction<Action4,\n    internal::DoBothAction<Action5, internal::DoBothAction<Action6,\n    internal::DoBothAction<Action7, Action8> > > > > > >\nDoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4, Action5 a5, Action6 a6,\n    Action7 a7, Action8 a8) {\n  return DoAll(a1, DoAll(a2, a3, a4, a5, a6, a7, a8));\n}\n\ntemplate <typename Action1, typename Action2, typename Action3,\n    typename Action4, typename Action5, typename Action6, typename Action7,\n    typename Action8, typename Action9>\ninline internal::DoBothAction<Action1, internal::DoBothAction<Action2,\n    internal::DoBothAction<Action3, internal::DoBothAction<Action4,\n    internal::DoBothAction<Action5, internal::DoBothAction<Action6,\n    internal::DoBothAction<Action7, internal::DoBothAction<Action8,\n    Action9> > > > > > > >\nDoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4, Action5 a5, Action6 a6,\n    Action7 a7, Action8 a8, Action9 a9) {\n  return DoAll(a1, DoAll(a2, a3, a4, a5, a6, a7, a8, a9));\n}\n\ntemplate <typename Action1, typename Action2, typename Action3,\n    typename Action4, typename Action5, typename Action6, typename Action7,\n    typename Action8, typename Action9, typename Action10>\ninline internal::DoBothAction<Action1, internal::DoBothAction<Action2,\n    internal::DoBothAction<Action3, internal::DoBothAction<Action4,\n    internal::DoBothAction<Action5, internal::DoBothAction<Action6,\n    internal::DoBothAction<Action7, internal::DoBothAction<Action8,\n    internal::DoBothAction<Action9, Action10> > > > > > > > >\nDoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4, Action5 a5, Action6 a6,\n    Action7 a7, Action8 a8, Action9 a9, Action10 a10) {\n  return DoAll(a1, DoAll(a2, a3, a4, a5, a6, a7, a8, a9, a10));\n}\n\n}  // namespace testing\n\n// The ACTION* family of macros can be used in a namespace scope to\n// define custom actions easily.  The syntax:\n//\n//   ACTION(name) { statements; }\n//\n// will define an action with the given name that executes the\n// statements.  The value returned by the statements will be used as\n// the return value of the action.  Inside the statements, you can\n// refer to the K-th (0-based) argument of the mock function by\n// 'argK', and refer to its type by 'argK_type'.  For example:\n//\n//   ACTION(IncrementArg1) {\n//     arg1_type temp = arg1;\n//     return ++(*temp);\n//   }\n//\n// allows you to write\n//\n//   ...WillOnce(IncrementArg1());\n//\n// You can also refer to the entire argument tuple and its type by\n// 'args' and 'args_type', and refer to the mock function type and its\n// return type by 'function_type' and 'return_type'.\n//\n// Note that you don't need to specify the types of the mock function\n// arguments.  However rest assured that your code is still type-safe:\n// you'll get a compiler error if *arg1 doesn't support the ++\n// operator, or if the type of ++(*arg1) isn't compatible with the\n// mock function's return type, for example.\n//\n// Sometimes you'll want to parameterize the action.   For that you can use\n// another macro:\n//\n//   ACTION_P(name, param_name) { statements; }\n//\n// For example:\n//\n//   ACTION_P(Add, n) { return arg0 + n; }\n//\n// will allow you to write:\n//\n//   ...WillOnce(Add(5));\n//\n// Note that you don't need to provide the type of the parameter\n// either.  If you need to reference the type of a parameter named\n// 'foo', you can write 'foo_type'.  For example, in the body of\n// ACTION_P(Add, n) above, you can write 'n_type' to refer to the type\n// of 'n'.\n//\n// We also provide ACTION_P2, ACTION_P3, ..., up to ACTION_P10 to support\n// multi-parameter actions.\n//\n// For the purpose of typing, you can view\n//\n//   ACTION_Pk(Foo, p1, ..., pk) { ... }\n//\n// as shorthand for\n//\n//   template <typename p1_type, ..., typename pk_type>\n//   FooActionPk<p1_type, ..., pk_type> Foo(p1_type p1, ..., pk_type pk) { ... }\n//\n// In particular, you can provide the template type arguments\n// explicitly when invoking Foo(), as in Foo<long, bool>(5, false);\n// although usually you can rely on the compiler to infer the types\n// for you automatically.  You can assign the result of expression\n// Foo(p1, ..., pk) to a variable of type FooActionPk<p1_type, ...,\n// pk_type>.  This can be useful when composing actions.\n//\n// You can also overload actions with different numbers of parameters:\n//\n//   ACTION_P(Plus, a) { ... }\n//   ACTION_P2(Plus, a, b) { ... }\n//\n// While it's tempting to always use the ACTION* macros when defining\n// a new action, you should also consider implementing ActionInterface\n// or using MakePolymorphicAction() instead, especially if you need to\n// use the action a lot.  While these approaches require more work,\n// they give you more control on the types of the mock function\n// arguments and the action parameters, which in general leads to\n// better compiler error messages that pay off in the long run.  They\n// also allow overloading actions based on parameter types (as opposed\n// to just based on the number of parameters).\n//\n// CAVEAT:\n//\n// ACTION*() can only be used in a namespace scope.  The reason is\n// that C++ doesn't yet allow function-local types to be used to\n// instantiate templates.  The up-coming C++0x standard will fix this.\n// Once that's done, we'll consider supporting using ACTION*() inside\n// a function.\n//\n// MORE INFORMATION:\n//\n// To learn more about using these macros, please search for 'ACTION'\n// on http://code.google.com/p/googlemock/wiki/CookBook.\n\n// An internal macro needed for implementing ACTION*().\n#define GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_\\\n    const args_type& args GTEST_ATTRIBUTE_UNUSED_, \\\n    arg0_type arg0 GTEST_ATTRIBUTE_UNUSED_, \\\n    arg1_type arg1 GTEST_ATTRIBUTE_UNUSED_, \\\n    arg2_type arg2 GTEST_ATTRIBUTE_UNUSED_, \\\n    arg3_type arg3 GTEST_ATTRIBUTE_UNUSED_, \\\n    arg4_type arg4 GTEST_ATTRIBUTE_UNUSED_, \\\n    arg5_type arg5 GTEST_ATTRIBUTE_UNUSED_, \\\n    arg6_type arg6 GTEST_ATTRIBUTE_UNUSED_, \\\n    arg7_type arg7 GTEST_ATTRIBUTE_UNUSED_, \\\n    arg8_type arg8 GTEST_ATTRIBUTE_UNUSED_, \\\n    arg9_type arg9 GTEST_ATTRIBUTE_UNUSED_\n\n// Sometimes you want to give an action explicit template parameters\n// that cannot be inferred from its value parameters.  ACTION() and\n// ACTION_P*() don't support that.  ACTION_TEMPLATE() remedies that\n// and can be viewed as an extension to ACTION() and ACTION_P*().\n//\n// The syntax:\n//\n//   ACTION_TEMPLATE(ActionName,\n//                   HAS_m_TEMPLATE_PARAMS(kind1, name1, ..., kind_m, name_m),\n//                   AND_n_VALUE_PARAMS(p1, ..., p_n)) { statements; }\n//\n// defines an action template that takes m explicit template\n// parameters and n value parameters.  name_i is the name of the i-th\n// template parameter, and kind_i specifies whether it's a typename,\n// an integral constant, or a template.  p_i is the name of the i-th\n// value parameter.\n//\n// Example:\n//\n//   // DuplicateArg<k, T>(output) converts the k-th argument of the mock\n//   // function to type T and copies it to *output.\n//   ACTION_TEMPLATE(DuplicateArg,\n//                   HAS_2_TEMPLATE_PARAMS(int, k, typename, T),\n//                   AND_1_VALUE_PARAMS(output)) {\n//     *output = T(::testing::get<k>(args));\n//   }\n//   ...\n//     int n;\n//     EXPECT_CALL(mock, Foo(_, _))\n//         .WillOnce(DuplicateArg<1, unsigned char>(&n));\n//\n// To create an instance of an action template, write:\n//\n//   ActionName<t1, ..., t_m>(v1, ..., v_n)\n//\n// where the ts are the template arguments and the vs are the value\n// arguments.  The value argument types are inferred by the compiler.\n// If you want to explicitly specify the value argument types, you can\n// provide additional template arguments:\n//\n//   ActionName<t1, ..., t_m, u1, ..., u_k>(v1, ..., v_n)\n//\n// where u_i is the desired type of v_i.\n//\n// ACTION_TEMPLATE and ACTION/ACTION_P* can be overloaded on the\n// number of value parameters, but not on the number of template\n// parameters.  Without the restriction, the meaning of the following\n// is unclear:\n//\n//   OverloadedAction<int, bool>(x);\n//\n// Are we using a single-template-parameter action where 'bool' refers\n// to the type of x, or are we using a two-template-parameter action\n// where the compiler is asked to infer the type of x?\n//\n// Implementation notes:\n//\n// GMOCK_INTERNAL_*_HAS_m_TEMPLATE_PARAMS and\n// GMOCK_INTERNAL_*_AND_n_VALUE_PARAMS are internal macros for\n// implementing ACTION_TEMPLATE.  The main trick we use is to create\n// new macro invocations when expanding a macro.  For example, we have\n//\n//   #define ACTION_TEMPLATE(name, template_params, value_params)\n//       ... GMOCK_INTERNAL_DECL_##template_params ...\n//\n// which causes ACTION_TEMPLATE(..., HAS_1_TEMPLATE_PARAMS(typename, T), ...)\n// to expand to\n//\n//       ... GMOCK_INTERNAL_DECL_HAS_1_TEMPLATE_PARAMS(typename, T) ...\n//\n// Since GMOCK_INTERNAL_DECL_HAS_1_TEMPLATE_PARAMS is a macro, the\n// preprocessor will continue to expand it to\n//\n//       ... typename T ...\n//\n// This technique conforms to the C++ standard and is portable.  It\n// allows us to implement action templates using O(N) code, where N is\n// the maximum number of template/value parameters supported.  Without\n// using it, we'd have to devote O(N^2) amount of code to implement all\n// combinations of m and n.\n\n// Declares the template parameters.\n#define GMOCK_INTERNAL_DECL_HAS_1_TEMPLATE_PARAMS(kind0, name0) kind0 name0\n#define GMOCK_INTERNAL_DECL_HAS_2_TEMPLATE_PARAMS(kind0, name0, kind1, \\\n    name1) kind0 name0, kind1 name1\n#define GMOCK_INTERNAL_DECL_HAS_3_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2) kind0 name0, kind1 name1, kind2 name2\n#define GMOCK_INTERNAL_DECL_HAS_4_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3) kind0 name0, kind1 name1, kind2 name2, \\\n    kind3 name3\n#define GMOCK_INTERNAL_DECL_HAS_5_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3, kind4, name4) kind0 name0, kind1 name1, \\\n    kind2 name2, kind3 name3, kind4 name4\n#define GMOCK_INTERNAL_DECL_HAS_6_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3, kind4, name4, kind5, name5) kind0 name0, \\\n    kind1 name1, kind2 name2, kind3 name3, kind4 name4, kind5 name5\n#define GMOCK_INTERNAL_DECL_HAS_7_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3, kind4, name4, kind5, name5, kind6, \\\n    name6) kind0 name0, kind1 name1, kind2 name2, kind3 name3, kind4 name4, \\\n    kind5 name5, kind6 name6\n#define GMOCK_INTERNAL_DECL_HAS_8_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3, kind4, name4, kind5, name5, kind6, name6, \\\n    kind7, name7) kind0 name0, kind1 name1, kind2 name2, kind3 name3, \\\n    kind4 name4, kind5 name5, kind6 name6, kind7 name7\n#define GMOCK_INTERNAL_DECL_HAS_9_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3, kind4, name4, kind5, name5, kind6, name6, \\\n    kind7, name7, kind8, name8) kind0 name0, kind1 name1, kind2 name2, \\\n    kind3 name3, kind4 name4, kind5 name5, kind6 name6, kind7 name7, \\\n    kind8 name8\n#define GMOCK_INTERNAL_DECL_HAS_10_TEMPLATE_PARAMS(kind0, name0, kind1, \\\n    name1, kind2, name2, kind3, name3, kind4, name4, kind5, name5, kind6, \\\n    name6, kind7, name7, kind8, name8, kind9, name9) kind0 name0, \\\n    kind1 name1, kind2 name2, kind3 name3, kind4 name4, kind5 name5, \\\n    kind6 name6, kind7 name7, kind8 name8, kind9 name9\n\n// Lists the template parameters.\n#define GMOCK_INTERNAL_LIST_HAS_1_TEMPLATE_PARAMS(kind0, name0) name0\n#define GMOCK_INTERNAL_LIST_HAS_2_TEMPLATE_PARAMS(kind0, name0, kind1, \\\n    name1) name0, name1\n#define GMOCK_INTERNAL_LIST_HAS_3_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2) name0, name1, name2\n#define GMOCK_INTERNAL_LIST_HAS_4_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3) name0, name1, name2, name3\n#define GMOCK_INTERNAL_LIST_HAS_5_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3, kind4, name4) name0, name1, name2, name3, \\\n    name4\n#define GMOCK_INTERNAL_LIST_HAS_6_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3, kind4, name4, kind5, name5) name0, name1, \\\n    name2, name3, name4, name5\n#define GMOCK_INTERNAL_LIST_HAS_7_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3, kind4, name4, kind5, name5, kind6, \\\n    name6) name0, name1, name2, name3, name4, name5, name6\n#define GMOCK_INTERNAL_LIST_HAS_8_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3, kind4, name4, kind5, name5, kind6, name6, \\\n    kind7, name7) name0, name1, name2, name3, name4, name5, name6, name7\n#define GMOCK_INTERNAL_LIST_HAS_9_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3, kind4, name4, kind5, name5, kind6, name6, \\\n    kind7, name7, kind8, name8) name0, name1, name2, name3, name4, name5, \\\n    name6, name7, name8\n#define GMOCK_INTERNAL_LIST_HAS_10_TEMPLATE_PARAMS(kind0, name0, kind1, \\\n    name1, kind2, name2, kind3, name3, kind4, name4, kind5, name5, kind6, \\\n    name6, kind7, name7, kind8, name8, kind9, name9) name0, name1, name2, \\\n    name3, name4, name5, name6, name7, name8, name9\n\n// Declares the types of value parameters.\n#define GMOCK_INTERNAL_DECL_TYPE_AND_0_VALUE_PARAMS()\n#define GMOCK_INTERNAL_DECL_TYPE_AND_1_VALUE_PARAMS(p0) , typename p0##_type\n#define GMOCK_INTERNAL_DECL_TYPE_AND_2_VALUE_PARAMS(p0, p1) , \\\n    typename p0##_type, typename p1##_type\n#define GMOCK_INTERNAL_DECL_TYPE_AND_3_VALUE_PARAMS(p0, p1, p2) , \\\n    typename p0##_type, typename p1##_type, typename p2##_type\n#define GMOCK_INTERNAL_DECL_TYPE_AND_4_VALUE_PARAMS(p0, p1, p2, p3) , \\\n    typename p0##_type, typename p1##_type, typename p2##_type, \\\n    typename p3##_type\n#define GMOCK_INTERNAL_DECL_TYPE_AND_5_VALUE_PARAMS(p0, p1, p2, p3, p4) , \\\n    typename p0##_type, typename p1##_type, typename p2##_type, \\\n    typename p3##_type, typename p4##_type\n#define GMOCK_INTERNAL_DECL_TYPE_AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, p5) , \\\n    typename p0##_type, typename p1##_type, typename p2##_type, \\\n    typename p3##_type, typename p4##_type, typename p5##_type\n#define GMOCK_INTERNAL_DECL_TYPE_AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \\\n    p6) , typename p0##_type, typename p1##_type, typename p2##_type, \\\n    typename p3##_type, typename p4##_type, typename p5##_type, \\\n    typename p6##_type\n#define GMOCK_INTERNAL_DECL_TYPE_AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \\\n    p6, p7) , typename p0##_type, typename p1##_type, typename p2##_type, \\\n    typename p3##_type, typename p4##_type, typename p5##_type, \\\n    typename p6##_type, typename p7##_type\n#define GMOCK_INTERNAL_DECL_TYPE_AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \\\n    p6, p7, p8) , typename p0##_type, typename p1##_type, typename p2##_type, \\\n    typename p3##_type, typename p4##_type, typename p5##_type, \\\n    typename p6##_type, typename p7##_type, typename p8##_type\n#define GMOCK_INTERNAL_DECL_TYPE_AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \\\n    p6, p7, p8, p9) , typename p0##_type, typename p1##_type, \\\n    typename p2##_type, typename p3##_type, typename p4##_type, \\\n    typename p5##_type, typename p6##_type, typename p7##_type, \\\n    typename p8##_type, typename p9##_type\n\n// Initializes the value parameters.\n#define GMOCK_INTERNAL_INIT_AND_0_VALUE_PARAMS()\\\n    ()\n#define GMOCK_INTERNAL_INIT_AND_1_VALUE_PARAMS(p0)\\\n    (p0##_type gmock_p0) : p0(gmock_p0)\n#define GMOCK_INTERNAL_INIT_AND_2_VALUE_PARAMS(p0, p1)\\\n    (p0##_type gmock_p0, p1##_type gmock_p1) : p0(gmock_p0), p1(gmock_p1)\n#define GMOCK_INTERNAL_INIT_AND_3_VALUE_PARAMS(p0, p1, p2)\\\n    (p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2)\n#define GMOCK_INTERNAL_INIT_AND_4_VALUE_PARAMS(p0, p1, p2, p3)\\\n    (p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n        p3##_type gmock_p3) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3)\n#define GMOCK_INTERNAL_INIT_AND_5_VALUE_PARAMS(p0, p1, p2, p3, p4)\\\n    (p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n        p3##_type gmock_p3, p4##_type gmock_p4) : p0(gmock_p0), p1(gmock_p1), \\\n        p2(gmock_p2), p3(gmock_p3), p4(gmock_p4)\n#define GMOCK_INTERNAL_INIT_AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, p5)\\\n    (p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n        p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5)\n#define GMOCK_INTERNAL_INIT_AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6)\\\n    (p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n        p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n        p6##_type gmock_p6) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6)\n#define GMOCK_INTERNAL_INIT_AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, p7)\\\n    (p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n        p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n        p6##_type gmock_p6, p7##_type gmock_p7) : p0(gmock_p0), p1(gmock_p1), \\\n        p2(gmock_p2), p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), \\\n        p7(gmock_p7)\n#define GMOCK_INTERNAL_INIT_AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7, p8)\\\n    (p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n        p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n        p6##_type gmock_p6, p7##_type gmock_p7, \\\n        p8##_type gmock_p8) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7), \\\n        p8(gmock_p8)\n#define GMOCK_INTERNAL_INIT_AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7, p8, p9)\\\n    (p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n        p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n        p6##_type gmock_p6, p7##_type gmock_p7, p8##_type gmock_p8, \\\n        p9##_type gmock_p9) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7), \\\n        p8(gmock_p8), p9(gmock_p9)\n\n// Declares the fields for storing the value parameters.\n#define GMOCK_INTERNAL_DEFN_AND_0_VALUE_PARAMS()\n#define GMOCK_INTERNAL_DEFN_AND_1_VALUE_PARAMS(p0) p0##_type p0;\n#define GMOCK_INTERNAL_DEFN_AND_2_VALUE_PARAMS(p0, p1) p0##_type p0; \\\n    p1##_type p1;\n#define GMOCK_INTERNAL_DEFN_AND_3_VALUE_PARAMS(p0, p1, p2) p0##_type p0; \\\n    p1##_type p1; p2##_type p2;\n#define GMOCK_INTERNAL_DEFN_AND_4_VALUE_PARAMS(p0, p1, p2, p3) p0##_type p0; \\\n    p1##_type p1; p2##_type p2; p3##_type p3;\n#define GMOCK_INTERNAL_DEFN_AND_5_VALUE_PARAMS(p0, p1, p2, p3, \\\n    p4) p0##_type p0; p1##_type p1; p2##_type p2; p3##_type p3; p4##_type p4;\n#define GMOCK_INTERNAL_DEFN_AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, \\\n    p5) p0##_type p0; p1##_type p1; p2##_type p2; p3##_type p3; p4##_type p4; \\\n    p5##_type p5;\n#define GMOCK_INTERNAL_DEFN_AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \\\n    p6) p0##_type p0; p1##_type p1; p2##_type p2; p3##_type p3; p4##_type p4; \\\n    p5##_type p5; p6##_type p6;\n#define GMOCK_INTERNAL_DEFN_AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7) p0##_type p0; p1##_type p1; p2##_type p2; p3##_type p3; p4##_type p4; \\\n    p5##_type p5; p6##_type p6; p7##_type p7;\n#define GMOCK_INTERNAL_DEFN_AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7, p8) p0##_type p0; p1##_type p1; p2##_type p2; p3##_type p3; \\\n    p4##_type p4; p5##_type p5; p6##_type p6; p7##_type p7; p8##_type p8;\n#define GMOCK_INTERNAL_DEFN_AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7, p8, p9) p0##_type p0; p1##_type p1; p2##_type p2; p3##_type p3; \\\n    p4##_type p4; p5##_type p5; p6##_type p6; p7##_type p7; p8##_type p8; \\\n    p9##_type p9;\n\n// Lists the value parameters.\n#define GMOCK_INTERNAL_LIST_AND_0_VALUE_PARAMS()\n#define GMOCK_INTERNAL_LIST_AND_1_VALUE_PARAMS(p0) p0\n#define GMOCK_INTERNAL_LIST_AND_2_VALUE_PARAMS(p0, p1) p0, p1\n#define GMOCK_INTERNAL_LIST_AND_3_VALUE_PARAMS(p0, p1, p2) p0, p1, p2\n#define GMOCK_INTERNAL_LIST_AND_4_VALUE_PARAMS(p0, p1, p2, p3) p0, p1, p2, p3\n#define GMOCK_INTERNAL_LIST_AND_5_VALUE_PARAMS(p0, p1, p2, p3, p4) p0, p1, \\\n    p2, p3, p4\n#define GMOCK_INTERNAL_LIST_AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, p5) p0, \\\n    p1, p2, p3, p4, p5\n#define GMOCK_INTERNAL_LIST_AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \\\n    p6) p0, p1, p2, p3, p4, p5, p6\n#define GMOCK_INTERNAL_LIST_AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7) p0, p1, p2, p3, p4, p5, p6, p7\n#define GMOCK_INTERNAL_LIST_AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7, p8) p0, p1, p2, p3, p4, p5, p6, p7, p8\n#define GMOCK_INTERNAL_LIST_AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7, p8, p9) p0, p1, p2, p3, p4, p5, p6, p7, p8, p9\n\n// Lists the value parameter types.\n#define GMOCK_INTERNAL_LIST_TYPE_AND_0_VALUE_PARAMS()\n#define GMOCK_INTERNAL_LIST_TYPE_AND_1_VALUE_PARAMS(p0) , p0##_type\n#define GMOCK_INTERNAL_LIST_TYPE_AND_2_VALUE_PARAMS(p0, p1) , p0##_type, \\\n    p1##_type\n#define GMOCK_INTERNAL_LIST_TYPE_AND_3_VALUE_PARAMS(p0, p1, p2) , p0##_type, \\\n    p1##_type, p2##_type\n#define GMOCK_INTERNAL_LIST_TYPE_AND_4_VALUE_PARAMS(p0, p1, p2, p3) , \\\n    p0##_type, p1##_type, p2##_type, p3##_type\n#define GMOCK_INTERNAL_LIST_TYPE_AND_5_VALUE_PARAMS(p0, p1, p2, p3, p4) , \\\n    p0##_type, p1##_type, p2##_type, p3##_type, p4##_type\n#define GMOCK_INTERNAL_LIST_TYPE_AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, p5) , \\\n    p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, p5##_type\n#define GMOCK_INTERNAL_LIST_TYPE_AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \\\n    p6) , p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, p5##_type, \\\n    p6##_type\n#define GMOCK_INTERNAL_LIST_TYPE_AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \\\n    p6, p7) , p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n    p5##_type, p6##_type, p7##_type\n#define GMOCK_INTERNAL_LIST_TYPE_AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \\\n    p6, p7, p8) , p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n    p5##_type, p6##_type, p7##_type, p8##_type\n#define GMOCK_INTERNAL_LIST_TYPE_AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \\\n    p6, p7, p8, p9) , p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n    p5##_type, p6##_type, p7##_type, p8##_type, p9##_type\n\n// Declares the value parameters.\n#define GMOCK_INTERNAL_DECL_AND_0_VALUE_PARAMS()\n#define GMOCK_INTERNAL_DECL_AND_1_VALUE_PARAMS(p0) p0##_type p0\n#define GMOCK_INTERNAL_DECL_AND_2_VALUE_PARAMS(p0, p1) p0##_type p0, \\\n    p1##_type p1\n#define GMOCK_INTERNAL_DECL_AND_3_VALUE_PARAMS(p0, p1, p2) p0##_type p0, \\\n    p1##_type p1, p2##_type p2\n#define GMOCK_INTERNAL_DECL_AND_4_VALUE_PARAMS(p0, p1, p2, p3) p0##_type p0, \\\n    p1##_type p1, p2##_type p2, p3##_type p3\n#define GMOCK_INTERNAL_DECL_AND_5_VALUE_PARAMS(p0, p1, p2, p3, \\\n    p4) p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, p4##_type p4\n#define GMOCK_INTERNAL_DECL_AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, \\\n    p5) p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, p4##_type p4, \\\n    p5##_type p5\n#define GMOCK_INTERNAL_DECL_AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \\\n    p6) p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, p4##_type p4, \\\n    p5##_type p5, p6##_type p6\n#define GMOCK_INTERNAL_DECL_AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7) p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, p4##_type p4, \\\n    p5##_type p5, p6##_type p6, p7##_type p7\n#define GMOCK_INTERNAL_DECL_AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7, p8) p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \\\n    p4##_type p4, p5##_type p5, p6##_type p6, p7##_type p7, p8##_type p8\n#define GMOCK_INTERNAL_DECL_AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7, p8, p9) p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \\\n    p4##_type p4, p5##_type p5, p6##_type p6, p7##_type p7, p8##_type p8, \\\n    p9##_type p9\n\n// The suffix of the class template implementing the action template.\n#define GMOCK_INTERNAL_COUNT_AND_0_VALUE_PARAMS()\n#define GMOCK_INTERNAL_COUNT_AND_1_VALUE_PARAMS(p0) P\n#define GMOCK_INTERNAL_COUNT_AND_2_VALUE_PARAMS(p0, p1) P2\n#define GMOCK_INTERNAL_COUNT_AND_3_VALUE_PARAMS(p0, p1, p2) P3\n#define GMOCK_INTERNAL_COUNT_AND_4_VALUE_PARAMS(p0, p1, p2, p3) P4\n#define GMOCK_INTERNAL_COUNT_AND_5_VALUE_PARAMS(p0, p1, p2, p3, p4) P5\n#define GMOCK_INTERNAL_COUNT_AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, p5) P6\n#define GMOCK_INTERNAL_COUNT_AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6) P7\n#define GMOCK_INTERNAL_COUNT_AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7) P8\n#define GMOCK_INTERNAL_COUNT_AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7, p8) P9\n#define GMOCK_INTERNAL_COUNT_AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7, p8, p9) P10\n\n// The name of the class template implementing the action template.\n#define GMOCK_ACTION_CLASS_(name, value_params)\\\n    GTEST_CONCAT_TOKEN_(name##Action, GMOCK_INTERNAL_COUNT_##value_params)\n\n#define ACTION_TEMPLATE(name, template_params, value_params)\\\n  template <GMOCK_INTERNAL_DECL_##template_params\\\n            GMOCK_INTERNAL_DECL_TYPE_##value_params>\\\n  class GMOCK_ACTION_CLASS_(name, value_params) {\\\n   public:\\\n    explicit GMOCK_ACTION_CLASS_(name, value_params)\\\n        GMOCK_INTERNAL_INIT_##value_params {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      explicit gmock_Impl GMOCK_INTERNAL_INIT_##value_params {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n      GMOCK_INTERNAL_DEFN_##value_params\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(\\\n          new gmock_Impl<F>(GMOCK_INTERNAL_LIST_##value_params));\\\n    }\\\n    GMOCK_INTERNAL_DEFN_##value_params\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(GMOCK_ACTION_CLASS_(name, value_params));\\\n  };\\\n  template <GMOCK_INTERNAL_DECL_##template_params\\\n            GMOCK_INTERNAL_DECL_TYPE_##value_params>\\\n  inline GMOCK_ACTION_CLASS_(name, value_params)<\\\n      GMOCK_INTERNAL_LIST_##template_params\\\n      GMOCK_INTERNAL_LIST_TYPE_##value_params> name(\\\n          GMOCK_INTERNAL_DECL_##value_params) {\\\n    return GMOCK_ACTION_CLASS_(name, value_params)<\\\n        GMOCK_INTERNAL_LIST_##template_params\\\n        GMOCK_INTERNAL_LIST_TYPE_##value_params>(\\\n            GMOCK_INTERNAL_LIST_##value_params);\\\n  }\\\n  template <GMOCK_INTERNAL_DECL_##template_params\\\n            GMOCK_INTERNAL_DECL_TYPE_##value_params>\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      GMOCK_ACTION_CLASS_(name, value_params)<\\\n          GMOCK_INTERNAL_LIST_##template_params\\\n          GMOCK_INTERNAL_LIST_TYPE_##value_params>::gmock_Impl<F>::\\\n              gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION(name)\\\n  class name##Action {\\\n   public:\\\n    name##Action() {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      gmock_Impl() {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(new gmock_Impl<F>());\\\n    }\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##Action);\\\n  };\\\n  inline name##Action name() {\\\n    return name##Action();\\\n  }\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      name##Action::gmock_Impl<F>::gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION_P(name, p0)\\\n  template <typename p0##_type>\\\n  class name##ActionP {\\\n   public:\\\n    explicit name##ActionP(p0##_type gmock_p0) : p0(gmock_p0) {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      explicit gmock_Impl(p0##_type gmock_p0) : p0(gmock_p0) {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n      p0##_type p0;\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(new gmock_Impl<F>(p0));\\\n    }\\\n    p0##_type p0;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##ActionP);\\\n  };\\\n  template <typename p0##_type>\\\n  inline name##ActionP<p0##_type> name(p0##_type p0) {\\\n    return name##ActionP<p0##_type>(p0);\\\n  }\\\n  template <typename p0##_type>\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      name##ActionP<p0##_type>::gmock_Impl<F>::gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION_P2(name, p0, p1)\\\n  template <typename p0##_type, typename p1##_type>\\\n  class name##ActionP2 {\\\n   public:\\\n    name##ActionP2(p0##_type gmock_p0, p1##_type gmock_p1) : p0(gmock_p0), \\\n        p1(gmock_p1) {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1) : p0(gmock_p0), \\\n          p1(gmock_p1) {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(new gmock_Impl<F>(p0, p1));\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##ActionP2);\\\n  };\\\n  template <typename p0##_type, typename p1##_type>\\\n  inline name##ActionP2<p0##_type, p1##_type> name(p0##_type p0, \\\n      p1##_type p1) {\\\n    return name##ActionP2<p0##_type, p1##_type>(p0, p1);\\\n  }\\\n  template <typename p0##_type, typename p1##_type>\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      name##ActionP2<p0##_type, p1##_type>::gmock_Impl<F>::gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION_P3(name, p0, p1, p2)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type>\\\n  class name##ActionP3 {\\\n   public:\\\n    name##ActionP3(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2) {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, \\\n          p2##_type gmock_p2) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2) {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(new gmock_Impl<F>(p0, p1, p2));\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##ActionP3);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type>\\\n  inline name##ActionP3<p0##_type, p1##_type, p2##_type> name(p0##_type p0, \\\n      p1##_type p1, p2##_type p2) {\\\n    return name##ActionP3<p0##_type, p1##_type, p2##_type>(p0, p1, p2);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type>\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      name##ActionP3<p0##_type, p1##_type, \\\n          p2##_type>::gmock_Impl<F>::gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION_P4(name, p0, p1, p2, p3)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type>\\\n  class name##ActionP4 {\\\n   public:\\\n    name##ActionP4(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3) : p0(gmock_p0), p1(gmock_p1), \\\n        p2(gmock_p2), p3(gmock_p3) {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n          p3(gmock_p3) {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(new gmock_Impl<F>(p0, p1, p2, p3));\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##ActionP4);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type>\\\n  inline name##ActionP4<p0##_type, p1##_type, p2##_type, \\\n      p3##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, \\\n      p3##_type p3) {\\\n    return name##ActionP4<p0##_type, p1##_type, p2##_type, p3##_type>(p0, p1, \\\n        p2, p3);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type>\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      name##ActionP4<p0##_type, p1##_type, p2##_type, \\\n          p3##_type>::gmock_Impl<F>::gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION_P5(name, p0, p1, p2, p3, p4)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type>\\\n  class name##ActionP5 {\\\n   public:\\\n    name##ActionP5(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, \\\n        p4##_type gmock_p4) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4) {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4) : p0(gmock_p0), \\\n          p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), p4(gmock_p4) {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(new gmock_Impl<F>(p0, p1, p2, p3, p4));\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##ActionP5);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type>\\\n  inline name##ActionP5<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \\\n      p4##_type p4) {\\\n    return name##ActionP5<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type>(p0, p1, p2, p3, p4);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type>\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      name##ActionP5<p0##_type, p1##_type, p2##_type, p3##_type, \\\n          p4##_type>::gmock_Impl<F>::gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION_P6(name, p0, p1, p2, p3, p4, p5)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type>\\\n  class name##ActionP6 {\\\n   public:\\\n    name##ActionP6(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5) {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, \\\n          p5##_type gmock_p5) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n          p3(gmock_p3), p4(gmock_p4), p5(gmock_p5) {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(new gmock_Impl<F>(p0, p1, p2, p3, p4, p5));\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##ActionP6);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type>\\\n  inline name##ActionP6<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, \\\n      p3##_type p3, p4##_type p4, p5##_type p5) {\\\n    return name##ActionP6<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type>(p0, p1, p2, p3, p4, p5);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type>\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      name##ActionP6<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n          p5##_type>::gmock_Impl<F>::gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION_P7(name, p0, p1, p2, p3, p4, p5, p6)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type>\\\n  class name##ActionP7 {\\\n   public:\\\n    name##ActionP7(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5, p6##_type gmock_p6) : p0(gmock_p0), p1(gmock_p1), \\\n        p2(gmock_p2), p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), \\\n        p6(gmock_p6) {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n          p6##_type gmock_p6) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n          p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6) {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n      p6##_type p6;\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(new gmock_Impl<F>(p0, p1, p2, p3, p4, p5, \\\n          p6));\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n    p6##_type p6;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##ActionP7);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type>\\\n  inline name##ActionP7<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type, p6##_type> name(p0##_type p0, p1##_type p1, \\\n      p2##_type p2, p3##_type p3, p4##_type p4, p5##_type p5, \\\n      p6##_type p6) {\\\n    return name##ActionP7<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type, p6##_type>(p0, p1, p2, p3, p4, p5, p6);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type>\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      name##ActionP7<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n          p5##_type, p6##_type>::gmock_Impl<F>::gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION_P8(name, p0, p1, p2, p3, p4, p5, p6, p7)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type>\\\n  class name##ActionP8 {\\\n   public:\\\n    name##ActionP8(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5, p6##_type gmock_p6, \\\n        p7##_type gmock_p7) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), \\\n        p7(gmock_p7) {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n          p6##_type gmock_p6, p7##_type gmock_p7) : p0(gmock_p0), \\\n          p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), p4(gmock_p4), \\\n          p5(gmock_p5), p6(gmock_p6), p7(gmock_p7) {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n      p6##_type p6;\\\n      p7##_type p7;\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(new gmock_Impl<F>(p0, p1, p2, p3, p4, p5, \\\n          p6, p7));\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n    p6##_type p6;\\\n    p7##_type p7;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##ActionP8);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type>\\\n  inline name##ActionP8<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type, p6##_type, p7##_type> name(p0##_type p0, \\\n      p1##_type p1, p2##_type p2, p3##_type p3, p4##_type p4, p5##_type p5, \\\n      p6##_type p6, p7##_type p7) {\\\n    return name##ActionP8<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type, p6##_type, p7##_type>(p0, p1, p2, p3, p4, p5, \\\n        p6, p7);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type>\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      name##ActionP8<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n          p5##_type, p6##_type, \\\n          p7##_type>::gmock_Impl<F>::gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION_P9(name, p0, p1, p2, p3, p4, p5, p6, p7, p8)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type>\\\n  class name##ActionP9 {\\\n   public:\\\n    name##ActionP9(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5, p6##_type gmock_p6, p7##_type gmock_p7, \\\n        p8##_type gmock_p8) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7), \\\n        p8(gmock_p8) {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n          p6##_type gmock_p6, p7##_type gmock_p7, \\\n          p8##_type gmock_p8) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n          p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), \\\n          p7(gmock_p7), p8(gmock_p8) {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n      p6##_type p6;\\\n      p7##_type p7;\\\n      p8##_type p8;\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(new gmock_Impl<F>(p0, p1, p2, p3, p4, p5, \\\n          p6, p7, p8));\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n    p6##_type p6;\\\n    p7##_type p7;\\\n    p8##_type p8;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##ActionP9);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type>\\\n  inline name##ActionP9<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type, p6##_type, p7##_type, \\\n      p8##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \\\n      p4##_type p4, p5##_type p5, p6##_type p6, p7##_type p7, \\\n      p8##_type p8) {\\\n    return name##ActionP9<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type, p6##_type, p7##_type, p8##_type>(p0, p1, p2, \\\n        p3, p4, p5, p6, p7, p8);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type>\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      name##ActionP9<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n          p5##_type, p6##_type, p7##_type, \\\n          p8##_type>::gmock_Impl<F>::gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION_P10(name, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type, \\\n      typename p9##_type>\\\n  class name##ActionP10 {\\\n   public:\\\n    name##ActionP10(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5, p6##_type gmock_p6, p7##_type gmock_p7, \\\n        p8##_type gmock_p8, p9##_type gmock_p9) : p0(gmock_p0), p1(gmock_p1), \\\n        p2(gmock_p2), p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), \\\n        p7(gmock_p7), p8(gmock_p8), p9(gmock_p9) {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n          p6##_type gmock_p6, p7##_type gmock_p7, p8##_type gmock_p8, \\\n          p9##_type gmock_p9) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n          p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), \\\n          p7(gmock_p7), p8(gmock_p8), p9(gmock_p9) {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n      p6##_type p6;\\\n      p7##_type p7;\\\n      p8##_type p8;\\\n      p9##_type p9;\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(new gmock_Impl<F>(p0, p1, p2, p3, p4, p5, \\\n          p6, p7, p8, p9));\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n    p6##_type p6;\\\n    p7##_type p7;\\\n    p8##_type p8;\\\n    p9##_type p9;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##ActionP10);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type, \\\n      typename p9##_type>\\\n  inline name##ActionP10<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, \\\n      p9##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \\\n      p4##_type p4, p5##_type p5, p6##_type p6, p7##_type p7, p8##_type p8, \\\n      p9##_type p9) {\\\n    return name##ActionP10<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, p9##_type>(p0, \\\n        p1, p2, p3, p4, p5, p6, p7, p8, p9);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type, \\\n      typename p9##_type>\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      name##ActionP10<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n          p5##_type, p6##_type, p7##_type, p8##_type, \\\n          p9##_type>::gmock_Impl<F>::gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\nnamespace testing {\n\n\n// The ACTION*() macros trigger warning C4100 (unreferenced formal\n// parameter) in MSVC with -W4.  Unfortunately they cannot be fixed in\n// the macro definition, as the warnings are generated when the macro\n// is expanded and macro expansion cannot contain #pragma.  Therefore\n// we suppress them here.\n#ifdef _MSC_VER\n# pragma warning(push)\n# pragma warning(disable:4100)\n#endif\n\n// Various overloads for InvokeArgument<N>().\n//\n// The InvokeArgument<N>(a1, a2, ..., a_k) action invokes the N-th\n// (0-based) argument, which must be a k-ary callable, of the mock\n// function, with arguments a1, a2, ..., a_k.\n//\n// Notes:\n//\n//   1. The arguments are passed by value by default.  If you need to\n//   pass an argument by reference, wrap it inside ByRef().  For\n//   example,\n//\n//     InvokeArgument<1>(5, string(\"Hello\"), ByRef(foo))\n//\n//   passes 5 and string(\"Hello\") by value, and passes foo by\n//   reference.\n//\n//   2. If the callable takes an argument by reference but ByRef() is\n//   not used, it will receive the reference to a copy of the value,\n//   instead of the original value.  For example, when the 0-th\n//   argument of the mock function takes a const string&, the action\n//\n//     InvokeArgument<0>(string(\"Hello\"))\n//\n//   makes a copy of the temporary string(\"Hello\") object and passes a\n//   reference of the copy, instead of the original temporary object,\n//   to the callable.  This makes it easy for a user to define an\n//   InvokeArgument action from temporary values and have it performed\n//   later.\n\nnamespace internal {\nnamespace invoke_argument {\n\n// Appears in InvokeArgumentAdl's argument list to help avoid\n// accidental calls to user functions of the same name.\nstruct AdlTag {};\n\n// InvokeArgumentAdl - a helper for InvokeArgument.\n// The basic overloads are provided here for generic functors.\n// Overloads for other custom-callables are provided in the\n// internal/custom/callback-actions.h header.\n\ntemplate <typename R, typename F>\nR InvokeArgumentAdl(AdlTag, F f) {\n  return f();\n}\ntemplate <typename R, typename F, typename A1>\nR InvokeArgumentAdl(AdlTag, F f, A1 a1) {\n  return f(a1);\n}\ntemplate <typename R, typename F, typename A1, typename A2>\nR InvokeArgumentAdl(AdlTag, F f, A1 a1, A2 a2) {\n  return f(a1, a2);\n}\ntemplate <typename R, typename F, typename A1, typename A2, typename A3>\nR InvokeArgumentAdl(AdlTag, F f, A1 a1, A2 a2, A3 a3) {\n  return f(a1, a2, a3);\n}\ntemplate <typename R, typename F, typename A1, typename A2, typename A3,\n    typename A4>\nR InvokeArgumentAdl(AdlTag, F f, A1 a1, A2 a2, A3 a3, A4 a4) {\n  return f(a1, a2, a3, a4);\n}\ntemplate <typename R, typename F, typename A1, typename A2, typename A3,\n    typename A4, typename A5>\nR InvokeArgumentAdl(AdlTag, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) {\n  return f(a1, a2, a3, a4, a5);\n}\ntemplate <typename R, typename F, typename A1, typename A2, typename A3,\n    typename A4, typename A5, typename A6>\nR InvokeArgumentAdl(AdlTag, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) {\n  return f(a1, a2, a3, a4, a5, a6);\n}\ntemplate <typename R, typename F, typename A1, typename A2, typename A3,\n    typename A4, typename A5, typename A6, typename A7>\nR InvokeArgumentAdl(AdlTag, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6,\n    A7 a7) {\n  return f(a1, a2, a3, a4, a5, a6, a7);\n}\ntemplate <typename R, typename F, typename A1, typename A2, typename A3,\n    typename A4, typename A5, typename A6, typename A7, typename A8>\nR InvokeArgumentAdl(AdlTag, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6,\n    A7 a7, A8 a8) {\n  return f(a1, a2, a3, a4, a5, a6, a7, a8);\n}\ntemplate <typename R, typename F, typename A1, typename A2, typename A3,\n    typename A4, typename A5, typename A6, typename A7, typename A8,\n    typename A9>\nR InvokeArgumentAdl(AdlTag, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6,\n    A7 a7, A8 a8, A9 a9) {\n  return f(a1, a2, a3, a4, a5, a6, a7, a8, a9);\n}\ntemplate <typename R, typename F, typename A1, typename A2, typename A3,\n    typename A4, typename A5, typename A6, typename A7, typename A8,\n    typename A9, typename A10>\nR InvokeArgumentAdl(AdlTag, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6,\n    A7 a7, A8 a8, A9 a9, A10 a10) {\n  return f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);\n}\n}  // namespace invoke_argument\n}  // namespace internal\n\nACTION_TEMPLATE(InvokeArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_0_VALUE_PARAMS()) {\n  using internal::invoke_argument::InvokeArgumentAdl;\n  return InvokeArgumentAdl<return_type>(\n      internal::invoke_argument::AdlTag(),\n      ::testing::get<k>(args));\n}\n\nACTION_TEMPLATE(InvokeArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_1_VALUE_PARAMS(p0)) {\n  using internal::invoke_argument::InvokeArgumentAdl;\n  return InvokeArgumentAdl<return_type>(\n      internal::invoke_argument::AdlTag(),\n      ::testing::get<k>(args), p0);\n}\n\nACTION_TEMPLATE(InvokeArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_2_VALUE_PARAMS(p0, p1)) {\n  using internal::invoke_argument::InvokeArgumentAdl;\n  return InvokeArgumentAdl<return_type>(\n      internal::invoke_argument::AdlTag(),\n      ::testing::get<k>(args), p0, p1);\n}\n\nACTION_TEMPLATE(InvokeArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_3_VALUE_PARAMS(p0, p1, p2)) {\n  using internal::invoke_argument::InvokeArgumentAdl;\n  return InvokeArgumentAdl<return_type>(\n      internal::invoke_argument::AdlTag(),\n      ::testing::get<k>(args), p0, p1, p2);\n}\n\nACTION_TEMPLATE(InvokeArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_4_VALUE_PARAMS(p0, p1, p2, p3)) {\n  using internal::invoke_argument::InvokeArgumentAdl;\n  return InvokeArgumentAdl<return_type>(\n      internal::invoke_argument::AdlTag(),\n      ::testing::get<k>(args), p0, p1, p2, p3);\n}\n\nACTION_TEMPLATE(InvokeArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_5_VALUE_PARAMS(p0, p1, p2, p3, p4)) {\n  using internal::invoke_argument::InvokeArgumentAdl;\n  return InvokeArgumentAdl<return_type>(\n      internal::invoke_argument::AdlTag(),\n      ::testing::get<k>(args), p0, p1, p2, p3, p4);\n}\n\nACTION_TEMPLATE(InvokeArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, p5)) {\n  using internal::invoke_argument::InvokeArgumentAdl;\n  return InvokeArgumentAdl<return_type>(\n      internal::invoke_argument::AdlTag(),\n      ::testing::get<k>(args), p0, p1, p2, p3, p4, p5);\n}\n\nACTION_TEMPLATE(InvokeArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6)) {\n  using internal::invoke_argument::InvokeArgumentAdl;\n  return InvokeArgumentAdl<return_type>(\n      internal::invoke_argument::AdlTag(),\n      ::testing::get<k>(args), p0, p1, p2, p3, p4, p5, p6);\n}\n\nACTION_TEMPLATE(InvokeArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, p7)) {\n  using internal::invoke_argument::InvokeArgumentAdl;\n  return InvokeArgumentAdl<return_type>(\n      internal::invoke_argument::AdlTag(),\n      ::testing::get<k>(args), p0, p1, p2, p3, p4, p5, p6, p7);\n}\n\nACTION_TEMPLATE(InvokeArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, p7, p8)) {\n  using internal::invoke_argument::InvokeArgumentAdl;\n  return InvokeArgumentAdl<return_type>(\n      internal::invoke_argument::AdlTag(),\n      ::testing::get<k>(args), p0, p1, p2, p3, p4, p5, p6, p7, p8);\n}\n\nACTION_TEMPLATE(InvokeArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)) {\n  using internal::invoke_argument::InvokeArgumentAdl;\n  return InvokeArgumentAdl<return_type>(\n      internal::invoke_argument::AdlTag(),\n      ::testing::get<k>(args), p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);\n}\n\n// Various overloads for ReturnNew<T>().\n//\n// The ReturnNew<T>(a1, a2, ..., a_k) action returns a pointer to a new\n// instance of type T, constructed on the heap with constructor arguments\n// a1, a2, ..., and a_k. The caller assumes ownership of the returned value.\nACTION_TEMPLATE(ReturnNew,\n                HAS_1_TEMPLATE_PARAMS(typename, T),\n                AND_0_VALUE_PARAMS()) {\n  return new T();\n}\n\nACTION_TEMPLATE(ReturnNew,\n                HAS_1_TEMPLATE_PARAMS(typename, T),\n                AND_1_VALUE_PARAMS(p0)) {\n  return new T(p0);\n}\n\nACTION_TEMPLATE(ReturnNew,\n                HAS_1_TEMPLATE_PARAMS(typename, T),\n                AND_2_VALUE_PARAMS(p0, p1)) {\n  return new T(p0, p1);\n}\n\nACTION_TEMPLATE(ReturnNew,\n                HAS_1_TEMPLATE_PARAMS(typename, T),\n                AND_3_VALUE_PARAMS(p0, p1, p2)) {\n  return new T(p0, p1, p2);\n}\n\nACTION_TEMPLATE(ReturnNew,\n                HAS_1_TEMPLATE_PARAMS(typename, T),\n                AND_4_VALUE_PARAMS(p0, p1, p2, p3)) {\n  return new T(p0, p1, p2, p3);\n}\n\nACTION_TEMPLATE(ReturnNew,\n                HAS_1_TEMPLATE_PARAMS(typename, T),\n                AND_5_VALUE_PARAMS(p0, p1, p2, p3, p4)) {\n  return new T(p0, p1, p2, p3, p4);\n}\n\nACTION_TEMPLATE(ReturnNew,\n                HAS_1_TEMPLATE_PARAMS(typename, T),\n                AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, p5)) {\n  return new T(p0, p1, p2, p3, p4, p5);\n}\n\nACTION_TEMPLATE(ReturnNew,\n                HAS_1_TEMPLATE_PARAMS(typename, T),\n                AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6)) {\n  return new T(p0, p1, p2, p3, p4, p5, p6);\n}\n\nACTION_TEMPLATE(ReturnNew,\n                HAS_1_TEMPLATE_PARAMS(typename, T),\n                AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, p7)) {\n  return new T(p0, p1, p2, p3, p4, p5, p6, p7);\n}\n\nACTION_TEMPLATE(ReturnNew,\n                HAS_1_TEMPLATE_PARAMS(typename, T),\n                AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, p7, p8)) {\n  return new T(p0, p1, p2, p3, p4, p5, p6, p7, p8);\n}\n\nACTION_TEMPLATE(ReturnNew,\n                HAS_1_TEMPLATE_PARAMS(typename, T),\n                AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)) {\n  return new T(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);\n}\n\n#ifdef _MSC_VER\n# pragma warning(pop)\n#endif\n\n}  // namespace testing\n\n// Include any custom actions added by the local installation.\n// We must include this header at the end to make sure it can use the\n// declarations from this file.\n#include \"gmock/internal/custom/gmock-generated-actions.h\"\n\n#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_ACTIONS_H_\n"}, "37": {"id": 37, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "content": "// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// This file implements some commonly used argument matchers.  More\n// matchers can be defined by the user implementing the\n// MatcherInterface<T> interface if necessary.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_MATCHERS_H_\n#define GMOCK_INCLUDE_GMOCK_GMOCK_MATCHERS_H_\n\n#include <math.h>\n#include <algorithm>\n#include <iterator>\n#include <limits>\n#include <ostream>  // NOLINT\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\n#include \"gmock/internal/gmock-internal-utils.h\"\n#include \"gmock/internal/gmock-port.h\"\n#include \"gtest/gtest.h\"\n\n#if GTEST_HAS_STD_INITIALIZER_LIST_\n# include <initializer_list>  // NOLINT -- must be after gtest.h\n#endif\n\nnamespace testing {\n\n// To implement a matcher Foo for type T, define:\n//   1. a class FooMatcherImpl that implements the\n//      MatcherInterface<T> interface, and\n//   2. a factory function that creates a Matcher<T> object from a\n//      FooMatcherImpl*.\n//\n// The two-level delegation design makes it possible to allow a user\n// to write \"v\" instead of \"Eq(v)\" where a Matcher is expected, which\n// is impossible if we pass matchers by pointers.  It also eases\n// ownership management as Matcher objects can now be copied like\n// plain values.\n\n// MatchResultListener is an abstract class.  Its << operator can be\n// used by a matcher to explain why a value matches or doesn't match.\n//\n// TODO(wan@google.com): add method\n//   bool InterestedInWhy(bool result) const;\n// to indicate whether the listener is interested in why the match\n// result is 'result'.\nclass MatchResultListener {\n public:\n  // Creates a listener object with the given underlying ostream.  The\n  // listener does not own the ostream, and does not dereference it\n  // in the constructor or destructor.\n  explicit MatchResultListener(::std::ostream* os) : stream_(os) {}\n  virtual ~MatchResultListener() = 0;  // Makes this class abstract.\n\n  // Streams x to the underlying ostream; does nothing if the ostream\n  // is NULL.\n  template <typename T>\n  MatchResultListener& operator<<(const T& x) {\n    if (stream_ != NULL)\n      *stream_ << x;\n    return *this;\n  }\n\n  // Returns the underlying ostream.\n  ::std::ostream* stream() { return stream_; }\n\n  // Returns true iff the listener is interested in an explanation of\n  // the match result.  A matcher's MatchAndExplain() method can use\n  // this information to avoid generating the explanation when no one\n  // intends to hear it.\n  bool IsInterested() const { return stream_ != NULL; }\n\n private:\n  ::std::ostream* const stream_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(MatchResultListener);\n};\n\ninline MatchResultListener::~MatchResultListener() {\n}\n\n// An instance of a subclass of this knows how to describe itself as a\n// matcher.\nclass MatcherDescriberInterface {\n public:\n  virtual ~MatcherDescriberInterface() {}\n\n  // Describes this matcher to an ostream.  The function should print\n  // a verb phrase that describes the property a value matching this\n  // matcher should have.  The subject of the verb phrase is the value\n  // being matched.  For example, the DescribeTo() method of the Gt(7)\n  // matcher prints \"is greater than 7\".\n  virtual void DescribeTo(::std::ostream* os) const = 0;\n\n  // Describes the negation of this matcher to an ostream.  For\n  // example, if the description of this matcher is \"is greater than\n  // 7\", the negated description could be \"is not greater than 7\".\n  // You are not required to override this when implementing\n  // MatcherInterface, but it is highly advised so that your matcher\n  // can produce good error messages.\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"not (\";\n    DescribeTo(os);\n    *os << \")\";\n  }\n};\n\n// The implementation of a matcher.\ntemplate <typename T>\nclass MatcherInterface : public MatcherDescriberInterface {\n public:\n  // Returns true iff the matcher matches x; also explains the match\n  // result to 'listener' if necessary (see the next paragraph), in\n  // the form of a non-restrictive relative clause (\"which ...\",\n  // \"whose ...\", etc) that describes x.  For example, the\n  // MatchAndExplain() method of the Pointee(...) matcher should\n  // generate an explanation like \"which points to ...\".\n  //\n  // Implementations of MatchAndExplain() should add an explanation of\n  // the match result *if and only if* they can provide additional\n  // information that's not already present (or not obvious) in the\n  // print-out of x and the matcher's description.  Whether the match\n  // succeeds is not a factor in deciding whether an explanation is\n  // needed, as sometimes the caller needs to print a failure message\n  // when the match succeeds (e.g. when the matcher is used inside\n  // Not()).\n  //\n  // For example, a \"has at least 10 elements\" matcher should explain\n  // what the actual element count is, regardless of the match result,\n  // as it is useful information to the reader; on the other hand, an\n  // \"is empty\" matcher probably only needs to explain what the actual\n  // size is when the match fails, as it's redundant to say that the\n  // size is 0 when the value is already known to be empty.\n  //\n  // You should override this method when defining a new matcher.\n  //\n  // It's the responsibility of the caller (Google Mock) to guarantee\n  // that 'listener' is not NULL.  This helps to simplify a matcher's\n  // implementation when it doesn't care about the performance, as it\n  // can talk to 'listener' without checking its validity first.\n  // However, in order to implement dummy listeners efficiently,\n  // listener->stream() may be NULL.\n  virtual bool MatchAndExplain(T x, MatchResultListener* listener) const = 0;\n\n  // Inherits these methods from MatcherDescriberInterface:\n  //   virtual void DescribeTo(::std::ostream* os) const = 0;\n  //   virtual void DescribeNegationTo(::std::ostream* os) const;\n};\n\n// A match result listener that stores the explanation in a string.\nclass StringMatchResultListener : public MatchResultListener {\n public:\n  StringMatchResultListener() : MatchResultListener(&ss_) {}\n\n  // Returns the explanation accumulated so far.\n  internal::string str() const { return ss_.str(); }\n\n  // Clears the explanation accumulated so far.\n  void Clear() { ss_.str(\"\"); }\n\n private:\n  ::std::stringstream ss_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(StringMatchResultListener);\n};\n\nnamespace internal {\n\nstruct AnyEq {\n  template <typename A, typename B>\n  bool operator()(const A& a, const B& b) const { return a == b; }\n};\nstruct AnyNe {\n  template <typename A, typename B>\n  bool operator()(const A& a, const B& b) const { return a != b; }\n};\nstruct AnyLt {\n  template <typename A, typename B>\n  bool operator()(const A& a, const B& b) const { return a < b; }\n};\nstruct AnyGt {\n  template <typename A, typename B>\n  bool operator()(const A& a, const B& b) const { return a > b; }\n};\nstruct AnyLe {\n  template <typename A, typename B>\n  bool operator()(const A& a, const B& b) const { return a <= b; }\n};\nstruct AnyGe {\n  template <typename A, typename B>\n  bool operator()(const A& a, const B& b) const { return a >= b; }\n};\n\n// A match result listener that ignores the explanation.\nclass DummyMatchResultListener : public MatchResultListener {\n public:\n  DummyMatchResultListener() : MatchResultListener(NULL) {}\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(DummyMatchResultListener);\n};\n\n// A match result listener that forwards the explanation to a given\n// ostream.  The difference between this and MatchResultListener is\n// that the former is concrete.\nclass StreamMatchResultListener : public MatchResultListener {\n public:\n  explicit StreamMatchResultListener(::std::ostream* os)\n      : MatchResultListener(os) {}\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(StreamMatchResultListener);\n};\n\n// An internal class for implementing Matcher<T>, which will derive\n// from it.  We put functionalities common to all Matcher<T>\n// specializations here to avoid code duplication.\ntemplate <typename T>\nclass MatcherBase {\n public:\n  // Returns true iff the matcher matches x; also explains the match\n  // result to 'listener'.\n  bool MatchAndExplain(T x, MatchResultListener* listener) const {\n    return impl_->MatchAndExplain(x, listener);\n  }\n\n  // Returns true iff this matcher matches x.\n  bool Matches(T x) const {\n    DummyMatchResultListener dummy;\n    return MatchAndExplain(x, &dummy);\n  }\n\n  // Describes this matcher to an ostream.\n  void DescribeTo(::std::ostream* os) const { impl_->DescribeTo(os); }\n\n  // Describes the negation of this matcher to an ostream.\n  void DescribeNegationTo(::std::ostream* os) const {\n    impl_->DescribeNegationTo(os);\n  }\n\n  // Explains why x matches, or doesn't match, the matcher.\n  void ExplainMatchResultTo(T x, ::std::ostream* os) const {\n    StreamMatchResultListener listener(os);\n    MatchAndExplain(x, &listener);\n  }\n\n  // Returns the describer for this matcher object; retains ownership\n  // of the describer, which is only guaranteed to be alive when\n  // this matcher object is alive.\n  const MatcherDescriberInterface* GetDescriber() const {\n    return impl_.get();\n  }\n\n protected:\n  MatcherBase() {}\n\n  // Constructs a matcher from its implementation.\n  explicit MatcherBase(const MatcherInterface<T>* impl)\n      : impl_(impl) {}\n\n  virtual ~MatcherBase() {}\n\n private:\n  // shared_ptr (util/gtl/shared_ptr.h) and linked_ptr have similar\n  // interfaces.  The former dynamically allocates a chunk of memory\n  // to hold the reference count, while the latter tracks all\n  // references using a circular linked list without allocating\n  // memory.  It has been observed that linked_ptr performs better in\n  // typical scenarios.  However, shared_ptr can out-perform\n  // linked_ptr when there are many more uses of the copy constructor\n  // than the default constructor.\n  //\n  // If performance becomes a problem, we should see if using\n  // shared_ptr helps.\n  ::testing::internal::linked_ptr<const MatcherInterface<T> > impl_;\n};\n\n}  // namespace internal\n\n// A Matcher<T> is a copyable and IMMUTABLE (except by assignment)\n// object that can check whether a value of type T matches.  The\n// implementation of Matcher<T> is just a linked_ptr to const\n// MatcherInterface<T>, so copying is fairly cheap.  Don't inherit\n// from Matcher!\ntemplate <typename T>\nclass Matcher : public internal::MatcherBase<T> {\n public:\n  // Constructs a null matcher.  Needed for storing Matcher objects in STL\n  // containers.  A default-constructed matcher is not yet initialized.  You\n  // cannot use it until a valid value has been assigned to it.\n  explicit Matcher() {}  // NOLINT\n\n  // Constructs a matcher from its implementation.\n  explicit Matcher(const MatcherInterface<T>* impl)\n      : internal::MatcherBase<T>(impl) {}\n\n  // Implicit constructor here allows people to write\n  // EXPECT_CALL(foo, Bar(5)) instead of EXPECT_CALL(foo, Bar(Eq(5))) sometimes\n  Matcher(T value);  // NOLINT\n};\n\n// The following two specializations allow the user to write str\n// instead of Eq(str) and \"foo\" instead of Eq(\"foo\") when a string\n// matcher is expected.\ntemplate <>\nclass GTEST_API_ Matcher<const internal::string&>\n    : public internal::MatcherBase<const internal::string&> {\n public:\n  Matcher() {}\n\n  explicit Matcher(const MatcherInterface<const internal::string&>* impl)\n      : internal::MatcherBase<const internal::string&>(impl) {}\n\n  // Allows the user to write str instead of Eq(str) sometimes, where\n  // str is a string object.\n  Matcher(const internal::string& s);  // NOLINT\n\n  // Allows the user to write \"foo\" instead of Eq(\"foo\") sometimes.\n  Matcher(const char* s);  // NOLINT\n};\n\ntemplate <>\nclass GTEST_API_ Matcher<internal::string>\n    : public internal::MatcherBase<internal::string> {\n public:\n  Matcher() {}\n\n  explicit Matcher(const MatcherInterface<internal::string>* impl)\n      : internal::MatcherBase<internal::string>(impl) {}\n\n  // Allows the user to write str instead of Eq(str) sometimes, where\n  // str is a string object.\n  Matcher(const internal::string& s);  // NOLINT\n\n  // Allows the user to write \"foo\" instead of Eq(\"foo\") sometimes.\n  Matcher(const char* s);  // NOLINT\n};\n\n#if GTEST_HAS_STRING_PIECE_\n// The following two specializations allow the user to write str\n// instead of Eq(str) and \"foo\" instead of Eq(\"foo\") when a StringPiece\n// matcher is expected.\ntemplate <>\nclass GTEST_API_ Matcher<const StringPiece&>\n    : public internal::MatcherBase<const StringPiece&> {\n public:\n  Matcher() {}\n\n  explicit Matcher(const MatcherInterface<const StringPiece&>* impl)\n      : internal::MatcherBase<const StringPiece&>(impl) {}\n\n  // Allows the user to write str instead of Eq(str) sometimes, where\n  // str is a string object.\n  Matcher(const internal::string& s);  // NOLINT\n\n  // Allows the user to write \"foo\" instead of Eq(\"foo\") sometimes.\n  Matcher(const char* s);  // NOLINT\n\n  // Allows the user to pass StringPieces directly.\n  Matcher(StringPiece s);  // NOLINT\n};\n\ntemplate <>\nclass GTEST_API_ Matcher<StringPiece>\n    : public internal::MatcherBase<StringPiece> {\n public:\n  Matcher() {}\n\n  explicit Matcher(const MatcherInterface<StringPiece>* impl)\n      : internal::MatcherBase<StringPiece>(impl) {}\n\n  // Allows the user to write str instead of Eq(str) sometimes, where\n  // str is a string object.\n  Matcher(const internal::string& s);  // NOLINT\n\n  // Allows the user to write \"foo\" instead of Eq(\"foo\") sometimes.\n  Matcher(const char* s);  // NOLINT\n\n  // Allows the user to pass StringPieces directly.\n  Matcher(StringPiece s);  // NOLINT\n};\n#endif  // GTEST_HAS_STRING_PIECE_\n\n// The PolymorphicMatcher class template makes it easy to implement a\n// polymorphic matcher (i.e. a matcher that can match values of more\n// than one type, e.g. Eq(n) and NotNull()).\n//\n// To define a polymorphic matcher, a user should provide an Impl\n// class that has a DescribeTo() method and a DescribeNegationTo()\n// method, and define a member function (or member function template)\n//\n//   bool MatchAndExplain(const Value& value,\n//                        MatchResultListener* listener) const;\n//\n// See the definition of NotNull() for a complete example.\ntemplate <class Impl>\nclass PolymorphicMatcher {\n public:\n  explicit PolymorphicMatcher(const Impl& an_impl) : impl_(an_impl) {}\n\n  // Returns a mutable reference to the underlying matcher\n  // implementation object.\n  Impl& mutable_impl() { return impl_; }\n\n  // Returns an immutable reference to the underlying matcher\n  // implementation object.\n  const Impl& impl() const { return impl_; }\n\n  template <typename T>\n  operator Matcher<T>() const {\n    return Matcher<T>(new MonomorphicImpl<T>(impl_));\n  }\n\n private:\n  template <typename T>\n  class MonomorphicImpl : public MatcherInterface<T> {\n   public:\n    explicit MonomorphicImpl(const Impl& impl) : impl_(impl) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      impl_.DescribeTo(os);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      impl_.DescribeNegationTo(os);\n    }\n\n    virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {\n      return impl_.MatchAndExplain(x, listener);\n    }\n\n   private:\n    const Impl impl_;\n\n    GTEST_DISALLOW_ASSIGN_(MonomorphicImpl);\n  };\n\n  Impl impl_;\n\n  GTEST_DISALLOW_ASSIGN_(PolymorphicMatcher);\n};\n\n// Creates a matcher from its implementation.  This is easier to use\n// than the Matcher<T> constructor as it doesn't require you to\n// explicitly write the template argument, e.g.\n//\n//   MakeMatcher(foo);\n// vs\n//   Matcher<const string&>(foo);\ntemplate <typename T>\ninline Matcher<T> MakeMatcher(const MatcherInterface<T>* impl) {\n  return Matcher<T>(impl);\n}\n\n// Creates a polymorphic matcher from its implementation.  This is\n// easier to use than the PolymorphicMatcher<Impl> constructor as it\n// doesn't require you to explicitly write the template argument, e.g.\n//\n//   MakePolymorphicMatcher(foo);\n// vs\n//   PolymorphicMatcher<TypeOfFoo>(foo);\ntemplate <class Impl>\ninline PolymorphicMatcher<Impl> MakePolymorphicMatcher(const Impl& impl) {\n  return PolymorphicMatcher<Impl>(impl);\n}\n\n// Anything inside the 'internal' namespace IS INTERNAL IMPLEMENTATION\n// and MUST NOT BE USED IN USER CODE!!!\nnamespace internal {\n\n// The MatcherCastImpl class template is a helper for implementing\n// MatcherCast().  We need this helper in order to partially\n// specialize the implementation of MatcherCast() (C++ allows\n// class/struct templates to be partially specialized, but not\n// function templates.).\n\n// This general version is used when MatcherCast()'s argument is a\n// polymorphic matcher (i.e. something that can be converted to a\n// Matcher but is not one yet; for example, Eq(value)) or a value (for\n// example, \"hello\").\ntemplate <typename T, typename M>\nclass MatcherCastImpl {\n public:\n  static Matcher<T> Cast(const M& polymorphic_matcher_or_value) {\n    // M can be a polymorhic matcher, in which case we want to use\n    // its conversion operator to create Matcher<T>.  Or it can be a value\n    // that should be passed to the Matcher<T>'s constructor.\n    //\n    // We can't call Matcher<T>(polymorphic_matcher_or_value) when M is a\n    // polymorphic matcher because it'll be ambiguous if T has an implicit\n    // constructor from M (this usually happens when T has an implicit\n    // constructor from any type).\n    //\n    // It won't work to unconditionally implict_cast\n    // polymorphic_matcher_or_value to Matcher<T> because it won't trigger\n    // a user-defined conversion from M to T if one exists (assuming M is\n    // a value).\n    return CastImpl(\n        polymorphic_matcher_or_value,\n        BooleanConstant<\n            internal::ImplicitlyConvertible<M, Matcher<T> >::value>());\n  }\n\n private:\n  static Matcher<T> CastImpl(const M& value, BooleanConstant<false>) {\n    // M can't be implicitly converted to Matcher<T>, so M isn't a polymorphic\n    // matcher.  It must be a value then.  Use direct initialization to create\n    // a matcher.\n    return Matcher<T>(ImplicitCast_<T>(value));\n  }\n\n  static Matcher<T> CastImpl(const M& polymorphic_matcher_or_value,\n                             BooleanConstant<true>) {\n    // M is implicitly convertible to Matcher<T>, which means that either\n    // M is a polymorhpic matcher or Matcher<T> has an implicit constructor\n    // from M.  In both cases using the implicit conversion will produce a\n    // matcher.\n    //\n    // Even if T has an implicit constructor from M, it won't be called because\n    // creating Matcher<T> would require a chain of two user-defined conversions\n    // (first to create T from M and then to create Matcher<T> from T).\n    return polymorphic_matcher_or_value;\n  }\n};\n\n// This more specialized version is used when MatcherCast()'s argument\n// is already a Matcher.  This only compiles when type T can be\n// statically converted to type U.\ntemplate <typename T, typename U>\nclass MatcherCastImpl<T, Matcher<U> > {\n public:\n  static Matcher<T> Cast(const Matcher<U>& source_matcher) {\n    return Matcher<T>(new Impl(source_matcher));\n  }\n\n private:\n  class Impl : public MatcherInterface<T> {\n   public:\n    explicit Impl(const Matcher<U>& source_matcher)\n        : source_matcher_(source_matcher) {}\n\n    // We delegate the matching logic to the source matcher.\n    virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {\n      return source_matcher_.MatchAndExplain(static_cast<U>(x), listener);\n    }\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      source_matcher_.DescribeTo(os);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      source_matcher_.DescribeNegationTo(os);\n    }\n\n   private:\n    const Matcher<U> source_matcher_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n};\n\n// This even more specialized version is used for efficiently casting\n// a matcher to its own type.\ntemplate <typename T>\nclass MatcherCastImpl<T, Matcher<T> > {\n public:\n  static Matcher<T> Cast(const Matcher<T>& matcher) { return matcher; }\n};\n\n}  // namespace internal\n\n// In order to be safe and clear, casting between different matcher\n// types is done explicitly via MatcherCast<T>(m), which takes a\n// matcher m and returns a Matcher<T>.  It compiles only when T can be\n// statically converted to the argument type of m.\ntemplate <typename T, typename M>\ninline Matcher<T> MatcherCast(const M& matcher) {\n  return internal::MatcherCastImpl<T, M>::Cast(matcher);\n}\n\n// Implements SafeMatcherCast().\n//\n// We use an intermediate class to do the actual safe casting as Nokia's\n// Symbian compiler cannot decide between\n// template <T, M> ... (M) and\n// template <T, U> ... (const Matcher<U>&)\n// for function templates but can for member function templates.\ntemplate <typename T>\nclass SafeMatcherCastImpl {\n public:\n  // This overload handles polymorphic matchers and values only since\n  // monomorphic matchers are handled by the next one.\n  template <typename M>\n  static inline Matcher<T> Cast(const M& polymorphic_matcher_or_value) {\n    return internal::MatcherCastImpl<T, M>::Cast(polymorphic_matcher_or_value);\n  }\n\n  // This overload handles monomorphic matchers.\n  //\n  // In general, if type T can be implicitly converted to type U, we can\n  // safely convert a Matcher<U> to a Matcher<T> (i.e. Matcher is\n  // contravariant): just keep a copy of the original Matcher<U>, convert the\n  // argument from type T to U, and then pass it to the underlying Matcher<U>.\n  // The only exception is when U is a reference and T is not, as the\n  // underlying Matcher<U> may be interested in the argument's address, which\n  // is not preserved in the conversion from T to U.\n  template <typename U>\n  static inline Matcher<T> Cast(const Matcher<U>& matcher) {\n    // Enforce that T can be implicitly converted to U.\n    GTEST_COMPILE_ASSERT_((internal::ImplicitlyConvertible<T, U>::value),\n                          T_must_be_implicitly_convertible_to_U);\n    // Enforce that we are not converting a non-reference type T to a reference\n    // type U.\n    GTEST_COMPILE_ASSERT_(\n        internal::is_reference<T>::value || !internal::is_reference<U>::value,\n        cannot_convert_non_referentce_arg_to_reference);\n    // In case both T and U are arithmetic types, enforce that the\n    // conversion is not lossy.\n    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(T) RawT;\n    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(U) RawU;\n    const bool kTIsOther = GMOCK_KIND_OF_(RawT) == internal::kOther;\n    const bool kUIsOther = GMOCK_KIND_OF_(RawU) == internal::kOther;\n    GTEST_COMPILE_ASSERT_(\n        kTIsOther || kUIsOther ||\n        (internal::LosslessArithmeticConvertible<RawT, RawU>::value),\n        conversion_of_arithmetic_types_must_be_lossless);\n    return MatcherCast<T>(matcher);\n  }\n};\n\ntemplate <typename T, typename M>\ninline Matcher<T> SafeMatcherCast(const M& polymorphic_matcher) {\n  return SafeMatcherCastImpl<T>::Cast(polymorphic_matcher);\n}\n\n// A<T>() returns a matcher that matches any value of type T.\ntemplate <typename T>\nMatcher<T> A();\n\n// Anything inside the 'internal' namespace IS INTERNAL IMPLEMENTATION\n// and MUST NOT BE USED IN USER CODE!!!\nnamespace internal {\n\n// If the explanation is not empty, prints it to the ostream.\ninline void PrintIfNotEmpty(const internal::string& explanation,\n                            ::std::ostream* os) {\n  if (explanation != \"\" && os != NULL) {\n    *os << \", \" << explanation;\n  }\n}\n\n// Returns true if the given type name is easy to read by a human.\n// This is used to decide whether printing the type of a value might\n// be helpful.\ninline bool IsReadableTypeName(const string& type_name) {\n  // We consider a type name readable if it's short or doesn't contain\n  // a template or function type.\n  return (type_name.length() <= 20 ||\n          type_name.find_first_of(\"<(\") == string::npos);\n}\n\n// Matches the value against the given matcher, prints the value and explains\n// the match result to the listener. Returns the match result.\n// 'listener' must not be NULL.\n// Value cannot be passed by const reference, because some matchers take a\n// non-const argument.\ntemplate <typename Value, typename T>\nbool MatchPrintAndExplain(Value& value, const Matcher<T>& matcher,\n                          MatchResultListener* listener) {\n  if (!listener->IsInterested()) {\n    // If the listener is not interested, we do not need to construct the\n    // inner explanation.\n    return matcher.Matches(value);\n  }\n\n  StringMatchResultListener inner_listener;\n  const bool match = matcher.MatchAndExplain(value, &inner_listener);\n\n  UniversalPrint(value, listener->stream());\n#if GTEST_HAS_RTTI\n  const string& type_name = GetTypeName<Value>();\n  if (IsReadableTypeName(type_name))\n    *listener->stream() << \" (of type \" << type_name << \")\";\n#endif\n  PrintIfNotEmpty(inner_listener.str(), listener->stream());\n\n  return match;\n}\n\n// An internal helper class for doing compile-time loop on a tuple's\n// fields.\ntemplate <size_t N>\nclass TuplePrefix {\n public:\n  // TuplePrefix<N>::Matches(matcher_tuple, value_tuple) returns true\n  // iff the first N fields of matcher_tuple matches the first N\n  // fields of value_tuple, respectively.\n  template <typename MatcherTuple, typename ValueTuple>\n  static bool Matches(const MatcherTuple& matcher_tuple,\n                      const ValueTuple& value_tuple) {\n    return TuplePrefix<N - 1>::Matches(matcher_tuple, value_tuple)\n        && get<N - 1>(matcher_tuple).Matches(get<N - 1>(value_tuple));\n  }\n\n  // TuplePrefix<N>::ExplainMatchFailuresTo(matchers, values, os)\n  // describes failures in matching the first N fields of matchers\n  // against the first N fields of values.  If there is no failure,\n  // nothing will be streamed to os.\n  template <typename MatcherTuple, typename ValueTuple>\n  static void ExplainMatchFailuresTo(const MatcherTuple& matchers,\n                                     const ValueTuple& values,\n                                     ::std::ostream* os) {\n    // First, describes failures in the first N - 1 fields.\n    TuplePrefix<N - 1>::ExplainMatchFailuresTo(matchers, values, os);\n\n    // Then describes the failure (if any) in the (N - 1)-th (0-based)\n    // field.\n    typename tuple_element<N - 1, MatcherTuple>::type matcher =\n        get<N - 1>(matchers);\n    typedef typename tuple_element<N - 1, ValueTuple>::type Value;\n    Value value = get<N - 1>(values);\n    StringMatchResultListener listener;\n    if (!matcher.MatchAndExplain(value, &listener)) {\n      // TODO(wan): include in the message the name of the parameter\n      // as used in MOCK_METHOD*() when possible.\n      *os << \"  Expected arg #\" << N - 1 << \": \";\n      get<N - 1>(matchers).DescribeTo(os);\n      *os << \"\\n           Actual: \";\n      // We remove the reference in type Value to prevent the\n      // universal printer from printing the address of value, which\n      // isn't interesting to the user most of the time.  The\n      // matcher's MatchAndExplain() method handles the case when\n      // the address is interesting.\n      internal::UniversalPrint(value, os);\n      PrintIfNotEmpty(listener.str(), os);\n      *os << \"\\n\";\n    }\n  }\n};\n\n// The base case.\ntemplate <>\nclass TuplePrefix<0> {\n public:\n  template <typename MatcherTuple, typename ValueTuple>\n  static bool Matches(const MatcherTuple& /* matcher_tuple */,\n                      const ValueTuple& /* value_tuple */) {\n    return true;\n  }\n\n  template <typename MatcherTuple, typename ValueTuple>\n  static void ExplainMatchFailuresTo(const MatcherTuple& /* matchers */,\n                                     const ValueTuple& /* values */,\n                                     ::std::ostream* /* os */) {}\n};\n\n// TupleMatches(matcher_tuple, value_tuple) returns true iff all\n// matchers in matcher_tuple match the corresponding fields in\n// value_tuple.  It is a compiler error if matcher_tuple and\n// value_tuple have different number of fields or incompatible field\n// types.\ntemplate <typename MatcherTuple, typename ValueTuple>\nbool TupleMatches(const MatcherTuple& matcher_tuple,\n                  const ValueTuple& value_tuple) {\n  // Makes sure that matcher_tuple and value_tuple have the same\n  // number of fields.\n  GTEST_COMPILE_ASSERT_(tuple_size<MatcherTuple>::value ==\n                        tuple_size<ValueTuple>::value,\n                        matcher_and_value_have_different_numbers_of_fields);\n  return TuplePrefix<tuple_size<ValueTuple>::value>::\n      Matches(matcher_tuple, value_tuple);\n}\n\n// Describes failures in matching matchers against values.  If there\n// is no failure, nothing will be streamed to os.\ntemplate <typename MatcherTuple, typename ValueTuple>\nvoid ExplainMatchFailureTupleTo(const MatcherTuple& matchers,\n                                const ValueTuple& values,\n                                ::std::ostream* os) {\n  TuplePrefix<tuple_size<MatcherTuple>::value>::ExplainMatchFailuresTo(\n      matchers, values, os);\n}\n\n// TransformTupleValues and its helper.\n//\n// TransformTupleValuesHelper hides the internal machinery that\n// TransformTupleValues uses to implement a tuple traversal.\ntemplate <typename Tuple, typename Func, typename OutIter>\nclass TransformTupleValuesHelper {\n private:\n  typedef ::testing::tuple_size<Tuple> TupleSize;\n\n public:\n  // For each member of tuple 't', taken in order, evaluates '*out++ = f(t)'.\n  // Returns the final value of 'out' in case the caller needs it.\n  static OutIter Run(Func f, const Tuple& t, OutIter out) {\n    return IterateOverTuple<Tuple, TupleSize::value>()(f, t, out);\n  }\n\n private:\n  template <typename Tup, size_t kRemainingSize>\n  struct IterateOverTuple {\n    OutIter operator() (Func f, const Tup& t, OutIter out) const {\n      *out++ = f(::testing::get<TupleSize::value - kRemainingSize>(t));\n      return IterateOverTuple<Tup, kRemainingSize - 1>()(f, t, out);\n    }\n  };\n  template <typename Tup>\n  struct IterateOverTuple<Tup, 0> {\n    OutIter operator() (Func /* f */, const Tup& /* t */, OutIter out) const {\n      return out;\n    }\n  };\n};\n\n// Successively invokes 'f(element)' on each element of the tuple 't',\n// appending each result to the 'out' iterator. Returns the final value\n// of 'out'.\ntemplate <typename Tuple, typename Func, typename OutIter>\nOutIter TransformTupleValues(Func f, const Tuple& t, OutIter out) {\n  return TransformTupleValuesHelper<Tuple, Func, OutIter>::Run(f, t, out);\n}\n\n// Implements A<T>().\ntemplate <typename T>\nclass AnyMatcherImpl : public MatcherInterface<T> {\n public:\n  virtual bool MatchAndExplain(\n      T /* x */, MatchResultListener* /* listener */) const { return true; }\n  virtual void DescribeTo(::std::ostream* os) const { *os << \"is anything\"; }\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    // This is mostly for completeness' safe, as it's not very useful\n    // to write Not(A<bool>()).  However we cannot completely rule out\n    // such a possibility, and it doesn't hurt to be prepared.\n    *os << \"never matches\";\n  }\n};\n\n// Implements _, a matcher that matches any value of any\n// type.  This is a polymorphic matcher, so we need a template type\n// conversion operator to make it appearing as a Matcher<T> for any\n// type T.\nclass AnythingMatcher {\n public:\n  template <typename T>\n  operator Matcher<T>() const { return A<T>(); }\n};\n\n// Implements a matcher that compares a given value with a\n// pre-supplied value using one of the ==, <=, <, etc, operators.  The\n// two values being compared don't have to have the same type.\n//\n// The matcher defined here is polymorphic (for example, Eq(5) can be\n// used to match an int, a short, a double, etc).  Therefore we use\n// a template type conversion operator in the implementation.\n//\n// The following template definition assumes that the Rhs parameter is\n// a \"bare\" type (i.e. neither 'const T' nor 'T&').\ntemplate <typename D, typename Rhs, typename Op>\nclass ComparisonBase {\n public:\n  explicit ComparisonBase(const Rhs& rhs) : rhs_(rhs) {}\n  template <typename Lhs>\n  operator Matcher<Lhs>() const {\n    return MakeMatcher(new Impl<Lhs>(rhs_));\n  }\n\n private:\n  template <typename Lhs>\n  class Impl : public MatcherInterface<Lhs> {\n   public:\n    explicit Impl(const Rhs& rhs) : rhs_(rhs) {}\n    virtual bool MatchAndExplain(\n        Lhs lhs, MatchResultListener* /* listener */) const {\n      return Op()(lhs, rhs_);\n    }\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << D::Desc() << \" \";\n      UniversalPrint(rhs_, os);\n    }\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << D::NegatedDesc() <<  \" \";\n      UniversalPrint(rhs_, os);\n    }\n   private:\n    Rhs rhs_;\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n  Rhs rhs_;\n  GTEST_DISALLOW_ASSIGN_(ComparisonBase);\n};\n\ntemplate <typename Rhs>\nclass EqMatcher : public ComparisonBase<EqMatcher<Rhs>, Rhs, AnyEq> {\n public:\n  explicit EqMatcher(const Rhs& rhs)\n      : ComparisonBase<EqMatcher<Rhs>, Rhs, AnyEq>(rhs) { }\n  static const char* Desc() { return \"is equal to\"; }\n  static const char* NegatedDesc() { return \"isn't equal to\"; }\n};\ntemplate <typename Rhs>\nclass NeMatcher : public ComparisonBase<NeMatcher<Rhs>, Rhs, AnyNe> {\n public:\n  explicit NeMatcher(const Rhs& rhs)\n      : ComparisonBase<NeMatcher<Rhs>, Rhs, AnyNe>(rhs) { }\n  static const char* Desc() { return \"isn't equal to\"; }\n  static const char* NegatedDesc() { return \"is equal to\"; }\n};\ntemplate <typename Rhs>\nclass LtMatcher : public ComparisonBase<LtMatcher<Rhs>, Rhs, AnyLt> {\n public:\n  explicit LtMatcher(const Rhs& rhs)\n      : ComparisonBase<LtMatcher<Rhs>, Rhs, AnyLt>(rhs) { }\n  static const char* Desc() { return \"is <\"; }\n  static const char* NegatedDesc() { return \"isn't <\"; }\n};\ntemplate <typename Rhs>\nclass GtMatcher : public ComparisonBase<GtMatcher<Rhs>, Rhs, AnyGt> {\n public:\n  explicit GtMatcher(const Rhs& rhs)\n      : ComparisonBase<GtMatcher<Rhs>, Rhs, AnyGt>(rhs) { }\n  static const char* Desc() { return \"is >\"; }\n  static const char* NegatedDesc() { return \"isn't >\"; }\n};\ntemplate <typename Rhs>\nclass LeMatcher : public ComparisonBase<LeMatcher<Rhs>, Rhs, AnyLe> {\n public:\n  explicit LeMatcher(const Rhs& rhs)\n      : ComparisonBase<LeMatcher<Rhs>, Rhs, AnyLe>(rhs) { }\n  static const char* Desc() { return \"is <=\"; }\n  static const char* NegatedDesc() { return \"isn't <=\"; }\n};\ntemplate <typename Rhs>\nclass GeMatcher : public ComparisonBase<GeMatcher<Rhs>, Rhs, AnyGe> {\n public:\n  explicit GeMatcher(const Rhs& rhs)\n      : ComparisonBase<GeMatcher<Rhs>, Rhs, AnyGe>(rhs) { }\n  static const char* Desc() { return \"is >=\"; }\n  static const char* NegatedDesc() { return \"isn't >=\"; }\n};\n\n// Implements the polymorphic IsNull() matcher, which matches any raw or smart\n// pointer that is NULL.\nclass IsNullMatcher {\n public:\n  template <typename Pointer>\n  bool MatchAndExplain(const Pointer& p,\n                       MatchResultListener* /* listener */) const {\n#if GTEST_LANG_CXX11\n    return p == nullptr;\n#else  // GTEST_LANG_CXX11\n    return GetRawPointer(p) == NULL;\n#endif  // GTEST_LANG_CXX11\n  }\n\n  void DescribeTo(::std::ostream* os) const { *os << \"is NULL\"; }\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"isn't NULL\";\n  }\n};\n\n// Implements the polymorphic NotNull() matcher, which matches any raw or smart\n// pointer that is not NULL.\nclass NotNullMatcher {\n public:\n  template <typename Pointer>\n  bool MatchAndExplain(const Pointer& p,\n                       MatchResultListener* /* listener */) const {\n#if GTEST_LANG_CXX11\n    return p != nullptr;\n#else  // GTEST_LANG_CXX11\n    return GetRawPointer(p) != NULL;\n#endif  // GTEST_LANG_CXX11\n  }\n\n  void DescribeTo(::std::ostream* os) const { *os << \"isn't NULL\"; }\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"is NULL\";\n  }\n};\n\n// Ref(variable) matches any argument that is a reference to\n// 'variable'.  This matcher is polymorphic as it can match any\n// super type of the type of 'variable'.\n//\n// The RefMatcher template class implements Ref(variable).  It can\n// only be instantiated with a reference type.  This prevents a user\n// from mistakenly using Ref(x) to match a non-reference function\n// argument.  For example, the following will righteously cause a\n// compiler error:\n//\n//   int n;\n//   Matcher<int> m1 = Ref(n);   // This won't compile.\n//   Matcher<int&> m2 = Ref(n);  // This will compile.\ntemplate <typename T>\nclass RefMatcher;\n\ntemplate <typename T>\nclass RefMatcher<T&> {\n  // Google Mock is a generic framework and thus needs to support\n  // mocking any function types, including those that take non-const\n  // reference arguments.  Therefore the template parameter T (and\n  // Super below) can be instantiated to either a const type or a\n  // non-const type.\n public:\n  // RefMatcher() takes a T& instead of const T&, as we want the\n  // compiler to catch using Ref(const_value) as a matcher for a\n  // non-const reference.\n  explicit RefMatcher(T& x) : object_(x) {}  // NOLINT\n\n  template <typename Super>\n  operator Matcher<Super&>() const {\n    // By passing object_ (type T&) to Impl(), which expects a Super&,\n    // we make sure that Super is a super type of T.  In particular,\n    // this catches using Ref(const_value) as a matcher for a\n    // non-const reference, as you cannot implicitly convert a const\n    // reference to a non-const reference.\n    return MakeMatcher(new Impl<Super>(object_));\n  }\n\n private:\n  template <typename Super>\n  class Impl : public MatcherInterface<Super&> {\n   public:\n    explicit Impl(Super& x) : object_(x) {}  // NOLINT\n\n    // MatchAndExplain() takes a Super& (as opposed to const Super&)\n    // in order to match the interface MatcherInterface<Super&>.\n    virtual bool MatchAndExplain(\n        Super& x, MatchResultListener* listener) const {\n      *listener << \"which is located @\" << static_cast<const void*>(&x);\n      return &x == &object_;\n    }\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"references the variable \";\n      UniversalPrinter<Super&>::Print(object_, os);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"does not reference the variable \";\n      UniversalPrinter<Super&>::Print(object_, os);\n    }\n\n   private:\n    const Super& object_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  T& object_;\n\n  GTEST_DISALLOW_ASSIGN_(RefMatcher);\n};\n\n// Polymorphic helper functions for narrow and wide string matchers.\ninline bool CaseInsensitiveCStringEquals(const char* lhs, const char* rhs) {\n  return String::CaseInsensitiveCStringEquals(lhs, rhs);\n}\n\ninline bool CaseInsensitiveCStringEquals(const wchar_t* lhs,\n                                         const wchar_t* rhs) {\n  return String::CaseInsensitiveWideCStringEquals(lhs, rhs);\n}\n\n// String comparison for narrow or wide strings that can have embedded NUL\n// characters.\ntemplate <typename StringType>\nbool CaseInsensitiveStringEquals(const StringType& s1,\n                                 const StringType& s2) {\n  // Are the heads equal?\n  if (!CaseInsensitiveCStringEquals(s1.c_str(), s2.c_str())) {\n    return false;\n  }\n\n  // Skip the equal heads.\n  const typename StringType::value_type nul = 0;\n  const size_t i1 = s1.find(nul), i2 = s2.find(nul);\n\n  // Are we at the end of either s1 or s2?\n  if (i1 == StringType::npos || i2 == StringType::npos) {\n    return i1 == i2;\n  }\n\n  // Are the tails equal?\n  return CaseInsensitiveStringEquals(s1.substr(i1 + 1), s2.substr(i2 + 1));\n}\n\n// String matchers.\n\n// Implements equality-based string matchers like StrEq, StrCaseNe, and etc.\ntemplate <typename StringType>\nclass StrEqualityMatcher {\n public:\n  StrEqualityMatcher(const StringType& str, bool expect_eq,\n                     bool case_sensitive)\n      : string_(str), expect_eq_(expect_eq), case_sensitive_(case_sensitive) {}\n\n  // Accepts pointer types, particularly:\n  //   const char*\n  //   char*\n  //   const wchar_t*\n  //   wchar_t*\n  template <typename CharType>\n  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {\n    if (s == NULL) {\n      return !expect_eq_;\n    }\n    return MatchAndExplain(StringType(s), listener);\n  }\n\n  // Matches anything that can convert to StringType.\n  //\n  // This is a template, not just a plain function with const StringType&,\n  // because StringPiece has some interfering non-explicit constructors.\n  template <typename MatcheeStringType>\n  bool MatchAndExplain(const MatcheeStringType& s,\n                       MatchResultListener* /* listener */) const {\n    const StringType& s2(s);\n    const bool eq = case_sensitive_ ? s2 == string_ :\n        CaseInsensitiveStringEquals(s2, string_);\n    return expect_eq_ == eq;\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    DescribeToHelper(expect_eq_, os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    DescribeToHelper(!expect_eq_, os);\n  }\n\n private:\n  void DescribeToHelper(bool expect_eq, ::std::ostream* os) const {\n    *os << (expect_eq ? \"is \" : \"isn't \");\n    *os << \"equal to \";\n    if (!case_sensitive_) {\n      *os << \"(ignoring case) \";\n    }\n    UniversalPrint(string_, os);\n  }\n\n  const StringType string_;\n  const bool expect_eq_;\n  const bool case_sensitive_;\n\n  GTEST_DISALLOW_ASSIGN_(StrEqualityMatcher);\n};\n\n// Implements the polymorphic HasSubstr(substring) matcher, which\n// can be used as a Matcher<T> as long as T can be converted to a\n// string.\ntemplate <typename StringType>\nclass HasSubstrMatcher {\n public:\n  explicit HasSubstrMatcher(const StringType& substring)\n      : substring_(substring) {}\n\n  // Accepts pointer types, particularly:\n  //   const char*\n  //   char*\n  //   const wchar_t*\n  //   wchar_t*\n  template <typename CharType>\n  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {\n    return s != NULL && MatchAndExplain(StringType(s), listener);\n  }\n\n  // Matches anything that can convert to StringType.\n  //\n  // This is a template, not just a plain function with const StringType&,\n  // because StringPiece has some interfering non-explicit constructors.\n  template <typename MatcheeStringType>\n  bool MatchAndExplain(const MatcheeStringType& s,\n                       MatchResultListener* /* listener */) const {\n    const StringType& s2(s);\n    return s2.find(substring_) != StringType::npos;\n  }\n\n  // Describes what this matcher matches.\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"has substring \";\n    UniversalPrint(substring_, os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"has no substring \";\n    UniversalPrint(substring_, os);\n  }\n\n private:\n  const StringType substring_;\n\n  GTEST_DISALLOW_ASSIGN_(HasSubstrMatcher);\n};\n\n// Implements the polymorphic StartsWith(substring) matcher, which\n// can be used as a Matcher<T> as long as T can be converted to a\n// string.\ntemplate <typename StringType>\nclass StartsWithMatcher {\n public:\n  explicit StartsWithMatcher(const StringType& prefix) : prefix_(prefix) {\n  }\n\n  // Accepts pointer types, particularly:\n  //   const char*\n  //   char*\n  //   const wchar_t*\n  //   wchar_t*\n  template <typename CharType>\n  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {\n    return s != NULL && MatchAndExplain(StringType(s), listener);\n  }\n\n  // Matches anything that can convert to StringType.\n  //\n  // This is a template, not just a plain function with const StringType&,\n  // because StringPiece has some interfering non-explicit constructors.\n  template <typename MatcheeStringType>\n  bool MatchAndExplain(const MatcheeStringType& s,\n                       MatchResultListener* /* listener */) const {\n    const StringType& s2(s);\n    return s2.length() >= prefix_.length() &&\n        s2.substr(0, prefix_.length()) == prefix_;\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"starts with \";\n    UniversalPrint(prefix_, os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"doesn't start with \";\n    UniversalPrint(prefix_, os);\n  }\n\n private:\n  const StringType prefix_;\n\n  GTEST_DISALLOW_ASSIGN_(StartsWithMatcher);\n};\n\n// Implements the polymorphic EndsWith(substring) matcher, which\n// can be used as a Matcher<T> as long as T can be converted to a\n// string.\ntemplate <typename StringType>\nclass EndsWithMatcher {\n public:\n  explicit EndsWithMatcher(const StringType& suffix) : suffix_(suffix) {}\n\n  // Accepts pointer types, particularly:\n  //   const char*\n  //   char*\n  //   const wchar_t*\n  //   wchar_t*\n  template <typename CharType>\n  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {\n    return s != NULL && MatchAndExplain(StringType(s), listener);\n  }\n\n  // Matches anything that can convert to StringType.\n  //\n  // This is a template, not just a plain function with const StringType&,\n  // because StringPiece has some interfering non-explicit constructors.\n  template <typename MatcheeStringType>\n  bool MatchAndExplain(const MatcheeStringType& s,\n                       MatchResultListener* /* listener */) const {\n    const StringType& s2(s);\n    return s2.length() >= suffix_.length() &&\n        s2.substr(s2.length() - suffix_.length()) == suffix_;\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"ends with \";\n    UniversalPrint(suffix_, os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"doesn't end with \";\n    UniversalPrint(suffix_, os);\n  }\n\n private:\n  const StringType suffix_;\n\n  GTEST_DISALLOW_ASSIGN_(EndsWithMatcher);\n};\n\n// Implements polymorphic matchers MatchesRegex(regex) and\n// ContainsRegex(regex), which can be used as a Matcher<T> as long as\n// T can be converted to a string.\nclass MatchesRegexMatcher {\n public:\n  MatchesRegexMatcher(const RE* regex, bool full_match)\n      : regex_(regex), full_match_(full_match) {}\n\n  // Accepts pointer types, particularly:\n  //   const char*\n  //   char*\n  //   const wchar_t*\n  //   wchar_t*\n  template <typename CharType>\n  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {\n    return s != NULL && MatchAndExplain(internal::string(s), listener);\n  }\n\n  // Matches anything that can convert to internal::string.\n  //\n  // This is a template, not just a plain function with const internal::string&,\n  // because StringPiece has some interfering non-explicit constructors.\n  template <class MatcheeStringType>\n  bool MatchAndExplain(const MatcheeStringType& s,\n                       MatchResultListener* /* listener */) const {\n    const internal::string& s2(s);\n    return full_match_ ? RE::FullMatch(s2, *regex_) :\n        RE::PartialMatch(s2, *regex_);\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << (full_match_ ? \"matches\" : \"contains\")\n        << \" regular expression \";\n    UniversalPrinter<internal::string>::Print(regex_->pattern(), os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"doesn't \" << (full_match_ ? \"match\" : \"contain\")\n        << \" regular expression \";\n    UniversalPrinter<internal::string>::Print(regex_->pattern(), os);\n  }\n\n private:\n  const internal::linked_ptr<const RE> regex_;\n  const bool full_match_;\n\n  GTEST_DISALLOW_ASSIGN_(MatchesRegexMatcher);\n};\n\n// Implements a matcher that compares the two fields of a 2-tuple\n// using one of the ==, <=, <, etc, operators.  The two fields being\n// compared don't have to have the same type.\n//\n// The matcher defined here is polymorphic (for example, Eq() can be\n// used to match a tuple<int, short>, a tuple<const long&, double>,\n// etc).  Therefore we use a template type conversion operator in the\n// implementation.\ntemplate <typename D, typename Op>\nclass PairMatchBase {\n public:\n  template <typename T1, typename T2>\n  operator Matcher< ::testing::tuple<T1, T2> >() const {\n    return MakeMatcher(new Impl< ::testing::tuple<T1, T2> >);\n  }\n  template <typename T1, typename T2>\n  operator Matcher<const ::testing::tuple<T1, T2>&>() const {\n    return MakeMatcher(new Impl<const ::testing::tuple<T1, T2>&>);\n  }\n\n private:\n  static ::std::ostream& GetDesc(::std::ostream& os) {  // NOLINT\n    return os << D::Desc();\n  }\n\n  template <typename Tuple>\n  class Impl : public MatcherInterface<Tuple> {\n   public:\n    virtual bool MatchAndExplain(\n        Tuple args,\n        MatchResultListener* /* listener */) const {\n      return Op()(::testing::get<0>(args), ::testing::get<1>(args));\n    }\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"are \" << GetDesc;\n    }\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"aren't \" << GetDesc;\n    }\n  };\n};\n\nclass Eq2Matcher : public PairMatchBase<Eq2Matcher, AnyEq> {\n public:\n  static const char* Desc() { return \"an equal pair\"; }\n};\nclass Ne2Matcher : public PairMatchBase<Ne2Matcher, AnyNe> {\n public:\n  static const char* Desc() { return \"an unequal pair\"; }\n};\nclass Lt2Matcher : public PairMatchBase<Lt2Matcher, AnyLt> {\n public:\n  static const char* Desc() { return \"a pair where the first < the second\"; }\n};\nclass Gt2Matcher : public PairMatchBase<Gt2Matcher, AnyGt> {\n public:\n  static const char* Desc() { return \"a pair where the first > the second\"; }\n};\nclass Le2Matcher : public PairMatchBase<Le2Matcher, AnyLe> {\n public:\n  static const char* Desc() { return \"a pair where the first <= the second\"; }\n};\nclass Ge2Matcher : public PairMatchBase<Ge2Matcher, AnyGe> {\n public:\n  static const char* Desc() { return \"a pair where the first >= the second\"; }\n};\n\n// Implements the Not(...) matcher for a particular argument type T.\n// We do not nest it inside the NotMatcher class template, as that\n// will prevent different instantiations of NotMatcher from sharing\n// the same NotMatcherImpl<T> class.\ntemplate <typename T>\nclass NotMatcherImpl : public MatcherInterface<T> {\n public:\n  explicit NotMatcherImpl(const Matcher<T>& matcher)\n      : matcher_(matcher) {}\n\n  virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {\n    return !matcher_.MatchAndExplain(x, listener);\n  }\n\n  virtual void DescribeTo(::std::ostream* os) const {\n    matcher_.DescribeNegationTo(os);\n  }\n\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    matcher_.DescribeTo(os);\n  }\n\n private:\n  const Matcher<T> matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(NotMatcherImpl);\n};\n\n// Implements the Not(m) matcher, which matches a value that doesn't\n// match matcher m.\ntemplate <typename InnerMatcher>\nclass NotMatcher {\n public:\n  explicit NotMatcher(InnerMatcher matcher) : matcher_(matcher) {}\n\n  // This template type conversion operator allows Not(m) to be used\n  // to match any type m can match.\n  template <typename T>\n  operator Matcher<T>() const {\n    return Matcher<T>(new NotMatcherImpl<T>(SafeMatcherCast<T>(matcher_)));\n  }\n\n private:\n  InnerMatcher matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(NotMatcher);\n};\n\n// Implements the AllOf(m1, m2) matcher for a particular argument type\n// T. We do not nest it inside the BothOfMatcher class template, as\n// that will prevent different instantiations of BothOfMatcher from\n// sharing the same BothOfMatcherImpl<T> class.\ntemplate <typename T>\nclass BothOfMatcherImpl : public MatcherInterface<T> {\n public:\n  BothOfMatcherImpl(const Matcher<T>& matcher1, const Matcher<T>& matcher2)\n      : matcher1_(matcher1), matcher2_(matcher2) {}\n\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"(\";\n    matcher1_.DescribeTo(os);\n    *os << \") and (\";\n    matcher2_.DescribeTo(os);\n    *os << \")\";\n  }\n\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"(\";\n    matcher1_.DescribeNegationTo(os);\n    *os << \") or (\";\n    matcher2_.DescribeNegationTo(os);\n    *os << \")\";\n  }\n\n  virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {\n    // If either matcher1_ or matcher2_ doesn't match x, we only need\n    // to explain why one of them fails.\n    StringMatchResultListener listener1;\n    if (!matcher1_.MatchAndExplain(x, &listener1)) {\n      *listener << listener1.str();\n      return false;\n    }\n\n    StringMatchResultListener listener2;\n    if (!matcher2_.MatchAndExplain(x, &listener2)) {\n      *listener << listener2.str();\n      return false;\n    }\n\n    // Otherwise we need to explain why *both* of them match.\n    const internal::string s1 = listener1.str();\n    const internal::string s2 = listener2.str();\n\n    if (s1 == \"\") {\n      *listener << s2;\n    } else {\n      *listener << s1;\n      if (s2 != \"\") {\n        *listener << \", and \" << s2;\n      }\n    }\n    return true;\n  }\n\n private:\n  const Matcher<T> matcher1_;\n  const Matcher<T> matcher2_;\n\n  GTEST_DISALLOW_ASSIGN_(BothOfMatcherImpl);\n};\n\n#if GTEST_LANG_CXX11\n// MatcherList provides mechanisms for storing a variable number of matchers in\n// a list structure (ListType) and creating a combining matcher from such a\n// list.\n// The template is defined recursively using the following template paramters:\n//   * kSize is the length of the MatcherList.\n//   * Head is the type of the first matcher of the list.\n//   * Tail denotes the types of the remaining matchers of the list.\ntemplate <int kSize, typename Head, typename... Tail>\nstruct MatcherList {\n  typedef MatcherList<kSize - 1, Tail...> MatcherListTail;\n  typedef ::std::pair<Head, typename MatcherListTail::ListType> ListType;\n\n  // BuildList stores variadic type values in a nested pair structure.\n  // Example:\n  // MatcherList<3, int, string, float>::BuildList(5, \"foo\", 2.0) will return\n  // the corresponding result of type pair<int, pair<string, float>>.\n  static ListType BuildList(const Head& matcher, const Tail&... tail) {\n    return ListType(matcher, MatcherListTail::BuildList(tail...));\n  }\n\n  // CreateMatcher<T> creates a Matcher<T> from a given list of matchers (built\n  // by BuildList()). CombiningMatcher<T> is used to combine the matchers of the\n  // list. CombiningMatcher<T> must implement MatcherInterface<T> and have a\n  // constructor taking two Matcher<T>s as input.\n  template <typename T, template <typename /* T */> class CombiningMatcher>\n  static Matcher<T> CreateMatcher(const ListType& matchers) {\n    return Matcher<T>(new CombiningMatcher<T>(\n        SafeMatcherCast<T>(matchers.first),\n        MatcherListTail::template CreateMatcher<T, CombiningMatcher>(\n            matchers.second)));\n  }\n};\n\n// The following defines the base case for the recursive definition of\n// MatcherList.\ntemplate <typename Matcher1, typename Matcher2>\nstruct MatcherList<2, Matcher1, Matcher2> {\n  typedef ::std::pair<Matcher1, Matcher2> ListType;\n\n  static ListType BuildList(const Matcher1& matcher1,\n                            const Matcher2& matcher2) {\n    return ::std::pair<Matcher1, Matcher2>(matcher1, matcher2);\n  }\n\n  template <typename T, template <typename /* T */> class CombiningMatcher>\n  static Matcher<T> CreateMatcher(const ListType& matchers) {\n    return Matcher<T>(new CombiningMatcher<T>(\n        SafeMatcherCast<T>(matchers.first),\n        SafeMatcherCast<T>(matchers.second)));\n  }\n};\n\n// VariadicMatcher is used for the variadic implementation of\n// AllOf(m_1, m_2, ...) and AnyOf(m_1, m_2, ...).\n// CombiningMatcher<T> is used to recursively combine the provided matchers\n// (of type Args...).\ntemplate <template <typename T> class CombiningMatcher, typename... Args>\nclass VariadicMatcher {\n public:\n  VariadicMatcher(const Args&... matchers)  // NOLINT\n      : matchers_(MatcherListType::BuildList(matchers...)) {}\n\n  // This template type conversion operator allows an\n  // VariadicMatcher<Matcher1, Matcher2...> object to match any type that\n  // all of the provided matchers (Matcher1, Matcher2, ...) can match.\n  template <typename T>\n  operator Matcher<T>() const {\n    return MatcherListType::template CreateMatcher<T, CombiningMatcher>(\n        matchers_);\n  }\n\n private:\n  typedef MatcherList<sizeof...(Args), Args...> MatcherListType;\n\n  const typename MatcherListType::ListType matchers_;\n\n  GTEST_DISALLOW_ASSIGN_(VariadicMatcher);\n};\n\ntemplate <typename... Args>\nusing AllOfMatcher = VariadicMatcher<BothOfMatcherImpl, Args...>;\n\n#endif  // GTEST_LANG_CXX11\n\n// Used for implementing the AllOf(m_1, ..., m_n) matcher, which\n// matches a value that matches all of the matchers m_1, ..., and m_n.\ntemplate <typename Matcher1, typename Matcher2>\nclass BothOfMatcher {\n public:\n  BothOfMatcher(Matcher1 matcher1, Matcher2 matcher2)\n      : matcher1_(matcher1), matcher2_(matcher2) {}\n\n  // This template type conversion operator allows a\n  // BothOfMatcher<Matcher1, Matcher2> object to match any type that\n  // both Matcher1 and Matcher2 can match.\n  template <typename T>\n  operator Matcher<T>() const {\n    return Matcher<T>(new BothOfMatcherImpl<T>(SafeMatcherCast<T>(matcher1_),\n                                               SafeMatcherCast<T>(matcher2_)));\n  }\n\n private:\n  Matcher1 matcher1_;\n  Matcher2 matcher2_;\n\n  GTEST_DISALLOW_ASSIGN_(BothOfMatcher);\n};\n\n// Implements the AnyOf(m1, m2) matcher for a particular argument type\n// T.  We do not nest it inside the AnyOfMatcher class template, as\n// that will prevent different instantiations of AnyOfMatcher from\n// sharing the same EitherOfMatcherImpl<T> class.\ntemplate <typename T>\nclass EitherOfMatcherImpl : public MatcherInterface<T> {\n public:\n  EitherOfMatcherImpl(const Matcher<T>& matcher1, const Matcher<T>& matcher2)\n      : matcher1_(matcher1), matcher2_(matcher2) {}\n\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"(\";\n    matcher1_.DescribeTo(os);\n    *os << \") or (\";\n    matcher2_.DescribeTo(os);\n    *os << \")\";\n  }\n\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"(\";\n    matcher1_.DescribeNegationTo(os);\n    *os << \") and (\";\n    matcher2_.DescribeNegationTo(os);\n    *os << \")\";\n  }\n\n  virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {\n    // If either matcher1_ or matcher2_ matches x, we just need to\n    // explain why *one* of them matches.\n    StringMatchResultListener listener1;\n    if (matcher1_.MatchAndExplain(x, &listener1)) {\n      *listener << listener1.str();\n      return true;\n    }\n\n    StringMatchResultListener listener2;\n    if (matcher2_.MatchAndExplain(x, &listener2)) {\n      *listener << listener2.str();\n      return true;\n    }\n\n    // Otherwise we need to explain why *both* of them fail.\n    const internal::string s1 = listener1.str();\n    const internal::string s2 = listener2.str();\n\n    if (s1 == \"\") {\n      *listener << s2;\n    } else {\n      *listener << s1;\n      if (s2 != \"\") {\n        *listener << \", and \" << s2;\n      }\n    }\n    return false;\n  }\n\n private:\n  const Matcher<T> matcher1_;\n  const Matcher<T> matcher2_;\n\n  GTEST_DISALLOW_ASSIGN_(EitherOfMatcherImpl);\n};\n\n#if GTEST_LANG_CXX11\n// AnyOfMatcher is used for the variadic implementation of AnyOf(m_1, m_2, ...).\ntemplate <typename... Args>\nusing AnyOfMatcher = VariadicMatcher<EitherOfMatcherImpl, Args...>;\n\n#endif  // GTEST_LANG_CXX11\n\n// Used for implementing the AnyOf(m_1, ..., m_n) matcher, which\n// matches a value that matches at least one of the matchers m_1, ...,\n// and m_n.\ntemplate <typename Matcher1, typename Matcher2>\nclass EitherOfMatcher {\n public:\n  EitherOfMatcher(Matcher1 matcher1, Matcher2 matcher2)\n      : matcher1_(matcher1), matcher2_(matcher2) {}\n\n  // This template type conversion operator allows a\n  // EitherOfMatcher<Matcher1, Matcher2> object to match any type that\n  // both Matcher1 and Matcher2 can match.\n  template <typename T>\n  operator Matcher<T>() const {\n    return Matcher<T>(new EitherOfMatcherImpl<T>(\n        SafeMatcherCast<T>(matcher1_), SafeMatcherCast<T>(matcher2_)));\n  }\n\n private:\n  Matcher1 matcher1_;\n  Matcher2 matcher2_;\n\n  GTEST_DISALLOW_ASSIGN_(EitherOfMatcher);\n};\n\n// Used for implementing Truly(pred), which turns a predicate into a\n// matcher.\ntemplate <typename Predicate>\nclass TrulyMatcher {\n public:\n  explicit TrulyMatcher(Predicate pred) : predicate_(pred) {}\n\n  // This method template allows Truly(pred) to be used as a matcher\n  // for type T where T is the argument type of predicate 'pred'.  The\n  // argument is passed by reference as the predicate may be\n  // interested in the address of the argument.\n  template <typename T>\n  bool MatchAndExplain(T& x,  // NOLINT\n                       MatchResultListener* /* listener */) const {\n    // Without the if-statement, MSVC sometimes warns about converting\n    // a value to bool (warning 4800).\n    //\n    // We cannot write 'return !!predicate_(x);' as that doesn't work\n    // when predicate_(x) returns a class convertible to bool but\n    // having no operator!().\n    if (predicate_(x))\n      return true;\n    return false;\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"satisfies the given predicate\";\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"doesn't satisfy the given predicate\";\n  }\n\n private:\n  Predicate predicate_;\n\n  GTEST_DISALLOW_ASSIGN_(TrulyMatcher);\n};\n\n// Used for implementing Matches(matcher), which turns a matcher into\n// a predicate.\ntemplate <typename M>\nclass MatcherAsPredicate {\n public:\n  explicit MatcherAsPredicate(M matcher) : matcher_(matcher) {}\n\n  // This template operator() allows Matches(m) to be used as a\n  // predicate on type T where m is a matcher on type T.\n  //\n  // The argument x is passed by reference instead of by value, as\n  // some matcher may be interested in its address (e.g. as in\n  // Matches(Ref(n))(x)).\n  template <typename T>\n  bool operator()(const T& x) const {\n    // We let matcher_ commit to a particular type here instead of\n    // when the MatcherAsPredicate object was constructed.  This\n    // allows us to write Matches(m) where m is a polymorphic matcher\n    // (e.g. Eq(5)).\n    //\n    // If we write Matcher<T>(matcher_).Matches(x) here, it won't\n    // compile when matcher_ has type Matcher<const T&>; if we write\n    // Matcher<const T&>(matcher_).Matches(x) here, it won't compile\n    // when matcher_ has type Matcher<T>; if we just write\n    // matcher_.Matches(x), it won't compile when matcher_ is\n    // polymorphic, e.g. Eq(5).\n    //\n    // MatcherCast<const T&>() is necessary for making the code work\n    // in all of the above situations.\n    return MatcherCast<const T&>(matcher_).Matches(x);\n  }\n\n private:\n  M matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(MatcherAsPredicate);\n};\n\n// For implementing ASSERT_THAT() and EXPECT_THAT().  The template\n// argument M must be a type that can be converted to a matcher.\ntemplate <typename M>\nclass PredicateFormatterFromMatcher {\n public:\n  explicit PredicateFormatterFromMatcher(M m) : matcher_(internal::move(m)) {}\n\n  // This template () operator allows a PredicateFormatterFromMatcher\n  // object to act as a predicate-formatter suitable for using with\n  // Google Test's EXPECT_PRED_FORMAT1() macro.\n  template <typename T>\n  AssertionResult operator()(const char* value_text, const T& x) const {\n    // We convert matcher_ to a Matcher<const T&> *now* instead of\n    // when the PredicateFormatterFromMatcher object was constructed,\n    // as matcher_ may be polymorphic (e.g. NotNull()) and we won't\n    // know which type to instantiate it to until we actually see the\n    // type of x here.\n    //\n    // We write SafeMatcherCast<const T&>(matcher_) instead of\n    // Matcher<const T&>(matcher_), as the latter won't compile when\n    // matcher_ has type Matcher<T> (e.g. An<int>()).\n    // We don't write MatcherCast<const T&> either, as that allows\n    // potentially unsafe downcasting of the matcher argument.\n    const Matcher<const T&> matcher = SafeMatcherCast<const T&>(matcher_);\n    StringMatchResultListener listener;\n    if (MatchPrintAndExplain(x, matcher, &listener))\n      return AssertionSuccess();\n\n    ::std::stringstream ss;\n    ss << \"Value of: \" << value_text << \"\\n\"\n       << \"Expected: \";\n    matcher.DescribeTo(&ss);\n    ss << \"\\n  Actual: \" << listener.str();\n    return AssertionFailure() << ss.str();\n  }\n\n private:\n  const M matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(PredicateFormatterFromMatcher);\n};\n\n// A helper function for converting a matcher to a predicate-formatter\n// without the user needing to explicitly write the type.  This is\n// used for implementing ASSERT_THAT() and EXPECT_THAT().\n// Implementation detail: 'matcher' is received by-value to force decaying.\ntemplate <typename M>\ninline PredicateFormatterFromMatcher<M>\nMakePredicateFormatterFromMatcher(M matcher) {\n  return PredicateFormatterFromMatcher<M>(internal::move(matcher));\n}\n\n// Implements the polymorphic floating point equality matcher, which matches\n// two float values using ULP-based approximation or, optionally, a\n// user-specified epsilon.  The template is meant to be instantiated with\n// FloatType being either float or double.\ntemplate <typename FloatType>\nclass FloatingEqMatcher {\n public:\n  // Constructor for FloatingEqMatcher.\n  // The matcher's input will be compared with expected.  The matcher treats two\n  // NANs as equal if nan_eq_nan is true.  Otherwise, under IEEE standards,\n  // equality comparisons between NANs will always return false.  We specify a\n  // negative max_abs_error_ term to indicate that ULP-based approximation will\n  // be used for comparison.\n  FloatingEqMatcher(FloatType expected, bool nan_eq_nan) :\n    expected_(expected), nan_eq_nan_(nan_eq_nan), max_abs_error_(-1) {\n  }\n\n  // Constructor that supports a user-specified max_abs_error that will be used\n  // for comparison instead of ULP-based approximation.  The max absolute\n  // should be non-negative.\n  FloatingEqMatcher(FloatType expected, bool nan_eq_nan,\n                    FloatType max_abs_error)\n      : expected_(expected),\n        nan_eq_nan_(nan_eq_nan),\n        max_abs_error_(max_abs_error) {\n    GTEST_CHECK_(max_abs_error >= 0)\n        << \", where max_abs_error is\" << max_abs_error;\n  }\n\n  // Implements floating point equality matcher as a Matcher<T>.\n  template <typename T>\n  class Impl : public MatcherInterface<T> {\n   public:\n    Impl(FloatType expected, bool nan_eq_nan, FloatType max_abs_error)\n        : expected_(expected),\n          nan_eq_nan_(nan_eq_nan),\n          max_abs_error_(max_abs_error) {}\n\n    virtual bool MatchAndExplain(T value,\n                                 MatchResultListener* listener) const {\n      const FloatingPoint<FloatType> actual(value), expected(expected_);\n\n      // Compares NaNs first, if nan_eq_nan_ is true.\n      if (actual.is_nan() || expected.is_nan()) {\n        if (actual.is_nan() && expected.is_nan()) {\n          return nan_eq_nan_;\n        }\n        // One is nan; the other is not nan.\n        return false;\n      }\n      if (HasMaxAbsError()) {\n        // We perform an equality check so that inf will match inf, regardless\n        // of error bounds.  If the result of value - expected_ would result in\n        // overflow or if either value is inf, the default result is infinity,\n        // which should only match if max_abs_error_ is also infinity.\n        if (value == expected_) {\n          return true;\n        }\n\n        const FloatType diff = value - expected_;\n        if (fabs(diff) <= max_abs_error_) {\n          return true;\n        }\n\n        if (listener->IsInterested()) {\n          *listener << \"which is \" << diff << \" from \" << expected_;\n        }\n        return false;\n      } else {\n        return actual.AlmostEquals(expected);\n      }\n    }\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      // os->precision() returns the previously set precision, which we\n      // store to restore the ostream to its original configuration\n      // after outputting.\n      const ::std::streamsize old_precision = os->precision(\n          ::std::numeric_limits<FloatType>::digits10 + 2);\n      if (FloatingPoint<FloatType>(expected_).is_nan()) {\n        if (nan_eq_nan_) {\n          *os << \"is NaN\";\n        } else {\n          *os << \"never matches\";\n        }\n      } else {\n        *os << \"is approximately \" << expected_;\n        if (HasMaxAbsError()) {\n          *os << \" (absolute error <= \" << max_abs_error_ << \")\";\n        }\n      }\n      os->precision(old_precision);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      // As before, get original precision.\n      const ::std::streamsize old_precision = os->precision(\n          ::std::numeric_limits<FloatType>::digits10 + 2);\n      if (FloatingPoint<FloatType>(expected_).is_nan()) {\n        if (nan_eq_nan_) {\n          *os << \"isn't NaN\";\n        } else {\n          *os << \"is anything\";\n        }\n      } else {\n        *os << \"isn't approximately \" << expected_;\n        if (HasMaxAbsError()) {\n          *os << \" (absolute error > \" << max_abs_error_ << \")\";\n        }\n      }\n      // Restore original precision.\n      os->precision(old_precision);\n    }\n\n   private:\n    bool HasMaxAbsError() const {\n      return max_abs_error_ >= 0;\n    }\n\n    const FloatType expected_;\n    const bool nan_eq_nan_;\n    // max_abs_error will be used for value comparison when >= 0.\n    const FloatType max_abs_error_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  // The following 3 type conversion operators allow FloatEq(expected) and\n  // NanSensitiveFloatEq(expected) to be used as a Matcher<float>, a\n  // Matcher<const float&>, or a Matcher<float&>, but nothing else.\n  // (While Google's C++ coding style doesn't allow arguments passed\n  // by non-const reference, we may see them in code not conforming to\n  // the style.  Therefore Google Mock needs to support them.)\n  operator Matcher<FloatType>() const {\n    return MakeMatcher(\n        new Impl<FloatType>(expected_, nan_eq_nan_, max_abs_error_));\n  }\n\n  operator Matcher<const FloatType&>() const {\n    return MakeMatcher(\n        new Impl<const FloatType&>(expected_, nan_eq_nan_, max_abs_error_));\n  }\n\n  operator Matcher<FloatType&>() const {\n    return MakeMatcher(\n        new Impl<FloatType&>(expected_, nan_eq_nan_, max_abs_error_));\n  }\n\n private:\n  const FloatType expected_;\n  const bool nan_eq_nan_;\n  // max_abs_error will be used for value comparison when >= 0.\n  const FloatType max_abs_error_;\n\n  GTEST_DISALLOW_ASSIGN_(FloatingEqMatcher);\n};\n\n// Implements the Pointee(m) matcher for matching a pointer whose\n// pointee matches matcher m.  The pointer can be either raw or smart.\ntemplate <typename InnerMatcher>\nclass PointeeMatcher {\n public:\n  explicit PointeeMatcher(const InnerMatcher& matcher) : matcher_(matcher) {}\n\n  // This type conversion operator template allows Pointee(m) to be\n  // used as a matcher for any pointer type whose pointee type is\n  // compatible with the inner matcher, where type Pointer can be\n  // either a raw pointer or a smart pointer.\n  //\n  // The reason we do this instead of relying on\n  // MakePolymorphicMatcher() is that the latter is not flexible\n  // enough for implementing the DescribeTo() method of Pointee().\n  template <typename Pointer>\n  operator Matcher<Pointer>() const {\n    return MakeMatcher(new Impl<Pointer>(matcher_));\n  }\n\n private:\n  // The monomorphic implementation that works for a particular pointer type.\n  template <typename Pointer>\n  class Impl : public MatcherInterface<Pointer> {\n   public:\n    typedef typename PointeeOf<GTEST_REMOVE_CONST_(  // NOLINT\n        GTEST_REMOVE_REFERENCE_(Pointer))>::type Pointee;\n\n    explicit Impl(const InnerMatcher& matcher)\n        : matcher_(MatcherCast<const Pointee&>(matcher)) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"points to a value that \";\n      matcher_.DescribeTo(os);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"does not point to a value that \";\n      matcher_.DescribeTo(os);\n    }\n\n    virtual bool MatchAndExplain(Pointer pointer,\n                                 MatchResultListener* listener) const {\n      if (GetRawPointer(pointer) == NULL)\n        return false;\n\n      *listener << \"which points to \";\n      return MatchPrintAndExplain(*pointer, matcher_, listener);\n    }\n\n   private:\n    const Matcher<const Pointee&> matcher_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  const InnerMatcher matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(PointeeMatcher);\n};\n\n// Implements the WhenDynamicCastTo<T>(m) matcher that matches a pointer or\n// reference that matches inner_matcher when dynamic_cast<T> is applied.\n// The result of dynamic_cast<To> is forwarded to the inner matcher.\n// If To is a pointer and the cast fails, the inner matcher will receive NULL.\n// If To is a reference and the cast fails, this matcher returns false\n// immediately.\ntemplate <typename To>\nclass WhenDynamicCastToMatcherBase {\n public:\n  explicit WhenDynamicCastToMatcherBase(const Matcher<To>& matcher)\n      : matcher_(matcher) {}\n\n  void DescribeTo(::std::ostream* os) const {\n    GetCastTypeDescription(os);\n    matcher_.DescribeTo(os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    GetCastTypeDescription(os);\n    matcher_.DescribeNegationTo(os);\n  }\n\n protected:\n  const Matcher<To> matcher_;\n\n  static string GetToName() {\n#if GTEST_HAS_RTTI\n    return GetTypeName<To>();\n#else  // GTEST_HAS_RTTI\n    return \"the target type\";\n#endif  // GTEST_HAS_RTTI\n  }\n\n private:\n  static void GetCastTypeDescription(::std::ostream* os) {\n    *os << \"when dynamic_cast to \" << GetToName() << \", \";\n  }\n\n  GTEST_DISALLOW_ASSIGN_(WhenDynamicCastToMatcherBase);\n};\n\n// Primary template.\n// To is a pointer. Cast and forward the result.\ntemplate <typename To>\nclass WhenDynamicCastToMatcher : public WhenDynamicCastToMatcherBase<To> {\n public:\n  explicit WhenDynamicCastToMatcher(const Matcher<To>& matcher)\n      : WhenDynamicCastToMatcherBase<To>(matcher) {}\n\n  template <typename From>\n  bool MatchAndExplain(From from, MatchResultListener* listener) const {\n    // TODO(sbenza): Add more detail on failures. ie did the dyn_cast fail?\n    To to = dynamic_cast<To>(from);\n    return MatchPrintAndExplain(to, this->matcher_, listener);\n  }\n};\n\n// Specialize for references.\n// In this case we return false if the dynamic_cast fails.\ntemplate <typename To>\nclass WhenDynamicCastToMatcher<To&> : public WhenDynamicCastToMatcherBase<To&> {\n public:\n  explicit WhenDynamicCastToMatcher(const Matcher<To&>& matcher)\n      : WhenDynamicCastToMatcherBase<To&>(matcher) {}\n\n  template <typename From>\n  bool MatchAndExplain(From& from, MatchResultListener* listener) const {\n    // We don't want an std::bad_cast here, so do the cast with pointers.\n    To* to = dynamic_cast<To*>(&from);\n    if (to == NULL) {\n      *listener << \"which cannot be dynamic_cast to \" << this->GetToName();\n      return false;\n    }\n    return MatchPrintAndExplain(*to, this->matcher_, listener);\n  }\n};\n\n// Implements the Field() matcher for matching a field (i.e. member\n// variable) of an object.\ntemplate <typename Class, typename FieldType>\nclass FieldMatcher {\n public:\n  FieldMatcher(FieldType Class::*field,\n               const Matcher<const FieldType&>& matcher)\n      : field_(field), matcher_(matcher) {}\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"is an object whose given field \";\n    matcher_.DescribeTo(os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"is an object whose given field \";\n    matcher_.DescribeNegationTo(os);\n  }\n\n  template <typename T>\n  bool MatchAndExplain(const T& value, MatchResultListener* listener) const {\n    return MatchAndExplainImpl(\n        typename ::testing::internal::\n            is_pointer<GTEST_REMOVE_CONST_(T)>::type(),\n        value, listener);\n  }\n\n private:\n  // The first argument of MatchAndExplainImpl() is needed to help\n  // Symbian's C++ compiler choose which overload to use.  Its type is\n  // true_type iff the Field() matcher is used to match a pointer.\n  bool MatchAndExplainImpl(false_type /* is_not_pointer */, const Class& obj,\n                           MatchResultListener* listener) const {\n    *listener << \"whose given field is \";\n    return MatchPrintAndExplain(obj.*field_, matcher_, listener);\n  }\n\n  bool MatchAndExplainImpl(true_type /* is_pointer */, const Class* p,\n                           MatchResultListener* listener) const {\n    if (p == NULL)\n      return false;\n\n    *listener << \"which points to an object \";\n    // Since *p has a field, it must be a class/struct/union type and\n    // thus cannot be a pointer.  Therefore we pass false_type() as\n    // the first argument.\n    return MatchAndExplainImpl(false_type(), *p, listener);\n  }\n\n  const FieldType Class::*field_;\n  const Matcher<const FieldType&> matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(FieldMatcher);\n};\n\n// Implements the Property() matcher for matching a property\n// (i.e. return value of a getter method) of an object.\ntemplate <typename Class, typename PropertyType>\nclass PropertyMatcher {\n public:\n  // The property may have a reference type, so 'const PropertyType&'\n  // may cause double references and fail to compile.  That's why we\n  // need GTEST_REFERENCE_TO_CONST, which works regardless of\n  // PropertyType being a reference or not.\n  typedef GTEST_REFERENCE_TO_CONST_(PropertyType) RefToConstProperty;\n\n  PropertyMatcher(PropertyType (Class::*property)() const,\n                  const Matcher<RefToConstProperty>& matcher)\n      : property_(property), matcher_(matcher) {}\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"is an object whose given property \";\n    matcher_.DescribeTo(os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"is an object whose given property \";\n    matcher_.DescribeNegationTo(os);\n  }\n\n  template <typename T>\n  bool MatchAndExplain(const T&value, MatchResultListener* listener) const {\n    return MatchAndExplainImpl(\n        typename ::testing::internal::\n            is_pointer<GTEST_REMOVE_CONST_(T)>::type(),\n        value, listener);\n  }\n\n private:\n  // The first argument of MatchAndExplainImpl() is needed to help\n  // Symbian's C++ compiler choose which overload to use.  Its type is\n  // true_type iff the Property() matcher is used to match a pointer.\n  bool MatchAndExplainImpl(false_type /* is_not_pointer */, const Class& obj,\n                           MatchResultListener* listener) const {\n    *listener << \"whose given property is \";\n    // Cannot pass the return value (for example, int) to MatchPrintAndExplain,\n    // which takes a non-const reference as argument.\n#if defined(_PREFAST_ ) && _MSC_VER == 1800\n    // Workaround bug in VC++ 2013's /analyze parser.\n    // https://connect.microsoft.com/VisualStudio/feedback/details/1106363/internal-compiler-error-with-analyze-due-to-failure-to-infer-move\n    posix::Abort();  // To make sure it is never run.\n    return false;\n#else\n    RefToConstProperty result = (obj.*property_)();\n    return MatchPrintAndExplain(result, matcher_, listener);\n#endif\n  }\n\n  bool MatchAndExplainImpl(true_type /* is_pointer */, const Class* p,\n                           MatchResultListener* listener) const {\n    if (p == NULL)\n      return false;\n\n    *listener << \"which points to an object \";\n    // Since *p has a property method, it must be a class/struct/union\n    // type and thus cannot be a pointer.  Therefore we pass\n    // false_type() as the first argument.\n    return MatchAndExplainImpl(false_type(), *p, listener);\n  }\n\n  PropertyType (Class::*property_)() const;\n  const Matcher<RefToConstProperty> matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(PropertyMatcher);\n};\n\n// Type traits specifying various features of different functors for ResultOf.\n// The default template specifies features for functor objects.\n// Functor classes have to typedef argument_type and result_type\n// to be compatible with ResultOf.\ntemplate <typename Functor>\nstruct CallableTraits {\n  typedef typename Functor::result_type ResultType;\n  typedef Functor StorageType;\n\n  static void CheckIsValid(Functor /* functor */) {}\n  template <typename T>\n  static ResultType Invoke(Functor f, T arg) { return f(arg); }\n};\n\n// Specialization for function pointers.\ntemplate <typename ArgType, typename ResType>\nstruct CallableTraits<ResType(*)(ArgType)> {\n  typedef ResType ResultType;\n  typedef ResType(*StorageType)(ArgType);\n\n  static void CheckIsValid(ResType(*f)(ArgType)) {\n    GTEST_CHECK_(f != NULL)\n        << \"NULL function pointer is passed into ResultOf().\";\n  }\n  template <typename T>\n  static ResType Invoke(ResType(*f)(ArgType), T arg) {\n    return (*f)(arg);\n  }\n};\n\n// Implements the ResultOf() matcher for matching a return value of a\n// unary function of an object.\ntemplate <typename Callable>\nclass ResultOfMatcher {\n public:\n  typedef typename CallableTraits<Callable>::ResultType ResultType;\n\n  ResultOfMatcher(Callable callable, const Matcher<ResultType>& matcher)\n      : callable_(callable), matcher_(matcher) {\n    CallableTraits<Callable>::CheckIsValid(callable_);\n  }\n\n  template <typename T>\n  operator Matcher<T>() const {\n    return Matcher<T>(new Impl<T>(callable_, matcher_));\n  }\n\n private:\n  typedef typename CallableTraits<Callable>::StorageType CallableStorageType;\n\n  template <typename T>\n  class Impl : public MatcherInterface<T> {\n   public:\n    Impl(CallableStorageType callable, const Matcher<ResultType>& matcher)\n        : callable_(callable), matcher_(matcher) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"is mapped by the given callable to a value that \";\n      matcher_.DescribeTo(os);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"is mapped by the given callable to a value that \";\n      matcher_.DescribeNegationTo(os);\n    }\n\n    virtual bool MatchAndExplain(T obj, MatchResultListener* listener) const {\n      *listener << \"which is mapped by the given callable to \";\n      // Cannot pass the return value (for example, int) to\n      // MatchPrintAndExplain, which takes a non-const reference as argument.\n      ResultType result =\n          CallableTraits<Callable>::template Invoke<T>(callable_, obj);\n      return MatchPrintAndExplain(result, matcher_, listener);\n    }\n\n   private:\n    // Functors often define operator() as non-const method even though\n    // they are actualy stateless. But we need to use them even when\n    // 'this' is a const pointer. It's the user's responsibility not to\n    // use stateful callables with ResultOf(), which does't guarantee\n    // how many times the callable will be invoked.\n    mutable CallableStorageType callable_;\n    const Matcher<ResultType> matcher_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };  // class Impl\n\n  const CallableStorageType callable_;\n  const Matcher<ResultType> matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(ResultOfMatcher);\n};\n\n// Implements a matcher that checks the size of an STL-style container.\ntemplate <typename SizeMatcher>\nclass SizeIsMatcher {\n public:\n  explicit SizeIsMatcher(const SizeMatcher& size_matcher)\n       : size_matcher_(size_matcher) {\n  }\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    return MakeMatcher(new Impl<Container>(size_matcher_));\n  }\n\n  template <typename Container>\n  class Impl : public MatcherInterface<Container> {\n   public:\n    typedef internal::StlContainerView<\n         GTEST_REMOVE_REFERENCE_AND_CONST_(Container)> ContainerView;\n    typedef typename ContainerView::type::size_type SizeType;\n    explicit Impl(const SizeMatcher& size_matcher)\n        : size_matcher_(MatcherCast<SizeType>(size_matcher)) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"size \";\n      size_matcher_.DescribeTo(os);\n    }\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"size \";\n      size_matcher_.DescribeNegationTo(os);\n    }\n\n    virtual bool MatchAndExplain(Container container,\n                                 MatchResultListener* listener) const {\n      SizeType size = container.size();\n      StringMatchResultListener size_listener;\n      const bool result = size_matcher_.MatchAndExplain(size, &size_listener);\n      *listener\n          << \"whose size \" << size << (result ? \" matches\" : \" doesn't match\");\n      PrintIfNotEmpty(size_listener.str(), listener->stream());\n      return result;\n    }\n\n   private:\n    const Matcher<SizeType> size_matcher_;\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n private:\n  const SizeMatcher size_matcher_;\n  GTEST_DISALLOW_ASSIGN_(SizeIsMatcher);\n};\n\n// Implements a matcher that checks the begin()..end() distance of an STL-style\n// container.\ntemplate <typename DistanceMatcher>\nclass BeginEndDistanceIsMatcher {\n public:\n  explicit BeginEndDistanceIsMatcher(const DistanceMatcher& distance_matcher)\n      : distance_matcher_(distance_matcher) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    return MakeMatcher(new Impl<Container>(distance_matcher_));\n  }\n\n  template <typename Container>\n  class Impl : public MatcherInterface<Container> {\n   public:\n    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n    typedef internal::StlContainerView<RawContainer> View;\n    typedef typename View::type StlContainer;\n    typedef typename View::const_reference StlContainerReference;\n    typedef decltype(std::begin(\n        std::declval<StlContainerReference>())) StlContainerConstIterator;\n    typedef typename std::iterator_traits<\n        StlContainerConstIterator>::difference_type DistanceType;\n    explicit Impl(const DistanceMatcher& distance_matcher)\n        : distance_matcher_(MatcherCast<DistanceType>(distance_matcher)) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"distance between begin() and end() \";\n      distance_matcher_.DescribeTo(os);\n    }\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"distance between begin() and end() \";\n      distance_matcher_.DescribeNegationTo(os);\n    }\n\n    virtual bool MatchAndExplain(Container container,\n                                 MatchResultListener* listener) const {\n#if GTEST_HAS_STD_BEGIN_AND_END_\n      using std::begin;\n      using std::end;\n      DistanceType distance = std::distance(begin(container), end(container));\n#else\n      DistanceType distance = std::distance(container.begin(), container.end());\n#endif\n      StringMatchResultListener distance_listener;\n      const bool result =\n          distance_matcher_.MatchAndExplain(distance, &distance_listener);\n      *listener << \"whose distance between begin() and end() \" << distance\n                << (result ? \" matches\" : \" doesn't match\");\n      PrintIfNotEmpty(distance_listener.str(), listener->stream());\n      return result;\n    }\n\n   private:\n    const Matcher<DistanceType> distance_matcher_;\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n private:\n  const DistanceMatcher distance_matcher_;\n  GTEST_DISALLOW_ASSIGN_(BeginEndDistanceIsMatcher);\n};\n\n// Implements an equality matcher for any STL-style container whose elements\n// support ==. This matcher is like Eq(), but its failure explanations provide\n// more detailed information that is useful when the container is used as a set.\n// The failure message reports elements that are in one of the operands but not\n// the other. The failure messages do not report duplicate or out-of-order\n// elements in the containers (which don't properly matter to sets, but can\n// occur if the containers are vectors or lists, for example).\n//\n// Uses the container's const_iterator, value_type, operator ==,\n// begin(), and end().\ntemplate <typename Container>\nclass ContainerEqMatcher {\n public:\n  typedef internal::StlContainerView<Container> View;\n  typedef typename View::type StlContainer;\n  typedef typename View::const_reference StlContainerReference;\n\n  // We make a copy of expected in case the elements in it are modified\n  // after this matcher is created.\n  explicit ContainerEqMatcher(const Container& expected)\n      : expected_(View::Copy(expected)) {\n    // Makes sure the user doesn't instantiate this class template\n    // with a const or reference type.\n    (void)testing::StaticAssertTypeEq<Container,\n        GTEST_REMOVE_REFERENCE_AND_CONST_(Container)>();\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"equals \";\n    UniversalPrint(expected_, os);\n  }\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"does not equal \";\n    UniversalPrint(expected_, os);\n  }\n\n  template <typename LhsContainer>\n  bool MatchAndExplain(const LhsContainer& lhs,\n                       MatchResultListener* listener) const {\n    // GTEST_REMOVE_CONST_() is needed to work around an MSVC 8.0 bug\n    // that causes LhsContainer to be a const type sometimes.\n    typedef internal::StlContainerView<GTEST_REMOVE_CONST_(LhsContainer)>\n        LhsView;\n    typedef typename LhsView::type LhsStlContainer;\n    StlContainerReference lhs_stl_container = LhsView::ConstReference(lhs);\n    if (lhs_stl_container == expected_)\n      return true;\n\n    ::std::ostream* const os = listener->stream();\n    if (os != NULL) {\n      // Something is different. Check for extra values first.\n      bool printed_header = false;\n      for (typename LhsStlContainer::const_iterator it =\n               lhs_stl_container.begin();\n           it != lhs_stl_container.end(); ++it) {\n        if (internal::ArrayAwareFind(expected_.begin(), expected_.end(), *it) ==\n            expected_.end()) {\n          if (printed_header) {\n            *os << \", \";\n          } else {\n            *os << \"which has these unexpected elements: \";\n            printed_header = true;\n          }\n          UniversalPrint(*it, os);\n        }\n      }\n\n      // Now check for missing values.\n      bool printed_header2 = false;\n      for (typename StlContainer::const_iterator it = expected_.begin();\n           it != expected_.end(); ++it) {\n        if (internal::ArrayAwareFind(\n                lhs_stl_container.begin(), lhs_stl_container.end(), *it) ==\n            lhs_stl_container.end()) {\n          if (printed_header2) {\n            *os << \", \";\n          } else {\n            *os << (printed_header ? \",\\nand\" : \"which\")\n                << \" doesn't have these expected elements: \";\n            printed_header2 = true;\n          }\n          UniversalPrint(*it, os);\n        }\n      }\n    }\n\n    return false;\n  }\n\n private:\n  const StlContainer expected_;\n\n  GTEST_DISALLOW_ASSIGN_(ContainerEqMatcher);\n};\n\n// A comparator functor that uses the < operator to compare two values.\nstruct LessComparator {\n  template <typename T, typename U>\n  bool operator()(const T& lhs, const U& rhs) const { return lhs < rhs; }\n};\n\n// Implements WhenSortedBy(comparator, container_matcher).\ntemplate <typename Comparator, typename ContainerMatcher>\nclass WhenSortedByMatcher {\n public:\n  WhenSortedByMatcher(const Comparator& comparator,\n                      const ContainerMatcher& matcher)\n      : comparator_(comparator), matcher_(matcher) {}\n\n  template <typename LhsContainer>\n  operator Matcher<LhsContainer>() const {\n    return MakeMatcher(new Impl<LhsContainer>(comparator_, matcher_));\n  }\n\n  template <typename LhsContainer>\n  class Impl : public MatcherInterface<LhsContainer> {\n   public:\n    typedef internal::StlContainerView<\n         GTEST_REMOVE_REFERENCE_AND_CONST_(LhsContainer)> LhsView;\n    typedef typename LhsView::type LhsStlContainer;\n    typedef typename LhsView::const_reference LhsStlContainerReference;\n    // Transforms std::pair<const Key, Value> into std::pair<Key, Value>\n    // so that we can match associative containers.\n    typedef typename RemoveConstFromKey<\n        typename LhsStlContainer::value_type>::type LhsValue;\n\n    Impl(const Comparator& comparator, const ContainerMatcher& matcher)\n        : comparator_(comparator), matcher_(matcher) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"(when sorted) \";\n      matcher_.DescribeTo(os);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"(when sorted) \";\n      matcher_.DescribeNegationTo(os);\n    }\n\n    virtual bool MatchAndExplain(LhsContainer lhs,\n                                 MatchResultListener* listener) const {\n      LhsStlContainerReference lhs_stl_container = LhsView::ConstReference(lhs);\n      ::std::vector<LhsValue> sorted_container(lhs_stl_container.begin(),\n                                               lhs_stl_container.end());\n      ::std::sort(\n           sorted_container.begin(), sorted_container.end(), comparator_);\n\n      if (!listener->IsInterested()) {\n        // If the listener is not interested, we do not need to\n        // construct the inner explanation.\n        return matcher_.Matches(sorted_container);\n      }\n\n      *listener << \"which is \";\n      UniversalPrint(sorted_container, listener->stream());\n      *listener << \" when sorted\";\n\n      StringMatchResultListener inner_listener;\n      const bool match = matcher_.MatchAndExplain(sorted_container,\n                                                  &inner_listener);\n      PrintIfNotEmpty(inner_listener.str(), listener->stream());\n      return match;\n    }\n\n   private:\n    const Comparator comparator_;\n    const Matcher<const ::std::vector<LhsValue>&> matcher_;\n\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(Impl);\n  };\n\n private:\n  const Comparator comparator_;\n  const ContainerMatcher matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(WhenSortedByMatcher);\n};\n\n// Implements Pointwise(tuple_matcher, rhs_container).  tuple_matcher\n// must be able to be safely cast to Matcher<tuple<const T1&, const\n// T2&> >, where T1 and T2 are the types of elements in the LHS\n// container and the RHS container respectively.\ntemplate <typename TupleMatcher, typename RhsContainer>\nclass PointwiseMatcher {\n public:\n  typedef internal::StlContainerView<RhsContainer> RhsView;\n  typedef typename RhsView::type RhsStlContainer;\n  typedef typename RhsStlContainer::value_type RhsValue;\n\n  // Like ContainerEq, we make a copy of rhs in case the elements in\n  // it are modified after this matcher is created.\n  PointwiseMatcher(const TupleMatcher& tuple_matcher, const RhsContainer& rhs)\n      : tuple_matcher_(tuple_matcher), rhs_(RhsView::Copy(rhs)) {\n    // Makes sure the user doesn't instantiate this class template\n    // with a const or reference type.\n    (void)testing::StaticAssertTypeEq<RhsContainer,\n        GTEST_REMOVE_REFERENCE_AND_CONST_(RhsContainer)>();\n  }\n\n  template <typename LhsContainer>\n  operator Matcher<LhsContainer>() const {\n    return MakeMatcher(new Impl<LhsContainer>(tuple_matcher_, rhs_));\n  }\n\n  template <typename LhsContainer>\n  class Impl : public MatcherInterface<LhsContainer> {\n   public:\n    typedef internal::StlContainerView<\n         GTEST_REMOVE_REFERENCE_AND_CONST_(LhsContainer)> LhsView;\n    typedef typename LhsView::type LhsStlContainer;\n    typedef typename LhsView::const_reference LhsStlContainerReference;\n    typedef typename LhsStlContainer::value_type LhsValue;\n    // We pass the LHS value and the RHS value to the inner matcher by\n    // reference, as they may be expensive to copy.  We must use tuple\n    // instead of pair here, as a pair cannot hold references (C++ 98,\n    // 20.2.2 [lib.pairs]).\n    typedef ::testing::tuple<const LhsValue&, const RhsValue&> InnerMatcherArg;\n\n    Impl(const TupleMatcher& tuple_matcher, const RhsStlContainer& rhs)\n        // mono_tuple_matcher_ holds a monomorphic version of the tuple matcher.\n        : mono_tuple_matcher_(SafeMatcherCast<InnerMatcherArg>(tuple_matcher)),\n          rhs_(rhs) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"contains \" << rhs_.size()\n          << \" values, where each value and its corresponding value in \";\n      UniversalPrinter<RhsStlContainer>::Print(rhs_, os);\n      *os << \" \";\n      mono_tuple_matcher_.DescribeTo(os);\n    }\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"doesn't contain exactly \" << rhs_.size()\n          << \" values, or contains a value x at some index i\"\n          << \" where x and the i-th value of \";\n      UniversalPrint(rhs_, os);\n      *os << \" \";\n      mono_tuple_matcher_.DescribeNegationTo(os);\n    }\n\n    virtual bool MatchAndExplain(LhsContainer lhs,\n                                 MatchResultListener* listener) const {\n      LhsStlContainerReference lhs_stl_container = LhsView::ConstReference(lhs);\n      const size_t actual_size = lhs_stl_container.size();\n      if (actual_size != rhs_.size()) {\n        *listener << \"which contains \" << actual_size << \" values\";\n        return false;\n      }\n\n      typename LhsStlContainer::const_iterator left = lhs_stl_container.begin();\n      typename RhsStlContainer::const_iterator right = rhs_.begin();\n      for (size_t i = 0; i != actual_size; ++i, ++left, ++right) {\n        const InnerMatcherArg value_pair(*left, *right);\n\n        if (listener->IsInterested()) {\n          StringMatchResultListener inner_listener;\n          if (!mono_tuple_matcher_.MatchAndExplain(\n                  value_pair, &inner_listener)) {\n            *listener << \"where the value pair (\";\n            UniversalPrint(*left, listener->stream());\n            *listener << \", \";\n            UniversalPrint(*right, listener->stream());\n            *listener << \") at index #\" << i << \" don't match\";\n            PrintIfNotEmpty(inner_listener.str(), listener->stream());\n            return false;\n          }\n        } else {\n          if (!mono_tuple_matcher_.Matches(value_pair))\n            return false;\n        }\n      }\n\n      return true;\n    }\n\n   private:\n    const Matcher<InnerMatcherArg> mono_tuple_matcher_;\n    const RhsStlContainer rhs_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n private:\n  const TupleMatcher tuple_matcher_;\n  const RhsStlContainer rhs_;\n\n  GTEST_DISALLOW_ASSIGN_(PointwiseMatcher);\n};\n\n// Holds the logic common to ContainsMatcherImpl and EachMatcherImpl.\ntemplate <typename Container>\nclass QuantifierMatcherImpl : public MatcherInterface<Container> {\n public:\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n  typedef StlContainerView<RawContainer> View;\n  typedef typename View::type StlContainer;\n  typedef typename View::const_reference StlContainerReference;\n  typedef typename StlContainer::value_type Element;\n\n  template <typename InnerMatcher>\n  explicit QuantifierMatcherImpl(InnerMatcher inner_matcher)\n      : inner_matcher_(\n           testing::SafeMatcherCast<const Element&>(inner_matcher)) {}\n\n  // Checks whether:\n  // * All elements in the container match, if all_elements_should_match.\n  // * Any element in the container matches, if !all_elements_should_match.\n  bool MatchAndExplainImpl(bool all_elements_should_match,\n                           Container container,\n                           MatchResultListener* listener) const {\n    StlContainerReference stl_container = View::ConstReference(container);\n    size_t i = 0;\n    for (typename StlContainer::const_iterator it = stl_container.begin();\n         it != stl_container.end(); ++it, ++i) {\n      StringMatchResultListener inner_listener;\n      const bool matches = inner_matcher_.MatchAndExplain(*it, &inner_listener);\n\n      if (matches != all_elements_should_match) {\n        *listener << \"whose element #\" << i\n                  << (matches ? \" matches\" : \" doesn't match\");\n        PrintIfNotEmpty(inner_listener.str(), listener->stream());\n        return !all_elements_should_match;\n      }\n    }\n    return all_elements_should_match;\n  }\n\n protected:\n  const Matcher<const Element&> inner_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(QuantifierMatcherImpl);\n};\n\n// Implements Contains(element_matcher) for the given argument type Container.\n// Symmetric to EachMatcherImpl.\ntemplate <typename Container>\nclass ContainsMatcherImpl : public QuantifierMatcherImpl<Container> {\n public:\n  template <typename InnerMatcher>\n  explicit ContainsMatcherImpl(InnerMatcher inner_matcher)\n      : QuantifierMatcherImpl<Container>(inner_matcher) {}\n\n  // Describes what this matcher does.\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"contains at least one element that \";\n    this->inner_matcher_.DescribeTo(os);\n  }\n\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"doesn't contain any element that \";\n    this->inner_matcher_.DescribeTo(os);\n  }\n\n  virtual bool MatchAndExplain(Container container,\n                               MatchResultListener* listener) const {\n    return this->MatchAndExplainImpl(false, container, listener);\n  }\n\n private:\n  GTEST_DISALLOW_ASSIGN_(ContainsMatcherImpl);\n};\n\n// Implements Each(element_matcher) for the given argument type Container.\n// Symmetric to ContainsMatcherImpl.\ntemplate <typename Container>\nclass EachMatcherImpl : public QuantifierMatcherImpl<Container> {\n public:\n  template <typename InnerMatcher>\n  explicit EachMatcherImpl(InnerMatcher inner_matcher)\n      : QuantifierMatcherImpl<Container>(inner_matcher) {}\n\n  // Describes what this matcher does.\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"only contains elements that \";\n    this->inner_matcher_.DescribeTo(os);\n  }\n\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"contains some element that \";\n    this->inner_matcher_.DescribeNegationTo(os);\n  }\n\n  virtual bool MatchAndExplain(Container container,\n                               MatchResultListener* listener) const {\n    return this->MatchAndExplainImpl(true, container, listener);\n  }\n\n private:\n  GTEST_DISALLOW_ASSIGN_(EachMatcherImpl);\n};\n\n// Implements polymorphic Contains(element_matcher).\ntemplate <typename M>\nclass ContainsMatcher {\n public:\n  explicit ContainsMatcher(M m) : inner_matcher_(m) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    return MakeMatcher(new ContainsMatcherImpl<Container>(inner_matcher_));\n  }\n\n private:\n  const M inner_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(ContainsMatcher);\n};\n\n// Implements polymorphic Each(element_matcher).\ntemplate <typename M>\nclass EachMatcher {\n public:\n  explicit EachMatcher(M m) : inner_matcher_(m) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    return MakeMatcher(new EachMatcherImpl<Container>(inner_matcher_));\n  }\n\n private:\n  const M inner_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(EachMatcher);\n};\n\n// Implements Key(inner_matcher) for the given argument pair type.\n// Key(inner_matcher) matches an std::pair whose 'first' field matches\n// inner_matcher.  For example, Contains(Key(Ge(5))) can be used to match an\n// std::map that contains at least one element whose key is >= 5.\ntemplate <typename PairType>\nclass KeyMatcherImpl : public MatcherInterface<PairType> {\n public:\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(PairType) RawPairType;\n  typedef typename RawPairType::first_type KeyType;\n\n  template <typename InnerMatcher>\n  explicit KeyMatcherImpl(InnerMatcher inner_matcher)\n      : inner_matcher_(\n          testing::SafeMatcherCast<const KeyType&>(inner_matcher)) {\n  }\n\n  // Returns true iff 'key_value.first' (the key) matches the inner matcher.\n  virtual bool MatchAndExplain(PairType key_value,\n                               MatchResultListener* listener) const {\n    StringMatchResultListener inner_listener;\n    const bool match = inner_matcher_.MatchAndExplain(key_value.first,\n                                                      &inner_listener);\n    const internal::string explanation = inner_listener.str();\n    if (explanation != \"\") {\n      *listener << \"whose first field is a value \" << explanation;\n    }\n    return match;\n  }\n\n  // Describes what this matcher does.\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"has a key that \";\n    inner_matcher_.DescribeTo(os);\n  }\n\n  // Describes what the negation of this matcher does.\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"doesn't have a key that \";\n    inner_matcher_.DescribeTo(os);\n  }\n\n private:\n  const Matcher<const KeyType&> inner_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(KeyMatcherImpl);\n};\n\n// Implements polymorphic Key(matcher_for_key).\ntemplate <typename M>\nclass KeyMatcher {\n public:\n  explicit KeyMatcher(M m) : matcher_for_key_(m) {}\n\n  template <typename PairType>\n  operator Matcher<PairType>() const {\n    return MakeMatcher(new KeyMatcherImpl<PairType>(matcher_for_key_));\n  }\n\n private:\n  const M matcher_for_key_;\n\n  GTEST_DISALLOW_ASSIGN_(KeyMatcher);\n};\n\n// Implements Pair(first_matcher, second_matcher) for the given argument pair\n// type with its two matchers. See Pair() function below.\ntemplate <typename PairType>\nclass PairMatcherImpl : public MatcherInterface<PairType> {\n public:\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(PairType) RawPairType;\n  typedef typename RawPairType::first_type FirstType;\n  typedef typename RawPairType::second_type SecondType;\n\n  template <typename FirstMatcher, typename SecondMatcher>\n  PairMatcherImpl(FirstMatcher first_matcher, SecondMatcher second_matcher)\n      : first_matcher_(\n            testing::SafeMatcherCast<const FirstType&>(first_matcher)),\n        second_matcher_(\n            testing::SafeMatcherCast<const SecondType&>(second_matcher)) {\n  }\n\n  // Describes what this matcher does.\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"has a first field that \";\n    first_matcher_.DescribeTo(os);\n    *os << \", and has a second field that \";\n    second_matcher_.DescribeTo(os);\n  }\n\n  // Describes what the negation of this matcher does.\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"has a first field that \";\n    first_matcher_.DescribeNegationTo(os);\n    *os << \", or has a second field that \";\n    second_matcher_.DescribeNegationTo(os);\n  }\n\n  // Returns true iff 'a_pair.first' matches first_matcher and 'a_pair.second'\n  // matches second_matcher.\n  virtual bool MatchAndExplain(PairType a_pair,\n                               MatchResultListener* listener) const {\n    if (!listener->IsInterested()) {\n      // If the listener is not interested, we don't need to construct the\n      // explanation.\n      return first_matcher_.Matches(a_pair.first) &&\n             second_matcher_.Matches(a_pair.second);\n    }\n    StringMatchResultListener first_inner_listener;\n    if (!first_matcher_.MatchAndExplain(a_pair.first,\n                                        &first_inner_listener)) {\n      *listener << \"whose first field does not match\";\n      PrintIfNotEmpty(first_inner_listener.str(), listener->stream());\n      return false;\n    }\n    StringMatchResultListener second_inner_listener;\n    if (!second_matcher_.MatchAndExplain(a_pair.second,\n                                         &second_inner_listener)) {\n      *listener << \"whose second field does not match\";\n      PrintIfNotEmpty(second_inner_listener.str(), listener->stream());\n      return false;\n    }\n    ExplainSuccess(first_inner_listener.str(), second_inner_listener.str(),\n                   listener);\n    return true;\n  }\n\n private:\n  void ExplainSuccess(const internal::string& first_explanation,\n                      const internal::string& second_explanation,\n                      MatchResultListener* listener) const {\n    *listener << \"whose both fields match\";\n    if (first_explanation != \"\") {\n      *listener << \", where the first field is a value \" << first_explanation;\n    }\n    if (second_explanation != \"\") {\n      *listener << \", \";\n      if (first_explanation != \"\") {\n        *listener << \"and \";\n      } else {\n        *listener << \"where \";\n      }\n      *listener << \"the second field is a value \" << second_explanation;\n    }\n  }\n\n  const Matcher<const FirstType&> first_matcher_;\n  const Matcher<const SecondType&> second_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(PairMatcherImpl);\n};\n\n// Implements polymorphic Pair(first_matcher, second_matcher).\ntemplate <typename FirstMatcher, typename SecondMatcher>\nclass PairMatcher {\n public:\n  PairMatcher(FirstMatcher first_matcher, SecondMatcher second_matcher)\n      : first_matcher_(first_matcher), second_matcher_(second_matcher) {}\n\n  template <typename PairType>\n  operator Matcher<PairType> () const {\n    return MakeMatcher(\n        new PairMatcherImpl<PairType>(\n            first_matcher_, second_matcher_));\n  }\n\n private:\n  const FirstMatcher first_matcher_;\n  const SecondMatcher second_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(PairMatcher);\n};\n\n// Implements ElementsAre() and ElementsAreArray().\ntemplate <typename Container>\nclass ElementsAreMatcherImpl : public MatcherInterface<Container> {\n public:\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n  typedef internal::StlContainerView<RawContainer> View;\n  typedef typename View::type StlContainer;\n  typedef typename View::const_reference StlContainerReference;\n  typedef decltype(std::begin(\n      std::declval<StlContainerReference>())) StlContainerConstIterator;\n  typedef std::remove_reference_t<decltype(\n      *std::declval<StlContainerConstIterator &>())>\n      Element;\n\n  // Constructs the matcher from a sequence of element values or\n  // element matchers.\n  template <typename InputIter>\n  ElementsAreMatcherImpl(InputIter first, InputIter last) {\n    while (first != last) {\n      matchers_.push_back(MatcherCast<const Element&>(*first++));\n    }\n  }\n\n  // Describes what this matcher does.\n  virtual void DescribeTo(::std::ostream* os) const {\n    if (count() == 0) {\n      *os << \"is empty\";\n    } else if (count() == 1) {\n      *os << \"has 1 element that \";\n      matchers_[0].DescribeTo(os);\n    } else {\n      *os << \"has \" << Elements(count()) << \" where\\n\";\n      for (size_t i = 0; i != count(); ++i) {\n        *os << \"element #\" << i << \" \";\n        matchers_[i].DescribeTo(os);\n        if (i + 1 < count()) {\n          *os << \",\\n\";\n        }\n      }\n    }\n  }\n\n  // Describes what the negation of this matcher does.\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    if (count() == 0) {\n      *os << \"isn't empty\";\n      return;\n    }\n\n    *os << \"doesn't have \" << Elements(count()) << \", or\\n\";\n    for (size_t i = 0; i != count(); ++i) {\n      *os << \"element #\" << i << \" \";\n      matchers_[i].DescribeNegationTo(os);\n      if (i + 1 < count()) {\n        *os << \", or\\n\";\n      }\n    }\n  }\n\n  virtual bool MatchAndExplain(Container container,\n                               MatchResultListener* listener) const {\n    // To work with stream-like \"containers\", we must only walk\n    // through the elements in one pass.\n\n    const bool listener_interested = listener->IsInterested();\n\n    // explanations[i] is the explanation of the element at index i.\n    ::std::vector<internal::string> explanations(count());\n    StlContainerReference stl_container = View::ConstReference(container);\n    StlContainerConstIterator it = stl_container.begin();\n    size_t exam_pos = 0;\n    bool mismatch_found = false;  // Have we found a mismatched element yet?\n\n    // Go through the elements and matchers in pairs, until we reach\n    // the end of either the elements or the matchers, or until we find a\n    // mismatch.\n    for (; it != stl_container.end() && exam_pos != count(); ++it, ++exam_pos) {\n      bool match;  // Does the current element match the current matcher?\n      if (listener_interested) {\n        StringMatchResultListener s;\n        match = matchers_[exam_pos].MatchAndExplain(*it, &s);\n        explanations[exam_pos] = s.str();\n      } else {\n        match = matchers_[exam_pos].Matches(*it);\n      }\n\n      if (!match) {\n        mismatch_found = true;\n        break;\n      }\n    }\n    // If mismatch_found is true, 'exam_pos' is the index of the mismatch.\n\n    // Find how many elements the actual container has.  We avoid\n    // calling size() s.t. this code works for stream-like \"containers\"\n    // that don't define size().\n    size_t actual_count = exam_pos;\n    for (; it != stl_container.end(); ++it) {\n      ++actual_count;\n    }\n\n    if (actual_count != count()) {\n      // The element count doesn't match.  If the container is empty,\n      // there's no need to explain anything as Google Mock already\n      // prints the empty container.  Otherwise we just need to show\n      // how many elements there actually are.\n      if (listener_interested && (actual_count != 0)) {\n        *listener << \"which has \" << Elements(actual_count);\n      }\n      return false;\n    }\n\n    if (mismatch_found) {\n      // The element count matches, but the exam_pos-th element doesn't match.\n      if (listener_interested) {\n        *listener << \"whose element #\" << exam_pos << \" doesn't match\";\n        PrintIfNotEmpty(explanations[exam_pos], listener->stream());\n      }\n      return false;\n    }\n\n    // Every element matches its expectation.  We need to explain why\n    // (the obvious ones can be skipped).\n    if (listener_interested) {\n      bool reason_printed = false;\n      for (size_t i = 0; i != count(); ++i) {\n        const internal::string& s = explanations[i];\n        if (!s.empty()) {\n          if (reason_printed) {\n            *listener << \",\\nand \";\n          }\n          *listener << \"whose element #\" << i << \" matches, \" << s;\n          reason_printed = true;\n        }\n      }\n    }\n    return true;\n  }\n\n private:\n  static Message Elements(size_t count) {\n    return Message() << count << (count == 1 ? \" element\" : \" elements\");\n  }\n\n  size_t count() const { return matchers_.size(); }\n\n  ::std::vector<Matcher<const Element&> > matchers_;\n\n  GTEST_DISALLOW_ASSIGN_(ElementsAreMatcherImpl);\n};\n\n// Connectivity matrix of (elements X matchers), in element-major order.\n// Initially, there are no edges.\n// Use NextGraph() to iterate over all possible edge configurations.\n// Use Randomize() to generate a random edge configuration.\nclass GTEST_API_ MatchMatrix {\n public:\n  MatchMatrix(size_t num_elements, size_t num_matchers)\n      : num_elements_(num_elements),\n        num_matchers_(num_matchers),\n        matched_(num_elements_* num_matchers_, 0) {\n  }\n\n  size_t LhsSize() const { return num_elements_; }\n  size_t RhsSize() const { return num_matchers_; }\n  bool HasEdge(size_t ilhs, size_t irhs) const {\n    return matched_[SpaceIndex(ilhs, irhs)] == 1;\n  }\n  void SetEdge(size_t ilhs, size_t irhs, bool b) {\n    matched_[SpaceIndex(ilhs, irhs)] = b ? 1 : 0;\n  }\n\n  // Treating the connectivity matrix as a (LhsSize()*RhsSize())-bit number,\n  // adds 1 to that number; returns false if incrementing the graph left it\n  // empty.\n  bool NextGraph();\n\n  void Randomize();\n\n  string DebugString() const;\n\n private:\n  size_t SpaceIndex(size_t ilhs, size_t irhs) const {\n    return ilhs * num_matchers_ + irhs;\n  }\n\n  size_t num_elements_;\n  size_t num_matchers_;\n\n  // Each element is a char interpreted as bool. They are stored as a\n  // flattened array in lhs-major order, use 'SpaceIndex()' to translate\n  // a (ilhs, irhs) matrix coordinate into an offset.\n  ::std::vector<char> matched_;\n};\n\ntypedef ::std::pair<size_t, size_t> ElementMatcherPair;\ntypedef ::std::vector<ElementMatcherPair> ElementMatcherPairs;\n\n// Returns a maximum bipartite matching for the specified graph 'g'.\n// The matching is represented as a vector of {element, matcher} pairs.\nGTEST_API_ ElementMatcherPairs\nFindMaxBipartiteMatching(const MatchMatrix& g);\n\nGTEST_API_ bool FindPairing(const MatchMatrix& matrix,\n                            MatchResultListener* listener);\n\n// Untyped base class for implementing UnorderedElementsAre.  By\n// putting logic that's not specific to the element type here, we\n// reduce binary bloat and increase compilation speed.\nclass GTEST_API_ UnorderedElementsAreMatcherImplBase {\n protected:\n  // A vector of matcher describers, one for each element matcher.\n  // Does not own the describers (and thus can be used only when the\n  // element matchers are alive).\n  typedef ::std::vector<const MatcherDescriberInterface*> MatcherDescriberVec;\n\n  // Describes this UnorderedElementsAre matcher.\n  void DescribeToImpl(::std::ostream* os) const;\n\n  // Describes the negation of this UnorderedElementsAre matcher.\n  void DescribeNegationToImpl(::std::ostream* os) const;\n\n  bool VerifyAllElementsAndMatchersAreMatched(\n      const ::std::vector<string>& element_printouts,\n      const MatchMatrix& matrix,\n      MatchResultListener* listener) const;\n\n  MatcherDescriberVec& matcher_describers() {\n    return matcher_describers_;\n  }\n\n  static Message Elements(size_t n) {\n    return Message() << n << \" element\" << (n == 1 ? \"\" : \"s\");\n  }\n\n private:\n  MatcherDescriberVec matcher_describers_;\n\n  GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreMatcherImplBase);\n};\n\n// Implements unordered ElementsAre and unordered ElementsAreArray.\ntemplate <typename Container>\nclass UnorderedElementsAreMatcherImpl\n    : public MatcherInterface<Container>,\n      public UnorderedElementsAreMatcherImplBase {\n public:\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n  typedef internal::StlContainerView<RawContainer> View;\n  typedef typename View::type StlContainer;\n  typedef typename View::const_reference StlContainerReference;\n  typedef decltype(std::begin(\n      std::declval<StlContainerReference>())) StlContainerConstIterator;\n  typedef std::remove_reference_t<decltype(\n      *std::declval<StlContainerConstIterator &>())>\n      Element;\n\n  // Constructs the matcher from a sequence of element values or\n  // element matchers.\n  template <typename InputIter>\n  UnorderedElementsAreMatcherImpl(InputIter first, InputIter last) {\n    for (; first != last; ++first) {\n      matchers_.push_back(MatcherCast<const Element&>(*first));\n      matcher_describers().push_back(matchers_.back().GetDescriber());\n    }\n  }\n\n  // Describes what this matcher does.\n  virtual void DescribeTo(::std::ostream* os) const {\n    return UnorderedElementsAreMatcherImplBase::DescribeToImpl(os);\n  }\n\n  // Describes what the negation of this matcher does.\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    return UnorderedElementsAreMatcherImplBase::DescribeNegationToImpl(os);\n  }\n\n  virtual bool MatchAndExplain(Container container,\n                               MatchResultListener* listener) const {\n    StlContainerReference stl_container = View::ConstReference(container);\n    ::std::vector<string> element_printouts;\n    MatchMatrix matrix = AnalyzeElements(stl_container.begin(),\n                                         stl_container.end(),\n                                         &element_printouts,\n                                         listener);\n\n    const size_t actual_count = matrix.LhsSize();\n    if (actual_count == 0 && matchers_.empty()) {\n      return true;\n    }\n    if (actual_count != matchers_.size()) {\n      // The element count doesn't match.  If the container is empty,\n      // there's no need to explain anything as Google Mock already\n      // prints the empty container. Otherwise we just need to show\n      // how many elements there actually are.\n      if (actual_count != 0 && listener->IsInterested()) {\n        *listener << \"which has \" << Elements(actual_count);\n      }\n      return false;\n    }\n\n    return VerifyAllElementsAndMatchersAreMatched(element_printouts,\n                                                  matrix, listener) &&\n           FindPairing(matrix, listener);\n  }\n\n private:\n  typedef ::std::vector<Matcher<const Element&> > MatcherVec;\n\n  template <typename ElementIter>\n  MatchMatrix AnalyzeElements(ElementIter elem_first, ElementIter elem_last,\n                              ::std::vector<string>* element_printouts,\n                              MatchResultListener* listener) const {\n    element_printouts->clear();\n    ::std::vector<char> did_match;\n    size_t num_elements = 0;\n    for (; elem_first != elem_last; ++num_elements, ++elem_first) {\n      if (listener->IsInterested()) {\n        element_printouts->push_back(PrintToString(*elem_first));\n      }\n      for (size_t irhs = 0; irhs != matchers_.size(); ++irhs) {\n        did_match.push_back(Matches(matchers_[irhs])(*elem_first));\n      }\n    }\n\n    MatchMatrix matrix(num_elements, matchers_.size());\n    ::std::vector<char>::const_iterator did_match_iter = did_match.begin();\n    for (size_t ilhs = 0; ilhs != num_elements; ++ilhs) {\n      for (size_t irhs = 0; irhs != matchers_.size(); ++irhs) {\n        matrix.SetEdge(ilhs, irhs, *did_match_iter++ != 0);\n      }\n    }\n    return matrix;\n  }\n\n  MatcherVec matchers_;\n\n  GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreMatcherImpl);\n};\n\n// Functor for use in TransformTuple.\n// Performs MatcherCast<Target> on an input argument of any type.\ntemplate <typename Target>\nstruct CastAndAppendTransform {\n  template <typename Arg>\n  Matcher<Target> operator()(const Arg& a) const {\n    return MatcherCast<Target>(a);\n  }\n};\n\n// Implements UnorderedElementsAre.\ntemplate <typename MatcherTuple>\nclass UnorderedElementsAreMatcher {\n public:\n  explicit UnorderedElementsAreMatcher(const MatcherTuple& args)\n      : matchers_(args) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n    typedef internal::StlContainerView<RawContainer> View;\n    typedef typename View::const_reference StlContainerReference;\n    typedef decltype(std::begin(\n        std::declval<StlContainerReference>())) StlContainerConstIterator;\n    typedef std::remove_reference_t<decltype(\n        *std::declval<StlContainerConstIterator &>())>\n        Element;\n    typedef ::std::vector<Matcher<const Element&> > MatcherVec;\n    MatcherVec matchers;\n    matchers.reserve(::testing::tuple_size<MatcherTuple>::value);\n    TransformTupleValues(CastAndAppendTransform<const Element&>(), matchers_,\n                         ::std::back_inserter(matchers));\n    return MakeMatcher(new UnorderedElementsAreMatcherImpl<Container>(\n                           matchers.begin(), matchers.end()));\n  }\n\n private:\n  const MatcherTuple matchers_;\n  GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreMatcher);\n};\n\n// Implements ElementsAre.\ntemplate <typename MatcherTuple>\nclass ElementsAreMatcher {\n public:\n  explicit ElementsAreMatcher(const MatcherTuple& args) : matchers_(args) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n    typedef internal::StlContainerView<RawContainer> View;\n    typedef typename View::const_reference StlContainerReference;\n    typedef decltype(std::begin(\n        std::declval<StlContainerReference>())) StlContainerConstIterator;\n    typedef std::remove_reference_t<decltype(\n        *std::declval<StlContainerConstIterator &>())>\n        Element;\n    typedef ::std::vector<Matcher<const Element&> > MatcherVec;\n    MatcherVec matchers;\n    matchers.reserve(::testing::tuple_size<MatcherTuple>::value);\n    TransformTupleValues(CastAndAppendTransform<const Element&>(), matchers_,\n                         ::std::back_inserter(matchers));\n    return MakeMatcher(new ElementsAreMatcherImpl<Container>(\n                           matchers.begin(), matchers.end()));\n  }\n\n private:\n  const MatcherTuple matchers_;\n  GTEST_DISALLOW_ASSIGN_(ElementsAreMatcher);\n};\n\n// Implements UnorderedElementsAreArray().\ntemplate <typename T>\nclass UnorderedElementsAreArrayMatcher {\n public:\n  UnorderedElementsAreArrayMatcher() {}\n\n  template <typename Iter>\n  UnorderedElementsAreArrayMatcher(Iter first, Iter last)\n      : matchers_(first, last) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    return MakeMatcher(\n        new UnorderedElementsAreMatcherImpl<Container>(matchers_.begin(),\n                                                       matchers_.end()));\n  }\n\n private:\n  ::std::vector<T> matchers_;\n\n  GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreArrayMatcher);\n};\n\n// Implements ElementsAreArray().\ntemplate <typename T>\nclass ElementsAreArrayMatcher {\n public:\n  template <typename Iter>\n  ElementsAreArrayMatcher(Iter first, Iter last) : matchers_(first, last) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    return MakeMatcher(new ElementsAreMatcherImpl<Container>(\n        matchers_.begin(), matchers_.end()));\n  }\n\n private:\n  const ::std::vector<T> matchers_;\n\n  GTEST_DISALLOW_ASSIGN_(ElementsAreArrayMatcher);\n};\n\n// Given a 2-tuple matcher tm of type Tuple2Matcher and a value second\n// of type Second, BoundSecondMatcher<Tuple2Matcher, Second>(tm,\n// second) is a polymorphic matcher that matches a value x iff tm\n// matches tuple (x, second).  Useful for implementing\n// UnorderedPointwise() in terms of UnorderedElementsAreArray().\n//\n// BoundSecondMatcher is copyable and assignable, as we need to put\n// instances of this class in a vector when implementing\n// UnorderedPointwise().\ntemplate <typename Tuple2Matcher, typename Second>\nclass BoundSecondMatcher {\n public:\n  BoundSecondMatcher(const Tuple2Matcher& tm, const Second& second)\n      : tuple2_matcher_(tm), second_value_(second) {}\n\n  template <typename T>\n  operator Matcher<T>() const {\n    return MakeMatcher(new Impl<T>(tuple2_matcher_, second_value_));\n  }\n\n  // We have to define this for UnorderedPointwise() to compile in\n  // C++98 mode, as it puts BoundSecondMatcher instances in a vector,\n  // which requires the elements to be assignable in C++98.  The\n  // compiler cannot generate the operator= for us, as Tuple2Matcher\n  // and Second may not be assignable.\n  //\n  // However, this should never be called, so the implementation just\n  // need to assert.\n  void operator=(const BoundSecondMatcher& /*rhs*/) {\n    GTEST_LOG_(FATAL) << \"BoundSecondMatcher should never be assigned.\";\n  }\n\n  BoundSecondMatcher(const BoundSecondMatcher &) = default;\n\n private:\n  template <typename T>\n  class Impl : public MatcherInterface<T> {\n   public:\n    typedef ::testing::tuple<T, Second> ArgTuple;\n\n    Impl(const Tuple2Matcher& tm, const Second& second)\n        : mono_tuple2_matcher_(SafeMatcherCast<const ArgTuple&>(tm)),\n          second_value_(second) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"and \";\n      UniversalPrint(second_value_, os);\n      *os << \" \";\n      mono_tuple2_matcher_.DescribeTo(os);\n    }\n\n    virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {\n      return mono_tuple2_matcher_.MatchAndExplain(ArgTuple(x, second_value_),\n                                                  listener);\n    }\n\n   private:\n    const Matcher<const ArgTuple&> mono_tuple2_matcher_;\n    const Second second_value_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  const Tuple2Matcher tuple2_matcher_;\n  const Second second_value_;\n};\n\n// Given a 2-tuple matcher tm and a value second,\n// MatcherBindSecond(tm, second) returns a matcher that matches a\n// value x iff tm matches tuple (x, second).  Useful for implementing\n// UnorderedPointwise() in terms of UnorderedElementsAreArray().\ntemplate <typename Tuple2Matcher, typename Second>\nBoundSecondMatcher<Tuple2Matcher, Second> MatcherBindSecond(\n    const Tuple2Matcher& tm, const Second& second) {\n  return BoundSecondMatcher<Tuple2Matcher, Second>(tm, second);\n}\n\n// Returns the description for a matcher defined using the MATCHER*()\n// macro where the user-supplied description string is \"\", if\n// 'negation' is false; otherwise returns the description of the\n// negation of the matcher.  'param_values' contains a list of strings\n// that are the print-out of the matcher's parameters.\nGTEST_API_ string FormatMatcherDescription(bool negation,\n                                           const char* matcher_name,\n                                           const Strings& param_values);\n\n}  // namespace internal\n\n// ElementsAreArray(first, last)\n// ElementsAreArray(pointer, count)\n// ElementsAreArray(array)\n// ElementsAreArray(container)\n// ElementsAreArray({ e1, e2, ..., en })\n//\n// The ElementsAreArray() functions are like ElementsAre(...), except\n// that they are given a homogeneous sequence rather than taking each\n// element as a function argument. The sequence can be specified as an\n// array, a pointer and count, a vector, an initializer list, or an\n// STL iterator range. In each of these cases, the underlying sequence\n// can be either a sequence of values or a sequence of matchers.\n//\n// All forms of ElementsAreArray() make a copy of the input matcher sequence.\n\ntemplate <typename Iter>\ninline internal::ElementsAreArrayMatcher<\n    typename ::std::iterator_traits<Iter>::value_type>\nElementsAreArray(Iter first, Iter last) {\n  typedef typename ::std::iterator_traits<Iter>::value_type T;\n  return internal::ElementsAreArrayMatcher<T>(first, last);\n}\n\ntemplate <typename T>\ninline internal::ElementsAreArrayMatcher<T> ElementsAreArray(\n    const T* pointer, size_t count) {\n  return ElementsAreArray(pointer, pointer + count);\n}\n\ntemplate <typename T, size_t N>\ninline internal::ElementsAreArrayMatcher<T> ElementsAreArray(\n    const T (&array)[N]) {\n  return ElementsAreArray(array, N);\n}\n\ntemplate <typename Container>\ninline internal::ElementsAreArrayMatcher<typename Container::value_type>\nElementsAreArray(const Container& container) {\n  return ElementsAreArray(container.begin(), container.end());\n}\n\n#if GTEST_HAS_STD_INITIALIZER_LIST_\ntemplate <typename T>\ninline internal::ElementsAreArrayMatcher<T>\nElementsAreArray(::std::initializer_list<T> xs) {\n  return ElementsAreArray(xs.begin(), xs.end());\n}\n#endif\n\n// UnorderedElementsAreArray(first, last)\n// UnorderedElementsAreArray(pointer, count)\n// UnorderedElementsAreArray(array)\n// UnorderedElementsAreArray(container)\n// UnorderedElementsAreArray({ e1, e2, ..., en })\n//\n// The UnorderedElementsAreArray() functions are like\n// ElementsAreArray(...), but allow matching the elements in any order.\ntemplate <typename Iter>\ninline internal::UnorderedElementsAreArrayMatcher<\n    typename ::std::iterator_traits<Iter>::value_type>\nUnorderedElementsAreArray(Iter first, Iter last) {\n  typedef typename ::std::iterator_traits<Iter>::value_type T;\n  return internal::UnorderedElementsAreArrayMatcher<T>(first, last);\n}\n\ntemplate <typename T>\ninline internal::UnorderedElementsAreArrayMatcher<T>\nUnorderedElementsAreArray(const T* pointer, size_t count) {\n  return UnorderedElementsAreArray(pointer, pointer + count);\n}\n\ntemplate <typename T, size_t N>\ninline internal::UnorderedElementsAreArrayMatcher<T>\nUnorderedElementsAreArray(const T (&array)[N]) {\n  return UnorderedElementsAreArray(array, N);\n}\n\ntemplate <typename Container>\ninline internal::UnorderedElementsAreArrayMatcher<\n    typename Container::value_type>\nUnorderedElementsAreArray(const Container& container) {\n  return UnorderedElementsAreArray(container.begin(), container.end());\n}\n\n#if GTEST_HAS_STD_INITIALIZER_LIST_\ntemplate <typename T>\ninline internal::UnorderedElementsAreArrayMatcher<T>\nUnorderedElementsAreArray(::std::initializer_list<T> xs) {\n  return UnorderedElementsAreArray(xs.begin(), xs.end());\n}\n#endif\n\n// _ is a matcher that matches anything of any type.\n//\n// This definition is fine as:\n//\n//   1. The C++ standard permits using the name _ in a namespace that\n//      is not the global namespace or ::std.\n//   2. The AnythingMatcher class has no data member or constructor,\n//      so it's OK to create global variables of this type.\n//   3. c-style has approved of using _ in this case.\nconst internal::AnythingMatcher _ = {};\n// Creates a matcher that matches any value of the given type T.\ntemplate <typename T>\ninline Matcher<T> A() { return MakeMatcher(new internal::AnyMatcherImpl<T>()); }\n\n// Creates a matcher that matches any value of the given type T.\ntemplate <typename T>\ninline Matcher<T> An() { return A<T>(); }\n\n// Creates a polymorphic matcher that matches anything equal to x.\n// Note: if the parameter of Eq() were declared as const T&, Eq(\"foo\")\n// wouldn't compile.\ntemplate <typename T>\ninline internal::EqMatcher<T> Eq(T x) { return internal::EqMatcher<T>(x); }\n\n// Constructs a Matcher<T> from a 'value' of type T.  The constructed\n// matcher matches any value that's equal to 'value'.\ntemplate <typename T>\nMatcher<T>::Matcher(T value) { *this = Eq(value); }\n\n// Creates a monomorphic matcher that matches anything with type Lhs\n// and equal to rhs.  A user may need to use this instead of Eq(...)\n// in order to resolve an overloading ambiguity.\n//\n// TypedEq<T>(x) is just a convenient short-hand for Matcher<T>(Eq(x))\n// or Matcher<T>(x), but more readable than the latter.\n//\n// We could define similar monomorphic matchers for other comparison\n// operations (e.g. TypedLt, TypedGe, and etc), but decided not to do\n// it yet as those are used much less than Eq() in practice.  A user\n// can always write Matcher<T>(Lt(5)) to be explicit about the type,\n// for example.\ntemplate <typename Lhs, typename Rhs>\ninline Matcher<Lhs> TypedEq(const Rhs& rhs) { return Eq(rhs); }\n\n// Creates a polymorphic matcher that matches anything >= x.\ntemplate <typename Rhs>\ninline internal::GeMatcher<Rhs> Ge(Rhs x) {\n  return internal::GeMatcher<Rhs>(x);\n}\n\n// Creates a polymorphic matcher that matches anything > x.\ntemplate <typename Rhs>\ninline internal::GtMatcher<Rhs> Gt(Rhs x) {\n  return internal::GtMatcher<Rhs>(x);\n}\n\n// Creates a polymorphic matcher that matches anything <= x.\ntemplate <typename Rhs>\ninline internal::LeMatcher<Rhs> Le(Rhs x) {\n  return internal::LeMatcher<Rhs>(x);\n}\n\n// Creates a polymorphic matcher that matches anything < x.\ntemplate <typename Rhs>\ninline internal::LtMatcher<Rhs> Lt(Rhs x) {\n  return internal::LtMatcher<Rhs>(x);\n}\n\n// Creates a polymorphic matcher that matches anything != x.\ntemplate <typename Rhs>\ninline internal::NeMatcher<Rhs> Ne(Rhs x) {\n  return internal::NeMatcher<Rhs>(x);\n}\n\n// Creates a polymorphic matcher that matches any NULL pointer.\ninline PolymorphicMatcher<internal::IsNullMatcher > IsNull() {\n  return MakePolymorphicMatcher(internal::IsNullMatcher());\n}\n\n// Creates a polymorphic matcher that matches any non-NULL pointer.\n// This is convenient as Not(NULL) doesn't compile (the compiler\n// thinks that that expression is comparing a pointer with an integer).\ninline PolymorphicMatcher<internal::NotNullMatcher > NotNull() {\n  return MakePolymorphicMatcher(internal::NotNullMatcher());\n}\n\n// Creates a polymorphic matcher that matches any argument that\n// references variable x.\ntemplate <typename T>\ninline internal::RefMatcher<T&> Ref(T& x) {  // NOLINT\n  return internal::RefMatcher<T&>(x);\n}\n\n// Creates a matcher that matches any double argument approximately\n// equal to rhs, where two NANs are considered unequal.\ninline internal::FloatingEqMatcher<double> DoubleEq(double rhs) {\n  return internal::FloatingEqMatcher<double>(rhs, false);\n}\n\n// Creates a matcher that matches any double argument approximately\n// equal to rhs, including NaN values when rhs is NaN.\ninline internal::FloatingEqMatcher<double> NanSensitiveDoubleEq(double rhs) {\n  return internal::FloatingEqMatcher<double>(rhs, true);\n}\n\n// Creates a matcher that matches any double argument approximately equal to\n// rhs, up to the specified max absolute error bound, where two NANs are\n// considered unequal.  The max absolute error bound must be non-negative.\ninline internal::FloatingEqMatcher<double> DoubleNear(\n    double rhs, double max_abs_error) {\n  return internal::FloatingEqMatcher<double>(rhs, false, max_abs_error);\n}\n\n// Creates a matcher that matches any double argument approximately equal to\n// rhs, up to the specified max absolute error bound, including NaN values when\n// rhs is NaN.  The max absolute error bound must be non-negative.\ninline internal::FloatingEqMatcher<double> NanSensitiveDoubleNear(\n    double rhs, double max_abs_error) {\n  return internal::FloatingEqMatcher<double>(rhs, true, max_abs_error);\n}\n\n// Creates a matcher that matches any float argument approximately\n// equal to rhs, where two NANs are considered unequal.\ninline internal::FloatingEqMatcher<float> FloatEq(float rhs) {\n  return internal::FloatingEqMatcher<float>(rhs, false);\n}\n\n// Creates a matcher that matches any float argument approximately\n// equal to rhs, including NaN values when rhs is NaN.\ninline internal::FloatingEqMatcher<float> NanSensitiveFloatEq(float rhs) {\n  return internal::FloatingEqMatcher<float>(rhs, true);\n}\n\n// Creates a matcher that matches any float argument approximately equal to\n// rhs, up to the specified max absolute error bound, where two NANs are\n// considered unequal.  The max absolute error bound must be non-negative.\ninline internal::FloatingEqMatcher<float> FloatNear(\n    float rhs, float max_abs_error) {\n  return internal::FloatingEqMatcher<float>(rhs, false, max_abs_error);\n}\n\n// Creates a matcher that matches any float argument approximately equal to\n// rhs, up to the specified max absolute error bound, including NaN values when\n// rhs is NaN.  The max absolute error bound must be non-negative.\ninline internal::FloatingEqMatcher<float> NanSensitiveFloatNear(\n    float rhs, float max_abs_error) {\n  return internal::FloatingEqMatcher<float>(rhs, true, max_abs_error);\n}\n\n// Creates a matcher that matches a pointer (raw or smart) that points\n// to a value that matches inner_matcher.\ntemplate <typename InnerMatcher>\ninline internal::PointeeMatcher<InnerMatcher> Pointee(\n    const InnerMatcher& inner_matcher) {\n  return internal::PointeeMatcher<InnerMatcher>(inner_matcher);\n}\n\n// Creates a matcher that matches a pointer or reference that matches\n// inner_matcher when dynamic_cast<To> is applied.\n// The result of dynamic_cast<To> is forwarded to the inner matcher.\n// If To is a pointer and the cast fails, the inner matcher will receive NULL.\n// If To is a reference and the cast fails, this matcher returns false\n// immediately.\ntemplate <typename To>\ninline PolymorphicMatcher<internal::WhenDynamicCastToMatcher<To> >\nWhenDynamicCastTo(const Matcher<To>& inner_matcher) {\n  return MakePolymorphicMatcher(\n      internal::WhenDynamicCastToMatcher<To>(inner_matcher));\n}\n\n// Creates a matcher that matches an object whose given field matches\n// 'matcher'.  For example,\n//   Field(&Foo::number, Ge(5))\n// matches a Foo object x iff x.number >= 5.\ntemplate <typename Class, typename FieldType, typename FieldMatcher>\ninline PolymorphicMatcher<\n  internal::FieldMatcher<Class, FieldType> > Field(\n    FieldType Class::*field, const FieldMatcher& matcher) {\n  return MakePolymorphicMatcher(\n      internal::FieldMatcher<Class, FieldType>(\n          field, MatcherCast<const FieldType&>(matcher)));\n  // The call to MatcherCast() is required for supporting inner\n  // matchers of compatible types.  For example, it allows\n  //   Field(&Foo::bar, m)\n  // to compile where bar is an int32 and m is a matcher for int64.\n}\n\n// Creates a matcher that matches an object whose given property\n// matches 'matcher'.  For example,\n//   Property(&Foo::str, StartsWith(\"hi\"))\n// matches a Foo object x iff x.str() starts with \"hi\".\ntemplate <typename Class, typename PropertyType, typename PropertyMatcher>\ninline PolymorphicMatcher<\n  internal::PropertyMatcher<Class, PropertyType> > Property(\n    PropertyType (Class::*property)() const, const PropertyMatcher& matcher) {\n  return MakePolymorphicMatcher(\n      internal::PropertyMatcher<Class, PropertyType>(\n          property,\n          MatcherCast<GTEST_REFERENCE_TO_CONST_(PropertyType)>(matcher)));\n  // The call to MatcherCast() is required for supporting inner\n  // matchers of compatible types.  For example, it allows\n  //   Property(&Foo::bar, m)\n  // to compile where bar() returns an int32 and m is a matcher for int64.\n}\n\n// Creates a matcher that matches an object iff the result of applying\n// a callable to x matches 'matcher'.\n// For example,\n//   ResultOf(f, StartsWith(\"hi\"))\n// matches a Foo object x iff f(x) starts with \"hi\".\n// callable parameter can be a function, function pointer, or a functor.\n// Callable has to satisfy the following conditions:\n//   * It is required to keep no state affecting the results of\n//     the calls on it and make no assumptions about how many calls\n//     will be made. Any state it keeps must be protected from the\n//     concurrent access.\n//   * If it is a function object, it has to define type result_type.\n//     We recommend deriving your functor classes from std::unary_function.\ntemplate <typename Callable, typename ResultOfMatcher>\ninternal::ResultOfMatcher<Callable> ResultOf(\n    Callable callable, const ResultOfMatcher& matcher) {\n  return internal::ResultOfMatcher<Callable>(\n          callable,\n          MatcherCast<typename internal::CallableTraits<Callable>::ResultType>(\n              matcher));\n  // The call to MatcherCast() is required for supporting inner\n  // matchers of compatible types.  For example, it allows\n  //   ResultOf(Function, m)\n  // to compile where Function() returns an int32 and m is a matcher for int64.\n}\n\n// String matchers.\n\n// Matches a string equal to str.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::string> >\n    StrEq(const internal::string& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::string>(\n      str, true, true));\n}\n\n// Matches a string not equal to str.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::string> >\n    StrNe(const internal::string& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::string>(\n      str, false, true));\n}\n\n// Matches a string equal to str, ignoring case.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::string> >\n    StrCaseEq(const internal::string& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::string>(\n      str, true, false));\n}\n\n// Matches a string not equal to str, ignoring case.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::string> >\n    StrCaseNe(const internal::string& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::string>(\n      str, false, false));\n}\n\n// Creates a matcher that matches any string, std::string, or C string\n// that contains the given substring.\ninline PolymorphicMatcher<internal::HasSubstrMatcher<internal::string> >\n    HasSubstr(const internal::string& substring) {\n  return MakePolymorphicMatcher(internal::HasSubstrMatcher<internal::string>(\n      substring));\n}\n\n// Matches a string that starts with 'prefix' (case-sensitive).\ninline PolymorphicMatcher<internal::StartsWithMatcher<internal::string> >\n    StartsWith(const internal::string& prefix) {\n  return MakePolymorphicMatcher(internal::StartsWithMatcher<internal::string>(\n      prefix));\n}\n\n// Matches a string that ends with 'suffix' (case-sensitive).\ninline PolymorphicMatcher<internal::EndsWithMatcher<internal::string> >\n    EndsWith(const internal::string& suffix) {\n  return MakePolymorphicMatcher(internal::EndsWithMatcher<internal::string>(\n      suffix));\n}\n\n// Matches a string that fully matches regular expression 'regex'.\n// The matcher takes ownership of 'regex'.\ninline PolymorphicMatcher<internal::MatchesRegexMatcher> MatchesRegex(\n    const internal::RE* regex) {\n  return MakePolymorphicMatcher(internal::MatchesRegexMatcher(regex, true));\n}\ninline PolymorphicMatcher<internal::MatchesRegexMatcher> MatchesRegex(\n    const internal::string& regex) {\n  return MatchesRegex(new internal::RE(regex));\n}\n\n// Matches a string that contains regular expression 'regex'.\n// The matcher takes ownership of 'regex'.\ninline PolymorphicMatcher<internal::MatchesRegexMatcher> ContainsRegex(\n    const internal::RE* regex) {\n  return MakePolymorphicMatcher(internal::MatchesRegexMatcher(regex, false));\n}\ninline PolymorphicMatcher<internal::MatchesRegexMatcher> ContainsRegex(\n    const internal::string& regex) {\n  return ContainsRegex(new internal::RE(regex));\n}\n\n#if GTEST_HAS_GLOBAL_WSTRING || GTEST_HAS_STD_WSTRING\n// Wide string matchers.\n\n// Matches a string equal to str.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::wstring> >\n    StrEq(const internal::wstring& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::wstring>(\n      str, true, true));\n}\n\n// Matches a string not equal to str.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::wstring> >\n    StrNe(const internal::wstring& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::wstring>(\n      str, false, true));\n}\n\n// Matches a string equal to str, ignoring case.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::wstring> >\n    StrCaseEq(const internal::wstring& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::wstring>(\n      str, true, false));\n}\n\n// Matches a string not equal to str, ignoring case.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::wstring> >\n    StrCaseNe(const internal::wstring& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::wstring>(\n      str, false, false));\n}\n\n// Creates a matcher that matches any wstring, std::wstring, or C wide string\n// that contains the given substring.\ninline PolymorphicMatcher<internal::HasSubstrMatcher<internal::wstring> >\n    HasSubstr(const internal::wstring& substring) {\n  return MakePolymorphicMatcher(internal::HasSubstrMatcher<internal::wstring>(\n      substring));\n}\n\n// Matches a string that starts with 'prefix' (case-sensitive).\ninline PolymorphicMatcher<internal::StartsWithMatcher<internal::wstring> >\n    StartsWith(const internal::wstring& prefix) {\n  return MakePolymorphicMatcher(internal::StartsWithMatcher<internal::wstring>(\n      prefix));\n}\n\n// Matches a string that ends with 'suffix' (case-sensitive).\ninline PolymorphicMatcher<internal::EndsWithMatcher<internal::wstring> >\n    EndsWith(const internal::wstring& suffix) {\n  return MakePolymorphicMatcher(internal::EndsWithMatcher<internal::wstring>(\n      suffix));\n}\n\n#endif  // GTEST_HAS_GLOBAL_WSTRING || GTEST_HAS_STD_WSTRING\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field == the second field.\ninline internal::Eq2Matcher Eq() { return internal::Eq2Matcher(); }\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field >= the second field.\ninline internal::Ge2Matcher Ge() { return internal::Ge2Matcher(); }\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field > the second field.\ninline internal::Gt2Matcher Gt() { return internal::Gt2Matcher(); }\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field <= the second field.\ninline internal::Le2Matcher Le() { return internal::Le2Matcher(); }\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field < the second field.\ninline internal::Lt2Matcher Lt() { return internal::Lt2Matcher(); }\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field != the second field.\ninline internal::Ne2Matcher Ne() { return internal::Ne2Matcher(); }\n\n// Creates a matcher that matches any value of type T that m doesn't\n// match.\ntemplate <typename InnerMatcher>\ninline internal::NotMatcher<InnerMatcher> Not(InnerMatcher m) {\n  return internal::NotMatcher<InnerMatcher>(m);\n}\n\n// Returns a matcher that matches anything that satisfies the given\n// predicate.  The predicate can be any unary function or functor\n// whose return type can be implicitly converted to bool.\ntemplate <typename Predicate>\ninline PolymorphicMatcher<internal::TrulyMatcher<Predicate> >\nTruly(Predicate pred) {\n  return MakePolymorphicMatcher(internal::TrulyMatcher<Predicate>(pred));\n}\n\n// Returns a matcher that matches the container size. The container must\n// support both size() and size_type which all STL-like containers provide.\n// Note that the parameter 'size' can be a value of type size_type as well as\n// matcher. For instance:\n//   EXPECT_THAT(container, SizeIs(2));     // Checks container has 2 elements.\n//   EXPECT_THAT(container, SizeIs(Le(2));  // Checks container has at most 2.\ntemplate <typename SizeMatcher>\ninline internal::SizeIsMatcher<SizeMatcher>\nSizeIs(const SizeMatcher& size_matcher) {\n  return internal::SizeIsMatcher<SizeMatcher>(size_matcher);\n}\n\n// Returns a matcher that matches the distance between the container's begin()\n// iterator and its end() iterator, i.e. the size of the container. This matcher\n// can be used instead of SizeIs with containers such as std::forward_list which\n// do not implement size(). The container must provide const_iterator (with\n// valid iterator_traits), begin() and end().\ntemplate <typename DistanceMatcher>\ninline internal::BeginEndDistanceIsMatcher<DistanceMatcher>\nBeginEndDistanceIs(const DistanceMatcher& distance_matcher) {\n  return internal::BeginEndDistanceIsMatcher<DistanceMatcher>(distance_matcher);\n}\n\n// Returns a matcher that matches an equal container.\n// This matcher behaves like Eq(), but in the event of mismatch lists the\n// values that are included in one container but not the other. (Duplicate\n// values and order differences are not explained.)\ntemplate <typename Container>\ninline PolymorphicMatcher<internal::ContainerEqMatcher<  // NOLINT\n                            GTEST_REMOVE_CONST_(Container)> >\n    ContainerEq(const Container& rhs) {\n  // This following line is for working around a bug in MSVC 8.0,\n  // which causes Container to be a const type sometimes.\n  typedef GTEST_REMOVE_CONST_(Container) RawContainer;\n  return MakePolymorphicMatcher(\n      internal::ContainerEqMatcher<RawContainer>(rhs));\n}\n\n// Returns a matcher that matches a container that, when sorted using\n// the given comparator, matches container_matcher.\ntemplate <typename Comparator, typename ContainerMatcher>\ninline internal::WhenSortedByMatcher<Comparator, ContainerMatcher>\nWhenSortedBy(const Comparator& comparator,\n             const ContainerMatcher& container_matcher) {\n  return internal::WhenSortedByMatcher<Comparator, ContainerMatcher>(\n      comparator, container_matcher);\n}\n\n// Returns a matcher that matches a container that, when sorted using\n// the < operator, matches container_matcher.\ntemplate <typename ContainerMatcher>\ninline internal::WhenSortedByMatcher<internal::LessComparator, ContainerMatcher>\nWhenSorted(const ContainerMatcher& container_matcher) {\n  return\n      internal::WhenSortedByMatcher<internal::LessComparator, ContainerMatcher>(\n          internal::LessComparator(), container_matcher);\n}\n\n// Matches an STL-style container or a native array that contains the\n// same number of elements as in rhs, where its i-th element and rhs's\n// i-th element (as a pair) satisfy the given pair matcher, for all i.\n// TupleMatcher must be able to be safely cast to Matcher<tuple<const\n// T1&, const T2&> >, where T1 and T2 are the types of elements in the\n// LHS container and the RHS container respectively.\ntemplate <typename TupleMatcher, typename Container>\ninline internal::PointwiseMatcher<TupleMatcher,\n                                  GTEST_REMOVE_CONST_(Container)>\nPointwise(const TupleMatcher& tuple_matcher, const Container& rhs) {\n  // This following line is for working around a bug in MSVC 8.0,\n  // which causes Container to be a const type sometimes (e.g. when\n  // rhs is a const int[])..\n  typedef GTEST_REMOVE_CONST_(Container) RawContainer;\n  return internal::PointwiseMatcher<TupleMatcher, RawContainer>(\n      tuple_matcher, rhs);\n}\n\n#if GTEST_HAS_STD_INITIALIZER_LIST_\n\n// Supports the Pointwise(m, {a, b, c}) syntax.\ntemplate <typename TupleMatcher, typename T>\ninline internal::PointwiseMatcher<TupleMatcher, std::vector<T> > Pointwise(\n    const TupleMatcher& tuple_matcher, std::initializer_list<T> rhs) {\n  return Pointwise(tuple_matcher, std::vector<T>(rhs));\n}\n\n#endif  // GTEST_HAS_STD_INITIALIZER_LIST_\n\n// UnorderedPointwise(pair_matcher, rhs) matches an STL-style\n// container or a native array that contains the same number of\n// elements as in rhs, where in some permutation of the container, its\n// i-th element and rhs's i-th element (as a pair) satisfy the given\n// pair matcher, for all i.  Tuple2Matcher must be able to be safely\n// cast to Matcher<tuple<const T1&, const T2&> >, where T1 and T2 are\n// the types of elements in the LHS container and the RHS container\n// respectively.\n//\n// This is like Pointwise(pair_matcher, rhs), except that the element\n// order doesn't matter.\ntemplate <typename Tuple2Matcher, typename RhsContainer>\ninline internal::UnorderedElementsAreArrayMatcher<\n    typename internal::BoundSecondMatcher<\n        Tuple2Matcher, typename internal::StlContainerView<GTEST_REMOVE_CONST_(\n                           RhsContainer)>::type::value_type> >\nUnorderedPointwise(const Tuple2Matcher& tuple2_matcher,\n                   const RhsContainer& rhs_container) {\n  // This following line is for working around a bug in MSVC 8.0,\n  // which causes RhsContainer to be a const type sometimes (e.g. when\n  // rhs_container is a const int[]).\n  typedef GTEST_REMOVE_CONST_(RhsContainer) RawRhsContainer;\n\n  // RhsView allows the same code to handle RhsContainer being a\n  // STL-style container and it being a native C-style array.\n  typedef typename internal::StlContainerView<RawRhsContainer> RhsView;\n  typedef typename RhsView::type RhsStlContainer;\n  typedef typename RhsStlContainer::value_type Second;\n  const RhsStlContainer& rhs_stl_container =\n      RhsView::ConstReference(rhs_container);\n\n  // Create a matcher for each element in rhs_container.\n  ::std::vector<internal::BoundSecondMatcher<Tuple2Matcher, Second> > matchers;\n  for (typename RhsStlContainer::const_iterator it = rhs_stl_container.begin();\n       it != rhs_stl_container.end(); ++it) {\n    matchers.push_back(\n        internal::MatcherBindSecond(tuple2_matcher, *it));\n  }\n\n  // Delegate the work to UnorderedElementsAreArray().\n  return UnorderedElementsAreArray(matchers);\n}\n\n#if GTEST_HAS_STD_INITIALIZER_LIST_\n\n// Supports the UnorderedPointwise(m, {a, b, c}) syntax.\ntemplate <typename Tuple2Matcher, typename T>\ninline internal::UnorderedElementsAreArrayMatcher<\n    typename internal::BoundSecondMatcher<Tuple2Matcher, T> >\nUnorderedPointwise(const Tuple2Matcher& tuple2_matcher,\n                   std::initializer_list<T> rhs) {\n  return UnorderedPointwise(tuple2_matcher, std::vector<T>(rhs));\n}\n\n#endif  // GTEST_HAS_STD_INITIALIZER_LIST_\n\n// Matches an STL-style container or a native array that contains at\n// least one element matching the given value or matcher.\n//\n// Examples:\n//   ::std::set<int> page_ids;\n//   page_ids.insert(3);\n//   page_ids.insert(1);\n//   EXPECT_THAT(page_ids, Contains(1));\n//   EXPECT_THAT(page_ids, Contains(Gt(2)));\n//   EXPECT_THAT(page_ids, Not(Contains(4)));\n//\n//   ::std::map<int, size_t> page_lengths;\n//   page_lengths[1] = 100;\n//   EXPECT_THAT(page_lengths,\n//               Contains(::std::pair<const int, size_t>(1, 100)));\n//\n//   const char* user_ids[] = { \"joe\", \"mike\", \"tom\" };\n//   EXPECT_THAT(user_ids, Contains(Eq(::std::string(\"tom\"))));\ntemplate <typename M>\ninline internal::ContainsMatcher<M> Contains(M matcher) {\n  return internal::ContainsMatcher<M>(matcher);\n}\n\n// Matches an STL-style container or a native array that contains only\n// elements matching the given value or matcher.\n//\n// Each(m) is semantically equivalent to Not(Contains(Not(m))). Only\n// the messages are different.\n//\n// Examples:\n//   ::std::set<int> page_ids;\n//   // Each(m) matches an empty container, regardless of what m is.\n//   EXPECT_THAT(page_ids, Each(Eq(1)));\n//   EXPECT_THAT(page_ids, Each(Eq(77)));\n//\n//   page_ids.insert(3);\n//   EXPECT_THAT(page_ids, Each(Gt(0)));\n//   EXPECT_THAT(page_ids, Not(Each(Gt(4))));\n//   page_ids.insert(1);\n//   EXPECT_THAT(page_ids, Not(Each(Lt(2))));\n//\n//   ::std::map<int, size_t> page_lengths;\n//   page_lengths[1] = 100;\n//   page_lengths[2] = 200;\n//   page_lengths[3] = 300;\n//   EXPECT_THAT(page_lengths, Not(Each(Pair(1, 100))));\n//   EXPECT_THAT(page_lengths, Each(Key(Le(3))));\n//\n//   const char* user_ids[] = { \"joe\", \"mike\", \"tom\" };\n//   EXPECT_THAT(user_ids, Not(Each(Eq(::std::string(\"tom\")))));\ntemplate <typename M>\ninline internal::EachMatcher<M> Each(M matcher) {\n  return internal::EachMatcher<M>(matcher);\n}\n\n// Key(inner_matcher) matches an std::pair whose 'first' field matches\n// inner_matcher.  For example, Contains(Key(Ge(5))) can be used to match an\n// std::map that contains at least one element whose key is >= 5.\ntemplate <typename M>\ninline internal::KeyMatcher<M> Key(M inner_matcher) {\n  return internal::KeyMatcher<M>(inner_matcher);\n}\n\n// Pair(first_matcher, second_matcher) matches a std::pair whose 'first' field\n// matches first_matcher and whose 'second' field matches second_matcher.  For\n// example, EXPECT_THAT(map_type, ElementsAre(Pair(Ge(5), \"foo\"))) can be used\n// to match a std::map<int, string> that contains exactly one element whose key\n// is >= 5 and whose value equals \"foo\".\ntemplate <typename FirstMatcher, typename SecondMatcher>\ninline internal::PairMatcher<FirstMatcher, SecondMatcher>\nPair(FirstMatcher first_matcher, SecondMatcher second_matcher) {\n  return internal::PairMatcher<FirstMatcher, SecondMatcher>(\n      first_matcher, second_matcher);\n}\n\n// Returns a predicate that is satisfied by anything that matches the\n// given matcher.\ntemplate <typename M>\ninline internal::MatcherAsPredicate<M> Matches(M matcher) {\n  return internal::MatcherAsPredicate<M>(matcher);\n}\n\n// Returns true iff the value matches the matcher.\ntemplate <typename T, typename M>\ninline bool Value(const T& value, M matcher) {\n  return testing::Matches(matcher)(value);\n}\n\n// Matches the value against the given matcher and explains the match\n// result to listener.\ntemplate <typename T, typename M>\ninline bool ExplainMatchResult(\n    M matcher, const T& value, MatchResultListener* listener) {\n  return SafeMatcherCast<const T&>(matcher).MatchAndExplain(value, listener);\n}\n\n#if GTEST_LANG_CXX11\n// Define variadic matcher versions. They are overloaded in\n// gmock-generated-matchers.h for the cases supported by pre C++11 compilers.\ntemplate <typename... Args>\ninline internal::AllOfMatcher<Args...> AllOf(const Args&... matchers) {\n  return internal::AllOfMatcher<Args...>(matchers...);\n}\n\ntemplate <typename... Args>\ninline internal::AnyOfMatcher<Args...> AnyOf(const Args&... matchers) {\n  return internal::AnyOfMatcher<Args...>(matchers...);\n}\n\n#endif  // GTEST_LANG_CXX11\n\n// AllArgs(m) is a synonym of m.  This is useful in\n//\n//   EXPECT_CALL(foo, Bar(_, _)).With(AllArgs(Eq()));\n//\n// which is easier to read than\n//\n//   EXPECT_CALL(foo, Bar(_, _)).With(Eq());\ntemplate <typename InnerMatcher>\ninline InnerMatcher AllArgs(const InnerMatcher& matcher) { return matcher; }\n\n// These macros allow using matchers to check values in Google Test\n// tests.  ASSERT_THAT(value, matcher) and EXPECT_THAT(value, matcher)\n// succeed iff the value matches the matcher.  If the assertion fails,\n// the value and the description of the matcher will be printed.\n#define ASSERT_THAT(value, matcher) ASSERT_PRED_FORMAT1(\\\n    ::testing::internal::MakePredicateFormatterFromMatcher(matcher), value)\n#define EXPECT_THAT(value, matcher) EXPECT_PRED_FORMAT1(\\\n    ::testing::internal::MakePredicateFormatterFromMatcher(matcher), value)\n\n}  // namespace testing\n\n// Include any custom callback matchers added by the local installation.\n// We must include this header at the end to make sure it can use the\n// declarations from this file.\n#include \"gmock/internal/custom/gmock-matchers.h\"\n#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_MATCHERS_H_\n"}, "38": {"id": 38, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-spec-builders.h", "content": "// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// This file implements the ON_CALL() and EXPECT_CALL() macros.\n//\n// A user can use the ON_CALL() macro to specify the default action of\n// a mock method.  The syntax is:\n//\n//   ON_CALL(mock_object, Method(argument-matchers))\n//       .With(multi-argument-matcher)\n//       .WillByDefault(action);\n//\n//  where the .With() clause is optional.\n//\n// A user can use the EXPECT_CALL() macro to specify an expectation on\n// a mock method.  The syntax is:\n//\n//   EXPECT_CALL(mock_object, Method(argument-matchers))\n//       .With(multi-argument-matchers)\n//       .Times(cardinality)\n//       .InSequence(sequences)\n//       .After(expectations)\n//       .WillOnce(action)\n//       .WillRepeatedly(action)\n//       .RetiresOnSaturation();\n//\n// where all clauses are optional, and .InSequence()/.After()/\n// .WillOnce() can appear any number of times.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_SPEC_BUILDERS_H_\n#define GMOCK_INCLUDE_GMOCK_GMOCK_SPEC_BUILDERS_H_\n\n#include <map>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\n#if GTEST_HAS_EXCEPTIONS\n# include <stdexcept>  // NOLINT\n#endif\n\n#include \"gmock/gmock-actions.h\"\n#include \"gmock/gmock-cardinalities.h\"\n#include \"gmock/gmock-matchers.h\"\n#include \"gmock/internal/gmock-internal-utils.h\"\n#include \"gmock/internal/gmock-port.h\"\n#include \"gtest/gtest.h\"\n\nnamespace testing {\n\n// An abstract handle of an expectation.\nclass Expectation;\n\n// A set of expectation handles.\nclass ExpectationSet;\n\n// Anything inside the 'internal' namespace IS INTERNAL IMPLEMENTATION\n// and MUST NOT BE USED IN USER CODE!!!\nnamespace internal {\n\n// Implements a mock function.\ntemplate <typename F> class FunctionMocker;\n\n// Base class for expectations.\nclass ExpectationBase;\n\n// Implements an expectation.\ntemplate <typename F> class TypedExpectation;\n\n// Helper class for testing the Expectation class template.\nclass ExpectationTester;\n\n// Base class for function mockers.\ntemplate <typename F> class FunctionMockerBase;\n\n// Protects the mock object registry (in class Mock), all function\n// mockers, and all expectations.\n//\n// The reason we don't use more fine-grained protection is: when a\n// mock function Foo() is called, it needs to consult its expectations\n// to see which one should be picked.  If another thread is allowed to\n// call a mock function (either Foo() or a different one) at the same\n// time, it could affect the \"retired\" attributes of Foo()'s\n// expectations when InSequence() is used, and thus affect which\n// expectation gets picked.  Therefore, we sequence all mock function\n// calls to ensure the integrity of the mock objects' states.\nGTEST_API_ GTEST_DECLARE_STATIC_MUTEX_(g_gmock_mutex);\n\n// Untyped base class for ActionResultHolder<R>.\nclass UntypedActionResultHolderBase;\n\n// Abstract base class of FunctionMockerBase.  This is the\n// type-agnostic part of the function mocker interface.  Its pure\n// virtual methods are implemented by FunctionMockerBase.\nclass GTEST_API_ UntypedFunctionMockerBase {\n public:\n  UntypedFunctionMockerBase();\n  virtual ~UntypedFunctionMockerBase();\n\n  // Verifies that all expectations on this mock function have been\n  // satisfied.  Reports one or more Google Test non-fatal failures\n  // and returns false if not.\n  bool VerifyAndClearExpectationsLocked()\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);\n\n  // Clears the ON_CALL()s set on this mock function.\n  virtual void ClearDefaultActionsLocked()\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) = 0;\n\n  // In all of the following Untyped* functions, it's the caller's\n  // responsibility to guarantee the correctness of the arguments'\n  // types.\n\n  // Performs the default action with the given arguments and returns\n  // the action's result.  The call description string will be used in\n  // the error message to describe the call in the case the default\n  // action fails.\n  // L = *\n  virtual UntypedActionResultHolderBase* UntypedPerformDefaultAction(\n      const void* untyped_args,\n      const string& call_description) const = 0;\n\n  // Performs the given action with the given arguments and returns\n  // the action's result.\n  // L = *\n  virtual UntypedActionResultHolderBase* UntypedPerformAction(\n      const void* untyped_action,\n      const void* untyped_args) const = 0;\n\n  // Writes a message that the call is uninteresting (i.e. neither\n  // explicitly expected nor explicitly unexpected) to the given\n  // ostream.\n  virtual void UntypedDescribeUninterestingCall(\n      const void* untyped_args,\n      ::std::ostream* os) const\n          GTEST_LOCK_EXCLUDED_(g_gmock_mutex) = 0;\n\n  // Returns the expectation that matches the given function arguments\n  // (or NULL is there's no match); when a match is found,\n  // untyped_action is set to point to the action that should be\n  // performed (or NULL if the action is \"do default\"), and\n  // is_excessive is modified to indicate whether the call exceeds the\n  // expected number.\n  virtual const ExpectationBase* UntypedFindMatchingExpectation(\n      const void* untyped_args,\n      const void** untyped_action, bool* is_excessive,\n      ::std::ostream* what, ::std::ostream* why)\n          GTEST_LOCK_EXCLUDED_(g_gmock_mutex) = 0;\n\n  // Prints the given function arguments to the ostream.\n  virtual void UntypedPrintArgs(const void* untyped_args,\n                                ::std::ostream* os) const = 0;\n\n  // Sets the mock object this mock method belongs to, and registers\n  // this information in the global mock registry.  Will be called\n  // whenever an EXPECT_CALL() or ON_CALL() is executed on this mock\n  // method.\n  // TODO(wan@google.com): rename to SetAndRegisterOwner().\n  void RegisterOwner(const void* mock_obj)\n      GTEST_LOCK_EXCLUDED_(g_gmock_mutex);\n\n  // Sets the mock object this mock method belongs to, and sets the\n  // name of the mock function.  Will be called upon each invocation\n  // of this mock function.\n  void SetOwnerAndName(const void* mock_obj, const char* name)\n      GTEST_LOCK_EXCLUDED_(g_gmock_mutex);\n\n  // Returns the mock object this mock method belongs to.  Must be\n  // called after RegisterOwner() or SetOwnerAndName() has been\n  // called.\n  const void* MockObject() const\n      GTEST_LOCK_EXCLUDED_(g_gmock_mutex);\n\n  // Returns the name of this mock method.  Must be called after\n  // SetOwnerAndName() has been called.\n  const char* Name() const\n      GTEST_LOCK_EXCLUDED_(g_gmock_mutex);\n\n  // Returns the result of invoking this mock function with the given\n  // arguments.  This function can be safely called from multiple\n  // threads concurrently.  The caller is responsible for deleting the\n  // result.\n  UntypedActionResultHolderBase* UntypedInvokeWith(\n      const void* untyped_args)\n          GTEST_LOCK_EXCLUDED_(g_gmock_mutex);\n\n protected:\n  typedef std::vector<const void*> UntypedOnCallSpecs;\n\n  typedef std::vector<internal::linked_ptr<ExpectationBase> >\n  UntypedExpectations;\n\n  // Returns an Expectation object that references and co-owns exp,\n  // which must be an expectation on this mock function.\n  Expectation GetHandleOf(ExpectationBase* exp);\n\n  // Address of the mock object this mock method belongs to.  Only\n  // valid after this mock method has been called or\n  // ON_CALL/EXPECT_CALL has been invoked on it.\n  const void* mock_obj_;  // Protected by g_gmock_mutex.\n\n  // Name of the function being mocked.  Only valid after this mock\n  // method has been called.\n  const char* name_;  // Protected by g_gmock_mutex.\n\n  // All default action specs for this function mocker.\n  UntypedOnCallSpecs untyped_on_call_specs_;\n\n  // All expectations for this function mocker.\n  UntypedExpectations untyped_expectations_;\n};  // class UntypedFunctionMockerBase\n\n// Untyped base class for OnCallSpec<F>.\nclass UntypedOnCallSpecBase {\n public:\n  // The arguments are the location of the ON_CALL() statement.\n  UntypedOnCallSpecBase(const char* a_file, int a_line)\n      : file_(a_file), line_(a_line), last_clause_(kNone) {}\n\n  // Where in the source file was the default action spec defined?\n  const char* file() const { return file_; }\n  int line() const { return line_; }\n\n protected:\n  // Gives each clause in the ON_CALL() statement a name.\n  enum Clause {\n    // Do not change the order of the enum members!  The run-time\n    // syntax checking relies on it.\n    kNone,\n    kWith,\n    kWillByDefault\n  };\n\n  // Asserts that the ON_CALL() statement has a certain property.\n  void AssertSpecProperty(bool property, const string& failure_message) const {\n    Assert(property, file_, line_, failure_message);\n  }\n\n  // Expects that the ON_CALL() statement has a certain property.\n  void ExpectSpecProperty(bool property, const string& failure_message) const {\n    Expect(property, file_, line_, failure_message);\n  }\n\n  const char* file_;\n  int line_;\n\n  // The last clause in the ON_CALL() statement as seen so far.\n  // Initially kNone and changes as the statement is parsed.\n  Clause last_clause_;\n};  // class UntypedOnCallSpecBase\n\n// This template class implements an ON_CALL spec.\ntemplate <typename F>\nclass OnCallSpec : public UntypedOnCallSpecBase {\n public:\n  typedef typename Function<F>::ArgumentTuple ArgumentTuple;\n  typedef typename Function<F>::ArgumentMatcherTuple ArgumentMatcherTuple;\n\n  // Constructs an OnCallSpec object from the information inside\n  // the parenthesis of an ON_CALL() statement.\n  OnCallSpec(const char* a_file, int a_line,\n             const ArgumentMatcherTuple& matchers)\n      : UntypedOnCallSpecBase(a_file, a_line),\n        matchers_(matchers),\n        // By default, extra_matcher_ should match anything.  However,\n        // we cannot initialize it with _ as that triggers a compiler\n        // bug in Symbian's C++ compiler (cannot decide between two\n        // overloaded constructors of Matcher<const ArgumentTuple&>).\n        extra_matcher_(A<const ArgumentTuple&>()) {\n  }\n\n  // Implements the .With() clause.\n  OnCallSpec& With(const Matcher<const ArgumentTuple&>& m) {\n    // Makes sure this is called at most once.\n    ExpectSpecProperty(last_clause_ < kWith,\n                       \".With() cannot appear \"\n                       \"more than once in an ON_CALL().\");\n    last_clause_ = kWith;\n\n    extra_matcher_ = m;\n    return *this;\n  }\n\n  // Implements the .WillByDefault() clause.\n  OnCallSpec& WillByDefault(const Action<F>& action) {\n    ExpectSpecProperty(last_clause_ < kWillByDefault,\n                       \".WillByDefault() must appear \"\n                       \"exactly once in an ON_CALL().\");\n    last_clause_ = kWillByDefault;\n\n    ExpectSpecProperty(!action.IsDoDefault(),\n                       \"DoDefault() cannot be used in ON_CALL().\");\n    action_ = action;\n    return *this;\n  }\n\n  // Returns true iff the given arguments match the matchers.\n  bool Matches(const ArgumentTuple& args) const {\n    return TupleMatches(matchers_, args) && extra_matcher_.Matches(args);\n  }\n\n  // Returns the action specified by the user.\n  const Action<F>& GetAction() const {\n    AssertSpecProperty(last_clause_ == kWillByDefault,\n                       \".WillByDefault() must appear exactly \"\n                       \"once in an ON_CALL().\");\n    return action_;\n  }\n\n private:\n  // The information in statement\n  //\n  //   ON_CALL(mock_object, Method(matchers))\n  //       .With(multi-argument-matcher)\n  //       .WillByDefault(action);\n  //\n  // is recorded in the data members like this:\n  //\n  //   source file that contains the statement => file_\n  //   line number of the statement            => line_\n  //   matchers                                => matchers_\n  //   multi-argument-matcher                  => extra_matcher_\n  //   action                                  => action_\n  ArgumentMatcherTuple matchers_;\n  Matcher<const ArgumentTuple&> extra_matcher_;\n  Action<F> action_;\n};  // class OnCallSpec\n\n// Possible reactions on uninteresting calls.\nenum CallReaction {\n  kAllow,\n  kWarn,\n  kFail,\n  kDefault = kWarn  // By default, warn about uninteresting calls.\n};\n\n}  // namespace internal\n\n// Utilities for manipulating mock objects.\nclass GTEST_API_ Mock {\n public:\n  // The following public methods can be called concurrently.\n\n  // Tells Google Mock to ignore mock_obj when checking for leaked\n  // mock objects.\n  static void AllowLeak(const void* mock_obj)\n      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);\n\n  // Verifies and clears all expectations on the given mock object.\n  // If the expectations aren't satisfied, generates one or more\n  // Google Test non-fatal failures and returns false.\n  static bool VerifyAndClearExpectations(void* mock_obj)\n      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);\n\n  // Verifies all expectations on the given mock object and clears its\n  // default actions and expectations.  Returns true iff the\n  // verification was successful.\n  static bool VerifyAndClear(void* mock_obj)\n      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);\n\n private:\n  friend class internal::UntypedFunctionMockerBase;\n\n  // Needed for a function mocker to register itself (so that we know\n  // how to clear a mock object).\n  template <typename F>\n  friend class internal::FunctionMockerBase;\n\n  template <typename M>\n  friend class NiceMock;\n\n  template <typename M>\n  friend class NaggyMock;\n\n  template <typename M>\n  friend class StrictMock;\n\n  // Tells Google Mock to allow uninteresting calls on the given mock\n  // object.\n  static void AllowUninterestingCalls(const void* mock_obj)\n      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);\n\n  // Tells Google Mock to warn the user about uninteresting calls on\n  // the given mock object.\n  static void WarnUninterestingCalls(const void* mock_obj)\n      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);\n\n  // Tells Google Mock to fail uninteresting calls on the given mock\n  // object.\n  static void FailUninterestingCalls(const void* mock_obj)\n      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);\n\n  // Tells Google Mock the given mock object is being destroyed and\n  // its entry in the call-reaction table should be removed.\n  static void UnregisterCallReaction(const void* mock_obj)\n      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);\n\n  // Returns the reaction Google Mock will have on uninteresting calls\n  // made on the given mock object.\n  static internal::CallReaction GetReactionOnUninterestingCalls(\n      const void* mock_obj)\n          GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);\n\n  // Verifies that all expectations on the given mock object have been\n  // satisfied.  Reports one or more Google Test non-fatal failures\n  // and returns false if not.\n  static bool VerifyAndClearExpectationsLocked(void* mock_obj)\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(internal::g_gmock_mutex);\n\n  // Clears all ON_CALL()s set on the given mock object.\n  static void ClearDefaultActionsLocked(void* mock_obj)\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(internal::g_gmock_mutex);\n\n  // Registers a mock object and a mock method it owns.\n  static void Register(\n      const void* mock_obj,\n      internal::UntypedFunctionMockerBase* mocker)\n          GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);\n\n  // Tells Google Mock where in the source code mock_obj is used in an\n  // ON_CALL or EXPECT_CALL.  In case mock_obj is leaked, this\n  // information helps the user identify which object it is.\n  static void RegisterUseByOnCallOrExpectCall(\n      const void* mock_obj, const char* file, int line)\n          GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);\n\n  // Unregisters a mock method; removes the owning mock object from\n  // the registry when the last mock method associated with it has\n  // been unregistered.  This is called only in the destructor of\n  // FunctionMockerBase.\n  static void UnregisterLocked(internal::UntypedFunctionMockerBase* mocker)\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(internal::g_gmock_mutex);\n};  // class Mock\n\n// An abstract handle of an expectation.  Useful in the .After()\n// clause of EXPECT_CALL() for setting the (partial) order of\n// expectations.  The syntax:\n//\n//   Expectation e1 = EXPECT_CALL(...)...;\n//   EXPECT_CALL(...).After(e1)...;\n//\n// sets two expectations where the latter can only be matched after\n// the former has been satisfied.\n//\n// Notes:\n//   - This class is copyable and has value semantics.\n//   - Constness is shallow: a const Expectation object itself cannot\n//     be modified, but the mutable methods of the ExpectationBase\n//     object it references can be called via expectation_base().\n//   - The constructors and destructor are defined out-of-line because\n//     the Symbian WINSCW compiler wants to otherwise instantiate them\n//     when it sees this class definition, at which point it doesn't have\n//     ExpectationBase available yet, leading to incorrect destruction\n//     in the linked_ptr (or compilation errors if using a checking\n//     linked_ptr).\nclass GTEST_API_ Expectation {\n public:\n  // Constructs a null object that doesn't reference any expectation.\n  Expectation();\n\n  ~Expectation();\n\n  // This single-argument ctor must not be explicit, in order to support the\n  //   Expectation e = EXPECT_CALL(...);\n  // syntax.\n  //\n  // A TypedExpectation object stores its pre-requisites as\n  // Expectation objects, and needs to call the non-const Retire()\n  // method on the ExpectationBase objects they reference.  Therefore\n  // Expectation must receive a *non-const* reference to the\n  // ExpectationBase object.\n  Expectation(internal::ExpectationBase& exp);  // NOLINT\n\n  // The compiler-generated copy ctor and operator= work exactly as\n  // intended, so we don't need to define our own.\n\n  // Returns true iff rhs references the same expectation as this object does.\n  bool operator==(const Expectation& rhs) const {\n    return expectation_base_ == rhs.expectation_base_;\n  }\n\n  bool operator!=(const Expectation& rhs) const { return !(*this == rhs); }\n\n private:\n  friend class ExpectationSet;\n  friend class Sequence;\n  friend class ::testing::internal::ExpectationBase;\n  friend class ::testing::internal::UntypedFunctionMockerBase;\n\n  template <typename F>\n  friend class ::testing::internal::FunctionMockerBase;\n\n  template <typename F>\n  friend class ::testing::internal::TypedExpectation;\n\n  // This comparator is needed for putting Expectation objects into a set.\n  class Less {\n   public:\n    bool operator()(const Expectation& lhs, const Expectation& rhs) const {\n      return lhs.expectation_base_.get() < rhs.expectation_base_.get();\n    }\n  };\n\n  typedef ::std::set<Expectation, Less> Set;\n\n  Expectation(\n      const internal::linked_ptr<internal::ExpectationBase>& expectation_base);\n\n  // Returns the expectation this object references.\n  const internal::linked_ptr<internal::ExpectationBase>&\n  expectation_base() const {\n    return expectation_base_;\n  }\n\n  // A linked_ptr that co-owns the expectation this handle references.\n  internal::linked_ptr<internal::ExpectationBase> expectation_base_;\n};\n\n// A set of expectation handles.  Useful in the .After() clause of\n// EXPECT_CALL() for setting the (partial) order of expectations.  The\n// syntax:\n//\n//   ExpectationSet es;\n//   es += EXPECT_CALL(...)...;\n//   es += EXPECT_CALL(...)...;\n//   EXPECT_CALL(...).After(es)...;\n//\n// sets three expectations where the last one can only be matched\n// after the first two have both been satisfied.\n//\n// This class is copyable and has value semantics.\nclass ExpectationSet {\n public:\n  // A bidirectional iterator that can read a const element in the set.\n  typedef Expectation::Set::const_iterator const_iterator;\n\n  // An object stored in the set.  This is an alias of Expectation.\n  typedef Expectation::Set::value_type value_type;\n\n  // Constructs an empty set.\n  ExpectationSet() {}\n\n  // This single-argument ctor must not be explicit, in order to support the\n  //   ExpectationSet es = EXPECT_CALL(...);\n  // syntax.\n  ExpectationSet(internal::ExpectationBase& exp) {  // NOLINT\n    *this += Expectation(exp);\n  }\n\n  // This single-argument ctor implements implicit conversion from\n  // Expectation and thus must not be explicit.  This allows either an\n  // Expectation or an ExpectationSet to be used in .After().\n  ExpectationSet(const Expectation& e) {  // NOLINT\n    *this += e;\n  }\n\n  // The compiler-generator ctor and operator= works exactly as\n  // intended, so we don't need to define our own.\n\n  // Returns true iff rhs contains the same set of Expectation objects\n  // as this does.\n  bool operator==(const ExpectationSet& rhs) const {\n    return expectations_ == rhs.expectations_;\n  }\n\n  bool operator!=(const ExpectationSet& rhs) const { return !(*this == rhs); }\n\n  // Implements the syntax\n  //   expectation_set += EXPECT_CALL(...);\n  ExpectationSet& operator+=(const Expectation& e) {\n    expectations_.insert(e);\n    return *this;\n  }\n\n  int size() const { return static_cast<int>(expectations_.size()); }\n\n  const_iterator begin() const { return expectations_.begin(); }\n  const_iterator end() const { return expectations_.end(); }\n\n private:\n  Expectation::Set expectations_;\n};\n\n\n// Sequence objects are used by a user to specify the relative order\n// in which the expectations should match.  They are copyable (we rely\n// on the compiler-defined copy constructor and assignment operator).\nclass GTEST_API_ Sequence {\n public:\n  // Constructs an empty sequence.\n  Sequence() : last_expectation_(new Expectation) {}\n\n  // Adds an expectation to this sequence.  The caller must ensure\n  // that no other thread is accessing this Sequence object.\n  void AddExpectation(const Expectation& expectation) const;\n\n private:\n  // The last expectation in this sequence.  We use a linked_ptr here\n  // because Sequence objects are copyable and we want the copies to\n  // be aliases.  The linked_ptr allows the copies to co-own and share\n  // the same Expectation object.\n  internal::linked_ptr<Expectation> last_expectation_;\n};  // class Sequence\n\n// An object of this type causes all EXPECT_CALL() statements\n// encountered in its scope to be put in an anonymous sequence.  The\n// work is done in the constructor and destructor.  You should only\n// create an InSequence object on the stack.\n//\n// The sole purpose for this class is to support easy definition of\n// sequential expectations, e.g.\n//\n//   {\n//     InSequence dummy;  // The name of the object doesn't matter.\n//\n//     // The following expectations must match in the order they appear.\n//     EXPECT_CALL(a, Bar())...;\n//     EXPECT_CALL(a, Baz())...;\n//     ...\n//     EXPECT_CALL(b, Xyz())...;\n//   }\n//\n// You can create InSequence objects in multiple threads, as long as\n// they are used to affect different mock objects.  The idea is that\n// each thread can create and set up its own mocks as if it's the only\n// thread.  However, for clarity of your tests we recommend you to set\n// up mocks in the main thread unless you have a good reason not to do\n// so.\nclass GTEST_API_ InSequence {\n public:\n  InSequence();\n  ~InSequence();\n private:\n  bool sequence_created_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(InSequence);  // NOLINT\n} GTEST_ATTRIBUTE_UNUSED_;\n\nnamespace internal {\n\n// Points to the implicit sequence introduced by a living InSequence\n// object (if any) in the current thread or NULL.\nGTEST_API_ extern ThreadLocal<Sequence*> g_gmock_implicit_sequence;\n\n// Base class for implementing expectations.\n//\n// There are two reasons for having a type-agnostic base class for\n// Expectation:\n//\n//   1. We need to store collections of expectations of different\n//   types (e.g. all pre-requisites of a particular expectation, all\n//   expectations in a sequence).  Therefore these expectation objects\n//   must share a common base class.\n//\n//   2. We can avoid binary code bloat by moving methods not depending\n//   on the template argument of Expectation to the base class.\n//\n// This class is internal and mustn't be used by user code directly.\nclass GTEST_API_ ExpectationBase {\n public:\n  // source_text is the EXPECT_CALL(...) source that created this Expectation.\n  ExpectationBase(const char* file, int line, const string& source_text);\n\n  virtual ~ExpectationBase();\n\n  // Where in the source file was the expectation spec defined?\n  const char* file() const { return file_; }\n  int line() const { return line_; }\n  const char* source_text() const { return source_text_.c_str(); }\n  // Returns the cardinality specified in the expectation spec.\n  const Cardinality& cardinality() const { return cardinality_; }\n\n  // Describes the source file location of this expectation.\n  void DescribeLocationTo(::std::ostream* os) const {\n    *os << FormatFileLocation(file(), line()) << \" \";\n  }\n\n  // Describes how many times a function call matching this\n  // expectation has occurred.\n  void DescribeCallCountTo(::std::ostream* os) const\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);\n\n  // If this mock method has an extra matcher (i.e. .With(matcher)),\n  // describes it to the ostream.\n  virtual void MaybeDescribeExtraMatcherTo(::std::ostream* os) = 0;\n\n protected:\n  friend class ::testing::Expectation;\n  friend class UntypedFunctionMockerBase;\n\n  enum Clause {\n    // Don't change the order of the enum members!\n    kNone,\n    kWith,\n    kTimes,\n    kInSequence,\n    kAfter,\n    kWillOnce,\n    kWillRepeatedly,\n    kRetiresOnSaturation\n  };\n\n  typedef std::vector<const void*> UntypedActions;\n\n  // Returns an Expectation object that references and co-owns this\n  // expectation.\n  virtual Expectation GetHandle() = 0;\n\n  // Asserts that the EXPECT_CALL() statement has the given property.\n  void AssertSpecProperty(bool property, const string& failure_message) const {\n    Assert(property, file_, line_, failure_message);\n  }\n\n  // Expects that the EXPECT_CALL() statement has the given property.\n  void ExpectSpecProperty(bool property, const string& failure_message) const {\n    Expect(property, file_, line_, failure_message);\n  }\n\n  // Explicitly specifies the cardinality of this expectation.  Used\n  // by the subclasses to implement the .Times() clause.\n  void SpecifyCardinality(const Cardinality& cardinality);\n\n  // Returns true iff the user specified the cardinality explicitly\n  // using a .Times().\n  bool cardinality_specified() const { return cardinality_specified_; }\n\n  // Sets the cardinality of this expectation spec.\n  void set_cardinality(const Cardinality& a_cardinality) {\n    cardinality_ = a_cardinality;\n  }\n\n  // The following group of methods should only be called after the\n  // EXPECT_CALL() statement, and only when g_gmock_mutex is held by\n  // the current thread.\n\n  // Retires all pre-requisites of this expectation.\n  void RetireAllPreRequisites()\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);\n\n  // Returns true iff this expectation is retired.\n  bool is_retired() const\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    return retired_;\n  }\n\n  // Retires this expectation.\n  void Retire()\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    retired_ = true;\n  }\n\n  // Returns true iff this expectation is satisfied.\n  bool IsSatisfied() const\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    return cardinality().IsSatisfiedByCallCount(call_count_);\n  }\n\n  // Returns true iff this expectation is saturated.\n  bool IsSaturated() const\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    return cardinality().IsSaturatedByCallCount(call_count_);\n  }\n\n  // Returns true iff this expectation is over-saturated.\n  bool IsOverSaturated() const\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    return cardinality().IsOverSaturatedByCallCount(call_count_);\n  }\n\n  // Returns true iff all pre-requisites of this expectation are satisfied.\n  bool AllPrerequisitesAreSatisfied() const\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);\n\n  // Adds unsatisfied pre-requisites of this expectation to 'result'.\n  void FindUnsatisfiedPrerequisites(ExpectationSet* result) const\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);\n\n  // Returns the number this expectation has been invoked.\n  int call_count() const\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    return call_count_;\n  }\n\n  // Increments the number this expectation has been invoked.\n  void IncrementCallCount()\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    call_count_++;\n  }\n\n  // Checks the action count (i.e. the number of WillOnce() and\n  // WillRepeatedly() clauses) against the cardinality if this hasn't\n  // been done before.  Prints a warning if there are too many or too\n  // few actions.\n  void CheckActionCountIfNotDone() const\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  friend class ::testing::Sequence;\n  friend class ::testing::internal::ExpectationTester;\n\n  template <typename Function>\n  friend class TypedExpectation;\n\n  // Implements the .Times() clause.\n  void UntypedTimes(const Cardinality& a_cardinality);\n\n  // This group of fields are part of the spec and won't change after\n  // an EXPECT_CALL() statement finishes.\n  const char* file_;          // The file that contains the expectation.\n  int line_;                  // The line number of the expectation.\n  const string source_text_;  // The EXPECT_CALL(...) source text.\n  // True iff the cardinality is specified explicitly.\n  bool cardinality_specified_;\n  Cardinality cardinality_;            // The cardinality of the expectation.\n  // The immediate pre-requisites (i.e. expectations that must be\n  // satisfied before this expectation can be matched) of this\n  // expectation.  We use linked_ptr in the set because we want an\n  // Expectation object to be co-owned by its FunctionMocker and its\n  // successors.  This allows multiple mock objects to be deleted at\n  // different times.\n  ExpectationSet immediate_prerequisites_;\n\n  // This group of fields are the current state of the expectation,\n  // and can change as the mock function is called.\n  int call_count_;  // How many times this expectation has been invoked.\n  bool retired_;    // True iff this expectation has retired.\n  UntypedActions untyped_actions_;\n  bool extra_matcher_specified_;\n  bool repeated_action_specified_;  // True if a WillRepeatedly() was specified.\n  bool retires_on_saturation_;\n  Clause last_clause_;\n  mutable bool action_count_checked_;  // Under mutex_.\n  mutable Mutex mutex_;  // Protects action_count_checked_.\n\n  GTEST_DISALLOW_ASSIGN_(ExpectationBase);\n};  // class ExpectationBase\n\n// Impements an expectation for the given function type.\ntemplate <typename F>\nclass TypedExpectation : public ExpectationBase {\n public:\n  typedef typename Function<F>::ArgumentTuple ArgumentTuple;\n  typedef typename Function<F>::ArgumentMatcherTuple ArgumentMatcherTuple;\n  typedef typename Function<F>::Result Result;\n\n  TypedExpectation(FunctionMockerBase<F>* owner,\n                   const char* a_file, int a_line, const string& a_source_text,\n                   const ArgumentMatcherTuple& m)\n      : ExpectationBase(a_file, a_line, a_source_text),\n        owner_(owner),\n        matchers_(m),\n        // By default, extra_matcher_ should match anything.  However,\n        // we cannot initialize it with _ as that triggers a compiler\n        // bug in Symbian's C++ compiler (cannot decide between two\n        // overloaded constructors of Matcher<const ArgumentTuple&>).\n        extra_matcher_(A<const ArgumentTuple&>()),\n        repeated_action_(DoDefault()) {}\n\n  virtual ~TypedExpectation() {\n    // Check the validity of the action count if it hasn't been done\n    // yet (for example, if the expectation was never used).\n    CheckActionCountIfNotDone();\n    for (UntypedActions::const_iterator it = untyped_actions_.begin();\n         it != untyped_actions_.end(); ++it) {\n      delete static_cast<const Action<F>*>(*it);\n    }\n  }\n\n  // Implements the .With() clause.\n  TypedExpectation& With(const Matcher<const ArgumentTuple&>& m) {\n    if (last_clause_ == kWith) {\n      ExpectSpecProperty(false,\n                         \".With() cannot appear \"\n                         \"more than once in an EXPECT_CALL().\");\n    } else {\n      ExpectSpecProperty(last_clause_ < kWith,\n                         \".With() must be the first \"\n                         \"clause in an EXPECT_CALL().\");\n    }\n    last_clause_ = kWith;\n\n    extra_matcher_ = m;\n    extra_matcher_specified_ = true;\n    return *this;\n  }\n\n  // Implements the .Times() clause.\n  TypedExpectation& Times(const Cardinality& a_cardinality) {\n    ExpectationBase::UntypedTimes(a_cardinality);\n    return *this;\n  }\n\n  // Implements the .Times() clause.\n  TypedExpectation& Times(int n) {\n    return Times(Exactly(n));\n  }\n\n  // Implements the .InSequence() clause.\n  TypedExpectation& InSequence(const Sequence& s) {\n    ExpectSpecProperty(last_clause_ <= kInSequence,\n                       \".InSequence() cannot appear after .After(),\"\n                       \" .WillOnce(), .WillRepeatedly(), or \"\n                       \".RetiresOnSaturation().\");\n    last_clause_ = kInSequence;\n\n    s.AddExpectation(GetHandle());\n    return *this;\n  }\n  TypedExpectation& InSequence(const Sequence& s1, const Sequence& s2) {\n    return InSequence(s1).InSequence(s2);\n  }\n  TypedExpectation& InSequence(const Sequence& s1, const Sequence& s2,\n                               const Sequence& s3) {\n    return InSequence(s1, s2).InSequence(s3);\n  }\n  TypedExpectation& InSequence(const Sequence& s1, const Sequence& s2,\n                               const Sequence& s3, const Sequence& s4) {\n    return InSequence(s1, s2, s3).InSequence(s4);\n  }\n  TypedExpectation& InSequence(const Sequence& s1, const Sequence& s2,\n                               const Sequence& s3, const Sequence& s4,\n                               const Sequence& s5) {\n    return InSequence(s1, s2, s3, s4).InSequence(s5);\n  }\n\n  // Implements that .After() clause.\n  TypedExpectation& After(const ExpectationSet& s) {\n    ExpectSpecProperty(last_clause_ <= kAfter,\n                       \".After() cannot appear after .WillOnce(),\"\n                       \" .WillRepeatedly(), or \"\n                       \".RetiresOnSaturation().\");\n    last_clause_ = kAfter;\n\n    for (ExpectationSet::const_iterator it = s.begin(); it != s.end(); ++it) {\n      immediate_prerequisites_ += *it;\n    }\n    return *this;\n  }\n  TypedExpectation& After(const ExpectationSet& s1, const ExpectationSet& s2) {\n    return After(s1).After(s2);\n  }\n  TypedExpectation& After(const ExpectationSet& s1, const ExpectationSet& s2,\n                          const ExpectationSet& s3) {\n    return After(s1, s2).After(s3);\n  }\n  TypedExpectation& After(const ExpectationSet& s1, const ExpectationSet& s2,\n                          const ExpectationSet& s3, const ExpectationSet& s4) {\n    return After(s1, s2, s3).After(s4);\n  }\n  TypedExpectation& After(const ExpectationSet& s1, const ExpectationSet& s2,\n                          const ExpectationSet& s3, const ExpectationSet& s4,\n                          const ExpectationSet& s5) {\n    return After(s1, s2, s3, s4).After(s5);\n  }\n\n  // Implements the .WillOnce() clause.\n  TypedExpectation& WillOnce(const Action<F>& action) {\n    ExpectSpecProperty(last_clause_ <= kWillOnce,\n                       \".WillOnce() cannot appear after \"\n                       \".WillRepeatedly() or .RetiresOnSaturation().\");\n    last_clause_ = kWillOnce;\n\n    untyped_actions_.push_back(new Action<F>(action));\n    if (!cardinality_specified()) {\n      set_cardinality(Exactly(static_cast<int>(untyped_actions_.size())));\n    }\n    return *this;\n  }\n\n  // Implements the .WillRepeatedly() clause.\n  TypedExpectation& WillRepeatedly(const Action<F>& action) {\n    if (last_clause_ == kWillRepeatedly) {\n      ExpectSpecProperty(false,\n                         \".WillRepeatedly() cannot appear \"\n                         \"more than once in an EXPECT_CALL().\");\n    } else {\n      ExpectSpecProperty(last_clause_ < kWillRepeatedly,\n                         \".WillRepeatedly() cannot appear \"\n                         \"after .RetiresOnSaturation().\");\n    }\n    last_clause_ = kWillRepeatedly;\n    repeated_action_specified_ = true;\n\n    repeated_action_ = action;\n    if (!cardinality_specified()) {\n      set_cardinality(AtLeast(static_cast<int>(untyped_actions_.size())));\n    }\n\n    // Now that no more action clauses can be specified, we check\n    // whether their count makes sense.\n    CheckActionCountIfNotDone();\n    return *this;\n  }\n\n  // Implements the .RetiresOnSaturation() clause.\n  TypedExpectation& RetiresOnSaturation() {\n    ExpectSpecProperty(last_clause_ < kRetiresOnSaturation,\n                       \".RetiresOnSaturation() cannot appear \"\n                       \"more than once.\");\n    last_clause_ = kRetiresOnSaturation;\n    retires_on_saturation_ = true;\n\n    // Now that no more action clauses can be specified, we check\n    // whether their count makes sense.\n    CheckActionCountIfNotDone();\n    return *this;\n  }\n\n  // Returns the matchers for the arguments as specified inside the\n  // EXPECT_CALL() macro.\n  const ArgumentMatcherTuple& matchers() const {\n    return matchers_;\n  }\n\n  // Returns the matcher specified by the .With() clause.\n  const Matcher<const ArgumentTuple&>& extra_matcher() const {\n    return extra_matcher_;\n  }\n\n  // Returns the action specified by the .WillRepeatedly() clause.\n  const Action<F>& repeated_action() const { return repeated_action_; }\n\n  // If this mock method has an extra matcher (i.e. .With(matcher)),\n  // describes it to the ostream.\n  virtual void MaybeDescribeExtraMatcherTo(::std::ostream* os) {\n    if (extra_matcher_specified_) {\n      *os << \"    Expected args: \";\n      extra_matcher_.DescribeTo(os);\n      *os << \"\\n\";\n    }\n  }\n\n private:\n  template <typename Function>\n  friend class FunctionMockerBase;\n\n  // Returns an Expectation object that references and co-owns this\n  // expectation.\n  virtual Expectation GetHandle() {\n    return owner_->GetHandleOf(this);\n  }\n\n  // The following methods will be called only after the EXPECT_CALL()\n  // statement finishes and when the current thread holds\n  // g_gmock_mutex.\n\n  // Returns true iff this expectation matches the given arguments.\n  bool Matches(const ArgumentTuple& args) const\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    return TupleMatches(matchers_, args) && extra_matcher_.Matches(args);\n  }\n\n  // Returns true iff this expectation should handle the given arguments.\n  bool ShouldHandleArguments(const ArgumentTuple& args) const\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n\n    // In case the action count wasn't checked when the expectation\n    // was defined (e.g. if this expectation has no WillRepeatedly()\n    // or RetiresOnSaturation() clause), we check it when the\n    // expectation is used for the first time.\n    CheckActionCountIfNotDone();\n    return !is_retired() && AllPrerequisitesAreSatisfied() && Matches(args);\n  }\n\n  // Describes the result of matching the arguments against this\n  // expectation to the given ostream.\n  void ExplainMatchResultTo(\n      const ArgumentTuple& args,\n      ::std::ostream* os) const\n          GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n\n    if (is_retired()) {\n      *os << \"         Expected: the expectation is active\\n\"\n          << \"           Actual: it is retired\\n\";\n    } else if (!Matches(args)) {\n      if (!TupleMatches(matchers_, args)) {\n        ExplainMatchFailureTupleTo(matchers_, args, os);\n      }\n      StringMatchResultListener listener;\n      if (!extra_matcher_.MatchAndExplain(args, &listener)) {\n        *os << \"    Expected args: \";\n        extra_matcher_.DescribeTo(os);\n        *os << \"\\n           Actual: don't match\";\n\n        internal::PrintIfNotEmpty(listener.str(), os);\n        *os << \"\\n\";\n      }\n    } else if (!AllPrerequisitesAreSatisfied()) {\n      *os << \"         Expected: all pre-requisites are satisfied\\n\"\n          << \"           Actual: the following immediate pre-requisites \"\n          << \"are not satisfied:\\n\";\n      ExpectationSet unsatisfied_prereqs;\n      FindUnsatisfiedPrerequisites(&unsatisfied_prereqs);\n      int i = 0;\n      for (ExpectationSet::const_iterator it = unsatisfied_prereqs.begin();\n           it != unsatisfied_prereqs.end(); ++it) {\n        it->expectation_base()->DescribeLocationTo(os);\n        *os << \"pre-requisite #\" << i++ << \"\\n\";\n      }\n      *os << \"                   (end of pre-requisites)\\n\";\n    } else {\n      // This line is here just for completeness' sake.  It will never\n      // be executed as currently the ExplainMatchResultTo() function\n      // is called only when the mock function call does NOT match the\n      // expectation.\n      *os << \"The call matches the expectation.\\n\";\n    }\n  }\n\n  // Returns the action that should be taken for the current invocation.\n  const Action<F>& GetCurrentAction(\n      const FunctionMockerBase<F>* mocker,\n      const ArgumentTuple& args) const\n          GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    const int count = call_count();\n    Assert(count >= 1, __FILE__, __LINE__,\n           \"call_count() is <= 0 when GetCurrentAction() is \"\n           \"called - this should never happen.\");\n\n    const int action_count = static_cast<int>(untyped_actions_.size());\n    if (action_count > 0 && !repeated_action_specified_ &&\n        count > action_count) {\n      // If there is at least one WillOnce() and no WillRepeatedly(),\n      // we warn the user when the WillOnce() clauses ran out.\n      ::std::stringstream ss;\n      DescribeLocationTo(&ss);\n      ss << \"Actions ran out in \" << source_text() << \"...\\n\"\n         << \"Called \" << count << \" times, but only \"\n         << action_count << \" WillOnce()\"\n         << (action_count == 1 ? \" is\" : \"s are\") << \" specified - \";\n      mocker->DescribeDefaultActionTo(args, &ss);\n      Log(kWarning, ss.str(), 1);\n    }\n\n    return count <= action_count ?\n        *static_cast<const Action<F>*>(untyped_actions_[count - 1]) :\n        repeated_action();\n  }\n\n  // Given the arguments of a mock function call, if the call will\n  // over-saturate this expectation, returns the default action;\n  // otherwise, returns the next action in this expectation.  Also\n  // describes *what* happened to 'what', and explains *why* Google\n  // Mock does it to 'why'.  This method is not const as it calls\n  // IncrementCallCount().  A return value of NULL means the default\n  // action.\n  const Action<F>* GetActionForArguments(\n      const FunctionMockerBase<F>* mocker,\n      const ArgumentTuple& args,\n      ::std::ostream* what,\n      ::std::ostream* why)\n          GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    if (IsSaturated()) {\n      // We have an excessive call.\n      IncrementCallCount();\n      *what << \"Mock function called more times than expected - \";\n      mocker->DescribeDefaultActionTo(args, what);\n      DescribeCallCountTo(why);\n\n      // TODO(wan@google.com): allow the user to control whether\n      // unexpected calls should fail immediately or continue using a\n      // flag --gmock_unexpected_calls_are_fatal.\n      return NULL;\n    }\n\n    IncrementCallCount();\n    RetireAllPreRequisites();\n\n    if (retires_on_saturation_ && IsSaturated()) {\n      Retire();\n    }\n\n    // Must be done after IncrementCount()!\n    *what << \"Mock function call matches \" << source_text() <<\"...\\n\";\n    return &(GetCurrentAction(mocker, args));\n  }\n\n  // All the fields below won't change once the EXPECT_CALL()\n  // statement finishes.\n  FunctionMockerBase<F>* const owner_;\n  ArgumentMatcherTuple matchers_;\n  Matcher<const ArgumentTuple&> extra_matcher_;\n  Action<F> repeated_action_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TypedExpectation);\n};  // class TypedExpectation\n\n// A MockSpec object is used by ON_CALL() or EXPECT_CALL() for\n// specifying the default behavior of, or expectation on, a mock\n// function.\n\n// Note: class MockSpec really belongs to the ::testing namespace.\n// However if we define it in ::testing, MSVC will complain when\n// classes in ::testing::internal declare it as a friend class\n// template.  To workaround this compiler bug, we define MockSpec in\n// ::testing::internal and import it into ::testing.\n\n// Logs a message including file and line number information.\nGTEST_API_ void LogWithLocation(testing::internal::LogSeverity severity,\n                                const char* file, int line,\n                                const string& message);\n\ntemplate <typename F>\nclass MockSpec {\n public:\n  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n  typedef typename internal::Function<F>::ArgumentMatcherTuple\n      ArgumentMatcherTuple;\n\n  // Constructs a MockSpec object, given the function mocker object\n  // that the spec is associated with.\n  explicit MockSpec(internal::FunctionMockerBase<F>* function_mocker)\n      : function_mocker_(function_mocker) {}\n\n  // Adds a new default action spec to the function mocker and returns\n  // the newly created spec.\n  internal::OnCallSpec<F>& InternalDefaultActionSetAt(\n      const char* file, int line, const char* obj, const char* call) {\n    LogWithLocation(internal::kInfo, file, line,\n        string(\"ON_CALL(\") + obj + \", \" + call + \") invoked\");\n    return function_mocker_->AddNewOnCallSpec(file, line, matchers_);\n  }\n\n  // Adds a new expectation spec to the function mocker and returns\n  // the newly created spec.\n  internal::TypedExpectation<F>& InternalExpectedAt(\n      const char* file, int line, const char* obj, const char* call) {\n    const string source_text(string(\"EXPECT_CALL(\") + obj + \", \" + call + \")\");\n    LogWithLocation(internal::kInfo, file, line, source_text + \" invoked\");\n    return function_mocker_->AddNewExpectation(\n        file, line, source_text, matchers_);\n  }\n\n private:\n  template <typename Function>\n  friend class internal::FunctionMocker;\n\n  void SetMatchers(const ArgumentMatcherTuple& matchers) {\n    matchers_ = matchers;\n  }\n\n  // The function mocker that owns this spec.\n  internal::FunctionMockerBase<F>* const function_mocker_;\n  // The argument matchers specified in the spec.\n  ArgumentMatcherTuple matchers_;\n\n  GTEST_DISALLOW_ASSIGN_(MockSpec);\n};  // class MockSpec\n\n// Wrapper type for generically holding an ordinary value or lvalue reference.\n// If T is not a reference type, it must be copyable or movable.\n// ReferenceOrValueWrapper<T> is movable, and will also be copyable unless\n// T is a move-only value type (which means that it will always be copyable\n// if the current platform does not support move semantics).\n//\n// The primary template defines handling for values, but function header\n// comments describe the contract for the whole template (including\n// specializations).\ntemplate <typename T>\nclass ReferenceOrValueWrapper {\n public:\n  // Constructs a wrapper from the given value/reference.\n  explicit ReferenceOrValueWrapper(T value)\n      : value_(::testing::internal::move(value)) {\n  }\n\n  // Unwraps and returns the underlying value/reference, exactly as\n  // originally passed. The behavior of calling this more than once on\n  // the same object is unspecified.\n  T Unwrap() { return ::testing::internal::move(value_); }\n\n  // Provides nondestructive access to the underlying value/reference.\n  // Always returns a const reference (more precisely,\n  // const RemoveReference<T>&). The behavior of calling this after\n  // calling Unwrap on the same object is unspecified.\n  const T& Peek() const {\n    return value_;\n  }\n\n private:\n  T value_;\n};\n\n// Specialization for lvalue reference types. See primary template\n// for documentation.\ntemplate <typename T>\nclass ReferenceOrValueWrapper<T&> {\n public:\n  // Workaround for debatable pass-by-reference lint warning (c-library-team\n  // policy precludes NOLINT in this context)\n  typedef T& reference;\n  explicit ReferenceOrValueWrapper(reference ref)\n      : value_ptr_(&ref) {}\n  T& Unwrap() { return *value_ptr_; }\n  const T& Peek() const { return *value_ptr_; }\n\n private:\n  T* value_ptr_;\n};\n\n// MSVC warns about using 'this' in base member initializer list, so\n// we need to temporarily disable the warning.  We have to do it for\n// the entire class to suppress the warning, even though it's about\n// the constructor only.\n\n#ifdef _MSC_VER\n# pragma warning(push)          // Saves the current warning state.\n# pragma warning(disable:4355)  // Temporarily disables warning 4355.\n#endif  // _MSV_VER\n\n// C++ treats the void type specially.  For example, you cannot define\n// a void-typed variable or pass a void value to a function.\n// ActionResultHolder<T> holds a value of type T, where T must be a\n// copyable type or void (T doesn't need to be default-constructable).\n// It hides the syntactic difference between void and other types, and\n// is used to unify the code for invoking both void-returning and\n// non-void-returning mock functions.\n\n// Untyped base class for ActionResultHolder<T>.\nclass UntypedActionResultHolderBase {\n public:\n  virtual ~UntypedActionResultHolderBase() {}\n\n  // Prints the held value as an action's result to os.\n  virtual void PrintAsActionResult(::std::ostream* os) const = 0;\n};\n\n// This generic definition is used when T is not void.\ntemplate <typename T>\nclass ActionResultHolder : public UntypedActionResultHolderBase {\n public:\n  // Returns the held value. Must not be called more than once.\n  T Unwrap() {\n    return result_.Unwrap();\n  }\n\n  // Prints the held value as an action's result to os.\n  virtual void PrintAsActionResult(::std::ostream* os) const {\n    *os << \"\\n          Returns: \";\n    // T may be a reference type, so we don't use UniversalPrint().\n    UniversalPrinter<T>::Print(result_.Peek(), os);\n  }\n\n  // Performs the given mock function's default action and returns the\n  // result in a new-ed ActionResultHolder.\n  template <typename F>\n  static ActionResultHolder* PerformDefaultAction(\n      const FunctionMockerBase<F>* func_mocker,\n      const typename Function<F>::ArgumentTuple& args,\n      const string& call_description) {\n    return new ActionResultHolder(Wrapper(\n        func_mocker->PerformDefaultAction(args, call_description)));\n  }\n\n  // Performs the given action and returns the result in a new-ed\n  // ActionResultHolder.\n  template <typename F>\n  static ActionResultHolder*\n  PerformAction(const Action<F>& action,\n                const typename Function<F>::ArgumentTuple& args) {\n    return new ActionResultHolder(Wrapper(action.Perform(args)));\n  }\n\n private:\n  typedef ReferenceOrValueWrapper<T> Wrapper;\n\n  explicit ActionResultHolder(Wrapper result)\n      : result_(::testing::internal::move(result)) {\n  }\n\n  Wrapper result_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ActionResultHolder);\n};\n\n// Specialization for T = void.\ntemplate <>\nclass ActionResultHolder<void> : public UntypedActionResultHolderBase {\n public:\n  void Unwrap() { }\n\n  virtual void PrintAsActionResult(::std::ostream* /* os */) const {}\n\n  // Performs the given mock function's default action and returns ownership\n  // of an empty ActionResultHolder*.\n  template <typename F>\n  static ActionResultHolder* PerformDefaultAction(\n      const FunctionMockerBase<F>* func_mocker,\n      const typename Function<F>::ArgumentTuple& args,\n      const string& call_description) {\n    func_mocker->PerformDefaultAction(args, call_description);\n    return new ActionResultHolder;\n  }\n\n  // Performs the given action and returns ownership of an empty\n  // ActionResultHolder*.\n  template <typename F>\n  static ActionResultHolder* PerformAction(\n      const Action<F>& action,\n      const typename Function<F>::ArgumentTuple& args) {\n    action.Perform(args);\n    return new ActionResultHolder;\n  }\n\n private:\n  ActionResultHolder() {}\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ActionResultHolder);\n};\n\n// The base of the function mocker class for the given function type.\n// We put the methods in this class instead of its child to avoid code\n// bloat.\ntemplate <typename F>\nclass FunctionMockerBase : public UntypedFunctionMockerBase {\n public:\n  typedef typename Function<F>::Result Result;\n  typedef typename Function<F>::ArgumentTuple ArgumentTuple;\n  typedef typename Function<F>::ArgumentMatcherTuple ArgumentMatcherTuple;\n\n  FunctionMockerBase() : current_spec_(this) {}\n\n  // The destructor verifies that all expectations on this mock\n  // function have been satisfied.  If not, it will report Google Test\n  // non-fatal failures for the violations.\n  virtual ~FunctionMockerBase()\n        GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {\n    MutexLock l(&g_gmock_mutex);\n    VerifyAndClearExpectationsLocked();\n    Mock::UnregisterLocked(this);\n    ClearDefaultActionsLocked();\n  }\n\n  // Returns the ON_CALL spec that matches this mock function with the\n  // given arguments; returns NULL if no matching ON_CALL is found.\n  // L = *\n  const OnCallSpec<F>* FindOnCallSpec(\n      const ArgumentTuple& args) const {\n    for (UntypedOnCallSpecs::const_reverse_iterator it\n             = untyped_on_call_specs_.rbegin();\n         it != untyped_on_call_specs_.rend(); ++it) {\n      const OnCallSpec<F>* spec = static_cast<const OnCallSpec<F>*>(*it);\n      if (spec->Matches(args))\n        return spec;\n    }\n\n    return NULL;\n  }\n\n  // Performs the default action of this mock function on the given\n  // arguments and returns the result. Asserts (or throws if\n  // exceptions are enabled) with a helpful call descrption if there\n  // is no valid return value. This method doesn't depend on the\n  // mutable state of this object, and thus can be called concurrently\n  // without locking.\n  // L = *\n  Result PerformDefaultAction(const ArgumentTuple& args,\n                              const string& call_description) const {\n    const OnCallSpec<F>* const spec =\n        this->FindOnCallSpec(args);\n    if (spec != NULL) {\n      return spec->GetAction().Perform(args);\n    }\n    const string message = call_description +\n        \"\\n    The mock function has no default action \"\n        \"set, and its return type has no default value set.\";\n#if GTEST_HAS_EXCEPTIONS\n    if (!DefaultValue<Result>::Exists()) {\n      throw std::runtime_error(message);\n    }\n#else\n    Assert(DefaultValue<Result>::Exists(), \"\", -1, message);\n#endif\n    return DefaultValue<Result>::Get();\n  }\n\n  // Performs the default action with the given arguments and returns\n  // the action's result.  The call description string will be used in\n  // the error message to describe the call in the case the default\n  // action fails.  The caller is responsible for deleting the result.\n  // L = *\n  virtual UntypedActionResultHolderBase* UntypedPerformDefaultAction(\n      const void* untyped_args,  // must point to an ArgumentTuple\n      const string& call_description) const {\n    const ArgumentTuple& args =\n        *static_cast<const ArgumentTuple*>(untyped_args);\n    return ResultHolder::PerformDefaultAction(this, args, call_description);\n  }\n\n  // Performs the given action with the given arguments and returns\n  // the action's result.  The caller is responsible for deleting the\n  // result.\n  // L = *\n  virtual UntypedActionResultHolderBase* UntypedPerformAction(\n      const void* untyped_action, const void* untyped_args) const {\n    // Make a copy of the action before performing it, in case the\n    // action deletes the mock object (and thus deletes itself).\n    const Action<F> action = *static_cast<const Action<F>*>(untyped_action);\n    const ArgumentTuple& args =\n        *static_cast<const ArgumentTuple*>(untyped_args);\n    return ResultHolder::PerformAction(action, args);\n  }\n\n  // Implements UntypedFunctionMockerBase::ClearDefaultActionsLocked():\n  // clears the ON_CALL()s set on this mock function.\n  virtual void ClearDefaultActionsLocked()\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n\n    // Deleting our default actions may trigger other mock objects to be\n    // deleted, for example if an action contains a reference counted smart\n    // pointer to that mock object, and that is the last reference. So if we\n    // delete our actions within the context of the global mutex we may deadlock\n    // when this method is called again. Instead, make a copy of the set of\n    // actions to delete, clear our set within the mutex, and then delete the\n    // actions outside of the mutex.\n    UntypedOnCallSpecs specs_to_delete;\n    untyped_on_call_specs_.swap(specs_to_delete);\n\n    g_gmock_mutex.Unlock();\n    for (UntypedOnCallSpecs::const_iterator it =\n             specs_to_delete.begin();\n         it != specs_to_delete.end(); ++it) {\n      delete static_cast<const OnCallSpec<F>*>(*it);\n    }\n\n    // Lock the mutex again, since the caller expects it to be locked when we\n    // return.\n    g_gmock_mutex.Lock();\n  }\n\n protected:\n  template <typename Function>\n  friend class MockSpec;\n\n  typedef ActionResultHolder<Result> ResultHolder;\n\n  // Returns the result of invoking this mock function with the given\n  // arguments.  This function can be safely called from multiple\n  // threads concurrently.\n  Result InvokeWith(const ArgumentTuple& args)\n        GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {\n    scoped_ptr<ResultHolder> holder(\n        DownCast_<ResultHolder*>(this->UntypedInvokeWith(&args)));\n    return holder->Unwrap();\n  }\n\n  // Adds and returns a default action spec for this mock function.\n  OnCallSpec<F>& AddNewOnCallSpec(\n      const char* file, int line,\n      const ArgumentMatcherTuple& m)\n          GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {\n    Mock::RegisterUseByOnCallOrExpectCall(MockObject(), file, line);\n    OnCallSpec<F>* const on_call_spec = new OnCallSpec<F>(file, line, m);\n    untyped_on_call_specs_.push_back(on_call_spec);\n    return *on_call_spec;\n  }\n\n  // Adds and returns an expectation spec for this mock function.\n  TypedExpectation<F>& AddNewExpectation(\n      const char* file,\n      int line,\n      const string& source_text,\n      const ArgumentMatcherTuple& m)\n          GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {\n    Mock::RegisterUseByOnCallOrExpectCall(MockObject(), file, line);\n    TypedExpectation<F>* const expectation =\n        new TypedExpectation<F>(this, file, line, source_text, m);\n    const linked_ptr<ExpectationBase> untyped_expectation(expectation);\n    untyped_expectations_.push_back(untyped_expectation);\n\n    // Adds this expectation into the implicit sequence if there is one.\n    Sequence* const implicit_sequence = g_gmock_implicit_sequence.get();\n    if (implicit_sequence != NULL) {\n      implicit_sequence->AddExpectation(Expectation(untyped_expectation));\n    }\n\n    return *expectation;\n  }\n\n  // The current spec (either default action spec or expectation spec)\n  // being described on this function mocker.\n  MockSpec<F>& current_spec() { return current_spec_; }\n\n private:\n  template <typename Func> friend class TypedExpectation;\n\n  // Some utilities needed for implementing UntypedInvokeWith().\n\n  // Describes what default action will be performed for the given\n  // arguments.\n  // L = *\n  void DescribeDefaultActionTo(const ArgumentTuple& args,\n                               ::std::ostream* os) const {\n    const OnCallSpec<F>* const spec = FindOnCallSpec(args);\n\n    if (spec == NULL) {\n      *os << (internal::type_equals<Result, void>::value ?\n              \"returning directly.\\n\" :\n              \"returning default value.\\n\");\n    } else {\n      *os << \"taking default action specified at:\\n\"\n          << FormatFileLocation(spec->file(), spec->line()) << \"\\n\";\n    }\n  }\n\n  // Writes a message that the call is uninteresting (i.e. neither\n  // explicitly expected nor explicitly unexpected) to the given\n  // ostream.\n  virtual void UntypedDescribeUninterestingCall(\n      const void* untyped_args,\n      ::std::ostream* os) const\n          GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {\n    const ArgumentTuple& args =\n        *static_cast<const ArgumentTuple*>(untyped_args);\n    *os << \"Uninteresting mock function call - \";\n    DescribeDefaultActionTo(args, os);\n    *os << \"    Function call: \" << Name();\n    UniversalPrint(args, os);\n  }\n\n  // Returns the expectation that matches the given function arguments\n  // (or NULL is there's no match); when a match is found,\n  // untyped_action is set to point to the action that should be\n  // performed (or NULL if the action is \"do default\"), and\n  // is_excessive is modified to indicate whether the call exceeds the\n  // expected number.\n  //\n  // Critical section: We must find the matching expectation and the\n  // corresponding action that needs to be taken in an ATOMIC\n  // transaction.  Otherwise another thread may call this mock\n  // method in the middle and mess up the state.\n  //\n  // However, performing the action has to be left out of the critical\n  // section.  The reason is that we have no control on what the\n  // action does (it can invoke an arbitrary user function or even a\n  // mock function) and excessive locking could cause a dead lock.\n  virtual const ExpectationBase* UntypedFindMatchingExpectation(\n      const void* untyped_args,\n      const void** untyped_action, bool* is_excessive,\n      ::std::ostream* what, ::std::ostream* why)\n          GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {\n    const ArgumentTuple& args =\n        *static_cast<const ArgumentTuple*>(untyped_args);\n    MutexLock l(&g_gmock_mutex);\n    TypedExpectation<F>* exp = this->FindMatchingExpectationLocked(args);\n    if (exp == NULL) {  // A match wasn't found.\n      this->FormatUnexpectedCallMessageLocked(args, what, why);\n      return NULL;\n    }\n\n    // This line must be done before calling GetActionForArguments(),\n    // which will increment the call count for *exp and thus affect\n    // its saturation status.\n    *is_excessive = exp->IsSaturated();\n    const Action<F>* action = exp->GetActionForArguments(this, args, what, why);\n    if (action != NULL && action->IsDoDefault())\n      action = NULL;  // Normalize \"do default\" to NULL.\n    *untyped_action = action;\n    return exp;\n  }\n\n  // Prints the given function arguments to the ostream.\n  virtual void UntypedPrintArgs(const void* untyped_args,\n                                ::std::ostream* os) const {\n    const ArgumentTuple& args =\n        *static_cast<const ArgumentTuple*>(untyped_args);\n    UniversalPrint(args, os);\n  }\n\n  // Returns the expectation that matches the arguments, or NULL if no\n  // expectation matches them.\n  TypedExpectation<F>* FindMatchingExpectationLocked(\n      const ArgumentTuple& args) const\n          GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    for (typename UntypedExpectations::const_reverse_iterator it =\n             untyped_expectations_.rbegin();\n         it != untyped_expectations_.rend(); ++it) {\n      TypedExpectation<F>* const exp =\n          static_cast<TypedExpectation<F>*>(it->get());\n      if (exp->ShouldHandleArguments(args)) {\n        return exp;\n      }\n    }\n    return NULL;\n  }\n\n  // Returns a message that the arguments don't match any expectation.\n  void FormatUnexpectedCallMessageLocked(\n      const ArgumentTuple& args,\n      ::std::ostream* os,\n      ::std::ostream* why) const\n          GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    *os << \"\\nUnexpected mock function call - \";\n    DescribeDefaultActionTo(args, os);\n    PrintTriedExpectationsLocked(args, why);\n  }\n\n  // Prints a list of expectations that have been tried against the\n  // current mock function call.\n  void PrintTriedExpectationsLocked(\n      const ArgumentTuple& args,\n      ::std::ostream* why) const\n          GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    const int count = static_cast<int>(untyped_expectations_.size());\n    *why << \"Google Mock tried the following \" << count << \" \"\n         << (count == 1 ? \"expectation, but it didn't match\" :\n             \"expectations, but none matched\")\n         << \":\\n\";\n    for (int i = 0; i < count; i++) {\n      TypedExpectation<F>* const expectation =\n          static_cast<TypedExpectation<F>*>(untyped_expectations_[i].get());\n      *why << \"\\n\";\n      expectation->DescribeLocationTo(why);\n      if (count > 1) {\n        *why << \"tried expectation #\" << i << \": \";\n      }\n      *why << expectation->source_text() << \"...\\n\";\n      expectation->ExplainMatchResultTo(args, why);\n      expectation->DescribeCallCountTo(why);\n    }\n  }\n\n  // The current spec (either default action spec or expectation spec)\n  // being described on this function mocker.\n  MockSpec<F> current_spec_;\n\n  // There is no generally useful and implementable semantics of\n  // copying a mock object, so copying a mock is usually a user error.\n  // Thus we disallow copying function mockers.  If the user really\n  // wants to copy a mock object, he should implement his own copy\n  // operation, for example:\n  //\n  //   class MockFoo : public Foo {\n  //    public:\n  //     // Defines a copy constructor explicitly.\n  //     MockFoo(const MockFoo& src) {}\n  //     ...\n  //   };\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(FunctionMockerBase);\n};  // class FunctionMockerBase\n\n#ifdef _MSC_VER\n# pragma warning(pop)  // Restores the warning state.\n#endif  // _MSV_VER\n\n// Implements methods of FunctionMockerBase.\n\n// Verifies that all expectations on this mock function have been\n// satisfied.  Reports one or more Google Test non-fatal failures and\n// returns false if not.\n\n// Reports an uninteresting call (whose description is in msg) in the\n// manner specified by 'reaction'.\nvoid ReportUninterestingCall(CallReaction reaction, const string& msg);\n\n}  // namespace internal\n\n// The style guide prohibits \"using\" statements in a namespace scope\n// inside a header file.  However, the MockSpec class template is\n// meant to be defined in the ::testing namespace.  The following line\n// is just a trick for working around a bug in MSVC 8.0, which cannot\n// handle it if we define MockSpec in ::testing.\nusing internal::MockSpec;\n\n// Const(x) is a convenient function for obtaining a const reference\n// to x.  This is useful for setting expectations on an overloaded\n// const mock method, e.g.\n//\n//   class MockFoo : public FooInterface {\n//    public:\n//     MOCK_METHOD0(Bar, int());\n//     MOCK_CONST_METHOD0(Bar, int&());\n//   };\n//\n//   MockFoo foo;\n//   // Expects a call to non-const MockFoo::Bar().\n//   EXPECT_CALL(foo, Bar());\n//   // Expects a call to const MockFoo::Bar().\n//   EXPECT_CALL(Const(foo), Bar());\ntemplate <typename T>\ninline const T& Const(const T& x) { return x; }\n\n// Constructs an Expectation object that references and co-owns exp.\ninline Expectation::Expectation(internal::ExpectationBase& exp)  // NOLINT\n    : expectation_base_(exp.GetHandle().expectation_base()) {}\n\n}  // namespace testing\n\n// A separate macro is required to avoid compile errors when the name\n// of the method used in call is a result of macro expansion.\n// See CompilesWithMethodNameExpandedFromMacro tests in\n// internal/gmock-spec-builders_test.cc for more details.\n#define GMOCK_ON_CALL_IMPL_(obj, call) \\\n    ((obj).gmock_##call).InternalDefaultActionSetAt(__FILE__, __LINE__, \\\n                                                    #obj, #call)\n#define ON_CALL(obj, call) GMOCK_ON_CALL_IMPL_(obj, call)\n\n#define GMOCK_EXPECT_CALL_IMPL_(obj, call) \\\n    ((obj).gmock_##call).InternalExpectedAt(__FILE__, __LINE__, #obj, #call)\n#define EXPECT_CALL(obj, call) GMOCK_EXPECT_CALL_IMPL_(obj, call)\n\n#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_SPEC_BUILDERS_H_\n"}, "39": {"id": 39, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/internal/gmock-internal-utils.h", "content": "// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// This file defines some utilities useful for implementing Google\n// Mock.  They are subject to change without notice, so please DO NOT\n// USE THEM IN USER CODE.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_INTERNAL_UTILS_H_\n#define GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_INTERNAL_UTILS_H_\n\n#include <stdio.h>\n#include <ostream>  // NOLINT\n#include <string>\n\n#include \"gmock/internal/gmock-generated-internal-utils.h\"\n#include \"gmock/internal/gmock-port.h\"\n#include \"gtest/gtest.h\"\n\nnamespace testing {\nnamespace internal {\n\n// Converts an identifier name to a space-separated list of lower-case\n// words.  Each maximum substring of the form [A-Za-z][a-z]*|\\d+ is\n// treated as one word.  For example, both \"FooBar123\" and\n// \"foo_bar_123\" are converted to \"foo bar 123\".\nGTEST_API_ string ConvertIdentifierNameToWords(const char* id_name);\n\n// PointeeOf<Pointer>::type is the type of a value pointed to by a\n// Pointer, which can be either a smart pointer or a raw pointer.  The\n// following default implementation is for the case where Pointer is a\n// smart pointer.\ntemplate <typename Pointer>\nstruct PointeeOf {\n  // Smart pointer classes define type element_type as the type of\n  // their pointees.\n  typedef typename Pointer::element_type type;\n};\n// This specialization is for the raw pointer case.\ntemplate <typename T>\nstruct PointeeOf<T*> { typedef T type; };  // NOLINT\n\n// GetRawPointer(p) returns the raw pointer underlying p when p is a\n// smart pointer, or returns p itself when p is already a raw pointer.\n// The following default implementation is for the smart pointer case.\ntemplate <typename Pointer>\ninline const typename Pointer::element_type* GetRawPointer(const Pointer& p) {\n  return p.get();\n}\n// This overloaded version is for the raw pointer case.\ntemplate <typename Element>\ninline Element* GetRawPointer(Element* p) { return p; }\n\n// This comparator allows linked_ptr to be stored in sets.\ntemplate <typename T>\nstruct LinkedPtrLessThan {\n  bool operator()(const ::testing::internal::linked_ptr<T>& lhs,\n                  const ::testing::internal::linked_ptr<T>& rhs) const {\n    return lhs.get() < rhs.get();\n  }\n};\n\n// Symbian compilation can be done with wchar_t being either a native\n// type or a typedef.  Using Google Mock with OpenC without wchar_t\n// should require the definition of _STLP_NO_WCHAR_T.\n//\n// MSVC treats wchar_t as a native type usually, but treats it as the\n// same as unsigned short when the compiler option /Zc:wchar_t- is\n// specified.  It defines _NATIVE_WCHAR_T_DEFINED symbol when wchar_t\n// is a native type.\n#if (GTEST_OS_SYMBIAN && defined(_STLP_NO_WCHAR_T)) || \\\n    (defined(_MSC_VER) && !defined(_NATIVE_WCHAR_T_DEFINED))\n// wchar_t is a typedef.\n#else\n# define GMOCK_WCHAR_T_IS_NATIVE_ 1\n#endif\n\n// signed wchar_t and unsigned wchar_t are NOT in the C++ standard.\n// Using them is a bad practice and not portable.  So DON'T use them.\n//\n// Still, Google Mock is designed to work even if the user uses signed\n// wchar_t or unsigned wchar_t (obviously, assuming the compiler\n// supports them).\n//\n// To gcc,\n//   wchar_t == signed wchar_t != unsigned wchar_t == unsigned int\n#ifdef __GNUC__\n// signed/unsigned wchar_t are valid types.\n# define GMOCK_HAS_SIGNED_WCHAR_T_ 1\n#endif\n\n// In what follows, we use the term \"kind\" to indicate whether a type\n// is bool, an integer type (excluding bool), a floating-point type,\n// or none of them.  This categorization is useful for determining\n// when a matcher argument type can be safely converted to another\n// type in the implementation of SafeMatcherCast.\nenum TypeKind {\n  kBool, kInteger, kFloatingPoint, kOther\n};\n\n// KindOf<T>::value is the kind of type T.\ntemplate <typename T> struct KindOf {\n  enum { value = kOther };  // The default kind.\n};\n\n// This macro declares that the kind of 'type' is 'kind'.\n#define GMOCK_DECLARE_KIND_(type, kind) \\\n  template <> struct KindOf<type> { enum { value = kind }; }\n\nGMOCK_DECLARE_KIND_(bool, kBool);\n\n// All standard integer types.\nGMOCK_DECLARE_KIND_(char, kInteger);\nGMOCK_DECLARE_KIND_(signed char, kInteger);\nGMOCK_DECLARE_KIND_(unsigned char, kInteger);\nGMOCK_DECLARE_KIND_(short, kInteger);  // NOLINT\nGMOCK_DECLARE_KIND_(unsigned short, kInteger);  // NOLINT\nGMOCK_DECLARE_KIND_(int, kInteger);\nGMOCK_DECLARE_KIND_(unsigned int, kInteger);\nGMOCK_DECLARE_KIND_(long, kInteger);  // NOLINT\nGMOCK_DECLARE_KIND_(unsigned long, kInteger);  // NOLINT\n\n#if GMOCK_WCHAR_T_IS_NATIVE_\nGMOCK_DECLARE_KIND_(wchar_t, kInteger);\n#endif\n\n// Non-standard integer types.\nGMOCK_DECLARE_KIND_(Int64, kInteger);\nGMOCK_DECLARE_KIND_(UInt64, kInteger);\n\n// All standard floating-point types.\nGMOCK_DECLARE_KIND_(float, kFloatingPoint);\nGMOCK_DECLARE_KIND_(double, kFloatingPoint);\nGMOCK_DECLARE_KIND_(long double, kFloatingPoint);\n\n#undef GMOCK_DECLARE_KIND_\n\n// Evaluates to the kind of 'type'.\n#define GMOCK_KIND_OF_(type) \\\n  static_cast< ::testing::internal::TypeKind>( \\\n      ::testing::internal::KindOf<type>::value)\n\n// Evaluates to true iff integer type T is signed.\n#define GMOCK_IS_SIGNED_(T) (static_cast<T>(-1) < 0)\n\n// LosslessArithmeticConvertibleImpl<kFromKind, From, kToKind, To>::value\n// is true iff arithmetic type From can be losslessly converted to\n// arithmetic type To.\n//\n// It's the user's responsibility to ensure that both From and To are\n// raw (i.e. has no CV modifier, is not a pointer, and is not a\n// reference) built-in arithmetic types, kFromKind is the kind of\n// From, and kToKind is the kind of To; the value is\n// implementation-defined when the above pre-condition is violated.\ntemplate <TypeKind kFromKind, typename From, TypeKind kToKind, typename To>\nstruct LosslessArithmeticConvertibleImpl : public false_type {};\n\n// Converting bool to bool is lossless.\ntemplate <>\nstruct LosslessArithmeticConvertibleImpl<kBool, bool, kBool, bool>\n    : public true_type {};  // NOLINT\n\n// Converting bool to any integer type is lossless.\ntemplate <typename To>\nstruct LosslessArithmeticConvertibleImpl<kBool, bool, kInteger, To>\n    : public true_type {};  // NOLINT\n\n// Converting bool to any floating-point type is lossless.\ntemplate <typename To>\nstruct LosslessArithmeticConvertibleImpl<kBool, bool, kFloatingPoint, To>\n    : public true_type {};  // NOLINT\n\n// Converting an integer to bool is lossy.\ntemplate <typename From>\nstruct LosslessArithmeticConvertibleImpl<kInteger, From, kBool, bool>\n    : public false_type {};  // NOLINT\n\n// Converting an integer to another non-bool integer is lossless iff\n// the target type's range encloses the source type's range.\ntemplate <typename From, typename To>\nstruct LosslessArithmeticConvertibleImpl<kInteger, From, kInteger, To>\n    : public bool_constant<\n      // When converting from a smaller size to a larger size, we are\n      // fine as long as we are not converting from signed to unsigned.\n      ((sizeof(From) < sizeof(To)) &&\n       (!GMOCK_IS_SIGNED_(From) || GMOCK_IS_SIGNED_(To))) ||\n      // When converting between the same size, the signedness must match.\n      ((sizeof(From) == sizeof(To)) &&\n       (GMOCK_IS_SIGNED_(From) == GMOCK_IS_SIGNED_(To)))> {};  // NOLINT\n\n#undef GMOCK_IS_SIGNED_\n\n// Converting an integer to a floating-point type may be lossy, since\n// the format of a floating-point number is implementation-defined.\ntemplate <typename From, typename To>\nstruct LosslessArithmeticConvertibleImpl<kInteger, From, kFloatingPoint, To>\n    : public false_type {};  // NOLINT\n\n// Converting a floating-point to bool is lossy.\ntemplate <typename From>\nstruct LosslessArithmeticConvertibleImpl<kFloatingPoint, From, kBool, bool>\n    : public false_type {};  // NOLINT\n\n// Converting a floating-point to an integer is lossy.\ntemplate <typename From, typename To>\nstruct LosslessArithmeticConvertibleImpl<kFloatingPoint, From, kInteger, To>\n    : public false_type {};  // NOLINT\n\n// Converting a floating-point to another floating-point is lossless\n// iff the target type is at least as big as the source type.\ntemplate <typename From, typename To>\nstruct LosslessArithmeticConvertibleImpl<\n  kFloatingPoint, From, kFloatingPoint, To>\n    : public bool_constant<sizeof(From) <= sizeof(To)> {};  // NOLINT\n\n// LosslessArithmeticConvertible<From, To>::value is true iff arithmetic\n// type From can be losslessly converted to arithmetic type To.\n//\n// It's the user's responsibility to ensure that both From and To are\n// raw (i.e. has no CV modifier, is not a pointer, and is not a\n// reference) built-in arithmetic types; the value is\n// implementation-defined when the above pre-condition is violated.\ntemplate <typename From, typename To>\nstruct LosslessArithmeticConvertible\n    : public LosslessArithmeticConvertibleImpl<\n  GMOCK_KIND_OF_(From), From, GMOCK_KIND_OF_(To), To> {};  // NOLINT\n\n// This interface knows how to report a Google Mock failure (either\n// non-fatal or fatal).\nclass FailureReporterInterface {\n public:\n  // The type of a failure (either non-fatal or fatal).\n  enum FailureType {\n    kNonfatal, kFatal\n  };\n\n  virtual ~FailureReporterInterface() {}\n\n  // Reports a failure that occurred at the given source file location.\n  virtual void ReportFailure(FailureType type, const char* file, int line,\n                             const string& message) = 0;\n};\n\n// Returns the failure reporter used by Google Mock.\nGTEST_API_ FailureReporterInterface* GetFailureReporter();\n\n// Asserts that condition is true; aborts the process with the given\n// message if condition is false.  We cannot use LOG(FATAL) or CHECK()\n// as Google Mock might be used to mock the log sink itself.  We\n// inline this function to prevent it from showing up in the stack\n// trace.\ninline void Assert(bool condition, const char* file, int line,\n                   const string& msg) {\n  if (!condition) {\n    GetFailureReporter()->ReportFailure(FailureReporterInterface::kFatal,\n                                        file, line, msg);\n  }\n}\ninline void Assert(bool condition, const char* file, int line) {\n  Assert(condition, file, line, \"Assertion failed.\");\n}\n\n// Verifies that condition is true; generates a non-fatal failure if\n// condition is false.\ninline void Expect(bool condition, const char* file, int line,\n                   const string& msg) {\n  if (!condition) {\n    GetFailureReporter()->ReportFailure(FailureReporterInterface::kNonfatal,\n                                        file, line, msg);\n  }\n}\ninline void Expect(bool condition, const char* file, int line) {\n  Expect(condition, file, line, \"Expectation failed.\");\n}\n\n// Severity level of a log.\nenum LogSeverity {\n  kInfo = 0,\n  kWarning = 1\n};\n\n// Valid values for the --gmock_verbose flag.\n\n// All logs (informational and warnings) are printed.\nconst char kInfoVerbosity[] = \"info\";\n// Only warnings are printed.\nconst char kWarningVerbosity[] = \"warning\";\n// No logs are printed.\nconst char kErrorVerbosity[] = \"error\";\n\n// Returns true iff a log with the given severity is visible according\n// to the --gmock_verbose flag.\nGTEST_API_ bool LogIsVisible(LogSeverity severity);\n\n// Prints the given message to stdout iff 'severity' >= the level\n// specified by the --gmock_verbose flag.  If stack_frames_to_skip >=\n// 0, also prints the stack trace excluding the top\n// stack_frames_to_skip frames.  In opt mode, any positive\n// stack_frames_to_skip is treated as 0, since we don't know which\n// function calls will be inlined by the compiler and need to be\n// conservative.\nGTEST_API_ void Log(LogSeverity severity,\n                    const string& message,\n                    int stack_frames_to_skip);\n\n// TODO(wan@google.com): group all type utilities together.\n\n// Type traits.\n\n// is_reference<T>::value is non-zero iff T is a reference type.\ntemplate <typename T> struct is_reference : public false_type {};\ntemplate <typename T> struct is_reference<T&> : public true_type {};\n\n// type_equals<T1, T2>::value is non-zero iff T1 and T2 are the same type.\ntemplate <typename T1, typename T2> struct type_equals : public false_type {};\ntemplate <typename T> struct type_equals<T, T> : public true_type {};\n\n// remove_reference<T>::type removes the reference from type T, if any.\ntemplate <typename T> struct remove_reference { typedef T type; };  // NOLINT\ntemplate <typename T> struct remove_reference<T&> { typedef T type; }; // NOLINT\n\n// DecayArray<T>::type turns an array type U[N] to const U* and preserves\n// other types.  Useful for saving a copy of a function argument.\ntemplate <typename T> struct DecayArray { typedef T type; };  // NOLINT\ntemplate <typename T, size_t N> struct DecayArray<T[N]> {\n  typedef const T* type;\n};\n// Sometimes people use arrays whose size is not available at the use site\n// (e.g. extern const char kNamePrefix[]).  This specialization covers that\n// case.\ntemplate <typename T> struct DecayArray<T[]> {\n  typedef const T* type;\n};\n\n// Disable MSVC warnings for infinite recursion, since in this case the\n// the recursion is unreachable.\n#ifdef _MSC_VER\n# pragma warning(push)\n# pragma warning(disable:4717)\n#endif\n\n// Invalid<T>() is usable as an expression of type T, but will terminate\n// the program with an assertion failure if actually run.  This is useful\n// when a value of type T is needed for compilation, but the statement\n// will not really be executed (or we don't care if the statement\n// crashes).\ntemplate <typename T>\ninline T Invalid() {\n  Assert(false, \"\", -1, \"Internal error: attempt to return invalid value\");\n  // This statement is unreachable, and would never terminate even if it\n  // could be reached. It is provided only to placate compiler warnings\n  // about missing return statements.\n  return Invalid<T>();\n}\n\n#ifdef _MSC_VER\n# pragma warning(pop)\n#endif\n\n// Given a raw type (i.e. having no top-level reference or const\n// modifier) RawContainer that's either an STL-style container or a\n// native array, class StlContainerView<RawContainer> has the\n// following members:\n//\n//   - type is a type that provides an STL-style container view to\n//     (i.e. implements the STL container concept for) RawContainer;\n//   - const_reference is a type that provides a reference to a const\n//     RawContainer;\n//   - ConstReference(raw_container) returns a const reference to an STL-style\n//     container view to raw_container, which is a RawContainer.\n//   - Copy(raw_container) returns an STL-style container view of a\n//     copy of raw_container, which is a RawContainer.\n//\n// This generic version is used when RawContainer itself is already an\n// STL-style container.\ntemplate <class RawContainer>\nclass StlContainerView {\n public:\n  typedef RawContainer type;\n  typedef const type& const_reference;\n\n  static const_reference ConstReference(const RawContainer& container) {\n    // Ensures that RawContainer is not a const type.\n    testing::StaticAssertTypeEq<RawContainer,\n        GTEST_REMOVE_CONST_(RawContainer)>();\n    return container;\n  }\n  static type Copy(const RawContainer& container) { return container; }\n};\n\n// This specialization is used when RawContainer is a native array type.\ntemplate <typename Element, size_t N>\nclass StlContainerView<Element[N]> {\n public:\n  typedef GTEST_REMOVE_CONST_(Element) RawElement;\n  typedef internal::NativeArray<RawElement> type;\n  // NativeArray<T> can represent a native array either by value or by\n  // reference (selected by a constructor argument), so 'const type'\n  // can be used to reference a const native array.  We cannot\n  // 'typedef const type& const_reference' here, as that would mean\n  // ConstReference() has to return a reference to a local variable.\n  typedef const type const_reference;\n\n  static const_reference ConstReference(const Element (&array)[N]) {\n    // Ensures that Element is not a const type.\n    testing::StaticAssertTypeEq<Element, RawElement>();\n#if GTEST_OS_SYMBIAN\n    // The Nokia Symbian compiler confuses itself in template instantiation\n    // for this call without the cast to Element*:\n    // function call '[testing::internal::NativeArray<char *>].NativeArray(\n    //     {lval} const char *[4], long, testing::internal::RelationToSource)'\n    //     does not match\n    // 'testing::internal::NativeArray<char *>::NativeArray(\n    //     char *const *, unsigned int, testing::internal::RelationToSource)'\n    // (instantiating: 'testing::internal::ContainsMatcherImpl\n    //     <const char * (&)[4]>::Matches(const char * (&)[4]) const')\n    // (instantiating: 'testing::internal::StlContainerView<char *[4]>::\n    //     ConstReference(const char * (&)[4])')\n    // (and though the N parameter type is mismatched in the above explicit\n    // conversion of it doesn't help - only the conversion of the array).\n    return type(const_cast<Element*>(&array[0]), N,\n                RelationToSourceReference());\n#else\n    return type(array, N, RelationToSourceReference());\n#endif  // GTEST_OS_SYMBIAN\n  }\n  static type Copy(const Element (&array)[N]) {\n#if GTEST_OS_SYMBIAN\n    return type(const_cast<Element*>(&array[0]), N, RelationToSourceCopy());\n#else\n    return type(array, N, RelationToSourceCopy());\n#endif  // GTEST_OS_SYMBIAN\n  }\n};\n\n// This specialization is used when RawContainer is a native array\n// represented as a (pointer, size) tuple.\ntemplate <typename ElementPointer, typename Size>\nclass StlContainerView< ::testing::tuple<ElementPointer, Size> > {\n public:\n  typedef GTEST_REMOVE_CONST_(\n      typename internal::PointeeOf<ElementPointer>::type) RawElement;\n  typedef internal::NativeArray<RawElement> type;\n  typedef const type const_reference;\n\n  static const_reference ConstReference(\n      const ::testing::tuple<ElementPointer, Size>& array) {\n    return type(get<0>(array), get<1>(array), RelationToSourceReference());\n  }\n  static type Copy(const ::testing::tuple<ElementPointer, Size>& array) {\n    return type(get<0>(array), get<1>(array), RelationToSourceCopy());\n  }\n};\n\n// The following specialization prevents the user from instantiating\n// StlContainer with a reference type.\ntemplate <typename T> class StlContainerView<T&>;\n\n// A type transform to remove constness from the first part of a pair.\n// Pairs like that are used as the value_type of associative containers,\n// and this transform produces a similar but assignable pair.\ntemplate <typename T>\nstruct RemoveConstFromKey {\n  typedef T type;\n};\n\n// Partially specialized to remove constness from std::pair<const K, V>.\ntemplate <typename K, typename V>\nstruct RemoveConstFromKey<std::pair<const K, V> > {\n  typedef std::pair<K, V> type;\n};\n\n// Mapping from booleans to types. Similar to boost::bool_<kValue> and\n// std::integral_constant<bool, kValue>.\ntemplate <bool kValue>\nstruct BooleanConstant {};\n\n}  // namespace internal\n}  // namespace testing\n\n#endif  // GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_INTERNAL_UTILS_H_\n\n"}, "40": {"id": 40, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest-test-part.h", "content": "// Copyright 2008, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: mheule@google.com (Markus Heule)\n//\n\n#ifndef GTEST_INCLUDE_GTEST_GTEST_TEST_PART_H_\n#define GTEST_INCLUDE_GTEST_GTEST_TEST_PART_H_\n\n#include <iosfwd>\n#include <vector>\n#include \"gtest/internal/gtest-internal.h\"\n#include \"gtest/internal/gtest-string.h\"\n\nnamespace testing {\n\n// A copyable object representing the result of a test part (i.e. an\n// assertion or an explicit FAIL(), ADD_FAILURE(), or SUCCESS()).\n//\n// Don't inherit from TestPartResult as its destructor is not virtual.\nclass GTEST_API_ TestPartResult {\n public:\n  // The possible outcomes of a test part (i.e. an assertion or an\n  // explicit SUCCEED(), FAIL(), or ADD_FAILURE()).\n  enum Type {\n    kSuccess,          // Succeeded.\n    kNonFatalFailure,  // Failed but the test can continue.\n    kFatalFailure      // Failed and the test should be terminated.\n  };\n\n  // C'tor.  TestPartResult does NOT have a default constructor.\n  // Always use this constructor (with parameters) to create a\n  // TestPartResult object.\n  TestPartResult(Type a_type,\n                 const char* a_file_name,\n                 int a_line_number,\n                 const char* a_message)\n      : type_(a_type),\n        file_name_(a_file_name == NULL ? \"\" : a_file_name),\n        line_number_(a_line_number),\n        summary_(ExtractSummary(a_message)),\n        message_(a_message) {\n  }\n\n  // Gets the outcome of the test part.\n  Type type() const { return type_; }\n\n  // Gets the name of the source file where the test part took place, or\n  // NULL if it's unknown.\n  const char* file_name() const {\n    return file_name_.empty() ? NULL : file_name_.c_str();\n  }\n\n  // Gets the line in the source file where the test part took place,\n  // or -1 if it's unknown.\n  int line_number() const { return line_number_; }\n\n  // Gets the summary of the failure message.\n  const char* summary() const { return summary_.c_str(); }\n\n  // Gets the message associated with the test part.\n  const char* message() const { return message_.c_str(); }\n\n  // Returns true iff the test part passed.\n  bool passed() const { return type_ == kSuccess; }\n\n  // Returns true iff the test part failed.\n  bool failed() const { return type_ != kSuccess; }\n\n  // Returns true iff the test part non-fatally failed.\n  bool nonfatally_failed() const { return type_ == kNonFatalFailure; }\n\n  // Returns true iff the test part fatally failed.\n  bool fatally_failed() const { return type_ == kFatalFailure; }\n\n private:\n  Type type_;\n\n  // Gets the summary of the failure message by omitting the stack\n  // trace in it.\n  static std::string ExtractSummary(const char* message);\n\n  // The name of the source file where the test part took place, or\n  // \"\" if the source file is unknown.\n  std::string file_name_;\n  // The line in the source file where the test part took place, or -1\n  // if the line number is unknown.\n  int line_number_;\n  std::string summary_;  // The test failure summary.\n  std::string message_;  // The test failure message.\n};\n\n// Prints a TestPartResult object.\nstd::ostream& operator<<(std::ostream& os, const TestPartResult& result);\n\n// An array of TestPartResult objects.\n//\n// Don't inherit from TestPartResultArray as its destructor is not\n// virtual.\nclass GTEST_API_ TestPartResultArray {\n public:\n  TestPartResultArray() {}\n\n  // Appends the given TestPartResult to the array.\n  void Append(const TestPartResult& result);\n\n  // Returns the TestPartResult at the given index (0-based).\n  const TestPartResult& GetTestPartResult(int index) const;\n\n  // Returns the number of TestPartResult objects in the array.\n  int size() const;\n\n private:\n  std::vector<TestPartResult> array_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestPartResultArray);\n};\n\n// This interface knows how to report a test part result.\nclass TestPartResultReporterInterface {\n public:\n  virtual ~TestPartResultReporterInterface() {}\n\n  virtual void ReportTestPartResult(const TestPartResult& result) = 0;\n};\n\nnamespace internal {\n\n// This helper class is used by {ASSERT|EXPECT}_NO_FATAL_FAILURE to check if a\n// statement generates new fatal failures. To do so it registers itself as the\n// current test part result reporter. Besides checking if fatal failures were\n// reported, it only delegates the reporting to the former result reporter.\n// The original result reporter is restored in the destructor.\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nclass GTEST_API_ HasNewFatalFailureHelper\n    : public TestPartResultReporterInterface {\n public:\n  HasNewFatalFailureHelper();\n  virtual ~HasNewFatalFailureHelper();\n  virtual void ReportTestPartResult(const TestPartResult& result);\n  bool has_new_fatal_failure() const { return has_new_fatal_failure_; }\n private:\n  bool has_new_fatal_failure_;\n  TestPartResultReporterInterface* original_reporter_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(HasNewFatalFailureHelper);\n};\n\n}  // namespace internal\n\n}  // namespace testing\n\n#endif  // GTEST_INCLUDE_GTEST_GTEST_TEST_PART_H_\n"}, "41": {"id": 41, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n//\n// The Google C++ Testing Framework (Google Test)\n//\n// This header file defines the public API for Google Test.  It should be\n// included by any test program that uses Google Test.\n//\n// IMPORTANT NOTE: Due to limitation of the C++ language, we have to\n// leave some internal implementation details in this header file.\n// They are clearly marked by comments like this:\n//\n//   // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n//\n// Such code is NOT meant to be used by a user directly, and is subject\n// to CHANGE WITHOUT NOTICE.  Therefore DO NOT DEPEND ON IT in a user\n// program!\n//\n// Acknowledgment: Google Test borrowed the idea of automatic test\n// registration from Barthelemy Dagenais' (barthelemy@prologique.com)\n// easyUnit framework.\n\n#ifndef GTEST_INCLUDE_GTEST_GTEST_H_\n#define GTEST_INCLUDE_GTEST_GTEST_H_\n\n#include <limits>\n#include <ostream>\n#include <vector>\n\n#include \"gtest/internal/gtest-internal.h\"\n#include \"gtest/internal/gtest-string.h\"\n#include \"gtest/gtest-death-test.h\"\n#include \"gtest/gtest-message.h\"\n#include \"gtest/gtest-param-test.h\"\n#include \"gtest/gtest-printers.h\"\n#include \"gtest/gtest_prod.h\"\n#include \"gtest/gtest-test-part.h\"\n#include \"gtest/gtest-typed-test.h\"\n\n// Depending on the platform, different string classes are available.\n// On Linux, in addition to ::std::string, Google also makes use of\n// class ::string, which has the same interface as ::std::string, but\n// has a different implementation.\n//\n// You can define GTEST_HAS_GLOBAL_STRING to 1 to indicate that\n// ::string is available AND is a distinct type to ::std::string, or\n// define it to 0 to indicate otherwise.\n//\n// If ::std::string and ::string are the same class on your platform\n// due to aliasing, you should define GTEST_HAS_GLOBAL_STRING to 0.\n//\n// If you do not define GTEST_HAS_GLOBAL_STRING, it is defined\n// heuristically.\n\nnamespace testing {\n\n// Declares the flags.\n\n// This flag temporary enables the disabled tests.\nGTEST_DECLARE_bool_(also_run_disabled_tests);\n\n// This flag brings the debugger on an assertion failure.\nGTEST_DECLARE_bool_(break_on_failure);\n\n// This flag controls whether Google Test catches all test-thrown exceptions\n// and logs them as failures.\nGTEST_DECLARE_bool_(catch_exceptions);\n\n// This flag enables using colors in terminal output. Available values are\n// \"yes\" to enable colors, \"no\" (disable colors), or \"auto\" (the default)\n// to let Google Test decide.\nGTEST_DECLARE_string_(color);\n\n// This flag sets up the filter to select by name using a glob pattern\n// the tests to run. If the filter is not given all tests are executed.\nGTEST_DECLARE_string_(filter);\n\n// This flag causes the Google Test to list tests. None of the tests listed\n// are actually run if the flag is provided.\nGTEST_DECLARE_bool_(list_tests);\n\n// This flag controls whether Google Test emits a detailed XML report to a file\n// in addition to its normal textual output.\nGTEST_DECLARE_string_(output);\n\n// This flags control whether Google Test prints the elapsed time for each\n// test.\nGTEST_DECLARE_bool_(print_time);\n\n// This flag specifies the random number seed.\nGTEST_DECLARE_int32_(random_seed);\n\n// This flag sets how many times the tests are repeated. The default value\n// is 1. If the value is -1 the tests are repeating forever.\nGTEST_DECLARE_int32_(repeat);\n\n// This flag controls whether Google Test includes Google Test internal\n// stack frames in failure stack traces.\nGTEST_DECLARE_bool_(show_internal_stack_frames);\n\n// When this flag is specified, tests' order is randomized on every iteration.\nGTEST_DECLARE_bool_(shuffle);\n\n// This flag specifies the maximum number of stack frames to be\n// printed in a failure message.\nGTEST_DECLARE_int32_(stack_trace_depth);\n\n// When this flag is specified, a failed assertion will throw an\n// exception if exceptions are enabled, or exit the program with a\n// non-zero code otherwise.\nGTEST_DECLARE_bool_(throw_on_failure);\n\n// When this flag is set with a \"host:port\" string, on supported\n// platforms test results are streamed to the specified port on\n// the specified host machine.\nGTEST_DECLARE_string_(stream_result_to);\n\n// The upper limit for valid stack trace depths.\nconst int kMaxStackTraceDepth = 100;\n\nnamespace internal {\n\nclass AssertHelper;\nclass DefaultGlobalTestPartResultReporter;\nclass ExecDeathTest;\nclass NoExecDeathTest;\nclass FinalSuccessChecker;\nclass GTestFlagSaver;\nclass StreamingListenerTest;\nclass TestResultAccessor;\nclass TestEventListenersAccessor;\nclass TestEventRepeater;\nclass UnitTestRecordPropertyTestHelper;\nclass WindowsDeathTest;\nclass UnitTestImpl* GetUnitTestImpl();\nvoid ReportFailureInUnknownLocation(TestPartResult::Type result_type,\n                                    const std::string& message);\n\n}  // namespace internal\n\n// The friend relationship of some of these classes is cyclic.\n// If we don't forward declare them the compiler might confuse the classes\n// in friendship clauses with same named classes on the scope.\nclass Test;\nclass TestCase;\nclass TestInfo;\nclass UnitTest;\n\n// A class for indicating whether an assertion was successful.  When\n// the assertion wasn't successful, the AssertionResult object\n// remembers a non-empty message that describes how it failed.\n//\n// To create an instance of this class, use one of the factory functions\n// (AssertionSuccess() and AssertionFailure()).\n//\n// This class is useful for two purposes:\n//   1. Defining predicate functions to be used with Boolean test assertions\n//      EXPECT_TRUE/EXPECT_FALSE and their ASSERT_ counterparts\n//   2. Defining predicate-format functions to be\n//      used with predicate assertions (ASSERT_PRED_FORMAT*, etc).\n//\n// For example, if you define IsEven predicate:\n//\n//   testing::AssertionResult IsEven(int n) {\n//     if ((n % 2) == 0)\n//       return testing::AssertionSuccess();\n//     else\n//       return testing::AssertionFailure() << n << \" is odd\";\n//   }\n//\n// Then the failed expectation EXPECT_TRUE(IsEven(Fib(5)))\n// will print the message\n//\n//   Value of: IsEven(Fib(5))\n//     Actual: false (5 is odd)\n//   Expected: true\n//\n// instead of a more opaque\n//\n//   Value of: IsEven(Fib(5))\n//     Actual: false\n//   Expected: true\n//\n// in case IsEven is a simple Boolean predicate.\n//\n// If you expect your predicate to be reused and want to support informative\n// messages in EXPECT_FALSE and ASSERT_FALSE (negative assertions show up\n// about half as often as positive ones in our tests), supply messages for\n// both success and failure cases:\n//\n//   testing::AssertionResult IsEven(int n) {\n//     if ((n % 2) == 0)\n//       return testing::AssertionSuccess() << n << \" is even\";\n//     else\n//       return testing::AssertionFailure() << n << \" is odd\";\n//   }\n//\n// Then a statement EXPECT_FALSE(IsEven(Fib(6))) will print\n//\n//   Value of: IsEven(Fib(6))\n//     Actual: true (8 is even)\n//   Expected: false\n//\n// NB: Predicates that support negative Boolean assertions have reduced\n// performance in positive ones so be careful not to use them in tests\n// that have lots (tens of thousands) of positive Boolean assertions.\n//\n// To use this class with EXPECT_PRED_FORMAT assertions such as:\n//\n//   // Verifies that Foo() returns an even number.\n//   EXPECT_PRED_FORMAT1(IsEven, Foo());\n//\n// you need to define:\n//\n//   testing::AssertionResult IsEven(const char* expr, int n) {\n//     if ((n % 2) == 0)\n//       return testing::AssertionSuccess();\n//     else\n//       return testing::AssertionFailure()\n//         << \"Expected: \" << expr << \" is even\\n  Actual: it's \" << n;\n//   }\n//\n// If Foo() returns 5, you will see the following message:\n//\n//   Expected: Foo() is even\n//     Actual: it's 5\n//\nclass GTEST_API_ AssertionResult {\n public:\n  // Copy constructor.\n  // Used in EXPECT_TRUE/FALSE(assertion_result).\n  AssertionResult(const AssertionResult& other);\n\n  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4800 /* forcing value to bool */)\n\n  // Used in the EXPECT_TRUE/FALSE(bool_expression).\n  //\n  // T must be contextually convertible to bool.\n  //\n  // The second parameter prevents this overload from being considered if\n  // the argument is implicitly convertible to AssertionResult. In that case\n  // we want AssertionResult's copy constructor to be used.\n  template <typename T>\n  explicit AssertionResult(\n      const T& success,\n      typename internal::EnableIf<\n          !internal::ImplicitlyConvertible<T, AssertionResult>::value>::type*\n          /*enabler*/ = NULL)\n      : success_(success) {}\n\n  GTEST_DISABLE_MSC_WARNINGS_POP_()\n\n  // Assignment operator.\n  AssertionResult& operator=(AssertionResult other) {\n    swap(other);\n    return *this;\n  }\n\n  // Returns true iff the assertion succeeded.\n  operator bool() const { return success_; }  // NOLINT\n\n  // Returns the assertion's negation. Used with EXPECT/ASSERT_FALSE.\n  AssertionResult operator!() const;\n\n  // Returns the text streamed into this AssertionResult. Test assertions\n  // use it when they fail (i.e., the predicate's outcome doesn't match the\n  // assertion's expectation). When nothing has been streamed into the\n  // object, returns an empty string.\n  const char* message() const {\n    return message_.get() != NULL ?  message_->c_str() : \"\";\n  }\n  // TODO(vladl@google.com): Remove this after making sure no clients use it.\n  // Deprecated; please use message() instead.\n  const char* failure_message() const { return message(); }\n\n  // Streams a custom failure message into this object.\n  template <typename T> AssertionResult& operator<<(const T& value) {\n    AppendMessage(Message() << value);\n    return *this;\n  }\n\n  // Allows streaming basic output manipulators such as endl or flush into\n  // this object.\n  AssertionResult& operator<<(\n      ::std::ostream& (*basic_manipulator)(::std::ostream& stream)) {\n    AppendMessage(Message() << basic_manipulator);\n    return *this;\n  }\n\n private:\n  // Appends the contents of message to message_.\n  void AppendMessage(const Message& a_message) {\n    if (message_.get() == NULL)\n      message_.reset(new ::std::string);\n    message_->append(a_message.GetString().c_str());\n  }\n\n  // Swap the contents of this AssertionResult with other.\n  void swap(AssertionResult& other);\n\n  // Stores result of the assertion predicate.\n  bool success_;\n  // Stores the message describing the condition in case the expectation\n  // construct is not satisfied with the predicate's outcome.\n  // Referenced via a pointer to avoid taking too much stack frame space\n  // with test assertions.\n  internal::scoped_ptr< ::std::string> message_;\n};\n\n// Makes a successful assertion result.\nGTEST_API_ AssertionResult AssertionSuccess();\n\n// Makes a failed assertion result.\nGTEST_API_ AssertionResult AssertionFailure();\n\n// Makes a failed assertion result with the given failure message.\n// Deprecated; use AssertionFailure() << msg.\nGTEST_API_ AssertionResult AssertionFailure(const Message& msg);\n\n// The abstract class that all tests inherit from.\n//\n// In Google Test, a unit test program contains one or many TestCases, and\n// each TestCase contains one or many Tests.\n//\n// When you define a test using the TEST macro, you don't need to\n// explicitly derive from Test - the TEST macro automatically does\n// this for you.\n//\n// The only time you derive from Test is when defining a test fixture\n// to be used a TEST_F.  For example:\n//\n//   class FooTest : public testing::Test {\n//    protected:\n//     void SetUp() override { ... }\n//     void TearDown() override { ... }\n//     ...\n//   };\n//\n//   TEST_F(FooTest, Bar) { ... }\n//   TEST_F(FooTest, Baz) { ... }\n//\n// Test is not copyable.\nclass GTEST_API_ Test {\n public:\n  friend class TestInfo;\n\n  // Defines types for pointers to functions that set up and tear down\n  // a test case.\n  typedef internal::SetUpTestCaseFunc SetUpTestCaseFunc;\n  typedef internal::TearDownTestCaseFunc TearDownTestCaseFunc;\n\n  // The d'tor is virtual as we intend to inherit from Test.\n  virtual ~Test();\n\n  // Sets up the stuff shared by all tests in this test case.\n  //\n  // Google Test will call Foo::SetUpTestCase() before running the first\n  // test in test case Foo.  Hence a sub-class can define its own\n  // SetUpTestCase() method to shadow the one defined in the super\n  // class.\n  static void SetUpTestCase() {}\n\n  // Tears down the stuff shared by all tests in this test case.\n  //\n  // Google Test will call Foo::TearDownTestCase() after running the last\n  // test in test case Foo.  Hence a sub-class can define its own\n  // TearDownTestCase() method to shadow the one defined in the super\n  // class.\n  static void TearDownTestCase() {}\n\n  // Returns true iff the current test has a fatal failure.\n  static bool HasFatalFailure();\n\n  // Returns true iff the current test has a non-fatal failure.\n  static bool HasNonfatalFailure();\n\n  // Returns true iff the current test has a (either fatal or\n  // non-fatal) failure.\n  static bool HasFailure() { return HasFatalFailure() || HasNonfatalFailure(); }\n\n  // Logs a property for the current test, test case, or for the entire\n  // invocation of the test program when used outside of the context of a\n  // test case.  Only the last value for a given key is remembered.  These\n  // are public static so they can be called from utility functions that are\n  // not members of the test fixture.  Calls to RecordProperty made during\n  // lifespan of the test (from the moment its constructor starts to the\n  // moment its destructor finishes) will be output in XML as attributes of\n  // the <testcase> element.  Properties recorded from fixture's\n  // SetUpTestCase or TearDownTestCase are logged as attributes of the\n  // corresponding <testsuite> element.  Calls to RecordProperty made in the\n  // global context (before or after invocation of RUN_ALL_TESTS and from\n  // SetUp/TearDown method of Environment objects registered with Google\n  // Test) will be output as attributes of the <testsuites> element.\n  static void RecordProperty(const std::string& key, const std::string& value);\n  static void RecordProperty(const std::string& key, int value);\n\n protected:\n  // Creates a Test object.\n  Test();\n\n  // Sets up the test fixture.\n  virtual void SetUp();\n\n  // Tears down the test fixture.\n  virtual void TearDown();\n\n private:\n  // Returns true iff the current test has the same fixture class as\n  // the first test in the current test case.\n  static bool HasSameFixtureClass();\n\n  // Runs the test after the test fixture has been set up.\n  //\n  // A sub-class must implement this to define the test logic.\n  //\n  // DO NOT OVERRIDE THIS FUNCTION DIRECTLY IN A USER PROGRAM.\n  // Instead, use the TEST or TEST_F macro.\n  virtual void TestBody() = 0;\n\n  // Sets up, executes, and tears down the test.\n  void Run();\n\n  // Deletes self.  We deliberately pick an unusual name for this\n  // internal method to avoid clashing with names used in user TESTs.\n  void DeleteSelf_() { delete this; }\n\n  const internal::scoped_ptr< GTEST_FLAG_SAVER_ > gtest_flag_saver_;\n\n  // Often a user misspells SetUp() as Setup() and spends a long time\n  // wondering why it is never called by Google Test.  The declaration of\n  // the following method is solely for catching such an error at\n  // compile time:\n  //\n  //   - The return type is deliberately chosen to be not void, so it\n  //   will be a conflict if void Setup() is declared in the user's\n  //   test fixture.\n  //\n  //   - This method is private, so it will be another compiler error\n  //   if the method is called from the user's test fixture.\n  //\n  // DO NOT OVERRIDE THIS FUNCTION.\n  //\n  // If you see an error about overriding the following function or\n  // about it being private, you have mis-spelled SetUp() as Setup().\n  struct Setup_should_be_spelled_SetUp {};\n  virtual Setup_should_be_spelled_SetUp* Setup() { return NULL; }\n\n  // We disallow copying Tests.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Test);\n};\n\ntypedef internal::TimeInMillis TimeInMillis;\n\n// A copyable object representing a user specified test property which can be\n// output as a key/value string pair.\n//\n// Don't inherit from TestProperty as its destructor is not virtual.\nclass TestProperty {\n public:\n  // C'tor.  TestProperty does NOT have a default constructor.\n  // Always use this constructor (with parameters) to create a\n  // TestProperty object.\n  TestProperty(const std::string& a_key, const std::string& a_value) :\n    key_(a_key), value_(a_value) {\n  }\n\n  // Gets the user supplied key.\n  const char* key() const {\n    return key_.c_str();\n  }\n\n  // Gets the user supplied value.\n  const char* value() const {\n    return value_.c_str();\n  }\n\n  // Sets a new value, overriding the one supplied in the constructor.\n  void SetValue(const std::string& new_value) {\n    value_ = new_value;\n  }\n\n private:\n  // The key supplied by the user.\n  std::string key_;\n  // The value supplied by the user.\n  std::string value_;\n};\n\n// The result of a single Test.  This includes a list of\n// TestPartResults, a list of TestProperties, a count of how many\n// death tests there are in the Test, and how much time it took to run\n// the Test.\n//\n// TestResult is not copyable.\nclass GTEST_API_ TestResult {\n public:\n  // Creates an empty TestResult.\n  TestResult();\n\n  // D'tor.  Do not inherit from TestResult.\n  ~TestResult();\n\n  // Gets the number of all test parts.  This is the sum of the number\n  // of successful test parts and the number of failed test parts.\n  int total_part_count() const;\n\n  // Returns the number of the test properties.\n  int test_property_count() const;\n\n  // Returns true iff the test passed (i.e. no test part failed).\n  bool Passed() const { return !Failed(); }\n\n  // Returns true iff the test failed.\n  bool Failed() const;\n\n  // Returns true iff the test fatally failed.\n  bool HasFatalFailure() const;\n\n  // Returns true iff the test has a non-fatal failure.\n  bool HasNonfatalFailure() const;\n\n  // Returns the elapsed time, in milliseconds.\n  TimeInMillis elapsed_time() const { return elapsed_time_; }\n\n  // Returns the i-th test part result among all the results. i can range\n  // from 0 to test_property_count() - 1. If i is not in that range, aborts\n  // the program.\n  const TestPartResult& GetTestPartResult(int i) const;\n\n  // Returns the i-th test property. i can range from 0 to\n  // test_property_count() - 1. If i is not in that range, aborts the\n  // program.\n  const TestProperty& GetTestProperty(int i) const;\n\n private:\n  friend class TestInfo;\n  friend class TestCase;\n  friend class UnitTest;\n  friend class internal::DefaultGlobalTestPartResultReporter;\n  friend class internal::ExecDeathTest;\n  friend class internal::TestResultAccessor;\n  friend class internal::UnitTestImpl;\n  friend class internal::WindowsDeathTest;\n\n  // Gets the vector of TestPartResults.\n  const std::vector<TestPartResult>& test_part_results() const {\n    return test_part_results_;\n  }\n\n  // Gets the vector of TestProperties.\n  const std::vector<TestProperty>& test_properties() const {\n    return test_properties_;\n  }\n\n  // Sets the elapsed time.\n  void set_elapsed_time(TimeInMillis elapsed) { elapsed_time_ = elapsed; }\n\n  // Adds a test property to the list. The property is validated and may add\n  // a non-fatal failure if invalid (e.g., if it conflicts with reserved\n  // key names). If a property is already recorded for the same key, the\n  // value will be updated, rather than storing multiple values for the same\n  // key.  xml_element specifies the element for which the property is being\n  // recorded and is used for validation.\n  void RecordProperty(const std::string& xml_element,\n                      const TestProperty& test_property);\n\n  // Adds a failure if the key is a reserved attribute of Google Test\n  // testcase tags.  Returns true if the property is valid.\n  // TODO(russr): Validate attribute names are legal and human readable.\n  static bool ValidateTestProperty(const std::string& xml_element,\n                                   const TestProperty& test_property);\n\n  // Adds a test part result to the list.\n  void AddTestPartResult(const TestPartResult& test_part_result);\n\n  // Returns the death test count.\n  int death_test_count() const { return death_test_count_; }\n\n  // Increments the death test count, returning the new count.\n  int increment_death_test_count() { return ++death_test_count_; }\n\n  // Clears the test part results.\n  void ClearTestPartResults();\n\n  // Clears the object.\n  void Clear();\n\n  // Protects mutable state of the property vector and of owned\n  // properties, whose values may be updated.\n  internal::Mutex test_properites_mutex_;\n\n  // The vector of TestPartResults\n  std::vector<TestPartResult> test_part_results_;\n  // The vector of TestProperties\n  std::vector<TestProperty> test_properties_;\n  // Running count of death tests.\n  int death_test_count_;\n  // The elapsed time, in milliseconds.\n  TimeInMillis elapsed_time_;\n\n  // We disallow copying TestResult.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestResult);\n};  // class TestResult\n\n// A TestInfo object stores the following information about a test:\n//\n//   Test case name\n//   Test name\n//   Whether the test should be run\n//   A function pointer that creates the test object when invoked\n//   Test result\n//\n// The constructor of TestInfo registers itself with the UnitTest\n// singleton such that the RUN_ALL_TESTS() macro knows which tests to\n// run.\nclass GTEST_API_ TestInfo {\n public:\n  // Destructs a TestInfo object.  This function is not virtual, so\n  // don't inherit from TestInfo.\n  ~TestInfo();\n\n  // Returns the test case name.\n  const char* test_case_name() const { return test_case_name_.c_str(); }\n\n  // Returns the test name.\n  const char* name() const { return name_.c_str(); }\n\n  // Returns the name of the parameter type, or NULL if this is not a typed\n  // or a type-parameterized test.\n  const char* type_param() const {\n    if (type_param_.get() != NULL)\n      return type_param_->c_str();\n    return NULL;\n  }\n\n  // Returns the text representation of the value parameter, or NULL if this\n  // is not a value-parameterized test.\n  const char* value_param() const {\n    if (value_param_.get() != NULL)\n      return value_param_->c_str();\n    return NULL;\n  }\n\n  // Returns the file name where this test is defined.\n  const char* file() const { return location_.file.c_str(); }\n\n  // Returns the line where this test is defined.\n  int line() const { return location_.line; }\n\n  // Returns true if this test should run, that is if the test is not\n  // disabled (or it is disabled but the also_run_disabled_tests flag has\n  // been specified) and its full name matches the user-specified filter.\n  //\n  // Google Test allows the user to filter the tests by their full names.\n  // The full name of a test Bar in test case Foo is defined as\n  // \"Foo.Bar\".  Only the tests that match the filter will run.\n  //\n  // A filter is a colon-separated list of glob (not regex) patterns,\n  // optionally followed by a '-' and a colon-separated list of\n  // negative patterns (tests to exclude).  A test is run if it\n  // matches one of the positive patterns and does not match any of\n  // the negative patterns.\n  //\n  // For example, *A*:Foo.* is a filter that matches any string that\n  // contains the character 'A' or starts with \"Foo.\".\n  bool should_run() const { return should_run_; }\n\n  // Returns true iff this test will appear in the XML report.\n  bool is_reportable() const {\n    // For now, the XML report includes all tests matching the filter.\n    // In the future, we may trim tests that are excluded because of\n    // sharding.\n    return matches_filter_;\n  }\n\n  // Returns the result of the test.\n  const TestResult* result() const { return &result_; }\n\n private:\n#if GTEST_HAS_DEATH_TEST\n  friend class internal::DefaultDeathTestFactory;\n#endif  // GTEST_HAS_DEATH_TEST\n  friend class Test;\n  friend class TestCase;\n  friend class internal::UnitTestImpl;\n  friend class internal::StreamingListenerTest;\n  friend TestInfo* internal::MakeAndRegisterTestInfo(\n      const char* test_case_name,\n      const char* name,\n      const char* type_param,\n      const char* value_param,\n      internal::CodeLocation code_location,\n      internal::TypeId fixture_class_id,\n      Test::SetUpTestCaseFunc set_up_tc,\n      Test::TearDownTestCaseFunc tear_down_tc,\n      internal::TestFactoryBase* factory);\n\n  // Constructs a TestInfo object. The newly constructed instance assumes\n  // ownership of the factory object.\n  TestInfo(const std::string& test_case_name,\n           const std::string& name,\n           const char* a_type_param,   // NULL if not a type-parameterized test\n           const char* a_value_param,  // NULL if not a value-parameterized test\n           internal::CodeLocation a_code_location,\n           internal::TypeId fixture_class_id,\n           internal::TestFactoryBase* factory);\n\n  // Increments the number of death tests encountered in this test so\n  // far.\n  int increment_death_test_count() {\n    return result_.increment_death_test_count();\n  }\n\n  // Creates the test object, runs it, records its result, and then\n  // deletes it.\n  void Run();\n\n  static void ClearTestResult(TestInfo* test_info) {\n    test_info->result_.Clear();\n  }\n\n  // These fields are immutable properties of the test.\n  const std::string test_case_name_;     // Test case name\n  const std::string name_;               // Test name\n  // Name of the parameter type, or NULL if this is not a typed or a\n  // type-parameterized test.\n  const internal::scoped_ptr<const ::std::string> type_param_;\n  // Text representation of the value parameter, or NULL if this is not a\n  // value-parameterized test.\n  const internal::scoped_ptr<const ::std::string> value_param_;\n  internal::CodeLocation location_;\n  const internal::TypeId fixture_class_id_;   // ID of the test fixture class\n  bool should_run_;                 // True iff this test should run\n  bool is_disabled_;                // True iff this test is disabled\n  bool matches_filter_;             // True if this test matches the\n                                    // user-specified filter.\n  internal::TestFactoryBase* const factory_;  // The factory that creates\n                                              // the test object\n\n  // This field is mutable and needs to be reset before running the\n  // test for the second time.\n  TestResult result_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestInfo);\n};\n\n// A test case, which consists of a vector of TestInfos.\n//\n// TestCase is not copyable.\nclass GTEST_API_ TestCase {\n public:\n  // Creates a TestCase with the given name.\n  //\n  // TestCase does NOT have a default constructor.  Always use this\n  // constructor to create a TestCase object.\n  //\n  // Arguments:\n  //\n  //   name:         name of the test case\n  //   a_type_param: the name of the test's type parameter, or NULL if\n  //                 this is not a type-parameterized test.\n  //   set_up_tc:    pointer to the function that sets up the test case\n  //   tear_down_tc: pointer to the function that tears down the test case\n  TestCase(const char* name, const char* a_type_param,\n           Test::SetUpTestCaseFunc set_up_tc,\n           Test::TearDownTestCaseFunc tear_down_tc);\n\n  // Destructor of TestCase.\n  virtual ~TestCase();\n\n  // Gets the name of the TestCase.\n  const char* name() const { return name_.c_str(); }\n\n  // Returns the name of the parameter type, or NULL if this is not a\n  // type-parameterized test case.\n  const char* type_param() const {\n    if (type_param_.get() != NULL)\n      return type_param_->c_str();\n    return NULL;\n  }\n\n  // Returns true if any test in this test case should run.\n  bool should_run() const { return should_run_; }\n\n  // Gets the number of successful tests in this test case.\n  int successful_test_count() const;\n\n  // Gets the number of failed tests in this test case.\n  int failed_test_count() const;\n\n  // Gets the number of disabled tests that will be reported in the XML report.\n  int reportable_disabled_test_count() const;\n\n  // Gets the number of disabled tests in this test case.\n  int disabled_test_count() const;\n\n  // Gets the number of tests to be printed in the XML report.\n  int reportable_test_count() const;\n\n  // Get the number of tests in this test case that should run.\n  int test_to_run_count() const;\n\n  // Gets the number of all tests in this test case.\n  int total_test_count() const;\n\n  // Returns true iff the test case passed.\n  bool Passed() const { return !Failed(); }\n\n  // Returns true iff the test case failed.\n  bool Failed() const { return failed_test_count() > 0; }\n\n  // Returns the elapsed time, in milliseconds.\n  TimeInMillis elapsed_time() const { return elapsed_time_; }\n\n  // Returns the i-th test among all the tests. i can range from 0 to\n  // total_test_count() - 1. If i is not in that range, returns NULL.\n  const TestInfo* GetTestInfo(int i) const;\n\n  // Returns the TestResult that holds test properties recorded during\n  // execution of SetUpTestCase and TearDownTestCase.\n  const TestResult& ad_hoc_test_result() const { return ad_hoc_test_result_; }\n\n private:\n  friend class Test;\n  friend class internal::UnitTestImpl;\n\n  // Gets the (mutable) vector of TestInfos in this TestCase.\n  std::vector<TestInfo*>& test_info_list() { return test_info_list_; }\n\n  // Gets the (immutable) vector of TestInfos in this TestCase.\n  const std::vector<TestInfo*>& test_info_list() const {\n    return test_info_list_;\n  }\n\n  // Returns the i-th test among all the tests. i can range from 0 to\n  // total_test_count() - 1. If i is not in that range, returns NULL.\n  TestInfo* GetMutableTestInfo(int i);\n\n  // Sets the should_run member.\n  void set_should_run(bool should) { should_run_ = should; }\n\n  // Adds a TestInfo to this test case.  Will delete the TestInfo upon\n  // destruction of the TestCase object.\n  void AddTestInfo(TestInfo * test_info);\n\n  // Clears the results of all tests in this test case.\n  void ClearResult();\n\n  // Clears the results of all tests in the given test case.\n  static void ClearTestCaseResult(TestCase* test_case) {\n    test_case->ClearResult();\n  }\n\n  // Runs every test in this TestCase.\n  void Run();\n\n  // Runs SetUpTestCase() for this TestCase.  This wrapper is needed\n  // for catching exceptions thrown from SetUpTestCase().\n  void RunSetUpTestCase() { (*set_up_tc_)(); }\n\n  // Runs TearDownTestCase() for this TestCase.  This wrapper is\n  // needed for catching exceptions thrown from TearDownTestCase().\n  void RunTearDownTestCase() { (*tear_down_tc_)(); }\n\n  // Returns true iff test passed.\n  static bool TestPassed(const TestInfo* test_info) {\n    return test_info->should_run() && test_info->result()->Passed();\n  }\n\n  // Returns true iff test failed.\n  static bool TestFailed(const TestInfo* test_info) {\n    return test_info->should_run() && test_info->result()->Failed();\n  }\n\n  // Returns true iff the test is disabled and will be reported in the XML\n  // report.\n  static bool TestReportableDisabled(const TestInfo* test_info) {\n    return test_info->is_reportable() && test_info->is_disabled_;\n  }\n\n  // Returns true iff test is disabled.\n  static bool TestDisabled(const TestInfo* test_info) {\n    return test_info->is_disabled_;\n  }\n\n  // Returns true iff this test will appear in the XML report.\n  static bool TestReportable(const TestInfo* test_info) {\n    return test_info->is_reportable();\n  }\n\n  // Returns true if the given test should run.\n  static bool ShouldRunTest(const TestInfo* test_info) {\n    return test_info->should_run();\n  }\n\n  // Shuffles the tests in this test case.\n  void ShuffleTests(internal::Random* random);\n\n  // Restores the test order to before the first shuffle.\n  void UnshuffleTests();\n\n  // Name of the test case.\n  std::string name_;\n  // Name of the parameter type, or NULL if this is not a typed or a\n  // type-parameterized test.\n  const internal::scoped_ptr<const ::std::string> type_param_;\n  // The vector of TestInfos in their original order.  It owns the\n  // elements in the vector.\n  std::vector<TestInfo*> test_info_list_;\n  // Provides a level of indirection for the test list to allow easy\n  // shuffling and restoring the test order.  The i-th element in this\n  // vector is the index of the i-th test in the shuffled test list.\n  std::vector<int> test_indices_;\n  // Pointer to the function that sets up the test case.\n  Test::SetUpTestCaseFunc set_up_tc_;\n  // Pointer to the function that tears down the test case.\n  Test::TearDownTestCaseFunc tear_down_tc_;\n  // True iff any test in this test case should run.\n  bool should_run_;\n  // Elapsed time, in milliseconds.\n  TimeInMillis elapsed_time_;\n  // Holds test properties recorded during execution of SetUpTestCase and\n  // TearDownTestCase.\n  TestResult ad_hoc_test_result_;\n\n  // We disallow copying TestCases.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestCase);\n};\n\n// An Environment object is capable of setting up and tearing down an\n// environment.  You should subclass this to define your own\n// environment(s).\n//\n// An Environment object does the set-up and tear-down in virtual\n// methods SetUp() and TearDown() instead of the constructor and the\n// destructor, as:\n//\n//   1. You cannot safely throw from a destructor.  This is a problem\n//      as in some cases Google Test is used where exceptions are enabled, and\n//      we may want to implement ASSERT_* using exceptions where they are\n//      available.\n//   2. You cannot use ASSERT_* directly in a constructor or\n//      destructor.\nclass Environment {\n public:\n  // The d'tor is virtual as we need to subclass Environment.\n  virtual ~Environment() {}\n\n  // Override this to define how to set up the environment.\n  virtual void SetUp() {}\n\n  // Override this to define how to tear down the environment.\n  virtual void TearDown() {}\n private:\n  // If you see an error about overriding the following function or\n  // about it being private, you have mis-spelled SetUp() as Setup().\n  struct Setup_should_be_spelled_SetUp {};\n  virtual Setup_should_be_spelled_SetUp* Setup() { return NULL; }\n};\n\n// The interface for tracing execution of tests. The methods are organized in\n// the order the corresponding events are fired.\nclass TestEventListener {\n public:\n  virtual ~TestEventListener() {}\n\n  // Fired before any test activity starts.\n  virtual void OnTestProgramStart(const UnitTest& unit_test) = 0;\n\n  // Fired before each iteration of tests starts.  There may be more than\n  // one iteration if GTEST_FLAG(repeat) is set. iteration is the iteration\n  // index, starting from 0.\n  virtual void OnTestIterationStart(const UnitTest& unit_test,\n                                    int iteration) = 0;\n\n  // Fired before environment set-up for each iteration of tests starts.\n  virtual void OnEnvironmentsSetUpStart(const UnitTest& unit_test) = 0;\n\n  // Fired after environment set-up for each iteration of tests ends.\n  virtual void OnEnvironmentsSetUpEnd(const UnitTest& unit_test) = 0;\n\n  // Fired before the test case starts.\n  virtual void OnTestCaseStart(const TestCase& test_case) = 0;\n\n  // Fired before the test starts.\n  virtual void OnTestStart(const TestInfo& test_info) = 0;\n\n  // Fired after a failed assertion or a SUCCEED() invocation.\n  virtual void OnTestPartResult(const TestPartResult& test_part_result) = 0;\n\n  // Fired after the test ends.\n  virtual void OnTestEnd(const TestInfo& test_info) = 0;\n\n  // Fired after the test case ends.\n  virtual void OnTestCaseEnd(const TestCase& test_case) = 0;\n\n  // Fired before environment tear-down for each iteration of tests starts.\n  virtual void OnEnvironmentsTearDownStart(const UnitTest& unit_test) = 0;\n\n  // Fired after environment tear-down for each iteration of tests ends.\n  virtual void OnEnvironmentsTearDownEnd(const UnitTest& unit_test) = 0;\n\n  // Fired after each iteration of tests finishes.\n  virtual void OnTestIterationEnd(const UnitTest& unit_test,\n                                  int iteration) = 0;\n\n  // Fired after all test activities have ended.\n  virtual void OnTestProgramEnd(const UnitTest& unit_test) = 0;\n};\n\n// The convenience class for users who need to override just one or two\n// methods and are not concerned that a possible change to a signature of\n// the methods they override will not be caught during the build.  For\n// comments about each method please see the definition of TestEventListener\n// above.\nclass EmptyTestEventListener : public TestEventListener {\n public:\n  virtual void OnTestProgramStart(const UnitTest& /*unit_test*/) {}\n  virtual void OnTestIterationStart(const UnitTest& /*unit_test*/,\n                                    int /*iteration*/) {}\n  virtual void OnEnvironmentsSetUpStart(const UnitTest& /*unit_test*/) {}\n  virtual void OnEnvironmentsSetUpEnd(const UnitTest& /*unit_test*/) {}\n  virtual void OnTestCaseStart(const TestCase& /*test_case*/) {}\n  virtual void OnTestStart(const TestInfo& /*test_info*/) {}\n  virtual void OnTestPartResult(const TestPartResult& /*test_part_result*/) {}\n  virtual void OnTestEnd(const TestInfo& /*test_info*/) {}\n  virtual void OnTestCaseEnd(const TestCase& /*test_case*/) {}\n  virtual void OnEnvironmentsTearDownStart(const UnitTest& /*unit_test*/) {}\n  virtual void OnEnvironmentsTearDownEnd(const UnitTest& /*unit_test*/) {}\n  virtual void OnTestIterationEnd(const UnitTest& /*unit_test*/,\n                                  int /*iteration*/) {}\n  virtual void OnTestProgramEnd(const UnitTest& /*unit_test*/) {}\n};\n\n// TestEventListeners lets users add listeners to track events in Google Test.\nclass GTEST_API_ TestEventListeners {\n public:\n  TestEventListeners();\n  ~TestEventListeners();\n\n  // Appends an event listener to the end of the list. Google Test assumes\n  // the ownership of the listener (i.e. it will delete the listener when\n  // the test program finishes).\n  void Append(TestEventListener* listener);\n\n  // Removes the given event listener from the list and returns it.  It then\n  // becomes the caller's responsibility to delete the listener. Returns\n  // NULL if the listener is not found in the list.\n  TestEventListener* Release(TestEventListener* listener);\n\n  // Returns the standard listener responsible for the default console\n  // output.  Can be removed from the listeners list to shut down default\n  // console output.  Note that removing this object from the listener list\n  // with Release transfers its ownership to the caller and makes this\n  // function return NULL the next time.\n  TestEventListener* default_result_printer() const {\n    return default_result_printer_;\n  }\n\n  // Returns the standard listener responsible for the default XML output\n  // controlled by the --gtest_output=xml flag.  Can be removed from the\n  // listeners list by users who want to shut down the default XML output\n  // controlled by this flag and substitute it with custom one.  Note that\n  // removing this object from the listener list with Release transfers its\n  // ownership to the caller and makes this function return NULL the next\n  // time.\n  TestEventListener* default_xml_generator() const {\n    return default_xml_generator_;\n  }\n\n private:\n  friend class TestCase;\n  friend class TestInfo;\n  friend class internal::DefaultGlobalTestPartResultReporter;\n  friend class internal::NoExecDeathTest;\n  friend class internal::TestEventListenersAccessor;\n  friend class internal::UnitTestImpl;\n\n  // Returns repeater that broadcasts the TestEventListener events to all\n  // subscribers.\n  TestEventListener* repeater();\n\n  // Sets the default_result_printer attribute to the provided listener.\n  // The listener is also added to the listener list and previous\n  // default_result_printer is removed from it and deleted. The listener can\n  // also be NULL in which case it will not be added to the list. Does\n  // nothing if the previous and the current listener objects are the same.\n  void SetDefaultResultPrinter(TestEventListener* listener);\n\n  // Sets the default_xml_generator attribute to the provided listener.  The\n  // listener is also added to the listener list and previous\n  // default_xml_generator is removed from it and deleted. The listener can\n  // also be NULL in which case it will not be added to the list. Does\n  // nothing if the previous and the current listener objects are the same.\n  void SetDefaultXmlGenerator(TestEventListener* listener);\n\n  // Controls whether events will be forwarded by the repeater to the\n  // listeners in the list.\n  bool EventForwardingEnabled() const;\n  void SuppressEventForwarding();\n\n  // The actual list of listeners.\n  internal::TestEventRepeater* repeater_;\n  // Listener responsible for the standard result output.\n  TestEventListener* default_result_printer_;\n  // Listener responsible for the creation of the XML output file.\n  TestEventListener* default_xml_generator_;\n\n  // We disallow copying TestEventListeners.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestEventListeners);\n};\n\n// A UnitTest consists of a vector of TestCases.\n//\n// This is a singleton class.  The only instance of UnitTest is\n// created when UnitTest::GetInstance() is first called.  This\n// instance is never deleted.\n//\n// UnitTest is not copyable.\n//\n// This class is thread-safe as long as the methods are called\n// according to their specification.\nclass GTEST_API_ UnitTest {\n public:\n  // Gets the singleton UnitTest object.  The first time this method\n  // is called, a UnitTest object is constructed and returned.\n  // Consecutive calls will return the same object.\n  static UnitTest* GetInstance();\n\n  // Runs all tests in this UnitTest object and prints the result.\n  // Returns 0 if successful, or 1 otherwise.\n  //\n  // This method can only be called from the main thread.\n  //\n  // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n  int Run() GTEST_MUST_USE_RESULT_;\n\n  // Returns the working directory when the first TEST() or TEST_F()\n  // was executed.  The UnitTest object owns the string.\n  const char* original_working_dir() const;\n\n  // Returns the TestCase object for the test that's currently running,\n  // or NULL if no test is running.\n  const TestCase* current_test_case() const\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Returns the TestInfo object for the test that's currently running,\n  // or NULL if no test is running.\n  const TestInfo* current_test_info() const\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Returns the random seed used at the start of the current test run.\n  int random_seed() const;\n\n#if GTEST_HAS_PARAM_TEST\n  // Returns the ParameterizedTestCaseRegistry object used to keep track of\n  // value-parameterized tests and instantiate and register them.\n  //\n  // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n  internal::ParameterizedTestCaseRegistry& parameterized_test_registry()\n      GTEST_LOCK_EXCLUDED_(mutex_);\n#endif  // GTEST_HAS_PARAM_TEST\n\n  // Gets the number of successful test cases.\n  int successful_test_case_count() const;\n\n  // Gets the number of failed test cases.\n  int failed_test_case_count() const;\n\n  // Gets the number of all test cases.\n  int total_test_case_count() const;\n\n  // Gets the number of all test cases that contain at least one test\n  // that should run.\n  int test_case_to_run_count() const;\n\n  // Gets the number of successful tests.\n  int successful_test_count() const;\n\n  // Gets the number of failed tests.\n  int failed_test_count() const;\n\n  // Gets the number of disabled tests that will be reported in the XML report.\n  int reportable_disabled_test_count() const;\n\n  // Gets the number of disabled tests.\n  int disabled_test_count() const;\n\n  // Gets the number of tests to be printed in the XML report.\n  int reportable_test_count() const;\n\n  // Gets the number of all tests.\n  int total_test_count() const;\n\n  // Gets the number of tests that should run.\n  int test_to_run_count() const;\n\n  // Gets the time of the test program start, in ms from the start of the\n  // UNIX epoch.\n  TimeInMillis start_timestamp() const;\n\n  // Gets the elapsed time, in milliseconds.\n  TimeInMillis elapsed_time() const;\n\n  // Returns true iff the unit test passed (i.e. all test cases passed).\n  bool Passed() const;\n\n  // Returns true iff the unit test failed (i.e. some test case failed\n  // or something outside of all tests failed).\n  bool Failed() const;\n\n  // Gets the i-th test case among all the test cases. i can range from 0 to\n  // total_test_case_count() - 1. If i is not in that range, returns NULL.\n  const TestCase* GetTestCase(int i) const;\n\n  // Returns the TestResult containing information on test failures and\n  // properties logged outside of individual test cases.\n  const TestResult& ad_hoc_test_result() const;\n\n  // Returns the list of event listeners that can be used to track events\n  // inside Google Test.\n  TestEventListeners& listeners();\n\n private:\n  // Registers and returns a global test environment.  When a test\n  // program is run, all global test environments will be set-up in\n  // the order they were registered.  After all tests in the program\n  // have finished, all global test environments will be torn-down in\n  // the *reverse* order they were registered.\n  //\n  // The UnitTest object takes ownership of the given environment.\n  //\n  // This method can only be called from the main thread.\n  Environment* AddEnvironment(Environment* env);\n\n  // Adds a TestPartResult to the current TestResult object.  All\n  // Google Test assertion macros (e.g. ASSERT_TRUE, EXPECT_EQ, etc)\n  // eventually call this to report their results.  The user code\n  // should use the assertion macros instead of calling this directly.\n  void AddTestPartResult(TestPartResult::Type result_type,\n                         const char* file_name,\n                         int line_number,\n                         const std::string& message,\n                         const std::string& os_stack_trace)\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Adds a TestProperty to the current TestResult object when invoked from\n  // inside a test, to current TestCase's ad_hoc_test_result_ when invoked\n  // from SetUpTestCase or TearDownTestCase, or to the global property set\n  // when invoked elsewhere.  If the result already contains a property with\n  // the same key, the value will be updated.\n  void RecordProperty(const std::string& key, const std::string& value);\n\n  // Gets the i-th test case among all the test cases. i can range from 0 to\n  // total_test_case_count() - 1. If i is not in that range, returns NULL.\n  TestCase* GetMutableTestCase(int i);\n\n  // Accessors for the implementation object.\n  internal::UnitTestImpl* impl() { return impl_; }\n  const internal::UnitTestImpl* impl() const { return impl_; }\n\n  // These classes and funcions are friends as they need to access private\n  // members of UnitTest.\n  friend class Test;\n  friend class internal::AssertHelper;\n  friend class internal::ScopedTrace;\n  friend class internal::StreamingListenerTest;\n  friend class internal::UnitTestRecordPropertyTestHelper;\n  friend Environment* AddGlobalTestEnvironment(Environment* env);\n  friend internal::UnitTestImpl* internal::GetUnitTestImpl();\n  friend void internal::ReportFailureInUnknownLocation(\n      TestPartResult::Type result_type,\n      const std::string& message);\n\n  // Creates an empty UnitTest.\n  UnitTest();\n\n  // D'tor\n  virtual ~UnitTest();\n\n  // Pushes a trace defined by SCOPED_TRACE() on to the per-thread\n  // Google Test trace stack.\n  void PushGTestTrace(const internal::TraceInfo& trace)\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Pops a trace from the per-thread Google Test trace stack.\n  void PopGTestTrace()\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Protects mutable state in *impl_.  This is mutable as some const\n  // methods need to lock it too.\n  mutable internal::Mutex mutex_;\n\n  // Opaque implementation object.  This field is never changed once\n  // the object is constructed.  We don't mark it as const here, as\n  // doing so will cause a warning in the constructor of UnitTest.\n  // Mutable state in *impl_ is protected by mutex_.\n  internal::UnitTestImpl* impl_;\n\n  // We disallow copying UnitTest.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(UnitTest);\n};\n\n// A convenient wrapper for adding an environment for the test\n// program.\n//\n// You should call this before RUN_ALL_TESTS() is called, probably in\n// main().  If you use gtest_main, you need to call this before main()\n// starts for it to take effect.  For example, you can define a global\n// variable like this:\n//\n//   testing::Environment* const foo_env =\n//       testing::AddGlobalTestEnvironment(new FooEnvironment);\n//\n// However, we strongly recommend you to write your own main() and\n// call AddGlobalTestEnvironment() there, as relying on initialization\n// of global variables makes the code harder to read and may cause\n// problems when you register multiple environments from different\n// translation units and the environments have dependencies among them\n// (remember that the compiler doesn't guarantee the order in which\n// global variables from different translation units are initialized).\ninline Environment* AddGlobalTestEnvironment(Environment* env) {\n  return UnitTest::GetInstance()->AddEnvironment(env);\n}\n\n// Initializes Google Test.  This must be called before calling\n// RUN_ALL_TESTS().  In particular, it parses a command line for the\n// flags that Google Test recognizes.  Whenever a Google Test flag is\n// seen, it is removed from argv, and *argc is decremented.\n//\n// No value is returned.  Instead, the Google Test flag variables are\n// updated.\n//\n// Calling the function for the second time has no user-visible effect.\nGTEST_API_ void InitGoogleTest(int* argc, char** argv);\n\n// This overloaded version can be used in Windows programs compiled in\n// UNICODE mode.\nGTEST_API_ void InitGoogleTest(int* argc, wchar_t** argv);\n\nnamespace internal {\n\n// Separate the error generating code from the code path to reduce the stack\n// frame size of CmpHelperEQ. This helps reduce the overhead of some sanitizers\n// when calling EXPECT_* in a tight loop.\ntemplate <typename T1, typename T2>\nAssertionResult CmpHelperEQFailure(const char* lhs_expression,\n                                   const char* rhs_expression,\n                                   const T1& lhs, const T2& rhs) {\n  return EqFailure(lhs_expression,\n                   rhs_expression,\n                   FormatForComparisonFailureMessage(lhs, rhs),\n                   FormatForComparisonFailureMessage(rhs, lhs),\n                   false);\n}\n\n// The helper function for {ASSERT|EXPECT}_EQ.\ntemplate <typename T1, typename T2>\nAssertionResult CmpHelperEQ(const char* lhs_expression,\n                            const char* rhs_expression,\n                            const T1& lhs,\n                            const T2& rhs) {\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(4389 /* signed/unsigned mismatch */)\n  if (lhs == rhs) {\n    return AssertionSuccess();\n  }\nGTEST_DISABLE_MSC_WARNINGS_POP_()\n\n  return CmpHelperEQFailure(lhs_expression, rhs_expression, lhs, rhs);\n}\n\n// With this overloaded version, we allow anonymous enums to be used\n// in {ASSERT|EXPECT}_EQ when compiled with gcc 4, as anonymous enums\n// can be implicitly cast to BiggestInt.\nGTEST_API_ AssertionResult CmpHelperEQ(const char* lhs_expression,\n                                       const char* rhs_expression,\n                                       BiggestInt lhs,\n                                       BiggestInt rhs);\n\n// The helper class for {ASSERT|EXPECT}_EQ.  The template argument\n// lhs_is_null_literal is true iff the first argument to ASSERT_EQ()\n// is a null pointer literal.  The following default implementation is\n// for lhs_is_null_literal being false.\ntemplate <bool lhs_is_null_literal>\nclass EqHelper {\n public:\n  // This templatized version is for the general case.\n  template <typename T1, typename T2>\n  static AssertionResult Compare(const char* lhs_expression,\n                                 const char* rhs_expression,\n                                 const T1& lhs,\n                                 const T2& rhs) {\n    return CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);\n  }\n\n  // With this overloaded version, we allow anonymous enums to be used\n  // in {ASSERT|EXPECT}_EQ when compiled with gcc 4, as anonymous\n  // enums can be implicitly cast to BiggestInt.\n  //\n  // Even though its body looks the same as the above version, we\n  // cannot merge the two, as it will make anonymous enums unhappy.\n  static AssertionResult Compare(const char* lhs_expression,\n                                 const char* rhs_expression,\n                                 BiggestInt lhs,\n                                 BiggestInt rhs) {\n    return CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);\n  }\n};\n\n// This specialization is used when the first argument to ASSERT_EQ()\n// is a null pointer literal, like NULL, false, or 0.\ntemplate <>\nclass EqHelper<true> {\n public:\n  // We define two overloaded versions of Compare().  The first\n  // version will be picked when the second argument to ASSERT_EQ() is\n  // NOT a pointer, e.g. ASSERT_EQ(0, AnIntFunction()) or\n  // EXPECT_EQ(false, a_bool).\n  template <typename T1, typename T2>\n  static AssertionResult Compare(\n      const char* lhs_expression,\n      const char* rhs_expression,\n      const T1& lhs,\n      const T2& rhs,\n      // The following line prevents this overload from being considered if T2\n      // is not a pointer type.  We need this because ASSERT_EQ(NULL, my_ptr)\n      // expands to Compare(\"\", \"\", NULL, my_ptr), which requires a conversion\n      // to match the Secret* in the other overload, which would otherwise make\n      // this template match better.\n      typename EnableIf<!is_pointer<T2>::value>::type* = 0) {\n    return CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);\n  }\n\n  // This version will be picked when the second argument to ASSERT_EQ() is a\n  // pointer, e.g. ASSERT_EQ(NULL, a_pointer).\n  template <typename T>\n  static AssertionResult Compare(\n      const char* lhs_expression,\n      const char* rhs_expression,\n      // We used to have a second template parameter instead of Secret*.  That\n      // template parameter would deduce to 'long', making this a better match\n      // than the first overload even without the first overload's EnableIf.\n      // Unfortunately, gcc with -Wconversion-null warns when \"passing NULL to\n      // non-pointer argument\" (even a deduced integral argument), so the old\n      // implementation caused warnings in user code.\n      Secret* /* lhs (NULL) */,\n      T* rhs) {\n    // We already know that 'lhs' is a null pointer.\n    return CmpHelperEQ(lhs_expression, rhs_expression,\n                       static_cast<T*>(NULL), rhs);\n  }\n};\n\n// Separate the error generating code from the code path to reduce the stack\n// frame size of CmpHelperOP. This helps reduce the overhead of some sanitizers\n// when calling EXPECT_OP in a tight loop.\ntemplate <typename T1, typename T2>\nAssertionResult CmpHelperOpFailure(const char* expr1, const char* expr2,\n                                   const T1& val1, const T2& val2,\n                                   const char* op) {\n  return AssertionFailure()\n         << \"Expected: (\" << expr1 << \") \" << op << \" (\" << expr2\n         << \"), actual: \" << FormatForComparisonFailureMessage(val1, val2)\n         << \" vs \" << FormatForComparisonFailureMessage(val2, val1);\n}\n\n// A macro for implementing the helper functions needed to implement\n// ASSERT_?? and EXPECT_??.  It is here just to avoid copy-and-paste\n// of similar code.\n//\n// For each templatized helper function, we also define an overloaded\n// version for BiggestInt in order to reduce code bloat and allow\n// anonymous enums to be used with {ASSERT|EXPECT}_?? when compiled\n// with gcc 4.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n\n#define GTEST_IMPL_CMP_HELPER_(op_name, op)\\\ntemplate <typename T1, typename T2>\\\nAssertionResult CmpHelper##op_name(const char* expr1, const char* expr2, \\\n                                   const T1& val1, const T2& val2) {\\\n  if (val1 op val2) {\\\n    return AssertionSuccess();\\\n  } else {\\\n    return CmpHelperOpFailure(expr1, expr2, val1, val2, #op);\\\n  }\\\n}\\\nGTEST_API_ AssertionResult CmpHelper##op_name(\\\n    const char* expr1, const char* expr2, BiggestInt val1, BiggestInt val2)\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n\n// Implements the helper function for {ASSERT|EXPECT}_NE\nGTEST_IMPL_CMP_HELPER_(NE, !=);\n// Implements the helper function for {ASSERT|EXPECT}_LE\nGTEST_IMPL_CMP_HELPER_(LE, <=);\n// Implements the helper function for {ASSERT|EXPECT}_LT\nGTEST_IMPL_CMP_HELPER_(LT, <);\n// Implements the helper function for {ASSERT|EXPECT}_GE\nGTEST_IMPL_CMP_HELPER_(GE, >=);\n// Implements the helper function for {ASSERT|EXPECT}_GT\nGTEST_IMPL_CMP_HELPER_(GT, >);\n\n#undef GTEST_IMPL_CMP_HELPER_\n\n// The helper function for {ASSERT|EXPECT}_STREQ.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTREQ(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const char* s1,\n                                          const char* s2);\n\n// The helper function for {ASSERT|EXPECT}_STRCASEEQ.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRCASEEQ(const char* s1_expression,\n                                              const char* s2_expression,\n                                              const char* s1,\n                                              const char* s2);\n\n// The helper function for {ASSERT|EXPECT}_STRNE.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRNE(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const char* s1,\n                                          const char* s2);\n\n// The helper function for {ASSERT|EXPECT}_STRCASENE.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRCASENE(const char* s1_expression,\n                                              const char* s2_expression,\n                                              const char* s1,\n                                              const char* s2);\n\n\n// Helper function for *_STREQ on wide strings.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTREQ(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const wchar_t* s1,\n                                          const wchar_t* s2);\n\n// Helper function for *_STRNE on wide strings.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRNE(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const wchar_t* s1,\n                                          const wchar_t* s2);\n\n}  // namespace internal\n\n// IsSubstring() and IsNotSubstring() are intended to be used as the\n// first argument to {EXPECT,ASSERT}_PRED_FORMAT2(), not by\n// themselves.  They check whether needle is a substring of haystack\n// (NULL is considered a substring of itself only), and return an\n// appropriate error message when they fail.\n//\n// The {needle,haystack}_expr arguments are the stringified\n// expressions that generated the two real arguments.\nGTEST_API_ AssertionResult IsSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const char* needle, const char* haystack);\nGTEST_API_ AssertionResult IsSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const wchar_t* needle, const wchar_t* haystack);\nGTEST_API_ AssertionResult IsNotSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const char* needle, const char* haystack);\nGTEST_API_ AssertionResult IsNotSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const wchar_t* needle, const wchar_t* haystack);\nGTEST_API_ AssertionResult IsSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const ::std::string& needle, const ::std::string& haystack);\nGTEST_API_ AssertionResult IsNotSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const ::std::string& needle, const ::std::string& haystack);\n\n#if GTEST_HAS_STD_WSTRING\nGTEST_API_ AssertionResult IsSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const ::std::wstring& needle, const ::std::wstring& haystack);\nGTEST_API_ AssertionResult IsNotSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const ::std::wstring& needle, const ::std::wstring& haystack);\n#endif  // GTEST_HAS_STD_WSTRING\n\nnamespace internal {\n\n// Helper template function for comparing floating-points.\n//\n// Template parameter:\n//\n//   RawType: the raw floating-point type (either float or double)\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\ntemplate <typename RawType>\nAssertionResult CmpHelperFloatingPointEQ(const char* lhs_expression,\n                                         const char* rhs_expression,\n                                         RawType lhs_value,\n                                         RawType rhs_value) {\n  const FloatingPoint<RawType> lhs(lhs_value), rhs(rhs_value);\n\n  if (lhs.AlmostEquals(rhs)) {\n    return AssertionSuccess();\n  }\n\n  ::std::stringstream lhs_ss;\n  lhs_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)\n         << lhs_value;\n\n  ::std::stringstream rhs_ss;\n  rhs_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)\n         << rhs_value;\n\n  return EqFailure(lhs_expression,\n                   rhs_expression,\n                   StringStreamToString(&lhs_ss),\n                   StringStreamToString(&rhs_ss),\n                   false);\n}\n\n// Helper function for implementing ASSERT_NEAR.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult DoubleNearPredFormat(const char* expr1,\n                                                const char* expr2,\n                                                const char* abs_error_expr,\n                                                double val1,\n                                                double val2,\n                                                double abs_error);\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n// A class that enables one to stream messages to assertion macros\nclass GTEST_API_ AssertHelper {\n public:\n  // Constructor.\n  AssertHelper(TestPartResult::Type type,\n               const char* file,\n               int line,\n               const char* message);\n  ~AssertHelper();\n\n  // Message assignment is a semantic trick to enable assertion\n  // streaming; see the GTEST_MESSAGE_ macro below.\n  void operator=(const Message& message) const;\n\n private:\n  // We put our data in a struct so that the size of the AssertHelper class can\n  // be as small as possible.  This is important because gcc is incapable of\n  // re-using stack space even for temporary variables, so every EXPECT_EQ\n  // reserves stack space for another AssertHelper.\n  struct AssertHelperData {\n    AssertHelperData(TestPartResult::Type t,\n                     const char* srcfile,\n                     int line_num,\n                     const char* msg)\n        : type(t), file(srcfile), line(line_num), message(msg) { }\n\n    TestPartResult::Type const type;\n    const char* const file;\n    int const line;\n    std::string const message;\n\n   private:\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(AssertHelperData);\n  };\n\n  AssertHelperData* const data_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(AssertHelper);\n};\n\n}  // namespace internal\n\n#if GTEST_HAS_PARAM_TEST\n// The pure interface class that all value-parameterized tests inherit from.\n// A value-parameterized class must inherit from both ::testing::Test and\n// ::testing::WithParamInterface. In most cases that just means inheriting\n// from ::testing::TestWithParam, but more complicated test hierarchies\n// may need to inherit from Test and WithParamInterface at different levels.\n//\n// This interface has support for accessing the test parameter value via\n// the GetParam() method.\n//\n// Use it with one of the parameter generator defining functions, like Range(),\n// Values(), ValuesIn(), Bool(), and Combine().\n//\n// class FooTest : public ::testing::TestWithParam<int> {\n//  protected:\n//   FooTest() {\n//     // Can use GetParam() here.\n//   }\n//   virtual ~FooTest() {\n//     // Can use GetParam() here.\n//   }\n//   virtual void SetUp() {\n//     // Can use GetParam() here.\n//   }\n//   virtual void TearDown {\n//     // Can use GetParam() here.\n//   }\n// };\n// TEST_P(FooTest, DoesBar) {\n//   // Can use GetParam() method here.\n//   Foo foo;\n//   ASSERT_TRUE(foo.DoesBar(GetParam()));\n// }\n// INSTANTIATE_TEST_CASE_P(OneToTenRange, FooTest, ::testing::Range(1, 10));\n\ntemplate <typename T>\nclass WithParamInterface {\n public:\n  typedef T ParamType;\n  virtual ~WithParamInterface() {}\n\n  // The current parameter value. Is also available in the test fixture's\n  // constructor. This member function is non-static, even though it only\n  // references static data, to reduce the opportunity for incorrect uses\n  // like writing 'WithParamInterface<bool>::GetParam()' for a test that\n  // uses a fixture whose parameter type is int.\n  const ParamType& GetParam() const {\n    GTEST_CHECK_(parameter_ != NULL)\n        << \"GetParam() can only be called inside a value-parameterized test \"\n        << \"-- did you intend to write TEST_P instead of TEST_F?\";\n    return *parameter_;\n  }\n\n private:\n  // Sets parameter value. The caller is responsible for making sure the value\n  // remains alive and unchanged throughout the current test.\n  static void SetParam(const ParamType* parameter) {\n    parameter_ = parameter;\n  }\n\n  // Static value used for accessing parameter during a test lifetime.\n  static const ParamType* parameter_;\n\n  // TestClass must be a subclass of WithParamInterface<T> and Test.\n  template <class TestClass> friend class internal::ParameterizedTestFactory;\n};\n\ntemplate <typename T>\nconst T* WithParamInterface<T>::parameter_ = NULL;\n\n// Most value-parameterized classes can ignore the existence of\n// WithParamInterface, and can just inherit from ::testing::TestWithParam.\n\ntemplate <typename T>\nclass TestWithParam : public Test, public WithParamInterface<T> {\n};\n\n#endif  // GTEST_HAS_PARAM_TEST\n\n// Macros for indicating success/failure in test code.\n\n// ADD_FAILURE unconditionally adds a failure to the current test.\n// SUCCEED generates a success - it doesn't automatically make the\n// current test successful, as a test is only successful when it has\n// no failure.\n//\n// EXPECT_* verifies that a certain condition is satisfied.  If not,\n// it behaves like ADD_FAILURE.  In particular:\n//\n//   EXPECT_TRUE  verifies that a Boolean condition is true.\n//   EXPECT_FALSE verifies that a Boolean condition is false.\n//\n// FAIL and ASSERT_* are similar to ADD_FAILURE and EXPECT_*, except\n// that they will also abort the current function on failure.  People\n// usually want the fail-fast behavior of FAIL and ASSERT_*, but those\n// writing data-driven tests often find themselves using ADD_FAILURE\n// and EXPECT_* more.\n\n// Generates a nonfatal failure with a generic message.\n#define ADD_FAILURE() GTEST_NONFATAL_FAILURE_(\"Failed\")\n\n// Generates a nonfatal failure at the given source file location with\n// a generic message.\n#define ADD_FAILURE_AT(file, line) \\\n  GTEST_MESSAGE_AT_(file, line, \"Failed\", \\\n                    ::testing::TestPartResult::kNonFatalFailure)\n\n// Generates a fatal failure with a generic message.\n#define GTEST_FAIL() GTEST_FATAL_FAILURE_(\"Failed\")\n\n// Define this macro to 1 to omit the definition of FAIL(), which is a\n// generic name and clashes with some other libraries.\n#if !GTEST_DONT_DEFINE_FAIL\n# define FAIL() GTEST_FAIL()\n#endif\n\n// Generates a success with a generic message.\n#define GTEST_SUCCEED() GTEST_SUCCESS_(\"Succeeded\")\n\n// Define this macro to 1 to omit the definition of SUCCEED(), which\n// is a generic name and clashes with some other libraries.\n#if !GTEST_DONT_DEFINE_SUCCEED\n# define SUCCEED() GTEST_SUCCEED()\n#endif\n\n// Macros for testing exceptions.\n//\n//    * {ASSERT|EXPECT}_THROW(statement, expected_exception):\n//         Tests that the statement throws the expected exception.\n//    * {ASSERT|EXPECT}_NO_THROW(statement):\n//         Tests that the statement doesn't throw any exception.\n//    * {ASSERT|EXPECT}_ANY_THROW(statement):\n//         Tests that the statement throws an exception.\n\n#define EXPECT_THROW(statement, expected_exception) \\\n  GTEST_TEST_THROW_(statement, expected_exception, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_NO_THROW(statement) \\\n  GTEST_TEST_NO_THROW_(statement, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_ANY_THROW(statement) \\\n  GTEST_TEST_ANY_THROW_(statement, GTEST_NONFATAL_FAILURE_)\n#define ASSERT_THROW(statement, expected_exception) \\\n  GTEST_TEST_THROW_(statement, expected_exception, GTEST_FATAL_FAILURE_)\n#define ASSERT_NO_THROW(statement) \\\n  GTEST_TEST_NO_THROW_(statement, GTEST_FATAL_FAILURE_)\n#define ASSERT_ANY_THROW(statement) \\\n  GTEST_TEST_ANY_THROW_(statement, GTEST_FATAL_FAILURE_)\n\n// Boolean assertions. Condition can be either a Boolean expression or an\n// AssertionResult. For more information on how to use AssertionResult with\n// these macros see comments on that class.\n#define EXPECT_TRUE(condition) \\\n  GTEST_TEST_BOOLEAN_((condition), #condition, false, true, \\\n                      GTEST_NONFATAL_FAILURE_)\n#define EXPECT_FALSE(condition) \\\n  GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, \\\n                      GTEST_NONFATAL_FAILURE_)\n#define ASSERT_TRUE(condition) \\\n  GTEST_TEST_BOOLEAN_((condition), #condition, false, true, \\\n                      GTEST_FATAL_FAILURE_)\n#define ASSERT_FALSE(condition) \\\n  GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, \\\n                      GTEST_FATAL_FAILURE_)\n\n// Includes the auto-generated header that implements a family of\n// generic predicate assertion macros.\n#include \"gtest/gtest_pred_impl.h\"\n\n// Macros for testing equalities and inequalities.\n//\n//    * {ASSERT|EXPECT}_EQ(v1, v2): Tests that v1 == v2\n//    * {ASSERT|EXPECT}_NE(v1, v2): Tests that v1 != v2\n//    * {ASSERT|EXPECT}_LT(v1, v2): Tests that v1 < v2\n//    * {ASSERT|EXPECT}_LE(v1, v2): Tests that v1 <= v2\n//    * {ASSERT|EXPECT}_GT(v1, v2): Tests that v1 > v2\n//    * {ASSERT|EXPECT}_GE(v1, v2): Tests that v1 >= v2\n//\n// When they are not, Google Test prints both the tested expressions and\n// their actual values.  The values must be compatible built-in types,\n// or you will get a compiler error.  By \"compatible\" we mean that the\n// values can be compared by the respective operator.\n//\n// Note:\n//\n//   1. It is possible to make a user-defined type work with\n//   {ASSERT|EXPECT}_??(), but that requires overloading the\n//   comparison operators and is thus discouraged by the Google C++\n//   Usage Guide.  Therefore, you are advised to use the\n//   {ASSERT|EXPECT}_TRUE() macro to assert that two objects are\n//   equal.\n//\n//   2. The {ASSERT|EXPECT}_??() macros do pointer comparisons on\n//   pointers (in particular, C strings).  Therefore, if you use it\n//   with two C strings, you are testing how their locations in memory\n//   are related, not how their content is related.  To compare two C\n//   strings by content, use {ASSERT|EXPECT}_STR*().\n//\n//   3. {ASSERT|EXPECT}_EQ(v1, v2) is preferred to\n//   {ASSERT|EXPECT}_TRUE(v1 == v2), as the former tells you\n//   what the actual value is when it fails, and similarly for the\n//   other comparisons.\n//\n//   4. Do not depend on the order in which {ASSERT|EXPECT}_??()\n//   evaluate their arguments, which is undefined.\n//\n//   5. These macros evaluate their arguments exactly once.\n//\n// Examples:\n//\n//   EXPECT_NE(5, Foo());\n//   EXPECT_EQ(NULL, a_pointer);\n//   ASSERT_LT(i, array_size);\n//   ASSERT_GT(records.size(), 0) << \"There is no record left.\";\n\n#define EXPECT_EQ(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal:: \\\n                      EqHelper<GTEST_IS_NULL_LITERAL_(val1)>::Compare, \\\n                      val1, val2)\n#define EXPECT_NE(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperNE, val1, val2)\n#define EXPECT_LE(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperLE, val1, val2)\n#define EXPECT_LT(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperLT, val1, val2)\n#define EXPECT_GE(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperGE, val1, val2)\n#define EXPECT_GT(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperGT, val1, val2)\n\n#define GTEST_ASSERT_EQ(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal:: \\\n                      EqHelper<GTEST_IS_NULL_LITERAL_(val1)>::Compare, \\\n                      val1, val2)\n#define GTEST_ASSERT_NE(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperNE, val1, val2)\n#define GTEST_ASSERT_LE(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperLE, val1, val2)\n#define GTEST_ASSERT_LT(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperLT, val1, val2)\n#define GTEST_ASSERT_GE(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperGE, val1, val2)\n#define GTEST_ASSERT_GT(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperGT, val1, val2)\n\n// Define macro GTEST_DONT_DEFINE_ASSERT_XY to 1 to omit the definition of\n// ASSERT_XY(), which clashes with some users' own code.\n\n#if !GTEST_DONT_DEFINE_ASSERT_EQ\n# define ASSERT_EQ(val1, val2) GTEST_ASSERT_EQ(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_NE\n# define ASSERT_NE(val1, val2) GTEST_ASSERT_NE(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_LE\n# define ASSERT_LE(val1, val2) GTEST_ASSERT_LE(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_LT\n# define ASSERT_LT(val1, val2) GTEST_ASSERT_LT(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_GE\n# define ASSERT_GE(val1, val2) GTEST_ASSERT_GE(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_GT\n# define ASSERT_GT(val1, val2) GTEST_ASSERT_GT(val1, val2)\n#endif\n\n// C-string Comparisons.  All tests treat NULL and any non-NULL string\n// as different.  Two NULLs are equal.\n//\n//    * {ASSERT|EXPECT}_STREQ(s1, s2):     Tests that s1 == s2\n//    * {ASSERT|EXPECT}_STRNE(s1, s2):     Tests that s1 != s2\n//    * {ASSERT|EXPECT}_STRCASEEQ(s1, s2): Tests that s1 == s2, ignoring case\n//    * {ASSERT|EXPECT}_STRCASENE(s1, s2): Tests that s1 != s2, ignoring case\n//\n// For wide or narrow string objects, you can use the\n// {ASSERT|EXPECT}_??() macros.\n//\n// Don't depend on the order in which the arguments are evaluated,\n// which is undefined.\n//\n// These macros evaluate their arguments exactly once.\n\n#define EXPECT_STREQ(s1, s2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTREQ, s1, s2)\n#define EXPECT_STRNE(s1, s2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRNE, s1, s2)\n#define EXPECT_STRCASEEQ(s1, s2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASEEQ, s1, s2)\n#define EXPECT_STRCASENE(s1, s2)\\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASENE, s1, s2)\n\n#define ASSERT_STREQ(s1, s2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTREQ, s1, s2)\n#define ASSERT_STRNE(s1, s2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRNE, s1, s2)\n#define ASSERT_STRCASEEQ(s1, s2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASEEQ, s1, s2)\n#define ASSERT_STRCASENE(s1, s2)\\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASENE, s1, s2)\n\n// Macros for comparing floating-point numbers.\n//\n//    * {ASSERT|EXPECT}_FLOAT_EQ(val1, val2):\n//         Tests that two float values are almost equal.\n//    * {ASSERT|EXPECT}_DOUBLE_EQ(val1, val2):\n//         Tests that two double values are almost equal.\n//    * {ASSERT|EXPECT}_NEAR(v1, v2, abs_error):\n//         Tests that v1 and v2 are within the given distance to each other.\n//\n// Google Test uses ULP-based comparison to automatically pick a default\n// error bound that is appropriate for the operands.  See the\n// FloatingPoint template class in gtest-internal.h if you are\n// interested in the implementation details.\n\n#define EXPECT_FLOAT_EQ(val1, val2)\\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<float>, \\\n                      val1, val2)\n\n#define EXPECT_DOUBLE_EQ(val1, val2)\\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<double>, \\\n                      val1, val2)\n\n#define ASSERT_FLOAT_EQ(val1, val2)\\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<float>, \\\n                      val1, val2)\n\n#define ASSERT_DOUBLE_EQ(val1, val2)\\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<double>, \\\n                      val1, val2)\n\n#define EXPECT_NEAR(val1, val2, abs_error)\\\n  EXPECT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, \\\n                      val1, val2, abs_error)\n\n#define ASSERT_NEAR(val1, val2, abs_error)\\\n  ASSERT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, \\\n                      val1, val2, abs_error)\n\n// These predicate format functions work on floating-point values, and\n// can be used in {ASSERT|EXPECT}_PRED_FORMAT2*(), e.g.\n//\n//   EXPECT_PRED_FORMAT2(testing::DoubleLE, Foo(), 5.0);\n\n// Asserts that val1 is less than, or almost equal to, val2.  Fails\n// otherwise.  In particular, it fails if either val1 or val2 is NaN.\nGTEST_API_ AssertionResult FloatLE(const char* expr1, const char* expr2,\n                                   float val1, float val2);\nGTEST_API_ AssertionResult DoubleLE(const char* expr1, const char* expr2,\n                                    double val1, double val2);\n\n\n#if GTEST_OS_WINDOWS\n\n// Macros that test for HRESULT failure and success, these are only useful\n// on Windows, and rely on Windows SDK macros and APIs to compile.\n//\n//    * {ASSERT|EXPECT}_HRESULT_{SUCCEEDED|FAILED}(expr)\n//\n// When expr unexpectedly fails or succeeds, Google Test prints the\n// expected result and the actual result with both a human-readable\n// string representation of the error, if available, as well as the\n// hex result code.\n# define EXPECT_HRESULT_SUCCEEDED(expr) \\\n    EXPECT_PRED_FORMAT1(::testing::internal::IsHRESULTSuccess, (expr))\n\n# define ASSERT_HRESULT_SUCCEEDED(expr) \\\n    ASSERT_PRED_FORMAT1(::testing::internal::IsHRESULTSuccess, (expr))\n\n# define EXPECT_HRESULT_FAILED(expr) \\\n    EXPECT_PRED_FORMAT1(::testing::internal::IsHRESULTFailure, (expr))\n\n# define ASSERT_HRESULT_FAILED(expr) \\\n    ASSERT_PRED_FORMAT1(::testing::internal::IsHRESULTFailure, (expr))\n\n#endif  // GTEST_OS_WINDOWS\n\n// Macros that execute statement and check that it doesn't generate new fatal\n// failures in the current thread.\n//\n//   * {ASSERT|EXPECT}_NO_FATAL_FAILURE(statement);\n//\n// Examples:\n//\n//   EXPECT_NO_FATAL_FAILURE(Process());\n//   ASSERT_NO_FATAL_FAILURE(Process()) << \"Process() failed\";\n//\n#define ASSERT_NO_FATAL_FAILURE(statement) \\\n    GTEST_TEST_NO_FATAL_FAILURE_(statement, GTEST_FATAL_FAILURE_)\n#define EXPECT_NO_FATAL_FAILURE(statement) \\\n    GTEST_TEST_NO_FATAL_FAILURE_(statement, GTEST_NONFATAL_FAILURE_)\n\n// Causes a trace (including the source file path, the current line\n// number, and the given message) to be included in every test failure\n// message generated by code in the current scope.  The effect is\n// undone when the control leaves the current scope.\n//\n// The message argument can be anything streamable to std::ostream.\n//\n// In the implementation, we include the current line number as part\n// of the dummy variable name, thus allowing multiple SCOPED_TRACE()s\n// to appear in the same block - as long as they are on different\n// lines.\n#define SCOPED_TRACE(message) \\\n  ::testing::internal::ScopedTrace GTEST_CONCAT_TOKEN_(gtest_trace_, __LINE__)(\\\n    __FILE__, __LINE__, ::testing::Message() << (message))\n\n// Compile-time assertion for type equality.\n// StaticAssertTypeEq<type1, type2>() compiles iff type1 and type2 are\n// the same type.  The value it returns is not interesting.\n//\n// Instead of making StaticAssertTypeEq a class template, we make it a\n// function template that invokes a helper class template.  This\n// prevents a user from misusing StaticAssertTypeEq<T1, T2> by\n// defining objects of that type.\n//\n// CAVEAT:\n//\n// When used inside a method of a class template,\n// StaticAssertTypeEq<T1, T2>() is effective ONLY IF the method is\n// instantiated.  For example, given:\n//\n//   template <typename T> class Foo {\n//    public:\n//     void Bar() { testing::StaticAssertTypeEq<int, T>(); }\n//   };\n//\n// the code:\n//\n//   void Test1() { Foo<bool> foo; }\n//\n// will NOT generate a compiler error, as Foo<bool>::Bar() is never\n// actually instantiated.  Instead, you need:\n//\n//   void Test2() { Foo<bool> foo; foo.Bar(); }\n//\n// to cause a compiler error.\ntemplate <typename T1, typename T2>\nbool StaticAssertTypeEq() {\n  (void)internal::StaticAssertTypeEqHelper<T1, T2>();\n  return true;\n}\n\n// Defines a test.\n//\n// The first parameter is the name of the test case, and the second\n// parameter is the name of the test within the test case.\n//\n// The convention is to end the test case name with \"Test\".  For\n// example, a test case for the Foo class can be named FooTest.\n//\n// Test code should appear between braces after an invocation of\n// this macro.  Example:\n//\n//   TEST(FooTest, InitializesCorrectly) {\n//     Foo foo;\n//     EXPECT_TRUE(foo.StatusIsOK());\n//   }\n\n// Note that we call GetTestTypeId() instead of GetTypeId<\n// ::testing::Test>() here to get the type ID of testing::Test.  This\n// is to work around a suspected linker bug when using Google Test as\n// a framework on Mac OS X.  The bug causes GetTypeId<\n// ::testing::Test>() to return different values depending on whether\n// the call is from the Google Test framework itself or from user test\n// code.  GetTestTypeId() is guaranteed to always return the same\n// value, as it always calls GetTypeId<>() from the Google Test\n// framework.\n#define GTEST_TEST(test_case_name, test_name)\\\n  GTEST_TEST_(test_case_name, test_name, \\\n              ::testing::Test, ::testing::internal::GetTestTypeId())\n\n// Define this macro to 1 to omit the definition of TEST(), which\n// is a generic name and clashes with some other libraries.\n#if !GTEST_DONT_DEFINE_TEST\n# define TEST(test_case_name, test_name) GTEST_TEST(test_case_name, test_name)\n#endif\n\n// Defines a test that uses a test fixture.\n//\n// The first parameter is the name of the test fixture class, which\n// also doubles as the test case name.  The second parameter is the\n// name of the test within the test case.\n//\n// A test fixture class must be declared earlier.  The user should put\n// his test code between braces after using this macro.  Example:\n//\n//   class FooTest : public testing::Test {\n//    protected:\n//     virtual void SetUp() { b_.AddElement(3); }\n//\n//     Foo a_;\n//     Foo b_;\n//   };\n//\n//   TEST_F(FooTest, InitializesCorrectly) {\n//     EXPECT_TRUE(a_.StatusIsOK());\n//   }\n//\n//   TEST_F(FooTest, ReturnsElementCountCorrectly) {\n//     EXPECT_EQ(0, a_.size());\n//     EXPECT_EQ(1, b_.size());\n//   }\n\n#define TEST_F(test_fixture, test_name)\\\n  GTEST_TEST_(test_fixture, test_name, test_fixture, \\\n              ::testing::internal::GetTypeId<test_fixture>())\n\n}  // namespace testing\n\n// Use this function in main() to run all tests.  It returns 0 if all\n// tests are successful, or 1 otherwise.\n//\n// RUN_ALL_TESTS() should be invoked after the command line has been\n// parsed by InitGoogleTest().\n//\n// This function was formerly a macro; thus, it is in the global\n// namespace and has an all-caps name.\nint RUN_ALL_TESTS() GTEST_MUST_USE_RESULT_;\n\ninline int RUN_ALL_TESTS() {\n  return ::testing::UnitTest::GetInstance()->Run();\n}\n\n#endif  // GTEST_INCLUDE_GTEST_GTEST_H_\n"}, "42": {"id": 42, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/custom/raw-ostream.h", "content": "//===-- raw-ostream.h - Support for printing using raw_ostream --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n// This file is not part of gtest, but extends it to support LLVM libraries.\n// This is not a public API for testing - it's a detail of LLVM's gtest.\n//\n// gtest allows providing printers for custom types by defining operator<<.\n// In LLVM, operator<< usually takes llvm:raw_ostream& instead of std::ostream&.\n//\n// This file defines a template printable(V), which returns a version of V that\n// can be streamed into a std::ostream.\n//\n// This interface is chosen so that in the default case (printable(V) is V),\n// the main gtest code calls operator<<(OS, V) itself. gtest-printers carefully\n// controls the lookup to enable fallback printing (see testing::internal2).\n//===----------------------------------------------------------------------===//\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_CUSTOM_RAW_OSTREAM_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_CUSTOM_RAW_OSTREAM_H_\n\nnamespace llvm_gtest {\n// StreamSwitch is a trait that tells us how to stream a T into a std::ostream.\n// By default, we just stream the T directly. We'll specialize this later.\ntemplate <typename T, typename Enable = void> struct StreamSwitch {\n  static const T& printable(const T& V) { return V; }\n};\n\n// printable() returns a version of its argument that can be streamed into a\n// std::ostream. This may be the argument itself, or some other representation.\ntemplate <typename T> decltype(auto) printable(const T &V) {\n  // We delegate to the trait, to allow partial specialization.\n  return StreamSwitch<T>::printable(V);\n}\n} // namespace llvm_gtest\n\n// If raw_ostream support is enabled, we specialize for types with operator<<\n// that takes a raw_ostream.\n#if !GTEST_NO_LLVM_SUPPORT\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/Support/raw_os_ostream.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <ostream>\nnamespace llvm_gtest {\n\n// The printable() of a raw_ostream-enabled type T is a RawStreamProxy<T>.\n// It uses raw_os_ostream to write the wrapped value to a std::ostream.\ntemplate <typename T>\nstruct RawStreamProxy {\n  const T& V;\n  friend std::ostream &operator<<(std::ostream &S, const RawStreamProxy<T> &V) {\n    llvm::raw_os_ostream OS(S);\n    OS << V.V;\n    return S;\n  }\n};\n\n// We enable raw_ostream treatment if `(raw_ostream&) << (const T&)` is valid.\n// We don't want implicit conversions on the RHS (e.g. to bool!), so \"consume\"\n// the possible conversion by passing something convertible to const T& instead.\ntemplate <typename T> struct ConvertibleTo { operator T(); };\ntemplate <typename T>\nstruct StreamSwitch<T, decltype((void)(std::declval<llvm::raw_ostream &>()\n                                       << ConvertibleTo<const T &>()))> {\n  static const RawStreamProxy<T> printable(const T &V) { return {V}; }\n};\n\n// llvm::Optional has a template operator<<, which means it will not accept any\n// implicit conversions, so we need to special-case it here.\ntemplate <typename T>\nstruct StreamSwitch<llvm::Optional<T>,\n                    decltype((void)(std::declval<llvm::raw_ostream &>()\n                                    << std::declval<llvm::Optional<T>>()))> {\n  static const RawStreamProxy<llvm::Optional<T>>\n  printable(const llvm::Optional<T> &V) {\n    return {V};\n  }\n};\n} // namespace llvm_gtest\n#endif  // !GTEST_NO_LLVM_SUPPORT\n\n#endif // GTEST_INCLUDE_GTEST_INTERNAL_CUSTOM_RAW_OSTREAM_H_\n"}, "43": {"id": 43, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-death-test-internal.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Authors: wan@google.com (Zhanyong Wan), eefacm@gmail.com (Sean Mcafee)\n//\n// The Google C++ Testing Framework (Google Test)\n//\n// This header file defines internal utilities needed for implementing\n// death tests.  They are subject to change without notice.\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_DEATH_TEST_INTERNAL_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_DEATH_TEST_INTERNAL_H_\n\n#include \"gtest/internal/gtest-internal.h\"\n\n#include <stdio.h>\n\nnamespace testing {\nnamespace internal {\n\nGTEST_DECLARE_string_(internal_run_death_test);\n\n// Names of the flags (needed for parsing Google Test flags).\nconst char kDeathTestStyleFlag[] = \"death_test_style\";\nconst char kDeathTestUseFork[] = \"death_test_use_fork\";\nconst char kInternalRunDeathTestFlag[] = \"internal_run_death_test\";\n\n#if GTEST_HAS_DEATH_TEST\n\n// DeathTest is a class that hides much of the complexity of the\n// GTEST_DEATH_TEST_ macro.  It is abstract; its static Create method\n// returns a concrete class that depends on the prevailing death test\n// style, as defined by the --gtest_death_test_style and/or\n// --gtest_internal_run_death_test flags.\n\n// In describing the results of death tests, these terms are used with\n// the corresponding definitions:\n//\n// exit status:  The integer exit information in the format specified\n//               by wait(2)\n// exit code:    The integer code passed to exit(3), _exit(2), or\n//               returned from main()\nclass GTEST_API_ DeathTest {\n public:\n  // Create returns false if there was an error determining the\n  // appropriate action to take for the current death test; for example,\n  // if the gtest_death_test_style flag is set to an invalid value.\n  // The LastMessage method will return a more detailed message in that\n  // case.  Otherwise, the DeathTest pointer pointed to by the \"test\"\n  // argument is set.  If the death test should be skipped, the pointer\n  // is set to NULL; otherwise, it is set to the address of a new concrete\n  // DeathTest object that controls the execution of the current test.\n  static bool Create(const char* statement, const RE* regex,\n                     const char* file, int line, DeathTest** test);\n  DeathTest();\n  virtual ~DeathTest() { }\n\n  // A helper class that aborts a death test when it's deleted.\n  class ReturnSentinel {\n   public:\n    explicit ReturnSentinel(DeathTest* test) : test_(test) { }\n    ~ReturnSentinel() { test_->Abort(TEST_ENCOUNTERED_RETURN_STATEMENT); }\n   private:\n    DeathTest* const test_;\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(ReturnSentinel);\n  } GTEST_ATTRIBUTE_UNUSED_;\n\n  // An enumeration of possible roles that may be taken when a death\n  // test is encountered.  EXECUTE means that the death test logic should\n  // be executed immediately.  OVERSEE means that the program should prepare\n  // the appropriate environment for a child process to execute the death\n  // test, then wait for it to complete.\n  enum TestRole { OVERSEE_TEST, EXECUTE_TEST };\n\n  // An enumeration of the three reasons that a test might be aborted.\n  enum AbortReason {\n    TEST_ENCOUNTERED_RETURN_STATEMENT,\n    TEST_THREW_EXCEPTION,\n    TEST_DID_NOT_DIE\n  };\n\n  // Assumes one of the above roles.\n  virtual TestRole AssumeRole() = 0;\n\n  // Waits for the death test to finish and returns its status.\n  virtual int Wait() = 0;\n\n  // Returns true if the death test passed; that is, the test process\n  // exited during the test, its exit status matches a user-supplied\n  // predicate, and its stderr output matches a user-supplied regular\n  // expression.\n  // The user-supplied predicate may be a macro expression rather\n  // than a function pointer or functor, or else Wait and Passed could\n  // be combined.\n  virtual bool Passed(bool exit_status_ok) = 0;\n\n  // Signals that the death test did not die as expected.\n  virtual void Abort(AbortReason reason) = 0;\n\n  // Returns a human-readable outcome message regarding the outcome of\n  // the last death test.\n  static const char* LastMessage();\n\n  static void set_last_death_test_message(const std::string& message);\n\n private:\n  // A string containing a description of the outcome of the last death test.\n  static std::string last_death_test_message_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(DeathTest);\n};\n\n// Factory interface for death tests.  May be mocked out for testing.\nclass DeathTestFactory {\n public:\n  virtual ~DeathTestFactory() { }\n  virtual bool Create(const char* statement, const RE* regex,\n                      const char* file, int line, DeathTest** test) = 0;\n};\n\n// A concrete DeathTestFactory implementation for normal use.\nclass DefaultDeathTestFactory : public DeathTestFactory {\n public:\n  virtual bool Create(const char* statement, const RE* regex,\n                      const char* file, int line, DeathTest** test);\n};\n\n// Returns true if exit_status describes a process that was terminated\n// by a signal, or exited normally with a nonzero exit code.\nGTEST_API_ bool ExitedUnsuccessfully(int exit_status);\n\n// Traps C++ exceptions escaping statement and reports them as test\n// failures. Note that trapping SEH exceptions is not implemented here.\n# if GTEST_HAS_EXCEPTIONS\n#  define GTEST_EXECUTE_DEATH_TEST_STATEMENT_(statement, death_test) \\\n  try { \\\n    GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n  } catch (const ::std::exception& gtest_exception) { \\\n    fprintf(\\\n        stderr, \\\n        \"\\n%s: Caught std::exception-derived exception escaping the \" \\\n        \"death test statement. Exception message: %s\\n\", \\\n        ::testing::internal::FormatFileLocation(__FILE__, __LINE__).c_str(), \\\n        gtest_exception.what()); \\\n    fflush(stderr); \\\n    death_test->Abort(::testing::internal::DeathTest::TEST_THREW_EXCEPTION); \\\n  } catch (...) { \\\n    death_test->Abort(::testing::internal::DeathTest::TEST_THREW_EXCEPTION); \\\n  }\n\n# else\n#  define GTEST_EXECUTE_DEATH_TEST_STATEMENT_(statement, death_test) \\\n  GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement)\n\n# endif\n\n// This macro is for implementing ASSERT_DEATH*, EXPECT_DEATH*,\n// ASSERT_EXIT*, and EXPECT_EXIT*.\n# define GTEST_DEATH_TEST_(statement, predicate, regex, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::AlwaysTrue()) { \\\n    const ::testing::internal::RE& gtest_regex = (regex); \\\n    ::testing::internal::DeathTest* gtest_dt; \\\n    if (!::testing::internal::DeathTest::Create(#statement, &gtest_regex, \\\n        __FILE__, __LINE__, &gtest_dt)) { \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_, __LINE__); \\\n    } \\\n    if (gtest_dt != NULL) { \\\n      ::testing::internal::scoped_ptr< ::testing::internal::DeathTest> \\\n          gtest_dt_ptr(gtest_dt); \\\n      switch (gtest_dt->AssumeRole()) { \\\n        case ::testing::internal::DeathTest::OVERSEE_TEST: \\\n          if (!gtest_dt->Passed(predicate(gtest_dt->Wait()))) { \\\n            goto GTEST_CONCAT_TOKEN_(gtest_label_, __LINE__); \\\n          } \\\n          break; \\\n        case ::testing::internal::DeathTest::EXECUTE_TEST: { \\\n          ::testing::internal::DeathTest::ReturnSentinel \\\n              gtest_sentinel(gtest_dt); \\\n          GTEST_EXECUTE_DEATH_TEST_STATEMENT_(statement, gtest_dt); \\\n          gtest_dt->Abort(::testing::internal::DeathTest::TEST_DID_NOT_DIE); \\\n          break; \\\n        } \\\n      } \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_, __LINE__): \\\n      fail(::testing::internal::DeathTest::LastMessage())\n// The symbol \"fail\" here expands to something into which a message\n// can be streamed.\n\n// This macro is for implementing ASSERT/EXPECT_DEBUG_DEATH when compiled in\n// NDEBUG mode. In this case we need the statements to be executed, the regex is\n// ignored, and the macro must accept a streamed message even though the message\n// is never printed.\n# define GTEST_EXECUTE_STATEMENT_(statement, regex) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::AlwaysTrue()) { \\\n     GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n  } else \\\n    ::testing::Message()\n\n// A class representing the parsed contents of the\n// --gtest_internal_run_death_test flag, as it existed when\n// RUN_ALL_TESTS was called.\nclass InternalRunDeathTestFlag {\n public:\n  InternalRunDeathTestFlag(const std::string& a_file,\n                           int a_line,\n                           int an_index,\n                           int a_write_fd)\n      : file_(a_file), line_(a_line), index_(an_index),\n        write_fd_(a_write_fd) {}\n\n  ~InternalRunDeathTestFlag() {\n    if (write_fd_ >= 0)\n      posix::Close(write_fd_);\n  }\n\n  const std::string& file() const { return file_; }\n  int line() const { return line_; }\n  int index() const { return index_; }\n  int write_fd() const { return write_fd_; }\n\n private:\n  std::string file_;\n  int line_;\n  int index_;\n  int write_fd_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(InternalRunDeathTestFlag);\n};\n\n// Returns a newly created InternalRunDeathTestFlag object with fields\n// initialized from the GTEST_FLAG(internal_run_death_test) flag if\n// the flag is specified; otherwise returns NULL.\nInternalRunDeathTestFlag* ParseInternalRunDeathTestFlag();\n\n#else  // GTEST_HAS_DEATH_TEST\n\n// This macro is used for implementing macros such as\n// EXPECT_DEATH_IF_SUPPORTED and ASSERT_DEATH_IF_SUPPORTED on systems where\n// death tests are not supported. Those macros must compile on such systems\n// iff EXPECT_DEATH and ASSERT_DEATH compile with the same parameters on\n// systems that support death tests. This allows one to write such a macro\n// on a system that does not support death tests and be sure that it will\n// compile on a death-test supporting system.\n//\n// Parameters:\n//   statement -  A statement that a macro such as EXPECT_DEATH would test\n//                for program termination. This macro has to make sure this\n//                statement is compiled but not executed, to ensure that\n//                EXPECT_DEATH_IF_SUPPORTED compiles with a certain\n//                parameter iff EXPECT_DEATH compiles with it.\n//   regex     -  A regex that a macro such as EXPECT_DEATH would use to test\n//                the output of statement.  This parameter has to be\n//                compiled but not evaluated by this macro, to ensure that\n//                this macro only accepts expressions that a macro such as\n//                EXPECT_DEATH would accept.\n//   terminator - Must be an empty statement for EXPECT_DEATH_IF_SUPPORTED\n//                and a return statement for ASSERT_DEATH_IF_SUPPORTED.\n//                This ensures that ASSERT_DEATH_IF_SUPPORTED will not\n//                compile inside functions where ASSERT_DEATH doesn't\n//                compile.\n//\n//  The branch that has an always false condition is used to ensure that\n//  statement and regex are compiled (and thus syntactically correct) but\n//  never executed. The unreachable code macro protects the terminator\n//  statement from generating an 'unreachable code' warning in case\n//  statement unconditionally returns or throws. The Message constructor at\n//  the end allows the syntax of streaming additional messages into the\n//  macro, for compilational compatibility with EXPECT_DEATH/ASSERT_DEATH.\n# define GTEST_UNSUPPORTED_DEATH_TEST_(statement, regex, terminator) \\\n    GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n    if (::testing::internal::AlwaysTrue()) { \\\n      GTEST_LOG_(WARNING) \\\n          << \"Death tests are not supported on this platform.\\n\" \\\n          << \"Statement '\" #statement \"' cannot be verified.\"; \\\n    } else if (::testing::internal::AlwaysFalse()) { \\\n      ::testing::internal::RE::PartialMatch(\".*\", (regex)); \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n      terminator; \\\n    } else \\\n      ::testing::Message()\n\n#endif  // GTEST_HAS_DEATH_TEST\n\n}  // namespace internal\n}  // namespace testing\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_DEATH_TEST_INTERNAL_H_\n"}, "44": {"id": 44, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-internal.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Authors: wan@google.com (Zhanyong Wan), eefacm@gmail.com (Sean Mcafee)\n//\n// The Google C++ Testing Framework (Google Test)\n//\n// This header file declares functions and macros used internally by\n// Google Test.  They are subject to change without notice.\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_\n\n#include \"gtest/internal/gtest-port.h\"\n\n#if GTEST_OS_LINUX\n# include <stdlib.h>\n# include <sys/types.h>\n# include <sys/wait.h>\n# include <unistd.h>\n#endif  // GTEST_OS_LINUX\n\n#if GTEST_HAS_EXCEPTIONS\n# include <stdexcept>\n#endif\n\n#include <ctype.h>\n#include <float.h>\n#include <string.h>\n#include <iomanip>\n#include <limits>\n#include <map>\n#include <set>\n#include <string>\n#include <vector>\n\n#include \"gtest/gtest-message.h\"\n#include \"gtest/internal/gtest-string.h\"\n#include \"gtest/internal/gtest-filepath.h\"\n#include \"gtest/internal/gtest-type-util.h\"\n\n// Due to C++ preprocessor weirdness, we need double indirection to\n// concatenate two tokens when one of them is __LINE__.  Writing\n//\n//   foo ## __LINE__\n//\n// will result in the token foo__LINE__, instead of foo followed by\n// the current line number.  For more details, see\n// http://www.parashift.com/c++-faq-lite/misc-technical-issues.html#faq-39.6\n#define GTEST_CONCAT_TOKEN_(foo, bar) GTEST_CONCAT_TOKEN_IMPL_(foo, bar)\n#define GTEST_CONCAT_TOKEN_IMPL_(foo, bar) foo ## bar\n\nclass ProtocolMessage;\nnamespace proto2 { class Message; }\n\nnamespace testing {\n\n// Forward declarations.\n\nclass AssertionResult;                 // Result of an assertion.\nclass Message;                         // Represents a failure message.\nclass Test;                            // Represents a test.\nclass TestInfo;                        // Information about a test.\nclass TestPartResult;                  // Result of a test part.\nclass UnitTest;                        // A collection of test cases.\n\ntemplate <typename T>\n::std::string PrintToString(const T& value);\n\nnamespace internal {\n\nstruct TraceInfo;                      // Information about a trace point.\nclass ScopedTrace;                     // Implements scoped trace.\nclass TestInfoImpl;                    // Opaque implementation of TestInfo\nclass UnitTestImpl;                    // Opaque implementation of UnitTest\n\n// The text used in failure messages to indicate the start of the\n// stack trace.\nGTEST_API_ extern const char kStackTraceMarker[];\n\n// Two overloaded helpers for checking at compile time whether an\n// expression is a null pointer literal (i.e. NULL or any 0-valued\n// compile-time integral constant).  Their return values have\n// different sizes, so we can use sizeof() to test which version is\n// picked by the compiler.  These helpers have no implementations, as\n// we only need their signatures.\n//\n// Given IsNullLiteralHelper(x), the compiler will pick the first\n// version if x can be implicitly converted to Secret*, and pick the\n// second version otherwise.  Since Secret is a secret and incomplete\n// type, the only expression a user can write that has type Secret* is\n// a null pointer literal.  Therefore, we know that x is a null\n// pointer literal if and only if the first version is picked by the\n// compiler.\nchar IsNullLiteralHelper(Secret* p);\nchar (&IsNullLiteralHelper(...))[2];  // NOLINT\n\n// A compile-time bool constant that is true if and only if x is a\n// null pointer literal (i.e. NULL or any 0-valued compile-time\n// integral constant).\n#ifdef GTEST_ELLIPSIS_NEEDS_POD_\n// We lose support for NULL detection where the compiler doesn't like\n// passing non-POD classes through ellipsis (...).\n# define GTEST_IS_NULL_LITERAL_(x) false\n#else\n# define GTEST_IS_NULL_LITERAL_(x) \\\n    (sizeof(::testing::internal::IsNullLiteralHelper(x)) == 1)\n#endif  // GTEST_ELLIPSIS_NEEDS_POD_\n\n// Appends the user-supplied message to the Google-Test-generated message.\nGTEST_API_ std::string AppendUserMessage(\n    const std::string& gtest_msg, const Message& user_msg);\n\n#if GTEST_HAS_EXCEPTIONS\n\n// This exception is thrown by (and only by) a failed Google Test\n// assertion when GTEST_FLAG(throw_on_failure) is true (if exceptions\n// are enabled).  We derive it from std::runtime_error, which is for\n// errors presumably detectable only at run time.  Since\n// std::runtime_error inherits from std::exception, many testing\n// frameworks know how to extract and print the message inside it.\nclass GTEST_API_ GoogleTestFailureException : public ::std::runtime_error {\n public:\n  explicit GoogleTestFailureException(const TestPartResult& failure);\n};\n\n#endif  // GTEST_HAS_EXCEPTIONS\n\n// A helper class for creating scoped traces in user programs.\nclass GTEST_API_ ScopedTrace {\n public:\n  // The c'tor pushes the given source file location and message onto\n  // a trace stack maintained by Google Test.\n  ScopedTrace(const char* file, int line, const Message& message);\n\n  // The d'tor pops the info pushed by the c'tor.\n  //\n  // Note that the d'tor is not virtual in order to be efficient.\n  // Don't inherit from ScopedTrace!\n  ~ScopedTrace();\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ScopedTrace);\n} GTEST_ATTRIBUTE_UNUSED_;  // A ScopedTrace object does its job in its\n                            // c'tor and d'tor.  Therefore it doesn't\n                            // need to be used otherwise.\n\nnamespace edit_distance {\n// Returns the optimal edits to go from 'left' to 'right'.\n// All edits cost the same, with replace having lower priority than\n// add/remove.\n// Simple implementation of the Wagner\u2013Fischer algorithm.\n// See http://en.wikipedia.org/wiki/Wagner-Fischer_algorithm\nenum EditType { kMatch, kAdd, kRemove, kReplace };\nGTEST_API_ std::vector<EditType> CalculateOptimalEdits(\n    const std::vector<size_t>& left, const std::vector<size_t>& right);\n\n// Same as above, but the input is represented as strings.\nGTEST_API_ std::vector<EditType> CalculateOptimalEdits(\n    const std::vector<std::string>& left,\n    const std::vector<std::string>& right);\n\n// Create a diff of the input strings in Unified diff format.\nGTEST_API_ std::string CreateUnifiedDiff(const std::vector<std::string>& left,\n                                         const std::vector<std::string>& right,\n                                         size_t context = 2);\n\n}  // namespace edit_distance\n\n// Calculate the diff between 'left' and 'right' and return it in unified diff\n// format.\n// If not null, stores in 'total_line_count' the total number of lines found\n// in left + right.\nGTEST_API_ std::string DiffStrings(const std::string& left,\n                                   const std::string& right,\n                                   size_t* total_line_count);\n\n// Constructs and returns the message for an equality assertion\n// (e.g. ASSERT_EQ, EXPECT_STREQ, etc) failure.\n//\n// The first four parameters are the expressions used in the assertion\n// and their values, as strings.  For example, for ASSERT_EQ(foo, bar)\n// where foo is 5 and bar is 6, we have:\n//\n//   expected_expression: \"foo\"\n//   actual_expression:   \"bar\"\n//   expected_value:      \"5\"\n//   actual_value:        \"6\"\n//\n// The ignoring_case parameter is true iff the assertion is a\n// *_STRCASEEQ*.  When it's true, the string \" (ignoring case)\" will\n// be inserted into the message.\nGTEST_API_ AssertionResult EqFailure(const char* expected_expression,\n                                     const char* actual_expression,\n                                     const std::string& expected_value,\n                                     const std::string& actual_value,\n                                     bool ignoring_case);\n\n// Constructs a failure message for Boolean assertions such as EXPECT_TRUE.\nGTEST_API_ std::string GetBoolAssertionFailureMessage(\n    const AssertionResult& assertion_result,\n    const char* expression_text,\n    const char* actual_predicate_value,\n    const char* expected_predicate_value);\n\n// This template class represents an IEEE floating-point number\n// (either single-precision or double-precision, depending on the\n// template parameters).\n//\n// The purpose of this class is to do more sophisticated number\n// comparison.  (Due to round-off error, etc, it's very unlikely that\n// two floating-points will be equal exactly.  Hence a naive\n// comparison by the == operation often doesn't work.)\n//\n// Format of IEEE floating-point:\n//\n//   The most-significant bit being the leftmost, an IEEE\n//   floating-point looks like\n//\n//     sign_bit exponent_bits fraction_bits\n//\n//   Here, sign_bit is a single bit that designates the sign of the\n//   number.\n//\n//   For float, there are 8 exponent bits and 23 fraction bits.\n//\n//   For double, there are 11 exponent bits and 52 fraction bits.\n//\n//   More details can be found at\n//   http://en.wikipedia.org/wiki/IEEE_floating-point_standard.\n//\n// Template parameter:\n//\n//   RawType: the raw floating-point type (either float or double)\ntemplate <typename RawType>\nclass FloatingPoint {\n public:\n  // Defines the unsigned integer type that has the same size as the\n  // floating point number.\n  typedef typename TypeWithSize<sizeof(RawType)>::UInt Bits;\n\n  // Constants.\n\n  // # of bits in a number.\n  static const size_t kBitCount = 8*sizeof(RawType);\n\n  // # of fraction bits in a number.\n  static const size_t kFractionBitCount =\n    std::numeric_limits<RawType>::digits - 1;\n\n  // # of exponent bits in a number.\n  static const size_t kExponentBitCount = kBitCount - 1 - kFractionBitCount;\n\n  // The mask for the sign bit.\n  static const Bits kSignBitMask = static_cast<Bits>(1) << (kBitCount - 1);\n\n  // The mask for the fraction bits.\n  static const Bits kFractionBitMask =\n    ~static_cast<Bits>(0) >> (kExponentBitCount + 1);\n\n  // The mask for the exponent bits.\n  static const Bits kExponentBitMask = ~(kSignBitMask | kFractionBitMask);\n\n  // How many ULP's (Units in the Last Place) we want to tolerate when\n  // comparing two numbers.  The larger the value, the more error we\n  // allow.  A 0 value means that two numbers must be exactly the same\n  // to be considered equal.\n  //\n  // The maximum error of a single floating-point operation is 0.5\n  // units in the last place.  On Intel CPU's, all floating-point\n  // calculations are done with 80-bit precision, while double has 64\n  // bits.  Therefore, 4 should be enough for ordinary use.\n  //\n  // See the following article for more details on ULP:\n  // http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\n  static const size_t kMaxUlps = 4;\n\n  // Constructs a FloatingPoint from a raw floating-point number.\n  //\n  // On an Intel CPU, passing a non-normalized NAN (Not a Number)\n  // around may change its bits, although the new value is guaranteed\n  // to be also a NAN.  Therefore, don't expect this constructor to\n  // preserve the bits in x when x is a NAN.\n  explicit FloatingPoint(const RawType& x) { u_.value_ = x; }\n\n  // Static methods\n\n  // Reinterprets a bit pattern as a floating-point number.\n  //\n  // This function is needed to test the AlmostEquals() method.\n  static RawType ReinterpretBits(const Bits bits) {\n    FloatingPoint fp(0);\n    fp.u_.bits_ = bits;\n    return fp.u_.value_;\n  }\n\n  // Returns the floating-point number that represent positive infinity.\n  static RawType Infinity() {\n    return ReinterpretBits(kExponentBitMask);\n  }\n\n  // Returns the maximum representable finite floating-point number.\n  static RawType Max();\n\n  // Non-static methods\n\n  // Returns the bits that represents this number.\n  const Bits &bits() const { return u_.bits_; }\n\n  // Returns the exponent bits of this number.\n  Bits exponent_bits() const { return kExponentBitMask & u_.bits_; }\n\n  // Returns the fraction bits of this number.\n  Bits fraction_bits() const { return kFractionBitMask & u_.bits_; }\n\n  // Returns the sign bit of this number.\n  Bits sign_bit() const { return kSignBitMask & u_.bits_; }\n\n  // Returns true iff this is NAN (not a number).\n  bool is_nan() const {\n    // It's a NAN if the exponent bits are all ones and the fraction\n    // bits are not entirely zeros.\n    return (exponent_bits() == kExponentBitMask) && (fraction_bits() != 0);\n  }\n\n  // Returns true iff this number is at most kMaxUlps ULP's away from\n  // rhs.  In particular, this function:\n  //\n  //   - returns false if either number is (or both are) NAN.\n  //   - treats really large numbers as almost equal to infinity.\n  //   - thinks +0.0 and -0.0 are 0 DLP's apart.\n  bool AlmostEquals(const FloatingPoint& rhs) const {\n    // The IEEE standard says that any comparison operation involving\n    // a NAN must return false.\n    if (is_nan() || rhs.is_nan()) return false;\n\n    return DistanceBetweenSignAndMagnitudeNumbers(u_.bits_, rhs.u_.bits_)\n        <= kMaxUlps;\n  }\n\n private:\n  // The data type used to store the actual floating-point number.\n  union FloatingPointUnion {\n    RawType value_;  // The raw floating-point number.\n    Bits bits_;      // The bits that represent the number.\n  };\n\n  // Converts an integer from the sign-and-magnitude representation to\n  // the biased representation.  More precisely, let N be 2 to the\n  // power of (kBitCount - 1), an integer x is represented by the\n  // unsigned number x + N.\n  //\n  // For instance,\n  //\n  //   -N + 1 (the most negative number representable using\n  //          sign-and-magnitude) is represented by 1;\n  //   0      is represented by N; and\n  //   N - 1  (the biggest number representable using\n  //          sign-and-magnitude) is represented by 2N - 1.\n  //\n  // Read http://en.wikipedia.org/wiki/Signed_number_representations\n  // for more details on signed number representations.\n  static Bits SignAndMagnitudeToBiased(const Bits &sam) {\n    if (kSignBitMask & sam) {\n      // sam represents a negative number.\n      return ~sam + 1;\n    } else {\n      // sam represents a positive number.\n      return kSignBitMask | sam;\n    }\n  }\n\n  // Given two numbers in the sign-and-magnitude representation,\n  // returns the distance between them as an unsigned number.\n  static Bits DistanceBetweenSignAndMagnitudeNumbers(const Bits &sam1,\n                                                     const Bits &sam2) {\n    const Bits biased1 = SignAndMagnitudeToBiased(sam1);\n    const Bits biased2 = SignAndMagnitudeToBiased(sam2);\n    return (biased1 >= biased2) ? (biased1 - biased2) : (biased2 - biased1);\n  }\n\n  FloatingPointUnion u_;\n};\n\n// We cannot use std::numeric_limits<T>::max() as it clashes with the max()\n// macro defined by <windows.h>.\ntemplate <>\ninline float FloatingPoint<float>::Max() { return FLT_MAX; }\ntemplate <>\ninline double FloatingPoint<double>::Max() { return DBL_MAX; }\n\n// Typedefs the instances of the FloatingPoint template class that we\n// care to use.\ntypedef FloatingPoint<float> Float;\ntypedef FloatingPoint<double> Double;\n\n// In order to catch the mistake of putting tests that use different\n// test fixture classes in the same test case, we need to assign\n// unique IDs to fixture classes and compare them.  The TypeId type is\n// used to hold such IDs.  The user should treat TypeId as an opaque\n// type: the only operation allowed on TypeId values is to compare\n// them for equality using the == operator.\ntypedef const void* TypeId;\n\ntemplate <typename T>\nclass TypeIdHelper {\n public:\n  // dummy_ must not have a const type.  Otherwise an overly eager\n  // compiler (e.g. MSVC 7.1 & 8.0) may try to merge\n  // TypeIdHelper<T>::dummy_ for different Ts as an \"optimization\".\n  static bool dummy_;\n};\n\ntemplate <typename T>\nbool TypeIdHelper<T>::dummy_ = false;\n\n// GetTypeId<T>() returns the ID of type T.  Different values will be\n// returned for different types.  Calling the function twice with the\n// same type argument is guaranteed to return the same ID.\ntemplate <typename T>\nTypeId GetTypeId() {\n  // The compiler is required to allocate a different\n  // TypeIdHelper<T>::dummy_ variable for each T used to instantiate\n  // the template.  Therefore, the address of dummy_ is guaranteed to\n  // be unique.\n  return &(TypeIdHelper<T>::dummy_);\n}\n\n// Returns the type ID of ::testing::Test.  Always call this instead\n// of GetTypeId< ::testing::Test>() to get the type ID of\n// ::testing::Test, as the latter may give the wrong result due to a\n// suspected linker bug when compiling Google Test as a Mac OS X\n// framework.\nGTEST_API_ TypeId GetTestTypeId();\n\n// Defines the abstract factory interface that creates instances\n// of a Test object.\nclass TestFactoryBase {\n public:\n  virtual ~TestFactoryBase() {}\n\n  // Creates a test instance to run. The instance is both created and destroyed\n  // within TestInfoImpl::Run()\n  virtual Test* CreateTest() = 0;\n\n protected:\n  TestFactoryBase() {}\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestFactoryBase);\n};\n\n// This class provides implementation of TeastFactoryBase interface.\n// It is used in TEST and TEST_F macros.\ntemplate <class TestClass>\nclass TestFactoryImpl : public TestFactoryBase {\n public:\n  virtual Test* CreateTest() { return new TestClass; }\n};\n\n#if GTEST_OS_WINDOWS\n\n// Predicate-formatters for implementing the HRESULT checking macros\n// {ASSERT|EXPECT}_HRESULT_{SUCCEEDED|FAILED}\n// We pass a long instead of HRESULT to avoid causing an\n// include dependency for the HRESULT type.\nGTEST_API_ AssertionResult IsHRESULTSuccess(const char* expr,\n                                            long hr);  // NOLINT\nGTEST_API_ AssertionResult IsHRESULTFailure(const char* expr,\n                                            long hr);  // NOLINT\n\n#endif  // GTEST_OS_WINDOWS\n\n// Types of SetUpTestCase() and TearDownTestCase() functions.\ntypedef void (*SetUpTestCaseFunc)();\ntypedef void (*TearDownTestCaseFunc)();\n\nstruct CodeLocation {\n  CodeLocation(const string& a_file, int a_line) : file(a_file), line(a_line) {}\n\n  string file;\n  int line;\n};\n\n// Creates a new TestInfo object and registers it with Google Test;\n// returns the created object.\n//\n// Arguments:\n//\n//   test_case_name:   name of the test case\n//   name:             name of the test\n//   type_param        the name of the test's type parameter, or NULL if\n//                     this is not a typed or a type-parameterized test.\n//   value_param       text representation of the test's value parameter,\n//                     or NULL if this is not a type-parameterized test.\n//   code_location:    code location where the test is defined\n//   fixture_class_id: ID of the test fixture class\n//   set_up_tc:        pointer to the function that sets up the test case\n//   tear_down_tc:     pointer to the function that tears down the test case\n//   factory:          pointer to the factory that creates a test object.\n//                     The newly created TestInfo instance will assume\n//                     ownership of the factory object.\nGTEST_API_ TestInfo* MakeAndRegisterTestInfo(\n    const char* test_case_name,\n    const char* name,\n    const char* type_param,\n    const char* value_param,\n    CodeLocation code_location,\n    TypeId fixture_class_id,\n    SetUpTestCaseFunc set_up_tc,\n    TearDownTestCaseFunc tear_down_tc,\n    TestFactoryBase* factory);\n\n// If *pstr starts with the given prefix, modifies *pstr to be right\n// past the prefix and returns true; otherwise leaves *pstr unchanged\n// and returns false.  None of pstr, *pstr, and prefix can be NULL.\nGTEST_API_ bool SkipPrefix(const char* prefix, const char** pstr);\n\n#if GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P\n\n// State of the definition of a type-parameterized test case.\nclass GTEST_API_ TypedTestCasePState {\n public:\n  TypedTestCasePState() : registered_(false) {}\n\n  // Adds the given test name to defined_test_names_ and return true\n  // if the test case hasn't been registered; otherwise aborts the\n  // program.\n  bool AddTestName(const char* file, int line, const char* case_name,\n                   const char* test_name) {\n    if (registered_) {\n      fprintf(stderr, \"%s Test %s must be defined before \"\n              \"REGISTER_TYPED_TEST_CASE_P(%s, ...).\\n\",\n              FormatFileLocation(file, line).c_str(), test_name, case_name);\n      fflush(stderr);\n      posix::Abort();\n    }\n    registered_tests_.insert(\n        ::std::make_pair(test_name, CodeLocation(file, line)));\n    return true;\n  }\n\n  bool TestExists(const std::string& test_name) const {\n    return registered_tests_.count(test_name) > 0;\n  }\n\n  const CodeLocation& GetCodeLocation(const std::string& test_name) const {\n    RegisteredTestsMap::const_iterator it = registered_tests_.find(test_name);\n    GTEST_CHECK_(it != registered_tests_.end());\n    return it->second;\n  }\n\n  // Verifies that registered_tests match the test names in\n  // defined_test_names_; returns registered_tests if successful, or\n  // aborts the program otherwise.\n  const char* VerifyRegisteredTestNames(\n      const char* file, int line, const char* registered_tests);\n\n private:\n  typedef ::std::map<std::string, CodeLocation> RegisteredTestsMap;\n\n  bool registered_;\n  RegisteredTestsMap registered_tests_;\n};\n\n// Skips to the first non-space char after the first comma in 'str';\n// returns NULL if no comma is found in 'str'.\ninline const char* SkipComma(const char* str) {\n  const char* comma = strchr(str, ',');\n  if (comma == NULL) {\n    return NULL;\n  }\n  while (IsSpace(*(++comma))) {}\n  return comma;\n}\n\n// Returns the prefix of 'str' before the first comma in it; returns\n// the entire string if it contains no comma.\ninline std::string GetPrefixUntilComma(const char* str) {\n  const char* comma = strchr(str, ',');\n  return comma == NULL ? str : std::string(str, comma);\n}\n\n// Splits a given string on a given delimiter, populating a given\n// vector with the fields.\nvoid SplitString(const ::std::string& str, char delimiter,\n                 ::std::vector< ::std::string>* dest);\n\n// TypeParameterizedTest<Fixture, TestSel, Types>::Register()\n// registers a list of type-parameterized tests with Google Test.  The\n// return value is insignificant - we just need to return something\n// such that we can call this function in a namespace scope.\n//\n// Implementation note: The GTEST_TEMPLATE_ macro declares a template\n// template parameter.  It's defined in gtest-type-util.h.\ntemplate <GTEST_TEMPLATE_ Fixture, class TestSel, typename Types>\nclass TypeParameterizedTest {\n public:\n  // 'index' is the index of the test in the type list 'Types'\n  // specified in INSTANTIATE_TYPED_TEST_CASE_P(Prefix, TestCase,\n  // Types).  Valid values for 'index' are [0, N - 1] where N is the\n  // length of Types.\n  static bool Register(const char* prefix,\n                       CodeLocation code_location,\n                       const char* case_name, const char* test_names,\n                       int index) {\n    typedef typename Types::Head Type;\n    typedef Fixture<Type> FixtureClass;\n    typedef typename GTEST_BIND_(TestSel, Type) TestClass;\n\n    // First, registers the first type-parameterized test in the type\n    // list.\n    MakeAndRegisterTestInfo(\n        (std::string(prefix) + (prefix[0] == '\\0' ? \"\" : \"/\") + case_name + \"/\"\n         + StreamableToString(index)).c_str(),\n        StripTrailingSpaces(GetPrefixUntilComma(test_names)).c_str(),\n        GetTypeName<Type>().c_str(),\n        NULL,  // No value parameter.\n        code_location,\n        GetTypeId<FixtureClass>(),\n        TestClass::SetUpTestCase,\n        TestClass::TearDownTestCase,\n        new TestFactoryImpl<TestClass>);\n\n    // Next, recurses (at compile time) with the tail of the type list.\n    return TypeParameterizedTest<Fixture, TestSel, typename Types::Tail>\n        ::Register(prefix, code_location, case_name, test_names, index + 1);\n  }\n};\n\n// The base case for the compile time recursion.\ntemplate <GTEST_TEMPLATE_ Fixture, class TestSel>\nclass TypeParameterizedTest<Fixture, TestSel, Types0> {\n public:\n  static bool Register(const char* /*prefix*/, CodeLocation,\n                       const char* /*case_name*/, const char* /*test_names*/,\n                       int /*index*/) {\n    return true;\n  }\n};\n\n// TypeParameterizedTestCase<Fixture, Tests, Types>::Register()\n// registers *all combinations* of 'Tests' and 'Types' with Google\n// Test.  The return value is insignificant - we just need to return\n// something such that we can call this function in a namespace scope.\ntemplate <GTEST_TEMPLATE_ Fixture, typename Tests, typename Types>\nclass TypeParameterizedTestCase {\n public:\n  static bool Register(const char* prefix, CodeLocation code_location,\n                       const TypedTestCasePState* state,\n                       const char* case_name, const char* test_names) {\n    std::string test_name = StripTrailingSpaces(\n        GetPrefixUntilComma(test_names));\n    if (!state->TestExists(test_name)) {\n      fprintf(stderr, \"Failed to get code location for test %s.%s at %s.\",\n              case_name, test_name.c_str(),\n              FormatFileLocation(code_location.file.c_str(),\n                                 code_location.line).c_str());\n      fflush(stderr);\n      posix::Abort();\n    }\n    const CodeLocation& test_location = state->GetCodeLocation(test_name);\n\n    typedef typename Tests::Head Head;\n\n    // First, register the first test in 'Test' for each type in 'Types'.\n    TypeParameterizedTest<Fixture, Head, Types>::Register(\n        prefix, test_location, case_name, test_names, 0);\n\n    // Next, recurses (at compile time) with the tail of the test list.\n    return TypeParameterizedTestCase<Fixture, typename Tests::Tail, Types>\n        ::Register(prefix, code_location, state,\n                   case_name, SkipComma(test_names));\n  }\n};\n\n// The base case for the compile time recursion.\ntemplate <GTEST_TEMPLATE_ Fixture, typename Types>\nclass TypeParameterizedTestCase<Fixture, Templates0, Types> {\n public:\n  static bool Register(const char* /*prefix*/, CodeLocation,\n                       const TypedTestCasePState* /*state*/,\n                       const char* /*case_name*/, const char* /*test_names*/) {\n    return true;\n  }\n};\n\n#endif  // GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P\n\n// Returns the current OS stack trace as an std::string.\n//\n// The maximum number of stack frames to be included is specified by\n// the gtest_stack_trace_depth flag.  The skip_count parameter\n// specifies the number of top frames to be skipped, which doesn't\n// count against the number of frames to be included.\n//\n// For example, if Foo() calls Bar(), which in turn calls\n// GetCurrentOsStackTraceExceptTop(..., 1), Foo() will be included in\n// the trace but Bar() and GetCurrentOsStackTraceExceptTop() won't.\nGTEST_API_ std::string GetCurrentOsStackTraceExceptTop(\n    UnitTest* unit_test, int skip_count);\n\n// Helpers for suppressing warnings on unreachable code or constant\n// condition.\n\n// Always returns true.\nGTEST_API_ bool AlwaysTrue();\n\n// Always returns false.\ninline bool AlwaysFalse() { return !AlwaysTrue(); }\n\n// Helper for suppressing false warning from Clang on a const char*\n// variable declared in a conditional expression always being NULL in\n// the else branch.\nstruct GTEST_API_ ConstCharPtr {\n  ConstCharPtr(const char* str) : value(str) {}\n  operator bool() const { return true; }\n  const char* value;\n};\n\n// A simple Linear Congruential Generator for generating random\n// numbers with a uniform distribution.  Unlike rand() and srand(), it\n// doesn't use global state (and therefore can't interfere with user\n// code).  Unlike rand_r(), it's portable.  An LCG isn't very random,\n// but it's good enough for our purposes.\nclass GTEST_API_ Random {\n public:\n  static const UInt32 kMaxRange = 1u << 31;\n\n  explicit Random(UInt32 seed) : state_(seed) {}\n\n  void Reseed(UInt32 seed) { state_ = seed; }\n\n  // Generates a random number from [0, range).  Crashes if 'range' is\n  // 0 or greater than kMaxRange.\n  UInt32 Generate(UInt32 range);\n\n private:\n  UInt32 state_;\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Random);\n};\n\n// Defining a variable of type CompileAssertTypesEqual<T1, T2> will cause a\n// compiler error iff T1 and T2 are different types.\ntemplate <typename T1, typename T2>\nstruct CompileAssertTypesEqual;\n\ntemplate <typename T>\nstruct CompileAssertTypesEqual<T, T> {\n};\n\n// Removes the reference from a type if it is a reference type,\n// otherwise leaves it unchanged.  This is the same as\n// tr1::remove_reference, which is not widely available yet.\ntemplate <typename T>\nstruct RemoveReference { typedef T type; };  // NOLINT\ntemplate <typename T>\nstruct RemoveReference<T&> { typedef T type; };  // NOLINT\n\n// A handy wrapper around RemoveReference that works when the argument\n// T depends on template parameters.\n#define GTEST_REMOVE_REFERENCE_(T) \\\n    typename ::testing::internal::RemoveReference<T>::type\n\n// Removes const from a type if it is a const type, otherwise leaves\n// it unchanged.  This is the same as tr1::remove_const, which is not\n// widely available yet.\ntemplate <typename T>\nstruct RemoveConst { typedef T type; };  // NOLINT\ntemplate <typename T>\nstruct RemoveConst<const T> { typedef T type; };  // NOLINT\n\n// MSVC 8.0, Sun C++, and IBM XL C++ have a bug which causes the above\n// definition to fail to remove the const in 'const int[3]' and 'const\n// char[3][4]'.  The following specialization works around the bug.\ntemplate <typename T, size_t N>\nstruct RemoveConst<const T[N]> {\n  typedef typename RemoveConst<T>::type type[N];\n};\n\n#if defined(_MSC_VER) && _MSC_VER < 1400\n// This is the only specialization that allows VC++ 7.1 to remove const in\n// 'const int[3] and 'const int[3][4]'.  However, it causes trouble with GCC\n// and thus needs to be conditionally compiled.\ntemplate <typename T, size_t N>\nstruct RemoveConst<T[N]> {\n  typedef typename RemoveConst<T>::type type[N];\n};\n#endif\n\n// A handy wrapper around RemoveConst that works when the argument\n// T depends on template parameters.\n#define GTEST_REMOVE_CONST_(T) \\\n    typename ::testing::internal::RemoveConst<T>::type\n\n// Turns const U&, U&, const U, and U all into U.\n#define GTEST_REMOVE_REFERENCE_AND_CONST_(T) \\\n    GTEST_REMOVE_CONST_(GTEST_REMOVE_REFERENCE_(T))\n\n// Adds reference to a type if it is not a reference type,\n// otherwise leaves it unchanged.  This is the same as\n// tr1::add_reference, which is not widely available yet.\ntemplate <typename T>\nstruct AddReference { typedef T& type; };  // NOLINT\ntemplate <typename T>\nstruct AddReference<T&> { typedef T& type; };  // NOLINT\n\n// A handy wrapper around AddReference that works when the argument T\n// depends on template parameters.\n#define GTEST_ADD_REFERENCE_(T) \\\n    typename ::testing::internal::AddReference<T>::type\n\n// Adds a reference to const on top of T as necessary.  For example,\n// it transforms\n//\n//   char         ==> const char&\n//   const char   ==> const char&\n//   char&        ==> const char&\n//   const char&  ==> const char&\n//\n// The argument T must depend on some template parameters.\n#define GTEST_REFERENCE_TO_CONST_(T) \\\n    GTEST_ADD_REFERENCE_(const GTEST_REMOVE_REFERENCE_(T))\n\n// ImplicitlyConvertible<From, To>::value is a compile-time bool\n// constant that's true iff type From can be implicitly converted to\n// type To.\ntemplate <typename From, typename To>\nclass ImplicitlyConvertible {\n private:\n  // We need the following helper functions only for their types.\n  // They have no implementations.\n\n  // MakeFrom() is an expression whose type is From.  We cannot simply\n  // use From(), as the type From may not have a public default\n  // constructor.\n  static typename AddReference<From>::type MakeFrom();\n\n  // These two functions are overloaded.  Given an expression\n  // Helper(x), the compiler will pick the first version if x can be\n  // implicitly converted to type To; otherwise it will pick the\n  // second version.\n  //\n  // The first version returns a value of size 1, and the second\n  // version returns a value of size 2.  Therefore, by checking the\n  // size of Helper(x), which can be done at compile time, we can tell\n  // which version of Helper() is used, and hence whether x can be\n  // implicitly converted to type To.\n  static char Helper(To);\n  static char (&Helper(...))[2];  // NOLINT\n\n  // We have to put the 'public' section after the 'private' section,\n  // or MSVC refuses to compile the code.\n public:\n#if defined(__BORLANDC__)\n  // C++Builder cannot use member overload resolution during template\n  // instantiation.  The simplest workaround is to use its C++0x type traits\n  // functions (C++Builder 2009 and above only).\n  static const bool value = __is_convertible(From, To);\n#else\n  // MSVC warns about implicitly converting from double to int for\n  // possible loss of data, so we need to temporarily disable the\n  // warning.\n  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4244)\n  static const bool value =\n      sizeof(Helper(ImplicitlyConvertible::MakeFrom())) == 1;\n  GTEST_DISABLE_MSC_WARNINGS_POP_()\n#endif  // __BORLANDC__\n};\ntemplate <typename From, typename To>\nconst bool ImplicitlyConvertible<From, To>::value;\n\n// IsAProtocolMessage<T>::value is a compile-time bool constant that's\n// true iff T is type ProtocolMessage, proto2::Message, or a subclass\n// of those.\ntemplate <typename T>\nstruct IsAProtocolMessage\n    : public bool_constant<\n  ImplicitlyConvertible<const T*, const ::ProtocolMessage*>::value ||\n  ImplicitlyConvertible<const T*, const ::proto2::Message*>::value> {\n};\n\n// When the compiler sees expression IsContainerTest<C>(0), if C is an\n// STL-style container class, the first overload of IsContainerTest\n// will be viable (since both C::iterator* and C::const_iterator* are\n// valid types and NULL can be implicitly converted to them).  It will\n// be picked over the second overload as 'int' is a perfect match for\n// the type of argument 0.  If C::iterator or C::const_iterator is not\n// a valid type, the first overload is not viable, and the second\n// overload will be picked.  Therefore, we can determine whether C is\n// a container class by checking the type of IsContainerTest<C>(0).\n// The value of the expression is insignificant.\n//\n// Note that we look for both C::iterator and C::const_iterator.  The\n// reason is that C++ injects the name of a class as a member of the\n// class itself (e.g. you can refer to class iterator as either\n// 'iterator' or 'iterator::iterator').  If we look for C::iterator\n// only, for example, we would mistakenly think that a class named\n// iterator is an STL container.\n//\n// Also note that the simpler approach of overloading\n// IsContainerTest(typename C::const_iterator*) and\n// IsContainerTest(...) doesn't work with Visual Age C++ and Sun C++.\ntypedef int IsContainer;\ntemplate <class C>\nIsContainer IsContainerTest(int /* dummy */,\n                            typename C::iterator* /* it */ = NULL,\n                            typename C::const_iterator* /* const_it */ = NULL) {\n  return 0;\n}\n\ntypedef char IsNotContainer;\ntemplate <class C>\nIsNotContainer IsContainerTest(long /* dummy */) { return '\\0'; }\n\n// EnableIf<condition>::type is void when 'Cond' is true, and\n// undefined when 'Cond' is false.  To use SFINAE to make a function\n// overload only apply when a particular expression is true, add\n// \"typename EnableIf<expression>::type* = 0\" as the last parameter.\ntemplate<bool> struct EnableIf;\ntemplate<> struct EnableIf<true> { typedef void type; };  // NOLINT\n\n// Utilities for native arrays.\n\n// ArrayEq() compares two k-dimensional native arrays using the\n// elements' operator==, where k can be any integer >= 0.  When k is\n// 0, ArrayEq() degenerates into comparing a single pair of values.\n\ntemplate <typename T, typename U>\nbool ArrayEq(const T* lhs, size_t size, const U* rhs);\n\n// This generic version is used when k is 0.\ntemplate <typename T, typename U>\ninline bool ArrayEq(const T& lhs, const U& rhs) { return lhs == rhs; }\n\n// This overload is used when k >= 1.\ntemplate <typename T, typename U, size_t N>\ninline bool ArrayEq(const T(&lhs)[N], const U(&rhs)[N]) {\n  return internal::ArrayEq(lhs, N, rhs);\n}\n\n// This helper reduces code bloat.  If we instead put its logic inside\n// the previous ArrayEq() function, arrays with different sizes would\n// lead to different copies of the template code.\ntemplate <typename T, typename U>\nbool ArrayEq(const T* lhs, size_t size, const U* rhs) {\n  for (size_t i = 0; i != size; i++) {\n    if (!internal::ArrayEq(lhs[i], rhs[i]))\n      return false;\n  }\n  return true;\n}\n\n// Finds the first element in the iterator range [begin, end) that\n// equals elem.  Element may be a native array type itself.\ntemplate <typename Iter, typename Element>\nIter ArrayAwareFind(Iter begin, Iter end, const Element& elem) {\n  for (Iter it = begin; it != end; ++it) {\n    if (internal::ArrayEq(*it, elem))\n      return it;\n  }\n  return end;\n}\n\n// CopyArray() copies a k-dimensional native array using the elements'\n// operator=, where k can be any integer >= 0.  When k is 0,\n// CopyArray() degenerates into copying a single value.\n\ntemplate <typename T, typename U>\nvoid CopyArray(const T* from, size_t size, U* to);\n\n// This generic version is used when k is 0.\ntemplate <typename T, typename U>\ninline void CopyArray(const T& from, U* to) { *to = from; }\n\n// This overload is used when k >= 1.\ntemplate <typename T, typename U, size_t N>\ninline void CopyArray(const T(&from)[N], U(*to)[N]) {\n  internal::CopyArray(from, N, *to);\n}\n\n// This helper reduces code bloat.  If we instead put its logic inside\n// the previous CopyArray() function, arrays with different sizes\n// would lead to different copies of the template code.\ntemplate <typename T, typename U>\nvoid CopyArray(const T* from, size_t size, U* to) {\n  for (size_t i = 0; i != size; i++) {\n    internal::CopyArray(from[i], to + i);\n  }\n}\n\n// The relation between an NativeArray object (see below) and the\n// native array it represents.\n// We use 2 different structs to allow non-copyable types to be used, as long\n// as RelationToSourceReference() is passed.\nstruct RelationToSourceReference {};\nstruct RelationToSourceCopy {};\n\n// Adapts a native array to a read-only STL-style container.  Instead\n// of the complete STL container concept, this adaptor only implements\n// members useful for Google Mock's container matchers.  New members\n// should be added as needed.  To simplify the implementation, we only\n// support Element being a raw type (i.e. having no top-level const or\n// reference modifier).  It's the client's responsibility to satisfy\n// this requirement.  Element can be an array type itself (hence\n// multi-dimensional arrays are supported).\ntemplate <typename Element>\nclass NativeArray {\n public:\n  // STL-style container typedefs.\n  typedef Element value_type;\n  typedef Element* iterator;\n  typedef const Element* const_iterator;\n\n  // Constructs from a native array. References the source.\n  NativeArray(const Element* array, size_t count, RelationToSourceReference) {\n    InitRef(array, count);\n  }\n\n  // Constructs from a native array. Copies the source.\n  NativeArray(const Element* array, size_t count, RelationToSourceCopy) {\n    InitCopy(array, count);\n  }\n\n  // Copy constructor.\n  NativeArray(const NativeArray& rhs) {\n    (this->*rhs.clone_)(rhs.array_, rhs.size_);\n  }\n\n  ~NativeArray() {\n    if (clone_ != &NativeArray::InitRef)\n      delete[] array_;\n  }\n\n  // STL-style container methods.\n  size_t size() const { return size_; }\n  const_iterator begin() const { return array_; }\n  const_iterator end() const { return array_ + size_; }\n  bool operator==(const NativeArray& rhs) const {\n    return size() == rhs.size() &&\n        ArrayEq(begin(), size(), rhs.begin());\n  }\n\n private:\n  enum {\n    kCheckTypeIsNotConstOrAReference = StaticAssertTypeEqHelper<\n        Element, GTEST_REMOVE_REFERENCE_AND_CONST_(Element)>::value,\n  };\n\n  // Initializes this object with a copy of the input.\n  void InitCopy(const Element* array, size_t a_size) {\n    Element* const copy = new Element[a_size];\n    CopyArray(array, a_size, copy);\n    array_ = copy;\n    size_ = a_size;\n    clone_ = &NativeArray::InitCopy;\n  }\n\n  // Initializes this object with a reference of the input.\n  void InitRef(const Element* array, size_t a_size) {\n    array_ = array;\n    size_ = a_size;\n    clone_ = &NativeArray::InitRef;\n  }\n\n  const Element* array_;\n  size_t size_;\n  void (NativeArray::*clone_)(const Element*, size_t);\n\n  GTEST_DISALLOW_ASSIGN_(NativeArray);\n};\n\n}  // namespace internal\n}  // namespace testing\n\n#define GTEST_MESSAGE_AT_(file, line, message, result_type) \\\n  ::testing::internal::AssertHelper(result_type, file, line, message) \\\n    = ::testing::Message()\n\n#define GTEST_MESSAGE_(message, result_type) \\\n  GTEST_MESSAGE_AT_(__FILE__, __LINE__, message, result_type)\n\n#define GTEST_FATAL_FAILURE_(message) \\\n  return GTEST_MESSAGE_(message, ::testing::TestPartResult::kFatalFailure)\n\n#define GTEST_NONFATAL_FAILURE_(message) \\\n  GTEST_MESSAGE_(message, ::testing::TestPartResult::kNonFatalFailure)\n\n#define GTEST_SUCCESS_(message) \\\n  GTEST_MESSAGE_(message, ::testing::TestPartResult::kSuccess)\n\n// Suppresses MSVC warnings 4072 (unreachable code) for the code following\n// statement if it returns or throws (or doesn't return or throw in some\n// situations).\n#define GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement) \\\n  if (::testing::internal::AlwaysTrue()) { statement; }\n\n#define GTEST_TEST_THROW_(statement, expected_exception, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::ConstCharPtr gtest_msg = \"\") { \\\n    bool gtest_caught_expected = false; \\\n    try { \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    } \\\n    catch (expected_exception const&) { \\\n      gtest_caught_expected = true; \\\n    } \\\n    catch (...) { \\\n      gtest_msg.value = \\\n          \"Expected: \" #statement \" throws an exception of type \" \\\n          #expected_exception \".\\n  Actual: it throws a different type.\"; \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \\\n    } \\\n    if (!gtest_caught_expected) { \\\n      gtest_msg.value = \\\n          \"Expected: \" #statement \" throws an exception of type \" \\\n          #expected_exception \".\\n  Actual: it throws nothing.\"; \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__): \\\n      fail(gtest_msg.value)\n\n#define GTEST_TEST_NO_THROW_(statement, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::AlwaysTrue()) { \\\n    try { \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    } \\\n    catch (...) { \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__): \\\n      fail(\"Expected: \" #statement \" doesn't throw an exception.\\n\" \\\n           \"  Actual: it throws.\")\n\n#define GTEST_TEST_ANY_THROW_(statement, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::AlwaysTrue()) { \\\n    bool gtest_caught_any = false; \\\n    try { \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    } \\\n    catch (...) { \\\n      gtest_caught_any = true; \\\n    } \\\n    if (!gtest_caught_any) { \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__): \\\n      fail(\"Expected: \" #statement \" throws an exception.\\n\" \\\n           \"  Actual: it doesn't.\")\n\n\n// Implements Boolean test assertions such as EXPECT_TRUE. expression can be\n// either a boolean expression or an AssertionResult. text is a textual\n// represenation of expression as it was passed into the EXPECT_TRUE.\n#define GTEST_TEST_BOOLEAN_(expression, text, actual, expected, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (const ::testing::AssertionResult gtest_ar_ = \\\n      ::testing::AssertionResult(expression)) \\\n    ; \\\n  else \\\n    fail(::testing::internal::GetBoolAssertionFailureMessage(\\\n        gtest_ar_, text, #actual, #expected).c_str())\n\n#define GTEST_TEST_NO_FATAL_FAILURE_(statement, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::AlwaysTrue()) { \\\n    ::testing::internal::HasNewFatalFailureHelper gtest_fatal_failure_checker; \\\n    GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    if (gtest_fatal_failure_checker.has_new_fatal_failure()) { \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__): \\\n      fail(\"Expected: \" #statement \" doesn't generate new fatal \" \\\n           \"failures in the current thread.\\n\" \\\n           \"  Actual: it does.\")\n\n// Expands to the name of the class that implements the given test.\n#define GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \\\n  test_case_name##_##test_name##_Test\n\n// Helper macro for defining tests.\n#define GTEST_TEST_(test_case_name, test_name, parent_class, parent_id)\\\nclass GTEST_TEST_CLASS_NAME_(test_case_name, test_name) : public parent_class {\\\n public:\\\n  GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() {}\\\n private:\\\n  virtual void TestBody();\\\n  static ::testing::TestInfo* const test_info_ GTEST_ATTRIBUTE_UNUSED_;\\\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(\\\n      GTEST_TEST_CLASS_NAME_(test_case_name, test_name));\\\n};\\\n\\\n::testing::TestInfo* const GTEST_TEST_CLASS_NAME_(test_case_name, test_name)\\\n  ::test_info_ =\\\n    ::testing::internal::MakeAndRegisterTestInfo(\\\n        #test_case_name, #test_name, NULL, NULL, \\\n        ::testing::internal::CodeLocation(__FILE__, __LINE__), \\\n        (parent_id), \\\n        parent_class::SetUpTestCase, \\\n        parent_class::TearDownTestCase, \\\n        new ::testing::internal::TestFactoryImpl<\\\n            GTEST_TEST_CLASS_NAME_(test_case_name, test_name)>);\\\nvoid GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_\n\n"}, "45": {"id": 45, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-linked_ptr.h", "content": "// Copyright 2003 Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Authors: Dan Egnor (egnor@google.com)\n//\n// A \"smart\" pointer type with reference tracking.  Every pointer to a\n// particular object is kept on a circular linked list.  When the last pointer\n// to an object is destroyed or reassigned, the object is deleted.\n//\n// Used properly, this deletes the object when the last reference goes away.\n// There are several caveats:\n// - Like all reference counting schemes, cycles lead to leaks.\n// - Each smart pointer is actually two pointers (8 bytes instead of 4).\n// - Every time a pointer is assigned, the entire list of pointers to that\n//   object is traversed.  This class is therefore NOT SUITABLE when there\n//   will often be more than two or three pointers to a particular object.\n// - References are only tracked as long as linked_ptr<> objects are copied.\n//   If a linked_ptr<> is converted to a raw pointer and back, BAD THINGS\n//   will happen (double deletion).\n//\n// A good use of this class is storing object references in STL containers.\n// You can safely put linked_ptr<> in a vector<>.\n// Other uses may not be as good.\n//\n// Note: If you use an incomplete type with linked_ptr<>, the class\n// *containing* linked_ptr<> must have a constructor and destructor (even\n// if they do nothing!).\n//\n// Bill Gibbons suggested we use something like this.\n//\n// Thread Safety:\n//   Unlike other linked_ptr implementations, in this implementation\n//   a linked_ptr object is thread-safe in the sense that:\n//     - it's safe to copy linked_ptr objects concurrently,\n//     - it's safe to copy *from* a linked_ptr and read its underlying\n//       raw pointer (e.g. via get()) concurrently, and\n//     - it's safe to write to two linked_ptrs that point to the same\n//       shared object concurrently.\n// TODO(wan@google.com): rename this to safe_linked_ptr to avoid\n// confusion with normal linked_ptr.\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_LINKED_PTR_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_LINKED_PTR_H_\n\n#include <stdlib.h>\n#include <assert.h>\n\n#include \"gtest/internal/gtest-port.h\"\n\nnamespace testing {\nnamespace internal {\n\n// Protects copying of all linked_ptr objects.\nGTEST_API_ GTEST_DECLARE_STATIC_MUTEX_(g_linked_ptr_mutex);\n\n// This is used internally by all instances of linked_ptr<>.  It needs to be\n// a non-template class because different types of linked_ptr<> can refer to\n// the same object (linked_ptr<Superclass>(obj) vs linked_ptr<Subclass>(obj)).\n// So, it needs to be possible for different types of linked_ptr to participate\n// in the same circular linked list, so we need a single class type here.\n//\n// DO NOT USE THIS CLASS DIRECTLY YOURSELF.  Use linked_ptr<T>.\nclass linked_ptr_internal {\n public:\n  // Create a new circle that includes only this instance.\n  void join_new() {\n    next_ = this;\n  }\n\n  // Many linked_ptr operations may change p.link_ for some linked_ptr\n  // variable p in the same circle as this object.  Therefore we need\n  // to prevent two such operations from occurring concurrently.\n  //\n  // Note that different types of linked_ptr objects can coexist in a\n  // circle (e.g. linked_ptr<Base>, linked_ptr<Derived1>, and\n  // linked_ptr<Derived2>).  Therefore we must use a single mutex to\n  // protect all linked_ptr objects.  This can create serious\n  // contention in production code, but is acceptable in a testing\n  // framework.\n\n  // Join an existing circle.\n  void join(linked_ptr_internal const* ptr)\n      GTEST_LOCK_EXCLUDED_(g_linked_ptr_mutex) {\n    MutexLock lock(&g_linked_ptr_mutex);\n\n    linked_ptr_internal const* p = ptr;\n    while (p->next_ != ptr) {\n      assert(p->next_ != this &&\n             \"Trying to join() a linked ring we are already in. \"\n             \"Is GMock thread safety enabled?\");\n      p = p->next_;\n    }\n    p->next_ = this;\n    next_ = ptr;\n  }\n\n  // Leave whatever circle we're part of.  Returns true if we were the\n  // last member of the circle.  Once this is done, you can join() another.\n  bool depart()\n      GTEST_LOCK_EXCLUDED_(g_linked_ptr_mutex) {\n    MutexLock lock(&g_linked_ptr_mutex);\n\n    if (next_ == this) return true;\n    linked_ptr_internal const* p = next_;\n    while (p->next_ != this) {\n      assert(p->next_ != next_ &&\n             \"Trying to depart() a linked ring we are not in. \"\n             \"Is GMock thread safety enabled?\");\n      p = p->next_;\n    }\n    p->next_ = next_;\n    return false;\n  }\n\n private:\n  mutable linked_ptr_internal const* next_;\n};\n\ntemplate <typename T>\nclass linked_ptr {\n public:\n  typedef T element_type;\n\n  // Take over ownership of a raw pointer.  This should happen as soon as\n  // possible after the object is created.\n  explicit linked_ptr(T* ptr = NULL) { capture(ptr); }\n  ~linked_ptr() { depart(); }\n\n  // Copy an existing linked_ptr<>, adding ourselves to the list of references.\n  template <typename U> linked_ptr(linked_ptr<U> const& ptr) { copy(&ptr); }\n  linked_ptr(linked_ptr const& ptr) {  // NOLINT\n    assert(&ptr != this);\n    copy(&ptr);\n  }\n\n  // Assignment releases the old value and acquires the new.\n  template <typename U> linked_ptr& operator=(linked_ptr<U> const& ptr) {\n    depart();\n    copy(&ptr);\n    return *this;\n  }\n\n  linked_ptr& operator=(linked_ptr const& ptr) {\n    if (&ptr != this) {\n      depart();\n      copy(&ptr);\n    }\n    return *this;\n  }\n\n  // Smart pointer members.\n  void reset(T* ptr = NULL) {\n    depart();\n    capture(ptr);\n  }\n  T* get() const { return value_; }\n  T* operator->() const { return value_; }\n  T& operator*() const { return *value_; }\n\n  bool operator==(T* p) const { return value_ == p; }\n  bool operator!=(T* p) const { return value_ != p; }\n  template <typename U>\n  bool operator==(linked_ptr<U> const& ptr) const {\n    return value_ == ptr.get();\n  }\n  template <typename U>\n  bool operator!=(linked_ptr<U> const& ptr) const {\n    return value_ != ptr.get();\n  }\n\n private:\n  template <typename U>\n  friend class linked_ptr;\n\n  T* value_;\n  linked_ptr_internal link_;\n\n  void depart() {\n    if (link_.depart()) delete value_;\n  }\n\n  void capture(T* ptr) {\n    value_ = ptr;\n    link_.join_new();\n  }\n\n  template <typename U> void copy(linked_ptr<U> const* ptr) {\n    value_ = ptr->get();\n    if (value_)\n      link_.join(&ptr->link_);\n    else\n      link_.join_new();\n  }\n};\n\ntemplate<typename T> inline\nbool operator==(T* ptr, const linked_ptr<T>& x) {\n  return ptr == x.get();\n}\n\ntemplate<typename T> inline\nbool operator!=(T* ptr, const linked_ptr<T>& x) {\n  return ptr != x.get();\n}\n\n// A function to convert T* into linked_ptr<T>\n// Doing e.g. make_linked_ptr(new FooBarBaz<type>(arg)) is a shorter notation\n// for linked_ptr<FooBarBaz<type> >(new FooBarBaz<type>(arg))\ntemplate <typename T>\nlinked_ptr<T> make_linked_ptr(T* ptr) {\n  return linked_ptr<T>(ptr);\n}\n\n}  // namespace internal\n}  // namespace testing\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_LINKED_PTR_H_\n"}, "46": {"id": 46, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-port.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Authors: wan@google.com (Zhanyong Wan)\n//\n// Low-level types and utilities for porting Google Test to various\n// platforms.  All macros ending with _ and symbols defined in an\n// internal namespace are subject to change without notice.  Code\n// outside Google Test MUST NOT USE THEM DIRECTLY.  Macros that don't\n// end with _ are part of Google Test's public API and can be used by\n// code outside Google Test.\n//\n// This file is fundamental to Google Test.  All other Google Test source\n// files are expected to #include this.  Therefore, it cannot #include\n// any other Google Test header.\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_\n\n// Environment-describing macros\n// -----------------------------\n//\n// Google Test can be used in many different environments.  Macros in\n// this section tell Google Test what kind of environment it is being\n// used in, such that Google Test can provide environment-specific\n// features and implementations.\n//\n// Google Test tries to automatically detect the properties of its\n// environment, so users usually don't need to worry about these\n// macros.  However, the automatic detection is not perfect.\n// Sometimes it's necessary for a user to define some of the following\n// macros in the build script to override Google Test's decisions.\n//\n// If the user doesn't define a macro in the list, Google Test will\n// provide a default definition.  After this header is #included, all\n// macros in this list will be defined to either 1 or 0.\n//\n// Notes to maintainers:\n//   - Each macro here is a user-tweakable knob; do not grow the list\n//     lightly.\n//   - Use #if to key off these macros.  Don't use #ifdef or \"#if\n//     defined(...)\", which will not work as these macros are ALWAYS\n//     defined.\n//\n//   GTEST_HAS_CLONE          - Define it to 1/0 to indicate that clone(2)\n//                              is/isn't available.\n//   GTEST_HAS_EXCEPTIONS     - Define it to 1/0 to indicate that exceptions\n//                              are enabled.\n//   GTEST_HAS_GLOBAL_STRING  - Define it to 1/0 to indicate that ::string\n//                              is/isn't available (some systems define\n//                              ::string, which is different to std::string).\n//   GTEST_HAS_GLOBAL_WSTRING - Define it to 1/0 to indicate that ::string\n//                              is/isn't available (some systems define\n//                              ::wstring, which is different to std::wstring).\n//   GTEST_HAS_POSIX_RE       - Define it to 1/0 to indicate that POSIX regular\n//                              expressions are/aren't available.\n//   GTEST_HAS_PTHREAD        - Define it to 1/0 to indicate that <pthread.h>\n//                              is/isn't available.\n//   GTEST_HAS_RTTI           - Define it to 1/0 to indicate that RTTI is/isn't\n//                              enabled.\n//   GTEST_HAS_STD_WSTRING    - Define it to 1/0 to indicate that\n//                              std::wstring does/doesn't work (Google Test can\n//                              be used where std::wstring is unavailable).\n//   GTEST_HAS_TR1_TUPLE      - Define it to 1/0 to indicate tr1::tuple\n//                              is/isn't available.\n//   GTEST_HAS_SEH            - Define it to 1/0 to indicate whether the\n//                              compiler supports Microsoft's \"Structured\n//                              Exception Handling\".\n//   GTEST_HAS_STREAM_REDIRECTION\n//                            - Define it to 1/0 to indicate whether the\n//                              platform supports I/O stream redirection using\n//                              dup() and dup2().\n//   GTEST_USE_OWN_TR1_TUPLE  - Define it to 1/0 to indicate whether Google\n//                              Test's own tr1 tuple implementation should be\n//                              used.  Unused when the user sets\n//                              GTEST_HAS_TR1_TUPLE to 0.\n//   GTEST_LANG_CXX11         - Define it to 1/0 to indicate that Google Test\n//                              is building in C++11/C++98 mode.\n//   GTEST_LINKED_AS_SHARED_LIBRARY\n//                            - Define to 1 when compiling tests that use\n//                              Google Test as a shared library (known as\n//                              DLL on Windows).\n//   GTEST_CREATE_SHARED_LIBRARY\n//                            - Define to 1 when compiling Google Test itself\n//                              as a shared library.\n\n// Platform-indicating macros\n// --------------------------\n//\n// Macros indicating the platform on which Google Test is being used\n// (a macro is defined to 1 if compiled on the given platform;\n// otherwise UNDEFINED -- it's never defined to 0.).  Google Test\n// defines these macros automatically.  Code outside Google Test MUST\n// NOT define them.\n//\n//   GTEST_OS_AIX      - IBM AIX\n//   GTEST_OS_CYGWIN   - Cygwin\n//   GTEST_OS_FREEBSD  - FreeBSD\n//   GTEST_OS_HAIKU    - Haiku\n//   GTEST_OS_HPUX     - HP-UX\n//   GTEST_OS_LINUX    - Linux\n//     GTEST_OS_LINUX_ANDROID - Google Android\n//   GTEST_OS_MAC      - Mac OS X\n//     GTEST_OS_IOS    - iOS\n//   GTEST_OS_MINIX    - Minix\n//   GTEST_OS_NACL     - Google Native Client (NaCl)\n//   GTEST_OS_OPENBSD  - OpenBSD\n//   GTEST_OS_QNX      - QNX\n//   GTEST_OS_SOLARIS  - Sun Solaris\n//   GTEST_OS_SYMBIAN  - Symbian\n//   GTEST_OS_WINDOWS  - Windows (Desktop, MinGW, or Mobile)\n//     GTEST_OS_WINDOWS_DESKTOP  - Windows Desktop\n//     GTEST_OS_WINDOWS_MINGW    - MinGW\n//     GTEST_OS_WINDOWS_MOBILE   - Windows Mobile\n//     GTEST_OS_WINDOWS_PHONE    - Windows Phone\n//     GTEST_OS_WINDOWS_RT       - Windows Store App/WinRT\n//   GTEST_OS_ZOS      - z/OS\n//\n// Among the platforms, Cygwin, Linux, Max OS X, and Windows have the\n// most stable support.  Since core members of the Google Test project\n// don't have access to other platforms, support for them may be less\n// stable.  If you notice any problems on your platform, please notify\n// googletestframework@googlegroups.com (patches for fixing them are\n// even more welcome!).\n//\n// It is possible that none of the GTEST_OS_* macros are defined.\n\n// Feature-indicating macros\n// -------------------------\n//\n// Macros indicating which Google Test features are available (a macro\n// is defined to 1 if the corresponding feature is supported;\n// otherwise UNDEFINED -- it's never defined to 0.).  Google Test\n// defines these macros automatically.  Code outside Google Test MUST\n// NOT define them.\n//\n// These macros are public so that portable tests can be written.\n// Such tests typically surround code using a feature with an #if\n// which controls that code.  For example:\n//\n// #if GTEST_HAS_DEATH_TEST\n//   EXPECT_DEATH(DoSomethingDeadly());\n// #endif\n//\n//   GTEST_HAS_COMBINE      - the Combine() function (for value-parameterized\n//                            tests)\n//   GTEST_HAS_DEATH_TEST   - death tests\n//   GTEST_HAS_PARAM_TEST   - value-parameterized tests\n//   GTEST_HAS_TYPED_TEST   - typed tests\n//   GTEST_HAS_TYPED_TEST_P - type-parameterized tests\n//   GTEST_IS_THREADSAFE    - Google Test is thread-safe.\n//   GTEST_USES_POSIX_RE    - enhanced POSIX regex is used. Do not confuse with\n//                            GTEST_HAS_POSIX_RE (see above) which users can\n//                            define themselves.\n//   GTEST_USES_SIMPLE_RE   - our own simple regex is used;\n//                            the above two are mutually exclusive.\n//   GTEST_CAN_COMPARE_NULL - accepts untyped NULL in EXPECT_EQ().\n\n// Misc public macros\n// ------------------\n//\n//   GTEST_FLAG(flag_name)  - references the variable corresponding to\n//                            the given Google Test flag.\n\n// Internal utilities\n// ------------------\n//\n// The following macros and utilities are for Google Test's INTERNAL\n// use only.  Code outside Google Test MUST NOT USE THEM DIRECTLY.\n//\n// Macros for basic C++ coding:\n//   GTEST_AMBIGUOUS_ELSE_BLOCKER_ - for disabling a gcc warning.\n//   GTEST_ATTRIBUTE_UNUSED_  - declares that a class' instances or a\n//                              variable don't have to be used.\n//   GTEST_DISALLOW_ASSIGN_   - disables operator=.\n//   GTEST_DISALLOW_COPY_AND_ASSIGN_ - disables copy ctor and operator=.\n//   GTEST_MUST_USE_RESULT_   - declares that a function's result must be used.\n//   GTEST_INTENTIONAL_CONST_COND_PUSH_ - start code section where MSVC C4127 is\n//                                        suppressed (constant conditional).\n//   GTEST_INTENTIONAL_CONST_COND_POP_  - finish code section where MSVC C4127\n//                                        is suppressed.\n//\n// C++11 feature wrappers:\n//\n//   testing::internal::move  - portability wrapper for std::move.\n//\n// Synchronization:\n//   Mutex, MutexLock, ThreadLocal, GetThreadCount()\n//                            - synchronization primitives.\n//\n// Template meta programming:\n//   is_pointer     - as in TR1; needed on Symbian and IBM XL C/C++ only.\n//   IteratorTraits - partial implementation of std::iterator_traits, which\n//                    is not available in libCstd when compiled with Sun C++.\n//\n// Smart pointers:\n//   scoped_ptr     - as in TR2.\n//\n// Regular expressions:\n//   RE             - a simple regular expression class using the POSIX\n//                    Extended Regular Expression syntax on UNIX-like\n//                    platforms, or a reduced regular exception syntax on\n//                    other platforms, including Windows.\n//\n// Logging:\n//   GTEST_LOG_()   - logs messages at the specified severity level.\n//   LogToStderr()  - directs all log messages to stderr.\n//   FlushInfoLog() - flushes informational log messages.\n//\n// Stdout and stderr capturing:\n//   CaptureStdout()     - starts capturing stdout.\n//   GetCapturedStdout() - stops capturing stdout and returns the captured\n//                         string.\n//   CaptureStderr()     - starts capturing stderr.\n//   GetCapturedStderr() - stops capturing stderr and returns the captured\n//                         string.\n//\n// Integer types:\n//   TypeWithSize   - maps an integer to a int type.\n//   Int32, UInt32, Int64, UInt64, TimeInMillis\n//                  - integers of known sizes.\n//   BiggestInt     - the biggest signed integer type.\n//\n// Command-line utilities:\n//   GTEST_DECLARE_*()  - declares a flag.\n//   GTEST_DEFINE_*()   - defines a flag.\n//   GetInjectableArgvs() - returns the command line as a vector of strings.\n//\n// Environment variable utilities:\n//   GetEnv()             - gets the value of an environment variable.\n//   BoolFromGTestEnv()   - parses a bool environment variable.\n//   Int32FromGTestEnv()  - parses an Int32 environment variable.\n//   StringFromGTestEnv() - parses a string environment variable.\n\n#include <ctype.h>   // for isspace, etc\n#include <stddef.h>  // for ptrdiff_t\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#ifndef _WIN32_WCE\n# include <sys/types.h>\n# include <sys/stat.h>\n#endif  // !_WIN32_WCE\n\n#if defined __APPLE__\n# include <AvailabilityMacros.h>\n# include <TargetConditionals.h>\n#endif\n\n#include <algorithm>  // NOLINT\n#include <iostream>  // NOLINT\n#include <sstream>  // NOLINT\n#include <string>  // NOLINT\n#include <utility>\n#include <vector>  // NOLINT\n\n#include \"gtest/internal/gtest-port-arch.h\"\n#include \"gtest/internal/custom/gtest-port.h\"\n\n#if !defined(GTEST_DEV_EMAIL_)\n# define GTEST_DEV_EMAIL_ \"googletestframework@@googlegroups.com\"\n# define GTEST_FLAG_PREFIX_ \"gtest_\"\n# define GTEST_FLAG_PREFIX_DASH_ \"gtest-\"\n# define GTEST_FLAG_PREFIX_UPPER_ \"GTEST_\"\n# define GTEST_NAME_ \"Google Test\"\n# define GTEST_PROJECT_URL_ \"https://github.com/google/googletest/\"\n#endif  // !defined(GTEST_DEV_EMAIL_)\n\n#if !defined(GTEST_INIT_GOOGLE_TEST_NAME_)\n# define GTEST_INIT_GOOGLE_TEST_NAME_ \"testing::InitGoogleTest\"\n#endif  // !defined(GTEST_INIT_GOOGLE_TEST_NAME_)\n\n// Determines the version of gcc that is used to compile this.\n#ifdef __GNUC__\n// 40302 means version 4.3.2.\n# define GTEST_GCC_VER_ \\\n    (__GNUC__*10000 + __GNUC_MINOR__*100 + __GNUC_PATCHLEVEL__)\n#endif  // __GNUC__\n\n// Macros for disabling Microsoft Visual C++ warnings.\n//\n//   GTEST_DISABLE_MSC_WARNINGS_PUSH_(4800 4385)\n//   /* code that triggers warnings C4800 and C4385 */\n//   GTEST_DISABLE_MSC_WARNINGS_POP_()\n#if _MSC_VER >= 1500\n# define GTEST_DISABLE_MSC_WARNINGS_PUSH_(warnings) \\\n    __pragma(warning(push))                        \\\n    __pragma(warning(disable: warnings))\n# define GTEST_DISABLE_MSC_WARNINGS_POP_()          \\\n    __pragma(warning(pop))\n#else\n// Older versions of MSVC don't have __pragma.\n# define GTEST_DISABLE_MSC_WARNINGS_PUSH_(warnings)\n# define GTEST_DISABLE_MSC_WARNINGS_POP_()\n#endif\n\n#ifndef GTEST_LANG_CXX11\n// gcc and clang define __GXX_EXPERIMENTAL_CXX0X__ when\n// -std={c,gnu}++{0x,11} is passed.  The C++11 standard specifies a\n// value for __cplusplus, and recent versions of clang, gcc, and\n// probably other compilers set that too in C++11 mode.\n# if __GXX_EXPERIMENTAL_CXX0X__ || __cplusplus >= 201103L\n// Compiling in at least C++11 mode.\n#  define GTEST_LANG_CXX11 1\n# else\n#  define GTEST_LANG_CXX11 0\n# endif\n#endif\n\n// Distinct from C++11 language support, some environments don't provide\n// proper C++11 library support. Notably, it's possible to build in\n// C++11 mode when targeting Mac OS X 10.6, which has an old libstdc++\n// with no C++11 support.\n//\n// libstdc++ has sufficient C++11 support as of GCC 4.6.0, __GLIBCXX__\n// 20110325, but maintenance releases in the 4.4 and 4.5 series followed\n// this date, so check for those versions by their date stamps.\n// https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html#abi.versioning\n#if GTEST_LANG_CXX11 && \\\n    (!defined(__GLIBCXX__) || ( \\\n        __GLIBCXX__ >= 20110325ul &&  /* GCC >= 4.6.0 */ \\\n        /* Exclude patch releases of older branches: */ \\\n        __GLIBCXX__ != 20110416ul &&  /* GCC 4.4.6 */ \\\n        __GLIBCXX__ != 20120313ul &&  /* GCC 4.4.7 */ \\\n        __GLIBCXX__ != 20110428ul &&  /* GCC 4.5.3 */ \\\n        __GLIBCXX__ != 20120702ul))   /* GCC 4.5.4 */\n# define GTEST_STDLIB_CXX11 1\n#endif\n\n// Only use C++11 library features if the library provides them.\n#if GTEST_STDLIB_CXX11\n# define GTEST_HAS_STD_BEGIN_AND_END_ 1\n# define GTEST_HAS_STD_FORWARD_LIST_ 1\n# define GTEST_HAS_STD_FUNCTION_ 1\n# define GTEST_HAS_STD_INITIALIZER_LIST_ 1\n# define GTEST_HAS_STD_MOVE_ 1\n# define GTEST_HAS_STD_SHARED_PTR_ 1\n# define GTEST_HAS_STD_TYPE_TRAITS_ 1\n# define GTEST_HAS_STD_UNIQUE_PTR_ 1\n#endif\n\n// C++11 specifies that <tuple> provides std::tuple.\n// Some platforms still might not have it, however.\n#if GTEST_LANG_CXX11\n# define GTEST_HAS_STD_TUPLE_ 1\n# if defined(__clang__)\n// Inspired by http://clang.llvm.org/docs/LanguageExtensions.html#__has_include\n#  if defined(__has_include) && !__has_include(<tuple>)\n#   undef GTEST_HAS_STD_TUPLE_\n#  endif\n# elif defined(_MSC_VER)\n// Inspired by boost/config/stdlib/dinkumware.hpp\n#  if defined(_CPPLIB_VER) && _CPPLIB_VER < 520\n#   undef GTEST_HAS_STD_TUPLE_\n#  endif\n# elif defined(__GLIBCXX__)\n// Inspired by boost/config/stdlib/libstdcpp3.hpp,\n// http://gcc.gnu.org/gcc-4.2/changes.html and\n// http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt01ch01.html#manual.intro.status.standard.200x\n#  if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 2)\n#   undef GTEST_HAS_STD_TUPLE_\n#  endif\n# endif\n#endif\n\n// Brings in definitions for functions used in the testing::internal::posix\n// namespace (read, write, close, chdir, isatty, stat). We do not currently\n// use them on Windows Mobile.\n#if GTEST_OS_WINDOWS\n# if !GTEST_OS_WINDOWS_MOBILE\n#  include <direct.h>\n#  include <io.h>\n# endif\n// In order to avoid having to include <windows.h>, use forward declaration\n// assuming CRITICAL_SECTION is a typedef of _RTL_CRITICAL_SECTION.\n// This assumption is verified by\n// WindowsTypesTest.CRITICAL_SECTIONIs_RTL_CRITICAL_SECTION.\nstruct _RTL_CRITICAL_SECTION;\n#else\n// This assumes that non-Windows OSes provide unistd.h. For OSes where this\n// is not the case, we need to include headers that provide the functions\n// mentioned above.\n# include <unistd.h>\n# include <strings.h>\n#endif  // GTEST_OS_WINDOWS\n\n#if GTEST_OS_LINUX_ANDROID\n// Used to define __ANDROID_API__ matching the target NDK API level.\n#  include <android/api-level.h>  // NOLINT\n#endif\n\n// Defines this to true iff Google Test can use POSIX regular expressions.\n#ifndef GTEST_HAS_POSIX_RE\n# if GTEST_OS_LINUX_ANDROID\n// On Android, <regex.h> is only available starting with Gingerbread.\n#  define GTEST_HAS_POSIX_RE (__ANDROID_API__ >= 9)\n# else\n#  define GTEST_HAS_POSIX_RE (!GTEST_OS_WINDOWS)\n# endif\n#endif\n\n#if GTEST_USES_PCRE\n// The appropriate headers have already been included.\n\n#elif GTEST_HAS_POSIX_RE\n\n// On some platforms, <regex.h> needs someone to define size_t, and\n// won't compile otherwise.  We can #include it here as we already\n// included <stdlib.h>, which is guaranteed to define size_t through\n// <stddef.h>.\n# include <regex.h>  // NOLINT\n\n# define GTEST_USES_POSIX_RE 1\n\n#elif GTEST_OS_WINDOWS\n\n// <regex.h> is not available on Windows.  Use our own simple regex\n// implementation instead.\n# define GTEST_USES_SIMPLE_RE 1\n\n#else\n\n// <regex.h> may not be available on this platform.  Use our own\n// simple regex implementation instead.\n# define GTEST_USES_SIMPLE_RE 1\n\n#endif  // GTEST_USES_PCRE\n\n#ifndef GTEST_HAS_EXCEPTIONS\n// The user didn't tell us whether exceptions are enabled, so we need\n// to figure it out.\n# if defined(_MSC_VER) || defined(__BORLANDC__)\n// MSVC's and C++Builder's implementations of the STL use the _HAS_EXCEPTIONS\n// macro to enable exceptions, so we'll do the same.\n// Assumes that exceptions are enabled by default.\n#  ifndef _HAS_EXCEPTIONS\n#   define _HAS_EXCEPTIONS 1\n#  endif  // _HAS_EXCEPTIONS\n#  define GTEST_HAS_EXCEPTIONS _HAS_EXCEPTIONS\n# elif defined(__clang__)\n// clang defines __EXCEPTIONS iff exceptions are enabled before clang 220714,\n// but iff cleanups are enabled after that. In Obj-C++ files, there can be\n// cleanups for ObjC exceptions which also need cleanups, even if C++ exceptions\n// are disabled. clang has __has_feature(cxx_exceptions) which checks for C++\n// exceptions starting at clang r206352, but which checked for cleanups prior to\n// that. To reliably check for C++ exception availability with clang, check for\n// __EXCEPTIONS && __has_feature(cxx_exceptions).\n#  define GTEST_HAS_EXCEPTIONS (__EXCEPTIONS && __has_feature(cxx_exceptions))\n# elif defined(__GNUC__) && __EXCEPTIONS\n// gcc defines __EXCEPTIONS to 1 iff exceptions are enabled.\n#  define GTEST_HAS_EXCEPTIONS 1\n# elif defined(__SUNPRO_CC)\n// Sun Pro CC supports exceptions.  However, there is no compile-time way of\n// detecting whether they are enabled or not.  Therefore, we assume that\n// they are enabled unless the user tells us otherwise.\n#  define GTEST_HAS_EXCEPTIONS 1\n# elif defined(__IBMCPP__) && __EXCEPTIONS\n// xlC defines __EXCEPTIONS to 1 iff exceptions are enabled.\n#  define GTEST_HAS_EXCEPTIONS 1\n# elif defined(__HP_aCC)\n// Exception handling is in effect by default in HP aCC compiler. It has to\n// be turned of by +noeh compiler option if desired.\n#  define GTEST_HAS_EXCEPTIONS 1\n# else\n// For other compilers, we assume exceptions are disabled to be\n// conservative.\n#  define GTEST_HAS_EXCEPTIONS 0\n# endif  // defined(_MSC_VER) || defined(__BORLANDC__)\n#endif  // GTEST_HAS_EXCEPTIONS\n\n#if !defined(GTEST_HAS_STD_STRING)\n// Even though we don't use this macro any longer, we keep it in case\n// some clients still depend on it.\n# define GTEST_HAS_STD_STRING 1\n#elif !GTEST_HAS_STD_STRING\n// The user told us that ::std::string isn't available.\n# error \"Google Test cannot be used where ::std::string isn't available.\"\n#endif  // !defined(GTEST_HAS_STD_STRING)\n\n#ifndef GTEST_HAS_GLOBAL_STRING\n// The user didn't tell us whether ::string is available, so we need\n// to figure it out.\n\n# define GTEST_HAS_GLOBAL_STRING 0\n\n#endif  // GTEST_HAS_GLOBAL_STRING\n\n#ifndef GTEST_HAS_STD_WSTRING\n// The user didn't tell us whether ::std::wstring is available, so we need\n// to figure it out.\n// TODO(wan@google.com): uses autoconf to detect whether ::std::wstring\n//   is available.\n\n// Cygwin 1.7 and below doesn't support ::std::wstring.\n// Solaris' libc++ doesn't support it either.  Android has\n// no support for it at least as recent as Froyo (2.2).\n// Minix currently doesn't support it either.\n# define GTEST_HAS_STD_WSTRING \\\n    (!(GTEST_OS_LINUX_ANDROID || GTEST_OS_CYGWIN || GTEST_OS_SOLARIS || GTEST_OS_HAIKU || GTEST_OS_MINIX))\n\n#endif  // GTEST_HAS_STD_WSTRING\n\n#ifndef GTEST_HAS_GLOBAL_WSTRING\n// The user didn't tell us whether ::wstring is available, so we need\n// to figure it out.\n# define GTEST_HAS_GLOBAL_WSTRING \\\n    (GTEST_HAS_STD_WSTRING && GTEST_HAS_GLOBAL_STRING)\n#endif  // GTEST_HAS_GLOBAL_WSTRING\n\n// Determines whether RTTI is available.\n#ifndef GTEST_HAS_RTTI\n// The user didn't tell us whether RTTI is enabled, so we need to\n// figure it out.\n\n# ifdef _MSC_VER\n\n#  ifdef _CPPRTTI  // MSVC defines this macro iff RTTI is enabled.\n#   define GTEST_HAS_RTTI 1\n#  else\n#   define GTEST_HAS_RTTI 0\n#  endif\n\n// Starting with version 4.3.2, gcc defines __GXX_RTTI iff RTTI is enabled.\n# elif defined(__GNUC__) && (GTEST_GCC_VER_ >= 40302)\n\n#  ifdef __GXX_RTTI\n// When building against STLport with the Android NDK and with\n// -frtti -fno-exceptions, the build fails at link time with undefined\n// references to __cxa_bad_typeid. Note sure if STL or toolchain bug,\n// so disable RTTI when detected.\n#   if GTEST_OS_LINUX_ANDROID && defined(_STLPORT_MAJOR) && \\\n       !defined(__EXCEPTIONS)\n#    define GTEST_HAS_RTTI 0\n#   else\n#    define GTEST_HAS_RTTI 1\n#   endif  // GTEST_OS_LINUX_ANDROID && __STLPORT_MAJOR && !__EXCEPTIONS\n#  else\n#   define GTEST_HAS_RTTI 0\n#  endif  // __GXX_RTTI\n\n// Clang defines __GXX_RTTI starting with version 3.0, but its manual recommends\n// using has_feature instead. has_feature(cxx_rtti) is supported since 2.7, the\n// first version with C++ support.\n# elif defined(__clang__)\n\n#  define GTEST_HAS_RTTI __has_feature(cxx_rtti)\n\n// Starting with version 9.0 IBM Visual Age defines __RTTI_ALL__ to 1 if\n// both the typeid and dynamic_cast features are present.\n# elif defined(__IBMCPP__) && (__IBMCPP__ >= 900)\n\n#  ifdef __RTTI_ALL__\n#   define GTEST_HAS_RTTI 1\n#  else\n#   define GTEST_HAS_RTTI 0\n#  endif\n\n# else\n\n// For all other compilers, we assume RTTI is enabled.\n#  define GTEST_HAS_RTTI 1\n\n# endif  // _MSC_VER\n\n#endif  // GTEST_HAS_RTTI\n\n// It's this header's responsibility to #include <typeinfo> when RTTI\n// is enabled.\n#if GTEST_HAS_RTTI\n# include <typeinfo>\n#endif\n\n// Determines whether Google Test can use the pthreads library.\n#ifndef GTEST_HAS_PTHREAD\n// The user didn't tell us explicitly, so we make reasonable assumptions about\n// which platforms have pthreads support.\n//\n// To disable threading support in Google Test, add -DGTEST_HAS_PTHREAD=0\n// to your compiler flags.\n# define GTEST_HAS_PTHREAD (GTEST_OS_LINUX || GTEST_OS_MAC || GTEST_OS_HPUX \\\n    || GTEST_OS_QNX || GTEST_OS_FREEBSD || GTEST_OS_NACL)\n#endif  // GTEST_HAS_PTHREAD\n\n#if GTEST_HAS_PTHREAD\n// gtest-port.h guarantees to #include <pthread.h> when GTEST_HAS_PTHREAD is\n// true.\n# include <pthread.h>  // NOLINT\n\n// For timespec and nanosleep, used below.\n# include <time.h>  // NOLINT\n#endif\n\n// Determines if hash_map/hash_set are available.\n// Only used for testing against those containers.\n#if !defined(GTEST_HAS_HASH_MAP_)\n# if _MSC_VER\n#  define GTEST_HAS_HASH_MAP_ 1  // Indicates that hash_map is available.\n#  define GTEST_HAS_HASH_SET_ 1  // Indicates that hash_set is available.\n# endif  // _MSC_VER\n#endif  // !defined(GTEST_HAS_HASH_MAP_)\n\n// Determines whether Google Test can use tr1/tuple.  You can define\n// this macro to 0 to prevent Google Test from using tuple (any\n// feature depending on tuple with be disabled in this mode).\n#ifndef GTEST_HAS_TR1_TUPLE\n# if GTEST_OS_LINUX_ANDROID && defined(_STLPORT_MAJOR)\n// STLport, provided with the Android NDK, has neither <tr1/tuple> or <tuple>.\n#  define GTEST_HAS_TR1_TUPLE 0\n# else\n// The user didn't tell us not to do it, so we assume it's OK.\n#  define GTEST_HAS_TR1_TUPLE 1\n# endif\n#endif  // GTEST_HAS_TR1_TUPLE\n\n// Determines whether Google Test's own tr1 tuple implementation\n// should be used.\n#ifndef GTEST_USE_OWN_TR1_TUPLE\n// The user didn't tell us, so we need to figure it out.\n\n// We use our own TR1 tuple if we aren't sure the user has an\n// implementation of it already.  At this time, libstdc++ 4.0.0+ and\n// MSVC 2010 are the only mainstream standard libraries that come\n// with a TR1 tuple implementation.  NVIDIA's CUDA NVCC compiler\n// pretends to be GCC by defining __GNUC__ and friends, but cannot\n// compile GCC's tuple implementation.  MSVC 2008 (9.0) provides TR1\n// tuple in a 323 MB Feature Pack download, which we cannot assume the\n// user has.  QNX's QCC compiler is a modified GCC but it doesn't\n// support TR1 tuple.  libc++ only provides std::tuple, in C++11 mode,\n// and it can be used with some compilers that define __GNUC__.\n# if (defined(__GNUC__) && !defined(__CUDACC__) && (GTEST_GCC_VER_ >= 40000) \\\n      && !GTEST_OS_QNX && !defined(_LIBCPP_VERSION)) || _MSC_VER >= 1600\n#  define GTEST_ENV_HAS_TR1_TUPLE_ 1\n# endif\n\n// C++11 specifies that <tuple> provides std::tuple. Use that if gtest is used\n// in C++11 mode and libstdc++ isn't very old (binaries targeting OS X 10.6\n// can build with clang but need to use gcc4.2's libstdc++).\n# if GTEST_LANG_CXX11 && (!defined(__GLIBCXX__) || __GLIBCXX__ > 20110325)\n#  define GTEST_ENV_HAS_STD_TUPLE_ 1\n# endif\n\n# if GTEST_ENV_HAS_TR1_TUPLE_ || GTEST_ENV_HAS_STD_TUPLE_\n#  define GTEST_USE_OWN_TR1_TUPLE 0\n# else\n#  define GTEST_USE_OWN_TR1_TUPLE 1\n# endif\n\n#endif  // GTEST_USE_OWN_TR1_TUPLE\n\n// To avoid conditional compilation everywhere, we make it\n// gtest-port.h's responsibility to #include the header implementing\n// tuple.\n#if GTEST_HAS_STD_TUPLE_\n# include <tuple>  // IWYU pragma: export\n# define GTEST_TUPLE_NAMESPACE_ ::std\n#endif  // GTEST_HAS_STD_TUPLE_\n\n// We include tr1::tuple even if std::tuple is available to define printers for\n// them.\n#if GTEST_HAS_TR1_TUPLE\n# ifndef GTEST_TUPLE_NAMESPACE_\n#  define GTEST_TUPLE_NAMESPACE_ ::std::tr1\n# endif  // GTEST_TUPLE_NAMESPACE_\n\n# if GTEST_USE_OWN_TR1_TUPLE\n#  include \"gtest/internal/gtest-tuple.h\"  // IWYU pragma: export  // NOLINT\n# elif GTEST_ENV_HAS_STD_TUPLE_\n#  include <tuple>\n// C++11 puts its tuple into the ::std namespace rather than\n// ::std::tr1.  gtest expects tuple to live in ::std::tr1, so put it there.\n// This causes undefined behavior, but supported compilers react in\n// the way we intend.\nnamespace std {\nnamespace tr1 {\nusing ::std::get;\nusing ::std::make_tuple;\nusing ::std::tuple;\nusing ::std::tuple_element;\nusing ::std::tuple_size;\n}\n}\n\n# elif GTEST_OS_SYMBIAN\n\n// On Symbian, BOOST_HAS_TR1_TUPLE causes Boost's TR1 tuple library to\n// use STLport's tuple implementation, which unfortunately doesn't\n// work as the copy of STLport distributed with Symbian is incomplete.\n// By making sure BOOST_HAS_TR1_TUPLE is undefined, we force Boost to\n// use its own tuple implementation.\n#  ifdef BOOST_HAS_TR1_TUPLE\n#   undef BOOST_HAS_TR1_TUPLE\n#  endif  // BOOST_HAS_TR1_TUPLE\n\n// This prevents <boost/tr1/detail/config.hpp>, which defines\n// BOOST_HAS_TR1_TUPLE, from being #included by Boost's <tuple>.\n#  define BOOST_TR1_DETAIL_CONFIG_HPP_INCLUDED\n#  include <tuple>  // IWYU pragma: export  // NOLINT\n\n# elif defined(__GNUC__) && (GTEST_GCC_VER_ >= 40000)\n// GCC 4.0+ implements tr1/tuple in the <tr1/tuple> header.  This does\n// not conform to the TR1 spec, which requires the header to be <tuple>.\n\n#  if !GTEST_HAS_RTTI && GTEST_GCC_VER_ < 40302\n// Until version 4.3.2, gcc has a bug that causes <tr1/functional>,\n// which is #included by <tr1/tuple>, to not compile when RTTI is\n// disabled.  _TR1_FUNCTIONAL is the header guard for\n// <tr1/functional>.  Hence the following #define is a hack to prevent\n// <tr1/functional> from being included.\n#   define _TR1_FUNCTIONAL 1\n#   include <tr1/tuple>\n#   undef _TR1_FUNCTIONAL  // Allows the user to #include\n                        // <tr1/functional> if he chooses to.\n#  else\n#   include <tr1/tuple>  // NOLINT\n#  endif  // !GTEST_HAS_RTTI && GTEST_GCC_VER_ < 40302\n\n# else\n// If the compiler is not GCC 4.0+, we assume the user is using a\n// spec-conforming TR1 implementation.\n#  include <tuple>  // IWYU pragma: export  // NOLINT\n# endif  // GTEST_USE_OWN_TR1_TUPLE\n\n#endif  // GTEST_HAS_TR1_TUPLE\n\n// Determines whether clone(2) is supported.\n// Usually it will only be available on Linux, excluding\n// Linux on the Itanium architecture.\n// Also see http://linux.die.net/man/2/clone.\n#ifndef GTEST_HAS_CLONE\n// The user didn't tell us, so we need to figure it out.\n\n# if GTEST_OS_LINUX && !defined(__ia64__)\n#  if GTEST_OS_LINUX_ANDROID\n// On Android, clone() is only available on ARM starting with Gingerbread.\n#    if defined(__arm__) && __ANDROID_API__ >= 9\n#     define GTEST_HAS_CLONE 1\n#    else\n#     define GTEST_HAS_CLONE 0\n#    endif\n#  else\n#   define GTEST_HAS_CLONE 1\n#  endif\n# else\n#  define GTEST_HAS_CLONE 0\n# endif  // GTEST_OS_LINUX && !defined(__ia64__)\n\n#endif  // GTEST_HAS_CLONE\n\n// Determines whether to support stream redirection. This is used to test\n// output correctness and to implement death tests.\n#ifndef GTEST_HAS_STREAM_REDIRECTION\n// By default, we assume that stream redirection is supported on all\n// platforms except known mobile ones.\n# if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_SYMBIAN || \\\n    GTEST_OS_WINDOWS_PHONE || GTEST_OS_WINDOWS_RT\n#  define GTEST_HAS_STREAM_REDIRECTION 0\n# else\n#  define GTEST_HAS_STREAM_REDIRECTION 1\n# endif  // !GTEST_OS_WINDOWS_MOBILE && !GTEST_OS_SYMBIAN\n#endif  // GTEST_HAS_STREAM_REDIRECTION\n\n// Determines whether to support death tests.\n// Google Test does not support death tests for VC 7.1 and earlier as\n// abort() in a VC 7.1 application compiled as GUI in debug config\n// pops up a dialog window that cannot be suppressed programmatically.\n#if (GTEST_OS_LINUX || GTEST_OS_CYGWIN || GTEST_OS_SOLARIS || \\\n     (GTEST_OS_MAC && !GTEST_OS_IOS) || \\\n     (GTEST_OS_WINDOWS_DESKTOP && _MSC_VER >= 1400) || \\\n     GTEST_OS_WINDOWS_MINGW || GTEST_OS_AIX || GTEST_OS_HPUX || \\\n     GTEST_OS_OPENBSD || GTEST_OS_QNX || GTEST_OS_FREEBSD || GTEST_OS_NETBSD)\n# define GTEST_HAS_DEATH_TEST 1\n#endif\n\n// We don't support MSVC 7.1 with exceptions disabled now.  Therefore\n// all the compilers we care about are adequate for supporting\n// value-parameterized tests.\n#define GTEST_HAS_PARAM_TEST 1\n\n// Determines whether to support type-driven tests.\n\n// Typed tests need <typeinfo> and variadic macros, which GCC, VC++ 8.0,\n// Sun Pro CC, IBM Visual Age, and HP aCC support.\n#if defined(__GNUC__) || (_MSC_VER >= 1400) || defined(__SUNPRO_CC) || \\\n    defined(__IBMCPP__) || defined(__HP_aCC)\n# define GTEST_HAS_TYPED_TEST 1\n# define GTEST_HAS_TYPED_TEST_P 1\n#endif\n\n// Determines whether to support Combine(). This only makes sense when\n// value-parameterized tests are enabled.  The implementation doesn't\n// work on Sun Studio since it doesn't understand templated conversion\n// operators.\n#if GTEST_HAS_PARAM_TEST && GTEST_HAS_TR1_TUPLE && !defined(__SUNPRO_CC)\n# define GTEST_HAS_COMBINE 1\n#endif\n\n// Determines whether the system compiler uses UTF-16 for encoding wide strings.\n#define GTEST_WIDE_STRING_USES_UTF16_ \\\n    (GTEST_OS_WINDOWS || GTEST_OS_CYGWIN || GTEST_OS_SYMBIAN || GTEST_OS_AIX)\n\n// Determines whether test results can be streamed to a socket.\n#if GTEST_OS_LINUX\n# define GTEST_CAN_STREAM_RESULTS_ 1\n#endif\n\n// Defines some utility macros.\n\n// The GNU compiler emits a warning if nested \"if\" statements are followed by\n// an \"else\" statement and braces are not used to explicitly disambiguate the\n// \"else\" binding.  This leads to problems with code like:\n//\n//   if (gate)\n//     ASSERT_*(condition) << \"Some message\";\n//\n// The \"switch (0) case 0:\" idiom is used to suppress this.\n#ifdef __INTEL_COMPILER\n# define GTEST_AMBIGUOUS_ELSE_BLOCKER_\n#else\n# define GTEST_AMBIGUOUS_ELSE_BLOCKER_ switch (0) case 0: default:  // NOLINT\n#endif\n\n// Use this annotation at the end of a struct/class definition to\n// prevent the compiler from optimizing away instances that are never\n// used.  This is useful when all interesting logic happens inside the\n// c'tor and / or d'tor.  Example:\n//\n//   struct Foo {\n//     Foo() { ... }\n//   } GTEST_ATTRIBUTE_UNUSED_;\n//\n// Also use it after a variable or parameter declaration to tell the\n// compiler the variable/parameter does not have to be used.\n#if defined(__GNUC__) && !defined(COMPILER_ICC)\n# define GTEST_ATTRIBUTE_UNUSED_ __attribute__ ((unused))\n#elif defined(__clang__)\n# if __has_attribute(unused)\n#  define GTEST_ATTRIBUTE_UNUSED_ __attribute__ ((unused))\n# endif\n#endif\n#ifndef GTEST_ATTRIBUTE_UNUSED_\n# define GTEST_ATTRIBUTE_UNUSED_\n#endif\n\n// A macro to disallow operator=\n// This should be used in the private: declarations for a class.\n#define GTEST_DISALLOW_ASSIGN_(type)\\\n  void operator=(type const &) = delete\n\n// A macro to disallow copy constructor and operator=\n// This should be used in the private: declarations for a class.\n#define GTEST_DISALLOW_COPY_AND_ASSIGN_(type)\\\n  type(type const &) = delete;\\\n  GTEST_DISALLOW_ASSIGN_(type)\n\n// Tell the compiler to warn about unused return values for functions declared\n// with this macro.  The macro should be used on function declarations\n// following the argument list:\n//\n//   Sprocket* AllocateSprocket() GTEST_MUST_USE_RESULT_;\n#if defined(__GNUC__) && (GTEST_GCC_VER_ >= 30400) && !defined(COMPILER_ICC)\n# define GTEST_MUST_USE_RESULT_ __attribute__ ((warn_unused_result))\n#else\n# define GTEST_MUST_USE_RESULT_\n#endif  // __GNUC__ && (GTEST_GCC_VER_ >= 30400) && !COMPILER_ICC\n\n// MS C++ compiler emits warning when a conditional expression is compile time\n// constant. In some contexts this warning is false positive and needs to be\n// suppressed. Use the following two macros in such cases:\n//\n// GTEST_INTENTIONAL_CONST_COND_PUSH_()\n// while (true) {\n// GTEST_INTENTIONAL_CONST_COND_POP_()\n// }\n# define GTEST_INTENTIONAL_CONST_COND_PUSH_() \\\n    GTEST_DISABLE_MSC_WARNINGS_PUSH_(4127)\n# define GTEST_INTENTIONAL_CONST_COND_POP_() \\\n    GTEST_DISABLE_MSC_WARNINGS_POP_()\n\n// Determine whether the compiler supports Microsoft's Structured Exception\n// Handling.  This is supported by several Windows compilers but generally\n// does not exist on any other system.\n#ifndef GTEST_HAS_SEH\n// The user didn't tell us, so we need to figure it out.\n\n# if defined(_MSC_VER) || defined(__BORLANDC__)\n// These two compilers are known to support SEH.\n#  define GTEST_HAS_SEH 1\n# else\n// Assume no SEH.\n#  define GTEST_HAS_SEH 0\n# endif\n\n#endif  // GTEST_HAS_SEH\n\n#define GTEST_IS_THREADSAFE \\\n    (GTEST_HAS_MUTEX_AND_THREAD_LOCAL_ \\\n     || (GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT) \\\n     || GTEST_HAS_PTHREAD)\n\n#ifdef _MSC_VER\n# if GTEST_LINKED_AS_SHARED_LIBRARY\n#  define GTEST_API_ __declspec(dllimport)\n# elif GTEST_CREATE_SHARED_LIBRARY\n#  define GTEST_API_ __declspec(dllexport)\n# endif\n#elif __GNUC__ >= 4 || defined(__clang__)\n# define GTEST_API_ __attribute__((visibility (\"default\")))\n#endif // _MSC_VER\n\n#ifndef GTEST_API_\n# define GTEST_API_\n#endif\n\n#ifdef __GNUC__\n// Ask the compiler to never inline a given function.\n# define GTEST_NO_INLINE_ __attribute__((noinline))\n#else\n# define GTEST_NO_INLINE_\n#endif\n\n// _LIBCPP_VERSION is defined by the libc++ library from the LLVM project.\n#if defined(__has_include)\n# if __has_include(<cxxabi.h>)\n#  define GTEST_HAS_CXXABI_H_ 1\n# else\n#  define GTEST_HAS_CXXABI_H_ 0\n# endif\n#elif defined(__GLIBCXX__) || defined(_LIBCPP_VERSION)\n# define GTEST_HAS_CXXABI_H_ 1\n#else\n# define GTEST_HAS_CXXABI_H_ 0\n#endif\n\n// A function level attribute to disable checking for use of uninitialized\n// memory when built with MemorySanitizer.\n#if defined(__clang__)\n# if __has_feature(memory_sanitizer)\n#  define GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_ \\\n       __attribute__((no_sanitize_memory))\n# else\n#  define GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_\n# endif  // __has_feature(memory_sanitizer)\n#else\n# define GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_\n#endif  // __clang__\n\n// A function level attribute to disable AddressSanitizer instrumentation.\n#if defined(__clang__)\n# if __has_feature(address_sanitizer)\n#  define GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_ \\\n       __attribute__((no_sanitize_address))\n# else\n#  define GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_\n# endif  // __has_feature(address_sanitizer)\n#else\n# define GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_\n#endif  // __clang__\n\n// A function level attribute to disable ThreadSanitizer instrumentation.\n#if defined(__clang__)\n# if __has_feature(thread_sanitizer)\n#  define GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_ \\\n       __attribute__((no_sanitize_thread))\n# else\n#  define GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_\n# endif  // __has_feature(thread_sanitizer)\n#else\n# define GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_\n#endif  // __clang__\n\nnamespace testing {\n\nclass Message;\n\n#if defined(GTEST_TUPLE_NAMESPACE_)\n// Import tuple and friends into the ::testing namespace.\n// It is part of our interface, having them in ::testing allows us to change\n// their types as needed.\nusing GTEST_TUPLE_NAMESPACE_::get;\nusing GTEST_TUPLE_NAMESPACE_::make_tuple;\nusing GTEST_TUPLE_NAMESPACE_::tuple;\nusing GTEST_TUPLE_NAMESPACE_::tuple_size;\nusing GTEST_TUPLE_NAMESPACE_::tuple_element;\n#endif  // defined(GTEST_TUPLE_NAMESPACE_)\n\nnamespace internal {\n\n// A secret type that Google Test users don't know about.  It has no\n// definition on purpose.  Therefore it's impossible to create a\n// Secret object, which is what we want.\nclass Secret;\n\n// The GTEST_COMPILE_ASSERT_ macro can be used to verify that a compile time\n// expression is true. For example, you could use it to verify the\n// size of a static array:\n//\n//   GTEST_COMPILE_ASSERT_(GTEST_ARRAY_SIZE_(names) == NUM_NAMES,\n//                         names_incorrect_size);\n//\n// or to make sure a struct is smaller than a certain size:\n//\n//   GTEST_COMPILE_ASSERT_(sizeof(foo) < 128, foo_too_large);\n//\n// The second argument to the macro is the name of the variable. If\n// the expression is false, most compilers will issue a warning/error\n// containing the name of the variable.\n\n#if GTEST_LANG_CXX11\n# define GTEST_COMPILE_ASSERT_(expr, msg) static_assert(expr, #msg)\n#else  // !GTEST_LANG_CXX11\ntemplate <bool>\n  struct CompileAssert {\n};\n\n# define GTEST_COMPILE_ASSERT_(expr, msg) \\\n  typedef ::testing::internal::CompileAssert<(static_cast<bool>(expr))> \\\n      msg[static_cast<bool>(expr) ? 1 : -1] GTEST_ATTRIBUTE_UNUSED_\n#endif  // !GTEST_LANG_CXX11\n\n// Implementation details of GTEST_COMPILE_ASSERT_:\n//\n// (In C++11, we simply use static_assert instead of the following)\n//\n// - GTEST_COMPILE_ASSERT_ works by defining an array type that has -1\n//   elements (and thus is invalid) when the expression is false.\n//\n// - The simpler definition\n//\n//    #define GTEST_COMPILE_ASSERT_(expr, msg) typedef char msg[(expr) ? 1 : -1]\n//\n//   does not work, as gcc supports variable-length arrays whose sizes\n//   are determined at run-time (this is gcc's extension and not part\n//   of the C++ standard).  As a result, gcc fails to reject the\n//   following code with the simple definition:\n//\n//     int foo;\n//     GTEST_COMPILE_ASSERT_(foo, msg); // not supposed to compile as foo is\n//                                      // not a compile-time constant.\n//\n// - By using the type CompileAssert<(bool(expr))>, we ensures that\n//   expr is a compile-time constant.  (Template arguments must be\n//   determined at compile-time.)\n//\n// - The outter parentheses in CompileAssert<(bool(expr))> are necessary\n//   to work around a bug in gcc 3.4.4 and 4.0.1.  If we had written\n//\n//     CompileAssert<bool(expr)>\n//\n//   instead, these compilers will refuse to compile\n//\n//     GTEST_COMPILE_ASSERT_(5 > 0, some_message);\n//\n//   (They seem to think the \">\" in \"5 > 0\" marks the end of the\n//   template argument list.)\n//\n// - The array size is (bool(expr) ? 1 : -1), instead of simply\n//\n//     ((expr) ? 1 : -1).\n//\n//   This is to avoid running into a bug in MS VC 7.1, which\n//   causes ((0.0) ? 1 : -1) to incorrectly evaluate to 1.\n\n// StaticAssertTypeEqHelper is used by StaticAssertTypeEq defined in gtest.h.\n//\n// This template is declared, but intentionally undefined.\ntemplate <typename T1, typename T2>\nstruct StaticAssertTypeEqHelper;\n\ntemplate <typename T>\nstruct StaticAssertTypeEqHelper<T, T> {\n  enum { value = true };\n};\n\n// Evaluates to the number of elements in 'array'.\n#define GTEST_ARRAY_SIZE_(array) (sizeof(array) / sizeof(array[0]))\n\n#if GTEST_HAS_GLOBAL_STRING\ntypedef ::string string;\n#else\ntypedef ::std::string string;\n#endif  // GTEST_HAS_GLOBAL_STRING\n\n#if GTEST_HAS_GLOBAL_WSTRING\ntypedef ::wstring wstring;\n#elif GTEST_HAS_STD_WSTRING\ntypedef ::std::wstring wstring;\n#endif  // GTEST_HAS_GLOBAL_WSTRING\n\n// A helper for suppressing warnings on constant condition.  It just\n// returns 'condition'.\nGTEST_API_ bool IsTrue(bool condition);\n\n// Defines scoped_ptr.\n\n// This implementation of scoped_ptr is PARTIAL - it only contains\n// enough stuff to satisfy Google Test's need.\ntemplate <typename T>\nclass scoped_ptr {\n public:\n  typedef T element_type;\n\n  explicit scoped_ptr(T* p = NULL) : ptr_(p) {}\n  ~scoped_ptr() { reset(); }\n\n  T& operator*() const { return *ptr_; }\n  T* operator->() const { return ptr_; }\n  T* get() const { return ptr_; }\n\n  T* release() {\n    T* const ptr = ptr_;\n    ptr_ = NULL;\n    return ptr;\n  }\n\n  void reset(T* p = NULL) {\n    if (p != ptr_) {\n      if (IsTrue(sizeof(T) > 0)) {  // Makes sure T is a complete type.\n        delete ptr_;\n      }\n      ptr_ = p;\n    }\n  }\n\n  friend void swap(scoped_ptr& a, scoped_ptr& b) {\n    using std::swap;\n    swap(a.ptr_, b.ptr_);\n  }\n\n private:\n  T* ptr_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(scoped_ptr);\n};\n\n// Defines RE.\n\n// A simple C++ wrapper for <regex.h>.  It uses the POSIX Extended\n// Regular Expression syntax.\nclass GTEST_API_ RE {\n public:\n  // A copy constructor is required by the Standard to initialize object\n  // references from r-values.\n  RE(const RE& other) { Init(other.pattern()); }\n\n  // Constructs an RE from a string.\n  RE(const ::std::string& regex) { Init(regex.c_str()); }  // NOLINT\n\n#if GTEST_HAS_GLOBAL_STRING\n\n  RE(const ::string& regex) { Init(regex.c_str()); }  // NOLINT\n\n#endif  // GTEST_HAS_GLOBAL_STRING\n\n  RE(const char* regex) { Init(regex); }  // NOLINT\n  ~RE();\n\n  // Returns the string representation of the regex.\n  const char* pattern() const { return pattern_; }\n\n  // FullMatch(str, re) returns true iff regular expression re matches\n  // the entire str.\n  // PartialMatch(str, re) returns true iff regular expression re\n  // matches a substring of str (including str itself).\n  //\n  // TODO(wan@google.com): make FullMatch() and PartialMatch() work\n  // when str contains NUL characters.\n  static bool FullMatch(const ::std::string& str, const RE& re) {\n    return FullMatch(str.c_str(), re);\n  }\n  static bool PartialMatch(const ::std::string& str, const RE& re) {\n    return PartialMatch(str.c_str(), re);\n  }\n\n#if GTEST_HAS_GLOBAL_STRING\n\n  static bool FullMatch(const ::string& str, const RE& re) {\n    return FullMatch(str.c_str(), re);\n  }\n  static bool PartialMatch(const ::string& str, const RE& re) {\n    return PartialMatch(str.c_str(), re);\n  }\n\n#endif  // GTEST_HAS_GLOBAL_STRING\n\n  static bool FullMatch(const char* str, const RE& re);\n  static bool PartialMatch(const char* str, const RE& re);\n\n private:\n  void Init(const char* regex);\n\n  // We use a const char* instead of an std::string, as Google Test used to be\n  // used where std::string is not available.  TODO(wan@google.com): change to\n  // std::string.\n  const char* pattern_;\n  bool is_valid_;\n\n#if GTEST_USES_POSIX_RE\n\n  regex_t full_regex_;     // For FullMatch().\n  regex_t partial_regex_;  // For PartialMatch().\n\n#else  // GTEST_USES_SIMPLE_RE\n\n  const char* full_pattern_;  // For FullMatch();\n\n#endif\n\n  GTEST_DISALLOW_ASSIGN_(RE);\n};\n\n// Formats a source file path and a line number as they would appear\n// in an error message from the compiler used to compile this code.\nGTEST_API_ ::std::string FormatFileLocation(const char* file, int line);\n\n// Formats a file location for compiler-independent XML output.\n// Although this function is not platform dependent, we put it next to\n// FormatFileLocation in order to contrast the two functions.\nGTEST_API_ ::std::string FormatCompilerIndependentFileLocation(const char* file,\n                                                               int line);\n\n// Defines logging utilities:\n//   GTEST_LOG_(severity) - logs messages at the specified severity level. The\n//                          message itself is streamed into the macro.\n//   LogToStderr()  - directs all log messages to stderr.\n//   FlushInfoLog() - flushes informational log messages.\n\nenum GTestLogSeverity {\n  GTEST_INFO,\n  GTEST_WARNING,\n  GTEST_ERROR,\n  GTEST_FATAL\n};\n\n// Formats log entry severity, provides a stream object for streaming the\n// log message, and terminates the message with a newline when going out of\n// scope.\nclass GTEST_API_ GTestLog {\n public:\n  GTestLog(GTestLogSeverity severity, const char* file, int line);\n\n  // Flushes the buffers and, if severity is GTEST_FATAL, aborts the program.\n  ~GTestLog();\n\n  ::std::ostream& GetStream() { return ::std::cerr; }\n\n private:\n  const GTestLogSeverity severity_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(GTestLog);\n};\n\n#if !defined(GTEST_LOG_)\n\n# define GTEST_LOG_(severity) \\\n    ::testing::internal::GTestLog(::testing::internal::GTEST_##severity, \\\n                                  __FILE__, __LINE__).GetStream()\n\ninline void LogToStderr() {}\ninline void FlushInfoLog() { fflush(NULL); }\n\n#endif  // !defined(GTEST_LOG_)\n\n#if !defined(GTEST_CHECK_)\n// INTERNAL IMPLEMENTATION - DO NOT USE.\n//\n// GTEST_CHECK_ is an all-mode assert. It aborts the program if the condition\n// is not satisfied.\n//  Synopsys:\n//    GTEST_CHECK_(boolean_condition);\n//     or\n//    GTEST_CHECK_(boolean_condition) << \"Additional message\";\n//\n//    This checks the condition and if the condition is not satisfied\n//    it prints message about the condition violation, including the\n//    condition itself, plus additional message streamed into it, if any,\n//    and then it aborts the program. It aborts the program irrespective of\n//    whether it is built in the debug mode or not.\n# define GTEST_CHECK_(condition) \\\n    GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n    if (::testing::internal::IsTrue(condition)) \\\n      ; \\\n    else \\\n      GTEST_LOG_(FATAL) << \"Condition \" #condition \" failed. \"\n#endif  // !defined(GTEST_CHECK_)\n\n// An all-mode assert to verify that the given POSIX-style function\n// call returns 0 (indicating success).  Known limitation: this\n// doesn't expand to a balanced 'if' statement, so enclose the macro\n// in {} if you need to use it as the only statement in an 'if'\n// branch.\n#define GTEST_CHECK_POSIX_SUCCESS_(posix_call) \\\n  if (const int gtest_error = (posix_call)) \\\n    GTEST_LOG_(FATAL) << #posix_call << \"failed with error \" \\\n                      << gtest_error\n\n#if GTEST_HAS_STD_MOVE_\nusing std::move;\n#else  // GTEST_HAS_STD_MOVE_\ntemplate <typename T>\nconst T& move(const T& t) {\n  return t;\n}\n#endif  // GTEST_HAS_STD_MOVE_\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// Use ImplicitCast_ as a safe version of static_cast for upcasting in\n// the type hierarchy (e.g. casting a Foo* to a SuperclassOfFoo* or a\n// const Foo*).  When you use ImplicitCast_, the compiler checks that\n// the cast is safe.  Such explicit ImplicitCast_s are necessary in\n// surprisingly many situations where C++ demands an exact type match\n// instead of an argument type convertable to a target type.\n//\n// The syntax for using ImplicitCast_ is the same as for static_cast:\n//\n//   ImplicitCast_<ToType>(expr)\n//\n// ImplicitCast_ would have been part of the C++ standard library,\n// but the proposal was submitted too late.  It will probably make\n// its way into the language in the future.\n//\n// This relatively ugly name is intentional. It prevents clashes with\n// similar functions users may have (e.g., implicit_cast). The internal\n// namespace alone is not enough because the function can be found by ADL.\ntemplate<typename To>\ninline To ImplicitCast_(To x) { return x; }\n\n// When you upcast (that is, cast a pointer from type Foo to type\n// SuperclassOfFoo), it's fine to use ImplicitCast_<>, since upcasts\n// always succeed.  When you downcast (that is, cast a pointer from\n// type Foo to type SubclassOfFoo), static_cast<> isn't safe, because\n// how do you know the pointer is really of type SubclassOfFoo?  It\n// could be a bare Foo, or of type DifferentSubclassOfFoo.  Thus,\n// when you downcast, you should use this macro.  In debug mode, we\n// use dynamic_cast<> to double-check the downcast is legal (we die\n// if it's not).  In normal mode, we do the efficient static_cast<>\n// instead.  Thus, it's important to test in debug mode to make sure\n// the cast is legal!\n//    This is the only place in the code we should use dynamic_cast<>.\n// In particular, you SHOULDN'T be using dynamic_cast<> in order to\n// do RTTI (eg code like this:\n//    if (dynamic_cast<Subclass1>(foo)) HandleASubclass1Object(foo);\n//    if (dynamic_cast<Subclass2>(foo)) HandleASubclass2Object(foo);\n// You should design the code some other way not to need this.\n//\n// This relatively ugly name is intentional. It prevents clashes with\n// similar functions users may have (e.g., down_cast). The internal\n// namespace alone is not enough because the function can be found by ADL.\ntemplate<typename To, typename From>  // use like this: DownCast_<T*>(foo);\ninline To DownCast_(From* f) {  // so we only accept pointers\n  // Ensures that To is a sub-type of From *.  This test is here only\n  // for compile-time type checking, and has no overhead in an\n  // optimized build at run-time, as it will be optimized away\n  // completely.\n  GTEST_INTENTIONAL_CONST_COND_PUSH_()\n  if (false) {\n  GTEST_INTENTIONAL_CONST_COND_POP_()\n    const To to = NULL;\n    ::testing::internal::ImplicitCast_<From*>(to);\n  }\n\n#if GTEST_HAS_RTTI\n  // RTTI: debug mode only!\n  GTEST_CHECK_(f == NULL || dynamic_cast<To>(f) != NULL);\n#endif\n  return static_cast<To>(f);\n}\n\n// Downcasts the pointer of type Base to Derived.\n// Derived must be a subclass of Base. The parameter MUST\n// point to a class of type Derived, not any subclass of it.\n// When RTTI is available, the function performs a runtime\n// check to enforce this.\ntemplate <class Derived, class Base>\nDerived* CheckedDowncastToActualType(Base* base) {\n#if GTEST_HAS_RTTI\n  GTEST_CHECK_(typeid(*base) == typeid(Derived));\n#endif\n\n#if GTEST_HAS_DOWNCAST_\n  return ::down_cast<Derived*>(base);\n#elif GTEST_HAS_RTTI\n  return dynamic_cast<Derived*>(base);  // NOLINT\n#else\n  return static_cast<Derived*>(base);  // Poor man's downcast.\n#endif\n}\n\n#if GTEST_HAS_STREAM_REDIRECTION\n\n// Defines the stderr capturer:\n//   CaptureStdout     - starts capturing stdout.\n//   GetCapturedStdout - stops capturing stdout and returns the captured string.\n//   CaptureStderr     - starts capturing stderr.\n//   GetCapturedStderr - stops capturing stderr and returns the captured string.\n//\nGTEST_API_ void CaptureStdout();\nGTEST_API_ std::string GetCapturedStdout();\nGTEST_API_ void CaptureStderr();\nGTEST_API_ std::string GetCapturedStderr();\n\n#endif  // GTEST_HAS_STREAM_REDIRECTION\n\n// Returns a path to temporary directory.\nGTEST_API_ std::string TempDir();\n\n// Returns the size (in bytes) of a file.\nGTEST_API_ size_t GetFileSize(FILE* file);\n\n// Reads the entire content of a file as a string.\nGTEST_API_ std::string ReadEntireFile(FILE* file);\n\n// All command line arguments.\nGTEST_API_ const ::std::vector<testing::internal::string>& GetArgvs();\n\n#if GTEST_HAS_DEATH_TEST\n\nconst ::std::vector<testing::internal::string>& GetInjectableArgvs();\nvoid SetInjectableArgvs(const ::std::vector<testing::internal::string>*\n                             new_argvs);\n\n\n#endif  // GTEST_HAS_DEATH_TEST\n\n// Defines synchronization primitives.\n#if GTEST_IS_THREADSAFE\n# if GTEST_HAS_PTHREAD\n// Sleeps for (roughly) n milliseconds.  This function is only for testing\n// Google Test's own constructs.  Don't use it in user tests, either\n// directly or indirectly.\ninline void SleepMilliseconds(int n) {\n  const timespec time = {\n    0,                  // 0 seconds.\n    n * 1000L * 1000L,  // And n ms.\n  };\n  nanosleep(&time, NULL);\n}\n# endif  // GTEST_HAS_PTHREAD\n\n# if GTEST_HAS_NOTIFICATION_\n// Notification has already been imported into the namespace.\n// Nothing to do here.\n\n# elif GTEST_HAS_PTHREAD\n// Allows a controller thread to pause execution of newly created\n// threads until notified.  Instances of this class must be created\n// and destroyed in the controller thread.\n//\n// This class is only for testing Google Test's own constructs. Do not\n// use it in user tests, either directly or indirectly.\nclass Notification {\n public:\n  Notification() : notified_(false) {\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_init(&mutex_, NULL));\n  }\n  ~Notification() {\n    pthread_mutex_destroy(&mutex_);\n  }\n\n  // Notifies all threads created with this notification to start. Must\n  // be called from the controller thread.\n  void Notify() {\n    pthread_mutex_lock(&mutex_);\n    notified_ = true;\n    pthread_mutex_unlock(&mutex_);\n  }\n\n  // Blocks until the controller thread notifies. Must be called from a test\n  // thread.\n  void WaitForNotification() {\n    for (;;) {\n      pthread_mutex_lock(&mutex_);\n      const bool notified = notified_;\n      pthread_mutex_unlock(&mutex_);\n      if (notified)\n        break;\n      SleepMilliseconds(10);\n    }\n  }\n\n private:\n  pthread_mutex_t mutex_;\n  bool notified_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Notification);\n};\n\n# elif GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT\n\nGTEST_API_ void SleepMilliseconds(int n);\n\n// Provides leak-safe Windows kernel handle ownership.\n// Used in death tests and in threading support.\nclass GTEST_API_ AutoHandle {\n public:\n  // Assume that Win32 HANDLE type is equivalent to void*. Doing so allows us to\n  // avoid including <windows.h> in this header file. Including <windows.h> is\n  // undesirable because it defines a lot of symbols and macros that tend to\n  // conflict with client code. This assumption is verified by\n  // WindowsTypesTest.HANDLEIsVoidStar.\n  typedef void* Handle;\n  AutoHandle();\n  explicit AutoHandle(Handle handle);\n\n  ~AutoHandle();\n\n  Handle Get() const;\n  void Reset();\n  void Reset(Handle handle);\n\n private:\n  // Returns true iff the handle is a valid handle object that can be closed.\n  bool IsCloseable() const;\n\n  Handle handle_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(AutoHandle);\n};\n\n// Allows a controller thread to pause execution of newly created\n// threads until notified.  Instances of this class must be created\n// and destroyed in the controller thread.\n//\n// This class is only for testing Google Test's own constructs. Do not\n// use it in user tests, either directly or indirectly.\nclass GTEST_API_ Notification {\n public:\n  Notification();\n  void Notify();\n  void WaitForNotification();\n\n private:\n  AutoHandle event_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Notification);\n};\n# endif  // GTEST_HAS_NOTIFICATION_\n\n// On MinGW, we can have both GTEST_OS_WINDOWS and GTEST_HAS_PTHREAD\n// defined, but we don't want to use MinGW's pthreads implementation, which\n// has conformance problems with some versions of the POSIX standard.\n# if GTEST_HAS_PTHREAD && !GTEST_OS_WINDOWS_MINGW\n\n// As a C-function, ThreadFuncWithCLinkage cannot be templated itself.\n// Consequently, it cannot select a correct instantiation of ThreadWithParam\n// in order to call its Run(). Introducing ThreadWithParamBase as a\n// non-templated base class for ThreadWithParam allows us to bypass this\n// problem.\nclass ThreadWithParamBase {\n public:\n  virtual ~ThreadWithParamBase() {}\n  virtual void Run() = 0;\n};\n\n// pthread_create() accepts a pointer to a function type with the C linkage.\n// According to the Standard (7.5/1), function types with different linkages\n// are different even if they are otherwise identical.  Some compilers (for\n// example, SunStudio) treat them as different types.  Since class methods\n// cannot be defined with C-linkage we need to define a free C-function to\n// pass into pthread_create().\nextern \"C\" inline void* ThreadFuncWithCLinkage(void* thread) {\n  static_cast<ThreadWithParamBase*>(thread)->Run();\n  return NULL;\n}\n\n// Helper class for testing Google Test's multi-threading constructs.\n// To use it, write:\n//\n//   void ThreadFunc(int param) { /* Do things with param */ }\n//   Notification thread_can_start;\n//   ...\n//   // The thread_can_start parameter is optional; you can supply NULL.\n//   ThreadWithParam<int> thread(&ThreadFunc, 5, &thread_can_start);\n//   thread_can_start.Notify();\n//\n// These classes are only for testing Google Test's own constructs. Do\n// not use them in user tests, either directly or indirectly.\ntemplate <typename T>\nclass ThreadWithParam : public ThreadWithParamBase {\n public:\n  typedef void UserThreadFunc(T);\n\n  ThreadWithParam(UserThreadFunc* func, T param, Notification* thread_can_start)\n      : func_(func),\n        param_(param),\n        thread_can_start_(thread_can_start),\n        finished_(false) {\n    ThreadWithParamBase* const base = this;\n    // The thread can be created only after all fields except thread_\n    // have been initialized.\n    GTEST_CHECK_POSIX_SUCCESS_(\n        pthread_create(&thread_, 0, &ThreadFuncWithCLinkage, base));\n  }\n  ~ThreadWithParam() { Join(); }\n\n  void Join() {\n    if (!finished_) {\n      GTEST_CHECK_POSIX_SUCCESS_(pthread_join(thread_, 0));\n      finished_ = true;\n    }\n  }\n\n  virtual void Run() {\n    if (thread_can_start_ != NULL)\n      thread_can_start_->WaitForNotification();\n    func_(param_);\n  }\n\n private:\n  UserThreadFunc* const func_;  // User-supplied thread function.\n  const T param_;  // User-supplied parameter to the thread function.\n  // When non-NULL, used to block execution until the controller thread\n  // notifies.\n  Notification* const thread_can_start_;\n  bool finished_;  // true iff we know that the thread function has finished.\n  pthread_t thread_;  // The native thread object.\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadWithParam);\n};\n# endif  // !GTEST_OS_WINDOWS && GTEST_HAS_PTHREAD ||\n         // GTEST_HAS_MUTEX_AND_THREAD_LOCAL_\n\n# if GTEST_HAS_MUTEX_AND_THREAD_LOCAL_\n// Mutex and ThreadLocal have already been imported into the namespace.\n// Nothing to do here.\n\n# elif GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT\n\n// Mutex implements mutex on Windows platforms.  It is used in conjunction\n// with class MutexLock:\n//\n//   Mutex mutex;\n//   ...\n//   MutexLock lock(&mutex);  // Acquires the mutex and releases it at the\n//                            // end of the current scope.\n//\n// A static Mutex *must* be defined or declared using one of the following\n// macros:\n//   GTEST_DEFINE_STATIC_MUTEX_(g_some_mutex);\n//   GTEST_DECLARE_STATIC_MUTEX_(g_some_mutex);\n//\n// (A non-static Mutex is defined/declared in the usual way).\nclass GTEST_API_ Mutex {\n public:\n  enum MutexType { kStatic = 0, kDynamic = 1 };\n  // We rely on kStaticMutex being 0 as it is to what the linker initializes\n  // type_ in static mutexes.  critical_section_ will be initialized lazily\n  // in ThreadSafeLazyInit().\n  enum StaticConstructorSelector { kStaticMutex = 0 };\n\n  // This constructor intentionally does nothing.  It relies on type_ being\n  // statically initialized to 0 (effectively setting it to kStatic) and on\n  // ThreadSafeLazyInit() to lazily initialize the rest of the members.\n  explicit Mutex(StaticConstructorSelector /*dummy*/) {}\n\n  Mutex();\n  ~Mutex();\n\n  void Lock();\n\n  void Unlock();\n\n  // Does nothing if the current thread holds the mutex. Otherwise, crashes\n  // with high probability.\n  void AssertHeld();\n\n private:\n  // Initializes owner_thread_id_ and critical_section_ in static mutexes.\n  void ThreadSafeLazyInit();\n\n  // Per http://blogs.msdn.com/b/oldnewthing/archive/2004/02/23/78395.aspx,\n  // we assume that 0 is an invalid value for thread IDs.\n  unsigned int owner_thread_id_;\n\n  // For static mutexes, we rely on these members being initialized to zeros\n  // by the linker.\n  MutexType type_;\n  long critical_section_init_phase_;  // NOLINT\n  _RTL_CRITICAL_SECTION* critical_section_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Mutex);\n};\n\n# define GTEST_DECLARE_STATIC_MUTEX_(mutex) \\\n    extern ::testing::internal::Mutex mutex\n\n# define GTEST_DEFINE_STATIC_MUTEX_(mutex) \\\n    ::testing::internal::Mutex mutex(::testing::internal::Mutex::kStaticMutex)\n\n// We cannot name this class MutexLock because the ctor declaration would\n// conflict with a macro named MutexLock, which is defined on some\n// platforms. That macro is used as a defensive measure to prevent against\n// inadvertent misuses of MutexLock like \"MutexLock(&mu)\" rather than\n// \"MutexLock l(&mu)\".  Hence the typedef trick below.\nclass GTestMutexLock {\n public:\n  explicit GTestMutexLock(Mutex* mutex)\n      : mutex_(mutex) { mutex_->Lock(); }\n\n  ~GTestMutexLock() { mutex_->Unlock(); }\n\n private:\n  Mutex* const mutex_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(GTestMutexLock);\n};\n\ntypedef GTestMutexLock MutexLock;\n\n// Base class for ValueHolder<T>.  Allows a caller to hold and delete a value\n// without knowing its type.\nclass ThreadLocalValueHolderBase {\n public:\n  virtual ~ThreadLocalValueHolderBase() {}\n};\n\n// Provides a way for a thread to send notifications to a ThreadLocal\n// regardless of its parameter type.\nclass ThreadLocalBase {\n public:\n  // Creates a new ValueHolder<T> object holding a default value passed to\n  // this ThreadLocal<T>'s constructor and returns it.  It is the caller's\n  // responsibility not to call this when the ThreadLocal<T> instance already\n  // has a value on the current thread.\n  virtual ThreadLocalValueHolderBase* NewValueForCurrentThread() const = 0;\n\n protected:\n  ThreadLocalBase() {}\n  virtual ~ThreadLocalBase() {}\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadLocalBase);\n};\n\n// Maps a thread to a set of ThreadLocals that have values instantiated on that\n// thread and notifies them when the thread exits.  A ThreadLocal instance is\n// expected to persist until all threads it has values on have terminated.\nclass GTEST_API_ ThreadLocalRegistry {\n public:\n  // Registers thread_local_instance as having value on the current thread.\n  // Returns a value that can be used to identify the thread from other threads.\n  static ThreadLocalValueHolderBase* GetValueOnCurrentThread(\n      const ThreadLocalBase* thread_local_instance);\n\n  // Invoked when a ThreadLocal instance is destroyed.\n  static void OnThreadLocalDestroyed(\n      const ThreadLocalBase* thread_local_instance);\n};\n\nclass GTEST_API_ ThreadWithParamBase {\n public:\n  void Join();\n\n protected:\n  class Runnable {\n   public:\n    virtual ~Runnable() {}\n    virtual void Run() = 0;\n  };\n\n  ThreadWithParamBase(Runnable *runnable, Notification* thread_can_start);\n  virtual ~ThreadWithParamBase();\n\n private:\n  AutoHandle thread_;\n};\n\n// Helper class for testing Google Test's multi-threading constructs.\ntemplate <typename T>\nclass ThreadWithParam : public ThreadWithParamBase {\n public:\n  typedef void UserThreadFunc(T);\n\n  ThreadWithParam(UserThreadFunc* func, T param, Notification* thread_can_start)\n      : ThreadWithParamBase(new RunnableImpl(func, param), thread_can_start) {\n  }\n  virtual ~ThreadWithParam() {}\n\n private:\n  class RunnableImpl : public Runnable {\n   public:\n    RunnableImpl(UserThreadFunc* func, T param)\n        : func_(func),\n          param_(param) {\n    }\n    virtual ~RunnableImpl() {}\n    virtual void Run() {\n      func_(param_);\n    }\n\n   private:\n    UserThreadFunc* const func_;\n    const T param_;\n\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(RunnableImpl);\n  };\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadWithParam);\n};\n\n// Implements thread-local storage on Windows systems.\n//\n//   // Thread 1\n//   ThreadLocal<int> tl(100);  // 100 is the default value for each thread.\n//\n//   // Thread 2\n//   tl.set(150);  // Changes the value for thread 2 only.\n//   EXPECT_EQ(150, tl.get());\n//\n//   // Thread 1\n//   EXPECT_EQ(100, tl.get());  // In thread 1, tl has the original value.\n//   tl.set(200);\n//   EXPECT_EQ(200, tl.get());\n//\n// The template type argument T must have a public copy constructor.\n// In addition, the default ThreadLocal constructor requires T to have\n// a public default constructor.\n//\n// The users of a TheadLocal instance have to make sure that all but one\n// threads (including the main one) using that instance have exited before\n// destroying it. Otherwise, the per-thread objects managed for them by the\n// ThreadLocal instance are not guaranteed to be destroyed on all platforms.\n//\n// Google Test only uses global ThreadLocal objects.  That means they\n// will die after main() has returned.  Therefore, no per-thread\n// object managed by Google Test will be leaked as long as all threads\n// using Google Test have exited when main() returns.\ntemplate <typename T>\nclass ThreadLocal : public ThreadLocalBase {\n public:\n  ThreadLocal() : default_factory_(new DefaultValueHolderFactory()) {}\n  explicit ThreadLocal(const T& value)\n      : default_factory_(new InstanceValueHolderFactory(value)) {}\n\n  ~ThreadLocal() { ThreadLocalRegistry::OnThreadLocalDestroyed(this); }\n\n  T* pointer() { return GetOrCreateValue(); }\n  const T* pointer() const { return GetOrCreateValue(); }\n  const T& get() const { return *pointer(); }\n  void set(const T& value) { *pointer() = value; }\n\n private:\n  // Holds a value of T.  Can be deleted via its base class without the caller\n  // knowing the type of T.\n  class ValueHolder : public ThreadLocalValueHolderBase {\n   public:\n    ValueHolder() : value_() {}\n    explicit ValueHolder(const T& value) : value_(value) {}\n\n    T* pointer() { return &value_; }\n\n   private:\n    T value_;\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(ValueHolder);\n  };\n\n\n  T* GetOrCreateValue() const {\n    return static_cast<ValueHolder*>(\n        ThreadLocalRegistry::GetValueOnCurrentThread(this))->pointer();\n  }\n\n  virtual ThreadLocalValueHolderBase* NewValueForCurrentThread() const {\n    return default_factory_->MakeNewHolder();\n  }\n\n  class ValueHolderFactory {\n   public:\n    ValueHolderFactory() {}\n    virtual ~ValueHolderFactory() {}\n    virtual ValueHolder* MakeNewHolder() const = 0;\n\n   private:\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(ValueHolderFactory);\n  };\n\n  class DefaultValueHolderFactory : public ValueHolderFactory {\n   public:\n    DefaultValueHolderFactory() {}\n    virtual ValueHolder* MakeNewHolder() const { return new ValueHolder(); }\n\n   private:\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(DefaultValueHolderFactory);\n  };\n\n  class InstanceValueHolderFactory : public ValueHolderFactory {\n   public:\n    explicit InstanceValueHolderFactory(const T& value) : value_(value) {}\n    virtual ValueHolder* MakeNewHolder() const {\n      return new ValueHolder(value_);\n    }\n\n   private:\n    const T value_;  // The value for each thread.\n\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(InstanceValueHolderFactory);\n  };\n\n  scoped_ptr<ValueHolderFactory> default_factory_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadLocal);\n};\n\n# elif GTEST_HAS_PTHREAD\n\n// MutexBase and Mutex implement mutex on pthreads-based platforms.\nclass MutexBase {\n public:\n  // Acquires this mutex.\n  void Lock() {\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_lock(&mutex_));\n    owner_ = pthread_self();\n    has_owner_ = true;\n  }\n\n  // Releases this mutex.\n  void Unlock() {\n    // Since the lock is being released the owner_ field should no longer be\n    // considered valid. We don't protect writing to has_owner_ here, as it's\n    // the caller's responsibility to ensure that the current thread holds the\n    // mutex when this is called.\n    has_owner_ = false;\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_unlock(&mutex_));\n  }\n\n  // Does nothing if the current thread holds the mutex. Otherwise, crashes\n  // with high probability.\n  void AssertHeld() const {\n    GTEST_CHECK_(has_owner_ && pthread_equal(owner_, pthread_self()))\n        << \"The current thread is not holding the mutex @\" << this;\n  }\n\n  // A static mutex may be used before main() is entered.  It may even\n  // be used before the dynamic initialization stage.  Therefore we\n  // must be able to initialize a static mutex object at link time.\n  // This means MutexBase has to be a POD and its member variables\n  // have to be public.\n public:\n  pthread_mutex_t mutex_;  // The underlying pthread mutex.\n  // has_owner_ indicates whether the owner_ field below contains a valid thread\n  // ID and is therefore safe to inspect (e.g., to use in pthread_equal()). All\n  // accesses to the owner_ field should be protected by a check of this field.\n  // An alternative might be to memset() owner_ to all zeros, but there's no\n  // guarantee that a zero'd pthread_t is necessarily invalid or even different\n  // from pthread_self().\n  bool has_owner_;\n  pthread_t owner_;  // The thread holding the mutex.\n};\n\n// Forward-declares a static mutex.\n#  define GTEST_DECLARE_STATIC_MUTEX_(mutex) \\\n     extern ::testing::internal::MutexBase mutex\n\n// Defines and statically (i.e. at link time) initializes a static mutex.\n#  define GTEST_DEFINE_STATIC_MUTEX_(mutex) \\\n     ::testing::internal::MutexBase mutex = { PTHREAD_MUTEX_INITIALIZER, false, pthread_t() }\n\n// The Mutex class can only be used for mutexes created at runtime. It\n// shares its API with MutexBase otherwise.\nclass Mutex : public MutexBase {\n public:\n  Mutex() {\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_init(&mutex_, NULL));\n    has_owner_ = false;\n  }\n  ~Mutex() {\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_destroy(&mutex_));\n  }\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Mutex);\n};\n\n// We cannot name this class MutexLock because the ctor declaration would\n// conflict with a macro named MutexLock, which is defined on some\n// platforms. That macro is used as a defensive measure to prevent against\n// inadvertent misuses of MutexLock like \"MutexLock(&mu)\" rather than\n// \"MutexLock l(&mu)\".  Hence the typedef trick below.\nclass GTestMutexLock {\n public:\n  explicit GTestMutexLock(MutexBase* mutex)\n      : mutex_(mutex) { mutex_->Lock(); }\n\n  ~GTestMutexLock() { mutex_->Unlock(); }\n\n private:\n  MutexBase* const mutex_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(GTestMutexLock);\n};\n\ntypedef GTestMutexLock MutexLock;\n\n// Helpers for ThreadLocal.\n\n// pthread_key_create() requires DeleteThreadLocalValue() to have\n// C-linkage.  Therefore it cannot be templatized to access\n// ThreadLocal<T>.  Hence the need for class\n// ThreadLocalValueHolderBase.\nclass ThreadLocalValueHolderBase {\n public:\n  virtual ~ThreadLocalValueHolderBase() {}\n};\n\n// Called by pthread to delete thread-local data stored by\n// pthread_setspecific().\nextern \"C\" inline void DeleteThreadLocalValue(void* value_holder) {\n  delete static_cast<ThreadLocalValueHolderBase*>(value_holder);\n}\n\n// Implements thread-local storage on pthreads-based systems.\ntemplate <typename T>\nclass ThreadLocal {\n public:\n  ThreadLocal()\n      : key_(CreateKey()), default_factory_(new DefaultValueHolderFactory()) {}\n  explicit ThreadLocal(const T& value)\n      : key_(CreateKey()),\n        default_factory_(new InstanceValueHolderFactory(value)) {}\n\n  ~ThreadLocal() {\n    // Destroys the managed object for the current thread, if any.\n    DeleteThreadLocalValue(pthread_getspecific(key_));\n\n    // Releases resources associated with the key.  This will *not*\n    // delete managed objects for other threads.\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_key_delete(key_));\n  }\n\n  T* pointer() { return GetOrCreateValue(); }\n  const T* pointer() const { return GetOrCreateValue(); }\n  const T& get() const { return *pointer(); }\n  void set(const T& value) { *pointer() = value; }\n\n private:\n  // Holds a value of type T.\n  class ValueHolder : public ThreadLocalValueHolderBase {\n   public:\n    ValueHolder() : value_() {}\n    explicit ValueHolder(const T& value) : value_(value) {}\n\n    T* pointer() { return &value_; }\n\n   private:\n    T value_;\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(ValueHolder);\n  };\n\n  static pthread_key_t CreateKey() {\n    pthread_key_t key;\n    // When a thread exits, DeleteThreadLocalValue() will be called on\n    // the object managed for that thread.\n    GTEST_CHECK_POSIX_SUCCESS_(\n        pthread_key_create(&key, &DeleteThreadLocalValue));\n    return key;\n  }\n\n  T* GetOrCreateValue() const {\n    ThreadLocalValueHolderBase* const holder =\n        static_cast<ThreadLocalValueHolderBase*>(pthread_getspecific(key_));\n    if (holder != NULL) {\n      return CheckedDowncastToActualType<ValueHolder>(holder)->pointer();\n    }\n\n    ValueHolder* const new_holder = default_factory_->MakeNewHolder();\n    ThreadLocalValueHolderBase* const holder_base = new_holder;\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_setspecific(key_, holder_base));\n    return new_holder->pointer();\n  }\n\n  class ValueHolderFactory {\n   public:\n    ValueHolderFactory() {}\n    virtual ~ValueHolderFactory() {}\n    virtual ValueHolder* MakeNewHolder() const = 0;\n\n   private:\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(ValueHolderFactory);\n  };\n\n  class DefaultValueHolderFactory : public ValueHolderFactory {\n   public:\n    DefaultValueHolderFactory() {}\n    virtual ValueHolder* MakeNewHolder() const { return new ValueHolder(); }\n\n   private:\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(DefaultValueHolderFactory);\n  };\n\n  class InstanceValueHolderFactory : public ValueHolderFactory {\n   public:\n    explicit InstanceValueHolderFactory(const T& value) : value_(value) {}\n    virtual ValueHolder* MakeNewHolder() const {\n      return new ValueHolder(value_);\n    }\n\n   private:\n    const T value_;  // The value for each thread.\n\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(InstanceValueHolderFactory);\n  };\n\n  // A key pthreads uses for looking up per-thread values.\n  const pthread_key_t key_;\n  scoped_ptr<ValueHolderFactory> default_factory_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadLocal);\n};\n\n# endif  // GTEST_HAS_MUTEX_AND_THREAD_LOCAL_\n\n#else  // GTEST_IS_THREADSAFE\n\n// A dummy implementation of synchronization primitives (mutex, lock,\n// and thread-local variable).  Necessary for compiling Google Test where\n// mutex is not supported - using Google Test in multiple threads is not\n// supported on such platforms.\n\nclass Mutex {\n public:\n  Mutex() {}\n  void Lock() {}\n  void Unlock() {}\n  void AssertHeld() const {}\n};\n\n# define GTEST_DECLARE_STATIC_MUTEX_(mutex) \\\n  extern ::testing::internal::Mutex mutex\n\n# define GTEST_DEFINE_STATIC_MUTEX_(mutex) ::testing::internal::Mutex mutex\n\n// We cannot name this class MutexLock because the ctor declaration would\n// conflict with a macro named MutexLock, which is defined on some\n// platforms. That macro is used as a defensive measure to prevent against\n// inadvertent misuses of MutexLock like \"MutexLock(&mu)\" rather than\n// \"MutexLock l(&mu)\".  Hence the typedef trick below.\nclass GTestMutexLock {\n public:\n  explicit GTestMutexLock(Mutex*) {}  // NOLINT\n};\n\ntypedef GTestMutexLock MutexLock;\n\ntemplate <typename T>\nclass ThreadLocal {\n public:\n  ThreadLocal() : value_() {}\n  explicit ThreadLocal(const T& value) : value_(value) {}\n  T* pointer() { return &value_; }\n  const T* pointer() const { return &value_; }\n  const T& get() const { return value_; }\n  void set(const T& value) { value_ = value; }\n private:\n  T value_;\n};\n\n#endif  // GTEST_IS_THREADSAFE\n\n// Returns the number of threads running in the process, or 0 to indicate that\n// we cannot detect it.\nGTEST_API_ size_t GetThreadCount();\n\n// Passing non-POD classes through ellipsis (...) crashes the ARM\n// compiler and generates a warning in Sun Studio.  The Nokia Symbian\n// and the IBM XL C/C++ compiler try to instantiate a copy constructor\n// for objects passed through ellipsis (...), failing for uncopyable\n// objects.  We define this to ensure that only POD is passed through\n// ellipsis on these systems.\n#if defined(__SYMBIAN32__) || defined(__IBMCPP__) || defined(__SUNPRO_CC)\n// We lose support for NULL detection where the compiler doesn't like\n// passing non-POD classes through ellipsis (...).\n# define GTEST_ELLIPSIS_NEEDS_POD_ 1\n#else\n# define GTEST_CAN_COMPARE_NULL 1\n#endif\n\n// The Nokia Symbian and IBM XL C/C++ compilers cannot decide between\n// const T& and const T* in a function template.  These compilers\n// _can_ decide between class template specializations for T and T*,\n// so a tr1::type_traits-like is_pointer works.\n#if defined(__SYMBIAN32__) || defined(__IBMCPP__)\n# define GTEST_NEEDS_IS_POINTER_ 1\n#endif\n\ntemplate <bool bool_value>\nstruct bool_constant {\n  typedef bool_constant<bool_value> type;\n  static const bool value = bool_value;\n};\ntemplate <bool bool_value> const bool bool_constant<bool_value>::value;\n\ntypedef bool_constant<false> false_type;\ntypedef bool_constant<true> true_type;\n\ntemplate <typename T>\nstruct is_pointer : public false_type {};\n\ntemplate <typename T>\nstruct is_pointer<T*> : public true_type {};\n\ntemplate <typename Iterator>\nstruct IteratorTraits {\n  typedef typename Iterator::value_type value_type;\n};\n\ntemplate <typename T>\nstruct IteratorTraits<T*> {\n  typedef T value_type;\n};\n\ntemplate <typename T>\nstruct IteratorTraits<const T*> {\n  typedef T value_type;\n};\n\n#if GTEST_OS_WINDOWS\n# define GTEST_PATH_SEP_ \"\\\\\"\n# define GTEST_HAS_ALT_PATH_SEP_ 1\n// The biggest signed integer type the compiler supports.\ntypedef __int64 BiggestInt;\n#else\n# define GTEST_PATH_SEP_ \"/\"\n# define GTEST_HAS_ALT_PATH_SEP_ 0\ntypedef long long BiggestInt;  // NOLINT\n#endif  // GTEST_OS_WINDOWS\n\n// Utilities for char.\n\n// isspace(int ch) and friends accept an unsigned char or EOF.  char\n// may be signed, depending on the compiler (or compiler flags).\n// Therefore we need to cast a char to unsigned char before calling\n// isspace(), etc.\n\ninline bool IsAlpha(char ch) {\n  return isalpha(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsAlNum(char ch) {\n  return isalnum(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsDigit(char ch) {\n  return isdigit(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsLower(char ch) {\n  return islower(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsSpace(char ch) {\n  return isspace(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsUpper(char ch) {\n  return isupper(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsXDigit(char ch) {\n  return isxdigit(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsXDigit(wchar_t ch) {\n  const unsigned char low_byte = static_cast<unsigned char>(ch);\n  return ch == low_byte && isxdigit(low_byte) != 0;\n}\n\ninline char ToLower(char ch) {\n  return static_cast<char>(tolower(static_cast<unsigned char>(ch)));\n}\ninline char ToUpper(char ch) {\n  return static_cast<char>(toupper(static_cast<unsigned char>(ch)));\n}\n\ninline std::string StripTrailingSpaces(std::string str) {\n  std::string::iterator it = str.end();\n  while (it != str.begin() && IsSpace(*--it))\n    it = str.erase(it);\n  return str;\n}\n\n// The testing::internal::posix namespace holds wrappers for common\n// POSIX functions.  These wrappers hide the differences between\n// Windows/MSVC and POSIX systems.  Since some compilers define these\n// standard functions as macros, the wrapper cannot have the same name\n// as the wrapped function.\n\nnamespace posix {\n\n// Functions with a different name on Windows.\n\n#if GTEST_OS_WINDOWS\n\ntypedef struct _stat StatStruct;\n\n# ifdef __BORLANDC__\ninline int IsATTY(int fd) { return isatty(fd); }\ninline int StrCaseCmp(const char* s1, const char* s2) {\n  return stricmp(s1, s2);\n}\ninline char* StrDup(const char* src) { return strdup(src); }\n# else  // !__BORLANDC__\n#  if GTEST_OS_WINDOWS_MOBILE\ninline int IsATTY(int /* fd */) { return 0; }\n#  else\ninline int IsATTY(int fd) { return _isatty(fd); }\n#  endif  // GTEST_OS_WINDOWS_MOBILE\ninline int StrCaseCmp(const char* s1, const char* s2) {\n  return _stricmp(s1, s2);\n}\ninline char* StrDup(const char* src) { return _strdup(src); }\n# endif  // __BORLANDC__\n\n# if GTEST_OS_WINDOWS_MOBILE\ninline int FileNo(FILE* file) { return reinterpret_cast<int>(_fileno(file)); }\n// Stat(), RmDir(), and IsDir() are not needed on Windows CE at this\n// time and thus not defined there.\n# else\ninline int FileNo(FILE* file) { return _fileno(file); }\ninline int Stat(const char* path, StatStruct* buf) { return _stat(path, buf); }\ninline int RmDir(const char* dir) { return _rmdir(dir); }\ninline bool IsDir(const StatStruct& st) {\n  return (_S_IFDIR & st.st_mode) != 0;\n}\n# endif  // GTEST_OS_WINDOWS_MOBILE\n\n#else\n\ntypedef struct stat StatStruct;\n\ninline int FileNo(FILE* file) { return fileno(file); }\ninline int IsATTY(int fd) { return isatty(fd); }\ninline int Stat(const char* path, StatStruct* buf) { return stat(path, buf); }\ninline int StrCaseCmp(const char* s1, const char* s2) {\n  return strcasecmp(s1, s2);\n}\ninline char* StrDup(const char* src) { return strdup(src); }\ninline int RmDir(const char* dir) { return rmdir(dir); }\ninline bool IsDir(const StatStruct& st) { return S_ISDIR(st.st_mode); }\n\n#endif  // GTEST_OS_WINDOWS\n\n// Functions deprecated by MSVC 8.0.\n\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(4996 /* deprecated function */)\n\ninline const char* StrNCpy(char* dest, const char* src, size_t n) {\n  return strncpy(dest, src, n);\n}\n\n// ChDir(), FReopen(), FDOpen(), Read(), Write(), Close(), and\n// StrError() aren't needed on Windows CE at this time and thus not\n// defined there.\n\n#if !GTEST_OS_WINDOWS_MOBILE && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT\ninline int ChDir(const char* dir) { return chdir(dir); }\n#endif\ninline FILE* FOpen(const char* path, const char* mode) {\n  return fopen(path, mode);\n}\n#if !GTEST_OS_WINDOWS_MOBILE\ninline FILE *FReopen(const char* path, const char* mode, FILE* stream) {\n  return freopen(path, mode, stream);\n}\ninline FILE* FDOpen(int fd, const char* mode) { return fdopen(fd, mode); }\n#endif\ninline int FClose(FILE* fp) { return fclose(fp); }\n#if !GTEST_OS_WINDOWS_MOBILE\ninline int Read(int fd, void* buf, unsigned int count) {\n  return static_cast<int>(read(fd, buf, count));\n}\ninline int Write(int fd, const void* buf, unsigned int count) {\n  return static_cast<int>(write(fd, buf, count));\n}\ninline int Close(int fd) { return close(fd); }\ninline const char* StrError(int errnum) { return strerror(errnum); }\n#endif\ninline const char* GetEnv(const char* name) {\n#if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_WINDOWS_PHONE | GTEST_OS_WINDOWS_RT\n  // We are on Windows CE, which has no environment variables.\n  static_cast<void>(name);  // To prevent 'unused argument' warning.\n  return NULL;\n#elif defined(__BORLANDC__) || defined(__SunOS_5_8) || defined(__SunOS_5_9)\n  // Environment variables which we programmatically clear will be set to the\n  // empty string rather than unset (NULL).  Handle that case.\n  const char* const env = getenv(name);\n  return (env != NULL && env[0] != '\\0') ? env : NULL;\n#else\n  return getenv(name);\n#endif\n}\n\nGTEST_DISABLE_MSC_WARNINGS_POP_()\n\n#if GTEST_OS_WINDOWS_MOBILE\n// Windows CE has no C library. The abort() function is used in\n// several places in Google Test. This implementation provides a reasonable\n// imitation of standard behaviour.\nvoid Abort();\n#else\ninline void Abort() { abort(); }\n#endif  // GTEST_OS_WINDOWS_MOBILE\n\n}  // namespace posix\n\n// MSVC \"deprecates\" snprintf and issues warnings wherever it is used.  In\n// order to avoid these warnings, we need to use _snprintf or _snprintf_s on\n// MSVC-based platforms.  We map the GTEST_SNPRINTF_ macro to the appropriate\n// function in order to achieve that.  We use macro definition here because\n// snprintf is a variadic function.\n#if _MSC_VER >= 1400 && !GTEST_OS_WINDOWS_MOBILE\n// MSVC 2005 and above support variadic macros.\n# define GTEST_SNPRINTF_(buffer, size, format, ...) \\\n     _snprintf_s(buffer, size, size, format, __VA_ARGS__)\n#elif defined(_MSC_VER)\n// Windows CE does not define _snprintf_s and MSVC prior to 2005 doesn't\n// complain about _snprintf.\n# define GTEST_SNPRINTF_ _snprintf\n#else\n# define GTEST_SNPRINTF_ snprintf\n#endif\n\n// The maximum number a BiggestInt can represent.  This definition\n// works no matter BiggestInt is represented in one's complement or\n// two's complement.\n//\n// We cannot rely on numeric_limits in STL, as __int64 and long long\n// are not part of standard C++ and numeric_limits doesn't need to be\n// defined for them.\nconst BiggestInt kMaxBiggestInt =\n    ~(static_cast<BiggestInt>(1) << (8*sizeof(BiggestInt) - 1));\n\n// This template class serves as a compile-time function from size to\n// type.  It maps a size in bytes to a primitive type with that\n// size. e.g.\n//\n//   TypeWithSize<4>::UInt\n//\n// is typedef-ed to be unsigned int (unsigned integer made up of 4\n// bytes).\n//\n// Such functionality should belong to STL, but I cannot find it\n// there.\n//\n// Google Test uses this class in the implementation of floating-point\n// comparison.\n//\n// For now it only handles UInt (unsigned int) as that's all Google Test\n// needs.  Other types can be easily added in the future if need\n// arises.\ntemplate <size_t size>\nclass TypeWithSize {\n public:\n  // This prevents the user from using TypeWithSize<N> with incorrect\n  // values of N.\n  typedef void UInt;\n};\n\n// The specialization for size 4.\ntemplate <>\nclass TypeWithSize<4> {\n public:\n  // unsigned int has size 4 in both gcc and MSVC.\n  //\n  // As base/basictypes.h doesn't compile on Windows, we cannot use\n  // uint32, uint64, and etc here.\n  typedef int Int;\n  typedef unsigned int UInt;\n};\n\n// The specialization for size 8.\ntemplate <>\nclass TypeWithSize<8> {\n public:\n#if GTEST_OS_WINDOWS\n  typedef __int64 Int;\n  typedef unsigned __int64 UInt;\n#else\n  typedef long long Int;  // NOLINT\n  typedef unsigned long long UInt;  // NOLINT\n#endif  // GTEST_OS_WINDOWS\n};\n\n// Integer types of known sizes.\ntypedef TypeWithSize<4>::Int Int32;\ntypedef TypeWithSize<4>::UInt UInt32;\ntypedef TypeWithSize<8>::Int Int64;\ntypedef TypeWithSize<8>::UInt UInt64;\ntypedef TypeWithSize<8>::Int TimeInMillis;  // Represents time in milliseconds.\n\n// Utilities for command line flags and environment variables.\n\n// Macro for referencing flags.\n#if !defined(GTEST_FLAG)\n# define GTEST_FLAG(name) FLAGS_gtest_##name\n#endif  // !defined(GTEST_FLAG)\n\n#if !defined(GTEST_USE_OWN_FLAGFILE_FLAG_)\n# define GTEST_USE_OWN_FLAGFILE_FLAG_ 1\n#endif  // !defined(GTEST_USE_OWN_FLAGFILE_FLAG_)\n\n#if !defined(GTEST_DECLARE_bool_)\n# define GTEST_FLAG_SAVER_ ::testing::internal::GTestFlagSaver\n\n// Macros for declaring flags.\n# define GTEST_DECLARE_bool_(name) GTEST_API_ extern bool GTEST_FLAG(name)\n# define GTEST_DECLARE_int32_(name) \\\n    GTEST_API_ extern ::testing::internal::Int32 GTEST_FLAG(name)\n#define GTEST_DECLARE_string_(name) \\\n    GTEST_API_ extern ::std::string GTEST_FLAG(name)\n\n// Macros for defining flags.\n#define GTEST_DEFINE_bool_(name, default_val, doc) \\\n    GTEST_API_ bool GTEST_FLAG(name) = (default_val)\n#define GTEST_DEFINE_int32_(name, default_val, doc) \\\n    GTEST_API_ ::testing::internal::Int32 GTEST_FLAG(name) = (default_val)\n#define GTEST_DEFINE_string_(name, default_val, doc) \\\n    GTEST_API_ ::std::string GTEST_FLAG(name) = (default_val)\n\n#endif  // !defined(GTEST_DECLARE_bool_)\n\n// Thread annotations\n#if !defined(GTEST_EXCLUSIVE_LOCK_REQUIRED_)\n# define GTEST_EXCLUSIVE_LOCK_REQUIRED_(locks)\n# define GTEST_LOCK_EXCLUDED_(locks)\n#endif  // !defined(GTEST_EXCLUSIVE_LOCK_REQUIRED_)\n\n// Parses 'str' for a 32-bit signed integer.  If successful, writes the result\n// to *value and returns true; otherwise leaves *value unchanged and returns\n// false.\n// TODO(chandlerc): Find a better way to refactor flag and environment parsing\n// out of both gtest-port.cc and gtest.cc to avoid exporting this utility\n// function.\nbool ParseInt32(const Message& src_text, const char* str, Int32* value);\n\n// Parses a bool/Int32/string from the environment variable\n// corresponding to the given Google Test flag.\nbool BoolFromGTestEnv(const char* flag, bool default_val);\nGTEST_API_ Int32 Int32FromGTestEnv(const char* flag, Int32 default_val);\nstd::string StringFromGTestEnv(const char* flag, const char* default_val);\n\n}  // namespace internal\n}  // namespace testing\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_\n"}}, "reports": [{"events": [{"location": {"col": 8, "file": 4, "line": 41}, "message": "'DenseMapPair' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "d73644802c93de2a94351d2fd5b6b222", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 4, "line": 737}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 4, "line": 737}, "message": "'DenseMap' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "efbf0067c6a34fb9f2b2598a21d030da", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 14, "line": 31}, "message": "'SuperBlock' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/MSF/MSFCommon.h", "reportHash": "5a98f78e05fe10cc10a491a88f700745", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 14, "line": 51}, "message": "'MSFLayout' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/MSF/MSFCommon.h", "reportHash": "8e92672cdb564374f239341f272fcbc4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 15, "line": 37}, "message": "'MappedBlockStream' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/MSF/MappedBlockStream.h", "reportHash": "8b1e8a1357cbb0dd9a584afdb9694711", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 15, "line": 105}, "message": "'WritableMappedBlockStream' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/DebugInfo/MSF/MappedBlockStream.h", "reportHash": "3be4bee06ea6ef89f9081f845409f25a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 22, "line": 44}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 22, "line": 44}, "message": "'BinaryStreamRefBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BinaryStreamRef.h", "reportHash": "e7c51acabf05c181d1c2f00908d122ae", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 22, "line": 44}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 22, "line": 44}, "message": "'BinaryStreamRefBase<RefType, StreamType>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BinaryStreamRef.h", "reportHash": "1bbe97ce3c4b81848b718773c5ce28de", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 22, "line": 175}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 22, "line": 175}, "message": "'BinaryStreamRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BinaryStreamRef.h", "reportHash": "3cc6a646991e5cd52cf51707de1d34f8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 22, "line": 250}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 22, "line": 250}, "message": "'WritableBinaryStreamRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BinaryStreamRef.h", "reportHash": "c99cb48ec049149d582aa98a22119911", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 32, "line": 149}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 32, "line": 149}, "message": "'TempDir' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Testing/Support/SupportHelpers.h", "reportHash": "a7af8ccb17ef2241a35729cfd2e4543d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 32, "line": 194}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 32, "line": 194}, "message": "'TempLink' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Testing/Support/SupportHelpers.h", "reportHash": "4c9ed84e7cdf237b10c12a2d1e798120", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 33, "line": 29}, "message": "'DiscontiguousStream' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/unittests/DebugInfo/MSF/MappedBlockStreamTest.cpp", "reportHash": "ccc5a8077bacaf8c55bea4ff0e46ba2d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 626}, "message": "'ReturnNullAction' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-actions.h", "reportHash": "0f54adecd425cc4edd9f9c7300adec1f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 644}, "message": "'ReturnVoidAction' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-actions.h", "reportHash": "29fa28d04e7f79bc99857439877f447e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 18, "file": 35, "line": 85}, "message": "'Cardinality' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-cardinalities.h", "reportHash": "f19216091eb4c540b5354bafcaf4cee8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 510}, "message": "'ExcessiveArg' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-generated-actions.h", "reportHash": "a9f3d856c8c2999019383e63c458ef37", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 2131}, "message": "'AdlTag' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-generated-actions.h", "reportHash": "f454d5343f037224c9af48e4af26c610", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 37, "line": 145}, "message": "'MatcherInterface' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "reportHash": "6d9590de11516b00256c7247220b3d2c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 37, "line": 321}, "message": "'Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "reportHash": "523dbbb1c1fea07e08e5dd2fb9f7cd4d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 18, "file": 37, "line": 341}, "message": "'Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "reportHash": "cbd2f5c69bd7a550180d7b3f825e1dd3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 18, "file": 37, "line": 358}, "message": "'Matcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "reportHash": "1e01f5495a2c51642f51b72796da92a1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 37, "line": 979}, "message": "'IsNullMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "reportHash": "e0250f20d95c52ad090d283da3662182", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 37, "line": 999}, "message": "'NotNullMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "reportHash": "568a2251cef2ee0ea8faadca5bd4ec91", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 37, "line": 2611}, "message": "'LessComparator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "reportHash": "f4b481b2767b00d811cff8365faeb994", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 38, "line": 247}, "message": "'UntypedOnCallSpecBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-spec-builders.h", "reportHash": "0ba069d1fd2e3fd5053ee0fd482e1461", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 38, "line": 530}, "message": "'Less' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-spec-builders.h", "reportHash": "4810c10eef985713f0c5262dfc6f1f70", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 38, "line": 565}, "message": "'ExpectationSet' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-spec-builders.h", "reportHash": "be502e36ed7b869a3a626880006486be", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 18, "file": 38, "line": 621}, "message": "'Sequence' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-spec-builders.h", "reportHash": "06ca8b51c90083a44b68e2bd7be06f88", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 39, "line": 507}, "message": "'BooleanConstant' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/internal/gmock-internal-utils.h", "reportHash": "793a1c1ea5d3d8d51fe6d45a1f38778e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 18, "file": 40, "line": 47}, "message": "'TestPartResult' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest-test-part.h", "reportHash": "ec34a67e9384ff24b2bbfb5c48eaf362", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 41, "line": 486}, "message": "'TestProperty' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest.h", "reportHash": "ff7128bbef7afa4c68cf9c316af71264", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 41, "line": 1044}, "message": "'EmptyTestEventListener' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest.h", "reportHash": "0b356b3b17ad2ce248ee5f3ae98067d6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 42, "line": 52}, "message": "'RawStreamProxy' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/custom/raw-ostream.h", "reportHash": "3f850932efbb2945144be57d8c7fd7b5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 30, "file": 42, "line": 64}, "message": "'ConvertibleTo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/custom/raw-ostream.h", "reportHash": "1774ff347bcb2327d624e4315403ccbb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 43, "line": 148}, "message": "'DefaultDeathTestFactory' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-death-test-internal.h", "reportHash": "2d28fedb0431c931d9d02050982679dc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 44, "line": 482}, "message": "'TestFactoryImpl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-internal.h", "reportHash": "323963127e242660c27c07cd26f461a9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 18, "file": 44, "line": 548}, "message": "'TypedTestCasePState' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-internal.h", "reportHash": "d161972c2dc7480272f41e378a783e76", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 44, "line": 1022}, "message": "'RelationToSourceReference' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-internal.h", "reportHash": "a42683d03fed7db76e6e96b8262f8575", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 44, "line": 1023}, "message": "'RelationToSourceCopy' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-internal.h", "reportHash": "86037534cb7eabc4ea2689aa7dcc825a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 45, "line": 89}, "message": "'linked_ptr_internal' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-linked_ptr.h", "reportHash": "b04df7e3ee2cc2797d0bd53b72df95e6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 46, "line": 1933}, "message": "'MutexBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-port.h", "reportHash": "36638230e5e939eb105d83f055325e08", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 46, "line": 2222}, "message": "'is_pointer' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-port.h", "reportHash": "5b350ad8cd3797fcd14efc8864c7189d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 46, "line": 2225}, "message": "'is_pointer' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-port.h", "reportHash": "be2d177318033a5f05d6ec49c5afb460", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
