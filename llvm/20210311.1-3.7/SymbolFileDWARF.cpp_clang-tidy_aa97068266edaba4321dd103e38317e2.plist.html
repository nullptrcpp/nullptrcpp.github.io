<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"54": {"id": 54, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Highlighter.h", "content": "//===-- Highlighter.h -------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_CORE_HIGHLIGHTER_H\n#define LLDB_CORE_HIGHLIGHTER_H\n\n#include <utility>\n#include <vector>\n\n#include \"lldb/Utility/Stream.h\"\n#include \"lldb/lldb-enumerations.h\"\n#include \"llvm/ADT/StringRef.h\"\n\nnamespace lldb_private {\n\n/// Represents style that the highlighter should apply to the given source code.\n/// Stores information about how every kind of token should be annotated.\nstruct HighlightStyle {\n\n  /// A pair of strings that should be placed around a certain token. Usually\n  /// stores color codes in these strings (the suffix string is often used for\n  /// resetting the terminal attributes back to normal).\n  class ColorStyle {\n    std::string m_prefix;\n    std::string m_suffix;\n\n  public:\n    ColorStyle() = default;\n    ColorStyle(llvm::StringRef prefix, llvm::StringRef suffix) {\n      Set(prefix, suffix);\n    }\n\n    /// Applies this style to the given value.\n    /// \\param s\n    ///     The stream to which the result should be appended.\n    /// \\param value\n    ///     The value that we should place our strings around.\n    void Apply(Stream &s, llvm::StringRef value) const;\n\n    /// Sets the prefix and suffix strings.\n    void Set(llvm::StringRef prefix, llvm::StringRef suffix);\n  };\n\n  /// The style for the token which is below the cursor of the user. Note that\n  /// this style is overwritten by the SourceManager with the values of\n  /// stop-show-column-ansi-prefix/stop-show-column-ansi-suffix.\n  ColorStyle selected;\n\n  /// Matches identifiers to variable or functions.\n  ColorStyle identifier;\n  /// Matches any string or character literals in the language: \"foo\" or 'f'\n  ColorStyle string_literal;\n  /// Matches scalar value literals like '42' or '0.1'.\n  ColorStyle scalar_literal;\n  /// Matches all reserved keywords in the language.\n  ColorStyle keyword;\n  /// Matches any comments in the language.\n  ColorStyle comment;\n  /// Matches commas: ','\n  ColorStyle comma;\n  /// Matches one colon: ':'\n  ColorStyle colon;\n  /// Matches any semicolon: ';'\n  ColorStyle semicolons;\n  /// Matches operators like '+', '-', '%', '&', '='\n  ColorStyle operators;\n\n  /// Matches '{' or '}'\n  ColorStyle braces;\n  /// Matches '[' or ']'\n  ColorStyle square_brackets;\n  /// Matches '(' or ')'\n  ColorStyle parentheses;\n\n  // C language specific options\n\n  /// Matches directives to a preprocessor (if the language has any).\n  ColorStyle pp_directive;\n\n  /// Returns a HighlightStyle that is based on vim's default highlight style.\n  static HighlightStyle MakeVimStyle();\n};\n\n/// Annotates source code with color attributes.\nclass Highlighter {\npublic:\n  Highlighter() = default;\n  virtual ~Highlighter() = default;\n  Highlighter(const Highlighter &) = delete;\n  const Highlighter &operator=(const Highlighter &) = delete;\n\n  /// Returns a human readable name for the selected highlighter.\n  virtual llvm::StringRef GetName() const = 0;\n\n  /// Highlights the given line\n  /// \\param options\n  ///     The highlight options.\n  /// \\param line\n  ///     The user supplied line that needs to be highlighted.\n  /// \\param cursor_pos\n  ///     The cursor position of the user in this line, starting at 0 (which\n  ///     means the cursor is on the first character in 'line').\n  /// \\param previous_lines\n  ///     Any previous lines the user has written which we should only use\n  ///     for getting the context of the Highlighting right.\n  /// \\param s\n  ///     The stream to which the highlighted version of the user string should\n  ///     be written.\n  virtual void Highlight(const HighlightStyle &options, llvm::StringRef line,\n                         llvm::Optional<size_t> cursor_pos,\n                         llvm::StringRef previous_lines, Stream &s) const = 0;\n\n  /// Utility method for calling Highlight without a stream.\n  std::string Highlight(const HighlightStyle &options, llvm::StringRef line,\n                        llvm::Optional<size_t> cursor_pos,\n                        llvm::StringRef previous_lines = \"\") const;\n};\n\n/// A default highlighter that only highlights the user cursor, but doesn't\n/// do any other highlighting.\nclass DefaultHighlighter : public Highlighter {\npublic:\n  llvm::StringRef GetName() const override { return \"none\"; }\n\n  void Highlight(const HighlightStyle &options, llvm::StringRef line,\n                 llvm::Optional<size_t> cursor_pos,\n                 llvm::StringRef previous_lines, Stream &s) const override;\n};\n\n/// Manages the available highlighters.\nclass HighlighterManager {\n  DefaultHighlighter m_default;\n\npublic:\n  /// Queries all known highlighter for one that can highlight some source code.\n  /// \\param language_type\n  ///     The language type that the caller thinks the source code was given in.\n  /// \\param path\n  ///     The path to the file the source code is from. Used as a fallback when\n  ///     the user can't provide a language.\n  /// \\return\n  ///     The highlighter that wants to highlight the source code. Could be an\n  ///     empty highlighter that does nothing.\n  const Highlighter &getHighlighterFor(lldb::LanguageType language_type,\n                                       llvm::StringRef path) const;\n  const Highlighter &getDefaultHighlighter() const { return m_default; }\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_CORE_HIGHLIGHTER_H\n"}, "62": {"id": 62, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/DataFormatters/DumpValueObjectOptions.h", "content": "//===-- DumpValueObjectOptions.h --------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_DATAFORMATTERS_DUMPVALUEOBJECTOPTIONS_H\n#define LLDB_DATAFORMATTERS_DUMPVALUEOBJECTOPTIONS_H\n\n#include <string>\n\n#include \"lldb/lldb-private.h\"\n#include \"lldb/lldb-public.h\"\n\n#include <functional>\n#include <string>\n\nnamespace lldb_private {\n\nclass DumpValueObjectOptions {\npublic:\n  struct PointerDepth {\n    enum class Mode { Always, Default, Never } m_mode;\n    uint32_t m_count;\n\n    PointerDepth operator--() const {\n      if (m_count > 0)\n        return PointerDepth{m_mode, m_count - 1};\n      return PointerDepth{m_mode, m_count};\n    }\n\n    bool CanAllowExpansion() const;\n  };\n\n  struct PointerAsArraySettings {\n    size_t m_element_count;\n    size_t m_base_element;\n    size_t m_stride;\n\n    PointerAsArraySettings()\n        : m_element_count(0), m_base_element(0), m_stride() {}\n\n    PointerAsArraySettings(size_t elem_count, size_t base_elem = 0,\n                           size_t stride = 1)\n        : m_element_count(elem_count), m_base_element(base_elem),\n          m_stride(stride) {}\n\n    operator bool() { return m_element_count > 0; }\n  };\n\n  typedef std::function<bool(ConstString, ConstString,\n                             const DumpValueObjectOptions &, Stream &)>\n      DeclPrintingHelper;\n\n  static const DumpValueObjectOptions DefaultOptions() {\n    static DumpValueObjectOptions g_default_options;\n\n    return g_default_options;\n  }\n\n  DumpValueObjectOptions();\n\n  DumpValueObjectOptions(const DumpValueObjectOptions &rhs) = default;\n\n  DumpValueObjectOptions(ValueObject &valobj);\n\n  DumpValueObjectOptions &\n  SetMaximumPointerDepth(PointerDepth depth = {PointerDepth::Mode::Never, 0});\n\n  DumpValueObjectOptions &SetMaximumDepth(uint32_t depth = 0);\n\n  DumpValueObjectOptions &SetDeclPrintingHelper(DeclPrintingHelper helper);\n\n  DumpValueObjectOptions &SetShowTypes(bool show = false);\n\n  DumpValueObjectOptions &SetShowLocation(bool show = false);\n\n  DumpValueObjectOptions &SetUseObjectiveC(bool use = false);\n\n  DumpValueObjectOptions &SetShowSummary(bool show = true);\n\n  DumpValueObjectOptions &\n  SetUseDynamicType(lldb::DynamicValueType dyn = lldb::eNoDynamicValues);\n\n  DumpValueObjectOptions &SetUseSyntheticValue(bool use_synthetic = true);\n\n  DumpValueObjectOptions &SetScopeChecked(bool check = true);\n\n  DumpValueObjectOptions &SetFlatOutput(bool flat = false);\n\n  DumpValueObjectOptions &SetOmitSummaryDepth(uint32_t depth = 0);\n\n  DumpValueObjectOptions &SetIgnoreCap(bool ignore = false);\n\n  DumpValueObjectOptions &SetRawDisplay();\n\n  DumpValueObjectOptions &SetFormat(lldb::Format format = lldb::eFormatDefault);\n\n  DumpValueObjectOptions &\n  SetSummary(lldb::TypeSummaryImplSP summary = lldb::TypeSummaryImplSP());\n\n  DumpValueObjectOptions &SetRootValueObjectName(const char *name = nullptr);\n\n  DumpValueObjectOptions &SetHideRootType(bool hide_root_type = false);\n\n  DumpValueObjectOptions &SetHideName(bool hide_name = false);\n\n  DumpValueObjectOptions &SetHideValue(bool hide_value = false);\n\n  DumpValueObjectOptions &SetHidePointerValue(bool hide = false);\n\n  DumpValueObjectOptions &SetVariableFormatDisplayLanguage(\n      lldb::LanguageType lang = lldb::eLanguageTypeUnknown);\n\n  DumpValueObjectOptions &SetRunValidator(bool run = true);\n\n  DumpValueObjectOptions &SetUseTypeDisplayName(bool dis = false);\n\n  DumpValueObjectOptions &SetAllowOnelinerMode(bool oneliner = false);\n\n  DumpValueObjectOptions &SetRevealEmptyAggregates(bool reveal = true);\n\n  DumpValueObjectOptions &SetElementCount(uint32_t element_count = 0);\n\n  DumpValueObjectOptions &\n  SetPointerAsArray(const PointerAsArraySettings &ptr_array);\n\n  uint32_t m_max_depth = UINT32_MAX;\n  lldb::DynamicValueType m_use_dynamic = lldb::eNoDynamicValues;\n  uint32_t m_omit_summary_depth = 0;\n  lldb::Format m_format = lldb::eFormatDefault;\n  lldb::TypeSummaryImplSP m_summary_sp;\n  std::string m_root_valobj_name;\n  lldb::LanguageType m_varformat_language = lldb::eLanguageTypeUnknown;\n  PointerDepth m_max_ptr_depth;\n  DeclPrintingHelper m_decl_printing_helper;\n  PointerAsArraySettings m_pointer_as_array;\n  bool m_use_synthetic : 1;\n  bool m_scope_already_checked : 1;\n  bool m_flat_output : 1;\n  bool m_ignore_cap : 1;\n  bool m_show_types : 1;\n  bool m_show_location : 1;\n  bool m_use_objc : 1;\n  bool m_hide_root_type : 1;\n  bool m_hide_name : 1;\n  bool m_hide_value : 1;\n  bool m_run_validator : 1;\n  bool m_use_type_display_name : 1;\n  bool m_allow_oneliner_mode : 1;\n  bool m_hide_pointer_value : 1;\n  bool m_reveal_empty_aggregates : 1;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_DATAFORMATTERS_DUMPVALUEOBJECTOPTIONS_H\n"}, "68": {"id": 68, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Interpreter/Property.h", "content": "//===-- Property.h ----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_INTERPRETER_PROPERTY_H\n#define LLDB_INTERPRETER_PROPERTY_H\n\n#include \"lldb/Interpreter/OptionValue.h\"\n#include \"lldb/Utility/ConstString.h\"\n#include \"lldb/Utility/Flags.h\"\n#include \"lldb/lldb-defines.h\"\n#include \"lldb/lldb-private-types.h\"\n\n#include <string>\n\nnamespace lldb_private {\n\n// A structure that can be used to create a global table for all properties.\n// Property class instances can be constructed using one of these.\nstruct PropertyDefinition {\n  const char *name;\n  OptionValue::Type type;\n  bool global; // false == this setting is a global setting by default\n  uintptr_t default_uint_value;\n  const char *default_cstr_value;\n  OptionEnumValues enum_values;\n  const char *description;\n};\n\nusing PropertyDefinitions = llvm::ArrayRef<PropertyDefinition>;\n\nclass Property {\npublic:\n  Property(const PropertyDefinition &definition);\n\n  Property(ConstString name, ConstString desc, bool is_global,\n           const lldb::OptionValueSP &value_sp);\n\n  llvm::StringRef GetName() const { return m_name.GetStringRef(); }\n  llvm::StringRef GetDescription() const {\n    return m_description.GetStringRef();\n  }\n\n  const lldb::OptionValueSP &GetValue() const { return m_value_sp; }\n\n  void SetOptionValue(const lldb::OptionValueSP &value_sp) {\n    m_value_sp = value_sp;\n  }\n\n  bool IsValid() const { return (bool)m_value_sp; }\n\n  bool IsGlobal() const { return m_is_global; }\n\n  void Dump(const ExecutionContext *exe_ctx, Stream &strm,\n            uint32_t dump_mask) const;\n\n  bool DumpQualifiedName(Stream &strm) const;\n\n  void DumpDescription(CommandInterpreter &interpreter, Stream &strm,\n                       uint32_t output_width,\n                       bool display_qualified_name) const;\n\n  void SetValueChangedCallback(std::function<void()> callback);\n\nprotected:\n  ConstString m_name;\n  ConstString m_description;\n  lldb::OptionValueSP m_value_sp;\n  bool m_is_global;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_INTERPRETER_PROPERTY_H\n"}, "103": {"id": 103, "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/ExpressionParser/Clang/ClangASTImporter.h", "content": "//===-- ClangASTImporter.h --------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SOURCE_PLUGINS_EXPRESSIONPARSER_CLANG_CLANGASTIMPORTER_H\n#define LLDB_SOURCE_PLUGINS_EXPRESSIONPARSER_CLANG_CLANGASTIMPORTER_H\n\n#include <map>\n#include <memory>\n#include <set>\n#include <vector>\n\n#include \"clang/AST/ASTImporter.h\"\n#include \"clang/AST/CharUnits.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/Basic/FileManager.h\"\n#include \"clang/Basic/FileSystemOptions.h\"\n\n#include \"lldb/Host/FileSystem.h\"\n#include \"lldb/Symbol/CompilerDeclContext.h\"\n#include \"lldb/Utility/LLDBAssert.h\"\n#include \"lldb/lldb-types.h\"\n\n#include \"Plugins/ExpressionParser/Clang/CxxModuleHandler.h\"\n\n#include \"llvm/ADT/DenseMap.h\"\n\nnamespace lldb_private {\n\nclass ClangASTMetadata;\nclass TypeSystemClang;\n\n/// Manages and observes all Clang AST node importing in LLDB.\n///\n/// The ClangASTImporter takes care of two things:\n///\n/// 1. Keeps track of all ASTImporter instances in LLDB.\n///\n/// Clang's ASTImporter takes care of importing types from one ASTContext to\n/// another. This class expands this concept by allowing copying from several\n/// ASTContext instances to several other ASTContext instances. Instead of\n/// constructing a new ASTImporter manually to copy over a type/decl, this class\n/// can be asked to do this. It will construct a ASTImporter for the caller (and\n/// will cache the ASTImporter instance for later use) and then perform the\n/// import.\n///\n/// This mainly prevents that a caller might construct several ASTImporter\n/// instances for the same source/target ASTContext combination. As the\n/// ASTImporter has an internal state that keeps track of already imported\n/// declarations and so on, using only one ASTImporter instance is more\n/// efficient and less error-prone than using multiple.\n///\n/// 2. Keeps track of from where declarations were imported (origin-tracking).\n/// The ASTImporter instances in this class usually only performa a minimal\n/// import, i.e., only a shallow copy is made that is filled out on demand\n/// when more information is requested later on. This requires record-keeping\n/// of where any shallow clone originally came from so that the right original\n/// declaration can be found and used as the source of any missing information.\nclass ClangASTImporter {\npublic:\n  struct LayoutInfo {\n    LayoutInfo() = default;\n    typedef llvm::DenseMap<const clang::CXXRecordDecl *, clang::CharUnits>\n        OffsetMap;\n\n    uint64_t bit_size = 0;\n    uint64_t alignment = 0;\n    llvm::DenseMap<const clang::FieldDecl *, uint64_t> field_offsets;\n    OffsetMap base_offsets;\n    OffsetMap vbase_offsets;\n  };\n\n  ClangASTImporter()\n      : m_file_manager(clang::FileSystemOptions(),\n                       FileSystem::Instance().GetVirtualFileSystem()) {}\n\n  /// Copies the given type and the respective declarations to the destination\n  /// type system.\n  ///\n  /// This function does a shallow copy and requires that the target AST\n  /// has an ExternalASTSource which queries this ClangASTImporter instance\n  /// for any additional information that is maybe lacking in the shallow copy.\n  /// This also means that the type system of src_type can *not* be deleted\n  /// after this function has been called. If you need to delete the source\n  /// type system you either need to delete the destination type system first\n  /// or use \\ref ClangASTImporter::DeportType.\n  ///\n  /// \\see ClangASTImporter::DeportType\n  CompilerType CopyType(TypeSystemClang &dst, const CompilerType &src_type);\n\n  /// \\see ClangASTImporter::CopyType\n  clang::Decl *CopyDecl(clang::ASTContext *dst_ctx, clang::Decl *decl);\n\n  /// Copies the given type and the respective declarations to the destination\n  /// type system.\n  ///\n  /// Unlike CopyType this function ensures that types/declarations which are\n  /// originally from the AST of src_type are fully copied over. The type\n  /// system of src_type can safely be deleted after calling this function.\n  /// \\see ClangASTImporter::CopyType\n  CompilerType DeportType(TypeSystemClang &dst, const CompilerType &src_type);\n\n  /// Copies the given decl to the destination type system.\n  /// \\see ClangASTImporter::DeportType\n  clang::Decl *DeportDecl(clang::ASTContext *dst_ctx, clang::Decl *decl);\n\n  /// Sets the layout for the given RecordDecl. The layout will later be\n  /// used by Clang's during code generation. Not calling this function for\n  /// a RecordDecl will cause that Clang's codegen tries to layout the\n  /// record by itself.\n  ///\n  /// \\param decl The RecordDecl to set the layout for.\n  /// \\param layout The layout for the record.\n  void SetRecordLayout(clang::RecordDecl *decl, const LayoutInfo &layout);\n\n  bool LayoutRecordType(\n      const clang::RecordDecl *record_decl, uint64_t &bit_size,\n      uint64_t &alignment,\n      llvm::DenseMap<const clang::FieldDecl *, uint64_t> &field_offsets,\n      llvm::DenseMap<const clang::CXXRecordDecl *, clang::CharUnits>\n          &base_offsets,\n      llvm::DenseMap<const clang::CXXRecordDecl *, clang::CharUnits>\n          &vbase_offsets);\n\n  /// Returns true iff the given type was copied from another TypeSystemClang\n  /// and the original type in this other TypeSystemClang might contain\n  /// additional information (e.g., the definition of a 'class' type) that could\n  /// be imported.\n  ///\n  /// \\see ClangASTImporter::Import\n  bool CanImport(const CompilerType &type);\n\n  /// If the given type was copied from another TypeSystemClang then copy over\n  /// all missing information (e.g., the definition of a 'class' type).\n  ///\n  /// \\return True iff an original type in another TypeSystemClang was found.\n  ///         Note: Does *not* return false if an original type was found but\n  ///               no information was imported over.\n  ///\n  /// \\see ClangASTImporter::Import\n  bool Import(const CompilerType &type);\n\n  bool CompleteType(const CompilerType &compiler_type);\n\n  bool CompleteTagDecl(clang::TagDecl *decl);\n\n  bool CompleteTagDeclWithOrigin(clang::TagDecl *decl, clang::TagDecl *origin);\n\n  bool CompleteObjCInterfaceDecl(clang::ObjCInterfaceDecl *interface_decl);\n\n  bool CompleteAndFetchChildren(clang::QualType type);\n\n  bool RequireCompleteType(clang::QualType type);\n\n  /// Updates the internal origin-tracking information so that the given\n  /// 'original' decl is from now on used to import additional information\n  /// into the given decl.\n  ///\n  /// Usually the origin-tracking in the ClangASTImporter is automatically\n  /// updated when a declaration is imported, so the only valid reason to ever\n  /// call this is if there is a 'better' original decl and the target decl\n  /// is only a shallow clone that lacks any contents.\n  void SetDeclOrigin(const clang::Decl *decl, clang::Decl *original_decl);\n\n  ClangASTMetadata *GetDeclMetadata(const clang::Decl *decl);\n\n  //\n  // Namespace maps\n  //\n\n  typedef std::pair<lldb::ModuleSP, CompilerDeclContext> NamespaceMapItem;\n  typedef std::vector<NamespaceMapItem> NamespaceMap;\n  typedef std::shared_ptr<NamespaceMap> NamespaceMapSP;\n\n  void RegisterNamespaceMap(const clang::NamespaceDecl *decl,\n                            NamespaceMapSP &namespace_map);\n\n  NamespaceMapSP GetNamespaceMap(const clang::NamespaceDecl *decl);\n\n  void BuildNamespaceMap(const clang::NamespaceDecl *decl);\n\n  //\n  // Completers for maps\n  //\n\n  class MapCompleter {\n  public:\n    virtual ~MapCompleter();\n\n    virtual void CompleteNamespaceMap(NamespaceMapSP &namespace_map,\n                                      ConstString name,\n                                      NamespaceMapSP &parent_map) const = 0;\n  };\n\n  void InstallMapCompleter(clang::ASTContext *dst_ctx,\n                           MapCompleter &completer) {\n    ASTContextMetadataSP context_md;\n    ContextMetadataMap::iterator context_md_iter = m_metadata_map.find(dst_ctx);\n\n    if (context_md_iter == m_metadata_map.end()) {\n      context_md = ASTContextMetadataSP(new ASTContextMetadata(dst_ctx));\n      m_metadata_map[dst_ctx] = context_md;\n    } else {\n      context_md = context_md_iter->second;\n    }\n\n    context_md->m_map_completer = &completer;\n  }\n\n  void ForgetDestination(clang::ASTContext *dst_ctx);\n  void ForgetSource(clang::ASTContext *dst_ctx, clang::ASTContext *src_ctx);\n\n  struct DeclOrigin {\n    DeclOrigin() : ctx(nullptr), decl(nullptr) {}\n\n    DeclOrigin(clang::ASTContext *_ctx, clang::Decl *_decl)\n        : ctx(_ctx), decl(_decl) {\n      // The decl has to be in its associated ASTContext.\n      assert(_decl == nullptr || &_decl->getASTContext() == _ctx);\n    }\n\n    DeclOrigin(const DeclOrigin &rhs) {\n      ctx = rhs.ctx;\n      decl = rhs.decl;\n    }\n\n    void operator=(const DeclOrigin &rhs) {\n      ctx = rhs.ctx;\n      decl = rhs.decl;\n    }\n\n    bool Valid() const { return (ctx != nullptr || decl != nullptr); }\n\n    clang::ASTContext *ctx;\n    clang::Decl *decl;\n  };\n\n  /// Listener interface used by the ASTImporterDelegate to inform other code\n  /// about decls that have been imported the first time.\n  struct NewDeclListener {\n    virtual ~NewDeclListener() = default;\n    /// A decl has been imported for the first time.\n    virtual void NewDeclImported(clang::Decl *from, clang::Decl *to) = 0;\n  };\n\n  /// ASTImporter that intercepts and records the import process of the\n  /// underlying ASTImporter.\n  ///\n  /// This class updates the map from declarations to their original\n  /// declarations and can record declarations that have been imported in a\n  /// certain interval.\n  ///\n  /// When intercepting a declaration import, the ASTImporterDelegate uses the\n  /// CxxModuleHandler to replace any missing or malformed declarations with\n  /// their counterpart from a C++ module.\n  struct ASTImporterDelegate : public clang::ASTImporter {\n    ASTImporterDelegate(ClangASTImporter &master, clang::ASTContext *target_ctx,\n                        clang::ASTContext *source_ctx)\n        : clang::ASTImporter(*target_ctx, master.m_file_manager, *source_ctx,\n                             master.m_file_manager, true /*minimal*/),\n          m_master(master), m_source_ctx(source_ctx) {\n      // Target and source ASTContext shouldn't be identical. Importing AST\n      // nodes within the same AST doesn't make any sense as the whole idea\n      // is to import them to a different AST.\n      lldbassert(target_ctx != source_ctx && \"Can't import into itself\");\n      // This is always doing a minimal import of any declarations. This means\n      // that there has to be an ExternalASTSource in the target ASTContext\n      // (that should implement the callbacks that complete any declarations\n      // on demand). Without an ExternalASTSource, this ASTImporter will just\n      // do a minimal import and the imported declarations won't be completed.\n      assert(target_ctx->getExternalSource() && \"Missing ExternalSource\");\n      setODRHandling(clang::ASTImporter::ODRHandlingType::Liberal);\n    }\n\n    /// Scope guard that attaches a CxxModuleHandler to an ASTImporterDelegate\n    /// and deattaches it at the end of the scope. Supports being used multiple\n    /// times on the same ASTImporterDelegate instance in nested scopes.\n    class CxxModuleScope {\n      /// The handler we attach to the ASTImporterDelegate.\n      CxxModuleHandler m_handler;\n      /// The ASTImporterDelegate we are supposed to attach the handler to.\n      ASTImporterDelegate &m_delegate;\n      /// True iff we attached the handler to the ASTImporterDelegate.\n      bool m_valid = false;\n\n    public:\n      CxxModuleScope(ASTImporterDelegate &delegate, clang::ASTContext *dst_ctx)\n          : m_delegate(delegate) {\n        // If the delegate doesn't have a CxxModuleHandler yet, create one\n        // and attach it.\n        if (!delegate.m_std_handler) {\n          m_handler = CxxModuleHandler(delegate, dst_ctx);\n          m_valid = true;\n          delegate.m_std_handler = &m_handler;\n        }\n      }\n      ~CxxModuleScope() {\n        if (m_valid) {\n          // Make sure no one messed with the handler we placed.\n          assert(m_delegate.m_std_handler == &m_handler);\n          m_delegate.m_std_handler = nullptr;\n        }\n      }\n    };\n\n    void ImportDefinitionTo(clang::Decl *to, clang::Decl *from);\n\n    void Imported(clang::Decl *from, clang::Decl *to) override;\n\n    clang::Decl *GetOriginalDecl(clang::Decl *To) override;\n\n    void SetImportListener(NewDeclListener *listener) {\n      assert(m_new_decl_listener == nullptr && \"Already attached a listener?\");\n      m_new_decl_listener = listener;\n    }\n    void RemoveImportListener() { m_new_decl_listener = nullptr; }\n\n  protected:\n    llvm::Expected<clang::Decl *> ImportImpl(clang::Decl *From) override;\n\n  private:\n    /// Decls we should ignore when mapping decls back to their original\n    /// ASTContext. Used by the CxxModuleHandler to mark declarations that\n    /// were created from the 'std' C++ module to prevent that the Importer\n    /// tries to sync them with the broken equivalent in the debug info AST.\n    llvm::SmallPtrSet<clang::Decl *, 16> m_decls_to_ignore;\n    ClangASTImporter &m_master;\n    clang::ASTContext *m_source_ctx;\n    CxxModuleHandler *m_std_handler = nullptr;\n    /// The currently attached listener.\n    NewDeclListener *m_new_decl_listener = nullptr;\n  };\n\n  typedef std::shared_ptr<ASTImporterDelegate> ImporterDelegateSP;\n  typedef llvm::DenseMap<clang::ASTContext *, ImporterDelegateSP> DelegateMap;\n  typedef llvm::DenseMap<const clang::NamespaceDecl *, NamespaceMapSP>\n      NamespaceMetaMap;\n\n  class ASTContextMetadata {\n    typedef llvm::DenseMap<const clang::Decl *, DeclOrigin> OriginMap;\n\n  public:\n    ASTContextMetadata(clang::ASTContext *dst_ctx) : m_dst_ctx(dst_ctx) {}\n\n    clang::ASTContext *m_dst_ctx;\n    DelegateMap m_delegates;\n\n    NamespaceMetaMap m_namespace_maps;\n    MapCompleter *m_map_completer = nullptr;\n\n    /// Sets the DeclOrigin for the given Decl and overwrites any existing\n    /// DeclOrigin.\n    void setOrigin(const clang::Decl *decl, DeclOrigin origin) {\n      // Setting the origin of any decl to itself (or to a different decl\n      // in the same ASTContext) doesn't make any sense. It will also cause\n      // ASTImporterDelegate::ImportImpl to infinite recurse when trying to find\n      // the 'original' Decl when importing code.\n      assert(&decl->getASTContext() != origin.ctx &&\n             \"Trying to set decl origin to its own ASTContext?\");\n      assert(decl != origin.decl && \"Trying to set decl origin to itself?\");\n      m_origins[decl] = origin;\n    }\n\n    /// Removes any tracked DeclOrigin for the given decl.\n    void removeOrigin(const clang::Decl *decl) { m_origins.erase(decl); }\n\n    /// Remove all DeclOrigin entries that point to the given ASTContext.\n    /// Useful when an ASTContext is about to be deleted and all the dangling\n    /// pointers to it need to be removed.\n    void removeOriginsWithContext(clang::ASTContext *ctx) {\n      for (OriginMap::iterator iter = m_origins.begin();\n           iter != m_origins.end();) {\n        if (iter->second.ctx == ctx)\n          m_origins.erase(iter++);\n        else\n          ++iter;\n      }\n    }\n\n    /// Returns the DeclOrigin for the given Decl or an invalid DeclOrigin\n    /// instance if there no known DeclOrigin for the given Decl.\n    DeclOrigin getOrigin(const clang::Decl *decl) const {\n      auto iter = m_origins.find(decl);\n      if (iter == m_origins.end())\n        return DeclOrigin();\n      return iter->second;\n    }\n\n    /// Returns true there is a known DeclOrigin for the given Decl.\n    bool hasOrigin(const clang::Decl *decl) const {\n      return getOrigin(decl).Valid();\n    }\n\n  private:\n    /// Maps declarations to the ASTContext/Decl from which they were imported\n    /// from. If a declaration is from an ASTContext which has been deleted\n    /// since the declaration was imported or the declaration wasn't created by\n    /// the ASTImporter, then it doesn't have a DeclOrigin and will not be\n    /// tracked here.\n    OriginMap m_origins;\n  };\n\n  typedef std::shared_ptr<ASTContextMetadata> ASTContextMetadataSP;\n  typedef llvm::DenseMap<const clang::ASTContext *, ASTContextMetadataSP>\n      ContextMetadataMap;\n\n  ContextMetadataMap m_metadata_map;\n\n  ASTContextMetadataSP GetContextMetadata(clang::ASTContext *dst_ctx) {\n    ContextMetadataMap::iterator context_md_iter = m_metadata_map.find(dst_ctx);\n\n    if (context_md_iter == m_metadata_map.end()) {\n      ASTContextMetadataSP context_md =\n          ASTContextMetadataSP(new ASTContextMetadata(dst_ctx));\n      m_metadata_map[dst_ctx] = context_md;\n      return context_md;\n    }\n    return context_md_iter->second;\n  }\n\n  ASTContextMetadataSP MaybeGetContextMetadata(clang::ASTContext *dst_ctx) {\n    ContextMetadataMap::iterator context_md_iter = m_metadata_map.find(dst_ctx);\n\n    if (context_md_iter != m_metadata_map.end())\n      return context_md_iter->second;\n    return ASTContextMetadataSP();\n  }\n\n  ImporterDelegateSP GetDelegate(clang::ASTContext *dst_ctx,\n                                 clang::ASTContext *src_ctx) {\n    ASTContextMetadataSP context_md = GetContextMetadata(dst_ctx);\n\n    DelegateMap &delegates = context_md->m_delegates;\n    DelegateMap::iterator delegate_iter = delegates.find(src_ctx);\n\n    if (delegate_iter == delegates.end()) {\n      ImporterDelegateSP delegate =\n          ImporterDelegateSP(new ASTImporterDelegate(*this, dst_ctx, src_ctx));\n      delegates[src_ctx] = delegate;\n      return delegate;\n    }\n    return delegate_iter->second;\n  }\n\n  DeclOrigin GetDeclOrigin(const clang::Decl *decl);\n\n  clang::FileManager m_file_manager;\n  typedef llvm::DenseMap<const clang::RecordDecl *, LayoutInfo>\n      RecordDeclToLayoutMap;\n\n  RecordDeclToLayoutMap m_record_decl_to_layout_map;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_SOURCE_PLUGINS_EXPRESSIONPARSER_CLANG_CLANGASTIMPORTER_H\n"}, "104": {"id": 104, "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/ExpressionParser/Clang/CxxModuleHandler.h", "content": "//===-- CxxModuleHandler.h --------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SOURCE_PLUGINS_EXPRESSIONPARSER_CLANG_CXXMODULEHANDLER_H\n#define LLDB_SOURCE_PLUGINS_EXPRESSIONPARSER_CLANG_CXXMODULEHANDLER_H\n\n#include \"clang/AST/ASTImporter.h\"\n#include \"clang/Sema/Sema.h\"\n#include \"llvm/ADT/StringSet.h\"\n\nnamespace lldb_private {\n\n/// Handles importing decls into an ASTContext with an attached C++ module.\n///\n/// This class searches a C++ module (which must be attached to the target\n/// ASTContext) for an equivalent decl to the one that should be imported.\n/// If the decl that is found in the module is a suitable replacement\n/// for the decl that should be imported, the module decl will be treated as\n/// the result of the import process.\n///\n/// If the Decl that should be imported is a template specialization\n/// that doesn't exist yet in the target ASTContext (e.g. `std::vector<int>`),\n/// then this class tries to create the template specialization in the target\n/// ASTContext. This is only possible if the CxxModuleHandler can determine\n/// that instantiating this template is safe to do, e.g. because the target\n/// decl is a container class from the STL.\nclass CxxModuleHandler {\n  /// The ASTImporter that should be used to import any Decls which aren't\n  /// directly handled by this class itself.\n  clang::ASTImporter *m_importer = nullptr;\n\n  /// The Sema instance of the target ASTContext.\n  clang::Sema *m_sema = nullptr;\n\n  /// List of template names this class currently supports. These are the\n  /// template names inside the 'std' namespace such as 'vector' or 'list'.\n  llvm::StringSet<> m_supported_templates;\n\n  /// Tries to manually instantiate the given foreign template in the target\n  /// context (designated by m_sema).\n  llvm::Optional<clang::Decl *> tryInstantiateStdTemplate(clang::Decl *d);\n\npublic:\n  CxxModuleHandler() = default;\n  CxxModuleHandler(clang::ASTImporter &importer, clang::ASTContext *target);\n\n  /// Attempts to import the given decl into the target ASTContext by\n  /// deserializing it from the 'std' module. This function returns a Decl if a\n  /// Decl has been deserialized from the 'std' module. Otherwise this function\n  /// returns nothing.\n  llvm::Optional<clang::Decl *> Import(clang::Decl *d);\n\n  /// Returns true iff this instance is capable of importing any declarations\n  /// in the target ASTContext.\n  bool isValid() const { return m_sema != nullptr; }\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_SOURCE_PLUGINS_EXPRESSIONPARSER_CLANG_CXXMODULEHANDLER_H\n"}, "105": {"id": 105, "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/Language/ClangCommon/ClangHighlighter.h", "content": "//===-- ClangHighlighter.h --------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SOURCE_PLUGINS_LANGUAGE_CLANGCOMMON_CLANGHIGHLIGHTER_H\n#define LLDB_SOURCE_PLUGINS_LANGUAGE_CLANGCOMMON_CLANGHIGHLIGHTER_H\n\n#include \"lldb/Utility/Stream.h\"\n#include \"llvm/ADT/StringSet.h\"\n\n#include \"lldb/Core/Highlighter.h\"\n\nnamespace lldb_private {\n\nclass ClangHighlighter : public Highlighter {\n  llvm::StringSet<> keywords;\n\npublic:\n  ClangHighlighter();\n  llvm::StringRef GetName() const override { return \"clang\"; }\n\n  void Highlight(const HighlightStyle &options, llvm::StringRef line,\n                 llvm::Optional<size_t> cursor_pos,\n                 llvm::StringRef previous_lines, Stream &s) const override;\n\n  /// Returns true if the given string represents a keywords in any Clang\n  /// supported language.\n  bool isKeyword(llvm::StringRef token) const;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_SOURCE_PLUGINS_LANGUAGE_CLANGCOMMON_CLANGHIGHLIGHTER_H\n"}, "106": {"id": 106, "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/SymbolFile/DWARF/AppleDWARFIndex.h", "content": "//===-- AppleDWARFIndex.h --------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SOURCE_PLUGINS_SYMBOLFILE_DWARF_APPLEDWARFINDEX_H\n#define LLDB_SOURCE_PLUGINS_SYMBOLFILE_DWARF_APPLEDWARFINDEX_H\n\n#include \"Plugins/SymbolFile/DWARF/DWARFIndex.h\"\n#include \"Plugins/SymbolFile/DWARF/HashedNameToDIE.h\"\n\nnamespace lldb_private {\nclass AppleDWARFIndex : public DWARFIndex {\npublic:\n  static std::unique_ptr<AppleDWARFIndex>\n  Create(Module &module, DWARFDataExtractor apple_names,\n         DWARFDataExtractor apple_namespaces, DWARFDataExtractor apple_types,\n         DWARFDataExtractor apple_objc, DWARFDataExtractor debug_str);\n\n  AppleDWARFIndex(\n      Module &module, std::unique_ptr<DWARFMappedHash::MemoryTable> apple_names,\n      std::unique_ptr<DWARFMappedHash::MemoryTable> apple_namespaces,\n      std::unique_ptr<DWARFMappedHash::MemoryTable> apple_types,\n      std::unique_ptr<DWARFMappedHash::MemoryTable> apple_objc)\n      : DWARFIndex(module), m_apple_names_up(std::move(apple_names)),\n        m_apple_namespaces_up(std::move(apple_namespaces)),\n        m_apple_types_up(std::move(apple_types)),\n        m_apple_objc_up(std::move(apple_objc)) {}\n\n  void Preload() override {}\n\n  void\n  GetGlobalVariables(ConstString basename,\n                     llvm::function_ref<bool(DWARFDIE die)> callback) override;\n  void\n  GetGlobalVariables(const RegularExpression &regex,\n                     llvm::function_ref<bool(DWARFDIE die)> callback) override;\n  void\n  GetGlobalVariables(const DWARFUnit &cu,\n                     llvm::function_ref<bool(DWARFDIE die)> callback) override;\n  void GetObjCMethods(ConstString class_name,\n                      llvm::function_ref<bool(DWARFDIE die)> callback) override;\n  void GetCompleteObjCClass(\n      ConstString class_name, bool must_be_implementation,\n      llvm::function_ref<bool(DWARFDIE die)> callback) override;\n  void GetTypes(ConstString name,\n                llvm::function_ref<bool(DWARFDIE die)> callback) override;\n  void GetTypes(const DWARFDeclContext &context,\n                llvm::function_ref<bool(DWARFDIE die)> callback) override;\n  void GetNamespaces(ConstString name,\n                     llvm::function_ref<bool(DWARFDIE die)> callback) override;\n  void GetFunctions(ConstString name, SymbolFileDWARF &dwarf,\n                    const CompilerDeclContext &parent_decl_ctx,\n                    uint32_t name_type_mask,\n                    llvm::function_ref<bool(DWARFDIE die)> callback) override;\n  void GetFunctions(const RegularExpression &regex,\n                    llvm::function_ref<bool(DWARFDIE die)> callback) override;\n\n  void Dump(Stream &s) override;\n\nprivate:\n  std::unique_ptr<DWARFMappedHash::MemoryTable> m_apple_names_up;\n  std::unique_ptr<DWARFMappedHash::MemoryTable> m_apple_namespaces_up;\n  std::unique_ptr<DWARFMappedHash::MemoryTable> m_apple_types_up;\n  std::unique_ptr<DWARFMappedHash::MemoryTable> m_apple_objc_up;\n};\n} // namespace lldb_private\n\n#endif // LLDB_SOURCE_PLUGINS_SYMBOLFILE_DWARF_APPLEDWARFINDEX_H\n"}, "107": {"id": 107, "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/SymbolFile/DWARF/DWARFASTParserClang.h", "content": "//===-- DWARFASTParserClang.h -----------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SOURCE_PLUGINS_SYMBOLFILE_DWARF_DWARFASTPARSERCLANG_H\n#define LLDB_SOURCE_PLUGINS_SYMBOLFILE_DWARF_DWARFASTPARSERCLANG_H\n\n#include \"clang/AST/CharUnits.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n\n#include \"DWARFASTParser.h\"\n#include \"DWARFDIE.h\"\n#include \"DWARFDefines.h\"\n#include \"DWARFFormValue.h\"\n#include \"LogChannelDWARF.h\"\n#include \"lldb/Core/PluginInterface.h\"\n\n#include \"Plugins/ExpressionParser/Clang/ClangASTImporter.h\"\n#include \"Plugins/TypeSystem/Clang/TypeSystemClang.h\"\n\n#include <vector>\n\nnamespace lldb_private {\nclass CompileUnit;\n}\nclass DWARFDebugInfoEntry;\nclass SymbolFileDWARF;\n\nstruct ParsedDWARFTypeAttributes;\n\nclass DWARFASTParserClang : public DWARFASTParser {\npublic:\n  DWARFASTParserClang(lldb_private::TypeSystemClang &ast);\n\n  ~DWARFASTParserClang() override;\n\n  // DWARFASTParser interface.\n  lldb::TypeSP ParseTypeFromDWARF(const lldb_private::SymbolContext &sc,\n                                  const DWARFDIE &die,\n                                  bool *type_is_new_ptr) override;\n\n  lldb_private::Function *\n  ParseFunctionFromDWARF(lldb_private::CompileUnit &comp_unit,\n                         const DWARFDIE &die) override;\n\n  bool\n  CompleteTypeFromDWARF(const DWARFDIE &die, lldb_private::Type *type,\n                        lldb_private::CompilerType &compiler_type) override;\n\n  lldb_private::CompilerDecl\n  GetDeclForUIDFromDWARF(const DWARFDIE &die) override;\n\n  void EnsureAllDIEsInDeclContextHaveBeenParsed(\n      lldb_private::CompilerDeclContext decl_context) override;\n\n  lldb_private::CompilerDeclContext\n  GetDeclContextForUIDFromDWARF(const DWARFDIE &die) override;\n\n  lldb_private::CompilerDeclContext\n  GetDeclContextContainingUIDFromDWARF(const DWARFDIE &die) override;\n\n  lldb_private::ClangASTImporter &GetClangASTImporter();\n\nprotected:\n  /// Protected typedefs and members.\n  /// @{\n  class DelayedAddObjCClassProperty;\n  typedef std::vector<DelayedAddObjCClassProperty> DelayedPropertyList;\n\n  typedef llvm::SmallPtrSet<const DWARFDebugInfoEntry *, 4> DIEPointerSet;\n  typedef llvm::DenseMap<const DWARFDebugInfoEntry *, clang::DeclContext *>\n      DIEToDeclContextMap;\n  typedef std::multimap<const clang::DeclContext *, const DWARFDIE>\n      DeclContextToDIEMap;\n  typedef llvm::DenseMap<const DWARFDebugInfoEntry *,\n                         lldb_private::OptionalClangModuleID>\n      DIEToModuleMap;\n  typedef llvm::DenseMap<const DWARFDebugInfoEntry *, clang::Decl *>\n      DIEToDeclMap;\n  typedef llvm::DenseMap<const clang::Decl *, DIEPointerSet> DeclToDIEMap;\n\n  lldb_private::TypeSystemClang &m_ast;\n  DIEToDeclMap m_die_to_decl;\n  DeclToDIEMap m_decl_to_die;\n  DIEToDeclContextMap m_die_to_decl_ctx;\n  DeclContextToDIEMap m_decl_ctx_to_die;\n  DIEToModuleMap m_die_to_module;\n  std::unique_ptr<lldb_private::ClangASTImporter> m_clang_ast_importer_up;\n  /// @}\n\n  clang::DeclContext *GetDeclContextForBlock(const DWARFDIE &die);\n\n  clang::BlockDecl *ResolveBlockDIE(const DWARFDIE &die);\n\n  clang::NamespaceDecl *ResolveNamespaceDIE(const DWARFDIE &die);\n\n  bool ParseTemplateDIE(const DWARFDIE &die,\n                        lldb_private::TypeSystemClang::TemplateParameterInfos\n                            &template_param_infos);\n  bool ParseTemplateParameterInfos(\n      const DWARFDIE &parent_die,\n      lldb_private::TypeSystemClang::TemplateParameterInfos\n          &template_param_infos);\n\n  bool ParseChildMembers(\n      const DWARFDIE &die, lldb_private::CompilerType &class_compiler_type,\n      std::vector<std::unique_ptr<clang::CXXBaseSpecifier>> &base_classes,\n      std::vector<int> &member_accessibilities,\n      std::vector<DWARFDIE> &member_function_dies,\n      DelayedPropertyList &delayed_properties,\n      lldb::AccessType &default_accessibility, bool &is_a_class,\n      lldb_private::ClangASTImporter::LayoutInfo &layout_info);\n\n  size_t\n  ParseChildParameters(clang::DeclContext *containing_decl_ctx,\n                       const DWARFDIE &parent_die, bool skip_artificial,\n                       bool &is_static, bool &is_variadic,\n                       bool &has_template_params,\n                       std::vector<lldb_private::CompilerType> &function_args,\n                       std::vector<clang::ParmVarDecl *> &function_param_decls,\n                       unsigned &type_quals);\n\n  size_t ParseChildEnumerators(lldb_private::CompilerType &compiler_type,\n                               bool is_signed, uint32_t enumerator_byte_size,\n                               const DWARFDIE &parent_die);\n\n  /// Parse a structure, class, or union type DIE.\n  lldb::TypeSP ParseStructureLikeDIE(const lldb_private::SymbolContext &sc,\n                                     const DWARFDIE &die,\n                                     ParsedDWARFTypeAttributes &attrs);\n\n  lldb_private::Type *GetTypeForDIE(const DWARFDIE &die);\n\n  clang::Decl *GetClangDeclForDIE(const DWARFDIE &die);\n\n  clang::DeclContext *GetClangDeclContextForDIE(const DWARFDIE &die);\n\n  clang::DeclContext *GetClangDeclContextContainingDIE(const DWARFDIE &die,\n                                                       DWARFDIE *decl_ctx_die);\n  lldb_private::OptionalClangModuleID GetOwningClangModule(const DWARFDIE &die);\n\n  bool CopyUniqueClassMethodTypes(const DWARFDIE &src_class_die,\n                                  const DWARFDIE &dst_class_die,\n                                  lldb_private::Type *class_type,\n                                  std::vector<DWARFDIE> &failures);\n\n  clang::DeclContext *GetCachedClangDeclContextForDIE(const DWARFDIE &die);\n\n  void LinkDeclContextToDIE(clang::DeclContext *decl_ctx, const DWARFDIE &die);\n\n  void LinkDeclToDIE(clang::Decl *decl, const DWARFDIE &die);\n\n  /// If \\p type_sp is valid, calculate and set its symbol context scope, and\n  /// update the type list for its backing symbol file.\n  ///\n  /// Returns \\p type_sp.\n  lldb::TypeSP\n  UpdateSymbolContextScopeForType(const lldb_private::SymbolContext &sc,\n                                  const DWARFDIE &die, lldb::TypeSP type_sp);\n\n  /// Follow Clang Module Skeleton CU references to find a type definition.\n  lldb::TypeSP ParseTypeFromClangModule(const lldb_private::SymbolContext &sc,\n                                        const DWARFDIE &die,\n                                        lldb_private::Log *log);\n\n  // Return true if this type is a declaration to a type in an external\n  // module.\n  lldb::ModuleSP GetModuleForType(const DWARFDIE &die);\n\nprivate:\n  struct FieldInfo {\n    uint64_t bit_size = 0;\n    uint64_t bit_offset = 0;\n    bool is_bitfield = false;\n\n    FieldInfo() = default;\n\n    void SetIsBitfield(bool flag) { is_bitfield = flag; }\n    bool IsBitfield() { return is_bitfield; }\n\n    bool NextBitfieldOffsetIsValid(const uint64_t next_bit_offset) const {\n      // Any subsequent bitfields must not overlap and must be at a higher\n      // bit offset than any previous bitfield + size.\n      return (bit_size + bit_offset) <= next_bit_offset;\n    }\n  };\n\n  void\n  ParseSingleMember(const DWARFDIE &die, const DWARFDIE &parent_die,\n                    const lldb_private::CompilerType &class_clang_type,\n                    std::vector<int> &member_accessibilities,\n                    lldb::AccessType default_accessibility,\n                    DelayedPropertyList &delayed_properties,\n                    lldb_private::ClangASTImporter::LayoutInfo &layout_info,\n                    FieldInfo &last_field_info);\n\n  bool CompleteRecordType(const DWARFDIE &die, lldb_private::Type *type,\n                          lldb_private::CompilerType &clang_type);\n  bool CompleteEnumType(const DWARFDIE &die, lldb_private::Type *type,\n                        lldb_private::CompilerType &clang_type);\n\n  lldb::TypeSP ParseTypeModifier(const lldb_private::SymbolContext &sc,\n                                 const DWARFDIE &die,\n                                 ParsedDWARFTypeAttributes &attrs);\n  lldb::TypeSP ParseEnum(const lldb_private::SymbolContext &sc,\n                         const DWARFDIE &die, ParsedDWARFTypeAttributes &attrs);\n  lldb::TypeSP ParseSubroutine(const DWARFDIE &die,\n                               ParsedDWARFTypeAttributes &attrs);\n  // FIXME: attrs should be passed as a const reference.\n  lldb::TypeSP ParseArrayType(const DWARFDIE &die,\n                              ParsedDWARFTypeAttributes &attrs);\n  lldb::TypeSP ParsePointerToMemberType(const DWARFDIE &die,\n                                        const ParsedDWARFTypeAttributes &attrs);\n};\n\n/// Parsed form of all attributes that are relevant for type reconstruction.\n/// Some attributes are relevant for all kinds of types (declaration), while\n/// others are only meaningful to a specific type (is_virtual)\nstruct ParsedDWARFTypeAttributes {\n  explicit ParsedDWARFTypeAttributes(const DWARFDIE &die);\n\n  lldb::AccessType accessibility = lldb::eAccessNone;\n  bool is_artificial = false;\n  bool is_complete_objc_class = false;\n  bool is_explicit = false;\n  bool is_forward_declaration = false;\n  bool is_inline = false;\n  bool is_scoped_enum = false;\n  bool is_vector = false;\n  bool is_virtual = false;\n  bool is_objc_direct_call = false;\n  bool exports_symbols = false;\n  clang::StorageClass storage = clang::SC_None;\n  const char *mangled_name = nullptr;\n  lldb_private::ConstString name;\n  lldb_private::Declaration decl;\n  DWARFDIE object_pointer;\n  DWARFFormValue abstract_origin;\n  DWARFFormValue containing_type;\n  DWARFFormValue signature;\n  DWARFFormValue specification;\n  DWARFFormValue type;\n  lldb::LanguageType class_language = lldb::eLanguageTypeUnknown;\n  llvm::Optional<uint64_t> byte_size;\n  size_t calling_convention = llvm::dwarf::DW_CC_normal;\n  uint32_t bit_stride = 0;\n  uint32_t byte_stride = 0;\n  uint32_t encoding = 0;\n};\n\n#endif // LLDB_SOURCE_PLUGINS_SYMBOLFILE_DWARF_DWARFASTPARSERCLANG_H\n"}, "110": {"id": 110, "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/SymbolFile/DWARF/DWARFDebugInfoEntry.h", "content": "//===-- DWARFDebugInfoEntry.h -----------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SOURCE_PLUGINS_SYMBOLFILE_DWARF_DWARFDEBUGINFOENTRY_H\n#define LLDB_SOURCE_PLUGINS_SYMBOLFILE_DWARF_DWARFDEBUGINFOENTRY_H\n\n#include \"SymbolFileDWARF.h\"\n#include \"llvm/ADT/SmallVector.h\"\n\n#include \"DWARFAbbreviationDeclaration.h\"\n#include \"DWARFBaseDIE.h\"\n#include \"DWARFDebugAbbrev.h\"\n#include \"DWARFDebugRanges.h\"\n#include <map>\n#include <set>\n#include <vector>\n\nclass DWARFDeclContext;\n\n#define DIE_SIBLING_IDX_BITSIZE 31\n\n/// DWARFDebugInfoEntry objects assume that they are living in one big\n/// vector and do pointer arithmetic on their this pointers. Don't\n/// pass them by value. Due to the way they are constructed in a\n/// std::vector, we cannot delete the copy constructor.\nclass DWARFDebugInfoEntry {\npublic:\n  typedef std::vector<DWARFDebugInfoEntry> collection;\n  typedef collection::iterator iterator;\n  typedef collection::const_iterator const_iterator;\n\n  DWARFDebugInfoEntry()\n      : m_offset(DW_INVALID_OFFSET), m_parent_idx(0), m_sibling_idx(0),\n        m_has_children(false), m_abbr_idx(0), m_tag(llvm::dwarf::DW_TAG_null) {}\n\n  explicit operator bool() const { return m_offset != DW_INVALID_OFFSET; }\n  bool operator==(const DWARFDebugInfoEntry &rhs) const;\n  bool operator!=(const DWARFDebugInfoEntry &rhs) const;\n\n  void BuildFunctionAddressRangeTable(DWARFUnit *cu,\n                                      DWARFDebugAranges *debug_aranges) const;\n\n  bool Extract(const lldb_private::DWARFDataExtractor &data,\n               const DWARFUnit *cu, lldb::offset_t *offset_ptr);\n\n  using Recurse = DWARFBaseDIE::Recurse;\n  size_t GetAttributes(DWARFUnit *cu, DWARFAttributes &attrs,\n                       Recurse recurse = Recurse::yes) const {\n    return GetAttributes(cu, attrs, recurse, 0 /* curr_depth */);\n  }\n\n  dw_offset_t\n  GetAttributeValue(const DWARFUnit *cu, const dw_attr_t attr,\n                    DWARFFormValue &formValue,\n                    dw_offset_t *end_attr_offset_ptr = nullptr,\n                    bool check_specification_or_abstract_origin = false) const;\n\n  const char *GetAttributeValueAsString(\n      const DWARFUnit *cu, const dw_attr_t attr, const char *fail_value,\n      bool check_specification_or_abstract_origin = false) const;\n\n  uint64_t GetAttributeValueAsUnsigned(\n      const DWARFUnit *cu, const dw_attr_t attr, uint64_t fail_value,\n      bool check_specification_or_abstract_origin = false) const;\n\n  DWARFDIE GetAttributeValueAsReference(\n      const DWARFUnit *cu, const dw_attr_t attr,\n      bool check_specification_or_abstract_origin = false) const;\n\n  uint64_t GetAttributeValueAsAddress(\n      const DWARFUnit *cu, const dw_attr_t attr, uint64_t fail_value,\n      bool check_specification_or_abstract_origin = false) const;\n\n  dw_addr_t\n  GetAttributeHighPC(const DWARFUnit *cu, dw_addr_t lo_pc, uint64_t fail_value,\n                     bool check_specification_or_abstract_origin = false) const;\n\n  bool GetAttributeAddressRange(\n      const DWARFUnit *cu, dw_addr_t &lo_pc, dw_addr_t &hi_pc,\n      uint64_t fail_value,\n      bool check_specification_or_abstract_origin = false) const;\n\n  size_t GetAttributeAddressRanges(\n      DWARFUnit *cu, DWARFRangeList &ranges, bool check_hi_lo_pc,\n      bool check_specification_or_abstract_origin = false) const;\n\n  const char *GetName(const DWARFUnit *cu) const;\n\n  const char *GetMangledName(const DWARFUnit *cu,\n                             bool substitute_name_allowed = true) const;\n\n  const char *GetPubname(const DWARFUnit *cu) const;\n\n  const char *GetQualifiedName(DWARFUnit *cu, std::string &storage) const;\n\n  const char *GetQualifiedName(DWARFUnit *cu, const DWARFAttributes &attributes,\n                               std::string &storage) const;\n\n  bool GetDIENamesAndRanges(\n      DWARFUnit *cu, const char *&name, const char *&mangled,\n      DWARFRangeList &rangeList, int &decl_file, int &decl_line,\n      int &decl_column, int &call_file, int &call_line, int &call_column,\n      lldb_private::DWARFExpression *frame_base = nullptr) const;\n\n  const DWARFAbbreviationDeclaration *\n  GetAbbreviationDeclarationPtr(const DWARFUnit *cu) const;\n\n  lldb::offset_t GetFirstAttributeOffset() const;\n\n  dw_tag_t Tag() const { return m_tag; }\n\n  bool IsNULL() const { return m_abbr_idx == 0; }\n\n  dw_offset_t GetOffset() const { return m_offset; }\n\n  bool HasChildren() const { return m_has_children; }\n\n  void SetHasChildren(bool b) { m_has_children = b; }\n\n  // We know we are kept in a vector of contiguous entries, so we know\n  // our parent will be some index behind \"this\".\n  DWARFDebugInfoEntry *GetParent() {\n    return m_parent_idx > 0 ? this - m_parent_idx : nullptr;\n  }\n  const DWARFDebugInfoEntry *GetParent() const {\n    return m_parent_idx > 0 ? this - m_parent_idx : nullptr;\n  }\n  // We know we are kept in a vector of contiguous entries, so we know\n  // our sibling will be some index after \"this\".\n  DWARFDebugInfoEntry *GetSibling() {\n    return m_sibling_idx > 0 ? this + m_sibling_idx : nullptr;\n  }\n  const DWARFDebugInfoEntry *GetSibling() const {\n    return m_sibling_idx > 0 ? this + m_sibling_idx : nullptr;\n  }\n  // We know we are kept in a vector of contiguous entries, so we know\n  // we don't need to store our child pointer, if we have a child it will\n  // be the next entry in the list...\n  DWARFDebugInfoEntry *GetFirstChild() {\n    return HasChildren() ? this + 1 : nullptr;\n  }\n  const DWARFDebugInfoEntry *GetFirstChild() const {\n    return HasChildren() ? this + 1 : nullptr;\n  }\n\n  DWARFDeclContext GetDWARFDeclContext(DWARFUnit *cu) const;\n\n  DWARFDIE GetParentDeclContextDIE(DWARFUnit *cu) const;\n  DWARFDIE GetParentDeclContextDIE(DWARFUnit *cu,\n                                   const DWARFAttributes &attributes) const;\n\n  void SetSiblingIndex(uint32_t idx) { m_sibling_idx = idx; }\n  void SetParentIndex(uint32_t idx) { m_parent_idx = idx; }\n\n  // This function returns true if the variable scope is either\n  // global or (file-static). It will return false for static variables\n  // that are local to a function, as they have local scope.\n  bool IsGlobalOrStaticScopeVariable() const;\n\nprotected:\n  static DWARFDeclContext\n  GetDWARFDeclContextStatic(const DWARFDebugInfoEntry *die, DWARFUnit *cu);\n\n  dw_offset_t m_offset; // Offset within the .debug_info/.debug_types\n  uint32_t m_parent_idx; // How many to subtract from \"this\" to get the parent.\n                         // If zero this die has no parent\n  uint32_t m_sibling_idx : 31, // How many to add to \"this\" to get the sibling.\n      // If it is zero, then the DIE doesn't have children, or the\n      // DWARF claimed it had children but the DIE only contained\n      // a single NULL terminating child.\n      m_has_children : 1;\n  uint16_t m_abbr_idx;\n  /// A copy of the DW_TAG value so we don't have to go through the compile\n  /// unit abbrev table\n  dw_tag_t m_tag = llvm::dwarf::DW_TAG_null;\n\nprivate:\n  size_t GetAttributes(DWARFUnit *cu, DWARFAttributes &attrs, Recurse recurse,\n                       uint32_t curr_depth) const;\n};\n\n#endif // LLDB_SOURCE_PLUGINS_SYMBOLFILE_DWARF_DWARFDEBUGINFOENTRY_H\n"}, "111": {"id": 111, "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/SymbolFile/DWARF/DWARFDeclContext.h", "content": "//===-- DWARFDeclContext.h --------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SOURCE_PLUGINS_SYMBOLFILE_DWARF_DWARFDECLCONTEXT_H\n#define LLDB_SOURCE_PLUGINS_SYMBOLFILE_DWARF_DWARFDECLCONTEXT_H\n\n#include <string>\n#include <vector>\n#include \"lldb/Utility/ConstString.h\"\n#include \"DWARFDefines.h\"\n\n// DWARFDeclContext\n//\n// A class that represents a declaration context all the way down to a\n// DIE. This is useful when trying to find a DIE in one DWARF to a DIE\n// in another DWARF file.\n\nclass DWARFDeclContext {\npublic:\n  struct Entry {\n    Entry() : tag(llvm::dwarf::DW_TAG_null), name(nullptr) {}\n    Entry(dw_tag_t t, const char *n) : tag(t), name(n) {}\n\n    bool NameMatches(const Entry &rhs) const {\n      if (name == rhs.name)\n        return true;\n      else if (name && rhs.name)\n        return strcmp(name, rhs.name) == 0;\n      return false;\n    }\n\n    // Test operator\n    explicit operator bool() const { return tag != 0; }\n\n    dw_tag_t tag;\n    const char *name;\n  };\n\n  DWARFDeclContext() : m_entries(), m_language(lldb::eLanguageTypeUnknown) {}\n\n  void AppendDeclContext(dw_tag_t tag, const char *name) {\n    m_entries.push_back(Entry(tag, name));\n  }\n\n  bool operator==(const DWARFDeclContext &rhs) const;\n  bool operator!=(const DWARFDeclContext &rhs) const { return !(*this == rhs); }\n\n  uint32_t GetSize() const { return m_entries.size(); }\n\n  Entry &operator[](uint32_t idx) {\n    // \"idx\" must be valid\n    return m_entries[idx];\n  }\n\n  const Entry &operator[](uint32_t idx) const {\n    // \"idx\" must be valid\n    return m_entries[idx];\n  }\n\n  const char *GetQualifiedName() const;\n\n  // Same as GetQualifiedName, but the life time of the returned string will\n  // be that of the LLDB session.\n  lldb_private::ConstString GetQualifiedNameAsConstString() const {\n    return lldb_private::ConstString(GetQualifiedName());\n  }\n\n  void Clear() {\n    m_entries.clear();\n    m_qualified_name.clear();\n  }\n\n  lldb::LanguageType GetLanguage() const { return m_language; }\n\n  void SetLanguage(lldb::LanguageType language) { m_language = language; }\n\nprotected:\n  typedef std::vector<Entry> collection;\n  collection m_entries;\n  mutable std::string m_qualified_name;\n  lldb::LanguageType m_language;\n};\n\n#endif // LLDB_SOURCE_PLUGINS_SYMBOLFILE_DWARF_DWARFDECLCONTEXT_H\n"}, "112": {"id": 112, "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/SymbolFile/DWARF/DWARFFormValue.h", "content": "//===-- DWARFFormValue.h ----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SOURCE_PLUGINS_SYMBOLFILE_DWARF_DWARFFORMVALUE_H\n#define LLDB_SOURCE_PLUGINS_SYMBOLFILE_DWARF_DWARFFORMVALUE_H\n\n#include \"DWARFDataExtractor.h\"\n#include <stddef.h>\n#include \"llvm/ADT/Optional.h\"\n\nclass DWARFUnit;\nclass SymbolFileDWARF;\nclass DWARFDIE;\n\nclass DWARFFormValue {\npublic:\n  typedef struct ValueTypeTag {\n    ValueTypeTag() : value(), data(nullptr) { value.uval = 0; }\n\n    union {\n      uint64_t uval;\n      int64_t sval;\n      const char *cstr;\n    } value;\n    const uint8_t *data;\n  } ValueType;\n\n  enum {\n    eValueTypeInvalid = 0,\n    eValueTypeUnsigned,\n    eValueTypeSigned,\n    eValueTypeCStr,\n    eValueTypeBlock\n  };\n\n  DWARFFormValue() = default;\n  DWARFFormValue(const DWARFUnit *unit) : m_unit(unit) {}\n  DWARFFormValue(const DWARFUnit *unit, dw_form_t form)\n      : m_unit(unit), m_form(form) {}\n  const DWARFUnit *GetUnit() const { return m_unit; }\n  void SetUnit(const DWARFUnit *unit) { m_unit = unit; }\n  dw_form_t Form() const { return m_form; }\n  dw_form_t& FormRef() { return m_form; }\n  void SetForm(dw_form_t form) { m_form = form; }\n  const ValueType &Value() const { return m_value; }\n  ValueType &ValueRef() { return m_value; }\n  void SetValue(const ValueType &val) { m_value = val; }\n\n  void Dump(lldb_private::Stream &s) const;\n  bool ExtractValue(const lldb_private::DWARFDataExtractor &data,\n                    lldb::offset_t *offset_ptr);\n  const uint8_t *BlockData() const;\n  static llvm::Optional<uint8_t> GetFixedSize(dw_form_t form,\n                                              const DWARFUnit *u);\n  llvm::Optional<uint8_t> GetFixedSize() const;\n  DWARFDIE Reference() const;\n  uint64_t Reference(dw_offset_t offset) const;\n  bool Boolean() const { return m_value.value.uval != 0; }\n  uint64_t Unsigned() const { return m_value.value.uval; }\n  void SetUnsigned(uint64_t uval) { m_value.value.uval = uval; }\n  int64_t Signed() const { return m_value.value.sval; }\n  void SetSigned(int64_t sval) { m_value.value.sval = sval; }\n  const char *AsCString() const;\n  dw_addr_t Address() const;\n  bool IsValid() const { return m_form != 0; }\n  bool SkipValue(const lldb_private::DWARFDataExtractor &debug_info_data,\n                 lldb::offset_t *offset_ptr) const;\n  static bool SkipValue(const dw_form_t form,\n                        const lldb_private::DWARFDataExtractor &debug_info_data,\n                        lldb::offset_t *offset_ptr, const DWARFUnit *unit);\n  static bool IsBlockForm(const dw_form_t form);\n  static bool IsDataForm(const dw_form_t form);\n  static int Compare(const DWARFFormValue &a, const DWARFFormValue &b);\n  void Clear();\n  static bool FormIsSupported(dw_form_t form);\n\nprotected:\n  // Compile unit where m_value was located.\n  // It may be different from compile unit where m_value refers to.\n  const DWARFUnit *m_unit = nullptr; // Unit for this form\n  dw_form_t m_form = 0;              // Form for this value\n  ValueType m_value;            // Contains all data for the form\n};\n\n#endif // LLDB_SOURCE_PLUGINS_SYMBOLFILE_DWARF_DWARFFORMVALUE_H\n"}, "113": {"id": 113, "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/SymbolFile/DWARF/DWARFTypeUnit.h", "content": "//===-- DWARFTypeUnit.h -----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SOURCE_PLUGINS_SYMBOLFILE_DWARF_DWARFTYPEUNIT_H\n#define LLDB_SOURCE_PLUGINS_SYMBOLFILE_DWARF_DWARFTYPEUNIT_H\n\n#include \"DWARFUnit.h\"\n#include \"llvm/Support/Error.h\"\n\nclass DWARFTypeUnit : public DWARFUnit {\npublic:\n  void BuildAddressRangeTable(DWARFDebugAranges *debug_aranges) override {}\n\n  void Dump(lldb_private::Stream *s) const override;\n\n  uint64_t GetTypeHash() { return m_header.GetTypeHash(); }\n\n  dw_offset_t GetTypeOffset() { return GetOffset() + m_header.GetTypeOffset(); }\n\n  static bool classof(const DWARFUnit *unit) { return unit->IsTypeUnit(); }\n\nprivate:\n  DWARFTypeUnit(SymbolFileDWARF &dwarf, lldb::user_id_t uid,\n                const DWARFUnitHeader &header,\n                const DWARFAbbreviationDeclarationSet &abbrevs,\n                DIERef::Section section, bool is_dwo)\n      : DWARFUnit(dwarf, uid, header, abbrevs, section, is_dwo) {}\n\n  friend class DWARFUnit;\n};\n\n#endif // LLDB_SOURCE_PLUGINS_SYMBOLFILE_DWARF_DWARFTYPEUNIT_H\n"}, "114": {"id": 114, "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/SymbolFile/DWARF/DWARFUnit.h", "content": "//===-- DWARFUnit.h ---------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SOURCE_PLUGINS_SYMBOLFILE_DWARF_DWARFUNIT_H\n#define LLDB_SOURCE_PLUGINS_SYMBOLFILE_DWARF_DWARFUNIT_H\n\n#include \"DWARFDIE.h\"\n#include \"DWARFDebugInfoEntry.h\"\n#include \"lldb/lldb-enumerations.h\"\n#include \"lldb/Utility/XcodeSDK.h\"\n#include \"llvm/Support/RWMutex.h\"\n#include <atomic>\n\nclass DWARFUnit;\nclass DWARFCompileUnit;\nclass NameToDIE;\nclass SymbolFileDWARF;\nclass SymbolFileDWARFDwo;\n\ntypedef std::shared_ptr<DWARFUnit> DWARFUnitSP;\n\nenum DWARFProducer {\n  eProducerInvalid = 0,\n  eProducerClang,\n  eProducerGCC,\n  eProducerLLVMGCC,\n  eProcucerOther\n};\n\n/// Base class describing the header of any kind of \"unit.\"  Some information\n/// is specific to certain unit types.  We separate this class out so we can\n/// parse the header before deciding what specific kind of unit to construct.\nclass DWARFUnitHeader {\n  dw_offset_t m_offset = 0;\n  dw_offset_t m_length = 0;\n  uint16_t m_version = 0;\n  dw_offset_t m_abbr_offset = 0;\n\n  const llvm::DWARFUnitIndex::Entry *m_index_entry = nullptr;\n\n  uint8_t m_unit_type = 0;\n  uint8_t m_addr_size = 0;\n\n  uint64_t m_type_hash = 0;\n  uint32_t m_type_offset = 0;\n\n  uint64_t m_dwo_id = 0;\n\n  DWARFUnitHeader() = default;\n\npublic:\n  dw_offset_t GetOffset() const { return m_offset; }\n  uint16_t GetVersion() const { return m_version; }\n  uint16_t GetAddressByteSize() const { return m_addr_size; }\n  dw_offset_t GetLength() const { return m_length; }\n  dw_offset_t GetAbbrOffset() const { return m_abbr_offset; }\n  uint8_t GetUnitType() const { return m_unit_type; }\n  const llvm::DWARFUnitIndex::Entry *GetIndexEntry() const {\n    return m_index_entry;\n  }\n  uint64_t GetTypeHash() const { return m_type_hash; }\n  dw_offset_t GetTypeOffset() const { return m_type_offset; }\n  uint64_t GetDWOId() const { return m_dwo_id; }\n  bool IsTypeUnit() const {\n    return m_unit_type == DW_UT_type || m_unit_type == DW_UT_split_type;\n  }\n  uint32_t GetNextUnitOffset() const { return m_offset + m_length + 4; }\n\n  static llvm::Expected<DWARFUnitHeader>\n  extract(const lldb_private::DWARFDataExtractor &data, DIERef::Section section,\n          lldb_private::DWARFContext &dwarf_context,\n          lldb::offset_t *offset_ptr);\n};\n\nclass DWARFUnit : public lldb_private::UserID {\n  using die_iterator_range =\n      llvm::iterator_range<DWARFDebugInfoEntry::collection::iterator>;\n\npublic:\n  static llvm::Expected<DWARFUnitSP>\n  extract(SymbolFileDWARF &dwarf2Data, lldb::user_id_t uid,\n          const lldb_private::DWARFDataExtractor &debug_info,\n          DIERef::Section section, lldb::offset_t *offset_ptr);\n  virtual ~DWARFUnit();\n\n  bool IsDWOUnit() { return m_is_dwo; }\n  uint64_t GetDWOId();\n\n  void ExtractUnitDIEIfNeeded();\n  void ExtractDIEsIfNeeded();\n\n  class ScopedExtractDIEs {\n    DWARFUnit *m_cu;\n  public:\n    bool m_clear_dies = false;\n    ScopedExtractDIEs(DWARFUnit &cu);\n    ~ScopedExtractDIEs();\n    ScopedExtractDIEs(const ScopedExtractDIEs &) = delete;\n    const ScopedExtractDIEs &operator=(const ScopedExtractDIEs &) = delete;\n    ScopedExtractDIEs(ScopedExtractDIEs &&rhs);\n    ScopedExtractDIEs &operator=(ScopedExtractDIEs &&rhs);\n  };\n  ScopedExtractDIEs ExtractDIEsScoped();\n\n  bool Verify(lldb_private::Stream *s) const;\n  virtual void Dump(lldb_private::Stream *s) const = 0;\n  /// Get the data that contains the DIE information for this unit.\n  ///\n  /// This will return the correct bytes that contain the data for\n  /// this DWARFUnit. It could be .debug_info or .debug_types\n  /// depending on where the data for this unit originates.\n  ///\n  /// \\return\n  ///   The correct data for the DIE information in this unit.\n  const lldb_private::DWARFDataExtractor &GetData() const;\n\n  /// Get the size in bytes of the unit header.\n  ///\n  /// \\return\n  ///     Byte size of the unit header\n  uint32_t GetHeaderByteSize() const;\n\n  // Offset of the initial length field.\n  dw_offset_t GetOffset() const { return m_header.GetOffset(); }\n  /// Get the size in bytes of the length field in the header.\n  ///\n  /// In DWARF32 this is just 4 bytes\n  ///\n  /// \\return\n  ///     Byte size of the compile unit header length field\n  size_t GetLengthByteSize() const { return 4; }\n\n  bool ContainsDIEOffset(dw_offset_t die_offset) const {\n    return die_offset >= GetFirstDIEOffset() &&\n           die_offset < GetNextUnitOffset();\n  }\n  dw_offset_t GetFirstDIEOffset() const {\n    return GetOffset() + GetHeaderByteSize();\n  }\n  dw_offset_t GetNextUnitOffset() const { return m_header.GetNextUnitOffset(); }\n  // Size of the CU data (without initial length and without header).\n  size_t GetDebugInfoSize() const;\n  // Size of the CU data incl. header but without initial length.\n  uint32_t GetLength() const { return m_header.GetLength(); }\n  uint16_t GetVersion() const { return m_header.GetVersion(); }\n  const DWARFAbbreviationDeclarationSet *GetAbbreviations() const;\n  dw_offset_t GetAbbrevOffset() const;\n  uint8_t GetAddressByteSize() const { return m_header.GetAddressByteSize(); }\n  dw_addr_t GetAddrBase() const { return m_addr_base; }\n  dw_addr_t GetBaseAddress() const { return m_base_addr; }\n  dw_offset_t GetLineTableOffset();\n  dw_addr_t GetRangesBase() const { return m_ranges_base; }\n  dw_addr_t GetStrOffsetsBase() const { return m_str_offsets_base; }\n  void SetAddrBase(dw_addr_t addr_base);\n  void SetLoclistsBase(dw_addr_t loclists_base);\n  void SetRangesBase(dw_addr_t ranges_base);\n  void SetStrOffsetsBase(dw_offset_t str_offsets_base);\n  virtual void BuildAddressRangeTable(DWARFDebugAranges *debug_aranges) = 0;\n\n  lldb::ByteOrder GetByteOrder() const;\n\n  const DWARFDebugAranges &GetFunctionAranges();\n\n  void SetBaseAddress(dw_addr_t base_addr);\n\n  DWARFBaseDIE GetUnitDIEOnly() { return {this, GetUnitDIEPtrOnly()}; }\n\n  DWARFDIE DIE() { return DWARFDIE(this, DIEPtr()); }\n\n  DWARFDIE GetDIE(dw_offset_t die_offset);\n\n  DWARFUnit &GetNonSkeletonUnit();\n\n  static uint8_t GetAddressByteSize(const DWARFUnit *cu);\n\n  static uint8_t GetDefaultAddressSize();\n\n  void *GetUserData() const;\n\n  void SetUserData(void *d);\n\n  bool Supports_DW_AT_APPLE_objc_complete_type();\n\n  bool DW_AT_decl_file_attributes_are_invalid();\n\n  bool Supports_unnamed_objc_bitfields();\n\n  SymbolFileDWARF &GetSymbolFileDWARF() const { return m_dwarf; }\n\n  DWARFProducer GetProducer();\n\n  uint32_t GetProducerVersionMajor();\n\n  uint32_t GetProducerVersionMinor();\n\n  uint32_t GetProducerVersionUpdate();\n\n  uint64_t GetDWARFLanguageType();\n\n  bool GetIsOptimized();\n\n  const lldb_private::FileSpec &GetCompilationDirectory();\n  const lldb_private::FileSpec &GetAbsolutePath();\n  lldb_private::FileSpec GetFile(size_t file_idx);\n  lldb_private::FileSpec::Style GetPathStyle();\n\n  SymbolFileDWARFDwo *GetDwoSymbolFile();\n\n  die_iterator_range dies() {\n    ExtractDIEsIfNeeded();\n    return die_iterator_range(m_die_array.begin(), m_die_array.end());\n  }\n\n  DIERef::Section GetDebugSection() const { return m_section; }\n\n  uint8_t GetUnitType() const { return m_header.GetUnitType(); }\n  bool IsTypeUnit() const { return m_header.IsTypeUnit(); }\n\n  llvm::Optional<uint64_t> GetStringOffsetSectionItem(uint32_t index) const;\n\n  /// Return a list of address ranges resulting from a (possibly encoded)\n  /// range list starting at a given offset in the appropriate ranges section.\n  llvm::Expected<DWARFRangeList> FindRnglistFromOffset(dw_offset_t offset);\n\n  /// Return a list of address ranges retrieved from an encoded range\n  /// list whose offset is found via a table lookup given an index (DWARF v5\n  /// and later).\n  llvm::Expected<DWARFRangeList> FindRnglistFromIndex(uint32_t index);\n\n  /// Return a rangelist's offset based on an index. The index designates\n  /// an entry in the rangelist table's offset array and is supplied by\n  /// DW_FORM_rnglistx.\n  llvm::Optional<uint64_t> GetRnglistOffset(uint32_t Index) const {\n    if (!m_rnglist_table)\n      return llvm::None;\n    if (llvm::Optional<uint64_t> off = m_rnglist_table->getOffsetEntry(\n            m_dwarf.GetDWARFContext().getOrLoadRngListsData().GetAsLLVM(),\n            Index))\n      return *off + m_ranges_base;\n    return llvm::None;\n  }\n\n  llvm::Optional<uint64_t> GetLoclistOffset(uint32_t Index) {\n    if (!m_loclist_table_header)\n      return llvm::None;\n\n    llvm::Optional<uint64_t> Offset = m_loclist_table_header->getOffsetEntry(\n        m_dwarf.GetDWARFContext().getOrLoadLocListsData().GetAsLLVM(), Index);\n    if (!Offset)\n      return llvm::None;\n    return *Offset + m_loclists_base;\n  }\n\n  /// Return the location table for parsing the given location list data. The\n  /// format is chosen according to the unit type. Never returns null.\n  std::unique_ptr<llvm::DWARFLocationTable>\n  GetLocationTable(const lldb_private::DataExtractor &data) const;\n\n  lldb_private::DWARFDataExtractor GetLocationData() const;\n\nprotected:\n  DWARFUnit(SymbolFileDWARF &dwarf, lldb::user_id_t uid,\n            const DWARFUnitHeader &header,\n            const DWARFAbbreviationDeclarationSet &abbrevs,\n            DIERef::Section section, bool is_dwo);\n\n  llvm::Error ExtractHeader(SymbolFileDWARF &dwarf,\n                            const lldb_private::DWARFDataExtractor &data,\n                            lldb::offset_t *offset_ptr);\n\n  // Get the DWARF unit DWARF debug information entry. Parse the single DIE\n  // if needed.\n  const DWARFDebugInfoEntry *GetUnitDIEPtrOnly() {\n    ExtractUnitDIEIfNeeded();\n    // m_first_die_mutex is not required as m_first_die is never cleared.\n    if (!m_first_die)\n      return NULL;\n    return &m_first_die;\n  }\n\n  // Get all DWARF debug informration entries. Parse all DIEs if needed.\n  const DWARFDebugInfoEntry *DIEPtr() {\n    ExtractDIEsIfNeeded();\n    if (m_die_array.empty())\n      return NULL;\n    return &m_die_array[0];\n  }\n\n  SymbolFileDWARF &m_dwarf;\n  std::shared_ptr<DWARFUnit> m_dwo;\n  DWARFUnitHeader m_header;\n  const DWARFAbbreviationDeclarationSet *m_abbrevs = nullptr;\n  void *m_user_data = nullptr;\n  // The compile unit debug information entry item\n  DWARFDebugInfoEntry::collection m_die_array;\n  mutable llvm::sys::RWMutex m_die_array_mutex;\n  // It is used for tracking of ScopedExtractDIEs instances.\n  mutable llvm::sys::RWMutex m_die_array_scoped_mutex;\n  // ScopedExtractDIEs instances should not call ClearDIEsRWLocked()\n  // as someone called ExtractDIEsIfNeeded().\n  std::atomic<bool> m_cancel_scopes;\n  // GetUnitDIEPtrOnly() needs to return pointer to the first DIE.\n  // But the first element of m_die_array after ExtractUnitDIEIfNeeded()\n  // would possibly move in memory after later ExtractDIEsIfNeeded().\n  DWARFDebugInfoEntry m_first_die;\n  llvm::sys::RWMutex m_first_die_mutex;\n  // A table similar to the .debug_aranges table, but this one points to the\n  // exact DW_TAG_subprogram DIEs\n  std::unique_ptr<DWARFDebugAranges> m_func_aranges_up;\n  dw_addr_t m_base_addr = 0;\n  DWARFProducer m_producer = eProducerInvalid;\n  uint32_t m_producer_version_major = 0;\n  uint32_t m_producer_version_minor = 0;\n  uint32_t m_producer_version_update = 0;\n  llvm::Optional<uint64_t> m_language_type;\n  lldb_private::LazyBool m_is_optimized = lldb_private::eLazyBoolCalculate;\n  llvm::Optional<lldb_private::FileSpec> m_comp_dir;\n  llvm::Optional<lldb_private::FileSpec> m_file_spec;\n  dw_addr_t m_addr_base = 0;     ///< Value of DW_AT_addr_base.\n  dw_addr_t m_loclists_base = 0; ///< Value of DW_AT_loclists_base.\n  dw_addr_t m_ranges_base = 0;   ///< Value of DW_AT_rnglists_base.\n\n  /// Value of DW_AT_stmt_list.\n  dw_offset_t m_line_table_offset = DW_INVALID_OFFSET;\n\n  dw_offset_t m_str_offsets_base = 0; // Value of DW_AT_str_offsets_base.\n\n  llvm::Optional<llvm::DWARFDebugRnglistTable> m_rnglist_table;\n  llvm::Optional<llvm::DWARFListTableHeader> m_loclist_table_header;\n\n  const DIERef::Section m_section;\n  bool m_is_dwo;\n  /// Value of DW_AT_GNU_dwo_id (v4) or dwo_id from CU header (v5).\n  uint64_t m_dwo_id;\n\nprivate:\n  void ParseProducerInfo();\n  void ExtractDIEsRWLocked();\n  void ClearDIEsRWLocked();\n\n  void AddUnitDIE(const DWARFDebugInfoEntry &cu_die);\n  void SetDwoStrOffsetsBase();\n\n  void ComputeCompDirAndGuessPathStyle();\n  void ComputeAbsolutePath();\n\n  DWARFUnit(const DWARFUnit &) = delete;\n  const DWARFUnit &operator=(const DWARFUnit &) = delete;\n};\n\n#endif // LLDB_SOURCE_PLUGINS_SYMBOLFILE_DWARF_DWARFUNIT_H\n"}, "115": {"id": 115, "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/SymbolFile/DWARF/DebugNamesDWARFIndex.h", "content": "//===-- DebugNamesDWARFIndex.h ---------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SOURCE_PLUGINS_SYMBOLFILE_DWARF_DEBUGNAMESDWARFINDEX_H\n#define LLDB_SOURCE_PLUGINS_SYMBOLFILE_DWARF_DEBUGNAMESDWARFINDEX_H\n\n#include \"Plugins/SymbolFile/DWARF/DWARFIndex.h\"\n#include \"Plugins/SymbolFile/DWARF/LogChannelDWARF.h\"\n#include \"Plugins/SymbolFile/DWARF/ManualDWARFIndex.h\"\n#include \"Plugins/SymbolFile/DWARF/SymbolFileDWARF.h\"\n#include \"lldb/Utility/ConstString.h\"\n#include \"llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h\"\n\nnamespace lldb_private {\nclass DebugNamesDWARFIndex : public DWARFIndex {\npublic:\n  static llvm::Expected<std::unique_ptr<DebugNamesDWARFIndex>>\n  Create(Module &module, DWARFDataExtractor debug_names,\n         DWARFDataExtractor debug_str, SymbolFileDWARF &dwarf);\n\n  void Preload() override { m_fallback.Preload(); }\n\n  void\n  GetGlobalVariables(ConstString basename,\n                     llvm::function_ref<bool(DWARFDIE die)> callback) override;\n  void\n  GetGlobalVariables(const RegularExpression &regex,\n                     llvm::function_ref<bool(DWARFDIE die)> callback) override;\n  void\n  GetGlobalVariables(const DWARFUnit &cu,\n                     llvm::function_ref<bool(DWARFDIE die)> callback) override;\n  void\n  GetObjCMethods(ConstString class_name,\n                 llvm::function_ref<bool(DWARFDIE die)> callback) override {}\n  void GetCompleteObjCClass(\n      ConstString class_name, bool must_be_implementation,\n      llvm::function_ref<bool(DWARFDIE die)> callback) override;\n  void GetTypes(ConstString name,\n                llvm::function_ref<bool(DWARFDIE die)> callback) override;\n  void GetTypes(const DWARFDeclContext &context,\n                llvm::function_ref<bool(DWARFDIE die)> callback) override;\n  void GetNamespaces(ConstString name,\n                     llvm::function_ref<bool(DWARFDIE die)> callback) override;\n  void GetFunctions(ConstString name, SymbolFileDWARF &dwarf,\n                    const CompilerDeclContext &parent_decl_ctx,\n                    uint32_t name_type_mask,\n                    llvm::function_ref<bool(DWARFDIE die)> callback) override;\n  void GetFunctions(const RegularExpression &regex,\n                    llvm::function_ref<bool(DWARFDIE die)> callback) override;\n\n  void Dump(Stream &s) override;\n\nprivate:\n  DebugNamesDWARFIndex(Module &module,\n                       std::unique_ptr<llvm::DWARFDebugNames> debug_names_up,\n                       DWARFDataExtractor debug_names_data,\n                       DWARFDataExtractor debug_str_data,\n                       SymbolFileDWARF &dwarf)\n      : DWARFIndex(module), m_debug_info(dwarf.DebugInfo()),\n        m_debug_names_data(debug_names_data), m_debug_str_data(debug_str_data),\n        m_debug_names_up(std::move(debug_names_up)),\n        m_fallback(module, dwarf, GetUnits(*m_debug_names_up)) {}\n\n  DWARFDebugInfo &m_debug_info;\n\n  // LLVM DWARFDebugNames will hold a non-owning reference to this data, so keep\n  // track of the ownership here.\n  DWARFDataExtractor m_debug_names_data;\n  DWARFDataExtractor m_debug_str_data;\n\n  using DebugNames = llvm::DWARFDebugNames;\n  std::unique_ptr<DebugNames> m_debug_names_up;\n  ManualDWARFIndex m_fallback;\n\n  llvm::Optional<DIERef> ToDIERef(const DebugNames::Entry &entry);\n  bool ProcessEntry(const DebugNames::Entry &entry,\n                    llvm::function_ref<bool(DWARFDIE die)> callback,\n                    llvm::StringRef name);\n\n  static void MaybeLogLookupError(llvm::Error error,\n                                  const DebugNames::NameIndex &ni,\n                                  llvm::StringRef name);\n\n  static llvm::DenseSet<dw_offset_t> GetUnits(const DebugNames &debug_names);\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_SOURCE_PLUGINS_SYMBOLFILE_DWARF_DEBUGNAMESDWARFINDEX_H\n"}, "116": {"id": 116, "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/SymbolFile/DWARF/HashedNameToDIE.h", "content": "//===-- HashedNameToDIE.h ---------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SOURCE_PLUGINS_SYMBOLFILE_DWARF_HASHEDNAMETODIE_H\n#define LLDB_SOURCE_PLUGINS_SYMBOLFILE_DWARF_HASHEDNAMETODIE_H\n\n#include <vector>\n\n#include \"lldb/Core/MappedHash.h\"\n#include \"lldb/Core/dwarf.h\"\n#include \"lldb/Utility/RegularExpression.h\"\n#include \"lldb/lldb-defines.h\"\n\n#include \"DWARFDefines.h\"\n#include \"DWARFFormValue.h\"\n#include \"NameToDIE.h\"\n\nclass DWARFMappedHash {\npublic:\n  enum AtomType : uint16_t {\n    eAtomTypeNULL = 0u,\n    /// DIE offset, check form for encoding.\n    eAtomTypeDIEOffset = 1u,\n    /// DIE offset of the compiler unit header that contains the item in\n    /// question.\n    eAtomTypeCUOffset = 2u,\n    /// DW_TAG_xxx value, should be encoded as DW_FORM_data1 (if no tags exceed\n    /// 255) or DW_FORM_data2.\n    eAtomTypeTag = 3u,\n    // Flags from enum NameFlags.\n    eAtomTypeNameFlags = 4u,\n    // Flags from enum TypeFlags.\n    eAtomTypeTypeFlags = 5u,\n    /// A 32 bit hash of the full qualified name (since all hash entries are\n    /// basename only) For example a type like \"std::vector<int>::iterator\"\n    /// would have a name of \"iterator\" and a 32 bit hash for\n    /// \"std::vector<int>::iterator\" to allow us to not have to pull in debug\n    /// info for a type when we know the fully qualified name.\n    eAtomTypeQualNameHash = 6u\n  };\n\n  /// Bit definitions for the eAtomTypeTypeFlags flags.\n  enum TypeFlags {\n    /// Always set for C++, only set for ObjC if this is the\n    /// @implementation for class.\n    eTypeFlagClassIsImplementation = (1u << 1)\n  };\n\n  struct DIEInfo {\n    dw_offset_t die_offset = DW_INVALID_OFFSET;\n    dw_tag_t tag = llvm::dwarf::DW_TAG_null;\n\n    /// Any flags for this DIEInfo.\n    uint32_t type_flags = 0;\n\n    /// A 32 bit hash of the fully qualified name.\n    uint32_t qualified_name_hash = 0;\n\n    DIEInfo() = default;\n    DIEInfo(dw_offset_t o, dw_tag_t t, uint32_t f, uint32_t h);\n\n    explicit operator DIERef() const {\n      return DIERef(llvm::None, DIERef::Section::DebugInfo, die_offset);\n    }\n  };\n\n  struct Atom {\n    AtomType type;\n    dw_form_t form;\n  };\n\n  typedef std::vector<DIEInfo> DIEInfoArray;\n  typedef std::vector<Atom> AtomArray;\n\n  class Prologue {\n  public:\n    Prologue(dw_offset_t _die_base_offset = 0);\n\n    void ClearAtoms();\n\n    bool ContainsAtom(AtomType atom_type) const;\n\n    void Clear();\n\n    void AppendAtom(AtomType type, dw_form_t form);\n\n    lldb::offset_t Read(const lldb_private::DataExtractor &data,\n                        lldb::offset_t offset);\n\n    size_t GetByteSize() const;\n\n    size_t GetMinimumHashDataByteSize() const;\n\n    bool HashDataHasFixedByteSize() const;\n\n    /// DIE offset base so die offsets in hash_data can be CU relative.\n    dw_offset_t die_base_offset;\n    AtomArray atoms;\n    uint32_t atom_mask;\n    size_t min_hash_data_byte_size;\n    bool hash_data_has_fixed_byte_size;\n  };\n\n  class Header : public MappedHash::Header<Prologue> {\n  public:\n    size_t GetByteSize(const HeaderData &header_data) override;\n\n    lldb::offset_t Read(lldb_private::DataExtractor &data,\n                        lldb::offset_t offset) override;\n\n    bool Read(const lldb_private::DWARFDataExtractor &data,\n              lldb::offset_t *offset_ptr, DIEInfo &hash_data) const;\n  };\n\n  /// A class for reading and using a saved hash table from a block of data in\n  /// memory.\n  class MemoryTable\n      : public MappedHash::MemoryTable<uint32_t, DWARFMappedHash::Header,\n                                       DIEInfoArray> {\n  public:\n    MemoryTable(lldb_private::DWARFDataExtractor &table_data,\n                const lldb_private::DWARFDataExtractor &string_table,\n                const char *name);\n\n    const char *GetStringForKeyType(KeyType key) const override;\n\n    bool ReadHashData(uint32_t hash_data_offset,\n                      HashData &hash_data) const override;\n\n    void\n    AppendAllDIEsThatMatchingRegex(const lldb_private::RegularExpression &regex,\n                                   DIEInfoArray &die_info_array) const;\n\n    void AppendAllDIEsInRange(const uint32_t die_offset_start,\n                              const uint32_t die_offset_end,\n                              DIEInfoArray &die_info_array) const;\n\n    bool FindByName(llvm::StringRef name,\n                    llvm::function_ref<bool(DIERef ref)> callback);\n\n    void FindByNameAndTag(llvm::StringRef name, const dw_tag_t tag,\n                          llvm::function_ref<bool(DIERef ref)> callback);\n\n    void FindByNameAndTagAndQualifiedNameHash(\n        llvm::StringRef name, const dw_tag_t tag,\n        const uint32_t qualified_name_hash,\n        llvm::function_ref<bool(DIERef ref)> callback);\n\n    void\n    FindCompleteObjCClassByName(llvm::StringRef name,\n                                llvm::function_ref<bool(DIERef ref)> callback,\n                                bool must_be_implementation);\n\n  protected:\n    Result AppendHashDataForRegularExpression(\n        const lldb_private::RegularExpression &regex,\n        lldb::offset_t *hash_data_offset_ptr, Pair &pair) const;\n\n    void FindByName(llvm::StringRef name, DIEInfoArray &die_info_array);\n\n    Result GetHashDataForName(llvm::StringRef name,\n                              lldb::offset_t *hash_data_offset_ptr,\n                              Pair &pair) const override;\n\n    lldb_private::DWARFDataExtractor m_data;\n    lldb_private::DWARFDataExtractor m_string_table;\n    std::string m_name;\n  };\n\n  static bool ExtractDIEArray(const DIEInfoArray &die_info_array,\n                              llvm::function_ref<bool(DIERef ref)> callback);\n\nprotected:\n  static void ExtractDIEArray(const DIEInfoArray &die_info_array,\n                              const dw_tag_t tag,\n                              llvm::function_ref<bool(DIERef ref)> callback);\n\n  static void ExtractDIEArray(const DIEInfoArray &die_info_array,\n                              const dw_tag_t tag,\n                              const uint32_t qualified_name_hash,\n                              llvm::function_ref<bool(DIERef ref)> callback);\n\n  static void\n  ExtractClassOrStructDIEArray(const DIEInfoArray &die_info_array,\n                               bool return_implementation_only_if_available,\n                               llvm::function_ref<bool(DIERef ref)> callback);\n\n  static void\n  ExtractTypesFromDIEArray(const DIEInfoArray &die_info_array,\n                           uint32_t type_flag_mask, uint32_t type_flag_value,\n                           llvm::function_ref<bool(DIERef ref)> callback);\n\n  static const char *GetAtomTypeName(uint16_t atom);\n};\n\n#endif // LLDB_SOURCE_PLUGINS_SYMBOLFILE_DWARF_HASHEDNAMETODIE_H\n"}, "117": {"id": 117, "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/SymbolFile/DWARF/ManualDWARFIndex.h", "content": "//===-- ManualDWARFIndex.h --------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SOURCE_PLUGINS_SYMBOLFILE_DWARF_MANUALDWARFINDEX_H\n#define LLDB_SOURCE_PLUGINS_SYMBOLFILE_DWARF_MANUALDWARFINDEX_H\n\n#include \"Plugins/SymbolFile/DWARF/DWARFIndex.h\"\n#include \"Plugins/SymbolFile/DWARF/NameToDIE.h\"\n#include \"llvm/ADT/DenseSet.h\"\n\nclass DWARFDebugInfo;\nclass SymbolFileDWARFDwo;\n\nnamespace lldb_private {\nclass ManualDWARFIndex : public DWARFIndex {\npublic:\n  ManualDWARFIndex(Module &module, SymbolFileDWARF &dwarf,\n                   llvm::DenseSet<dw_offset_t> units_to_avoid = {})\n      : DWARFIndex(module), m_dwarf(&dwarf),\n        m_units_to_avoid(std::move(units_to_avoid)) {}\n\n  void Preload() override { Index(); }\n\n  void\n  GetGlobalVariables(ConstString basename,\n                     llvm::function_ref<bool(DWARFDIE die)> callback) override;\n  void\n  GetGlobalVariables(const RegularExpression &regex,\n                     llvm::function_ref<bool(DWARFDIE die)> callback) override;\n  void\n  GetGlobalVariables(const DWARFUnit &unit,\n                     llvm::function_ref<bool(DWARFDIE die)> callback) override;\n  void GetObjCMethods(ConstString class_name,\n                      llvm::function_ref<bool(DWARFDIE die)> callback) override;\n  void GetCompleteObjCClass(\n      ConstString class_name, bool must_be_implementation,\n      llvm::function_ref<bool(DWARFDIE die)> callback) override;\n  void GetTypes(ConstString name,\n                llvm::function_ref<bool(DWARFDIE die)> callback) override;\n  void GetTypes(const DWARFDeclContext &context,\n                llvm::function_ref<bool(DWARFDIE die)> callback) override;\n  void GetNamespaces(ConstString name,\n                     llvm::function_ref<bool(DWARFDIE die)> callback) override;\n  void GetFunctions(ConstString name, SymbolFileDWARF &dwarf,\n                    const CompilerDeclContext &parent_decl_ctx,\n                    uint32_t name_type_mask,\n                    llvm::function_ref<bool(DWARFDIE die)> callback) override;\n  void GetFunctions(const RegularExpression &regex,\n                    llvm::function_ref<bool(DWARFDIE die)> callback) override;\n\n  void Dump(Stream &s) override;\n\nprivate:\n  struct IndexSet {\n    NameToDIE function_basenames;\n    NameToDIE function_fullnames;\n    NameToDIE function_methods;\n    NameToDIE function_selectors;\n    NameToDIE objc_class_selectors;\n    NameToDIE globals;\n    NameToDIE types;\n    NameToDIE namespaces;\n  };\n  void Index();\n  void IndexUnit(DWARFUnit &unit, SymbolFileDWARFDwo *dwp, IndexSet &set);\n\n  static void IndexUnitImpl(DWARFUnit &unit,\n                            const lldb::LanguageType cu_language,\n                            IndexSet &set);\n\n  /// The DWARF file which we are indexing. Set to nullptr after the index is\n  /// built.\n  SymbolFileDWARF *m_dwarf;\n  /// Which dwarf units should we skip while building the index.\n  llvm::DenseSet<dw_offset_t> m_units_to_avoid;\n\n  IndexSet m_set;\n};\n} // namespace lldb_private\n\n#endif // LLDB_SOURCE_PLUGINS_SYMBOLFILE_DWARF_MANUALDWARFINDEX_H\n"}, "118": {"id": 118, "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/SymbolFile/DWARF/SymbolFileDWARF.cpp", "content": "//===-- SymbolFileDWARF.cpp -----------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include \"SymbolFileDWARF.h\"\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Threading.h\"\n\n#include \"lldb/Core/Module.h\"\n#include \"lldb/Core/ModuleList.h\"\n#include \"lldb/Core/ModuleSpec.h\"\n#include \"lldb/Core/PluginManager.h\"\n#include \"lldb/Core/Section.h\"\n#include \"lldb/Core/StreamFile.h\"\n#include \"lldb/Core/Value.h\"\n#include \"lldb/Utility/ArchSpec.h\"\n#include \"lldb/Utility/RegularExpression.h\"\n#include \"lldb/Utility/Scalar.h\"\n#include \"lldb/Utility/StreamString.h\"\n#include \"lldb/Utility/Timer.h\"\n\n#include \"Plugins/ExpressionParser/Clang/ClangModulesDeclVendor.h\"\n#include \"Plugins/Language/CPlusPlus/CPlusPlusLanguage.h\"\n\n#include \"lldb/Host/FileSystem.h\"\n#include \"lldb/Host/Host.h\"\n\n#include \"lldb/Interpreter/OptionValueFileSpecList.h\"\n#include \"lldb/Interpreter/OptionValueProperties.h\"\n\n#include \"Plugins/ExpressionParser/Clang/ClangUtil.h\"\n#include \"Plugins/SymbolFile/DWARF/DWARFDebugInfoEntry.h\"\n#include \"Plugins/TypeSystem/Clang/TypeSystemClang.h\"\n#include \"lldb/Symbol/Block.h\"\n#include \"lldb/Symbol/CompileUnit.h\"\n#include \"lldb/Symbol/CompilerDecl.h\"\n#include \"lldb/Symbol/CompilerDeclContext.h\"\n#include \"lldb/Symbol/DebugMacros.h\"\n#include \"lldb/Symbol/LineTable.h\"\n#include \"lldb/Symbol/LocateSymbolFile.h\"\n#include \"lldb/Symbol/ObjectFile.h\"\n#include \"lldb/Symbol/SymbolFile.h\"\n#include \"lldb/Symbol/TypeMap.h\"\n#include \"lldb/Symbol/TypeSystem.h\"\n#include \"lldb/Symbol/VariableList.h\"\n\n#include \"lldb/Target/Language.h\"\n#include \"lldb/Target/Target.h\"\n\n#include \"AppleDWARFIndex.h\"\n#include \"DWARFASTParser.h\"\n#include \"DWARFASTParserClang.h\"\n#include \"DWARFCompileUnit.h\"\n#include \"DWARFDebugAbbrev.h\"\n#include \"DWARFDebugAranges.h\"\n#include \"DWARFDebugInfo.h\"\n#include \"DWARFDebugMacro.h\"\n#include \"DWARFDebugRanges.h\"\n#include \"DWARFDeclContext.h\"\n#include \"DWARFFormValue.h\"\n#include \"DWARFTypeUnit.h\"\n#include \"DWARFUnit.h\"\n#include \"DebugNamesDWARFIndex.h\"\n#include \"LogChannelDWARF.h\"\n#include \"ManualDWARFIndex.h\"\n#include \"SymbolFileDWARFDebugMap.h\"\n#include \"SymbolFileDWARFDwo.h\"\n\n#include \"llvm/DebugInfo/DWARF/DWARFContext.h\"\n#include \"llvm/Support/FileSystem.h\"\n\n#include <algorithm>\n#include <map>\n#include <memory>\n\n#include <ctype.h>\n#include <string.h>\n\n//#define ENABLE_DEBUG_PRINTF // COMMENT OUT THIS LINE PRIOR TO CHECKIN\n\n#ifdef ENABLE_DEBUG_PRINTF\n#include <stdio.h>\n#define DEBUG_PRINTF(fmt, ...) printf(fmt, __VA_ARGS__)\n#else\n#define DEBUG_PRINTF(fmt, ...)\n#endif\n\nusing namespace lldb;\nusing namespace lldb_private;\n\nLLDB_PLUGIN_DEFINE(SymbolFileDWARF)\n\nchar SymbolFileDWARF::ID;\n\n// static inline bool\n// child_requires_parent_class_union_or_struct_to_be_completed (dw_tag_t tag)\n//{\n//    switch (tag)\n//    {\n//    default:\n//        break;\n//    case DW_TAG_subprogram:\n//    case DW_TAG_inlined_subroutine:\n//    case DW_TAG_class_type:\n//    case DW_TAG_structure_type:\n//    case DW_TAG_union_type:\n//        return true;\n//    }\n//    return false;\n//}\n//\n\nnamespace {\n\n#define LLDB_PROPERTIES_symbolfiledwarf\n#include \"SymbolFileDWARFProperties.inc\"\n\nenum {\n#define LLDB_PROPERTIES_symbolfiledwarf\n#include \"SymbolFileDWARFPropertiesEnum.inc\"\n};\n\nclass PluginProperties : public Properties {\npublic:\n  static ConstString GetSettingName() {\n    return SymbolFileDWARF::GetPluginNameStatic();\n  }\n\n  PluginProperties() {\n    m_collection_sp = std::make_shared<OptionValueProperties>(GetSettingName());\n    m_collection_sp->Initialize(g_symbolfiledwarf_properties);\n  }\n\n  bool IgnoreFileIndexes() const {\n    return m_collection_sp->GetPropertyAtIndexAsBoolean(\n        nullptr, ePropertyIgnoreIndexes, false);\n  }\n};\n\ntypedef std::shared_ptr<PluginProperties> SymbolFileDWARFPropertiesSP;\n\nstatic const SymbolFileDWARFPropertiesSP &GetGlobalPluginProperties() {\n  static const auto g_settings_sp(std::make_shared<PluginProperties>());\n  return g_settings_sp;\n}\n\n} // namespace\n\nstatic const llvm::DWARFDebugLine::LineTable *\nParseLLVMLineTable(lldb_private::DWARFContext &context,\n                   llvm::DWARFDebugLine &line, dw_offset_t line_offset,\n                   dw_offset_t unit_offset) {\n  Log *log = LogChannelDWARF::GetLogIfAll(DWARF_LOG_DEBUG_INFO);\n\n  llvm::DWARFDataExtractor data = context.getOrLoadLineData().GetAsLLVM();\n  llvm::DWARFContext &ctx = context.GetAsLLVM();\n  llvm::Expected<const llvm::DWARFDebugLine::LineTable *> line_table =\n      line.getOrParseLineTable(\n          data, line_offset, ctx, nullptr, [&](llvm::Error e) {\n            LLDB_LOG_ERROR(\n                log, std::move(e),\n                \"SymbolFileDWARF::ParseLineTable failed to parse: {0}\");\n          });\n\n  if (!line_table) {\n    LLDB_LOG_ERROR(log, line_table.takeError(),\n                   \"SymbolFileDWARF::ParseLineTable failed to parse: {0}\");\n    return nullptr;\n  }\n  return *line_table;\n}\n\nstatic bool ParseLLVMLineTablePrologue(lldb_private::DWARFContext &context,\n                                       llvm::DWARFDebugLine::Prologue &prologue,\n                                       dw_offset_t line_offset,\n                                       dw_offset_t unit_offset) {\n  Log *log = LogChannelDWARF::GetLogIfAll(DWARF_LOG_DEBUG_INFO);\n  bool success = true;\n  llvm::DWARFDataExtractor data = context.getOrLoadLineData().GetAsLLVM();\n  llvm::DWARFContext &ctx = context.GetAsLLVM();\n  uint64_t offset = line_offset;\n  llvm::Error error = prologue.parse(\n      data, &offset,\n      [&](llvm::Error e) {\n        success = false;\n        LLDB_LOG_ERROR(log, std::move(e),\n                       \"SymbolFileDWARF::ParseSupportFiles failed to parse \"\n                       \"line table prologue: {0}\");\n      },\n      ctx, nullptr);\n  if (error) {\n    LLDB_LOG_ERROR(log, std::move(error),\n                   \"SymbolFileDWARF::ParseSupportFiles failed to parse line \"\n                   \"table prologue: {0}\");\n    return false;\n  }\n  return success;\n}\n\nstatic llvm::Optional<std::string>\nGetFileByIndex(const llvm::DWARFDebugLine::Prologue &prologue, size_t idx,\n               llvm::StringRef compile_dir, FileSpec::Style style) {\n  // Try to get an absolute path first.\n  std::string abs_path;\n  auto absolute = llvm::DILineInfoSpecifier::FileLineInfoKind::AbsoluteFilePath;\n  if (prologue.getFileNameByIndex(idx, compile_dir, absolute, abs_path, style))\n    return std::move(abs_path);\n\n  // Otherwise ask for a relative path.\n  std::string rel_path;\n  auto relative = llvm::DILineInfoSpecifier::FileLineInfoKind::RawValue;\n  if (!prologue.getFileNameByIndex(idx, compile_dir, relative, rel_path, style))\n    return {};\n  return std::move(rel_path);\n}\n\nstatic FileSpecList\nParseSupportFilesFromPrologue(const lldb::ModuleSP &module,\n                              const llvm::DWARFDebugLine::Prologue &prologue,\n                              FileSpec::Style style,\n                              llvm::StringRef compile_dir = {}) {\n  FileSpecList support_files;\n  size_t first_file = 0;\n  if (prologue.getVersion() <= 4) {\n    // File index 0 is not valid before DWARF v5. Add a dummy entry to ensure\n    // support file list indices match those we get from the debug info and line\n    // tables.\n    support_files.Append(FileSpec());\n    first_file = 1;\n  }\n\n  const size_t number_of_files = prologue.FileNames.size();\n  for (size_t idx = first_file; idx <= number_of_files; ++idx) {\n    std::string remapped_file;\n    if (auto file_path = GetFileByIndex(prologue, idx, compile_dir, style))\n      if (!module->RemapSourceFile(llvm::StringRef(*file_path), remapped_file))\n        remapped_file = std::move(*file_path);\n\n    // Unconditionally add an entry, so the indices match up.\n    support_files.EmplaceBack(remapped_file, style);\n  }\n\n  return support_files;\n}\n\nvoid SymbolFileDWARF::Initialize() {\n  LogChannelDWARF::Initialize();\n  PluginManager::RegisterPlugin(GetPluginNameStatic(),\n                                GetPluginDescriptionStatic(), CreateInstance,\n                                DebuggerInitialize);\n  SymbolFileDWARFDebugMap::Initialize();\n}\n\nvoid SymbolFileDWARF::DebuggerInitialize(Debugger &debugger) {\n  if (!PluginManager::GetSettingForSymbolFilePlugin(\n          debugger, PluginProperties::GetSettingName())) {\n    const bool is_global_setting = true;\n    PluginManager::CreateSettingForSymbolFilePlugin(\n        debugger, GetGlobalPluginProperties()->GetValueProperties(),\n        ConstString(\"Properties for the dwarf symbol-file plug-in.\"),\n        is_global_setting);\n  }\n}\n\nvoid SymbolFileDWARF::Terminate() {\n  SymbolFileDWARFDebugMap::Terminate();\n  PluginManager::UnregisterPlugin(CreateInstance);\n  LogChannelDWARF::Terminate();\n}\n\nlldb_private::ConstString SymbolFileDWARF::GetPluginNameStatic() {\n  static ConstString g_name(\"dwarf\");\n  return g_name;\n}\n\nconst char *SymbolFileDWARF::GetPluginDescriptionStatic() {\n  return \"DWARF and DWARF3 debug symbol file reader.\";\n}\n\nSymbolFile *SymbolFileDWARF::CreateInstance(ObjectFileSP objfile_sp) {\n  return new SymbolFileDWARF(std::move(objfile_sp),\n                             /*dwo_section_list*/ nullptr);\n}\n\nTypeList &SymbolFileDWARF::GetTypeList() {\n  std::lock_guard<std::recursive_mutex> guard(GetModuleMutex());\n  if (SymbolFileDWARFDebugMap *debug_map_symfile = GetDebugMapSymfile())\n    return debug_map_symfile->GetTypeList();\n  return SymbolFile::GetTypeList();\n}\nvoid SymbolFileDWARF::GetTypes(const DWARFDIE &die, dw_offset_t min_die_offset,\n                               dw_offset_t max_die_offset, uint32_t type_mask,\n                               TypeSet &type_set) {\n  if (die) {\n    const dw_offset_t die_offset = die.GetOffset();\n\n    if (die_offset >= max_die_offset)\n      return;\n\n    if (die_offset >= min_die_offset) {\n      const dw_tag_t tag = die.Tag();\n\n      bool add_type = false;\n\n      switch (tag) {\n      case DW_TAG_array_type:\n        add_type = (type_mask & eTypeClassArray) != 0;\n        break;\n      case DW_TAG_unspecified_type:\n      case DW_TAG_base_type:\n        add_type = (type_mask & eTypeClassBuiltin) != 0;\n        break;\n      case DW_TAG_class_type:\n        add_type = (type_mask & eTypeClassClass) != 0;\n        break;\n      case DW_TAG_structure_type:\n        add_type = (type_mask & eTypeClassStruct) != 0;\n        break;\n      case DW_TAG_union_type:\n        add_type = (type_mask & eTypeClassUnion) != 0;\n        break;\n      case DW_TAG_enumeration_type:\n        add_type = (type_mask & eTypeClassEnumeration) != 0;\n        break;\n      case DW_TAG_subroutine_type:\n      case DW_TAG_subprogram:\n      case DW_TAG_inlined_subroutine:\n        add_type = (type_mask & eTypeClassFunction) != 0;\n        break;\n      case DW_TAG_pointer_type:\n        add_type = (type_mask & eTypeClassPointer) != 0;\n        break;\n      case DW_TAG_rvalue_reference_type:\n      case DW_TAG_reference_type:\n        add_type = (type_mask & eTypeClassReference) != 0;\n        break;\n      case DW_TAG_typedef:\n        add_type = (type_mask & eTypeClassTypedef) != 0;\n        break;\n      case DW_TAG_ptr_to_member_type:\n        add_type = (type_mask & eTypeClassMemberPointer) != 0;\n        break;\n      default:\n        break;\n      }\n\n      if (add_type) {\n        const bool assert_not_being_parsed = true;\n        Type *type = ResolveTypeUID(die, assert_not_being_parsed);\n        if (type)\n          type_set.insert(type);\n      }\n    }\n\n    for (DWARFDIE child_die = die.GetFirstChild(); child_die.IsValid();\n         child_die = child_die.GetSibling()) {\n      GetTypes(child_die, min_die_offset, max_die_offset, type_mask, type_set);\n    }\n  }\n}\n\nvoid SymbolFileDWARF::GetTypes(SymbolContextScope *sc_scope,\n                               TypeClass type_mask, TypeList &type_list)\n\n{\n  std::lock_guard<std::recursive_mutex> guard(GetModuleMutex());\n  TypeSet type_set;\n\n  CompileUnit *comp_unit = nullptr;\n  if (sc_scope)\n    comp_unit = sc_scope->CalculateSymbolContextCompileUnit();\n\n  const auto &get = [&](DWARFUnit *unit) {\n    if (!unit)\n      return;\n    unit = &unit->GetNonSkeletonUnit();\n    GetTypes(unit->DIE(), unit->GetOffset(), unit->GetNextUnitOffset(),\n             type_mask, type_set);\n  };\n  if (comp_unit) {\n    get(GetDWARFCompileUnit(comp_unit));\n  } else {\n    DWARFDebugInfo &info = DebugInfo();\n    const size_t num_cus = info.GetNumUnits();\n    for (size_t cu_idx = 0; cu_idx < num_cus; ++cu_idx)\n      get(info.GetUnitAtIndex(cu_idx));\n  }\n\n  std::set<CompilerType> compiler_type_set;\n  for (Type *type : type_set) {\n    CompilerType compiler_type = type->GetForwardCompilerType();\n    if (compiler_type_set.find(compiler_type) == compiler_type_set.end()) {\n      compiler_type_set.insert(compiler_type);\n      type_list.Insert(type->shared_from_this());\n    }\n  }\n}\n\n// Gets the first parent that is a lexical block, function or inlined\n// subroutine, or compile unit.\nDWARFDIE\nSymbolFileDWARF::GetParentSymbolContextDIE(const DWARFDIE &child_die) {\n  DWARFDIE die;\n  for (die = child_die.GetParent(); die; die = die.GetParent()) {\n    dw_tag_t tag = die.Tag();\n\n    switch (tag) {\n    case DW_TAG_compile_unit:\n    case DW_TAG_partial_unit:\n    case DW_TAG_subprogram:\n    case DW_TAG_inlined_subroutine:\n    case DW_TAG_lexical_block:\n      return die;\n    default:\n      break;\n    }\n  }\n  return DWARFDIE();\n}\n\nSymbolFileDWARF::SymbolFileDWARF(ObjectFileSP objfile_sp,\n                                 SectionList *dwo_section_list)\n    : SymbolFile(std::move(objfile_sp)),\n      UserID(0x7fffffff00000000), // Used by SymbolFileDWARFDebugMap to\n                                  // when this class parses .o files to\n                                  // contain the .o file index/ID\n      m_debug_map_module_wp(), m_debug_map_symfile(nullptr),\n      m_context(m_objfile_sp->GetModule()->GetSectionList(), dwo_section_list),\n      m_fetched_external_modules(false),\n      m_supports_DW_AT_APPLE_objc_complete_type(eLazyBoolCalculate) {}\n\nSymbolFileDWARF::~SymbolFileDWARF() {}\n\nstatic ConstString GetDWARFMachOSegmentName() {\n  static ConstString g_dwarf_section_name(\"__DWARF\");\n  return g_dwarf_section_name;\n}\n\nUniqueDWARFASTTypeMap &SymbolFileDWARF::GetUniqueDWARFASTTypeMap() {\n  SymbolFileDWARFDebugMap *debug_map_symfile = GetDebugMapSymfile();\n  if (debug_map_symfile)\n    return debug_map_symfile->GetUniqueDWARFASTTypeMap();\n  else\n    return m_unique_ast_type_map;\n}\n\nllvm::Expected<TypeSystem &>\nSymbolFileDWARF::GetTypeSystemForLanguage(LanguageType language) {\n  if (SymbolFileDWARFDebugMap *debug_map_symfile = GetDebugMapSymfile())\n    return debug_map_symfile->GetTypeSystemForLanguage(language);\n\n  auto type_system_or_err =\n      m_objfile_sp->GetModule()->GetTypeSystemForLanguage(language);\n  if (type_system_or_err) {\n    type_system_or_err->SetSymbolFile(this);\n  }\n  return type_system_or_err;\n}\n\nvoid SymbolFileDWARF::InitializeObject() {\n  Log *log = LogChannelDWARF::GetLogIfAll(DWARF_LOG_DEBUG_INFO);\n\n  if (!GetGlobalPluginProperties()->IgnoreFileIndexes()) {\n    DWARFDataExtractor apple_names, apple_namespaces, apple_types, apple_objc;\n    LoadSectionData(eSectionTypeDWARFAppleNames, apple_names);\n    LoadSectionData(eSectionTypeDWARFAppleNamespaces, apple_namespaces);\n    LoadSectionData(eSectionTypeDWARFAppleTypes, apple_types);\n    LoadSectionData(eSectionTypeDWARFAppleObjC, apple_objc);\n\n    m_index = AppleDWARFIndex::Create(\n        *GetObjectFile()->GetModule(), apple_names, apple_namespaces,\n        apple_types, apple_objc, m_context.getOrLoadStrData());\n\n    if (m_index)\n      return;\n\n    DWARFDataExtractor debug_names;\n    LoadSectionData(eSectionTypeDWARFDebugNames, debug_names);\n    if (debug_names.GetByteSize() > 0) {\n      llvm::Expected<std::unique_ptr<DebugNamesDWARFIndex>> index_or =\n          DebugNamesDWARFIndex::Create(*GetObjectFile()->GetModule(),\n                                       debug_names,\n                                       m_context.getOrLoadStrData(), *this);\n      if (index_or) {\n        m_index = std::move(*index_or);\n        return;\n      }\n      LLDB_LOG_ERROR(log, index_or.takeError(),\n                     \"Unable to read .debug_names data: {0}\");\n    }\n  }\n\n  m_index =\n      std::make_unique<ManualDWARFIndex>(*GetObjectFile()->GetModule(), *this);\n}\n\nbool SymbolFileDWARF::SupportedVersion(uint16_t version) {\n  return version >= 2 && version <= 5;\n}\n\nuint32_t SymbolFileDWARF::CalculateAbilities() {\n  uint32_t abilities = 0;\n  if (m_objfile_sp != nullptr) {\n    const Section *section = nullptr;\n    const SectionList *section_list = m_objfile_sp->GetSectionList();\n    if (section_list == nullptr)\n      return 0;\n\n    uint64_t debug_abbrev_file_size = 0;\n    uint64_t debug_info_file_size = 0;\n    uint64_t debug_line_file_size = 0;\n\n    section = section_list->FindSectionByName(GetDWARFMachOSegmentName()).get();\n\n    if (section)\n      section_list = &section->GetChildren();\n\n    section =\n        section_list->FindSectionByType(eSectionTypeDWARFDebugInfo, true).get();\n    if (section != nullptr) {\n      debug_info_file_size = section->GetFileSize();\n\n      section =\n          section_list->FindSectionByType(eSectionTypeDWARFDebugAbbrev, true)\n              .get();\n      if (section)\n        debug_abbrev_file_size = section->GetFileSize();\n\n      DWARFDebugAbbrev *abbrev = DebugAbbrev();\n      if (abbrev) {\n        std::set<dw_form_t> invalid_forms;\n        abbrev->GetUnsupportedForms(invalid_forms);\n        if (!invalid_forms.empty()) {\n          StreamString error;\n          error.Printf(\"unsupported DW_FORM value%s:\",\n                       invalid_forms.size() > 1 ? \"s\" : \"\");\n          for (auto form : invalid_forms)\n            error.Printf(\" %#x\", form);\n          m_objfile_sp->GetModule()->ReportWarning(\n              \"%s\", error.GetString().str().c_str());\n          return 0;\n        }\n      }\n\n      section =\n          section_list->FindSectionByType(eSectionTypeDWARFDebugLine, true)\n              .get();\n      if (section)\n        debug_line_file_size = section->GetFileSize();\n    } else {\n      const char *symfile_dir_cstr =\n          m_objfile_sp->GetFileSpec().GetDirectory().GetCString();\n      if (symfile_dir_cstr) {\n        if (strcasestr(symfile_dir_cstr, \".dsym\")) {\n          if (m_objfile_sp->GetType() == ObjectFile::eTypeDebugInfo) {\n            // We have a dSYM file that didn't have a any debug info. If the\n            // string table has a size of 1, then it was made from an\n            // executable with no debug info, or from an executable that was\n            // stripped.\n            section =\n                section_list->FindSectionByType(eSectionTypeDWARFDebugStr, true)\n                    .get();\n            if (section && section->GetFileSize() == 1) {\n              m_objfile_sp->GetModule()->ReportWarning(\n                  \"empty dSYM file detected, dSYM was created with an \"\n                  \"executable with no debug info.\");\n            }\n          }\n        }\n      }\n    }\n\n    if (debug_abbrev_file_size > 0 && debug_info_file_size > 0)\n      abilities |= CompileUnits | Functions | Blocks | GlobalVariables |\n                   LocalVariables | VariableTypes;\n\n    if (debug_line_file_size > 0)\n      abilities |= LineTables;\n  }\n  return abilities;\n}\n\nvoid SymbolFileDWARF::LoadSectionData(lldb::SectionType sect_type,\n                                      DWARFDataExtractor &data) {\n  ModuleSP module_sp(m_objfile_sp->GetModule());\n  const SectionList *section_list = module_sp->GetSectionList();\n  if (!section_list)\n    return;\n\n  SectionSP section_sp(section_list->FindSectionByType(sect_type, true));\n  if (!section_sp)\n    return;\n\n  data.Clear();\n  m_objfile_sp->ReadSectionData(section_sp.get(), data);\n}\n\nDWARFDebugAbbrev *SymbolFileDWARF::DebugAbbrev() {\n  if (m_abbr)\n    return m_abbr.get();\n\n  const DWARFDataExtractor &debug_abbrev_data = m_context.getOrLoadAbbrevData();\n  if (debug_abbrev_data.GetByteSize() == 0)\n    return nullptr;\n\n  auto abbr = std::make_unique<DWARFDebugAbbrev>();\n  llvm::Error error = abbr->parse(debug_abbrev_data);\n  if (error) {\n    Log *log = LogChannelDWARF::GetLogIfAll(DWARF_LOG_DEBUG_INFO);\n    LLDB_LOG_ERROR(log, std::move(error),\n                   \"Unable to read .debug_abbrev section: {0}\");\n    return nullptr;\n  }\n\n  m_abbr = std::move(abbr);\n  return m_abbr.get();\n}\n\nDWARFDebugInfo &SymbolFileDWARF::DebugInfo() {\n  llvm::call_once(m_info_once_flag, [&] {\n    LLDB_SCOPED_TIMERF(\"%s this = %p\", LLVM_PRETTY_FUNCTION,\n                       static_cast<void *>(this));\n    m_info = std::make_unique<DWARFDebugInfo>(*this, m_context);\n  });\n  return *m_info;\n}\n\nDWARFCompileUnit *SymbolFileDWARF::GetDWARFCompileUnit(CompileUnit *comp_unit) {\n  if (!comp_unit)\n    return nullptr;\n\n  // The compile unit ID is the index of the DWARF unit.\n  DWARFUnit *dwarf_cu = DebugInfo().GetUnitAtIndex(comp_unit->GetID());\n  if (dwarf_cu && dwarf_cu->GetUserData() == nullptr)\n    dwarf_cu->SetUserData(comp_unit);\n\n  // It must be DWARFCompileUnit when it created a CompileUnit.\n  return llvm::cast_or_null<DWARFCompileUnit>(dwarf_cu);\n}\n\nDWARFDebugRanges *SymbolFileDWARF::GetDebugRanges() {\n  if (!m_ranges) {\n    LLDB_SCOPED_TIMERF(\"%s this = %p\", LLVM_PRETTY_FUNCTION,\n                       static_cast<void *>(this));\n\n    if (m_context.getOrLoadRangesData().GetByteSize() > 0)\n      m_ranges = std::make_unique<DWARFDebugRanges>();\n\n    if (m_ranges)\n      m_ranges->Extract(m_context);\n  }\n  return m_ranges.get();\n}\n\n/// Make an absolute path out of \\p file_spec and remap it using the\n/// module's source remapping dictionary.\nstatic void MakeAbsoluteAndRemap(FileSpec &file_spec, DWARFUnit &dwarf_cu,\n                                 const ModuleSP &module_sp) {\n  if (!file_spec)\n    return;\n  // If we have a full path to the compile unit, we don't need to\n  // resolve the file.  This can be expensive e.g. when the source\n  // files are NFS mounted.\n  file_spec.MakeAbsolute(dwarf_cu.GetCompilationDirectory());\n\n  std::string remapped_file;\n  if (module_sp->RemapSourceFile(file_spec.GetPath(), remapped_file))\n    file_spec.SetFile(remapped_file, FileSpec::Style::native);\n}\n\nlldb::CompUnitSP SymbolFileDWARF::ParseCompileUnit(DWARFCompileUnit &dwarf_cu) {\n  CompUnitSP cu_sp;\n  CompileUnit *comp_unit = (CompileUnit *)dwarf_cu.GetUserData();\n  if (comp_unit) {\n    // We already parsed this compile unit, had out a shared pointer to it\n    cu_sp = comp_unit->shared_from_this();\n  } else {\n    if (dwarf_cu.GetOffset() == 0 && GetDebugMapSymfile()) {\n      // Let the debug map create the compile unit\n      cu_sp = m_debug_map_symfile->GetCompileUnit(this);\n      dwarf_cu.SetUserData(cu_sp.get());\n    } else {\n      ModuleSP module_sp(m_objfile_sp->GetModule());\n      if (module_sp) {\n        const DWARFBaseDIE cu_die =\n            dwarf_cu.GetNonSkeletonUnit().GetUnitDIEOnly();\n        if (cu_die) {\n          FileSpec cu_file_spec(cu_die.GetName(), dwarf_cu.GetPathStyle());\n          MakeAbsoluteAndRemap(cu_file_spec, dwarf_cu, module_sp);\n\n          LanguageType cu_language = SymbolFileDWARF::LanguageTypeFromDWARF(\n              cu_die.GetAttributeValueAsUnsigned(DW_AT_language, 0));\n\n          bool is_optimized = dwarf_cu.GetNonSkeletonUnit().GetIsOptimized();\n          BuildCuTranslationTable();\n          cu_sp = std::make_shared<CompileUnit>(\n              module_sp, &dwarf_cu, cu_file_spec,\n              *GetDWARFUnitIndex(dwarf_cu.GetID()), cu_language,\n              is_optimized ? eLazyBoolYes : eLazyBoolNo);\n\n          dwarf_cu.SetUserData(cu_sp.get());\n\n          SetCompileUnitAtIndex(dwarf_cu.GetID(), cu_sp);\n        }\n      }\n    }\n  }\n  return cu_sp;\n}\n\nvoid SymbolFileDWARF::BuildCuTranslationTable() {\n  if (!m_lldb_cu_to_dwarf_unit.empty())\n    return;\n\n  DWARFDebugInfo &info = DebugInfo();\n  if (!info.ContainsTypeUnits()) {\n    // We can use a 1-to-1 mapping. No need to build a translation table.\n    return;\n  }\n  for (uint32_t i = 0, num = info.GetNumUnits(); i < num; ++i) {\n    if (auto *cu = llvm::dyn_cast<DWARFCompileUnit>(info.GetUnitAtIndex(i))) {\n      cu->SetID(m_lldb_cu_to_dwarf_unit.size());\n      m_lldb_cu_to_dwarf_unit.push_back(i);\n    }\n  }\n}\n\nllvm::Optional<uint32_t> SymbolFileDWARF::GetDWARFUnitIndex(uint32_t cu_idx) {\n  BuildCuTranslationTable();\n  if (m_lldb_cu_to_dwarf_unit.empty())\n    return cu_idx;\n  if (cu_idx >= m_lldb_cu_to_dwarf_unit.size())\n    return llvm::None;\n  return m_lldb_cu_to_dwarf_unit[cu_idx];\n}\n\nuint32_t SymbolFileDWARF::CalculateNumCompileUnits() {\n  BuildCuTranslationTable();\n  return m_lldb_cu_to_dwarf_unit.empty() ? DebugInfo().GetNumUnits()\n                                         : m_lldb_cu_to_dwarf_unit.size();\n}\n\nCompUnitSP SymbolFileDWARF::ParseCompileUnitAtIndex(uint32_t cu_idx) {\n  ASSERT_MODULE_LOCK(this);\n  if (llvm::Optional<uint32_t> dwarf_idx = GetDWARFUnitIndex(cu_idx)) {\n    if (auto *dwarf_cu = llvm::cast_or_null<DWARFCompileUnit>(\n            DebugInfo().GetUnitAtIndex(*dwarf_idx)))\n      return ParseCompileUnit(*dwarf_cu);\n  }\n  return {};\n}\n\nFunction *SymbolFileDWARF::ParseFunction(CompileUnit &comp_unit,\n                                         const DWARFDIE &die) {\n  ASSERT_MODULE_LOCK(this);\n  if (!die.IsValid())\n    return nullptr;\n\n  auto type_system_or_err = GetTypeSystemForLanguage(GetLanguage(*die.GetCU()));\n  if (auto err = type_system_or_err.takeError()) {\n    LLDB_LOG_ERROR(lldb_private::GetLogIfAnyCategoriesSet(LIBLLDB_LOG_SYMBOLS),\n                   std::move(err), \"Unable to parse function\");\n    return nullptr;\n  }\n  DWARFASTParser *dwarf_ast = type_system_or_err->GetDWARFParser();\n  if (!dwarf_ast)\n    return nullptr;\n\n  return dwarf_ast->ParseFunctionFromDWARF(comp_unit, die);\n}\n\nlldb::addr_t SymbolFileDWARF::FixupAddress(lldb::addr_t file_addr) {\n  SymbolFileDWARFDebugMap *debug_map_symfile = GetDebugMapSymfile();\n  if (debug_map_symfile)\n    return debug_map_symfile->LinkOSOFileAddress(this, file_addr);\n  return file_addr;\n}\n\nbool SymbolFileDWARF::FixupAddress(Address &addr) {\n  SymbolFileDWARFDebugMap *debug_map_symfile = GetDebugMapSymfile();\n  if (debug_map_symfile) {\n    return debug_map_symfile->LinkOSOAddress(addr);\n  }\n  // This is a normal DWARF file, no address fixups need to happen\n  return true;\n}\nlldb::LanguageType SymbolFileDWARF::ParseLanguage(CompileUnit &comp_unit) {\n  std::lock_guard<std::recursive_mutex> guard(GetModuleMutex());\n  DWARFUnit *dwarf_cu = GetDWARFCompileUnit(&comp_unit);\n  if (dwarf_cu)\n    return GetLanguage(*dwarf_cu);\n  else\n    return eLanguageTypeUnknown;\n}\n\nXcodeSDK SymbolFileDWARF::ParseXcodeSDK(CompileUnit &comp_unit) {\n  std::lock_guard<std::recursive_mutex> guard(GetModuleMutex());\n  DWARFUnit *dwarf_cu = GetDWARFCompileUnit(&comp_unit);\n  if (!dwarf_cu)\n    return {};\n  const DWARFBaseDIE cu_die = dwarf_cu->GetNonSkeletonUnit().GetUnitDIEOnly();\n  if (!cu_die)\n    return {};\n  const char *sdk = cu_die.GetAttributeValueAsString(DW_AT_APPLE_sdk, nullptr);\n  if (!sdk)\n    return {};\n  const char *sysroot =\n      cu_die.GetAttributeValueAsString(DW_AT_LLVM_sysroot, \"\");\n  // Register the sysroot path remapping with the module belonging to\n  // the CU as well as the one belonging to the symbol file. The two\n  // would be different if this is an OSO object and module is the\n  // corresponding debug map, in which case both should be updated.\n  ModuleSP module_sp = comp_unit.GetModule();\n  if (module_sp)\n    module_sp->RegisterXcodeSDK(sdk, sysroot);\n\n  ModuleSP local_module_sp = m_objfile_sp->GetModule();\n  if (local_module_sp && local_module_sp != module_sp)\n    local_module_sp->RegisterXcodeSDK(sdk, sysroot);\n\n  return {sdk};\n}\n\nsize_t SymbolFileDWARF::ParseFunctions(CompileUnit &comp_unit) {\n  LLDB_SCOPED_TIMER();\n  std::lock_guard<std::recursive_mutex> guard(GetModuleMutex());\n  DWARFUnit *dwarf_cu = GetDWARFCompileUnit(&comp_unit);\n  if (!dwarf_cu)\n    return 0;\n\n  size_t functions_added = 0;\n  dwarf_cu = &dwarf_cu->GetNonSkeletonUnit();\n  for (DWARFDebugInfoEntry &entry : dwarf_cu->dies()) {\n    if (entry.Tag() != DW_TAG_subprogram)\n      continue;\n\n    DWARFDIE die(dwarf_cu, &entry);\n    if (comp_unit.FindFunctionByUID(die.GetID()))\n      continue;\n    if (ParseFunction(comp_unit, die))\n      ++functions_added;\n  }\n  // FixupTypes();\n  return functions_added;\n}\n\nbool SymbolFileDWARF::ForEachExternalModule(\n    CompileUnit &comp_unit,\n    llvm::DenseSet<lldb_private::SymbolFile *> &visited_symbol_files,\n    llvm::function_ref<bool(Module &)> lambda) {\n  // Only visit each symbol file once.\n  if (!visited_symbol_files.insert(this).second)\n    return false;\n\n  UpdateExternalModuleListIfNeeded();\n  for (auto &p : m_external_type_modules) {\n    ModuleSP module = p.second;\n    if (!module)\n      continue;\n\n    // Invoke the action and potentially early-exit.\n    if (lambda(*module))\n      return true;\n\n    for (std::size_t i = 0; i < module->GetNumCompileUnits(); ++i) {\n      auto cu = module->GetCompileUnitAtIndex(i);\n      bool early_exit = cu->ForEachExternalModule(visited_symbol_files, lambda);\n      if (early_exit)\n        return true;\n    }\n  }\n  return false;\n}\n\nbool SymbolFileDWARF::ParseSupportFiles(CompileUnit &comp_unit,\n                                        FileSpecList &support_files) {\n  std::lock_guard<std::recursive_mutex> guard(GetModuleMutex());\n  DWARFUnit *dwarf_cu = GetDWARFCompileUnit(&comp_unit);\n  if (!dwarf_cu)\n    return false;\n\n  dw_offset_t offset = dwarf_cu->GetLineTableOffset();\n  if (offset == DW_INVALID_OFFSET)\n    return false;\n\n  llvm::DWARFDebugLine::Prologue prologue;\n  if (!ParseLLVMLineTablePrologue(m_context, prologue, offset,\n                                  dwarf_cu->GetOffset()))\n    return false;\n\n  comp_unit.SetSupportFiles(ParseSupportFilesFromPrologue(\n      comp_unit.GetModule(), prologue, dwarf_cu->GetPathStyle(),\n      dwarf_cu->GetCompilationDirectory().GetCString()));\n\n  return true;\n}\n\nFileSpec SymbolFileDWARF::GetFile(DWARFUnit &unit, size_t file_idx) {\n  if (auto *dwarf_cu = llvm::dyn_cast<DWARFCompileUnit>(&unit)) {\n    if (CompileUnit *lldb_cu = GetCompUnitForDWARFCompUnit(*dwarf_cu))\n      return lldb_cu->GetSupportFiles().GetFileSpecAtIndex(file_idx);\n    return FileSpec();\n  }\n\n  auto &tu = llvm::cast<DWARFTypeUnit>(unit);\n  return GetTypeUnitSupportFiles(tu).GetFileSpecAtIndex(file_idx);\n}\n\nconst FileSpecList &\nSymbolFileDWARF::GetTypeUnitSupportFiles(DWARFTypeUnit &tu) {\n  static FileSpecList empty_list;\n\n  dw_offset_t offset = tu.GetLineTableOffset();\n  if (offset == DW_INVALID_OFFSET ||\n      offset == llvm::DenseMapInfo<dw_offset_t>::getEmptyKey() ||\n      offset == llvm::DenseMapInfo<dw_offset_t>::getTombstoneKey())\n    return empty_list;\n\n  // Many type units can share a line table, so parse the support file list\n  // once, and cache it based on the offset field.\n  auto iter_bool = m_type_unit_support_files.try_emplace(offset);\n  FileSpecList &list = iter_bool.first->second;\n  if (iter_bool.second) {\n    uint64_t line_table_offset = offset;\n    llvm::DWARFDataExtractor data = m_context.getOrLoadLineData().GetAsLLVM();\n    llvm::DWARFContext &ctx = m_context.GetAsLLVM();\n    llvm::DWARFDebugLine::Prologue prologue;\n    auto report = [](llvm::Error error) {\n      Log *log = LogChannelDWARF::GetLogIfAll(DWARF_LOG_DEBUG_INFO);\n      LLDB_LOG_ERROR(log, std::move(error),\n                     \"SymbolFileDWARF::GetTypeUnitSupportFiles failed to parse \"\n                     \"the line table prologue\");\n    };\n    llvm::Error error = prologue.parse(data, &line_table_offset, report, ctx);\n    if (error) {\n      report(std::move(error));\n    } else {\n      list = ParseSupportFilesFromPrologue(GetObjectFile()->GetModule(),\n                                           prologue, tu.GetPathStyle());\n    }\n  }\n  return list;\n}\n\nbool SymbolFileDWARF::ParseIsOptimized(CompileUnit &comp_unit) {\n  std::lock_guard<std::recursive_mutex> guard(GetModuleMutex());\n  DWARFUnit *dwarf_cu = GetDWARFCompileUnit(&comp_unit);\n  if (dwarf_cu)\n    return dwarf_cu->GetIsOptimized();\n  return false;\n}\n\nbool SymbolFileDWARF::ParseImportedModules(\n    const lldb_private::SymbolContext &sc,\n    std::vector<SourceModule> &imported_modules) {\n  std::lock_guard<std::recursive_mutex> guard(GetModuleMutex());\n  assert(sc.comp_unit);\n  DWARFUnit *dwarf_cu = GetDWARFCompileUnit(sc.comp_unit);\n  if (!dwarf_cu)\n    return false;\n  if (!ClangModulesDeclVendor::LanguageSupportsClangModules(\n          sc.comp_unit->GetLanguage()))\n    return false;\n  UpdateExternalModuleListIfNeeded();\n\n  const DWARFDIE die = dwarf_cu->DIE();\n  if (!die)\n    return false;\n\n  for (DWARFDIE child_die = die.GetFirstChild(); child_die;\n       child_die = child_die.GetSibling()) {\n    if (child_die.Tag() != DW_TAG_imported_declaration)\n      continue;\n\n    DWARFDIE module_die = child_die.GetReferencedDIE(DW_AT_import);\n    if (module_die.Tag() != DW_TAG_module)\n      continue;\n\n    if (const char *name =\n            module_die.GetAttributeValueAsString(DW_AT_name, nullptr)) {\n      SourceModule module;\n      module.path.push_back(ConstString(name));\n\n      DWARFDIE parent_die = module_die;\n      while ((parent_die = parent_die.GetParent())) {\n        if (parent_die.Tag() != DW_TAG_module)\n          break;\n        if (const char *name =\n                parent_die.GetAttributeValueAsString(DW_AT_name, nullptr))\n          module.path.push_back(ConstString(name));\n      }\n      std::reverse(module.path.begin(), module.path.end());\n      if (const char *include_path = module_die.GetAttributeValueAsString(\n              DW_AT_LLVM_include_path, nullptr)) {\n        FileSpec include_spec(include_path, dwarf_cu->GetPathStyle());\n        MakeAbsoluteAndRemap(include_spec, *dwarf_cu, m_objfile_sp->GetModule());\n        module.search_path = ConstString(include_spec.GetPath());\n      }\n      if (const char *sysroot = dwarf_cu->DIE().GetAttributeValueAsString(\n              DW_AT_LLVM_sysroot, nullptr))\n        module.sysroot = ConstString(sysroot);\n      imported_modules.push_back(module);\n    }\n  }\n  return true;\n}\n\nbool SymbolFileDWARF::ParseLineTable(CompileUnit &comp_unit) {\n  std::lock_guard<std::recursive_mutex> guard(GetModuleMutex());\n  if (comp_unit.GetLineTable() != nullptr)\n    return true;\n\n  DWARFUnit *dwarf_cu = GetDWARFCompileUnit(&comp_unit);\n  if (!dwarf_cu)\n    return false;\n\n  dw_offset_t offset = dwarf_cu->GetLineTableOffset();\n  if (offset == DW_INVALID_OFFSET)\n    return false;\n\n  llvm::DWARFDebugLine line;\n  const llvm::DWARFDebugLine::LineTable *line_table =\n      ParseLLVMLineTable(m_context, line, offset, dwarf_cu->GetOffset());\n\n  if (!line_table)\n    return false;\n\n  // FIXME: Rather than parsing the whole line table and then copying it over\n  // into LLDB, we should explore using a callback to populate the line table\n  // while we parse to reduce memory usage.\n  std::vector<std::unique_ptr<LineSequence>> sequences;\n  // The Sequences view contains only valid line sequences. Don't iterate over\n  // the Rows directly.\n  for (const llvm::DWARFDebugLine::Sequence &seq : line_table->Sequences) {\n    std::unique_ptr<LineSequence> sequence =\n        LineTable::CreateLineSequenceContainer();\n    for (unsigned idx = seq.FirstRowIndex; idx < seq.LastRowIndex; ++idx) {\n      const llvm::DWARFDebugLine::Row &row = line_table->Rows[idx];\n      LineTable::AppendLineEntryToSequence(\n          sequence.get(), row.Address.Address, row.Line, row.Column, row.File,\n          row.IsStmt, row.BasicBlock, row.PrologueEnd, row.EpilogueBegin,\n          row.EndSequence);\n    }\n    sequences.push_back(std::move(sequence));\n  }\n\n  std::unique_ptr<LineTable> line_table_up =\n      std::make_unique<LineTable>(&comp_unit, std::move(sequences));\n\n  if (SymbolFileDWARFDebugMap *debug_map_symfile = GetDebugMapSymfile()) {\n    // We have an object file that has a line table with addresses that are not\n    // linked. We need to link the line table and convert the addresses that\n    // are relative to the .o file into addresses for the main executable.\n    comp_unit.SetLineTable(\n        debug_map_symfile->LinkOSOLineTable(this, line_table_up.get()));\n  } else {\n    comp_unit.SetLineTable(line_table_up.release());\n  }\n\n  return true;\n}\n\nlldb_private::DebugMacrosSP\nSymbolFileDWARF::ParseDebugMacros(lldb::offset_t *offset) {\n  auto iter = m_debug_macros_map.find(*offset);\n  if (iter != m_debug_macros_map.end())\n    return iter->second;\n\n  const DWARFDataExtractor &debug_macro_data = m_context.getOrLoadMacroData();\n  if (debug_macro_data.GetByteSize() == 0)\n    return DebugMacrosSP();\n\n  lldb_private::DebugMacrosSP debug_macros_sp(new lldb_private::DebugMacros());\n  m_debug_macros_map[*offset] = debug_macros_sp;\n\n  const DWARFDebugMacroHeader &header =\n      DWARFDebugMacroHeader::ParseHeader(debug_macro_data, offset);\n  DWARFDebugMacroEntry::ReadMacroEntries(\n      debug_macro_data, m_context.getOrLoadStrData(), header.OffsetIs64Bit(),\n      offset, this, debug_macros_sp);\n\n  return debug_macros_sp;\n}\n\nbool SymbolFileDWARF::ParseDebugMacros(CompileUnit &comp_unit) {\n  std::lock_guard<std::recursive_mutex> guard(GetModuleMutex());\n\n  DWARFUnit *dwarf_cu = GetDWARFCompileUnit(&comp_unit);\n  if (dwarf_cu == nullptr)\n    return false;\n\n  const DWARFBaseDIE dwarf_cu_die = dwarf_cu->GetUnitDIEOnly();\n  if (!dwarf_cu_die)\n    return false;\n\n  lldb::offset_t sect_offset =\n      dwarf_cu_die.GetAttributeValueAsUnsigned(DW_AT_macros, DW_INVALID_OFFSET);\n  if (sect_offset == DW_INVALID_OFFSET)\n    sect_offset = dwarf_cu_die.GetAttributeValueAsUnsigned(DW_AT_GNU_macros,\n                                                           DW_INVALID_OFFSET);\n  if (sect_offset == DW_INVALID_OFFSET)\n    return false;\n\n  comp_unit.SetDebugMacros(ParseDebugMacros(&sect_offset));\n\n  return true;\n}\n\nsize_t SymbolFileDWARF::ParseBlocksRecursive(\n    lldb_private::CompileUnit &comp_unit, Block *parent_block,\n    const DWARFDIE &orig_die, addr_t subprogram_low_pc, uint32_t depth) {\n  size_t blocks_added = 0;\n  DWARFDIE die = orig_die;\n  while (die) {\n    dw_tag_t tag = die.Tag();\n\n    switch (tag) {\n    case DW_TAG_inlined_subroutine:\n    case DW_TAG_subprogram:\n    case DW_TAG_lexical_block: {\n      Block *block = nullptr;\n      if (tag == DW_TAG_subprogram) {\n        // Skip any DW_TAG_subprogram DIEs that are inside of a normal or\n        // inlined functions. These will be parsed on their own as separate\n        // entities.\n\n        if (depth > 0)\n          break;\n\n        block = parent_block;\n      } else {\n        BlockSP block_sp(new Block(die.GetID()));\n        parent_block->AddChild(block_sp);\n        block = block_sp.get();\n      }\n      DWARFRangeList ranges;\n      const char *name = nullptr;\n      const char *mangled_name = nullptr;\n\n      int decl_file = 0;\n      int decl_line = 0;\n      int decl_column = 0;\n      int call_file = 0;\n      int call_line = 0;\n      int call_column = 0;\n      if (die.GetDIENamesAndRanges(name, mangled_name, ranges, decl_file,\n                                   decl_line, decl_column, call_file, call_line,\n                                   call_column, nullptr)) {\n        if (tag == DW_TAG_subprogram) {\n          assert(subprogram_low_pc == LLDB_INVALID_ADDRESS);\n          subprogram_low_pc = ranges.GetMinRangeBase(0);\n        } else if (tag == DW_TAG_inlined_subroutine) {\n          // We get called here for inlined subroutines in two ways. The first\n          // time is when we are making the Function object for this inlined\n          // concrete instance.  Since we're creating a top level block at\n          // here, the subprogram_low_pc will be LLDB_INVALID_ADDRESS.  So we\n          // need to adjust the containing address. The second time is when we\n          // are parsing the blocks inside the function that contains the\n          // inlined concrete instance.  Since these will be blocks inside the\n          // containing \"real\" function the offset will be for that function.\n          if (subprogram_low_pc == LLDB_INVALID_ADDRESS) {\n            subprogram_low_pc = ranges.GetMinRangeBase(0);\n          }\n        }\n\n        const size_t num_ranges = ranges.GetSize();\n        for (size_t i = 0; i < num_ranges; ++i) {\n          const DWARFRangeList::Entry &range = ranges.GetEntryRef(i);\n          const addr_t range_base = range.GetRangeBase();\n          if (range_base >= subprogram_low_pc)\n            block->AddRange(Block::Range(range_base - subprogram_low_pc,\n                                         range.GetByteSize()));\n          else {\n            GetObjectFile()->GetModule()->ReportError(\n                \"0x%8.8\" PRIx64 \": adding range [0x%\" PRIx64 \"-0x%\" PRIx64\n                \") which has a base that is less than the function's low PC \"\n                \"0x%\" PRIx64 \". Please file a bug and attach the file at the \"\n                \"start of this error message\",\n                block->GetID(), range_base, range.GetRangeEnd(),\n                subprogram_low_pc);\n          }\n        }\n        block->FinalizeRanges();\n\n        if (tag != DW_TAG_subprogram &&\n            (name != nullptr || mangled_name != nullptr)) {\n          std::unique_ptr<Declaration> decl_up;\n          if (decl_file != 0 || decl_line != 0 || decl_column != 0)\n            decl_up = std::make_unique<Declaration>(\n                comp_unit.GetSupportFiles().GetFileSpecAtIndex(decl_file),\n                decl_line, decl_column);\n\n          std::unique_ptr<Declaration> call_up;\n          if (call_file != 0 || call_line != 0 || call_column != 0)\n            call_up = std::make_unique<Declaration>(\n                comp_unit.GetSupportFiles().GetFileSpecAtIndex(call_file),\n                call_line, call_column);\n\n          block->SetInlinedFunctionInfo(name, mangled_name, decl_up.get(),\n                                        call_up.get());\n        }\n\n        ++blocks_added;\n\n        if (die.HasChildren()) {\n          blocks_added +=\n              ParseBlocksRecursive(comp_unit, block, die.GetFirstChild(),\n                                   subprogram_low_pc, depth + 1);\n        }\n      }\n    } break;\n    default:\n      break;\n    }\n\n    // Only parse siblings of the block if we are not at depth zero. A depth of\n    // zero indicates we are currently parsing the top level DW_TAG_subprogram\n    // DIE\n\n    if (depth == 0)\n      die.Clear();\n    else\n      die = die.GetSibling();\n  }\n  return blocks_added;\n}\n\nbool SymbolFileDWARF::ClassOrStructIsVirtual(const DWARFDIE &parent_die) {\n  if (parent_die) {\n    for (DWARFDIE die = parent_die.GetFirstChild(); die;\n         die = die.GetSibling()) {\n      dw_tag_t tag = die.Tag();\n      bool check_virtuality = false;\n      switch (tag) {\n      case DW_TAG_inheritance:\n      case DW_TAG_subprogram:\n        check_virtuality = true;\n        break;\n      default:\n        break;\n      }\n      if (check_virtuality) {\n        if (die.GetAttributeValueAsUnsigned(DW_AT_virtuality, 0) != 0)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\nvoid SymbolFileDWARF::ParseDeclsForContext(CompilerDeclContext decl_ctx) {\n  auto *type_system = decl_ctx.GetTypeSystem();\n  if (type_system != nullptr)\n    type_system->GetDWARFParser()->EnsureAllDIEsInDeclContextHaveBeenParsed(\n        decl_ctx);\n}\n\nuser_id_t SymbolFileDWARF::GetUID(DIERef ref) {\n  if (GetDebugMapSymfile())\n    return GetID() | ref.die_offset();\n\n  lldbassert(GetDwoNum().getValueOr(0) <= 0x3fffffff);\n  return user_id_t(GetDwoNum().getValueOr(0)) << 32 | ref.die_offset() |\n         lldb::user_id_t(GetDwoNum().hasValue()) << 62 |\n         lldb::user_id_t(ref.section() == DIERef::Section::DebugTypes) << 63;\n}\n\nllvm::Optional<SymbolFileDWARF::DecodedUID>\nSymbolFileDWARF::DecodeUID(lldb::user_id_t uid) {\n  // This method can be called without going through the symbol vendor so we\n  // need to lock the module.\n  std::lock_guard<std::recursive_mutex> guard(GetModuleMutex());\n  // Anytime we get a \"lldb::user_id_t\" from an lldb_private::SymbolFile API we\n  // must make sure we use the correct DWARF file when resolving things. On\n  // MacOSX, when using SymbolFileDWARFDebugMap, we will use multiple\n  // SymbolFileDWARF classes, one for each .o file. We can often end up with\n  // references to other DWARF objects and we must be ready to receive a\n  // \"lldb::user_id_t\" that specifies a DIE from another SymbolFileDWARF\n  // instance.\n  if (SymbolFileDWARFDebugMap *debug_map = GetDebugMapSymfile()) {\n    SymbolFileDWARF *dwarf = debug_map->GetSymbolFileByOSOIndex(\n        debug_map->GetOSOIndexFromUserID(uid));\n    return DecodedUID{\n        *dwarf, {llvm::None, DIERef::Section::DebugInfo, dw_offset_t(uid)}};\n  }\n  dw_offset_t die_offset = uid;\n  if (die_offset == DW_INVALID_OFFSET)\n    return llvm::None;\n\n  DIERef::Section section =\n      uid >> 63 ? DIERef::Section::DebugTypes : DIERef::Section::DebugInfo;\n\n  llvm::Optional<uint32_t> dwo_num;\n  bool dwo_valid = uid >> 62 & 1;\n  if (dwo_valid)\n    dwo_num = uid >> 32 & 0x3fffffff;\n\n  return DecodedUID{*this, {dwo_num, section, die_offset}};\n}\n\nDWARFDIE\nSymbolFileDWARF::GetDIE(lldb::user_id_t uid) {\n  // This method can be called without going through the symbol vendor so we\n  // need to lock the module.\n  std::lock_guard<std::recursive_mutex> guard(GetModuleMutex());\n\n  llvm::Optional<DecodedUID> decoded = DecodeUID(uid);\n\n  if (decoded)\n    return decoded->dwarf.GetDIE(decoded->ref);\n\n  return DWARFDIE();\n}\n\nCompilerDecl SymbolFileDWARF::GetDeclForUID(lldb::user_id_t type_uid) {\n  // This method can be called without going through the symbol vendor so we\n  // need to lock the module.\n  std::lock_guard<std::recursive_mutex> guard(GetModuleMutex());\n  // Anytime we have a lldb::user_id_t, we must get the DIE by calling\n  // SymbolFileDWARF::GetDIE(). See comments inside the\n  // SymbolFileDWARF::GetDIE() for details.\n  if (DWARFDIE die = GetDIE(type_uid))\n    return GetDecl(die);\n  return CompilerDecl();\n}\n\nCompilerDeclContext\nSymbolFileDWARF::GetDeclContextForUID(lldb::user_id_t type_uid) {\n  // This method can be called without going through the symbol vendor so we\n  // need to lock the module.\n  std::lock_guard<std::recursive_mutex> guard(GetModuleMutex());\n  // Anytime we have a lldb::user_id_t, we must get the DIE by calling\n  // SymbolFileDWARF::GetDIE(). See comments inside the\n  // SymbolFileDWARF::GetDIE() for details.\n  if (DWARFDIE die = GetDIE(type_uid))\n    return GetDeclContext(die);\n  return CompilerDeclContext();\n}\n\nCompilerDeclContext\nSymbolFileDWARF::GetDeclContextContainingUID(lldb::user_id_t type_uid) {\n  std::lock_guard<std::recursive_mutex> guard(GetModuleMutex());\n  // Anytime we have a lldb::user_id_t, we must get the DIE by calling\n  // SymbolFileDWARF::GetDIE(). See comments inside the\n  // SymbolFileDWARF::GetDIE() for details.\n  if (DWARFDIE die = GetDIE(type_uid))\n    return GetContainingDeclContext(die);\n  return CompilerDeclContext();\n}\n\nType *SymbolFileDWARF::ResolveTypeUID(lldb::user_id_t type_uid) {\n  std::lock_guard<std::recursive_mutex> guard(GetModuleMutex());\n  // Anytime we have a lldb::user_id_t, we must get the DIE by calling\n  // SymbolFileDWARF::GetDIE(). See comments inside the\n  // SymbolFileDWARF::GetDIE() for details.\n  if (DWARFDIE type_die = GetDIE(type_uid))\n    return type_die.ResolveType();\n  else\n    return nullptr;\n}\n\nllvm::Optional<SymbolFile::ArrayInfo>\nSymbolFileDWARF::GetDynamicArrayInfoForUID(\n    lldb::user_id_t type_uid, const lldb_private::ExecutionContext *exe_ctx) {\n  std::lock_guard<std::recursive_mutex> guard(GetModuleMutex());\n  if (DWARFDIE type_die = GetDIE(type_uid))\n    return DWARFASTParser::ParseChildArrayInfo(type_die, exe_ctx);\n  else\n    return llvm::None;\n}\n\nType *SymbolFileDWARF::ResolveTypeUID(const DIERef &die_ref) {\n  return ResolveType(GetDIE(die_ref), true);\n}\n\nType *SymbolFileDWARF::ResolveTypeUID(const DWARFDIE &die,\n                                      bool assert_not_being_parsed) {\n  if (die) {\n    Log *log(LogChannelDWARF::GetLogIfAll(DWARF_LOG_DEBUG_INFO));\n    if (log)\n      GetObjectFile()->GetModule()->LogMessage(\n          log, \"SymbolFileDWARF::ResolveTypeUID (die = 0x%8.8x) %s '%s'\",\n          die.GetOffset(), die.GetTagAsCString(), die.GetName());\n\n    // We might be coming in in the middle of a type tree (a class within a\n    // class, an enum within a class), so parse any needed parent DIEs before\n    // we get to this one...\n    DWARFDIE decl_ctx_die = GetDeclContextDIEContainingDIE(die);\n    if (decl_ctx_die) {\n      if (log) {\n        switch (decl_ctx_die.Tag()) {\n        case DW_TAG_structure_type:\n        case DW_TAG_union_type:\n        case DW_TAG_class_type: {\n          // Get the type, which could be a forward declaration\n          if (log)\n            GetObjectFile()->GetModule()->LogMessage(\n                log,\n                \"SymbolFileDWARF::ResolveTypeUID (die = 0x%8.8x) %s '%s' \"\n                \"resolve parent forward type for 0x%8.8x\",\n                die.GetOffset(), die.GetTagAsCString(), die.GetName(),\n                decl_ctx_die.GetOffset());\n        } break;\n\n        default:\n          break;\n        }\n      }\n    }\n    return ResolveType(die);\n  }\n  return nullptr;\n}\n\n// This function is used when SymbolFileDWARFDebugMap owns a bunch of\n// SymbolFileDWARF objects to detect if this DWARF file is the one that can\n// resolve a compiler_type.\nbool SymbolFileDWARF::HasForwardDeclForClangType(\n    const CompilerType &compiler_type) {\n  CompilerType compiler_type_no_qualifiers =\n      ClangUtil::RemoveFastQualifiers(compiler_type);\n  if (GetForwardDeclClangTypeToDie().count(\n          compiler_type_no_qualifiers.GetOpaqueQualType())) {\n    return true;\n  }\n  TypeSystem *type_system = compiler_type.GetTypeSystem();\n\n  TypeSystemClang *clang_type_system =\n      llvm::dyn_cast_or_null<TypeSystemClang>(type_system);\n  if (!clang_type_system)\n    return false;\n  DWARFASTParserClang *ast_parser =\n      static_cast<DWARFASTParserClang *>(clang_type_system->GetDWARFParser());\n  return ast_parser->GetClangASTImporter().CanImport(compiler_type);\n}\n\nbool SymbolFileDWARF::CompleteType(CompilerType &compiler_type) {\n  std::lock_guard<std::recursive_mutex> guard(GetModuleMutex());\n\n  TypeSystemClang *clang_type_system =\n      llvm::dyn_cast_or_null<TypeSystemClang>(compiler_type.GetTypeSystem());\n  if (clang_type_system) {\n    DWARFASTParserClang *ast_parser =\n        static_cast<DWARFASTParserClang *>(clang_type_system->GetDWARFParser());\n    if (ast_parser &&\n        ast_parser->GetClangASTImporter().CanImport(compiler_type))\n      return ast_parser->GetClangASTImporter().CompleteType(compiler_type);\n  }\n\n  // We have a struct/union/class/enum that needs to be fully resolved.\n  CompilerType compiler_type_no_qualifiers =\n      ClangUtil::RemoveFastQualifiers(compiler_type);\n  auto die_it = GetForwardDeclClangTypeToDie().find(\n      compiler_type_no_qualifiers.GetOpaqueQualType());\n  if (die_it == GetForwardDeclClangTypeToDie().end()) {\n    // We have already resolved this type...\n    return true;\n  }\n\n  DWARFDIE dwarf_die = GetDIE(die_it->getSecond());\n  if (dwarf_die) {\n    // Once we start resolving this type, remove it from the forward\n    // declaration map in case anyone child members or other types require this\n    // type to get resolved. The type will get resolved when all of the calls\n    // to SymbolFileDWARF::ResolveClangOpaqueTypeDefinition are done.\n    GetForwardDeclClangTypeToDie().erase(die_it);\n\n    Type *type = GetDIEToType().lookup(dwarf_die.GetDIE());\n\n    Log *log(LogChannelDWARF::GetLogIfAny(DWARF_LOG_DEBUG_INFO |\n                                          DWARF_LOG_TYPE_COMPLETION));\n    if (log)\n      GetObjectFile()->GetModule()->LogMessageVerboseBacktrace(\n          log, \"0x%8.8\" PRIx64 \": %s '%s' resolving forward declaration...\",\n          dwarf_die.GetID(), dwarf_die.GetTagAsCString(),\n          type->GetName().AsCString());\n    assert(compiler_type);\n    if (DWARFASTParser *dwarf_ast = GetDWARFParser(*dwarf_die.GetCU()))\n      return dwarf_ast->CompleteTypeFromDWARF(dwarf_die, type, compiler_type);\n  }\n  return false;\n}\n\nType *SymbolFileDWARF::ResolveType(const DWARFDIE &die,\n                                   bool assert_not_being_parsed,\n                                   bool resolve_function_context) {\n  if (die) {\n    Type *type = GetTypeForDIE(die, resolve_function_context).get();\n\n    if (assert_not_being_parsed) {\n      if (type != DIE_IS_BEING_PARSED)\n        return type;\n\n      GetObjectFile()->GetModule()->ReportError(\n          \"Parsing a die that is being parsed die: 0x%8.8x: %s %s\",\n          die.GetOffset(), die.GetTagAsCString(), die.GetName());\n\n    } else\n      return type;\n  }\n  return nullptr;\n}\n\nCompileUnit *\nSymbolFileDWARF::GetCompUnitForDWARFCompUnit(DWARFCompileUnit &dwarf_cu) {\n  if (dwarf_cu.IsDWOUnit()) {\n    DWARFCompileUnit *non_dwo_cu =\n        static_cast<DWARFCompileUnit *>(dwarf_cu.GetUserData());\n    assert(non_dwo_cu);\n    return non_dwo_cu->GetSymbolFileDWARF().GetCompUnitForDWARFCompUnit(\n        *non_dwo_cu);\n  }\n  // Check if the symbol vendor already knows about this compile unit?\n  if (dwarf_cu.GetUserData() == nullptr) {\n    // The symbol vendor doesn't know about this compile unit, we need to parse\n    // and add it to the symbol vendor object.\n    return ParseCompileUnit(dwarf_cu).get();\n  }\n  return static_cast<CompileUnit *>(dwarf_cu.GetUserData());\n}\n\nvoid SymbolFileDWARF::GetObjCMethods(\n    ConstString class_name, llvm::function_ref<bool(DWARFDIE die)> callback) {\n  m_index->GetObjCMethods(class_name, callback);\n}\n\nbool SymbolFileDWARF::GetFunction(const DWARFDIE &die, SymbolContext &sc) {\n  sc.Clear(false);\n\n  if (die && llvm::isa<DWARFCompileUnit>(die.GetCU())) {\n    // Check if the symbol vendor already knows about this compile unit?\n    sc.comp_unit =\n        GetCompUnitForDWARFCompUnit(llvm::cast<DWARFCompileUnit>(*die.GetCU()));\n\n    sc.function = sc.comp_unit->FindFunctionByUID(die.GetID()).get();\n    if (sc.function == nullptr)\n      sc.function = ParseFunction(*sc.comp_unit, die);\n\n    if (sc.function) {\n      sc.module_sp = sc.function->CalculateSymbolContextModule();\n      return true;\n    }\n  }\n\n  return false;\n}\n\nlldb::ModuleSP SymbolFileDWARF::GetExternalModule(ConstString name) {\n  UpdateExternalModuleListIfNeeded();\n  const auto &pos = m_external_type_modules.find(name);\n  if (pos != m_external_type_modules.end())\n    return pos->second;\n  else\n    return lldb::ModuleSP();\n}\n\nDWARFDIE\nSymbolFileDWARF::GetDIE(const DIERef &die_ref) {\n  if (die_ref.dwo_num()) {\n    SymbolFileDWARF *dwarf = *die_ref.dwo_num() == 0x3fffffff\n                                 ? m_dwp_symfile.get()\n                                 : this->DebugInfo()\n                                       .GetUnitAtIndex(*die_ref.dwo_num())\n                                       ->GetDwoSymbolFile();\n    return dwarf->DebugInfo().GetDIE(die_ref);\n  }\n\n  return DebugInfo().GetDIE(die_ref);\n}\n\n/// Return the DW_AT_(GNU_)dwo_name.\nstatic const char *GetDWOName(DWARFCompileUnit &dwarf_cu,\n                              const DWARFDebugInfoEntry &cu_die) {\n  const char *dwo_name =\n      cu_die.GetAttributeValueAsString(&dwarf_cu, DW_AT_GNU_dwo_name, nullptr);\n  if (!dwo_name)\n    dwo_name =\n        cu_die.GetAttributeValueAsString(&dwarf_cu, DW_AT_dwo_name, nullptr);\n  return dwo_name;\n}\n\n/// Return the DW_AT_(GNU_)dwo_id.\n/// FIXME: Technically 0 is a valid hash.\nstatic uint64_t GetDWOId(DWARFCompileUnit &dwarf_cu,\n                         const DWARFDebugInfoEntry &cu_die) {\n  uint64_t dwo_id =\n      cu_die.GetAttributeValueAsUnsigned(&dwarf_cu, DW_AT_GNU_dwo_id, 0);\n  if (!dwo_id)\n    dwo_id = cu_die.GetAttributeValueAsUnsigned(&dwarf_cu, DW_AT_dwo_id, 0);\n  return dwo_id;\n}\n\nllvm::Optional<uint64_t> SymbolFileDWARF::GetDWOId() {\n  if (GetNumCompileUnits() == 1) {\n    if (auto comp_unit = GetCompileUnitAtIndex(0))\n      if (DWARFCompileUnit *cu = GetDWARFCompileUnit(comp_unit.get()))\n        if (DWARFDebugInfoEntry *cu_die = cu->DIE().GetDIE())\n          if (uint64_t dwo_id = ::GetDWOId(*cu, *cu_die))\n            return dwo_id;\n  }\n  return {};\n}\n\nstd::shared_ptr<SymbolFileDWARFDwo>\nSymbolFileDWARF::GetDwoSymbolFileForCompileUnit(\n    DWARFUnit &unit, const DWARFDebugInfoEntry &cu_die) {\n  // If this is a Darwin-style debug map (non-.dSYM) symbol file,\n  // never attempt to load ELF-style DWO files since the -gmodules\n  // support uses the same DWO machanism to specify full debug info\n  // files for modules. This is handled in\n  // UpdateExternalModuleListIfNeeded().\n  if (GetDebugMapSymfile())\n    return nullptr;\n\n  DWARFCompileUnit *dwarf_cu = llvm::dyn_cast<DWARFCompileUnit>(&unit);\n  // Only compile units can be split into two parts.\n  if (!dwarf_cu)\n    return nullptr;\n\n  const char *dwo_name = GetDWOName(*dwarf_cu, cu_die);\n  if (!dwo_name)\n    return nullptr;\n\n  if (std::shared_ptr<SymbolFileDWARFDwo> dwp_sp = GetDwpSymbolFile())\n    return dwp_sp;\n\n  FileSpec dwo_file(dwo_name);\n  FileSystem::Instance().Resolve(dwo_file);\n  if (dwo_file.IsRelative()) {\n    const char *comp_dir =\n        cu_die.GetAttributeValueAsString(dwarf_cu, DW_AT_comp_dir, nullptr);\n    if (!comp_dir)\n      return nullptr;\n\n    dwo_file.SetFile(comp_dir, FileSpec::Style::native);\n    FileSystem::Instance().Resolve(dwo_file);\n    dwo_file.AppendPathComponent(dwo_name);\n  }\n\n  if (!FileSystem::Instance().Exists(dwo_file))\n    return nullptr;\n\n  const lldb::offset_t file_offset = 0;\n  DataBufferSP dwo_file_data_sp;\n  lldb::offset_t dwo_file_data_offset = 0;\n  ObjectFileSP dwo_obj_file = ObjectFile::FindPlugin(\n      GetObjectFile()->GetModule(), &dwo_file, file_offset,\n      FileSystem::Instance().GetByteSize(dwo_file), dwo_file_data_sp,\n      dwo_file_data_offset);\n  if (dwo_obj_file == nullptr)\n    return nullptr;\n\n  return std::make_shared<SymbolFileDWARFDwo>(*this, dwo_obj_file,\n                                              dwarf_cu->GetID());\n}\n\nvoid SymbolFileDWARF::UpdateExternalModuleListIfNeeded() {\n  if (m_fetched_external_modules)\n    return;\n  m_fetched_external_modules = true;\n  DWARFDebugInfo &debug_info = DebugInfo();\n\n  // Follow DWO skeleton unit breadcrumbs.\n  const uint32_t num_compile_units = GetNumCompileUnits();\n  for (uint32_t cu_idx = 0; cu_idx < num_compile_units; ++cu_idx) {\n    auto *dwarf_cu =\n        llvm::dyn_cast<DWARFCompileUnit>(debug_info.GetUnitAtIndex(cu_idx));\n    if (!dwarf_cu)\n      continue;\n\n    const DWARFBaseDIE die = dwarf_cu->GetUnitDIEOnly();\n    if (!die || die.HasChildren() || !die.GetDIE())\n      continue;\n\n    const char *name = die.GetAttributeValueAsString(DW_AT_name, nullptr);\n    if (!name)\n      continue;\n\n    ConstString const_name(name);\n    ModuleSP &module_sp = m_external_type_modules[const_name];\n    if (module_sp)\n      continue;\n\n    const char *dwo_path = GetDWOName(*dwarf_cu, *die.GetDIE());\n    if (!dwo_path)\n      continue;\n\n    ModuleSpec dwo_module_spec;\n    dwo_module_spec.GetFileSpec().SetFile(dwo_path, FileSpec::Style::native);\n    if (dwo_module_spec.GetFileSpec().IsRelative()) {\n      const char *comp_dir =\n          die.GetAttributeValueAsString(DW_AT_comp_dir, nullptr);\n      if (comp_dir) {\n        dwo_module_spec.GetFileSpec().SetFile(comp_dir,\n                                              FileSpec::Style::native);\n        FileSystem::Instance().Resolve(dwo_module_spec.GetFileSpec());\n        dwo_module_spec.GetFileSpec().AppendPathComponent(dwo_path);\n      }\n    }\n    dwo_module_spec.GetArchitecture() =\n        m_objfile_sp->GetModule()->GetArchitecture();\n\n    // When LLDB loads \"external\" modules it looks at the presence of\n    // DW_AT_dwo_name. However, when the already created module\n    // (corresponding to .dwo itself) is being processed, it will see\n    // the presence of DW_AT_dwo_name (which contains the name of dwo\n    // file) and will try to call ModuleList::GetSharedModule\n    // again. In some cases (i.e., for empty files) Clang 4.0\n    // generates a *.dwo file which has DW_AT_dwo_name, but no\n    // DW_AT_comp_dir. In this case the method\n    // ModuleList::GetSharedModule will fail and the warning will be\n    // printed. However, as one can notice in this case we don't\n    // actually need to try to load the already loaded module\n    // (corresponding to .dwo) so we simply skip it.\n    if (m_objfile_sp->GetFileSpec().GetFileNameExtension() == \".dwo\" &&\n        llvm::StringRef(m_objfile_sp->GetFileSpec().GetPath())\n            .endswith(dwo_module_spec.GetFileSpec().GetPath())) {\n      continue;\n    }\n\n    Status error = ModuleList::GetSharedModule(dwo_module_spec, module_sp,\n                                               nullptr, nullptr, nullptr);\n    if (!module_sp) {\n      GetObjectFile()->GetModule()->ReportWarning(\n          \"0x%8.8x: unable to locate module needed for external types: \"\n          \"%s\\nerror: %s\\nDebugging will be degraded due to missing \"\n          \"types. Rebuilding the project will regenerate the needed \"\n          \"module files.\",\n          die.GetOffset(), dwo_module_spec.GetFileSpec().GetPath().c_str(),\n          error.AsCString(\"unknown error\"));\n      continue;\n    }\n\n    // Verify the DWO hash.\n    // FIXME: Technically \"0\" is a valid hash.\n    uint64_t dwo_id = ::GetDWOId(*dwarf_cu, *die.GetDIE());\n    if (!dwo_id)\n      continue;\n\n    auto *dwo_symfile =\n        llvm::dyn_cast_or_null<SymbolFileDWARF>(module_sp->GetSymbolFile());\n    if (!dwo_symfile)\n      continue;\n    llvm::Optional<uint64_t> dwo_dwo_id = dwo_symfile->GetDWOId();\n    if (!dwo_dwo_id)\n      continue;\n\n    if (dwo_id != dwo_dwo_id) {\n      GetObjectFile()->GetModule()->ReportWarning(\n          \"0x%8.8x: Module %s is out-of-date (hash mismatch). Type information \"\n          \"from this module may be incomplete or inconsistent with the rest of \"\n          \"the program. Rebuilding the project will regenerate the needed \"\n          \"module files.\",\n          die.GetOffset(), dwo_module_spec.GetFileSpec().GetPath().c_str());\n    }\n  }\n}\n\nSymbolFileDWARF::GlobalVariableMap &SymbolFileDWARF::GetGlobalAranges() {\n  if (!m_global_aranges_up) {\n    m_global_aranges_up = std::make_unique<GlobalVariableMap>();\n\n    ModuleSP module_sp = GetObjectFile()->GetModule();\n    if (module_sp) {\n      const size_t num_cus = module_sp->GetNumCompileUnits();\n      for (size_t i = 0; i < num_cus; ++i) {\n        CompUnitSP cu_sp = module_sp->GetCompileUnitAtIndex(i);\n        if (cu_sp) {\n          VariableListSP globals_sp = cu_sp->GetVariableList(true);\n          if (globals_sp) {\n            const size_t num_globals = globals_sp->GetSize();\n            for (size_t g = 0; g < num_globals; ++g) {\n              VariableSP var_sp = globals_sp->GetVariableAtIndex(g);\n              if (var_sp && !var_sp->GetLocationIsConstantValueData()) {\n                const DWARFExpression &location = var_sp->LocationExpression();\n                Value location_result;\n                Status error;\n                if (location.Evaluate(nullptr, LLDB_INVALID_ADDRESS, nullptr,\n                                      nullptr, location_result, &error)) {\n                  if (location_result.GetValueType() ==\n                      Value::ValueType::FileAddress) {\n                    lldb::addr_t file_addr =\n                        location_result.GetScalar().ULongLong();\n                    lldb::addr_t byte_size = 1;\n                    if (var_sp->GetType())\n                      byte_size =\n                          var_sp->GetType()->GetByteSize(nullptr).getValueOr(0);\n                    m_global_aranges_up->Append(GlobalVariableMap::Entry(\n                        file_addr, byte_size, var_sp.get()));\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    m_global_aranges_up->Sort();\n  }\n  return *m_global_aranges_up;\n}\n\nvoid SymbolFileDWARF::ResolveFunctionAndBlock(lldb::addr_t file_vm_addr,\n                                              bool lookup_block,\n                                              SymbolContext &sc) {\n  assert(sc.comp_unit);\n  DWARFCompileUnit &cu =\n      GetDWARFCompileUnit(sc.comp_unit)->GetNonSkeletonUnit();\n  DWARFDIE function_die = cu.LookupAddress(file_vm_addr);\n  DWARFDIE block_die;\n  if (function_die) {\n    sc.function = sc.comp_unit->FindFunctionByUID(function_die.GetID()).get();\n    if (sc.function == nullptr)\n      sc.function = ParseFunction(*sc.comp_unit, function_die);\n\n    if (sc.function && lookup_block)\n      block_die = function_die.LookupDeepestBlock(file_vm_addr);\n  }\n\n  if (!sc.function || ! lookup_block)\n    return;\n\n  Block &block = sc.function->GetBlock(true);\n  if (block_die)\n    sc.block = block.FindBlockByID(block_die.GetID());\n  else\n    sc.block = block.FindBlockByID(function_die.GetID());\n}\n\nuint32_t SymbolFileDWARF::ResolveSymbolContext(const Address &so_addr,\n                                               SymbolContextItem resolve_scope,\n                                               SymbolContext &sc) {\n  std::lock_guard<std::recursive_mutex> guard(GetModuleMutex());\n  LLDB_SCOPED_TIMERF(\"SymbolFileDWARF::\"\n                     \"ResolveSymbolContext (so_addr = { \"\n                     \"section = %p, offset = 0x%\" PRIx64\n                     \" }, resolve_scope = 0x%8.8x)\",\n                     static_cast<void *>(so_addr.GetSection().get()),\n                     so_addr.GetOffset(), resolve_scope);\n  uint32_t resolved = 0;\n  if (resolve_scope &\n      (eSymbolContextCompUnit | eSymbolContextFunction | eSymbolContextBlock |\n       eSymbolContextLineEntry | eSymbolContextVariable)) {\n    lldb::addr_t file_vm_addr = so_addr.GetFileAddress();\n\n    DWARFDebugInfo &debug_info = DebugInfo();\n    llvm::Expected<DWARFDebugAranges &> aranges =\n        debug_info.GetCompileUnitAranges();\n    if (!aranges) {\n      Log *log = LogChannelDWARF::GetLogIfAll(DWARF_LOG_DEBUG_INFO);\n      LLDB_LOG_ERROR(log, aranges.takeError(),\n                     \"SymbolFileDWARF::ResolveSymbolContext failed to get cu \"\n                     \"aranges.  {0}\");\n      return 0;\n    }\n\n    const dw_offset_t cu_offset = aranges->FindAddress(file_vm_addr);\n    if (cu_offset == DW_INVALID_OFFSET) {\n      // Global variables are not in the compile unit address ranges. The only\n      // way to currently find global variables is to iterate over the\n      // .debug_pubnames or the __apple_names table and find all items in there\n      // that point to DW_TAG_variable DIEs and then find the address that\n      // matches.\n      if (resolve_scope & eSymbolContextVariable) {\n        GlobalVariableMap &map = GetGlobalAranges();\n        const GlobalVariableMap::Entry *entry =\n            map.FindEntryThatContains(file_vm_addr);\n        if (entry && entry->data) {\n          Variable *variable = entry->data;\n          SymbolContextScope *scc = variable->GetSymbolContextScope();\n          if (scc) {\n            scc->CalculateSymbolContext(&sc);\n            sc.variable = variable;\n          }\n          return sc.GetResolvedMask();\n        }\n      }\n    } else {\n      uint32_t cu_idx = DW_INVALID_INDEX;\n      if (auto *dwarf_cu = llvm::dyn_cast_or_null<DWARFCompileUnit>(\n              debug_info.GetUnitAtOffset(DIERef::Section::DebugInfo, cu_offset,\n                                         &cu_idx))) {\n        sc.comp_unit = GetCompUnitForDWARFCompUnit(*dwarf_cu);\n        if (sc.comp_unit) {\n          resolved |= eSymbolContextCompUnit;\n\n          bool force_check_line_table = false;\n          if (resolve_scope & (eSymbolContextFunction | eSymbolContextBlock)) {\n            ResolveFunctionAndBlock(file_vm_addr,\n                                    resolve_scope & eSymbolContextBlock, sc);\n            if (sc.function)\n              resolved |= eSymbolContextFunction;\n            else {\n              // We might have had a compile unit that had discontiguous address\n              // ranges where the gaps are symbols that don't have any debug\n              // info. Discontiguous compile unit address ranges should only\n              // happen when there aren't other functions from other compile\n              // units in these gaps. This helps keep the size of the aranges\n              // down.\n              force_check_line_table = true;\n            }\n            if (sc.block)\n              resolved |= eSymbolContextBlock;\n          }\n\n          if ((resolve_scope & eSymbolContextLineEntry) ||\n              force_check_line_table) {\n            LineTable *line_table = sc.comp_unit->GetLineTable();\n            if (line_table != nullptr) {\n              // And address that makes it into this function should be in terms\n              // of this debug file if there is no debug map, or it will be an\n              // address in the .o file which needs to be fixed up to be in\n              // terms of the debug map executable. Either way, calling\n              // FixupAddress() will work for us.\n              Address exe_so_addr(so_addr);\n              if (FixupAddress(exe_so_addr)) {\n                if (line_table->FindLineEntryByAddress(exe_so_addr,\n                                                       sc.line_entry)) {\n                  resolved |= eSymbolContextLineEntry;\n                }\n              }\n            }\n          }\n\n          if (force_check_line_table && !(resolved & eSymbolContextLineEntry)) {\n            // We might have had a compile unit that had discontiguous address\n            // ranges where the gaps are symbols that don't have any debug info.\n            // Discontiguous compile unit address ranges should only happen when\n            // there aren't other functions from other compile units in these\n            // gaps. This helps keep the size of the aranges down.\n            sc.comp_unit = nullptr;\n            resolved &= ~eSymbolContextCompUnit;\n          }\n        } else {\n          GetObjectFile()->GetModule()->ReportWarning(\n              \"0x%8.8x: compile unit %u failed to create a valid \"\n              \"lldb_private::CompileUnit class.\",\n              cu_offset, cu_idx);\n        }\n      }\n    }\n  }\n  return resolved;\n}\n\nuint32_t SymbolFileDWARF::ResolveSymbolContext(const FileSpec &file_spec,\n                                               uint32_t line,\n                                               bool check_inlines,\n                                               SymbolContextItem resolve_scope,\n                                               SymbolContextList &sc_list) {\n  std::lock_guard<std::recursive_mutex> guard(GetModuleMutex());\n  const uint32_t prev_size = sc_list.GetSize();\n  if (resolve_scope & eSymbolContextCompUnit) {\n    for (uint32_t cu_idx = 0, num_cus = GetNumCompileUnits(); cu_idx < num_cus;\n         ++cu_idx) {\n      CompileUnit *dc_cu = ParseCompileUnitAtIndex(cu_idx).get();\n      if (!dc_cu)\n        continue;\n\n      bool file_spec_matches_cu_file_spec =\n          FileSpec::Match(file_spec, dc_cu->GetPrimaryFile());\n      if (check_inlines || file_spec_matches_cu_file_spec) {\n        SymbolContext sc(m_objfile_sp->GetModule());\n        sc.comp_unit = dc_cu;\n        uint32_t file_idx = UINT32_MAX;\n\n        // If we are looking for inline functions only and we don't find it\n        // in the support files, we are done.\n        if (check_inlines) {\n          file_idx =\n              sc.comp_unit->GetSupportFiles().FindFileIndex(1, file_spec, true);\n          if (file_idx == UINT32_MAX)\n            continue;\n        }\n\n        if (line != 0) {\n          LineTable *line_table = sc.comp_unit->GetLineTable();\n\n          if (line_table != nullptr && line != 0) {\n            // We will have already looked up the file index if we are\n            // searching for inline entries.\n            if (!check_inlines)\n              file_idx = sc.comp_unit->GetSupportFiles().FindFileIndex(\n                  1, file_spec, true);\n\n            if (file_idx != UINT32_MAX) {\n              uint32_t found_line;\n              uint32_t line_idx = line_table->FindLineEntryIndexByFileIndex(\n                  0, file_idx, line, false, &sc.line_entry);\n              found_line = sc.line_entry.line;\n\n              while (line_idx != UINT32_MAX) {\n                sc.function = nullptr;\n                sc.block = nullptr;\n                if (resolve_scope &\n                    (eSymbolContextFunction | eSymbolContextBlock)) {\n                  const lldb::addr_t file_vm_addr =\n                      sc.line_entry.range.GetBaseAddress().GetFileAddress();\n                  if (file_vm_addr != LLDB_INVALID_ADDRESS) {\n                    ResolveFunctionAndBlock(\n                        file_vm_addr, resolve_scope & eSymbolContextBlock, sc);\n                  }\n                }\n\n                sc_list.Append(sc);\n                line_idx = line_table->FindLineEntryIndexByFileIndex(\n                    line_idx + 1, file_idx, found_line, true, &sc.line_entry);\n              }\n            }\n          } else if (file_spec_matches_cu_file_spec && !check_inlines) {\n            // only append the context if we aren't looking for inline call\n            // sites by file and line and if the file spec matches that of\n            // the compile unit\n            sc_list.Append(sc);\n          }\n        } else if (file_spec_matches_cu_file_spec && !check_inlines) {\n          // only append the context if we aren't looking for inline call\n          // sites by file and line and if the file spec matches that of\n          // the compile unit\n          sc_list.Append(sc);\n        }\n\n        if (!check_inlines)\n          break;\n      }\n    }\n  }\n  return sc_list.GetSize() - prev_size;\n}\n\nvoid SymbolFileDWARF::PreloadSymbols() {\n  std::lock_guard<std::recursive_mutex> guard(GetModuleMutex());\n  m_index->Preload();\n}\n\nstd::recursive_mutex &SymbolFileDWARF::GetModuleMutex() const {\n  lldb::ModuleSP module_sp(m_debug_map_module_wp.lock());\n  if (module_sp)\n    return module_sp->GetMutex();\n  return GetObjectFile()->GetModule()->GetMutex();\n}\n\nbool SymbolFileDWARF::DeclContextMatchesThisSymbolFile(\n    const lldb_private::CompilerDeclContext &decl_ctx) {\n  if (!decl_ctx.IsValid()) {\n    // Invalid namespace decl which means we aren't matching only things in\n    // this symbol file, so return true to indicate it matches this symbol\n    // file.\n    return true;\n  }\n\n  TypeSystem *decl_ctx_type_system = decl_ctx.GetTypeSystem();\n  auto type_system_or_err = GetTypeSystemForLanguage(\n      decl_ctx_type_system->GetMinimumLanguage(nullptr));\n  if (auto err = type_system_or_err.takeError()) {\n    LLDB_LOG_ERROR(lldb_private::GetLogIfAnyCategoriesSet(LIBLLDB_LOG_SYMBOLS),\n                   std::move(err),\n                   \"Unable to match namespace decl using TypeSystem\");\n    return false;\n  }\n\n  if (decl_ctx_type_system == &type_system_or_err.get())\n    return true; // The type systems match, return true\n\n  // The namespace AST was valid, and it does not match...\n  Log *log(LogChannelDWARF::GetLogIfAll(DWARF_LOG_LOOKUPS));\n\n  if (log)\n    GetObjectFile()->GetModule()->LogMessage(\n        log, \"Valid namespace does not match symbol file\");\n\n  return false;\n}\n\nvoid SymbolFileDWARF::FindGlobalVariables(\n    ConstString name, const CompilerDeclContext &parent_decl_ctx,\n    uint32_t max_matches, VariableList &variables) {\n  std::lock_guard<std::recursive_mutex> guard(GetModuleMutex());\n  Log *log(LogChannelDWARF::GetLogIfAll(DWARF_LOG_LOOKUPS));\n\n  if (log)\n    GetObjectFile()->GetModule()->LogMessage(\n        log,\n        \"SymbolFileDWARF::FindGlobalVariables (name=\\\"%s\\\", \"\n        \"parent_decl_ctx=%p, max_matches=%u, variables)\",\n        name.GetCString(), static_cast<const void *>(&parent_decl_ctx),\n        max_matches);\n\n  if (!DeclContextMatchesThisSymbolFile(parent_decl_ctx))\n    return;\n\n  // Remember how many variables are in the list before we search.\n  const uint32_t original_size = variables.GetSize();\n\n  llvm::StringRef basename;\n  llvm::StringRef context;\n  bool name_is_mangled = (bool)Mangled(name);\n\n  if (!CPlusPlusLanguage::ExtractContextAndIdentifier(name.GetCString(),\n                                                      context, basename))\n    basename = name.GetStringRef();\n\n  // Loop invariant: Variables up to this index have been checked for context\n  // matches.\n  uint32_t pruned_idx = original_size;\n\n  SymbolContext sc;\n  m_index->GetGlobalVariables(ConstString(basename), [&](DWARFDIE die) {\n    if (!sc.module_sp)\n      sc.module_sp = m_objfile_sp->GetModule();\n    assert(sc.module_sp);\n\n    if (die.Tag() != DW_TAG_variable)\n      return true;\n\n    auto *dwarf_cu = llvm::dyn_cast<DWARFCompileUnit>(die.GetCU());\n    if (!dwarf_cu)\n      return true;\n    sc.comp_unit = GetCompUnitForDWARFCompUnit(*dwarf_cu);\n\n    if (parent_decl_ctx) {\n      if (DWARFASTParser *dwarf_ast = GetDWARFParser(*die.GetCU())) {\n        CompilerDeclContext actual_parent_decl_ctx =\n            dwarf_ast->GetDeclContextContainingUIDFromDWARF(die);\n        if (!actual_parent_decl_ctx ||\n            actual_parent_decl_ctx != parent_decl_ctx)\n          return true;\n      }\n    }\n\n    ParseVariables(sc, die, LLDB_INVALID_ADDRESS, false, false, &variables);\n    while (pruned_idx < variables.GetSize()) {\n      VariableSP var_sp = variables.GetVariableAtIndex(pruned_idx);\n      if (name_is_mangled ||\n          var_sp->GetName().GetStringRef().contains(name.GetStringRef()))\n        ++pruned_idx;\n      else\n        variables.RemoveVariableAtIndex(pruned_idx);\n    }\n\n    return variables.GetSize() - original_size < max_matches;\n  });\n\n  // Return the number of variable that were appended to the list\n  const uint32_t num_matches = variables.GetSize() - original_size;\n  if (log && num_matches > 0) {\n    GetObjectFile()->GetModule()->LogMessage(\n        log,\n        \"SymbolFileDWARF::FindGlobalVariables (name=\\\"%s\\\", \"\n        \"parent_decl_ctx=%p, max_matches=%u, variables) => %u\",\n        name.GetCString(), static_cast<const void *>(&parent_decl_ctx),\n        max_matches, num_matches);\n  }\n}\n\nvoid SymbolFileDWARF::FindGlobalVariables(const RegularExpression &regex,\n                                          uint32_t max_matches,\n                                          VariableList &variables) {\n  std::lock_guard<std::recursive_mutex> guard(GetModuleMutex());\n  Log *log(LogChannelDWARF::GetLogIfAll(DWARF_LOG_LOOKUPS));\n\n  if (log) {\n    GetObjectFile()->GetModule()->LogMessage(\n        log,\n        \"SymbolFileDWARF::FindGlobalVariables (regex=\\\"%s\\\", \"\n        \"max_matches=%u, variables)\",\n        regex.GetText().str().c_str(), max_matches);\n  }\n\n  // Remember how many variables are in the list before we search.\n  const uint32_t original_size = variables.GetSize();\n\n  SymbolContext sc;\n  m_index->GetGlobalVariables(regex, [&](DWARFDIE die) {\n    if (!sc.module_sp)\n      sc.module_sp = m_objfile_sp->GetModule();\n    assert(sc.module_sp);\n\n    DWARFCompileUnit *dwarf_cu = llvm::dyn_cast<DWARFCompileUnit>(die.GetCU());\n    if (!dwarf_cu)\n      return true;\n    sc.comp_unit = GetCompUnitForDWARFCompUnit(*dwarf_cu);\n\n    ParseVariables(sc, die, LLDB_INVALID_ADDRESS, false, false, &variables);\n\n    return variables.GetSize() - original_size < max_matches;\n  });\n}\n\nbool SymbolFileDWARF::ResolveFunction(const DWARFDIE &orig_die,\n                                      bool include_inlines,\n                                      SymbolContextList &sc_list) {\n  SymbolContext sc;\n\n  if (!orig_die)\n    return false;\n\n  // If we were passed a die that is not a function, just return false...\n  if (!(orig_die.Tag() == DW_TAG_subprogram ||\n        (include_inlines && orig_die.Tag() == DW_TAG_inlined_subroutine)))\n    return false;\n\n  DWARFDIE die = orig_die;\n  DWARFDIE inlined_die;\n  if (die.Tag() == DW_TAG_inlined_subroutine) {\n    inlined_die = die;\n\n    while (true) {\n      die = die.GetParent();\n\n      if (die) {\n        if (die.Tag() == DW_TAG_subprogram)\n          break;\n      } else\n        break;\n    }\n  }\n  assert(die && die.Tag() == DW_TAG_subprogram);\n  if (GetFunction(die, sc)) {\n    Address addr;\n    // Parse all blocks if needed\n    if (inlined_die) {\n      Block &function_block = sc.function->GetBlock(true);\n      sc.block = function_block.FindBlockByID(inlined_die.GetID());\n      if (sc.block == nullptr)\n        sc.block = function_block.FindBlockByID(inlined_die.GetOffset());\n      if (sc.block == nullptr || !sc.block->GetStartAddress(addr))\n        addr.Clear();\n    } else {\n      sc.block = nullptr;\n      addr = sc.function->GetAddressRange().GetBaseAddress();\n    }\n\n\n    if (auto section_sp = addr.GetSection()) {\n      if (section_sp->GetPermissions() & ePermissionsExecutable) {\n        sc_list.Append(sc);\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nbool SymbolFileDWARF::DIEInDeclContext(const CompilerDeclContext &decl_ctx,\n                                       const DWARFDIE &die) {\n  // If we have no parent decl context to match this DIE matches, and if the\n  // parent decl context isn't valid, we aren't trying to look for any\n  // particular decl context so any die matches.\n  if (!decl_ctx.IsValid())\n    return true;\n\n  if (die) {\n    if (DWARFASTParser *dwarf_ast = GetDWARFParser(*die.GetCU())) {\n      if (CompilerDeclContext actual_decl_ctx =\n              dwarf_ast->GetDeclContextContainingUIDFromDWARF(die))\n        return decl_ctx.IsContainedInLookup(actual_decl_ctx);\n    }\n  }\n  return false;\n}\n\nvoid SymbolFileDWARF::FindFunctions(ConstString name,\n                                    const CompilerDeclContext &parent_decl_ctx,\n                                    FunctionNameType name_type_mask,\n                                    bool include_inlines,\n                                    SymbolContextList &sc_list) {\n  std::lock_guard<std::recursive_mutex> guard(GetModuleMutex());\n  LLDB_SCOPED_TIMERF(\"SymbolFileDWARF::FindFunctions (name = '%s')\",\n                     name.AsCString());\n\n  // eFunctionNameTypeAuto should be pre-resolved by a call to\n  // Module::LookupInfo::LookupInfo()\n  assert((name_type_mask & eFunctionNameTypeAuto) == 0);\n\n  Log *log(LogChannelDWARF::GetLogIfAll(DWARF_LOG_LOOKUPS));\n\n  if (log) {\n    GetObjectFile()->GetModule()->LogMessage(\n        log,\n        \"SymbolFileDWARF::FindFunctions (name=\\\"%s\\\", name_type_mask=0x%x, sc_list)\",\n        name.GetCString(), name_type_mask);\n  }\n\n  if (!DeclContextMatchesThisSymbolFile(parent_decl_ctx))\n    return;\n\n  // If name is empty then we won't find anything.\n  if (name.IsEmpty())\n    return;\n\n  // Remember how many sc_list are in the list before we search in case we are\n  // appending the results to a variable list.\n\n  const uint32_t original_size = sc_list.GetSize();\n\n  llvm::DenseSet<const DWARFDebugInfoEntry *> resolved_dies;\n\n  m_index->GetFunctions(name, *this, parent_decl_ctx, name_type_mask,\n                        [&](DWARFDIE die) {\n                          if (resolved_dies.insert(die.GetDIE()).second)\n                            ResolveFunction(die, include_inlines, sc_list);\n                          return true;\n                        });\n\n  // Return the number of variable that were appended to the list\n  const uint32_t num_matches = sc_list.GetSize() - original_size;\n\n  if (log && num_matches > 0) {\n    GetObjectFile()->GetModule()->LogMessage(\n        log,\n        \"SymbolFileDWARF::FindFunctions (name=\\\"%s\\\", \"\n        \"name_type_mask=0x%x, include_inlines=%d, sc_list) => %u\",\n        name.GetCString(), name_type_mask, include_inlines,\n        num_matches);\n  }\n}\n\nvoid SymbolFileDWARF::FindFunctions(const RegularExpression &regex,\n                                    bool include_inlines,\n                                    SymbolContextList &sc_list) {\n  std::lock_guard<std::recursive_mutex> guard(GetModuleMutex());\n  LLDB_SCOPED_TIMERF(\"SymbolFileDWARF::FindFunctions (regex = '%s')\",\n                     regex.GetText().str().c_str());\n\n  Log *log(LogChannelDWARF::GetLogIfAll(DWARF_LOG_LOOKUPS));\n\n  if (log) {\n    GetObjectFile()->GetModule()->LogMessage(\n        log, \"SymbolFileDWARF::FindFunctions (regex=\\\"%s\\\", sc_list)\",\n        regex.GetText().str().c_str());\n  }\n\n  llvm::DenseSet<const DWARFDebugInfoEntry *> resolved_dies;\n  m_index->GetFunctions(regex, [&](DWARFDIE die) {\n    if (resolved_dies.insert(die.GetDIE()).second)\n      ResolveFunction(die, include_inlines, sc_list);\n    return true;\n  });\n}\n\nvoid SymbolFileDWARF::GetMangledNamesForFunction(\n    const std::string &scope_qualified_name,\n    std::vector<ConstString> &mangled_names) {\n  DWARFDebugInfo &info = DebugInfo();\n  uint32_t num_comp_units = info.GetNumUnits();\n  for (uint32_t i = 0; i < num_comp_units; i++) {\n    DWARFUnit *cu = info.GetUnitAtIndex(i);\n    if (cu == nullptr)\n      continue;\n\n    SymbolFileDWARFDwo *dwo = cu->GetDwoSymbolFile();\n    if (dwo)\n      dwo->GetMangledNamesForFunction(scope_qualified_name, mangled_names);\n  }\n\n  for (DIERef die_ref :\n       m_function_scope_qualified_name_map.lookup(scope_qualified_name)) {\n    DWARFDIE die = GetDIE(die_ref);\n    mangled_names.push_back(ConstString(die.GetMangledName()));\n  }\n}\n\nvoid SymbolFileDWARF::FindTypes(\n    ConstString name, const CompilerDeclContext &parent_decl_ctx,\n    uint32_t max_matches,\n    llvm::DenseSet<lldb_private::SymbolFile *> &searched_symbol_files,\n    TypeMap &types) {\n  std::lock_guard<std::recursive_mutex> guard(GetModuleMutex());\n  // Make sure we haven't already searched this SymbolFile before.\n  if (!searched_symbol_files.insert(this).second)\n    return;\n\n  Log *log(LogChannelDWARF::GetLogIfAll(DWARF_LOG_LOOKUPS));\n\n  if (log) {\n    if (parent_decl_ctx)\n      GetObjectFile()->GetModule()->LogMessage(\n          log,\n          \"SymbolFileDWARF::FindTypes (sc, name=\\\"%s\\\", parent_decl_ctx = \"\n          \"%p (\\\"%s\\\"), max_matches=%u, type_list)\",\n          name.GetCString(), static_cast<const void *>(&parent_decl_ctx),\n          parent_decl_ctx.GetName().AsCString(\"<NULL>\"), max_matches);\n    else\n      GetObjectFile()->GetModule()->LogMessage(\n          log,\n          \"SymbolFileDWARF::FindTypes (sc, name=\\\"%s\\\", parent_decl_ctx = \"\n          \"NULL, max_matches=%u, type_list)\",\n          name.GetCString(), max_matches);\n  }\n\n  if (!DeclContextMatchesThisSymbolFile(parent_decl_ctx))\n    return;\n\n  m_index->GetTypes(name, [&](DWARFDIE die) {\n    if (!DIEInDeclContext(parent_decl_ctx, die))\n      return true; // The containing decl contexts don't match\n\n    Type *matching_type = ResolveType(die, true, true);\n    if (!matching_type)\n      return true;\n\n    // We found a type pointer, now find the shared pointer form our type\n    // list\n    types.InsertUnique(matching_type->shared_from_this());\n    return types.GetSize() < max_matches;\n  });\n\n  // Next search through the reachable Clang modules. This only applies for\n  // DWARF objects compiled with -gmodules that haven't been processed by\n  // dsymutil.\n  if (types.GetSize() < max_matches) {\n    UpdateExternalModuleListIfNeeded();\n\n    for (const auto &pair : m_external_type_modules)\n      if (ModuleSP external_module_sp = pair.second)\n        if (SymbolFile *sym_file = external_module_sp->GetSymbolFile())\n          sym_file->FindTypes(name, parent_decl_ctx, max_matches,\n                              searched_symbol_files, types);\n  }\n\n  if (log && types.GetSize()) {\n    if (parent_decl_ctx) {\n      GetObjectFile()->GetModule()->LogMessage(\n          log,\n          \"SymbolFileDWARF::FindTypes (sc, name=\\\"%s\\\", parent_decl_ctx \"\n          \"= %p (\\\"%s\\\"), max_matches=%u, type_list) => %u\",\n          name.GetCString(), static_cast<const void *>(&parent_decl_ctx),\n          parent_decl_ctx.GetName().AsCString(\"<NULL>\"), max_matches,\n          types.GetSize());\n    } else {\n      GetObjectFile()->GetModule()->LogMessage(\n          log,\n          \"SymbolFileDWARF::FindTypes (sc, name=\\\"%s\\\", parent_decl_ctx \"\n          \"= NULL, max_matches=%u, type_list) => %u\",\n          name.GetCString(), max_matches, types.GetSize());\n    }\n  }\n}\n\nvoid SymbolFileDWARF::FindTypes(\n    llvm::ArrayRef<CompilerContext> pattern, LanguageSet languages,\n    llvm::DenseSet<SymbolFile *> &searched_symbol_files, TypeMap &types) {\n  // Make sure we haven't already searched this SymbolFile before.\n  if (!searched_symbol_files.insert(this).second)\n    return;\n\n  std::lock_guard<std::recursive_mutex> guard(GetModuleMutex());\n  if (pattern.empty())\n    return;\n\n  ConstString name = pattern.back().name;\n\n  if (!name)\n    return;\n\n  m_index->GetTypes(name, [&](DWARFDIE die) {\n    if (!languages[GetLanguage(*die.GetCU())])\n      return true;\n\n    llvm::SmallVector<CompilerContext, 4> die_context;\n    die.GetDeclContext(die_context);\n    if (!contextMatches(die_context, pattern))\n      return true;\n\n    if (Type *matching_type = ResolveType(die, true, true)) {\n      // We found a type pointer, now find the shared pointer form our type\n      // list.\n      types.InsertUnique(matching_type->shared_from_this());\n    }\n    return true;\n  });\n\n  // Next search through the reachable Clang modules. This only applies for\n  // DWARF objects compiled with -gmodules that haven't been processed by\n  // dsymutil.\n  UpdateExternalModuleListIfNeeded();\n\n  for (const auto &pair : m_external_type_modules)\n    if (ModuleSP external_module_sp = pair.second)\n      external_module_sp->FindTypes(pattern, languages, searched_symbol_files,\n                                    types);\n}\n\nCompilerDeclContext\nSymbolFileDWARF::FindNamespace(ConstString name,\n                               const CompilerDeclContext &parent_decl_ctx) {\n  std::lock_guard<std::recursive_mutex> guard(GetModuleMutex());\n  Log *log(LogChannelDWARF::GetLogIfAll(DWARF_LOG_LOOKUPS));\n\n  if (log) {\n    GetObjectFile()->GetModule()->LogMessage(\n        log, \"SymbolFileDWARF::FindNamespace (sc, name=\\\"%s\\\")\",\n        name.GetCString());\n  }\n\n  CompilerDeclContext namespace_decl_ctx;\n\n  if (!DeclContextMatchesThisSymbolFile(parent_decl_ctx))\n    return namespace_decl_ctx;\n\n  m_index->GetNamespaces(name, [&](DWARFDIE die) {\n    if (!DIEInDeclContext(parent_decl_ctx, die))\n      return true; // The containing decl contexts don't match\n\n    DWARFASTParser *dwarf_ast = GetDWARFParser(*die.GetCU());\n    if (!dwarf_ast)\n      return true;\n\n    namespace_decl_ctx = dwarf_ast->GetDeclContextForUIDFromDWARF(die);\n    return !namespace_decl_ctx.IsValid();\n  });\n\n  if (log && namespace_decl_ctx) {\n    GetObjectFile()->GetModule()->LogMessage(\n        log,\n        \"SymbolFileDWARF::FindNamespace (sc, name=\\\"%s\\\") => \"\n        \"CompilerDeclContext(%p/%p) \\\"%s\\\"\",\n        name.GetCString(),\n        static_cast<const void *>(namespace_decl_ctx.GetTypeSystem()),\n        static_cast<const void *>(namespace_decl_ctx.GetOpaqueDeclContext()),\n        namespace_decl_ctx.GetName().AsCString(\"<NULL>\"));\n  }\n\n  return namespace_decl_ctx;\n}\n\nTypeSP SymbolFileDWARF::GetTypeForDIE(const DWARFDIE &die,\n                                      bool resolve_function_context) {\n  TypeSP type_sp;\n  if (die) {\n    Type *type_ptr = GetDIEToType().lookup(die.GetDIE());\n    if (type_ptr == nullptr) {\n      SymbolContextScope *scope;\n      if (auto *dwarf_cu = llvm::dyn_cast<DWARFCompileUnit>(die.GetCU()))\n        scope = GetCompUnitForDWARFCompUnit(*dwarf_cu);\n      else\n        scope = GetObjectFile()->GetModule().get();\n      assert(scope);\n      SymbolContext sc(scope);\n      const DWARFDebugInfoEntry *parent_die = die.GetParent().GetDIE();\n      while (parent_die != nullptr) {\n        if (parent_die->Tag() == DW_TAG_subprogram)\n          break;\n        parent_die = parent_die->GetParent();\n      }\n      SymbolContext sc_backup = sc;\n      if (resolve_function_context && parent_die != nullptr &&\n          !GetFunction(DWARFDIE(die.GetCU(), parent_die), sc))\n        sc = sc_backup;\n\n      type_sp = ParseType(sc, die, nullptr);\n    } else if (type_ptr != DIE_IS_BEING_PARSED) {\n      // Grab the existing type from the master types lists\n      type_sp = type_ptr->shared_from_this();\n    }\n  }\n  return type_sp;\n}\n\nDWARFDIE\nSymbolFileDWARF::GetDeclContextDIEContainingDIE(const DWARFDIE &orig_die) {\n  if (orig_die) {\n    DWARFDIE die = orig_die;\n\n    while (die) {\n      // If this is the original DIE that we are searching for a declaration\n      // for, then don't look in the cache as we don't want our own decl\n      // context to be our decl context...\n      if (orig_die != die) {\n        switch (die.Tag()) {\n        case DW_TAG_compile_unit:\n        case DW_TAG_partial_unit:\n        case DW_TAG_namespace:\n        case DW_TAG_structure_type:\n        case DW_TAG_union_type:\n        case DW_TAG_class_type:\n        case DW_TAG_lexical_block:\n        case DW_TAG_subprogram:\n          return die;\n        case DW_TAG_inlined_subroutine: {\n          DWARFDIE abs_die = die.GetReferencedDIE(DW_AT_abstract_origin);\n          if (abs_die) {\n            return abs_die;\n          }\n          break;\n        }\n        default:\n          break;\n        }\n      }\n\n      DWARFDIE spec_die = die.GetReferencedDIE(DW_AT_specification);\n      if (spec_die) {\n        DWARFDIE decl_ctx_die = GetDeclContextDIEContainingDIE(spec_die);\n        if (decl_ctx_die)\n          return decl_ctx_die;\n      }\n\n      DWARFDIE abs_die = die.GetReferencedDIE(DW_AT_abstract_origin);\n      if (abs_die) {\n        DWARFDIE decl_ctx_die = GetDeclContextDIEContainingDIE(abs_die);\n        if (decl_ctx_die)\n          return decl_ctx_die;\n      }\n\n      die = die.GetParent();\n    }\n  }\n  return DWARFDIE();\n}\n\nSymbol *SymbolFileDWARF::GetObjCClassSymbol(ConstString objc_class_name) {\n  Symbol *objc_class_symbol = nullptr;\n  if (m_objfile_sp) {\n    Symtab *symtab = m_objfile_sp->GetSymtab();\n    if (symtab) {\n      objc_class_symbol = symtab->FindFirstSymbolWithNameAndType(\n          objc_class_name, eSymbolTypeObjCClass, Symtab::eDebugNo,\n          Symtab::eVisibilityAny);\n    }\n  }\n  return objc_class_symbol;\n}\n\n// Some compilers don't emit the DW_AT_APPLE_objc_complete_type attribute. If\n// they don't then we can end up looking through all class types for a complete\n// type and never find the full definition. We need to know if this attribute\n// is supported, so we determine this here and cache th result. We also need to\n// worry about the debug map\n// DWARF file\n// if we are doing darwin DWARF in .o file debugging.\nbool SymbolFileDWARF::Supports_DW_AT_APPLE_objc_complete_type(DWARFUnit *cu) {\n  if (m_supports_DW_AT_APPLE_objc_complete_type == eLazyBoolCalculate) {\n    m_supports_DW_AT_APPLE_objc_complete_type = eLazyBoolNo;\n    if (cu && cu->Supports_DW_AT_APPLE_objc_complete_type())\n      m_supports_DW_AT_APPLE_objc_complete_type = eLazyBoolYes;\n    else {\n      DWARFDebugInfo &debug_info = DebugInfo();\n      const uint32_t num_compile_units = GetNumCompileUnits();\n      for (uint32_t cu_idx = 0; cu_idx < num_compile_units; ++cu_idx) {\n        DWARFUnit *dwarf_cu = debug_info.GetUnitAtIndex(cu_idx);\n        if (dwarf_cu != cu &&\n            dwarf_cu->Supports_DW_AT_APPLE_objc_complete_type()) {\n          m_supports_DW_AT_APPLE_objc_complete_type = eLazyBoolYes;\n          break;\n        }\n      }\n    }\n    if (m_supports_DW_AT_APPLE_objc_complete_type == eLazyBoolNo &&\n        GetDebugMapSymfile())\n      return m_debug_map_symfile->Supports_DW_AT_APPLE_objc_complete_type(this);\n  }\n  return m_supports_DW_AT_APPLE_objc_complete_type == eLazyBoolYes;\n}\n\n// This function can be used when a DIE is found that is a forward declaration\n// DIE and we want to try and find a type that has the complete definition.\nTypeSP SymbolFileDWARF::FindCompleteObjCDefinitionTypeForDIE(\n    const DWARFDIE &die, ConstString type_name, bool must_be_implementation) {\n\n  TypeSP type_sp;\n\n  if (!type_name || (must_be_implementation && !GetObjCClassSymbol(type_name)))\n    return type_sp;\n\n  m_index->GetCompleteObjCClass(\n      type_name, must_be_implementation, [&](DWARFDIE type_die) {\n        bool try_resolving_type = false;\n\n        // Don't try and resolve the DIE we are looking for with the DIE\n        // itself!\n        if (type_die != die) {\n          switch (type_die.Tag()) {\n          case DW_TAG_class_type:\n          case DW_TAG_structure_type:\n            try_resolving_type = true;\n            break;\n          default:\n            break;\n          }\n        }\n        if (!try_resolving_type)\n          return true;\n\n        if (must_be_implementation &&\n            type_die.Supports_DW_AT_APPLE_objc_complete_type())\n          try_resolving_type = type_die.GetAttributeValueAsUnsigned(\n              DW_AT_APPLE_objc_complete_type, 0);\n        if (!try_resolving_type)\n          return true;\n\n        Type *resolved_type = ResolveType(type_die, false, true);\n        if (!resolved_type || resolved_type == DIE_IS_BEING_PARSED)\n          return true;\n\n        DEBUG_PRINTF(\n            \"resolved 0x%8.8\" PRIx64 \" from %s to 0x%8.8\" PRIx64\n            \" (cu 0x%8.8\" PRIx64 \")\\n\",\n            die.GetID(),\n            m_objfile_sp->GetFileSpec().GetFilename().AsCString(\"<Unknown>\"),\n            type_die.GetID(), type_cu->GetID());\n\n        if (die)\n          GetDIEToType()[die.GetDIE()] = resolved_type;\n        type_sp = resolved_type->shared_from_this();\n        return false;\n      });\n  return type_sp;\n}\n\n// This function helps to ensure that the declaration contexts match for two\n// different DIEs. Often times debug information will refer to a forward\n// declaration of a type (the equivalent of \"struct my_struct;\". There will\n// often be a declaration of that type elsewhere that has the full definition.\n// When we go looking for the full type \"my_struct\", we will find one or more\n// matches in the accelerator tables and we will then need to make sure the\n// type was in the same declaration context as the original DIE. This function\n// can efficiently compare two DIEs and will return true when the declaration\n// context matches, and false when they don't.\nbool SymbolFileDWARF::DIEDeclContextsMatch(const DWARFDIE &die1,\n                                           const DWARFDIE &die2) {\n  if (die1 == die2)\n    return true;\n\n  std::vector<DWARFDIE> decl_ctx_1;\n  std::vector<DWARFDIE> decl_ctx_2;\n  // The declaration DIE stack is a stack of the declaration context DIEs all\n  // the way back to the compile unit. If a type \"T\" is declared inside a class\n  // \"B\", and class \"B\" is declared inside a class \"A\" and class \"A\" is in a\n  // namespace \"lldb\", and the namespace is in a compile unit, there will be a\n  // stack of DIEs:\n  //\n  //   [0] DW_TAG_class_type for \"B\"\n  //   [1] DW_TAG_class_type for \"A\"\n  //   [2] DW_TAG_namespace  for \"lldb\"\n  //   [3] DW_TAG_compile_unit or DW_TAG_partial_unit for the source file.\n  //\n  // We grab both contexts and make sure that everything matches all the way\n  // back to the compiler unit.\n\n  // First lets grab the decl contexts for both DIEs\n  decl_ctx_1 = die1.GetDeclContextDIEs();\n  decl_ctx_2 = die2.GetDeclContextDIEs();\n  // Make sure the context arrays have the same size, otherwise we are done\n  const size_t count1 = decl_ctx_1.size();\n  const size_t count2 = decl_ctx_2.size();\n  if (count1 != count2)\n    return false;\n\n  // Make sure the DW_TAG values match all the way back up the compile unit. If\n  // they don't, then we are done.\n  DWARFDIE decl_ctx_die1;\n  DWARFDIE decl_ctx_die2;\n  size_t i;\n  for (i = 0; i < count1; i++) {\n    decl_ctx_die1 = decl_ctx_1[i];\n    decl_ctx_die2 = decl_ctx_2[i];\n    if (decl_ctx_die1.Tag() != decl_ctx_die2.Tag())\n      return false;\n  }\n#ifndef NDEBUG\n\n  // Make sure the top item in the decl context die array is always\n  // DW_TAG_compile_unit or DW_TAG_partial_unit. If it isn't then\n  // something went wrong in the DWARFDIE::GetDeclContextDIEs()\n  // function.\n  dw_tag_t cu_tag = decl_ctx_1[count1 - 1].Tag();\n  UNUSED_IF_ASSERT_DISABLED(cu_tag);\n  assert(cu_tag == DW_TAG_compile_unit || cu_tag == DW_TAG_partial_unit);\n\n#endif\n  // Always skip the compile unit when comparing by only iterating up to \"count\n  // - 1\". Here we compare the names as we go.\n  for (i = 0; i < count1 - 1; i++) {\n    decl_ctx_die1 = decl_ctx_1[i];\n    decl_ctx_die2 = decl_ctx_2[i];\n    const char *name1 = decl_ctx_die1.GetName();\n    const char *name2 = decl_ctx_die2.GetName();\n    // If the string was from a DW_FORM_strp, then the pointer will often be\n    // the same!\n    if (name1 == name2)\n      continue;\n\n    // Name pointers are not equal, so only compare the strings if both are not\n    // NULL.\n    if (name1 && name2) {\n      // If the strings don't compare, we are done...\n      if (strcmp(name1, name2) != 0)\n        return false;\n    } else {\n      // One name was NULL while the other wasn't\n      return false;\n    }\n  }\n  // We made it through all of the checks and the declaration contexts are\n  // equal.\n  return true;\n}\n\nTypeSP SymbolFileDWARF::FindDefinitionTypeForDWARFDeclContext(\n    const DWARFDeclContext &dwarf_decl_ctx) {\n  TypeSP type_sp;\n\n  const uint32_t dwarf_decl_ctx_count = dwarf_decl_ctx.GetSize();\n  if (dwarf_decl_ctx_count > 0) {\n    const ConstString type_name(dwarf_decl_ctx[0].name);\n    const dw_tag_t tag = dwarf_decl_ctx[0].tag;\n\n    if (type_name) {\n      Log *log(LogChannelDWARF::GetLogIfAny(DWARF_LOG_TYPE_COMPLETION |\n                                            DWARF_LOG_LOOKUPS));\n      if (log) {\n        GetObjectFile()->GetModule()->LogMessage(\n            log,\n            \"SymbolFileDWARF::FindDefinitionTypeForDWARFDeclContext(tag=%\"\n            \"s, qualified-name='%s')\",\n            DW_TAG_value_to_name(dwarf_decl_ctx[0].tag),\n            dwarf_decl_ctx.GetQualifiedName());\n      }\n\n      // Get the type system that we are looking to find a type for. We will\n      // use this to ensure any matches we find are in a language that this\n      // type system supports\n      const LanguageType language = dwarf_decl_ctx.GetLanguage();\n      TypeSystem *type_system = nullptr;\n      if (language != eLanguageTypeUnknown) {\n        auto type_system_or_err = GetTypeSystemForLanguage(language);\n        if (auto err = type_system_or_err.takeError()) {\n          LLDB_LOG_ERROR(\n              lldb_private::GetLogIfAnyCategoriesSet(LIBLLDB_LOG_SYMBOLS),\n              std::move(err), \"Cannot get TypeSystem for language {}\",\n              Language::GetNameForLanguageType(language));\n        } else {\n          type_system = &type_system_or_err.get();\n        }\n      }\n\n      m_index->GetTypes(dwarf_decl_ctx, [&](DWARFDIE type_die) {\n        // Make sure type_die's langauge matches the type system we are\n        // looking for. We don't want to find a \"Foo\" type from Java if we\n        // are looking for a \"Foo\" type for C, C++, ObjC, or ObjC++.\n        if (type_system &&\n            !type_system->SupportsLanguage(GetLanguage(*type_die.GetCU())))\n          return true;\n        bool try_resolving_type = false;\n\n        // Don't try and resolve the DIE we are looking for with the DIE\n        // itself!\n        const dw_tag_t type_tag = type_die.Tag();\n        // Make sure the tags match\n        if (type_tag == tag) {\n          // The tags match, lets try resolving this type\n          try_resolving_type = true;\n        } else {\n          // The tags don't match, but we need to watch our for a forward\n          // declaration for a struct and (\"struct foo\") ends up being a\n          // class (\"class foo { ... };\") or vice versa.\n          switch (type_tag) {\n          case DW_TAG_class_type:\n            // We had a \"class foo\", see if we ended up with a \"struct foo\n            // { ... };\"\n            try_resolving_type = (tag == DW_TAG_structure_type);\n            break;\n          case DW_TAG_structure_type:\n            // We had a \"struct foo\", see if we ended up with a \"class foo\n            // { ... };\"\n            try_resolving_type = (tag == DW_TAG_class_type);\n            break;\n          default:\n            // Tags don't match, don't event try to resolve using this type\n            // whose name matches....\n            break;\n          }\n        }\n\n        if (!try_resolving_type) {\n          if (log) {\n            std::string qualified_name;\n            type_die.GetQualifiedName(qualified_name);\n            GetObjectFile()->GetModule()->LogMessage(\n                log,\n                \"SymbolFileDWARF::\"\n                \"FindDefinitionTypeForDWARFDeclContext(tag=%s, \"\n                \"qualified-name='%s') ignoring die=0x%8.8x (%s)\",\n                DW_TAG_value_to_name(dwarf_decl_ctx[0].tag),\n                dwarf_decl_ctx.GetQualifiedName(), type_die.GetOffset(),\n                qualified_name.c_str());\n          }\n          return true;\n        }\n\n        DWARFDeclContext type_dwarf_decl_ctx = GetDWARFDeclContext(type_die);\n\n        if (log) {\n          GetObjectFile()->GetModule()->LogMessage(\n              log,\n              \"SymbolFileDWARF::\"\n              \"FindDefinitionTypeForDWARFDeclContext(tag=%s, \"\n              \"qualified-name='%s') trying die=0x%8.8x (%s)\",\n              DW_TAG_value_to_name(dwarf_decl_ctx[0].tag),\n              dwarf_decl_ctx.GetQualifiedName(), type_die.GetOffset(),\n              type_dwarf_decl_ctx.GetQualifiedName());\n        }\n\n        // Make sure the decl contexts match all the way up\n        if (dwarf_decl_ctx != type_dwarf_decl_ctx)\n          return true;\n\n        Type *resolved_type = ResolveType(type_die, false);\n        if (!resolved_type || resolved_type == DIE_IS_BEING_PARSED)\n          return true;\n\n        type_sp = resolved_type->shared_from_this();\n        return false;\n      });\n    }\n  }\n  return type_sp;\n}\n\nTypeSP SymbolFileDWARF::ParseType(const SymbolContext &sc, const DWARFDIE &die,\n                                  bool *type_is_new_ptr) {\n  if (!die)\n    return {};\n\n  auto type_system_or_err = GetTypeSystemForLanguage(GetLanguage(*die.GetCU()));\n  if (auto err = type_system_or_err.takeError()) {\n    LLDB_LOG_ERROR(lldb_private::GetLogIfAnyCategoriesSet(LIBLLDB_LOG_SYMBOLS),\n                   std::move(err), \"Unable to parse type\");\n    return {};\n  }\n\n  DWARFASTParser *dwarf_ast = type_system_or_err->GetDWARFParser();\n  if (!dwarf_ast)\n    return {};\n\n  TypeSP type_sp = dwarf_ast->ParseTypeFromDWARF(sc, die, type_is_new_ptr);\n  if (type_sp) {\n    GetTypeList().Insert(type_sp);\n\n    if (die.Tag() == DW_TAG_subprogram) {\n      std::string scope_qualified_name(GetDeclContextForUID(die.GetID())\n                                           .GetScopeQualifiedName()\n                                           .AsCString(\"\"));\n      if (scope_qualified_name.size()) {\n        m_function_scope_qualified_name_map[scope_qualified_name].insert(\n            *die.GetDIERef());\n      }\n    }\n  }\n\n  return type_sp;\n}\n\nsize_t SymbolFileDWARF::ParseTypes(const SymbolContext &sc,\n                                   const DWARFDIE &orig_die,\n                                   bool parse_siblings, bool parse_children) {\n  size_t types_added = 0;\n  DWARFDIE die = orig_die;\n\n  while (die) {\n    const dw_tag_t tag = die.Tag();\n    bool type_is_new = false;\n\n    Tag dwarf_tag = static_cast<Tag>(tag);\n\n    // TODO: Currently ParseTypeFromDWARF(...) which is called by ParseType(...)\n    // does not handle DW_TAG_subrange_type. It is not clear if this is a bug or\n    // not.\n    if (isType(dwarf_tag) && tag != DW_TAG_subrange_type)\n      ParseType(sc, die, &type_is_new);\n\n    if (type_is_new)\n      ++types_added;\n\n    if (parse_children && die.HasChildren()) {\n      if (die.Tag() == DW_TAG_subprogram) {\n        SymbolContext child_sc(sc);\n        child_sc.function = sc.comp_unit->FindFunctionByUID(die.GetID()).get();\n        types_added += ParseTypes(child_sc, die.GetFirstChild(), true, true);\n      } else\n        types_added += ParseTypes(sc, die.GetFirstChild(), true, true);\n    }\n\n    if (parse_siblings)\n      die = die.GetSibling();\n    else\n      die.Clear();\n  }\n  return types_added;\n}\n\nsize_t SymbolFileDWARF::ParseBlocksRecursive(Function &func) {\n  std::lock_guard<std::recursive_mutex> guard(GetModuleMutex());\n  CompileUnit *comp_unit = func.GetCompileUnit();\n  lldbassert(comp_unit);\n\n  DWARFUnit *dwarf_cu = GetDWARFCompileUnit(comp_unit);\n  if (!dwarf_cu)\n    return 0;\n\n  size_t functions_added = 0;\n  const dw_offset_t function_die_offset = func.GetID();\n  DWARFDIE function_die =\n      dwarf_cu->GetNonSkeletonUnit().GetDIE(function_die_offset);\n  if (function_die) {\n    ParseBlocksRecursive(*comp_unit, &func.GetBlock(false), function_die,\n                         LLDB_INVALID_ADDRESS, 0);\n  }\n\n  return functions_added;\n}\n\nsize_t SymbolFileDWARF::ParseTypes(CompileUnit &comp_unit) {\n  std::lock_guard<std::recursive_mutex> guard(GetModuleMutex());\n  size_t types_added = 0;\n  DWARFUnit *dwarf_cu = GetDWARFCompileUnit(&comp_unit);\n  if (dwarf_cu) {\n    DWARFDIE dwarf_cu_die = dwarf_cu->DIE();\n    if (dwarf_cu_die && dwarf_cu_die.HasChildren()) {\n      SymbolContext sc;\n      sc.comp_unit = &comp_unit;\n      types_added = ParseTypes(sc, dwarf_cu_die.GetFirstChild(), true, true);\n    }\n  }\n\n  return types_added;\n}\n\nsize_t SymbolFileDWARF::ParseVariablesForContext(const SymbolContext &sc) {\n  std::lock_guard<std::recursive_mutex> guard(GetModuleMutex());\n  if (sc.comp_unit != nullptr) {\n    if (sc.function) {\n      DWARFDIE function_die = GetDIE(sc.function->GetID());\n\n      dw_addr_t func_lo_pc = LLDB_INVALID_ADDRESS;\n      DWARFRangeList ranges;\n      if (function_die.GetDIE()->GetAttributeAddressRanges(\n              function_die.GetCU(), ranges,\n              /*check_hi_lo_pc=*/true))\n        func_lo_pc = ranges.GetMinRangeBase(0);\n      if (func_lo_pc != LLDB_INVALID_ADDRESS) {\n        const size_t num_variables = ParseVariables(\n            sc, function_die.GetFirstChild(), func_lo_pc, true, true);\n\n        // Let all blocks know they have parse all their variables\n        sc.function->GetBlock(false).SetDidParseVariables(true, true);\n        return num_variables;\n      }\n    } else if (sc.comp_unit) {\n      DWARFUnit *dwarf_cu = DebugInfo().GetUnitAtIndex(sc.comp_unit->GetID());\n\n      if (dwarf_cu == nullptr)\n        return 0;\n\n      uint32_t vars_added = 0;\n      VariableListSP variables(sc.comp_unit->GetVariableList(false));\n\n      if (variables.get() == nullptr) {\n        variables = std::make_shared<VariableList>();\n        sc.comp_unit->SetVariableList(variables);\n\n        m_index->GetGlobalVariables(\n            dwarf_cu->GetNonSkeletonUnit(), [&](DWARFDIE die) {\n              VariableSP var_sp(\n                  ParseVariableDIE(sc, die, LLDB_INVALID_ADDRESS));\n              if (var_sp) {\n                variables->AddVariableIfUnique(var_sp);\n                ++vars_added;\n              }\n              return true;\n            });\n      }\n      return vars_added;\n    }\n  }\n  return 0;\n}\n\nVariableSP SymbolFileDWARF::ParseVariableDIE(const SymbolContext &sc,\n                                             const DWARFDIE &die,\n                                             const lldb::addr_t func_low_pc) {\n  if (die.GetDWARF() != this)\n    return die.GetDWARF()->ParseVariableDIE(sc, die, func_low_pc);\n\n  if (!die)\n    return nullptr;\n\n  if (VariableSP var_sp = GetDIEToVariable()[die.GetDIE()])\n    return var_sp; // Already been parsed!\n\n  const dw_tag_t tag = die.Tag();\n  ModuleSP module = GetObjectFile()->GetModule();\n\n  if (tag != DW_TAG_variable && tag != DW_TAG_constant &&\n      (tag != DW_TAG_formal_parameter || !sc.function))\n    return nullptr;\n\n  DWARFAttributes attributes;\n  const size_t num_attributes = die.GetAttributes(attributes);\n  DWARFDIE spec_die;\n  VariableSP var_sp;\n  const char *name = nullptr;\n  const char *mangled = nullptr;\n  Declaration decl;\n  DWARFFormValue type_die_form;\n  DWARFExpression location;\n  bool is_external = false;\n  bool is_artificial = false;\n  DWARFFormValue const_value_form, location_form;\n  Variable::RangeList scope_ranges;\n\n  for (size_t i = 0; i < num_attributes; ++i) {\n    dw_attr_t attr = attributes.AttributeAtIndex(i);\n    DWARFFormValue form_value;\n\n    if (!attributes.ExtractFormValueAtIndex(i, form_value))\n      continue;\n    switch (attr) {\n    case DW_AT_decl_file:\n      decl.SetFile(\n          attributes.CompileUnitAtIndex(i)->GetFile(form_value.Unsigned()));\n      break;\n    case DW_AT_decl_line:\n      decl.SetLine(form_value.Unsigned());\n      break;\n    case DW_AT_decl_column:\n      decl.SetColumn(form_value.Unsigned());\n      break;\n    case DW_AT_name:\n      name = form_value.AsCString();\n      break;\n    case DW_AT_linkage_name:\n    case DW_AT_MIPS_linkage_name:\n      mangled = form_value.AsCString();\n      break;\n    case DW_AT_type:\n      type_die_form = form_value;\n      break;\n    case DW_AT_external:\n      is_external = form_value.Boolean();\n      break;\n    case DW_AT_const_value:\n      const_value_form = form_value;\n      break;\n    case DW_AT_location:\n      location_form = form_value;\n      break;\n    case DW_AT_specification:\n      spec_die = form_value.Reference();\n      break;\n    case DW_AT_start_scope:\n      // TODO: Implement this.\n      break;\n    case DW_AT_artificial:\n      is_artificial = form_value.Boolean();\n      break;\n    case DW_AT_declaration:\n    case DW_AT_description:\n    case DW_AT_endianity:\n    case DW_AT_segment:\n    case DW_AT_visibility:\n    default:\n    case DW_AT_abstract_origin:\n    case DW_AT_sibling:\n      break;\n    }\n  }\n\n  // Prefer DW_AT_location over DW_AT_const_value. Both can be emitted e.g.\n  // for static constexpr member variables -- DW_AT_const_value will be\n  // present in the class declaration and DW_AT_location in the DIE defining\n  // the member.\n  bool location_is_const_value_data = false;\n  bool has_explicit_location = false;\n  bool use_type_size_for_value = false;\n  if (location_form.IsValid()) {\n    has_explicit_location = true;\n    if (DWARFFormValue::IsBlockForm(location_form.Form())) {\n      const DWARFDataExtractor &data = die.GetData();\n\n      uint32_t block_offset = location_form.BlockData() - data.GetDataStart();\n      uint32_t block_length = location_form.Unsigned();\n      location = DWARFExpression(\n          module, DataExtractor(data, block_offset, block_length), die.GetCU());\n    } else {\n      DataExtractor data = die.GetCU()->GetLocationData();\n      dw_offset_t offset = location_form.Unsigned();\n      if (location_form.Form() == DW_FORM_loclistx)\n        offset = die.GetCU()->GetLoclistOffset(offset).getValueOr(-1);\n      if (data.ValidOffset(offset)) {\n        data = DataExtractor(data, offset, data.GetByteSize() - offset);\n        location = DWARFExpression(module, data, die.GetCU());\n        assert(func_low_pc != LLDB_INVALID_ADDRESS);\n        location.SetLocationListAddresses(\n            location_form.GetUnit()->GetBaseAddress(), func_low_pc);\n      }\n    }\n  } else if (const_value_form.IsValid()) {\n    location_is_const_value_data = true;\n    // The constant value will be either a block, a data value or a\n    // string.\n    const DWARFDataExtractor &debug_info_data = die.GetData();\n    if (DWARFFormValue::IsBlockForm(const_value_form.Form())) {\n      // Retrieve the value as a block expression.\n      uint32_t block_offset =\n          const_value_form.BlockData() - debug_info_data.GetDataStart();\n      uint32_t block_length = const_value_form.Unsigned();\n      location = DWARFExpression(\n          module, DataExtractor(debug_info_data, block_offset, block_length),\n          die.GetCU());\n    } else if (DWARFFormValue::IsDataForm(const_value_form.Form())) {\n      // Constant value size does not have to match the size of the\n      // variable. We will fetch the size of the type after we create\n      // it.\n      use_type_size_for_value = true;\n    } else if (const char *str = const_value_form.AsCString()) {\n      uint32_t string_length = strlen(str) + 1;\n      location = DWARFExpression(\n          module,\n          DataExtractor(str, string_length, die.GetCU()->GetByteOrder(),\n                        die.GetCU()->GetAddressByteSize()),\n          die.GetCU());\n    }\n  }\n\n  const DWARFDIE parent_context_die = GetDeclContextDIEContainingDIE(die);\n  const dw_tag_t parent_tag = die.GetParent().Tag();\n  bool is_static_member = (parent_tag == DW_TAG_compile_unit ||\n                           parent_tag == DW_TAG_partial_unit) &&\n                          (parent_context_die.Tag() == DW_TAG_class_type ||\n                           parent_context_die.Tag() == DW_TAG_structure_type);\n\n  ValueType scope = eValueTypeInvalid;\n\n  const DWARFDIE sc_parent_die = GetParentSymbolContextDIE(die);\n  SymbolContextScope *symbol_context_scope = nullptr;\n\n  bool has_explicit_mangled = mangled != nullptr;\n  if (!mangled) {\n    // LLDB relies on the mangled name (DW_TAG_linkage_name or\n    // DW_AT_MIPS_linkage_name) to generate fully qualified names\n    // of global variables with commands like \"frame var j\". For\n    // example, if j were an int variable holding a value 4 and\n    // declared in a namespace B which in turn is contained in a\n    // namespace A, the command \"frame var j\" returns\n    //   \"(int) A::B::j = 4\".\n    // If the compiler does not emit a linkage name, we should be\n    // able to generate a fully qualified name from the\n    // declaration context.\n    if ((parent_tag == DW_TAG_compile_unit ||\n         parent_tag == DW_TAG_partial_unit) &&\n        Language::LanguageIsCPlusPlus(GetLanguage(*die.GetCU())))\n      mangled =\n          GetDWARFDeclContext(die).GetQualifiedNameAsConstString().GetCString();\n  }\n\n  if (tag == DW_TAG_formal_parameter)\n    scope = eValueTypeVariableArgument;\n  else {\n    // DWARF doesn't specify if a DW_TAG_variable is a local, global\n    // or static variable, so we have to do a little digging:\n    // 1) DW_AT_linkage_name implies static lifetime (but may be missing)\n    // 2) An empty DW_AT_location is an (optimized-out) static lifetime var.\n    // 3) DW_AT_location containing a DW_OP_addr implies static lifetime.\n    // Clang likes to combine small global variables into the same symbol\n    // with locations like: DW_OP_addr(0x1000), DW_OP_constu(2), DW_OP_plus\n    // so we need to look through the whole expression.\n    bool is_static_lifetime =\n        has_explicit_mangled || (has_explicit_location && !location.IsValid());\n    // Check if the location has a DW_OP_addr with any address value...\n    lldb::addr_t location_DW_OP_addr = LLDB_INVALID_ADDRESS;\n    if (!location_is_const_value_data) {\n      bool op_error = false;\n      location_DW_OP_addr = location.GetLocation_DW_OP_addr(0, op_error);\n      if (op_error) {\n        StreamString strm;\n        location.DumpLocationForAddress(&strm, eDescriptionLevelFull, 0, 0,\n                                        nullptr);\n        GetObjectFile()->GetModule()->ReportError(\n            \"0x%8.8x: %s has an invalid location: %s\", die.GetOffset(),\n            die.GetTagAsCString(), strm.GetData());\n      }\n      if (location_DW_OP_addr != LLDB_INVALID_ADDRESS)\n        is_static_lifetime = true;\n    }\n    SymbolFileDWARFDebugMap *debug_map_symfile = GetDebugMapSymfile();\n    if (debug_map_symfile)\n      // Set the module of the expression to the linked module\n      // instead of the oject file so the relocated address can be\n      // found there.\n      location.SetModule(debug_map_symfile->GetObjectFile()->GetModule());\n\n    if (is_static_lifetime) {\n      if (is_external)\n        scope = eValueTypeVariableGlobal;\n      else\n        scope = eValueTypeVariableStatic;\n\n      if (debug_map_symfile) {\n        // When leaving the DWARF in the .o files on darwin, when we have a\n        // global variable that wasn't initialized, the .o file might not\n        // have allocated a virtual address for the global variable. In\n        // this case it will have created a symbol for the global variable\n        // that is undefined/data and external and the value will be the\n        // byte size of the variable. When we do the address map in\n        // SymbolFileDWARFDebugMap we rely on having an address, we need to\n        // do some magic here so we can get the correct address for our\n        // global variable. The address for all of these entries will be\n        // zero, and there will be an undefined symbol in this object file,\n        // and the executable will have a matching symbol with a good\n        // address. So here we dig up the correct address and replace it in\n        // the location for the variable, and set the variable's symbol\n        // context scope to be that of the main executable so the file\n        // address will resolve correctly.\n        bool linked_oso_file_addr = false;\n        if (is_external && location_DW_OP_addr == 0) {\n          // we have a possible uninitialized extern global\n          ConstString const_name(mangled ? mangled : name);\n          ObjectFile *debug_map_objfile = debug_map_symfile->GetObjectFile();\n          if (debug_map_objfile) {\n            Symtab *debug_map_symtab = debug_map_objfile->GetSymtab();\n            if (debug_map_symtab) {\n              Symbol *exe_symbol =\n                  debug_map_symtab->FindFirstSymbolWithNameAndType(\n                      const_name, eSymbolTypeData, Symtab::eDebugYes,\n                      Symtab::eVisibilityExtern);\n              if (exe_symbol) {\n                if (exe_symbol->ValueIsAddress()) {\n                  const addr_t exe_file_addr =\n                      exe_symbol->GetAddressRef().GetFileAddress();\n                  if (exe_file_addr != LLDB_INVALID_ADDRESS) {\n                    if (location.Update_DW_OP_addr(exe_file_addr)) {\n                      linked_oso_file_addr = true;\n                      symbol_context_scope = exe_symbol;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (!linked_oso_file_addr) {\n          // The DW_OP_addr is not zero, but it contains a .o file address\n          // which needs to be linked up correctly.\n          const lldb::addr_t exe_file_addr =\n              debug_map_symfile->LinkOSOFileAddress(this, location_DW_OP_addr);\n          if (exe_file_addr != LLDB_INVALID_ADDRESS) {\n            // Update the file address for this variable\n            location.Update_DW_OP_addr(exe_file_addr);\n          } else {\n            // Variable didn't make it into the final executable\n            return var_sp;\n          }\n        }\n      }\n    } else {\n      if (location_is_const_value_data &&\n          die.GetDIE()->IsGlobalOrStaticScopeVariable())\n        scope = eValueTypeVariableStatic;\n      else {\n        scope = eValueTypeVariableLocal;\n        if (debug_map_symfile) {\n          // We need to check for TLS addresses that we need to fixup\n          if (location.ContainsThreadLocalStorage()) {\n            location.LinkThreadLocalStorage(\n                debug_map_symfile->GetObjectFile()->GetModule(),\n                [this, debug_map_symfile](\n                    lldb::addr_t unlinked_file_addr) -> lldb::addr_t {\n                  return debug_map_symfile->LinkOSOFileAddress(\n                      this, unlinked_file_addr);\n                });\n            scope = eValueTypeVariableThreadLocal;\n          }\n        }\n      }\n    }\n  }\n\n  if (symbol_context_scope == nullptr) {\n    switch (parent_tag) {\n    case DW_TAG_subprogram:\n    case DW_TAG_inlined_subroutine:\n    case DW_TAG_lexical_block:\n      if (sc.function) {\n        symbol_context_scope =\n            sc.function->GetBlock(true).FindBlockByID(sc_parent_die.GetID());\n        if (symbol_context_scope == nullptr)\n          symbol_context_scope = sc.function;\n      }\n      break;\n\n    default:\n      symbol_context_scope = sc.comp_unit;\n      break;\n    }\n  }\n\n  if (symbol_context_scope) {\n    auto type_sp = std::make_shared<SymbolFileType>(\n        *this, GetUID(type_die_form.Reference()));\n\n    if (use_type_size_for_value && type_sp->GetType())\n      location.UpdateValue(\n          const_value_form.Unsigned(),\n          type_sp->GetType()->GetByteSize(nullptr).getValueOr(0),\n          die.GetCU()->GetAddressByteSize());\n\n    var_sp = std::make_shared<Variable>(\n        die.GetID(), name, mangled, type_sp, scope, symbol_context_scope,\n        scope_ranges, &decl, location, is_external, is_artificial,\n        location_is_const_value_data, is_static_member);\n  } else {\n    // Not ready to parse this variable yet. It might be a global or static\n    // variable that is in a function scope and the function in the symbol\n    // context wasn't filled in yet\n    return var_sp;\n  }\n  // Cache var_sp even if NULL (the variable was just a specification or was\n  // missing vital information to be able to be displayed in the debugger\n  // (missing location due to optimization, etc)) so we don't re-parse this\n  // DIE over and over later...\n  GetDIEToVariable()[die.GetDIE()] = var_sp;\n  if (spec_die)\n    GetDIEToVariable()[spec_die.GetDIE()] = var_sp;\n\n  return var_sp;\n}\n\nDWARFDIE\nSymbolFileDWARF::FindBlockContainingSpecification(\n    const DIERef &func_die_ref, dw_offset_t spec_block_die_offset) {\n  // Give the concrete function die specified by \"func_die_offset\", find the\n  // concrete block whose DW_AT_specification or DW_AT_abstract_origin points\n  // to \"spec_block_die_offset\"\n  return FindBlockContainingSpecification(DebugInfo().GetDIE(func_die_ref),\n                                          spec_block_die_offset);\n}\n\nDWARFDIE\nSymbolFileDWARF::FindBlockContainingSpecification(\n    const DWARFDIE &die, dw_offset_t spec_block_die_offset) {\n  if (die) {\n    switch (die.Tag()) {\n    case DW_TAG_subprogram:\n    case DW_TAG_inlined_subroutine:\n    case DW_TAG_lexical_block: {\n      if (die.GetReferencedDIE(DW_AT_specification).GetOffset() ==\n          spec_block_die_offset)\n        return die;\n\n      if (die.GetReferencedDIE(DW_AT_abstract_origin).GetOffset() ==\n          spec_block_die_offset)\n        return die;\n    } break;\n    default:\n      break;\n    }\n\n    // Give the concrete function die specified by \"func_die_offset\", find the\n    // concrete block whose DW_AT_specification or DW_AT_abstract_origin points\n    // to \"spec_block_die_offset\"\n    for (DWARFDIE child_die = die.GetFirstChild(); child_die;\n         child_die = child_die.GetSibling()) {\n      DWARFDIE result_die =\n          FindBlockContainingSpecification(child_die, spec_block_die_offset);\n      if (result_die)\n        return result_die;\n    }\n  }\n\n  return DWARFDIE();\n}\n\nsize_t SymbolFileDWARF::ParseVariables(const SymbolContext &sc,\n                                       const DWARFDIE &orig_die,\n                                       const lldb::addr_t func_low_pc,\n                                       bool parse_siblings, bool parse_children,\n                                       VariableList *cc_variable_list) {\n  if (!orig_die)\n    return 0;\n\n  VariableListSP variable_list_sp;\n\n  size_t vars_added = 0;\n  DWARFDIE die = orig_die;\n  while (die) {\n    dw_tag_t tag = die.Tag();\n\n    // Check to see if we have already parsed this variable or constant?\n    VariableSP var_sp = GetDIEToVariable()[die.GetDIE()];\n    if (var_sp) {\n      if (cc_variable_list)\n        cc_variable_list->AddVariableIfUnique(var_sp);\n    } else {\n      // We haven't already parsed it, lets do that now.\n      if ((tag == DW_TAG_variable) || (tag == DW_TAG_constant) ||\n          (tag == DW_TAG_formal_parameter && sc.function)) {\n        if (variable_list_sp.get() == nullptr) {\n          DWARFDIE sc_parent_die = GetParentSymbolContextDIE(orig_die);\n          dw_tag_t parent_tag = sc_parent_die.Tag();\n          switch (parent_tag) {\n          case DW_TAG_compile_unit:\n          case DW_TAG_partial_unit:\n            if (sc.comp_unit != nullptr) {\n              variable_list_sp = sc.comp_unit->GetVariableList(false);\n              if (variable_list_sp.get() == nullptr) {\n                variable_list_sp = std::make_shared<VariableList>();\n              }\n            } else {\n              GetObjectFile()->GetModule()->ReportError(\n                  \"parent 0x%8.8\" PRIx64 \" %s with no valid compile unit in \"\n                  \"symbol context for 0x%8.8\" PRIx64 \" %s.\\n\",\n                  sc_parent_die.GetID(), sc_parent_die.GetTagAsCString(),\n                  orig_die.GetID(), orig_die.GetTagAsCString());\n            }\n            break;\n\n          case DW_TAG_subprogram:\n          case DW_TAG_inlined_subroutine:\n          case DW_TAG_lexical_block:\n            if (sc.function != nullptr) {\n              // Check to see if we already have parsed the variables for the\n              // given scope\n\n              Block *block = sc.function->GetBlock(true).FindBlockByID(\n                  sc_parent_die.GetID());\n              if (block == nullptr) {\n                // This must be a specification or abstract origin with a\n                // concrete block counterpart in the current function. We need\n                // to find the concrete block so we can correctly add the\n                // variable to it\n                const DWARFDIE concrete_block_die =\n                    FindBlockContainingSpecification(\n                        GetDIE(sc.function->GetID()),\n                        sc_parent_die.GetOffset());\n                if (concrete_block_die)\n                  block = sc.function->GetBlock(true).FindBlockByID(\n                      concrete_block_die.GetID());\n              }\n\n              if (block != nullptr) {\n                const bool can_create = false;\n                variable_list_sp = block->GetBlockVariableList(can_create);\n                if (variable_list_sp.get() == nullptr) {\n                  variable_list_sp = std::make_shared<VariableList>();\n                  block->SetVariableList(variable_list_sp);\n                }\n              }\n            }\n            break;\n\n          default:\n            GetObjectFile()->GetModule()->ReportError(\n                \"didn't find appropriate parent DIE for variable list for \"\n                \"0x%8.8\" PRIx64 \" %s.\\n\",\n                orig_die.GetID(), orig_die.GetTagAsCString());\n            break;\n          }\n        }\n\n        if (variable_list_sp) {\n          VariableSP var_sp(ParseVariableDIE(sc, die, func_low_pc));\n          if (var_sp) {\n            variable_list_sp->AddVariableIfUnique(var_sp);\n            if (cc_variable_list)\n              cc_variable_list->AddVariableIfUnique(var_sp);\n            ++vars_added;\n          }\n        }\n      }\n    }\n\n    bool skip_children = (sc.function == nullptr && tag == DW_TAG_subprogram);\n\n    if (!skip_children && parse_children && die.HasChildren()) {\n      vars_added += ParseVariables(sc, die.GetFirstChild(), func_low_pc, true,\n                                   true, cc_variable_list);\n    }\n\n    if (parse_siblings)\n      die = die.GetSibling();\n    else\n      die.Clear();\n  }\n  return vars_added;\n}\n\n/// Collect call site parameters in a DW_TAG_call_site DIE.\nstatic CallSiteParameterArray\nCollectCallSiteParameters(ModuleSP module, DWARFDIE call_site_die) {\n  CallSiteParameterArray parameters;\n  for (DWARFDIE child = call_site_die.GetFirstChild(); child.IsValid();\n       child = child.GetSibling()) {\n    if (child.Tag() != DW_TAG_call_site_parameter &&\n        child.Tag() != DW_TAG_GNU_call_site_parameter)\n      continue;\n\n    llvm::Optional<DWARFExpression> LocationInCallee;\n    llvm::Optional<DWARFExpression> LocationInCaller;\n\n    DWARFAttributes attributes;\n    const size_t num_attributes = child.GetAttributes(attributes);\n\n    // Parse the location at index \\p attr_index within this call site parameter\n    // DIE, or return None on failure.\n    auto parse_simple_location =\n        [&](int attr_index) -> llvm::Optional<DWARFExpression> {\n      DWARFFormValue form_value;\n      if (!attributes.ExtractFormValueAtIndex(attr_index, form_value))\n        return {};\n      if (!DWARFFormValue::IsBlockForm(form_value.Form()))\n        return {};\n      auto data = child.GetData();\n      uint32_t block_offset = form_value.BlockData() - data.GetDataStart();\n      uint32_t block_length = form_value.Unsigned();\n      return DWARFExpression(module,\n                             DataExtractor(data, block_offset, block_length),\n                             child.GetCU());\n    };\n\n    for (size_t i = 0; i < num_attributes; ++i) {\n      dw_attr_t attr = attributes.AttributeAtIndex(i);\n      if (attr == DW_AT_location)\n        LocationInCallee = parse_simple_location(i);\n      if (attr == DW_AT_call_value || attr == DW_AT_GNU_call_site_value)\n        LocationInCaller = parse_simple_location(i);\n    }\n\n    if (LocationInCallee && LocationInCaller) {\n      CallSiteParameter param = {*LocationInCallee, *LocationInCaller};\n      parameters.push_back(param);\n    }\n  }\n  return parameters;\n}\n\n/// Collect call graph edges present in a function DIE.\nstd::vector<std::unique_ptr<lldb_private::CallEdge>>\nSymbolFileDWARF::CollectCallEdges(ModuleSP module, DWARFDIE function_die) {\n  // Check if the function has a supported call site-related attribute.\n  // TODO: In the future it may be worthwhile to support call_all_source_calls.\n  bool has_call_edges =\n      function_die.GetAttributeValueAsUnsigned(DW_AT_call_all_calls, 0) ||\n      function_die.GetAttributeValueAsUnsigned(DW_AT_GNU_all_call_sites, 0);\n  if (!has_call_edges)\n    return {};\n\n  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_STEP));\n  LLDB_LOG(log, \"CollectCallEdges: Found call site info in {0}\",\n           function_die.GetPubname());\n\n  // Scan the DIE for TAG_call_site entries.\n  // TODO: A recursive scan of all blocks in the subprogram is needed in order\n  // to be DWARF5-compliant. This may need to be done lazily to be performant.\n  // For now, assume that all entries are nested directly under the subprogram\n  // (this is the kind of DWARF LLVM produces) and parse them eagerly.\n  std::vector<std::unique_ptr<CallEdge>> call_edges;\n  for (DWARFDIE child = function_die.GetFirstChild(); child.IsValid();\n       child = child.GetSibling()) {\n    if (child.Tag() != DW_TAG_call_site && child.Tag() != DW_TAG_GNU_call_site)\n      continue;\n\n    llvm::Optional<DWARFDIE> call_origin;\n    llvm::Optional<DWARFExpression> call_target;\n    addr_t return_pc = LLDB_INVALID_ADDRESS;\n    addr_t call_inst_pc = LLDB_INVALID_ADDRESS;\n    addr_t low_pc = LLDB_INVALID_ADDRESS;\n    bool tail_call = false;\n\n    // Second DW_AT_low_pc may come from DW_TAG_subprogram referenced by\n    // DW_TAG_GNU_call_site's DW_AT_abstract_origin overwriting our 'low_pc'.\n    // So do not inherit attributes from DW_AT_abstract_origin.\n    DWARFAttributes attributes;\n    const size_t num_attributes =\n        child.GetAttributes(attributes, DWARFDIE::Recurse::no);\n    for (size_t i = 0; i < num_attributes; ++i) {\n      DWARFFormValue form_value;\n      if (!attributes.ExtractFormValueAtIndex(i, form_value)) {\n        LLDB_LOG(log, \"CollectCallEdges: Could not extract TAG_call_site form\");\n        break;\n      }\n\n      dw_attr_t attr = attributes.AttributeAtIndex(i);\n\n      if (attr == DW_AT_call_tail_call || attr == DW_AT_GNU_tail_call)\n        tail_call = form_value.Boolean();\n\n      // Extract DW_AT_call_origin (the call target's DIE).\n      if (attr == DW_AT_call_origin || attr == DW_AT_abstract_origin) {\n        call_origin = form_value.Reference();\n        if (!call_origin->IsValid()) {\n          LLDB_LOG(log, \"CollectCallEdges: Invalid call origin in {0}\",\n                   function_die.GetPubname());\n          break;\n        }\n      }\n\n      if (attr == DW_AT_low_pc)\n        low_pc = form_value.Address();\n\n      // Extract DW_AT_call_return_pc (the PC the call returns to) if it's\n      // available. It should only ever be unavailable for tail call edges, in\n      // which case use LLDB_INVALID_ADDRESS.\n      if (attr == DW_AT_call_return_pc)\n        return_pc = form_value.Address();\n\n      // Extract DW_AT_call_pc (the PC at the call/branch instruction). It\n      // should only ever be unavailable for non-tail calls, in which case use\n      // LLDB_INVALID_ADDRESS.\n      if (attr == DW_AT_call_pc)\n        call_inst_pc = form_value.Address();\n\n      // Extract DW_AT_call_target (the location of the address of the indirect\n      // call).\n      if (attr == DW_AT_call_target || attr == DW_AT_GNU_call_site_target) {\n        if (!DWARFFormValue::IsBlockForm(form_value.Form())) {\n          LLDB_LOG(log,\n                   \"CollectCallEdges: AT_call_target does not have block form\");\n          break;\n        }\n\n        auto data = child.GetData();\n        uint32_t block_offset = form_value.BlockData() - data.GetDataStart();\n        uint32_t block_length = form_value.Unsigned();\n        call_target = DWARFExpression(\n            module, DataExtractor(data, block_offset, block_length),\n            child.GetCU());\n      }\n    }\n    if (!call_origin && !call_target) {\n      LLDB_LOG(log, \"CollectCallEdges: call site without any call target\");\n      continue;\n    }\n\n    addr_t caller_address;\n    CallEdge::AddrType caller_address_type;\n    if (return_pc != LLDB_INVALID_ADDRESS) {\n      caller_address = return_pc;\n      caller_address_type = CallEdge::AddrType::AfterCall;\n    } else if (low_pc != LLDB_INVALID_ADDRESS) {\n      caller_address = low_pc;\n      caller_address_type = CallEdge::AddrType::AfterCall;\n    } else if (call_inst_pc != LLDB_INVALID_ADDRESS) {\n      caller_address = call_inst_pc;\n      caller_address_type = CallEdge::AddrType::Call;\n    } else {\n      LLDB_LOG(log, \"CollectCallEdges: No caller address\");\n      continue;\n    }\n    // Adjust any PC forms. It needs to be fixed up if the main executable\n    // contains a debug map (i.e. pointers to object files), because we need a\n    // file address relative to the executable's text section.\n    caller_address = FixupAddress(caller_address);\n\n    // Extract call site parameters.\n    CallSiteParameterArray parameters =\n        CollectCallSiteParameters(module, child);\n\n    std::unique_ptr<CallEdge> edge;\n    if (call_origin) {\n      LLDB_LOG(log,\n               \"CollectCallEdges: Found call origin: {0} (retn-PC: {1:x}) \"\n               \"(call-PC: {2:x})\",\n               call_origin->GetPubname(), return_pc, call_inst_pc);\n      edge = std::make_unique<DirectCallEdge>(\n          call_origin->GetMangledName(), caller_address_type, caller_address,\n          tail_call, std::move(parameters));\n    } else {\n      if (log) {\n        StreamString call_target_desc;\n        call_target->GetDescription(&call_target_desc, eDescriptionLevelBrief,\n                                    LLDB_INVALID_ADDRESS, nullptr);\n        LLDB_LOG(log, \"CollectCallEdges: Found indirect call target: {0}\",\n                 call_target_desc.GetString());\n      }\n      edge = std::make_unique<IndirectCallEdge>(\n          *call_target, caller_address_type, caller_address, tail_call,\n          std::move(parameters));\n    }\n\n    if (log && parameters.size()) {\n      for (const CallSiteParameter &param : parameters) {\n        StreamString callee_loc_desc, caller_loc_desc;\n        param.LocationInCallee.GetDescription(&callee_loc_desc,\n                                              eDescriptionLevelBrief,\n                                              LLDB_INVALID_ADDRESS, nullptr);\n        param.LocationInCaller.GetDescription(&caller_loc_desc,\n                                              eDescriptionLevelBrief,\n                                              LLDB_INVALID_ADDRESS, nullptr);\n        LLDB_LOG(log, \"CollectCallEdges: \\tparam: {0} => {1}\",\n                 callee_loc_desc.GetString(), caller_loc_desc.GetString());\n      }\n    }\n\n    call_edges.push_back(std::move(edge));\n  }\n  return call_edges;\n}\n\nstd::vector<std::unique_ptr<lldb_private::CallEdge>>\nSymbolFileDWARF::ParseCallEdgesInFunction(UserID func_id) {\n  // ParseCallEdgesInFunction must be called at the behest of an exclusively\n  // locked lldb::Function instance. Storage for parsed call edges is owned by\n  // the lldb::Function instance: locking at the SymbolFile level would be too\n  // late, because the act of storing results from ParseCallEdgesInFunction\n  // would be racy.\n  DWARFDIE func_die = GetDIE(func_id.GetID());\n  if (func_die.IsValid())\n    return CollectCallEdges(GetObjectFile()->GetModule(), func_die);\n  return {};\n}\n\n// PluginInterface protocol\nConstString SymbolFileDWARF::GetPluginName() { return GetPluginNameStatic(); }\n\nuint32_t SymbolFileDWARF::GetPluginVersion() { return 1; }\n\nvoid SymbolFileDWARF::Dump(lldb_private::Stream &s) {\n  SymbolFile::Dump(s);\n  m_index->Dump(s);\n}\n\nvoid SymbolFileDWARF::DumpClangAST(Stream &s) {\n  auto ts_or_err = GetTypeSystemForLanguage(eLanguageTypeC_plus_plus);\n  if (!ts_or_err)\n    return;\n  TypeSystemClang *clang =\n      llvm::dyn_cast_or_null<TypeSystemClang>(&ts_or_err.get());\n  if (!clang)\n    return;\n  clang->Dump(s);\n}\n\nSymbolFileDWARFDebugMap *SymbolFileDWARF::GetDebugMapSymfile() {\n  if (m_debug_map_symfile == nullptr && !m_debug_map_module_wp.expired()) {\n    lldb::ModuleSP module_sp(m_debug_map_module_wp.lock());\n    if (module_sp) {\n      m_debug_map_symfile =\n          static_cast<SymbolFileDWARFDebugMap *>(module_sp->GetSymbolFile());\n    }\n  }\n  return m_debug_map_symfile;\n}\n\nconst std::shared_ptr<SymbolFileDWARFDwo> &SymbolFileDWARF::GetDwpSymbolFile() {\n  llvm::call_once(m_dwp_symfile_once_flag, [this]() {\n    ModuleSpec module_spec;\n    module_spec.GetFileSpec() = m_objfile_sp->GetFileSpec();\n    module_spec.GetSymbolFileSpec() =\n        FileSpec(m_objfile_sp->GetModule()->GetFileSpec().GetPath() + \".dwp\");\n\n    FileSpecList search_paths = Target::GetDefaultDebugFileSearchPaths();\n    FileSpec dwp_filespec =\n        Symbols::LocateExecutableSymbolFile(module_spec, search_paths);\n    if (FileSystem::Instance().Exists(dwp_filespec)) {\n      DataBufferSP dwp_file_data_sp;\n      lldb::offset_t dwp_file_data_offset = 0;\n      ObjectFileSP dwp_obj_file = ObjectFile::FindPlugin(\n          GetObjectFile()->GetModule(), &dwp_filespec, 0,\n          FileSystem::Instance().GetByteSize(dwp_filespec), dwp_file_data_sp,\n          dwp_file_data_offset);\n      if (!dwp_obj_file)\n        return;\n      m_dwp_symfile =\n          std::make_shared<SymbolFileDWARFDwo>(*this, dwp_obj_file, 0x3fffffff);\n    }\n  });\n  return m_dwp_symfile;\n}\n\nllvm::Expected<TypeSystem &> SymbolFileDWARF::GetTypeSystem(DWARFUnit &unit) {\n  return unit.GetSymbolFileDWARF().GetTypeSystemForLanguage(GetLanguage(unit));\n}\n\nDWARFASTParser *SymbolFileDWARF::GetDWARFParser(DWARFUnit &unit) {\n  auto type_system_or_err = GetTypeSystem(unit);\n  if (auto err = type_system_or_err.takeError()) {\n    LLDB_LOG_ERROR(lldb_private::GetLogIfAnyCategoriesSet(LIBLLDB_LOG_SYMBOLS),\n                   std::move(err), \"Unable to get DWARFASTParser\");\n    return nullptr;\n  }\n  return type_system_or_err->GetDWARFParser();\n}\n\nCompilerDecl SymbolFileDWARF::GetDecl(const DWARFDIE &die) {\n  if (DWARFASTParser *dwarf_ast = GetDWARFParser(*die.GetCU()))\n    return dwarf_ast->GetDeclForUIDFromDWARF(die);\n  return CompilerDecl();\n}\n\nCompilerDeclContext SymbolFileDWARF::GetDeclContext(const DWARFDIE &die) {\n  if (DWARFASTParser *dwarf_ast = GetDWARFParser(*die.GetCU()))\n    return dwarf_ast->GetDeclContextForUIDFromDWARF(die);\n  return CompilerDeclContext();\n}\n\nCompilerDeclContext\nSymbolFileDWARF::GetContainingDeclContext(const DWARFDIE &die) {\n  if (DWARFASTParser *dwarf_ast = GetDWARFParser(*die.GetCU()))\n    return dwarf_ast->GetDeclContextContainingUIDFromDWARF(die);\n  return CompilerDeclContext();\n}\n\nDWARFDeclContext SymbolFileDWARF::GetDWARFDeclContext(const DWARFDIE &die) {\n  if (!die.IsValid())\n    return {};\n  DWARFDeclContext dwarf_decl_ctx =\n      die.GetDIE()->GetDWARFDeclContext(die.GetCU());\n  dwarf_decl_ctx.SetLanguage(GetLanguage(*die.GetCU()));\n  return dwarf_decl_ctx;\n}\n\nLanguageType SymbolFileDWARF::LanguageTypeFromDWARF(uint64_t val) {\n  // Note: user languages between lo_user and hi_user must be handled\n  // explicitly here.\n  switch (val) {\n  case DW_LANG_Mips_Assembler:\n    return eLanguageTypeMipsAssembler;\n  case DW_LANG_GOOGLE_RenderScript:\n    return eLanguageTypeExtRenderScript;\n  default:\n    return static_cast<LanguageType>(val);\n  }\n}\n\nLanguageType SymbolFileDWARF::GetLanguage(DWARFUnit &unit) {\n  return LanguageTypeFromDWARF(unit.GetDWARFLanguageType());\n}\n"}, "119": {"id": 119, "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/SymbolFile/DWARF/SymbolFileDWARFDebugMap.h", "content": "//===-- SymbolFileDWARFDebugMap.h ------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SOURCE_PLUGINS_SYMBOLFILE_DWARF_SYMBOLFILEDWARFDEBUGMAP_H\n#define LLDB_SOURCE_PLUGINS_SYMBOLFILE_DWARF_SYMBOLFILEDWARFDEBUGMAP_H\n\n#include \"lldb/Symbol/SymbolFile.h\"\n#include \"lldb/Utility/RangeMap.h\"\n#include \"llvm/Support/Chrono.h\"\n#include <bitset>\n#include <map>\n#include <vector>\n\n#include \"UniqueDWARFASTType.h\"\n\nclass SymbolFileDWARF;\nclass DWARFDebugAranges;\nclass DWARFDeclContext;\n\nclass SymbolFileDWARFDebugMap : public lldb_private::SymbolFile {\n  /// LLVM RTTI support.\n  static char ID;\n\npublic:\n  /// LLVM RTTI support.\n  /// \\{\n  bool isA(const void *ClassID) const override {\n    return ClassID == &ID || SymbolFile::isA(ClassID);\n  }\n  static bool classof(const SymbolFile *obj) { return obj->isA(&ID); }\n  /// \\}\n\n  // Static Functions\n  static void Initialize();\n\n  static void Terminate();\n\n  static lldb_private::ConstString GetPluginNameStatic();\n\n  static const char *GetPluginDescriptionStatic();\n\n  static lldb_private::SymbolFile *\n  CreateInstance(lldb::ObjectFileSP objfile_sp);\n\n  // Constructors and Destructors\n  SymbolFileDWARFDebugMap(lldb::ObjectFileSP objfile_sp);\n  ~SymbolFileDWARFDebugMap() override;\n\n  uint32_t CalculateAbilities() override;\n  void InitializeObject() override;\n\n  // Compile Unit function calls\n  lldb::LanguageType\n  ParseLanguage(lldb_private::CompileUnit &comp_unit) override;\n  lldb_private::XcodeSDK\n  ParseXcodeSDK(lldb_private::CompileUnit &comp_unit) override;\n  size_t ParseFunctions(lldb_private::CompileUnit &comp_unit) override;\n  bool ParseLineTable(lldb_private::CompileUnit &comp_unit) override;\n  bool ParseDebugMacros(lldb_private::CompileUnit &comp_unit) override;\n\n  bool ForEachExternalModule(\n      lldb_private::CompileUnit &, llvm::DenseSet<lldb_private::SymbolFile *> &,\n      llvm::function_ref<bool(lldb_private::Module &)>) override;\n\n  bool ParseSupportFiles(lldb_private::CompileUnit &comp_unit,\n                         lldb_private::FileSpecList &support_files) override;\n\n  bool ParseIsOptimized(lldb_private::CompileUnit &comp_unit) override;\n\n  size_t ParseTypes(lldb_private::CompileUnit &comp_unit) override;\n\n  bool ParseImportedModules(\n      const lldb_private::SymbolContext &sc,\n      std::vector<lldb_private::SourceModule> &imported_modules) override;\n  size_t ParseBlocksRecursive(lldb_private::Function &func) override;\n  size_t\n  ParseVariablesForContext(const lldb_private::SymbolContext &sc) override;\n\n  lldb_private::Type *ResolveTypeUID(lldb::user_id_t type_uid) override;\n  llvm::Optional<ArrayInfo> GetDynamicArrayInfoForUID(\n      lldb::user_id_t type_uid,\n      const lldb_private::ExecutionContext *exe_ctx) override;\n\n  lldb_private::CompilerDeclContext\n  GetDeclContextForUID(lldb::user_id_t uid) override;\n  lldb_private::CompilerDeclContext\n  GetDeclContextContainingUID(lldb::user_id_t uid) override;\n  void\n  ParseDeclsForContext(lldb_private::CompilerDeclContext decl_ctx) override;\n\n  bool CompleteType(lldb_private::CompilerType &compiler_type) override;\n  uint32_t ResolveSymbolContext(const lldb_private::Address &so_addr,\n                                lldb::SymbolContextItem resolve_scope,\n                                lldb_private::SymbolContext &sc) override;\n  uint32_t\n  ResolveSymbolContext(const lldb_private::FileSpec &file_spec, uint32_t line,\n                       bool check_inlines,\n                       lldb::SymbolContextItem resolve_scope,\n                       lldb_private::SymbolContextList &sc_list) override;\n  void\n  FindGlobalVariables(lldb_private::ConstString name,\n                      const lldb_private::CompilerDeclContext &parent_decl_ctx,\n                      uint32_t max_matches,\n                      lldb_private::VariableList &variables) override;\n  void FindGlobalVariables(const lldb_private::RegularExpression &regex,\n                           uint32_t max_matches,\n                           lldb_private::VariableList &variables) override;\n  void FindFunctions(lldb_private::ConstString name,\n                     const lldb_private::CompilerDeclContext &parent_decl_ctx,\n                     lldb::FunctionNameType name_type_mask,\n                     bool include_inlines,\n                     lldb_private::SymbolContextList &sc_list) override;\n  void FindFunctions(const lldb_private::RegularExpression &regex,\n                     bool include_inlines,\n                     lldb_private::SymbolContextList &sc_list) override;\n  void\n  FindTypes(lldb_private::ConstString name,\n            const lldb_private::CompilerDeclContext &parent_decl_ctx,\n            uint32_t max_matches,\n            llvm::DenseSet<lldb_private::SymbolFile *> &searched_symbol_files,\n            lldb_private::TypeMap &types) override;\n  void\n  FindTypes(llvm::ArrayRef<lldb_private::CompilerContext> context,\n            lldb_private::LanguageSet languages,\n            llvm::DenseSet<lldb_private::SymbolFile *> &searched_symbol_files,\n            lldb_private::TypeMap &types) override;\n  lldb_private::CompilerDeclContext FindNamespace(\n      lldb_private::ConstString name,\n      const lldb_private::CompilerDeclContext &parent_decl_ctx) override;\n  void GetTypes(lldb_private::SymbolContextScope *sc_scope,\n                lldb::TypeClass type_mask,\n                lldb_private::TypeList &type_list) override;\n  std::vector<std::unique_ptr<lldb_private::CallEdge>>\n  ParseCallEdgesInFunction(lldb_private::UserID func_id) override;\n\n  void DumpClangAST(lldb_private::Stream &s) override;\n\n  // PluginInterface protocol\n  lldb_private::ConstString GetPluginName() override;\n\n  uint32_t GetPluginVersion() override;\n\nprotected:\n  enum { kHaveInitializedOSOs = (1 << 0), kNumFlags };\n\n  friend class DebugMapModule;\n  friend class DWARFASTParserClang;\n  friend class DWARFCompileUnit;\n  friend class SymbolFileDWARF;\n  struct OSOInfo {\n    lldb::ModuleSP module_sp;\n\n    OSOInfo() : module_sp() {}\n  };\n\n  typedef std::shared_ptr<OSOInfo> OSOInfoSP;\n\n  typedef lldb_private::RangeDataVector<lldb::addr_t, lldb::addr_t,\n                                        lldb::addr_t>\n      FileRangeMap;\n\n  // Class specific types\n  struct CompileUnitInfo {\n    lldb_private::FileSpec so_file;\n    lldb_private::ConstString oso_path;\n    llvm::sys::TimePoint<> oso_mod_time;\n    OSOInfoSP oso_sp;\n    lldb::CompUnitSP compile_unit_sp;\n    uint32_t first_symbol_index;\n    uint32_t last_symbol_index;\n    uint32_t first_symbol_id;\n    uint32_t last_symbol_id;\n    FileRangeMap file_range_map;\n    bool file_range_map_valid;\n\n    CompileUnitInfo()\n        : so_file(), oso_path(), oso_mod_time(), oso_sp(), compile_unit_sp(),\n          first_symbol_index(UINT32_MAX), last_symbol_index(UINT32_MAX),\n          first_symbol_id(UINT32_MAX), last_symbol_id(UINT32_MAX),\n          file_range_map(), file_range_map_valid(false) {}\n\n    const FileRangeMap &GetFileRangeMap(SymbolFileDWARFDebugMap *exe_symfile);\n  };\n\n  // Protected Member Functions\n  void InitOSO();\n\n  uint32_t CalculateNumCompileUnits() override;\n  lldb::CompUnitSP ParseCompileUnitAtIndex(uint32_t index) override;\n\n  static uint32_t GetOSOIndexFromUserID(lldb::user_id_t uid) {\n    return (uint32_t)((uid >> 32ull) - 1ull);\n  }\n\n  static SymbolFileDWARF *GetSymbolFileAsSymbolFileDWARF(SymbolFile *sym_file);\n\n  bool GetFileSpecForSO(uint32_t oso_idx, lldb_private::FileSpec &file_spec);\n\n  CompileUnitInfo *GetCompUnitInfo(const lldb_private::SymbolContext &sc);\n  CompileUnitInfo *GetCompUnitInfo(const lldb_private::CompileUnit &comp_unit);\n\n  size_t GetCompUnitInfosForModule(const lldb_private::Module *oso_module,\n                                   std::vector<CompileUnitInfo *> &cu_infos);\n\n  lldb_private::Module *\n  GetModuleByCompUnitInfo(CompileUnitInfo *comp_unit_info);\n\n  lldb_private::Module *GetModuleByOSOIndex(uint32_t oso_idx);\n\n  lldb_private::ObjectFile *\n  GetObjectFileByCompUnitInfo(CompileUnitInfo *comp_unit_info);\n\n  lldb_private::ObjectFile *GetObjectFileByOSOIndex(uint32_t oso_idx);\n\n  uint32_t GetCompUnitInfoIndex(const CompileUnitInfo *comp_unit_info);\n\n  SymbolFileDWARF *GetSymbolFile(const lldb_private::SymbolContext &sc);\n  SymbolFileDWARF *GetSymbolFile(const lldb_private::CompileUnit &comp_unit);\n\n  SymbolFileDWARF *GetSymbolFileByCompUnitInfo(CompileUnitInfo *comp_unit_info);\n\n  SymbolFileDWARF *GetSymbolFileByOSOIndex(uint32_t oso_idx);\n\n  // If closure returns \"false\", iteration continues.  If it returns\n  // \"true\", iteration terminates.\n  void ForEachSymbolFile(std::function<bool(SymbolFileDWARF *)> closure) {\n    for (uint32_t oso_idx = 0, num_oso_idxs = m_compile_unit_infos.size();\n         oso_idx < num_oso_idxs; ++oso_idx) {\n      if (SymbolFileDWARF *oso_dwarf = GetSymbolFileByOSOIndex(oso_idx)) {\n        if (closure(oso_dwarf))\n          return;\n      }\n    }\n  }\n\n  CompileUnitInfo *GetCompileUnitInfoForSymbolWithIndex(uint32_t symbol_idx,\n                                                        uint32_t *oso_idx_ptr);\n\n  CompileUnitInfo *GetCompileUnitInfoForSymbolWithID(lldb::user_id_t symbol_id,\n                                                     uint32_t *oso_idx_ptr);\n\n  static int\n  SymbolContainsSymbolWithIndex(uint32_t *symbol_idx_ptr,\n                                const CompileUnitInfo *comp_unit_info);\n\n  static int SymbolContainsSymbolWithID(lldb::user_id_t *symbol_idx_ptr,\n                                        const CompileUnitInfo *comp_unit_info);\n\n  void PrivateFindGlobalVariables(\n      lldb_private::ConstString name,\n      const lldb_private::CompilerDeclContext &parent_decl_ctx,\n      const std::vector<uint32_t> &name_symbol_indexes, uint32_t max_matches,\n      lldb_private::VariableList &variables);\n\n  void SetCompileUnit(SymbolFileDWARF *oso_dwarf,\n                      const lldb::CompUnitSP &cu_sp);\n\n  lldb::CompUnitSP GetCompileUnit(SymbolFileDWARF *oso_dwarf);\n\n  CompileUnitInfo *GetCompileUnitInfo(SymbolFileDWARF *oso_dwarf);\n\n  lldb::TypeSP\n  FindDefinitionTypeForDWARFDeclContext(const DWARFDeclContext &die_decl_ctx);\n\n  bool Supports_DW_AT_APPLE_objc_complete_type(SymbolFileDWARF *skip_dwarf_oso);\n\n  lldb::TypeSP FindCompleteObjCDefinitionTypeForDIE(\n      const DWARFDIE &die, lldb_private::ConstString type_name,\n      bool must_be_implementation);\n\n  UniqueDWARFASTTypeMap &GetUniqueDWARFASTTypeMap() {\n    return m_unique_ast_type_map;\n  }\n\n  // OSOEntry\n  class OSOEntry {\n  public:\n    OSOEntry()\n        : m_exe_sym_idx(UINT32_MAX), m_oso_file_addr(LLDB_INVALID_ADDRESS) {}\n\n    OSOEntry(uint32_t exe_sym_idx, lldb::addr_t oso_file_addr)\n        : m_exe_sym_idx(exe_sym_idx), m_oso_file_addr(oso_file_addr) {}\n\n    uint32_t GetExeSymbolIndex() const { return m_exe_sym_idx; }\n\n    bool operator<(const OSOEntry &rhs) const {\n      return m_exe_sym_idx < rhs.m_exe_sym_idx;\n    }\n\n    lldb::addr_t GetOSOFileAddress() const { return m_oso_file_addr; }\n\n    void SetOSOFileAddress(lldb::addr_t oso_file_addr) {\n      m_oso_file_addr = oso_file_addr;\n    }\n\n  protected:\n    uint32_t m_exe_sym_idx;\n    lldb::addr_t m_oso_file_addr;\n  };\n\n  typedef lldb_private::RangeDataVector<lldb::addr_t, lldb::addr_t, OSOEntry>\n      DebugMap;\n\n  // Member Variables\n  std::bitset<kNumFlags> m_flags;\n  std::vector<CompileUnitInfo> m_compile_unit_infos;\n  std::vector<uint32_t> m_func_indexes; // Sorted by address\n  std::vector<uint32_t> m_glob_indexes;\n  std::map<std::pair<lldb_private::ConstString, llvm::sys::TimePoint<>>,\n           OSOInfoSP>\n      m_oso_map;\n  UniqueDWARFASTTypeMap m_unique_ast_type_map;\n  lldb_private::LazyBool m_supports_DW_AT_APPLE_objc_complete_type;\n  DebugMap m_debug_map;\n\n  // When an object file from the debug map gets parsed in\n  // SymbolFileDWARF, it needs to tell the debug map about the object\n  // files addresses by calling this function once for each N_FUN,\n  // N_GSYM and N_STSYM and after all entries in the debug map have\n  // been matched up, FinalizeOSOFileRanges() should be called.\n  bool AddOSOFileRange(CompileUnitInfo *cu_info, lldb::addr_t exe_file_addr,\n                       lldb::addr_t exe_byte_size, lldb::addr_t oso_file_addr,\n                       lldb::addr_t oso_byte_size);\n\n  // Called after calling AddOSOFileRange() for each object file debug\n  // map entry to finalize the info for the unlinked compile unit.\n  void FinalizeOSOFileRanges(CompileUnitInfo *cu_info);\n\n  /// Convert \\a addr from a .o file address, to an executable address.\n  ///\n  /// \\param[in] addr\n  ///     A section offset address from a .o file\n  ///\n  /// \\return\n  ///     Returns true if \\a addr was converted to be an executable\n  ///     section/offset address, false otherwise.\n  bool LinkOSOAddress(lldb_private::Address &addr);\n\n  /// Convert a .o file \"file address\" to an executable \"file address\".\n  ///\n  /// \\param[in] oso_symfile\n  ///     The DWARF symbol file that contains \\a oso_file_addr\n  ///\n  /// \\param[in] oso_file_addr\n  ///     A .o file \"file address\" to convert.\n  ///\n  /// \\return\n  ///     LLDB_INVALID_ADDRESS if \\a oso_file_addr is not in the\n  ///     linked executable, otherwise a valid \"file address\" from the\n  ///     linked executable that contains the debug map.\n  lldb::addr_t LinkOSOFileAddress(SymbolFileDWARF *oso_symfile,\n                                  lldb::addr_t oso_file_addr);\n\n  /// Given a line table full of lines with \"file addresses\" that are\n  /// for a .o file represented by \\a oso_symfile, link a new line table\n  /// and return it.\n  ///\n  /// \\param[in] oso_symfile\n  ///     The DWARF symbol file that produced the \\a line_table\n  ///\n  /// \\param[in] line_table\n  ///     A pointer to the line table.\n  ///\n  /// \\return\n  ///     Returns a valid line table full of linked addresses, or NULL\n  ///     if none of the line table addresses exist in the main\n  ///     executable.\n  lldb_private::LineTable *\n  LinkOSOLineTable(SymbolFileDWARF *oso_symfile,\n                   lldb_private::LineTable *line_table);\n\n  size_t AddOSOARanges(SymbolFileDWARF *dwarf2Data,\n                       DWARFDebugAranges *debug_aranges);\n};\n\n#endif // LLDB_SOURCE_PLUGINS_SYMBOLFILE_DWARF_SYMBOLFILEDWARFDEBUGMAP_H\n"}}, "reports": [{"events": [{"location": {"col": 9, "file": 54, "line": 28}, "message": "'ColorStyle' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Highlighter.h", "reportHash": "9e3550575572234e8e42727681658a06", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 54, "line": 126}, "message": "'DefaultHighlighter' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Highlighter.h", "reportHash": "7ddaf7f22a0ff6ef0b0344d4e133428d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 54, "line": 136}, "message": "'HighlighterManager' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Highlighter.h", "reportHash": "19ae2bef76965b74aee2563ff796781f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 62, "line": 37}, "message": "'PointerAsArraySettings' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/DataFormatters/DumpValueObjectOptions.h", "reportHash": "e6f811c1530a3527ff5a7d0ef35c9f1b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 68, "line": 36}, "message": "'Property' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Interpreter/Property.h", "reportHash": "5266306779b00121a443a3e1301ad402", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 103, "line": 261}, "message": "'ASTImporterDelegate' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/ExpressionParser/Clang/ClangASTImporter.h", "reportHash": "a979bcb3ddc1051c9f67a618dacc69b3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 103, "line": 344}, "message": "'ASTContextMetadata' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/ExpressionParser/Clang/ClangASTImporter.h", "reportHash": "7e85c49637382ee99ce446d43be16c03", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 104, "line": 32}, "message": "'CxxModuleHandler' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/ExpressionParser/Clang/CxxModuleHandler.h", "reportHash": "dc2dd5b24fb385b3832edd7974a19401", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 105, "line": 19}, "message": "'ClangHighlighter' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/Language/ClangCommon/ClangHighlighter.h", "reportHash": "f63ee3e852205ad68d05705afc72f44b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 106, "line": 16}, "message": "'AppleDWARFIndex' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/SymbolFile/DWARF/AppleDWARFIndex.h", "reportHash": "60c331a012a3bed7e27b8d88cd09b89d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 107, "line": 225}, "message": "'ParsedDWARFTypeAttributes' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/SymbolFile/DWARF/DWARFASTParserClang.h", "reportHash": "4bb9c889a214fe592ac967f4b8b8c424", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 110, "line": 31}, "message": "'DWARFDebugInfoEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/SymbolFile/DWARF/DWARFDebugInfoEntry.h", "reportHash": "193e69b9ab1fa8df566fdcb26dd88d88", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 111, "line": 25}, "message": "'Entry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/SymbolFile/DWARF/DWARFDeclContext.h", "reportHash": "34797112e0a38ba993a6a6493fc0f1c0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 112, "line": 20}, "message": "'DWARFFormValue' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/SymbolFile/DWARF/DWARFFormValue.h", "reportHash": "5da55d29582b1b5ff639209b9054c201", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 18, "file": 112, "line": 22}, "message": "'ValueTypeTag' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/SymbolFile/DWARF/DWARFFormValue.h", "reportHash": "c9a4b8509f8277c4788be0603dbed38f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 112, "line": 25}, "message": "'' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/SymbolFile/DWARF/DWARFFormValue.h", "reportHash": "7a1614d5e8be06435426538d05d0563f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 113, "line": 15}, "message": "'DWARFTypeUnit' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/SymbolFile/DWARF/DWARFTypeUnit.h", "reportHash": "4ddedafad0962213c2631e38d381c616", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 114, "line": 38}, "message": "'DWARFUnitHeader' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/SymbolFile/DWARF/DWARFUnit.h", "reportHash": "1370022cec8df7a8bf23b0ccaf218879", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 115, "line": 20}, "message": "'DebugNamesDWARFIndex' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/SymbolFile/DWARF/DebugNamesDWARFIndex.h", "reportHash": "215fcada8bd446c16f1f1d273da7e724", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 116, "line": 122}, "message": "'MemoryTable' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/SymbolFile/DWARF/HashedNameToDIE.h", "reportHash": "252a079e84ce3f6d6de3d75b7fb1f171", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 117, "line": 20}, "message": "'ManualDWARFIndex' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/SymbolFile/DWARF/ManualDWARFIndex.h", "reportHash": "b71912567187d950b200be409acc1044", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 118, "line": 129}, "message": "'PluginProperties' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/SymbolFile/DWARF/SymbolFileDWARF.cpp", "reportHash": "e200d23ae4658c085d88331c7c82158c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 119, "line": 155}, "message": "'OSOInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/SymbolFile/DWARF/SymbolFileDWARFDebugMap.h", "reportHash": "567ab20382d0ea63f58d2772e891d54c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
