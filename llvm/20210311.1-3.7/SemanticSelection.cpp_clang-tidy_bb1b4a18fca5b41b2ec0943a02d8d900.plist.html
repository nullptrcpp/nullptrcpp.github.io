<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/CollectMacros.h", "content": "//===--- CollectMacros.h -----------------------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_COLLECTEDMACROS_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_COLLECTEDMACROS_H\n\n#include \"AST.h\"\n#include \"Protocol.h\"\n#include \"SourceCode.h\"\n#include \"index/SymbolID.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Lex/PPCallbacks.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include <string>\n\nnamespace clang {\nnamespace clangd {\n\nstruct MacroOccurrence {\n  // Instead of storing SourceLocation, we have to store the token range because\n  // SourceManager from preamble is not available when we build the AST.\n  Range Rng;\n  bool IsDefinition;\n};\n\nstruct MainFileMacros {\n  llvm::StringSet<> Names;\n  llvm::DenseMap<SymbolID, std::vector<MacroOccurrence>> MacroRefs;\n  // Somtimes it is not possible to compute the SymbolID for the Macro, e.g. a\n  // reference to an undefined macro. Store them separately, e.g. for semantic\n  // highlighting.\n  std::vector<MacroOccurrence> UnknownMacros;\n  // Ranges skipped by the preprocessor due to being inactive.\n  std::vector<Range> SkippedRanges;\n};\n\n/// Collects macro references (e.g. definitions, expansions) in the main file.\n/// It is used to:\n///  - collect macros in the preamble section of the main file (in Preamble.cpp)\n///  - collect macros after the preamble of the main file (in ParsedAST.cpp)\nclass CollectMainFileMacros : public PPCallbacks {\npublic:\n  explicit CollectMainFileMacros(const SourceManager &SM, MainFileMacros &Out)\n      : SM(SM), Out(Out) {}\n\n  void FileChanged(SourceLocation Loc, FileChangeReason,\n                   SrcMgr::CharacteristicKind, FileID) override {\n    InMainFile = isInsideMainFile(Loc, SM);\n  }\n\n  void MacroDefined(const Token &MacroName, const MacroDirective *MD) override {\n    add(MacroName, MD->getMacroInfo(), /*IsDefinition=*/true);\n  }\n\n  void MacroExpands(const Token &MacroName, const MacroDefinition &MD,\n                    SourceRange Range, const MacroArgs *Args) override {\n    add(MacroName, MD.getMacroInfo());\n  }\n\n  void MacroUndefined(const clang::Token &MacroName,\n                      const clang::MacroDefinition &MD,\n                      const clang::MacroDirective *Undef) override {\n    add(MacroName, MD.getMacroInfo());\n  }\n\n  void Ifdef(SourceLocation Loc, const Token &MacroName,\n             const MacroDefinition &MD) override {\n    add(MacroName, MD.getMacroInfo());\n  }\n\n  void Ifndef(SourceLocation Loc, const Token &MacroName,\n              const MacroDefinition &MD) override {\n    add(MacroName, MD.getMacroInfo());\n  }\n\n  void Defined(const Token &MacroName, const MacroDefinition &MD,\n               SourceRange Range) override {\n    add(MacroName, MD.getMacroInfo());\n  }\n\n  void SourceRangeSkipped(SourceRange R, SourceLocation EndifLoc) override {\n    if (!InMainFile)\n      return;\n    Position Begin = sourceLocToPosition(SM, R.getBegin());\n    Position End = sourceLocToPosition(SM, R.getEnd());\n    Out.SkippedRanges.push_back(Range{Begin, End});\n  }\n\nprivate:\n  void add(const Token &MacroNameTok, const MacroInfo *MI,\n           bool IsDefinition = false);\n  const SourceManager &SM;\n  bool InMainFile = true;\n  MainFileMacros &Out;\n};\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_COLLECTEDMACROS_H\n"}, "2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/CompileCommands.h", "content": "//===--- CompileCommands.h - Manipulation of compile flags -------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_COMPILECOMMANDS_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_COMPILECOMMANDS_H\n\n#include \"support/Threading.h\"\n#include \"clang/Tooling/ArgumentsAdjusters.h\"\n#include \"clang/Tooling/CompilationDatabase.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include <deque>\n#include <string>\n#include <vector>\n\nnamespace clang {\nnamespace clangd {\n\n// CommandMangler transforms compile commands from some external source\n// for use in clangd. This means:\n//  - running the frontend only, stripping args regarding output files etc\n//  - forcing the use of clangd's builtin headers rather than clang's\n//  - resolving argv0 as cc1 expects\n//  - injecting -isysroot flags on mac as the system clang does\nstruct CommandMangler {\n  // Absolute path to clang.\n  llvm::Optional<std::string> ClangPath;\n  // Directory containing builtin headers.\n  llvm::Optional<std::string> ResourceDir;\n  // Root for searching for standard library (passed to -isysroot).\n  llvm::Optional<std::string> Sysroot;\n\n  // A command-mangler that doesn't know anything about the system.\n  // This is hermetic for unit-tests, but won't work well in production.\n  static CommandMangler forTests();\n  // Probe the system and build a command-mangler that knows the toolchain.\n  //  - try to find clang on $PATH, otherwise fake a path near clangd\n  //  - find the resource directory installed near clangd\n  //  - on mac, find clang and isysroot by querying the `xcrun` launcher\n  static CommandMangler detect();\n\n  void adjust(std::vector<std::string> &Cmd) const;\n  explicit operator clang::tooling::ArgumentsAdjuster() &&;\n\nprivate:\n  CommandMangler() = default;\n  Memoize<llvm::StringMap<std::string>> ResolvedDrivers;\n  Memoize<llvm::StringMap<std::string>> ResolvedDriversNoFollow;\n};\n\n// Removes args from a command-line in a semantically-aware way.\n//\n// Internally this builds a large (0.5MB) table of clang options on first use.\n// Both strip() and process() are fairly cheap after that.\n//\n// FIXME: this reimplements much of OptTable, it might be nice to expose more.\n// The table-building strategy may not make sense outside clangd.\nclass ArgStripper {\npublic:\n  ArgStripper() = default;\n  ArgStripper(ArgStripper &&) = default;\n  ArgStripper(const ArgStripper &) = delete;\n  ArgStripper &operator=(ArgStripper &&) = default;\n  ArgStripper &operator=(const ArgStripper &) = delete;\n\n  // Adds the arg to the set which should be removed.\n  //\n  // Recognized clang flags are stripped semantically. When \"-I\" is stripped:\n  //  - so is its value (either as -Ifoo or -I foo)\n  //  - aliases like --include-directory=foo are also stripped\n  //  - CL-style /Ifoo will be removed if the args indicate MS-compatible mode\n  // Compile args not recognized as flags are removed literally, except:\n  //  - strip(\"ABC*\") will remove any arg with an ABC prefix.\n  //\n  // In either case, the -Xclang prefix will be dropped if present.\n  void strip(llvm::StringRef Arg);\n  // Remove the targets from a compile command, in-place.\n  void process(std::vector<std::string> &Args) const;\n\nprivate:\n  // Deletion rules, to be checked for each arg.\n  struct Rule {\n    llvm::StringRef Text;    // Rule applies only if arg begins with Text.\n    unsigned char Modes = 0; // Rule applies only in specified driver modes.\n    uint16_t Priority = 0;   // Lower is better.\n    uint16_t ExactArgs = 0;  // Num args consumed when Arg == Text.\n    uint16_t PrefixArgs = 0; // Num args consumed when Arg starts with Text.\n  };\n  static llvm::ArrayRef<Rule> rulesFor(llvm::StringRef Arg);\n  const Rule *matchingRule(llvm::StringRef Arg, unsigned Mode,\n                           unsigned &ArgCount) const;\n  llvm::SmallVector<Rule> Rules;\n  std::deque<std::string> Storage; // Store strings not found in option table.\n};\n\n// Renders an argv list, with arguments separated by spaces.\n// Where needed, arguments are \"quoted\" and escaped.\nstd::string printArgv(llvm::ArrayRef<llvm::StringRef> Args);\nstd::string printArgv(llvm::ArrayRef<std::string> Args);\n\n} // namespace clangd\n} // namespace clang\n\n#endif\n"}, "3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Compiler.h", "content": "//===--- Compiler.h ----------------------------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Shared utilities for invoking the clang compiler.\n// Most callers will use this through Preamble/ParsedAST, but some features like\n// CodeComplete run their own compile actions that share these low-level pieces.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_COMPILER_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_COMPILER_H\n\n#include \"GlobalCompilationDatabase.h\"\n#include \"TidyProvider.h\"\n#include \"index/Index.h\"\n#include \"support/ThreadsafeFS.h\"\n#include \"clang/Frontend/CompilerInstance.h\"\n#include \"clang/Frontend/PrecompiledPreamble.h\"\n#include \"clang/Tooling/CompilationDatabase.h\"\n\nnamespace clang {\nnamespace clangd {\n\nclass IgnoreDiagnostics : public DiagnosticConsumer {\npublic:\n  static void log(DiagnosticsEngine::Level DiagLevel,\n                  const clang::Diagnostic &Info);\n\n  void HandleDiagnostic(DiagnosticsEngine::Level DiagLevel,\n                        const clang::Diagnostic &Info) override;\n};\n\n// Options to run clang e.g. when parsing AST.\nstruct ParseOptions {\n  // (empty at present, formerly controlled recovery AST, include-fixer etc)\n};\n\n/// Information required to run clang, e.g. to parse AST or do code completion.\nstruct ParseInputs {\n  tooling::CompileCommand CompileCommand;\n  const ThreadsafeFS *TFS;\n  std::string Contents;\n  // Version identifier for Contents, provided by the client and opaque to us.\n  std::string Version = \"null\";\n  // Prevent reuse of the cached preamble/AST. Slow! Useful to workaround\n  // clangd's assumption that missing header files will stay missing.\n  bool ForceRebuild = false;\n  // Used to recover from diagnostics (e.g. find missing includes for symbol).\n  const SymbolIndex *Index = nullptr;\n  ParseOptions Opts = ParseOptions();\n  TidyProviderRef ClangTidyProvider = {};\n};\n\n/// Builds compiler invocation that could be used to build AST or preamble.\nstd::unique_ptr<CompilerInvocation>\nbuildCompilerInvocation(const ParseInputs &Inputs, clang::DiagnosticConsumer &D,\n                        std::vector<std::string> *CC1Args = nullptr);\n\n/// Creates a compiler instance, configured so that:\n///   - Contents of the parsed file are remapped to \\p MainFile.\n///   - Preamble is overriden to use PCH passed to this function. It means the\n///     changes to the preamble headers or files included in the preamble are\n///     not visible to this compiler instance.\n///   - llvm::vfs::FileSystem is used for all underlying file accesses. The\n///     actual vfs used by the compiler may be an overlay over the passed vfs.\n/// Returns null on errors. When non-null value is returned, it is expected to\n/// be consumed by FrontendAction::BeginSourceFile to properly destroy \\p\n/// MainFile.\nstd::unique_ptr<CompilerInstance> prepareCompilerInstance(\n    std::unique_ptr<clang::CompilerInvocation>, const PrecompiledPreamble *,\n    std::unique_ptr<llvm::MemoryBuffer> MainFile,\n    IntrusiveRefCntPtr<llvm::vfs::FileSystem>, DiagnosticConsumer &);\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_COMPILER_H\n"}, "4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Diagnostics.h", "content": "//===--- Diagnostics.h -------------------------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_DIAGNOSTICS_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_DIAGNOSTICS_H\n\n#include \"Protocol.h\"\n#include \"support/Path.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringSet.h\"\n#include \"llvm/Support/SourceMgr.h\"\n#include <cassert>\n#include <string>\n\nnamespace clang {\nnamespace tidy {\nclass ClangTidyContext;\n} // namespace tidy\nnamespace clangd {\n\nstruct ClangdDiagnosticOptions {\n  /// If true, Clangd uses an LSP extension to embed the fixes with the\n  /// diagnostics that are sent to the client.\n  bool EmbedFixesInDiagnostics = false;\n\n  /// If true, Clangd uses the relatedInformation field to include other\n  /// locations (in particular attached notes).\n  /// Otherwise, these are flattened into the diagnostic message.\n  bool EmitRelatedLocations = false;\n\n  /// If true, Clangd uses an LSP extension to send the diagnostic's\n  /// category to the client. The category typically describes the compilation\n  /// stage during which the issue was produced, e.g. \"Semantic Issue\" or \"Parse\n  /// Issue\".\n  bool SendDiagnosticCategory = false;\n\n  /// If true, Clangd will add a number of available fixes to the diagnostic's\n  /// message.\n  bool DisplayFixesCount = true;\n};\n\n/// Contains basic information about a diagnostic.\nstruct DiagBase {\n  std::string Message;\n  // Intended to be used only in error messages.\n  // May be relative, absolute or even artificially constructed.\n  std::string File;\n  // Absolute path to containing file, if available.\n  llvm::Optional<std::string> AbsFile;\n\n  clangd::Range Range;\n  DiagnosticsEngine::Level Severity = DiagnosticsEngine::Note;\n  std::string Category;\n  // Since File is only descriptive, we store a separate flag to distinguish\n  // diags from the main file.\n  bool InsideMainFile = false;\n  unsigned ID; // e.g. member of clang::diag, or clang-tidy assigned ID.\n};\nllvm::raw_ostream &operator<<(llvm::raw_ostream &OS, const DiagBase &D);\n\n/// Represents a single fix-it that editor can apply to fix the error.\nstruct Fix {\n  /// Message for the fix-it.\n  std::string Message;\n  /// TextEdits from clang's fix-its. Must be non-empty.\n  llvm::SmallVector<TextEdit, 1> Edits;\n};\nllvm::raw_ostream &operator<<(llvm::raw_ostream &OS, const Fix &F);\n\n/// Represents a note for the diagnostic. Severity of notes can only be 'note'\n/// or 'remark'.\nstruct Note : DiagBase {};\n\n/// A top-level diagnostic that may have Notes and Fixes.\nstruct Diag : DiagBase {\n  std::string Name; // if ID was recognized.\n  // The source of this diagnostic.\n  enum DiagSource {\n    Unknown,\n    Clang,\n    ClangTidy,\n    ClangdConfig,\n  } Source = Unknown;\n  /// Elaborate on the problem, usually pointing to a related piece of code.\n  std::vector<Note> Notes;\n  /// *Alternative* fixes for this diagnostic, one should be chosen.\n  std::vector<Fix> Fixes;\n};\nllvm::raw_ostream &operator<<(llvm::raw_ostream &OS, const Diag &D);\n\nDiag toDiag(const llvm::SMDiagnostic &, Diag::DiagSource Source);\n\n/// Conversion to LSP diagnostics. Formats the error message of each diagnostic\n/// to include all its notes. Notes inside main file are also provided as\n/// separate diagnostics with their corresponding fixits. Notes outside main\n/// file do not have a corresponding LSP diagnostic, but can still be included\n/// as part of their main diagnostic's message.\nvoid toLSPDiags(\n    const Diag &D, const URIForFile &File, const ClangdDiagnosticOptions &Opts,\n    llvm::function_ref<void(clangd::Diagnostic, llvm::ArrayRef<Fix>)> OutFn);\n\n/// Convert from Fix to LSP CodeAction.\nCodeAction toCodeAction(const Fix &D, const URIForFile &File);\n\n/// Convert from clang diagnostic level to LSP severity.\nint getSeverity(DiagnosticsEngine::Level L);\n\n/// StoreDiags collects the diagnostics that can later be reported by\n/// clangd. It groups all notes for a diagnostic into a single Diag\n/// and filters out diagnostics that don't mention the main file (i.e. neither\n/// the diag itself nor its notes are in the main file).\nclass StoreDiags : public DiagnosticConsumer {\npublic:\n  // The ClangTidyContext populates Source and Name for clang-tidy diagnostics.\n  std::vector<Diag> take(const clang::tidy::ClangTidyContext *Tidy = nullptr);\n\n  void BeginSourceFile(const LangOptions &Opts,\n                       const Preprocessor *PP) override;\n  void EndSourceFile() override;\n  void HandleDiagnostic(DiagnosticsEngine::Level DiagLevel,\n                        const clang::Diagnostic &Info) override;\n\n  using DiagFixer = std::function<std::vector<Fix>(DiagnosticsEngine::Level,\n                                                   const clang::Diagnostic &)>;\n  using LevelAdjuster = std::function<DiagnosticsEngine::Level(\n      DiagnosticsEngine::Level, const clang::Diagnostic &)>;\n  /// If set, possibly adds fixes for diagnostics using \\p Fixer.\n  void contributeFixes(DiagFixer Fixer) { this->Fixer = Fixer; }\n  /// If set, this allows the client of this class to adjust the level of\n  /// diagnostics, such as promoting warnings to errors, or ignoring\n  /// diagnostics.\n  void setLevelAdjuster(LevelAdjuster Adjuster) { this->Adjuster = Adjuster; }\n\nprivate:\n  void flushLastDiag();\n\n  DiagFixer Fixer = nullptr;\n  LevelAdjuster Adjuster = nullptr;\n  std::vector<Diag> Output;\n  llvm::Optional<LangOptions> LangOpts;\n  llvm::Optional<Diag> LastDiag;\n  llvm::Optional<FullSourceLoc> LastDiagLoc; // Valid only when LastDiag is set.\n  bool LastDiagOriginallyError = false;      // Valid only when LastDiag is set.\n  SourceManager *OrigSrcMgr = nullptr;\n\n  llvm::DenseSet<std::pair<unsigned, unsigned>> IncludedErrorLocations;\n  bool LastPrimaryDiagnosticWasSuppressed = false;\n};\n\n/// Determine whether a (non-clang-tidy) diagnostic is suppressed by config.\nbool isBuiltinDiagnosticSuppressed(unsigned ID,\n                                   const llvm::StringSet<> &Suppressed);\n/// Take a user-specified diagnostic code, and convert it to a normalized form\n/// stored in the config and consumed by isBuiltinDiagnosticsSuppressed.\n///\n/// (This strips err_ and -W prefix so we can match with or without them.)\nllvm::StringRef normalizeSuppressedCode(llvm::StringRef);\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_DIAGNOSTICS_H\n"}, "5": {"id": 5, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/FS.h", "content": "//===--- FS.h - File system related utils ------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_FS_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_FS_H\n\n#include \"support/Path.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/Support/VirtualFileSystem.h\"\n\nnamespace clang {\nnamespace clangd {\n\n/// Records status information for files open()ed or stat()ed during preamble\n/// build (except for the main file), so we can avoid stat()s on the underlying\n/// FS when reusing the preamble. For example, code completion can re-stat files\n/// when getting FileID for source locations stored in preamble (e.g. checking\n/// whether a location is in the main file).\n///\n/// The cache is keyed by absolute path of file name in cached status, as this\n/// is what preamble stores.\n///\n/// The cache is not thread-safe when updates happen, so the use pattern should\n/// be:\n///   - One FS writes to the cache from one thread (or several but strictly\n///   sequenced), e.g. when building preamble.\n///   - Sequence point (no writes after this point, no reads before).\n///   - Several FSs can read from the cache, e.g. code completions.\n///\n/// Note that the cache is only valid when reusing preamble.\nclass PreambleFileStatusCache {\npublic:\n  /// \\p MainFilePath is the absolute path of the main source file this preamble\n  /// corresponds to. The stat for the main file will not be cached.\n  PreambleFileStatusCache(llvm::StringRef MainFilePath);\n\n  void update(const llvm::vfs::FileSystem &FS, llvm::vfs::Status S);\n\n  /// \\p Path is a path stored in preamble.\n  llvm::Optional<llvm::vfs::Status> lookup(llvm::StringRef Path) const;\n\n  /// Returns a VFS that collects file status.\n  /// Only cache stats for files that exist because\n  ///   1) we only care about existing files when reusing preamble, unlike\n  ///   building preamble.\n  ///   2) we use the file name in the Status as the cache key.\n  ///\n  /// Note that the returned VFS should not outlive the cache.\n  IntrusiveRefCntPtr<llvm::vfs::FileSystem>\n  getProducingFS(IntrusiveRefCntPtr<llvm::vfs::FileSystem> FS);\n\n  /// Returns a VFS that uses the cache collected.\n  ///\n  /// Note that the returned VFS should not outlive the cache.\n  IntrusiveRefCntPtr<llvm::vfs::FileSystem>\n  getConsumingFS(IntrusiveRefCntPtr<llvm::vfs::FileSystem> FS) const;\n\nprivate:\n  std::string MainFilePath;\n  llvm::StringMap<llvm::vfs::Status> StatCache;\n};\n\n/// Returns a version of \\p File that doesn't contain dots and dot dots.\n/// e.g /a/b/../c -> /a/c\n///     /a/b/./c -> /a/b/c\n/// FIXME: We should avoid encountering such paths in clangd internals by\n/// filtering everything we get over LSP, CDB, etc.\nPath removeDots(PathRef File);\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_FS_H\n"}, "6": {"id": 6, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/GlobalCompilationDatabase.h", "content": "//===--- GlobalCompilationDatabase.h -----------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_GLOBALCOMPILATIONDATABASE_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_GLOBALCOMPILATIONDATABASE_H\n\n#include \"CompileCommands.h\"\n#include \"support/Function.h\"\n#include \"support/Path.h\"\n#include \"support/ThreadsafeFS.h\"\n#include \"clang/Tooling/ArgumentsAdjusters.h\"\n#include \"clang/Tooling/CompilationDatabase.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include <memory>\n#include <mutex>\n#include <vector>\n\nnamespace clang {\nnamespace clangd {\n\nclass Logger;\n\nstruct ProjectInfo {\n  // The directory in which the compilation database was discovered.\n  // Empty if directory-based compilation database discovery was not used.\n  std::string SourceRoot;\n};\n\n/// Provides compilation arguments used for parsing C and C++ files.\nclass GlobalCompilationDatabase {\npublic:\n  virtual ~GlobalCompilationDatabase() = default;\n\n  /// If there are any known-good commands for building this file, returns one.\n  virtual llvm::Optional<tooling::CompileCommand>\n  getCompileCommand(PathRef File) const = 0;\n\n  /// Finds the closest project to \\p File.\n  virtual llvm::Optional<ProjectInfo> getProjectInfo(PathRef File) const {\n    return llvm::None;\n  }\n\n  /// Makes a guess at how to build a file.\n  /// The default implementation just runs clang on the file.\n  /// Clangd should treat the results as unreliable.\n  virtual tooling::CompileCommand getFallbackCommand(PathRef File) const;\n\n  /// If the CDB does any asynchronous work, wait for it to complete.\n  /// For use in tests.\n  virtual bool blockUntilIdle(Deadline D) const { return true; }\n\n  using CommandChanged = Event<std::vector<std::string>>;\n  /// The callback is notified when files may have new compile commands.\n  /// The argument is a list of full file paths.\n  CommandChanged::Subscription watch(CommandChanged::Listener L) const {\n    return OnCommandChanged.observe(std::move(L));\n  }\n\nprotected:\n  mutable CommandChanged OnCommandChanged;\n};\n\n// Helper class for implementing GlobalCompilationDatabases that wrap others.\nclass DelegatingCDB : public GlobalCompilationDatabase {\npublic:\n  DelegatingCDB(const GlobalCompilationDatabase *Base);\n  DelegatingCDB(std::unique_ptr<GlobalCompilationDatabase> Base);\n\n  llvm::Optional<tooling::CompileCommand>\n  getCompileCommand(PathRef File) const override;\n\n  llvm::Optional<ProjectInfo> getProjectInfo(PathRef File) const override;\n\n  tooling::CompileCommand getFallbackCommand(PathRef File) const override;\n\n  bool blockUntilIdle(Deadline D) const override;\n\nprivate:\n  const GlobalCompilationDatabase *Base;\n  std::unique_ptr<GlobalCompilationDatabase> BaseOwner;\n  CommandChanged::Subscription BaseChanged;\n};\n\n/// Gets compile args from tooling::CompilationDatabases built for parent\n/// directories.\nclass DirectoryBasedGlobalCompilationDatabase\n    : public GlobalCompilationDatabase {\npublic:\n  struct Options {\n    Options(const ThreadsafeFS &TFS) : TFS(TFS) {}\n\n    const ThreadsafeFS &TFS;\n    // Frequency to check whether e.g. compile_commands.json has changed.\n    std::chrono::steady_clock::duration RevalidateAfter =\n        std::chrono::seconds(5);\n    // Frequency to check whether e.g. compile_commands.json has been created.\n    // (This is more expensive to check frequently, as we check many locations).\n    std::chrono::steady_clock::duration RevalidateMissingAfter =\n        std::chrono::seconds(30);\n    // Used to provide per-file configuration.\n    std::function<Context(llvm::StringRef)> ContextProvider;\n    // Only look for a compilation database in this one fixed directory.\n    // FIXME: fold this into config/context mechanism.\n    llvm::Optional<Path> CompileCommandsDir;\n  };\n\n  DirectoryBasedGlobalCompilationDatabase(const Options &Opts);\n  ~DirectoryBasedGlobalCompilationDatabase() override;\n\n  /// Scans File's parents looking for compilation databases.\n  /// Any extra flags will be added.\n  /// Might trigger OnCommandChanged, if CDB wasn't broadcasted yet.\n  llvm::Optional<tooling::CompileCommand>\n  getCompileCommand(PathRef File) const override;\n\n  /// Returns the path to first directory containing a compilation database in\n  /// \\p File's parents.\n  llvm::Optional<ProjectInfo> getProjectInfo(PathRef File) const override;\n\n  bool blockUntilIdle(Deadline Timeout) const override;\n\nprivate:\n  Options Opts;\n\n  class DirectoryCache;\n  // Keyed by possibly-case-folded directory path.\n  // We can hand out pointers as they're stable and entries are never removed.\n  mutable llvm::StringMap<DirectoryCache> DirCaches;\n  mutable std::mutex DirCachesMutex;\n\n  std::vector<DirectoryCache *>\n  getDirectoryCaches(llvm::ArrayRef<llvm::StringRef> Dirs) const;\n\n  struct CDBLookupRequest {\n    PathRef FileName;\n    // Whether this lookup should trigger discovery of the CDB found.\n    bool ShouldBroadcast = false;\n    // Cached results newer than this are considered fresh and not checked\n    // against disk.\n    std::chrono::steady_clock::time_point FreshTime;\n    std::chrono::steady_clock::time_point FreshTimeMissing;\n  };\n  struct CDBLookupResult {\n    std::shared_ptr<const tooling::CompilationDatabase> CDB;\n    ProjectInfo PI;\n  };\n  llvm::Optional<CDBLookupResult> lookupCDB(CDBLookupRequest Request) const;\n\n  class BroadcastThread;\n  std::unique_ptr<BroadcastThread> Broadcaster;\n\n  // Performs broadcast on governed files.\n  void broadcastCDB(CDBLookupResult Res) const;\n\n  // cache test calls lookupCDB directly to ensure valid/invalid times.\n  friend class DirectoryBasedGlobalCompilationDatabaseCacheTest;\n};\n\n/// Extracts system include search path from drivers matching QueryDriverGlobs\n/// and adds them to the compile flags. Base may not be nullptr.\n/// Returns Base when \\p QueryDriverGlobs is empty.\nstd::unique_ptr<GlobalCompilationDatabase>\ngetQueryDriverDatabase(llvm::ArrayRef<std::string> QueryDriverGlobs,\n                       std::unique_ptr<GlobalCompilationDatabase> Base);\n\n/// Wraps another compilation database, and supports overriding the commands\n/// using an in-memory mapping.\nclass OverlayCDB : public DelegatingCDB {\npublic:\n  // Base may be null, in which case no entries are inherited.\n  // FallbackFlags are added to the fallback compile command.\n  // Adjuster is applied to all commands, fallback or not.\n  OverlayCDB(const GlobalCompilationDatabase *Base,\n             std::vector<std::string> FallbackFlags = {},\n             tooling::ArgumentsAdjuster Adjuster = nullptr);\n\n  llvm::Optional<tooling::CompileCommand>\n  getCompileCommand(PathRef File) const override;\n  tooling::CompileCommand getFallbackCommand(PathRef File) const override;\n\n  /// Sets or clears the compilation command for a particular file.\n  void\n  setCompileCommand(PathRef File,\n                    llvm::Optional<tooling::CompileCommand> CompilationCommand);\n\nprivate:\n  mutable std::mutex Mutex;\n  llvm::StringMap<tooling::CompileCommand> Commands; /* GUARDED_BY(Mut) */\n  tooling::ArgumentsAdjuster ArgsAdjuster;\n  std::vector<std::string> FallbackFlags;\n};\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_GLOBALCOMPILATIONDATABASE_H\n"}, "7": {"id": 7, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Headers.h", "content": "//===--- Headers.h - Include headers -----------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_HEADERS_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_HEADERS_H\n\n#include \"Protocol.h\"\n#include \"SourceCode.h\"\n#include \"index/Symbol.h\"\n#include \"support/Path.h\"\n#include \"clang/Basic/TokenKinds.h\"\n#include \"clang/Format/Format.h\"\n#include \"clang/Lex/HeaderSearch.h\"\n#include \"clang/Lex/PPCallbacks.h\"\n#include \"clang/Tooling/Inclusions/HeaderIncludes.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/StringSet.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/VirtualFileSystem.h\"\n#include <string>\n\nnamespace clang {\nnamespace clangd {\n\n/// Returns true if \\p Include is literal include like \"path\" or <path>.\nbool isLiteralInclude(llvm::StringRef Include);\n\n/// Represents a header file to be #include'd.\nstruct HeaderFile {\n  std::string File;\n  /// If this is true, `File` is a literal string quoted with <> or \"\" that\n  /// can be #included directly; otherwise, `File` is an absolute file path.\n  bool Verbatim;\n\n  bool valid() const;\n};\n\n/// Creates a `HeaderFile` from \\p Header which can be either a URI or a literal\n/// include.\nllvm::Expected<HeaderFile> toHeaderFile(llvm::StringRef Header,\n                                        llvm::StringRef HintPath);\n\n// Returns include headers for \\p Sym sorted by popularity. If two headers are\n// equally popular, prefer the shorter one.\nllvm::SmallVector<llvm::StringRef, 1> getRankedIncludes(const Symbol &Sym);\n\n// An #include directive that we found in the main file.\nstruct Inclusion {\n  tok::PPKeywordKind Directive; // Directive used for inclusion, e.g. import\n  std::string Written;          // Inclusion name as written e.g. <vector>.\n  Path Resolved; // Resolved path of included file. Empty if not resolved.\n  unsigned HashOffset = 0; // Byte offset from start of file to #.\n  int HashLine = 0;        // Line number containing the directive, 0-indexed.\n  SrcMgr::CharacteristicKind FileKind = SrcMgr::C_User;\n};\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const Inclusion &);\nbool operator==(const Inclusion &LHS, const Inclusion &RHS);\n\n// Contains information about one file in the build grpah and its direct\n// dependencies. Doesn't own the strings it references (IncludeGraph is\n// self-contained).\nstruct IncludeGraphNode {\n  enum class SourceFlag : uint8_t {\n    None = 0,\n    // Whether current file is a main file rather than a header.\n    IsTU = 1 << 0,\n    // Whether current file had any uncompilable errors during indexing.\n    HadErrors = 1 << 1,\n  };\n\n  SourceFlag Flags = SourceFlag::None;\n  llvm::StringRef URI;\n  FileDigest Digest{{0}};\n  std::vector<llvm::StringRef> DirectIncludes;\n};\n// FileURI and FileInclusions are references to keys of the map containing\n// them.\n// Important: The graph generated by those callbacks might contain cycles, self\n// edges and multi edges.\nusing IncludeGraph = llvm::StringMap<IncludeGraphNode>;\n\ninline IncludeGraphNode::SourceFlag operator|(IncludeGraphNode::SourceFlag A,\n                                              IncludeGraphNode::SourceFlag B) {\n  return static_cast<IncludeGraphNode::SourceFlag>(static_cast<uint8_t>(A) |\n                                                   static_cast<uint8_t>(B));\n}\n\ninline bool operator&(IncludeGraphNode::SourceFlag A,\n                      IncludeGraphNode::SourceFlag B) {\n  return static_cast<uint8_t>(A) & static_cast<uint8_t>(B);\n}\n\ninline IncludeGraphNode::SourceFlag &\noperator|=(IncludeGraphNode::SourceFlag &A, IncludeGraphNode::SourceFlag B) {\n  return A = A | B;\n}\n\n// Information captured about the inclusion graph in a translation unit.\n// This includes detailed information about the direct #includes, and summary\n// information about all transitive includes.\n//\n// It should be built incrementally with collectIncludeStructureCallback().\n// When we build the preamble, we capture and store its include structure along\n// with the preamble data. When we use the preamble, we can copy its\n// IncludeStructure and use another collectIncludeStructureCallback() to fill\n// in any non-preamble inclusions.\nclass IncludeStructure {\npublic:\n  std::vector<Inclusion> MainFileIncludes;\n\n  // Return all transitively reachable files.\n  llvm::ArrayRef<std::string> allHeaders() const { return RealPathNames; }\n\n  // Return all transitively reachable files, and their minimum include depth.\n  // All transitive includes (absolute paths), with their minimum include depth.\n  // Root --> 0, #included file --> 1, etc.\n  // Root is clang's name for a file, which may not be absolute.\n  // Usually it should be SM.getFileEntryForID(SM.getMainFileID())->getName().\n  llvm::StringMap<unsigned> includeDepth(llvm::StringRef Root) const;\n\n  // This updates IncludeDepth(), but not MainFileIncludes.\n  void recordInclude(llvm::StringRef IncludingName,\n                     llvm::StringRef IncludedName,\n                     llvm::StringRef IncludedRealName);\n\nprivate:\n  // Identifying files in a way that persists from preamble build to subsequent\n  // builds is surprisingly hard. FileID is unavailable in InclusionDirective(),\n  // and RealPathName and UniqueID are not preserved in the preamble.\n  // We use the FileEntry::Name, which is stable, interned into a \"file index\".\n  // The paths we want to expose are the RealPathName, so store those too.\n  std::vector<std::string> RealPathNames; // In file index order.\n  unsigned fileIndex(llvm::StringRef Name);\n  llvm::StringMap<unsigned> NameToIndex; // Values are file indexes.\n  // Maps a file's index to that of the files it includes.\n  llvm::DenseMap<unsigned, llvm::SmallVector<unsigned>> IncludeChildren;\n};\n\n/// Returns a PPCallback that visits all inclusions in the main file.\nstd::unique_ptr<PPCallbacks>\ncollectIncludeStructureCallback(const SourceManager &SM, IncludeStructure *Out);\n\n// Calculates insertion edit for including a new header in a file.\nclass IncludeInserter {\npublic:\n  // If \\p HeaderSearchInfo is nullptr (e.g. when compile command is\n  // infeasible), this will only try to insert verbatim headers, and\n  // include path of non-verbatim header will not be shortened.\n  IncludeInserter(StringRef FileName, StringRef Code,\n                  const format::FormatStyle &Style, StringRef BuildDir,\n                  HeaderSearch *HeaderSearchInfo)\n      : FileName(FileName), Code(Code), BuildDir(BuildDir),\n        HeaderSearchInfo(HeaderSearchInfo),\n        Inserter(FileName, Code, Style.IncludeStyle) {}\n\n  void addExisting(const Inclusion &Inc);\n\n  /// Checks whether to add an #include of the header into \\p File.\n  /// An #include will not be added if:\n  ///   - Either \\p DeclaringHeader or \\p InsertedHeader is already (directly)\n  ///   in \\p Inclusions (including those included via different paths).\n  ///   - \\p DeclaringHeader or \\p InsertedHeader is the same as \\p File.\n  ///\n  /// \\param DeclaringHeader is path of the original header corresponding to \\p\n  /// InsertedHeader e.g. the header that declares a symbol.\n  /// \\param InsertedHeader The preferred header to be inserted. This could be\n  /// the same as DeclaringHeader but must be provided.\n  bool shouldInsertInclude(PathRef DeclaringHeader,\n                           const HeaderFile &InsertedHeader) const;\n\n  /// Determines the preferred way to #include a file, taking into account the\n  /// search path. Usually this will prefer a shorter representation like\n  /// 'Foo/Bar.h' over a longer one like 'Baz/include/Foo/Bar.h'.\n  ///\n  /// \\param InsertedHeader The preferred header to be inserted.\n  ///\n  /// \\param IncludingFile is the absolute path of the file that InsertedHeader\n  /// will be inserted.\n  ///\n  /// \\return A quoted \"path\" or <path> to be included, or None if it couldn't\n  /// be shortened.\n  llvm::Optional<std::string>\n  calculateIncludePath(const HeaderFile &InsertedHeader,\n                       llvm::StringRef IncludingFile) const;\n\n  /// Calculates an edit that inserts \\p VerbatimHeader into code. If the header\n  /// is already included, this returns None.\n  llvm::Optional<TextEdit> insert(llvm::StringRef VerbatimHeader) const;\n\nprivate:\n  StringRef FileName;\n  StringRef Code;\n  StringRef BuildDir;\n  HeaderSearch *HeaderSearchInfo = nullptr;\n  llvm::StringSet<> IncludedHeaders; // Both written and resolved.\n  tooling::HeaderIncludes Inserter;  // Computers insertion replacement.\n};\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_HEADERS_H\n"}, "8": {"id": 8, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/ParsedAST.h", "content": "//===--- ParsedAST.h - Building translation units ----------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file exposes building a file as if it were open in clangd, and defines\n// the ParsedAST structure that holds the results.\n//\n// This is similar to a clang -fsyntax-only run that produces a clang AST, but\n// we have several customizations:\n//  - preamble handling\n//  - capturing diagnostics for later access\n//  - running clang-tidy checks checks\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_PARSEDAST_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_PARSEDAST_H\n\n#include \"CollectMacros.h\"\n#include \"Compiler.h\"\n#include \"Diagnostics.h\"\n#include \"Headers.h\"\n#include \"HeuristicResolver.h\"\n#include \"Preamble.h\"\n#include \"index/CanonicalIncludes.h\"\n#include \"support/Path.h\"\n#include \"clang/Frontend/FrontendAction.h\"\n#include \"clang/Frontend/PrecompiledPreamble.h\"\n#include \"clang/Lex/Preprocessor.h\"\n#include \"clang/Tooling/CompilationDatabase.h\"\n#include \"clang/Tooling/Syntax/Tokens.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <memory>\n#include <string>\n#include <vector>\n\nnamespace clang {\nnamespace clangd {\nclass SymbolIndex;\n\n/// Stores and provides access to parsed AST.\nclass ParsedAST {\npublic:\n  /// Attempts to run Clang and store the parsed AST.\n  /// If \\p Preamble is non-null it is reused during parsing.\n  /// This function does not check if preamble is valid to reuse.\n  static llvm::Optional<ParsedAST>\n  build(llvm::StringRef Filename, const ParseInputs &Inputs,\n        std::unique_ptr<clang::CompilerInvocation> CI,\n        llvm::ArrayRef<Diag> CompilerInvocationDiags,\n        std::shared_ptr<const PreambleData> Preamble);\n\n  ParsedAST(ParsedAST &&Other);\n  ParsedAST &operator=(ParsedAST &&Other);\n\n  ~ParsedAST();\n\n  /// Note that the returned ast will not contain decls from the preamble that\n  /// were not deserialized during parsing. Clients should expect only decls\n  /// from the main file to be in the AST.\n  ASTContext &getASTContext();\n  const ASTContext &getASTContext() const;\n\n  Preprocessor &getPreprocessor();\n  std::shared_ptr<Preprocessor> getPreprocessorPtr();\n  const Preprocessor &getPreprocessor() const;\n\n  SourceManager &getSourceManager() {\n    return getASTContext().getSourceManager();\n  }\n  const SourceManager &getSourceManager() const {\n    return getASTContext().getSourceManager();\n  }\n\n  const LangOptions &getLangOpts() const {\n    return getASTContext().getLangOpts();\n  }\n\n  /// This function returns top-level decls present in the main file of the AST.\n  /// The result does not include the decls that come from the preamble.\n  /// (These should be const, but RecursiveASTVisitor requires Decl*).\n  ArrayRef<Decl *> getLocalTopLevelDecls();\n\n  const std::vector<Diag> &getDiagnostics() const;\n\n  /// Returns the estimated size of the AST and the accessory structures, in\n  /// bytes. Does not include the size of the preamble.\n  std::size_t getUsedBytes() const;\n  const IncludeStructure &getIncludeStructure() const;\n  const CanonicalIncludes &getCanonicalIncludes() const;\n\n  /// Gets all macro references (definition, expansions) present in the main\n  /// file, including those in the preamble region.\n  const MainFileMacros &getMacros() const;\n  /// Tokens recorded while parsing the main file.\n  /// (!) does not have tokens from the preamble.\n  const syntax::TokenBuffer &getTokens() const { return Tokens; }\n\n  /// Returns the version of the ParseInputs this AST was built from.\n  llvm::StringRef version() const { return Version; }\n\n  /// Returns the version of the ParseInputs used to build Preamble part of this\n  /// AST. Might be None if no Preamble is used.\n  llvm::Optional<llvm::StringRef> preambleVersion() const;\n\n  const HeuristicResolver *getHeuristicResolver() const {\n    return Resolver.get();\n  }\n\nprivate:\n  ParsedAST(llvm::StringRef Version,\n            std::shared_ptr<const PreambleData> Preamble,\n            std::unique_ptr<CompilerInstance> Clang,\n            std::unique_ptr<FrontendAction> Action, syntax::TokenBuffer Tokens,\n            MainFileMacros Macros, std::vector<Decl *> LocalTopLevelDecls,\n            std::vector<Diag> Diags, IncludeStructure Includes,\n            CanonicalIncludes CanonIncludes);\n\n  std::string Version;\n  // In-memory preambles must outlive the AST, it is important that this member\n  // goes before Clang and Action.\n  std::shared_ptr<const PreambleData> Preamble;\n  // We store an \"incomplete\" FrontendAction (i.e. no EndSourceFile was called\n  // on it) and CompilerInstance used to run it. That way we don't have to do\n  // complex memory management of all Clang structures on our own. (They are\n  // stored in CompilerInstance and cleaned up by\n  // FrontendAction.EndSourceFile).\n  std::unique_ptr<CompilerInstance> Clang;\n  std::unique_ptr<FrontendAction> Action;\n  /// Tokens recorded after the preamble finished.\n  ///   - Includes all spelled tokens for the main file.\n  ///   - Includes expanded tokens produced **after** preamble.\n  ///   - Does not have spelled or expanded tokens for files from preamble.\n  syntax::TokenBuffer Tokens;\n\n  /// All macro definitions and expansions in the main file.\n  MainFileMacros Macros;\n  // Data, stored after parsing.\n  std::vector<Diag> Diags;\n  // Top-level decls inside the current file. Not that this does not include\n  // top-level decls from the preamble.\n  std::vector<Decl *> LocalTopLevelDecls;\n  IncludeStructure Includes;\n  CanonicalIncludes CanonIncludes;\n  std::unique_ptr<HeuristicResolver> Resolver;\n};\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_PARSEDAST_H\n"}, "9": {"id": 9, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Preamble.h", "content": "//===--- Preamble.h - Reusing expensive parts of the AST ---------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// The vast majority of code in a typical translation unit is in the headers\n// included at the top of the file.\n//\n// The preamble optimization says that we can parse this code once, and reuse\n// the result multiple times. The preamble is invalidated by changes to the\n// code in the preamble region, to the compile command, or to files on disk.\n//\n// This is the most important optimization in clangd: it allows operations like\n// code-completion to have sub-second latency. It is supported by the\n// PrecompiledPreamble functionality in clang, which wraps the techniques used\n// by PCH files, modules etc into a convenient interface.\n//\n//===----------------------------------------------------------------------===//\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_PREAMBLE_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_PREAMBLE_H\n\n#include \"CollectMacros.h\"\n#include \"Compiler.h\"\n#include \"Diagnostics.h\"\n#include \"FS.h\"\n#include \"Headers.h\"\n#include \"index/CanonicalIncludes.h\"\n#include \"support/Path.h\"\n#include \"clang/Frontend/CompilerInvocation.h\"\n#include \"clang/Frontend/PrecompiledPreamble.h\"\n#include \"clang/Lex/Lexer.h\"\n#include \"clang/Tooling/CompilationDatabase.h\"\n#include \"llvm/ADT/StringRef.h\"\n\n#include <memory>\n#include <string>\n#include <vector>\n\nnamespace clang {\nnamespace clangd {\n\n/// The parsed preamble and associated data.\n///\n/// As we must avoid re-parsing the preamble, any information that can only\n/// be obtained during parsing must be eagerly captured and stored here.\nstruct PreambleData {\n  PreambleData(const ParseInputs &Inputs, PrecompiledPreamble Preamble,\n               std::vector<Diag> Diags, IncludeStructure Includes,\n               MainFileMacros Macros,\n               std::unique_ptr<PreambleFileStatusCache> StatCache,\n               CanonicalIncludes CanonIncludes);\n\n  // Version of the ParseInputs this preamble was built from.\n  std::string Version;\n  tooling::CompileCommand CompileCommand;\n  PrecompiledPreamble Preamble;\n  std::vector<Diag> Diags;\n  // Processes like code completions and go-to-definitions will need #include\n  // information, and their compile action skips preamble range.\n  IncludeStructure Includes;\n  // Macros defined in the preamble section of the main file.\n  // Users care about headers vs main-file, not preamble vs non-preamble.\n  // These should be treated as main-file entities e.g. for code completion.\n  MainFileMacros Macros;\n  // Cache of FS operations performed when building the preamble.\n  // When reusing a preamble, this cache can be consumed to save IO.\n  std::unique_ptr<PreambleFileStatusCache> StatCache;\n  CanonicalIncludes CanonIncludes;\n};\n\nusing PreambleParsedCallback =\n    std::function<void(ASTContext &, std::shared_ptr<clang::Preprocessor>,\n                       const CanonicalIncludes &)>;\n\n/// Build a preamble for the new inputs unless an old one can be reused.\n/// If \\p PreambleCallback is set, it will be run on top of the AST while\n/// building the preamble.\nstd::shared_ptr<const PreambleData>\nbuildPreamble(PathRef FileName, CompilerInvocation CI,\n              const ParseInputs &Inputs, bool StoreInMemory,\n              PreambleParsedCallback PreambleCallback);\n\n/// Returns true if \\p Preamble is reusable for \\p Inputs. Note that it will\n/// return true when some missing headers are now available.\n/// FIXME: Should return more information about the delta between \\p Preamble\n/// and \\p Inputs, e.g. new headers.\nbool isPreambleCompatible(const PreambleData &Preamble,\n                          const ParseInputs &Inputs, PathRef FileName,\n                          const CompilerInvocation &CI);\n\n/// Stores information required to parse a TU using a (possibly stale) Baseline\n/// preamble. Later on this information can be injected into the main file by\n/// updating compiler invocation with \\c apply. This injected section\n/// approximately reflects additions to the preamble in Modified contents, e.g.\n/// new include directives.\nclass PreamblePatch {\npublic:\n  /// \\p Preamble is used verbatim.\n  static PreamblePatch unmodified(const PreambleData &Preamble);\n  /// Builds a patch that contains new PP directives introduced to the preamble\n  /// section of \\p Modified compared to \\p Baseline.\n  /// FIXME: This only handles include directives, we should at least handle\n  /// define/undef.\n  static PreamblePatch create(llvm::StringRef FileName,\n                              const ParseInputs &Modified,\n                              const PreambleData &Baseline);\n  /// Adjusts CI (which compiles the modified inputs) to be used with the\n  /// baseline preamble. This is done by inserting an artifical include to the\n  /// \\p CI that contains new directives calculated in create.\n  void apply(CompilerInvocation &CI) const;\n\n  /// Returns #include directives from the \\c Modified preamble that were\n  /// resolved using the \\c Baseline preamble. This covers the new locations of\n  /// inclusions that were moved around, but not inclusions of new files. Those\n  /// will be recorded when parsing the main file: the includes in the injected\n  /// section will be resolved back to their spelled positions in the main file\n  /// using the presumed-location mechanism.\n  std::vector<Inclusion> preambleIncludes() const;\n\n  /// Returns preamble bounds for the Modified.\n  PreambleBounds modifiedBounds() const { return ModifiedBounds; }\n\n  /// Returns textual patch contents.\n  llvm::StringRef text() const { return PatchContents; }\n\nprivate:\n  PreamblePatch() = default;\n  std::string PatchContents;\n  std::string PatchFileName;\n  /// Includes that are present in both \\p Baseline and \\p Modified. Used for\n  /// patching includes of baseline preamble.\n  std::vector<Inclusion> PreambleIncludes;\n  PreambleBounds ModifiedBounds = {0, false};\n};\n\n/// Translates locations inside preamble patch to their main-file equivalent\n/// using presumed locations. Returns \\p Loc if it isn't inside preamble patch.\nSourceLocation translatePreamblePatchLocation(SourceLocation Loc,\n                                              const SourceManager &SM);\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_PREAMBLE_H\n"}, "10": {"id": 10, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "content": "//===--- Protocol.h - Language Server Protocol Implementation ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains structs based on the LSP specification at\n// https://github.com/Microsoft/language-server-protocol/blob/master/protocol.md\n//\n// This is not meant to be a complete implementation, new interfaces are added\n// when they're needed.\n//\n// Each struct has a toJSON and fromJSON function, that converts between\n// the struct and a JSON representation. (See JSON.h)\n//\n// Some structs also have operator<< serialization. This is for debugging and\n// tests, and is not generally machine-readable.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_PROTOCOL_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_PROTOCOL_H\n\n#include \"URI.h\"\n#include \"index/SymbolID.h\"\n#include \"support/MemoryTree.h\"\n#include \"clang/Index/IndexSymbol.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/Support/JSON.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <bitset>\n#include <memory>\n#include <string>\n#include <vector>\n\nnamespace clang {\nnamespace clangd {\n\nenum class ErrorCode {\n  // Defined by JSON RPC.\n  ParseError = -32700,\n  InvalidRequest = -32600,\n  MethodNotFound = -32601,\n  InvalidParams = -32602,\n  InternalError = -32603,\n\n  ServerNotInitialized = -32002,\n  UnknownErrorCode = -32001,\n\n  // Defined by the protocol.\n  RequestCancelled = -32800,\n  ContentModified = -32801,\n};\n// Models an LSP error as an llvm::Error.\nclass LSPError : public llvm::ErrorInfo<LSPError> {\npublic:\n  std::string Message;\n  ErrorCode Code;\n  static char ID;\n\n  LSPError(std::string Message, ErrorCode Code)\n      : Message(std::move(Message)), Code(Code) {}\n\n  void log(llvm::raw_ostream &OS) const override {\n    OS << int(Code) << \": \" << Message;\n  }\n  std::error_code convertToErrorCode() const override {\n    return llvm::inconvertibleErrorCode();\n  }\n};\n\n// URI in \"file\" scheme for a file.\nstruct URIForFile {\n  URIForFile() = default;\n\n  /// Canonicalizes \\p AbsPath via URI.\n  ///\n  /// File paths in URIForFile can come from index or local AST. Path from\n  /// index goes through URI transformation, and the final path is resolved by\n  /// URI scheme and could potentially be different from the original path.\n  /// Hence, we do the same transformation for all paths.\n  ///\n  /// Files can be referred to by several paths (e.g. in the presence of links).\n  /// Which one we prefer may depend on where we're coming from. \\p TUPath is a\n  /// hint, and should usually be the main entrypoint file we're processing.\n  static URIForFile canonicalize(llvm::StringRef AbsPath,\n                                 llvm::StringRef TUPath);\n\n  static llvm::Expected<URIForFile> fromURI(const URI &U,\n                                            llvm::StringRef HintPath);\n\n  /// Retrieves absolute path to the file.\n  llvm::StringRef file() const { return File; }\n\n  explicit operator bool() const { return !File.empty(); }\n  std::string uri() const { return URI::createFile(File).toString(); }\n\n  friend bool operator==(const URIForFile &LHS, const URIForFile &RHS) {\n    return LHS.File == RHS.File;\n  }\n\n  friend bool operator!=(const URIForFile &LHS, const URIForFile &RHS) {\n    return !(LHS == RHS);\n  }\n\n  friend bool operator<(const URIForFile &LHS, const URIForFile &RHS) {\n    return LHS.File < RHS.File;\n  }\n\nprivate:\n  explicit URIForFile(std::string &&File) : File(std::move(File)) {}\n\n  std::string File;\n};\n\n/// Serialize/deserialize \\p URIForFile to/from a string URI.\nllvm::json::Value toJSON(const URIForFile &U);\nbool fromJSON(const llvm::json::Value &, URIForFile &, llvm::json::Path);\n\nstruct TextDocumentIdentifier {\n  /// The text document's URI.\n  URIForFile uri;\n};\nllvm::json::Value toJSON(const TextDocumentIdentifier &);\nbool fromJSON(const llvm::json::Value &, TextDocumentIdentifier &,\n              llvm::json::Path);\n\nstruct VersionedTextDocumentIdentifier : public TextDocumentIdentifier {\n  /// The version number of this document. If a versioned text document\n  /// identifier is sent from the server to the client and the file is not open\n  /// in the editor (the server has not received an open notification before)\n  /// the server can send `null` to indicate that the version is known and the\n  /// content on disk is the master (as speced with document content ownership).\n  ///\n  /// The version number of a document will increase after each change,\n  /// including undo/redo. The number doesn't need to be consecutive.\n  ///\n  /// clangd extension: versions are optional, and synthesized if missing.\n  llvm::Optional<std::int64_t> version;\n};\nllvm::json::Value toJSON(const VersionedTextDocumentIdentifier &);\nbool fromJSON(const llvm::json::Value &, VersionedTextDocumentIdentifier &,\n              llvm::json::Path);\n\nstruct Position {\n  /// Line position in a document (zero-based).\n  int line = 0;\n\n  /// Character offset on a line in a document (zero-based).\n  /// WARNING: this is in UTF-16 codepoints, not bytes or characters!\n  /// Use the functions in SourceCode.h to construct/interpret Positions.\n  int character = 0;\n\n  friend bool operator==(const Position &LHS, const Position &RHS) {\n    return std::tie(LHS.line, LHS.character) ==\n           std::tie(RHS.line, RHS.character);\n  }\n  friend bool operator!=(const Position &LHS, const Position &RHS) {\n    return !(LHS == RHS);\n  }\n  friend bool operator<(const Position &LHS, const Position &RHS) {\n    return std::tie(LHS.line, LHS.character) <\n           std::tie(RHS.line, RHS.character);\n  }\n  friend bool operator<=(const Position &LHS, const Position &RHS) {\n    return std::tie(LHS.line, LHS.character) <=\n           std::tie(RHS.line, RHS.character);\n  }\n};\nbool fromJSON(const llvm::json::Value &, Position &, llvm::json::Path);\nllvm::json::Value toJSON(const Position &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const Position &);\n\nstruct Range {\n  /// The range's start position.\n  Position start;\n\n  /// The range's end position.\n  Position end;\n\n  friend bool operator==(const Range &LHS, const Range &RHS) {\n    return std::tie(LHS.start, LHS.end) == std::tie(RHS.start, RHS.end);\n  }\n  friend bool operator!=(const Range &LHS, const Range &RHS) {\n    return !(LHS == RHS);\n  }\n  friend bool operator<(const Range &LHS, const Range &RHS) {\n    return std::tie(LHS.start, LHS.end) < std::tie(RHS.start, RHS.end);\n  }\n\n  bool contains(Position Pos) const { return start <= Pos && Pos < end; }\n  bool contains(Range Rng) const {\n    return start <= Rng.start && Rng.end <= end;\n  }\n};\nbool fromJSON(const llvm::json::Value &, Range &, llvm::json::Path);\nllvm::json::Value toJSON(const Range &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const Range &);\n\nstruct Location {\n  /// The text document's URI.\n  URIForFile uri;\n  Range range;\n\n  friend bool operator==(const Location &LHS, const Location &RHS) {\n    return LHS.uri == RHS.uri && LHS.range == RHS.range;\n  }\n\n  friend bool operator!=(const Location &LHS, const Location &RHS) {\n    return !(LHS == RHS);\n  }\n\n  friend bool operator<(const Location &LHS, const Location &RHS) {\n    return std::tie(LHS.uri, LHS.range) < std::tie(RHS.uri, RHS.range);\n  }\n};\nllvm::json::Value toJSON(const Location &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const Location &);\n\nstruct TextEdit {\n  /// The range of the text document to be manipulated. To insert\n  /// text into a document create a range where start === end.\n  Range range;\n\n  /// The string to be inserted. For delete operations use an\n  /// empty string.\n  std::string newText;\n};\ninline bool operator==(const TextEdit &L, const TextEdit &R) {\n  return std::tie(L.newText, L.range) == std::tie(R.newText, R.range);\n}\nbool fromJSON(const llvm::json::Value &, TextEdit &, llvm::json::Path);\nllvm::json::Value toJSON(const TextEdit &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const TextEdit &);\n\nstruct TextDocumentItem {\n  /// The text document's URI.\n  URIForFile uri;\n\n  /// The text document's language identifier.\n  std::string languageId;\n\n  /// The version number of this document (it will strictly increase after each\n  /// change, including undo/redo.\n  ///\n  /// clangd extension: versions are optional, and synthesized if missing.\n  llvm::Optional<int64_t> version;\n\n  /// The content of the opened text document.\n  std::string text;\n};\nbool fromJSON(const llvm::json::Value &, TextDocumentItem &, llvm::json::Path);\n\nenum class TraceLevel {\n  Off = 0,\n  Messages = 1,\n  Verbose = 2,\n};\nbool fromJSON(const llvm::json::Value &E, TraceLevel &Out, llvm::json::Path);\n\nstruct NoParams {};\ninline llvm::json::Value toJSON(const NoParams &) { return nullptr; }\ninline bool fromJSON(const llvm::json::Value &, NoParams &, llvm::json::Path) {\n  return true;\n}\nusing InitializedParams = NoParams;\n\n/// Defines how the host (editor) should sync document changes to the language\n/// server.\nenum class TextDocumentSyncKind {\n  /// Documents should not be synced at all.\n  None = 0,\n\n  /// Documents are synced by always sending the full content of the document.\n  Full = 1,\n\n  /// Documents are synced by sending the full content on open.  After that\n  /// only incremental updates to the document are send.\n  Incremental = 2,\n};\n\n/// The kind of a completion entry.\nenum class CompletionItemKind {\n  Missing = 0,\n  Text = 1,\n  Method = 2,\n  Function = 3,\n  Constructor = 4,\n  Field = 5,\n  Variable = 6,\n  Class = 7,\n  Interface = 8,\n  Module = 9,\n  Property = 10,\n  Unit = 11,\n  Value = 12,\n  Enum = 13,\n  Keyword = 14,\n  Snippet = 15,\n  Color = 16,\n  File = 17,\n  Reference = 18,\n  Folder = 19,\n  EnumMember = 20,\n  Constant = 21,\n  Struct = 22,\n  Event = 23,\n  Operator = 24,\n  TypeParameter = 25,\n};\nbool fromJSON(const llvm::json::Value &, CompletionItemKind &,\n              llvm::json::Path);\nconstexpr auto CompletionItemKindMin =\n    static_cast<size_t>(CompletionItemKind::Text);\nconstexpr auto CompletionItemKindMax =\n    static_cast<size_t>(CompletionItemKind::TypeParameter);\nusing CompletionItemKindBitset = std::bitset<CompletionItemKindMax + 1>;\nbool fromJSON(const llvm::json::Value &, CompletionItemKindBitset &,\n              llvm::json::Path);\nCompletionItemKind\nadjustKindToCapability(CompletionItemKind Kind,\n                       CompletionItemKindBitset &SupportedCompletionItemKinds);\n\n/// A symbol kind.\nenum class SymbolKind {\n  File = 1,\n  Module = 2,\n  Namespace = 3,\n  Package = 4,\n  Class = 5,\n  Method = 6,\n  Property = 7,\n  Field = 8,\n  Constructor = 9,\n  Enum = 10,\n  Interface = 11,\n  Function = 12,\n  Variable = 13,\n  Constant = 14,\n  String = 15,\n  Number = 16,\n  Boolean = 17,\n  Array = 18,\n  Object = 19,\n  Key = 20,\n  Null = 21,\n  EnumMember = 22,\n  Struct = 23,\n  Event = 24,\n  Operator = 25,\n  TypeParameter = 26\n};\nbool fromJSON(const llvm::json::Value &, SymbolKind &, llvm::json::Path);\nconstexpr auto SymbolKindMin = static_cast<size_t>(SymbolKind::File);\nconstexpr auto SymbolKindMax = static_cast<size_t>(SymbolKind::TypeParameter);\nusing SymbolKindBitset = std::bitset<SymbolKindMax + 1>;\nbool fromJSON(const llvm::json::Value &, SymbolKindBitset &, llvm::json::Path);\nSymbolKind adjustKindToCapability(SymbolKind Kind,\n                                  SymbolKindBitset &supportedSymbolKinds);\n\n// Convert a index::SymbolKind to clangd::SymbolKind (LSP)\n// Note, some are not perfect matches and should be improved when this LSP\n// issue is addressed:\n// https://github.com/Microsoft/language-server-protocol/issues/344\nSymbolKind indexSymbolKindToSymbolKind(index::SymbolKind Kind);\n\n// Determines the encoding used to measure offsets and lengths of source in LSP.\nenum class OffsetEncoding {\n  // Any string is legal on the wire. Unrecognized encodings parse as this.\n  UnsupportedEncoding,\n  // Length counts code units of UTF-16 encoded text. (Standard LSP behavior).\n  UTF16,\n  // Length counts bytes of UTF-8 encoded text. (Clangd extension).\n  UTF8,\n  // Length counts codepoints in unicode text. (Clangd extension).\n  UTF32,\n};\nllvm::json::Value toJSON(const OffsetEncoding &);\nbool fromJSON(const llvm::json::Value &, OffsetEncoding &, llvm::json::Path);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, OffsetEncoding);\n\n// Describes the content type that a client supports in various result literals\n// like `Hover`, `ParameterInfo` or `CompletionItem`.\nenum class MarkupKind {\n  PlainText,\n  Markdown,\n};\nbool fromJSON(const llvm::json::Value &, MarkupKind &, llvm::json::Path);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &OS, MarkupKind);\n\n// This struct doesn't mirror LSP!\n// The protocol defines deeply nested structures for client capabilities.\n// Instead of mapping them all, this just parses out the bits we care about.\nstruct ClientCapabilities {\n  /// The supported set of SymbolKinds for workspace/symbol.\n  /// workspace.symbol.symbolKind.valueSet\n  llvm::Optional<SymbolKindBitset> WorkspaceSymbolKinds;\n\n  /// Whether the client accepts diagnostics with codeActions attached inline.\n  /// textDocument.publishDiagnostics.codeActionsInline.\n  bool DiagnosticFixes = false;\n\n  /// Whether the client accepts diagnostics with related locations.\n  /// textDocument.publishDiagnostics.relatedInformation.\n  bool DiagnosticRelatedInformation = false;\n\n  /// Whether the client accepts diagnostics with category attached to it\n  /// using the \"category\" extension.\n  /// textDocument.publishDiagnostics.categorySupport\n  bool DiagnosticCategory = false;\n\n  /// Client supports snippets as insert text.\n  /// textDocument.completion.completionItem.snippetSupport\n  bool CompletionSnippets = false;\n\n  /// Client supports completions with additionalTextEdit near the cursor.\n  /// This is a clangd extension. (LSP says this is for unrelated text only).\n  /// textDocument.completion.editsNearCursor\n  bool CompletionFixes = false;\n\n  /// Client supports hierarchical document symbols.\n  /// textDocument.documentSymbol.hierarchicalDocumentSymbolSupport\n  bool HierarchicalDocumentSymbol = false;\n\n  /// Client supports signature help.\n  /// textDocument.signatureHelp\n  bool HasSignatureHelp = false;\n\n  /// Client supports processing label offsets instead of a simple label string.\n  /// textDocument.signatureHelp.signatureInformation.parameterInformation.labelOffsetSupport\n  bool OffsetsInSignatureHelp = false;\n\n  /// The supported set of CompletionItemKinds for textDocument/completion.\n  /// textDocument.completion.completionItemKind.valueSet\n  llvm::Optional<CompletionItemKindBitset> CompletionItemKinds;\n\n  /// The documentation format that should be used for textDocument/completion.\n  /// textDocument.completion.completionItem.documentationFormat\n  MarkupKind CompletionDocumentationFormat = MarkupKind::PlainText;\n\n  /// Client supports CodeAction return value for textDocument/codeAction.\n  /// textDocument.codeAction.codeActionLiteralSupport.\n  bool CodeActionStructure = false;\n\n  /// Client advertises support for the semanticTokens feature.\n  /// We support the textDocument/semanticTokens request in any case.\n  /// textDocument.semanticTokens\n  bool SemanticTokens = false;\n  /// Client supports Theia semantic highlighting extension.\n  /// https://github.com/microsoft/vscode-languageserver-node/pull/367\n  /// clangd no longer supports this, we detect it just to log a warning.\n  /// textDocument.semanticHighlightingCapabilities.semanticHighlighting\n  bool TheiaSemanticHighlighting = false;\n\n  /// Supported encodings for LSP character offsets. (clangd extension).\n  llvm::Optional<std::vector<OffsetEncoding>> offsetEncoding;\n\n  /// The content format that should be used for Hover requests.\n  /// textDocument.hover.contentEncoding\n  MarkupKind HoverContentFormat = MarkupKind::PlainText;\n\n  /// The client supports testing for validity of rename operations\n  /// before execution.\n  bool RenamePrepareSupport = false;\n\n  /// The client supports progress notifications.\n  /// window.workDoneProgress\n  bool WorkDoneProgress = false;\n\n  /// The client supports implicit $/progress work-done progress streams,\n  /// without a preceding window/workDoneProgress/create.\n  /// This is a clangd extension.\n  /// window.implicitWorkDoneProgressCreate\n  bool ImplicitProgressCreation = false;\n\n  /// Whether the client implementation supports a refresh request sent from the\n  /// server to the client.\n  bool SemanticTokenRefreshSupport = false;\n};\nbool fromJSON(const llvm::json::Value &, ClientCapabilities &,\n              llvm::json::Path);\n\n/// Clangd extension that's used in the 'compilationDatabaseChanges' in\n/// workspace/didChangeConfiguration to record updates to the in-memory\n/// compilation database.\nstruct ClangdCompileCommand {\n  std::string workingDirectory;\n  std::vector<std::string> compilationCommand;\n};\nbool fromJSON(const llvm::json::Value &, ClangdCompileCommand &,\n              llvm::json::Path);\n\n/// Clangd extension: parameters configurable at any time, via the\n/// `workspace/didChangeConfiguration` notification.\n/// LSP defines this type as `any`.\nstruct ConfigurationSettings {\n  // Changes to the in-memory compilation database.\n  // The key of the map is a file name.\n  std::map<std::string, ClangdCompileCommand> compilationDatabaseChanges;\n};\nbool fromJSON(const llvm::json::Value &, ConfigurationSettings &,\n              llvm::json::Path);\n\n/// Clangd extension: parameters configurable at `initialize` time.\n/// LSP defines this type as `any`.\nstruct InitializationOptions {\n  // What we can change throught the didChangeConfiguration request, we can\n  // also set through the initialize request (initializationOptions field).\n  ConfigurationSettings ConfigSettings;\n\n  llvm::Optional<std::string> compilationDatabasePath;\n  // Additional flags to be included in the \"fallback command\" used when\n  // the compilation database doesn't describe an opened file.\n  // The command used will be approximately `clang $FILE $fallbackFlags`.\n  std::vector<std::string> fallbackFlags;\n\n  /// Clients supports show file status for textDocument/clangd.fileStatus.\n  bool FileStatus = false;\n};\nbool fromJSON(const llvm::json::Value &, InitializationOptions &,\n              llvm::json::Path);\n\nstruct InitializeParams {\n  /// The process Id of the parent process that started\n  /// the server. Is null if the process has not been started by another\n  /// process. If the parent process is not alive then the server should exit\n  /// (see exit notification) its process.\n  llvm::Optional<int> processId;\n\n  /// The rootPath of the workspace. Is null\n  /// if no folder is open.\n  ///\n  /// @deprecated in favour of rootUri.\n  llvm::Optional<std::string> rootPath;\n\n  /// The rootUri of the workspace. Is null if no\n  /// folder is open. If both `rootPath` and `rootUri` are set\n  /// `rootUri` wins.\n  llvm::Optional<URIForFile> rootUri;\n\n  // User provided initialization options.\n  // initializationOptions?: any;\n\n  /// The capabilities provided by the client (editor or tool)\n  ClientCapabilities capabilities;\n  /// The same data as capabilities, but not parsed (to expose to modules).\n  llvm::json::Object rawCapabilities;\n\n  /// The initial trace setting. If omitted trace is disabled ('off').\n  llvm::Optional<TraceLevel> trace;\n\n  /// User-provided initialization options.\n  InitializationOptions initializationOptions;\n};\nbool fromJSON(const llvm::json::Value &, InitializeParams &, llvm::json::Path);\n\nstruct WorkDoneProgressCreateParams {\n  /// The token to be used to report progress.\n  llvm::json::Value token = nullptr;\n};\nllvm::json::Value toJSON(const WorkDoneProgressCreateParams &P);\n\ntemplate <typename T> struct ProgressParams {\n  /// The progress token provided by the client or server.\n  llvm::json::Value token = nullptr;\n\n  /// The progress data.\n  T value;\n};\ntemplate <typename T> llvm::json::Value toJSON(const ProgressParams<T> &P) {\n  return llvm::json::Object{{\"token\", P.token}, {\"value\", P.value}};\n}\n/// To start progress reporting a $/progress notification with the following\n/// payload must be sent.\nstruct WorkDoneProgressBegin {\n  /// Mandatory title of the progress operation. Used to briefly inform about\n  /// the kind of operation being performed.\n  ///\n  /// Examples: \"Indexing\" or \"Linking dependencies\".\n  std::string title;\n\n  /// Controls if a cancel button should show to allow the user to cancel the\n  /// long-running operation. Clients that don't support cancellation are\n  /// allowed to ignore the setting.\n  bool cancellable = false;\n\n  /// Optional progress percentage to display (value 100 is considered 100%).\n  /// If not provided infinite progress is assumed and clients are allowed\n  /// to ignore the `percentage` value in subsequent in report notifications.\n  ///\n  /// The value should be steadily rising. Clients are free to ignore values\n  /// that are not following this rule.\n  ///\n  /// Clangd implementation note: we only send nonzero percentages in\n  /// the WorkProgressReport. 'true' here means percentages will be used.\n  bool percentage = false;\n};\nllvm::json::Value toJSON(const WorkDoneProgressBegin &);\n\n/// Reporting progress is done using the following payload.\nstruct WorkDoneProgressReport {\n  /// Mandatory title of the progress operation. Used to briefly inform about\n  /// the kind of operation being performed.\n  ///\n  /// Examples: \"Indexing\" or \"Linking dependencies\".\n  std::string title;\n\n  /// Controls enablement state of a cancel button. This property is only valid\n  /// if a cancel button got requested in the `WorkDoneProgressStart` payload.\n  ///\n  /// Clients that don't support cancellation or don't support control\n  /// the button's enablement state are allowed to ignore the setting.\n  llvm::Optional<bool> cancellable;\n\n  /// Optional, more detailed associated progress message. Contains\n  /// complementary information to the `title`.\n  ///\n  /// Examples: \"3/25 files\", \"project/src/module2\", \"node_modules/some_dep\".\n  /// If unset, the previous progress message (if any) is still valid.\n  llvm::Optional<std::string> message;\n\n  /// Optional progress percentage to display (value 100 is considered 100%).\n  /// If not provided infinite progress is assumed and clients are allowed\n  /// to ignore the `percentage` value in subsequent in report notifications.\n  ///\n  /// The value should be steadily rising. Clients are free to ignore values\n  /// that are not following this rule.\n  llvm::Optional<double> percentage;\n};\nllvm::json::Value toJSON(const WorkDoneProgressReport &);\n//\n/// Signals the end of progress reporting.\nstruct WorkDoneProgressEnd {\n  /// Optional, a final message indicating to for example indicate the outcome\n  /// of the operation.\n  llvm::Optional<std::string> message;\n};\nllvm::json::Value toJSON(const WorkDoneProgressEnd &);\n\nenum class MessageType {\n  /// An error message.\n  Error = 1,\n  /// A warning message.\n  Warning = 2,\n  /// An information message.\n  Info = 3,\n  /// A log message.\n  Log = 4,\n};\nllvm::json::Value toJSON(const MessageType &);\n\n/// The show message notification is sent from a server to a client to ask the\n/// client to display a particular message in the user interface.\nstruct ShowMessageParams {\n  /// The message type.\n  MessageType type = MessageType::Info;\n  /// The actual message.\n  std::string message;\n};\nllvm::json::Value toJSON(const ShowMessageParams &);\n\nstruct DidOpenTextDocumentParams {\n  /// The document that was opened.\n  TextDocumentItem textDocument;\n};\nbool fromJSON(const llvm::json::Value &, DidOpenTextDocumentParams &,\n              llvm::json::Path);\n\nstruct DidCloseTextDocumentParams {\n  /// The document that was closed.\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, DidCloseTextDocumentParams &,\n              llvm::json::Path);\n\nstruct DidSaveTextDocumentParams {\n  /// The document that was saved.\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, DidSaveTextDocumentParams &,\n              llvm::json::Path);\n\nstruct TextDocumentContentChangeEvent {\n  /// The range of the document that changed.\n  llvm::Optional<Range> range;\n\n  /// The length of the range that got replaced.\n  llvm::Optional<int> rangeLength;\n\n  /// The new text of the range/document.\n  std::string text;\n};\nbool fromJSON(const llvm::json::Value &, TextDocumentContentChangeEvent &,\n              llvm::json::Path);\n\nstruct DidChangeTextDocumentParams {\n  /// The document that did change. The version number points\n  /// to the version after all provided content changes have\n  /// been applied.\n  VersionedTextDocumentIdentifier textDocument;\n\n  /// The actual content changes.\n  std::vector<TextDocumentContentChangeEvent> contentChanges;\n\n  /// Forces diagnostics to be generated, or to not be generated, for this\n  /// version of the file. If not set, diagnostics are eventually consistent:\n  /// either they will be provided for this version or some subsequent one.\n  /// This is a clangd extension.\n  llvm::Optional<bool> wantDiagnostics;\n\n  /// Force a complete rebuild of the file, ignoring all cached state. Slow!\n  /// This is useful to defeat clangd's assumption that missing headers will\n  /// stay missing.\n  /// This is a clangd extension.\n  bool forceRebuild = false;\n};\nbool fromJSON(const llvm::json::Value &, DidChangeTextDocumentParams &,\n              llvm::json::Path);\n\nenum class FileChangeType {\n  /// The file got created.\n  Created = 1,\n  /// The file got changed.\n  Changed = 2,\n  /// The file got deleted.\n  Deleted = 3\n};\nbool fromJSON(const llvm::json::Value &E, FileChangeType &Out,\n              llvm::json::Path);\n\nstruct FileEvent {\n  /// The file's URI.\n  URIForFile uri;\n  /// The change type.\n  FileChangeType type = FileChangeType::Created;\n};\nbool fromJSON(const llvm::json::Value &, FileEvent &, llvm::json::Path);\n\nstruct DidChangeWatchedFilesParams {\n  /// The actual file events.\n  std::vector<FileEvent> changes;\n};\nbool fromJSON(const llvm::json::Value &, DidChangeWatchedFilesParams &,\n              llvm::json::Path);\n\nstruct DidChangeConfigurationParams {\n  ConfigurationSettings settings;\n};\nbool fromJSON(const llvm::json::Value &, DidChangeConfigurationParams &,\n              llvm::json::Path);\n\n// Note: we do not parse FormattingOptions for *FormattingParams.\n// In general, we use a clang-format style detected from common mechanisms\n// (.clang-format files and the -fallback-style flag).\n// It would be possible to override these with FormatOptions, but:\n//  - the protocol makes FormatOptions mandatory, so many clients set them to\n//    useless values, and we can't tell when to respect them\n// - we also format in other places, where FormatOptions aren't available.\n\nstruct DocumentRangeFormattingParams {\n  /// The document to format.\n  TextDocumentIdentifier textDocument;\n\n  /// The range to format\n  Range range;\n};\nbool fromJSON(const llvm::json::Value &, DocumentRangeFormattingParams &,\n              llvm::json::Path);\n\nstruct DocumentOnTypeFormattingParams {\n  /// The document to format.\n  TextDocumentIdentifier textDocument;\n\n  /// The position at which this request was sent.\n  Position position;\n\n  /// The character that has been typed.\n  std::string ch;\n};\nbool fromJSON(const llvm::json::Value &, DocumentOnTypeFormattingParams &,\n              llvm::json::Path);\n\nstruct DocumentFormattingParams {\n  /// The document to format.\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, DocumentFormattingParams &,\n              llvm::json::Path);\n\nstruct DocumentSymbolParams {\n  // The text document to find symbols in.\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, DocumentSymbolParams &,\n              llvm::json::Path);\n\n/// Represents a related message and source code location for a diagnostic.\n/// This should be used to point to code locations that cause or related to a\n/// diagnostics, e.g when duplicating a symbol in a scope.\nstruct DiagnosticRelatedInformation {\n  /// The location of this related diagnostic information.\n  Location location;\n  /// The message of this related diagnostic information.\n  std::string message;\n};\nllvm::json::Value toJSON(const DiagnosticRelatedInformation &);\n\nstruct CodeAction;\nstruct Diagnostic {\n  /// The range at which the message applies.\n  Range range;\n\n  /// The diagnostic's severity. Can be omitted. If omitted it is up to the\n  /// client to interpret diagnostics as error, warning, info or hint.\n  int severity = 0;\n\n  /// The diagnostic's code. Can be omitted.\n  std::string code;\n\n  /// A human-readable string describing the source of this\n  /// diagnostic, e.g. 'typescript' or 'super lint'.\n  std::string source;\n\n  /// The diagnostic's message.\n  std::string message;\n\n  /// An array of related diagnostic information, e.g. when symbol-names within\n  /// a scope collide all definitions can be marked via this property.\n  llvm::Optional<std::vector<DiagnosticRelatedInformation>> relatedInformation;\n\n  /// The diagnostic's category. Can be omitted.\n  /// An LSP extension that's used to send the name of the category over to the\n  /// client. The category typically describes the compilation stage during\n  /// which the issue was produced, e.g. \"Semantic Issue\" or \"Parse Issue\".\n  llvm::Optional<std::string> category;\n\n  /// Clangd extension: code actions related to this diagnostic.\n  /// Only with capability textDocument.publishDiagnostics.codeActionsInline.\n  /// (These actions can also be obtained using textDocument/codeAction).\n  llvm::Optional<std::vector<CodeAction>> codeActions;\n};\nllvm::json::Value toJSON(const Diagnostic &);\n\n/// A LSP-specific comparator used to find diagnostic in a container like\n/// std:map.\n/// We only use the required fields of Diagnostic to do the comparison to avoid\n/// any regression issues from LSP clients (e.g. VScode), see\n/// https://git.io/vbr29\nstruct LSPDiagnosticCompare {\n  bool operator()(const Diagnostic &LHS, const Diagnostic &RHS) const {\n    return std::tie(LHS.range, LHS.message) < std::tie(RHS.range, RHS.message);\n  }\n};\nbool fromJSON(const llvm::json::Value &, Diagnostic &, llvm::json::Path);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const Diagnostic &);\n\nstruct PublishDiagnosticsParams {\n  /// The URI for which diagnostic information is reported.\n  URIForFile uri;\n  /// An array of diagnostic information items.\n  std::vector<Diagnostic> diagnostics;\n  /// The version number of the document the diagnostics are published for.\n  llvm::Optional<int64_t> version;\n};\nllvm::json::Value toJSON(const PublishDiagnosticsParams &);\n\nstruct CodeActionContext {\n  /// An array of diagnostics known on the client side overlapping the range\n  /// provided to the `textDocument/codeAction` request. They are provided so\n  /// that the server knows which errors are currently presented to the user for\n  /// the given range. There is no guarantee that these accurately reflect the\n  /// error state of the resource. The primary parameter to compute code actions\n  /// is the provided range.\n  std::vector<Diagnostic> diagnostics;\n\n  /// Requested kind of actions to return.\n  ///\n  /// Actions not of this kind are filtered out by the client before being\n  /// shown. So servers can omit computing them.\n  std::vector<std::string> only;\n};\nbool fromJSON(const llvm::json::Value &, CodeActionContext &, llvm::json::Path);\n\nstruct CodeActionParams {\n  /// The document in which the command was invoked.\n  TextDocumentIdentifier textDocument;\n\n  /// The range for which the command was invoked.\n  Range range;\n\n  /// Context carrying additional information.\n  CodeActionContext context;\n};\nbool fromJSON(const llvm::json::Value &, CodeActionParams &, llvm::json::Path);\n\nstruct WorkspaceEdit {\n  /// Holds changes to existing resources.\n  llvm::Optional<std::map<std::string, std::vector<TextEdit>>> changes;\n\n  /// Note: \"documentChanges\" is not currently used because currently there is\n  /// no support for versioned edits.\n};\nbool fromJSON(const llvm::json::Value &, WorkspaceEdit &, llvm::json::Path);\nllvm::json::Value toJSON(const WorkspaceEdit &WE);\n\n/// Arguments for the 'applyTweak' command. The server sends these commands as a\n/// response to the textDocument/codeAction request. The client can later send a\n/// command back to the server if the user requests to execute a particular code\n/// tweak.\nstruct TweakArgs {\n  /// A file provided by the client on a textDocument/codeAction request.\n  URIForFile file;\n  /// A selection provided by the client on a textDocument/codeAction request.\n  Range selection;\n  /// ID of the tweak that should be executed. Corresponds to Tweak::id().\n  std::string tweakID;\n};\nbool fromJSON(const llvm::json::Value &, TweakArgs &, llvm::json::Path);\nllvm::json::Value toJSON(const TweakArgs &A);\n\nstruct ExecuteCommandParams {\n  /// The identifier of the actual command handler.\n  std::string command;\n\n  // This is `arguments?: []any` in LSP.\n  // All clangd's commands accept a single argument (or none => null).\n  llvm::json::Value argument = nullptr;\n};\nbool fromJSON(const llvm::json::Value &, ExecuteCommandParams &,\n              llvm::json::Path);\n\nstruct Command : public ExecuteCommandParams {\n  std::string title;\n};\nllvm::json::Value toJSON(const Command &C);\n\n/// A code action represents a change that can be performed in code, e.g. to fix\n/// a problem or to refactor code.\n///\n/// A CodeAction must set either `edit` and/or a `command`. If both are\n/// supplied, the `edit` is applied first, then the `command` is executed.\nstruct CodeAction {\n  /// A short, human-readable, title for this code action.\n  std::string title;\n\n  /// The kind of the code action.\n  /// Used to filter code actions.\n  llvm::Optional<std::string> kind;\n  const static llvm::StringLiteral QUICKFIX_KIND;\n  const static llvm::StringLiteral REFACTOR_KIND;\n  const static llvm::StringLiteral INFO_KIND;\n\n  /// The diagnostics that this code action resolves.\n  llvm::Optional<std::vector<Diagnostic>> diagnostics;\n\n  /// Marks this as a preferred action. Preferred actions are used by the\n  /// `auto fix` command and can be targeted by keybindings.\n  /// A quick fix should be marked preferred if it properly addresses the\n  /// underlying error. A refactoring should be marked preferred if it is the\n  /// most reasonable choice of actions to take.\n  bool isPreferred = false;\n\n  /// The workspace edit this code action performs.\n  llvm::Optional<WorkspaceEdit> edit;\n\n  /// A command this code action executes. If a code action provides an edit\n  /// and a command, first the edit is executed and then the command.\n  llvm::Optional<Command> command;\n};\nllvm::json::Value toJSON(const CodeAction &);\n\n/// Represents programming constructs like variables, classes, interfaces etc.\n/// that appear in a document. Document symbols can be hierarchical and they\n/// have two ranges: one that encloses its definition and one that points to its\n/// most interesting range, e.g. the range of an identifier.\nstruct DocumentSymbol {\n  /// The name of this symbol.\n  std::string name;\n\n  /// More detail for this symbol, e.g the signature of a function.\n  std::string detail;\n\n  /// The kind of this symbol.\n  SymbolKind kind;\n\n  /// Indicates if this symbol is deprecated.\n  bool deprecated = false;\n\n  /// The range enclosing this symbol not including leading/trailing whitespace\n  /// but everything else like comments. This information is typically used to\n  /// determine if the clients cursor is inside the symbol to reveal in the\n  /// symbol in the UI.\n  Range range;\n\n  /// The range that should be selected and revealed when this symbol is being\n  /// picked, e.g the name of a function. Must be contained by the `range`.\n  Range selectionRange;\n\n  /// Children of this symbol, e.g. properties of a class.\n  std::vector<DocumentSymbol> children;\n};\nllvm::raw_ostream &operator<<(llvm::raw_ostream &O, const DocumentSymbol &S);\nllvm::json::Value toJSON(const DocumentSymbol &S);\n\n/// Represents information about programming constructs like variables, classes,\n/// interfaces etc.\nstruct SymbolInformation {\n  /// The name of this symbol.\n  std::string name;\n\n  /// The kind of this symbol.\n  SymbolKind kind;\n\n  /// The location of this symbol.\n  Location location;\n\n  /// The name of the symbol containing this symbol.\n  std::string containerName;\n\n  /// The score that clangd calculates to rank the returned symbols.\n  /// This excludes the fuzzy-matching score between `name` and the query.\n  /// (Specifically, the last ::-separated component).\n  /// This can be used to re-rank results as the user types, using client-side\n  /// fuzzy-matching (that score should be multiplied with this one).\n  /// This is a clangd extension, set only for workspace/symbol responses.\n  llvm::Optional<float> score;\n};\nllvm::json::Value toJSON(const SymbolInformation &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const SymbolInformation &);\n\n/// Represents information about identifier.\n/// This is returned from textDocument/symbolInfo, which is a clangd extension.\nstruct SymbolDetails {\n  std::string name;\n\n  std::string containerName;\n\n  /// Unified Symbol Resolution identifier\n  /// This is an opaque string uniquely identifying a symbol.\n  /// Unlike SymbolID, it is variable-length and somewhat human-readable.\n  /// It is a common representation across several clang tools.\n  /// (See USRGeneration.h)\n  std::string USR;\n\n  SymbolID ID;\n};\nllvm::json::Value toJSON(const SymbolDetails &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const SymbolDetails &);\nbool operator==(const SymbolDetails &, const SymbolDetails &);\n\n/// The parameters of a Workspace Symbol Request.\nstruct WorkspaceSymbolParams {\n  /// A non-empty query string\n  std::string query;\n};\nbool fromJSON(const llvm::json::Value &, WorkspaceSymbolParams &,\n              llvm::json::Path);\n\nstruct ApplyWorkspaceEditParams {\n  WorkspaceEdit edit;\n};\nllvm::json::Value toJSON(const ApplyWorkspaceEditParams &);\n\nstruct ApplyWorkspaceEditResponse {\n  bool applied = true;\n  llvm::Optional<std::string> failureReason;\n};\nbool fromJSON(const llvm::json::Value &, ApplyWorkspaceEditResponse &,\n              llvm::json::Path);\n\nstruct TextDocumentPositionParams {\n  /// The text document.\n  TextDocumentIdentifier textDocument;\n\n  /// The position inside the text document.\n  Position position;\n};\nbool fromJSON(const llvm::json::Value &, TextDocumentPositionParams &,\n              llvm::json::Path);\n\nenum class CompletionTriggerKind {\n  /// Completion was triggered by typing an identifier (24x7 code\n  /// complete), manual invocation (e.g Ctrl+Space) or via API.\n  Invoked = 1,\n  /// Completion was triggered by a trigger character specified by\n  /// the `triggerCharacters` properties of the `CompletionRegistrationOptions`.\n  TriggerCharacter = 2,\n  /// Completion was re-triggered as the current completion list is incomplete.\n  TriggerTriggerForIncompleteCompletions = 3\n};\n\nstruct CompletionContext {\n  /// How the completion was triggered.\n  CompletionTriggerKind triggerKind = CompletionTriggerKind::Invoked;\n  /// The trigger character (a single character) that has trigger code complete.\n  /// Is undefined if `triggerKind !== CompletionTriggerKind.TriggerCharacter`\n  std::string triggerCharacter;\n};\nbool fromJSON(const llvm::json::Value &, CompletionContext &, llvm::json::Path);\n\nstruct CompletionParams : TextDocumentPositionParams {\n  CompletionContext context;\n};\nbool fromJSON(const llvm::json::Value &, CompletionParams &, llvm::json::Path);\n\nstruct MarkupContent {\n  MarkupKind kind = MarkupKind::PlainText;\n  std::string value;\n};\nllvm::json::Value toJSON(const MarkupContent &MC);\n\nstruct Hover {\n  /// The hover's content\n  MarkupContent contents;\n\n  /// An optional range is a range inside a text document\n  /// that is used to visualize a hover, e.g. by changing the background color.\n  llvm::Optional<Range> range;\n};\nllvm::json::Value toJSON(const Hover &H);\n\n/// Defines whether the insert text in a completion item should be interpreted\n/// as plain text or a snippet.\nenum class InsertTextFormat {\n  Missing = 0,\n  /// The primary text to be inserted is treated as a plain string.\n  PlainText = 1,\n  /// The primary text to be inserted is treated as a snippet.\n  ///\n  /// A snippet can define tab stops and placeholders with `$1`, `$2`\n  /// and `${3:foo}`. `$0` defines the final tab stop, it defaults to the end\n  /// of the snippet. Placeholders with equal identifiers are linked, that is\n  /// typing in one will update others too.\n  ///\n  /// See also:\n  /// https//github.com/Microsoft/vscode/blob/master/src/vs/editor/contrib/snippet/common/snippet.md\n  Snippet = 2,\n};\n\nstruct CompletionItem {\n  /// The label of this completion item. By default also the text that is\n  /// inserted when selecting this completion.\n  std::string label;\n\n  /// The kind of this completion item. Based of the kind an icon is chosen by\n  /// the editor.\n  CompletionItemKind kind = CompletionItemKind::Missing;\n\n  /// A human-readable string with additional information about this item, like\n  /// type or symbol information.\n  std::string detail;\n\n  /// A human-readable string that represents a doc-comment.\n  llvm::Optional<MarkupContent> documentation;\n\n  /// A string that should be used when comparing this item with other items.\n  /// When `falsy` the label is used.\n  std::string sortText;\n\n  /// A string that should be used when filtering a set of completion items.\n  /// When `falsy` the label is used.\n  std::string filterText;\n\n  /// A string that should be inserted to a document when selecting this\n  /// completion. When `falsy` the label is used.\n  std::string insertText;\n\n  /// The format of the insert text. The format applies to both the `insertText`\n  /// property and the `newText` property of a provided `textEdit`.\n  InsertTextFormat insertTextFormat = InsertTextFormat::Missing;\n\n  /// An edit which is applied to a document when selecting this completion.\n  /// When an edit is provided `insertText` is ignored.\n  ///\n  /// Note: The range of the edit must be a single line range and it must\n  /// contain the position at which completion has been requested.\n  llvm::Optional<TextEdit> textEdit;\n\n  /// An optional array of additional text edits that are applied when selecting\n  /// this completion. Edits must not overlap with the main edit nor with\n  /// themselves.\n  std::vector<TextEdit> additionalTextEdits;\n\n  /// Indicates if this item is deprecated.\n  bool deprecated = false;\n\n  /// The score that clangd calculates to rank the returned completions.\n  /// This excludes the fuzzy-match between `filterText` and the partial word.\n  /// This can be used to re-rank results as the user types, using client-side\n  /// fuzzy-matching (that score should be multiplied with this one).\n  /// This is a clangd extension.\n  float score = 0.f;\n\n  // TODO: Add custom commitCharacters for some of the completion items. For\n  // example, it makes sense to use () only for the functions.\n  // TODO(krasimir): The following optional fields defined by the language\n  // server protocol are unsupported:\n  //\n  // data?: any - A data entry field that is preserved on a completion item\n  //              between a completion and a completion resolve request.\n};\nllvm::json::Value toJSON(const CompletionItem &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const CompletionItem &);\n\nbool operator<(const CompletionItem &, const CompletionItem &);\n\n/// Represents a collection of completion items to be presented in the editor.\nstruct CompletionList {\n  /// The list is not complete. Further typing should result in recomputing the\n  /// list.\n  bool isIncomplete = false;\n\n  /// The completion items.\n  std::vector<CompletionItem> items;\n};\nllvm::json::Value toJSON(const CompletionList &);\n\n/// A single parameter of a particular signature.\nstruct ParameterInformation {\n\n  /// The label of this parameter. Ignored when labelOffsets is set.\n  std::string labelString;\n\n  /// Inclusive start and exclusive end offsets withing the containing signature\n  /// label.\n  /// Offsets are computed by lspLength(), which counts UTF-16 code units by\n  /// default but that can be overriden, see its documentation for details.\n  llvm::Optional<std::pair<unsigned, unsigned>> labelOffsets;\n\n  /// The documentation of this parameter. Optional.\n  std::string documentation;\n};\nllvm::json::Value toJSON(const ParameterInformation &);\n\n/// Represents the signature of something callable.\nstruct SignatureInformation {\n\n  /// The label of this signature. Mandatory.\n  std::string label;\n\n  /// The documentation of this signature. Optional.\n  std::string documentation;\n\n  /// The parameters of this signature.\n  std::vector<ParameterInformation> parameters;\n};\nllvm::json::Value toJSON(const SignatureInformation &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &,\n                              const SignatureInformation &);\n\n/// Represents the signature of a callable.\nstruct SignatureHelp {\n\n  /// The resulting signatures.\n  std::vector<SignatureInformation> signatures;\n\n  /// The active signature.\n  int activeSignature = 0;\n\n  /// The active parameter of the active signature.\n  int activeParameter = 0;\n\n  /// Position of the start of the argument list, including opening paren. e.g.\n  /// foo(\"first arg\",   \"second arg\",\n  ///    ^-argListStart   ^-cursor\n  /// This is a clangd-specific extension, it is only available via C++ API and\n  /// not currently serialized for the LSP.\n  Position argListStart;\n};\nllvm::json::Value toJSON(const SignatureHelp &);\n\nstruct RenameParams {\n  /// The document that was opened.\n  TextDocumentIdentifier textDocument;\n\n  /// The position at which this request was sent.\n  Position position;\n\n  /// The new name of the symbol.\n  std::string newName;\n};\nbool fromJSON(const llvm::json::Value &, RenameParams &, llvm::json::Path);\n\nenum class DocumentHighlightKind { Text = 1, Read = 2, Write = 3 };\n\n/// A document highlight is a range inside a text document which deserves\n/// special attention. Usually a document highlight is visualized by changing\n/// the background color of its range.\n\nstruct DocumentHighlight {\n  /// The range this highlight applies to.\n  Range range;\n\n  /// The highlight kind, default is DocumentHighlightKind.Text.\n  DocumentHighlightKind kind = DocumentHighlightKind::Text;\n\n  friend bool operator<(const DocumentHighlight &LHS,\n                        const DocumentHighlight &RHS) {\n    int LHSKind = static_cast<int>(LHS.kind);\n    int RHSKind = static_cast<int>(RHS.kind);\n    return std::tie(LHS.range, LHSKind) < std::tie(RHS.range, RHSKind);\n  }\n\n  friend bool operator==(const DocumentHighlight &LHS,\n                         const DocumentHighlight &RHS) {\n    return LHS.kind == RHS.kind && LHS.range == RHS.range;\n  }\n};\nllvm::json::Value toJSON(const DocumentHighlight &DH);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const DocumentHighlight &);\n\nenum class TypeHierarchyDirection { Children = 0, Parents = 1, Both = 2 };\nbool fromJSON(const llvm::json::Value &E, TypeHierarchyDirection &Out,\n              llvm::json::Path);\n\n/// The type hierarchy params is an extension of the\n/// `TextDocumentPositionsParams` with optional properties which can be used to\n/// eagerly resolve the item when requesting from the server.\nstruct TypeHierarchyParams : public TextDocumentPositionParams {\n  /// The hierarchy levels to resolve. `0` indicates no level.\n  int resolve = 0;\n\n  /// The direction of the hierarchy levels to resolve.\n  TypeHierarchyDirection direction = TypeHierarchyDirection::Parents;\n};\nbool fromJSON(const llvm::json::Value &, TypeHierarchyParams &,\n              llvm::json::Path);\n\nstruct TypeHierarchyItem {\n  /// The human readable name of the hierarchy item.\n  std::string name;\n\n  /// Optional detail for the hierarchy item. It can be, for instance, the\n  /// signature of a function or method.\n  llvm::Optional<std::string> detail;\n\n  /// The kind of the hierarchy item. For instance, class or interface.\n  SymbolKind kind;\n\n  /// `true` if the hierarchy item is deprecated. Otherwise, `false`.\n  bool deprecated = false;\n\n  /// The URI of the text document where this type hierarchy item belongs to.\n  URIForFile uri;\n\n  /// The range enclosing this type hierarchy item not including\n  /// leading/trailing whitespace but everything else like comments. This\n  /// information is typically used to determine if the client's cursor is\n  /// inside the type hierarch item to reveal in the symbol in the UI.\n  Range range;\n\n  /// The range that should be selected and revealed when this type hierarchy\n  /// item is being picked, e.g. the name of a function. Must be contained by\n  /// the `range`.\n  Range selectionRange;\n\n  /// If this type hierarchy item is resolved, it contains the direct parents.\n  /// Could be empty if the item does not have direct parents. If not defined,\n  /// the parents have not been resolved yet.\n  llvm::Optional<std::vector<TypeHierarchyItem>> parents;\n\n  /// If this type hierarchy item is resolved, it contains the direct children\n  /// of the current item. Could be empty if the item does not have any\n  /// descendants. If not defined, the children have not been resolved.\n  llvm::Optional<std::vector<TypeHierarchyItem>> children;\n\n  /// An optional 'data' field, which can be used to identify a type hierarchy\n  /// item in a resolve request.\n  llvm::Optional<std::string> data;\n};\nllvm::json::Value toJSON(const TypeHierarchyItem &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const TypeHierarchyItem &);\nbool fromJSON(const llvm::json::Value &, TypeHierarchyItem &, llvm::json::Path);\n\n/// Parameters for the `typeHierarchy/resolve` request.\nstruct ResolveTypeHierarchyItemParams {\n  /// The item to resolve.\n  TypeHierarchyItem item;\n\n  /// The hierarchy levels to resolve. `0` indicates no level.\n  int resolve;\n\n  /// The direction of the hierarchy levels to resolve.\n  TypeHierarchyDirection direction;\n};\nbool fromJSON(const llvm::json::Value &, ResolveTypeHierarchyItemParams &,\n              llvm::json::Path);\n\nenum class SymbolTag { Deprecated = 1 };\nllvm::json::Value toJSON(SymbolTag);\n\n/// The parameter of a `textDocument/prepareCallHierarchy` request.\nstruct CallHierarchyPrepareParams : public TextDocumentPositionParams {};\n\n/// Represents programming constructs like functions or constructors\n/// in the context of call hierarchy.\nstruct CallHierarchyItem {\n  /// The name of this item.\n  std::string name;\n\n  /// The kind of this item.\n  SymbolKind kind;\n\n  /// Tags for this item.\n  std::vector<SymbolTag> tags;\n\n  /// More detaill for this item, e.g. the signature of a function.\n  std::string detail;\n\n  /// The resource identifier of this item.\n  URIForFile uri;\n\n  /// The range enclosing this symbol not including leading / trailing\n  /// whitespace but everything else, e.g. comments and code.\n  Range range;\n\n  /// The range that should be selected and revealed when this symbol\n  /// is being picked, e.g. the name of a function.\n  /// Must be contained by `Rng`.\n  Range selectionRange;\n\n  /// An optional 'data' field, which can be used to identify a call\n  /// hierarchy item in an incomingCalls or outgoingCalls request.\n  std::string data;\n};\nllvm::json::Value toJSON(const CallHierarchyItem &);\nbool fromJSON(const llvm::json::Value &, CallHierarchyItem &, llvm::json::Path);\n\n/// The parameter of a `callHierarchy/incomingCalls` request.\nstruct CallHierarchyIncomingCallsParams {\n  CallHierarchyItem item;\n};\nbool fromJSON(const llvm::json::Value &, CallHierarchyIncomingCallsParams &,\n              llvm::json::Path);\n\n/// Represents an incoming call, e.g. a caller of a method or constructor.\nstruct CallHierarchyIncomingCall {\n  /// The item that makes the call.\n  CallHierarchyItem from;\n\n  /// The range at which the calls appear.\n  /// This is relative to the caller denoted by `From`.\n  std::vector<Range> fromRanges;\n};\nllvm::json::Value toJSON(const CallHierarchyIncomingCall &);\n\n/// The parameter of a `callHierarchy/outgoingCalls` request.\nstruct CallHierarchyOutgoingCallsParams {\n  CallHierarchyItem item;\n};\nbool fromJSON(const llvm::json::Value &, CallHierarchyOutgoingCallsParams &,\n              llvm::json::Path);\n\n/// Represents an outgoing call, e.g. calling a getter from a method or\n/// a method from a constructor etc.\nstruct CallHierarchyOutgoingCall {\n  /// The item that is called.\n  CallHierarchyItem to;\n\n  /// The range at which this item is called.\n  /// This is the range relative to the caller, and not `To`.\n  std::vector<Range> fromRanges;\n};\nllvm::json::Value toJSON(const CallHierarchyOutgoingCall &);\n\nstruct ReferenceContext {\n  /// Include the declaration of the current symbol.\n  bool includeDeclaration = false;\n};\n\nstruct ReferenceParams : public TextDocumentPositionParams {\n  ReferenceContext context;\n};\nbool fromJSON(const llvm::json::Value &, ReferenceParams &, llvm::json::Path);\n\n/// Clangd extension: indicates the current state of the file in clangd,\n/// sent from server via the `textDocument/clangd.fileStatus` notification.\nstruct FileStatus {\n  /// The text document's URI.\n  URIForFile uri;\n  /// The human-readable string presents the current state of the file, can be\n  /// shown in the UI (e.g. status bar).\n  std::string state;\n  // FIXME: add detail messages.\n};\nllvm::json::Value toJSON(const FileStatus &);\n\n/// Specifies a single semantic token in the document.\n/// This struct is not part of LSP, which just encodes lists of tokens as\n/// arrays of numbers directly.\nstruct SemanticToken {\n  /// token line number, relative to the previous token\n  unsigned deltaLine = 0;\n  /// token start character, relative to the previous token\n  /// (relative to 0 or the previous token's start if they are on the same line)\n  unsigned deltaStart = 0;\n  /// the length of the token. A token cannot be multiline\n  unsigned length = 0;\n  /// will be looked up in `SemanticTokensLegend.tokenTypes`\n  unsigned tokenType = 0;\n  /// each set bit will be looked up in `SemanticTokensLegend.tokenModifiers`\n  unsigned tokenModifiers = 0;\n};\nbool operator==(const SemanticToken &, const SemanticToken &);\n\n/// A versioned set of tokens.\nstruct SemanticTokens {\n  // An optional result id. If provided and clients support delta updating\n  // the client will include the result id in the next semantic token request.\n  // A server can then instead of computing all semantic tokens again simply\n  // send a delta.\n  std::string resultId;\n\n  /// The actual tokens.\n  std::vector<SemanticToken> tokens; // encoded as a flat integer array.\n};\nllvm::json::Value toJSON(const SemanticTokens &);\n\n/// Body of textDocument/semanticTokens/full request.\nstruct SemanticTokensParams {\n  /// The text document.\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, SemanticTokensParams &,\n              llvm::json::Path);\n\n/// Body of textDocument/semanticTokens/full/delta request.\n/// Requests the changes in semantic tokens since a previous response.\nstruct SemanticTokensDeltaParams {\n  /// The text document.\n  TextDocumentIdentifier textDocument;\n  /// The previous result id.\n  std::string previousResultId;\n};\nbool fromJSON(const llvm::json::Value &Params, SemanticTokensDeltaParams &R,\n              llvm::json::Path);\n\n/// Describes a a replacement of a contiguous range of semanticTokens.\nstruct SemanticTokensEdit {\n  // LSP specifies `start` and `deleteCount` which are relative to the array\n  // encoding of the previous tokens.\n  // We use token counts instead, and translate when serializing this struct.\n  unsigned startToken = 0;\n  unsigned deleteTokens = 0;\n  std::vector<SemanticToken> tokens; // encoded as a flat integer array\n};\nllvm::json::Value toJSON(const SemanticTokensEdit &);\n\n/// This models LSP SemanticTokensDelta | SemanticTokens, which is the result of\n/// textDocument/semanticTokens/full/delta.\nstruct SemanticTokensOrDelta {\n  std::string resultId;\n  /// Set if we computed edits relative to a previous set of tokens.\n  llvm::Optional<std::vector<SemanticTokensEdit>> edits;\n  /// Set if we computed a fresh set of tokens.\n  llvm::Optional<std::vector<SemanticToken>> tokens; // encoded as integer array\n};\nllvm::json::Value toJSON(const SemanticTokensOrDelta &);\n\nstruct SelectionRangeParams {\n  /// The text document.\n  TextDocumentIdentifier textDocument;\n\n  /// The positions inside the text document.\n  std::vector<Position> positions;\n};\nbool fromJSON(const llvm::json::Value &, SelectionRangeParams &,\n              llvm::json::Path);\n\nstruct SelectionRange {\n  /**\n   * The range of this selection range.\n   */\n  Range range;\n  /**\n   * The parent selection range containing this range. Therefore `parent.range`\n   * must contain `this.range`.\n   */\n  std::unique_ptr<SelectionRange> parent;\n};\nllvm::json::Value toJSON(const SelectionRange &);\n\n/// Parameters for the document link request.\nstruct DocumentLinkParams {\n  /// The document to provide document links for.\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, DocumentLinkParams &,\n              llvm::json::Path);\n\n/// A range in a text document that links to an internal or external resource,\n/// like another text document or a web site.\nstruct DocumentLink {\n  /// The range this link applies to.\n  Range range;\n\n  /// The uri this link points to. If missing a resolve request is sent later.\n  URIForFile target;\n\n  // TODO(forster): The following optional fields defined by the language\n  // server protocol are unsupported:\n  //\n  // data?: any - A data entry field that is preserved on a document link\n  //              between a DocumentLinkRequest and a\n  //              DocumentLinkResolveRequest.\n\n  friend bool operator==(const DocumentLink &LHS, const DocumentLink &RHS) {\n    return LHS.range == RHS.range && LHS.target == RHS.target;\n  }\n\n  friend bool operator!=(const DocumentLink &LHS, const DocumentLink &RHS) {\n    return !(LHS == RHS);\n  }\n};\nllvm::json::Value toJSON(const DocumentLink &DocumentLink);\n\n// FIXME(kirillbobyrev): Add FoldingRangeClientCapabilities so we can support\n// per-line-folding editors.\nstruct FoldingRangeParams {\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, FoldingRangeParams &,\n              llvm::json::Path);\n\n/// Stores information about a region of code that can be folded.\nstruct FoldingRange {\n  unsigned startLine = 0;\n  unsigned startCharacter;\n  unsigned endLine = 0;\n  unsigned endCharacter;\n  llvm::Optional<std::string> kind;\n};\nllvm::json::Value toJSON(const FoldingRange &Range);\n\n/// Keys starting with an underscore(_) represent leaves, e.g. _total or _self\n/// for memory usage of whole subtree or only that specific node in bytes. All\n/// other keys represents children. An example:\n///   {\n///     \"_self\": 0,\n///     \"_total\": 8,\n///     \"child1\": {\n///       \"_self\": 4,\n///       \"_total\": 4,\n///     }\n///     \"child2\": {\n///       \"_self\": 2,\n///       \"_total\": 4,\n///       \"child_deep\": {\n///         \"_self\": 2,\n///         \"_total\": 2,\n///       }\n///     }\n///   }\nllvm::json::Value toJSON(const MemoryTree &MT);\n\n/// Payload for textDocument/ast request.\n/// This request is a clangd extension.\nstruct ASTParams {\n  /// The text document.\n  TextDocumentIdentifier textDocument;\n\n  /// The position of the node to be dumped.\n  /// The highest-level node that entirely contains the range will be returned.\n  Range range;\n};\nbool fromJSON(const llvm::json::Value &, ASTParams &, llvm::json::Path);\n\n/// Simplified description of a clang AST node.\n/// This is clangd's internal representation of C++ code.\nstruct ASTNode {\n  /// The general kind of node, such as \"expression\"\n  /// Corresponds to the base AST node type such as Expr.\n  std::string role;\n  /// The specific kind of node this is, such as \"BinaryOperator\".\n  /// This is usually a concrete node class (with Expr etc suffix dropped).\n  /// When there's no hierarchy (e.g. TemplateName), the variant (NameKind).\n  std::string kind;\n  /// Brief additional information, such as \"||\" for the particular operator.\n  /// The information included depends on the node kind, and may be empty.\n  std::string detail;\n  /// A one-line dump of detailed information about the node.\n  /// This includes role/kind/description information, but is rather cryptic.\n  /// It is similar to the output from `clang -Xclang -ast-dump`.\n  /// May be empty for certain types of nodes.\n  std::string arcana;\n  /// The range of the original source file covered by this node.\n  /// May be missing for implicit nodes, or those created by macro expansion.\n  llvm::Optional<Range> range;\n  /// Nodes nested within this one, such as the operands of a BinaryOperator.\n  std::vector<ASTNode> children;\n};\nllvm::json::Value toJSON(const ASTNode &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const ASTNode &);\n\n} // namespace clangd\n} // namespace clang\n\nnamespace llvm {\ntemplate <> struct format_provider<clang::clangd::Position> {\n  static void format(const clang::clangd::Position &Pos, raw_ostream &OS,\n                     StringRef Style) {\n    assert(Style.empty() && \"style modifiers for this type are not supported\");\n    OS << Pos;\n  }\n};\n} // namespace llvm\n\n#endif\n"}, "11": {"id": 11, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Selection.h", "content": "//===--- Selection.h - What's under the cursor? -------------------*-C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n// Many features are triggered at locations/ranges and operate on AST nodes.\n// (e.g. go-to-definition or code tweaks).\n// At a high level, such features need to work out which node is the correct\n// target.\n//\n// There are a few levels of ambiguity here:\n//\n// Which tokens are included:\n//   int x = one + two;  // what should \"go to definition\" do?\n//            ^^^^^^\n//\n// Same token means multiple things:\n//   string(\"foo\")       // class string, or a constructor?\n//   ^\n//\n// Which level of the AST is interesting?\n//   if (err) {          // reference to 'err', or operator bool(),\n//       ^               // or the if statement itself?\n//\n// Here we build and expose a data structure that allows features to resolve\n// these ambiguities in an appropriate way:\n//   - we determine which low-level nodes are partly or completely covered\n//     by the selection.\n//   - we expose a tree of the selected nodes and their lexical parents.\n//\n// Sadly LSP specifies locations as being between characters, and this causes\n// some ambiguities we cannot cleanly resolve:\n//   lhs+rhs  // targeting '+' or 'lhs'?\n//      ^     // in GUI editors, double-clicking 'lhs' yields this position!\n//\n// The best we can do in these cases is try both, which leads to the awkward\n// SelectionTree::createEach() API.\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_SELECTION_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_SELECTION_H\n#include \"clang/AST/ASTTypeTraits.h\"\n#include \"clang/AST/PrettyPrinter.h\"\n#include \"clang/Tooling/Syntax/Tokens.h\"\n#include \"llvm/ADT/SmallVector.h\"\n\nnamespace clang {\nnamespace clangd {\n\n// A selection can partially or completely cover several AST nodes.\n// The SelectionTree contains nodes that are covered, and their parents.\n// SelectionTree does not contain all AST nodes, rather only:\n//   Decl, Stmt, TypeLoc, NestedNamespaceSpecifierLoc, CXXCtorInitializer.\n// (These are the nodes with source ranges that fit in DynTypedNode).\n//\n// Usually commonAncestor() is the place to start:\n//  - it's the simplest answer to \"what node is under the cursor\"\n//  - the selected Expr (for example) can be found by walking up the parent\n//    chain and checking Node->ASTNode.\n//  - if you want to traverse the selected nodes, they are all under\n//    commonAncestor() in the tree.\n//\n// SelectionTree tries to behave sensibly in the presence of macros, but does\n// not model any preprocessor concepts: the output is a subset of the AST.\n// When a macro argument is specifically selected, only its first expansion is\n// selected in the AST. (Returning a selection forest is unreasonably difficult\n// for callers to handle correctly.)\n//\n// Comments, directives and whitespace are completely ignored.\n// Semicolons are also ignored, as the AST generally does not model them well.\n//\n// The SelectionTree owns the Node structures, but the ASTNode attributes\n// point back into the AST it was constructed with.\nclass SelectionTree {\npublic:\n  // Create selection trees for the given range, and pass them to Func.\n  //\n  // There may be multiple possible selection trees:\n  // - if the range is empty and borders two tokens, a tree for the right token\n  //   and a tree for the left token will be yielded.\n  // - Func should return true on success (stop) and false on failure (continue)\n  //\n  // Always yields at least one tree. If no tokens are touched, it is empty.\n  static bool createEach(ASTContext &AST, const syntax::TokenBuffer &Tokens,\n                         unsigned Begin, unsigned End,\n                         llvm::function_ref<bool(SelectionTree)> Func);\n\n  // Create a selection tree for the given range.\n  //\n  // Where ambiguous (range is empty and borders two tokens), prefer the token\n  // on the right.\n  static SelectionTree createRight(ASTContext &AST,\n                                   const syntax::TokenBuffer &Tokens,\n                                   unsigned Begin, unsigned End);\n\n  // Copies are no good - contain pointers to other nodes.\n  SelectionTree(const SelectionTree &) = delete;\n  SelectionTree &operator=(const SelectionTree &) = delete;\n  // Moves are OK though - internal storage is pointer-stable when moved.\n  SelectionTree(SelectionTree &&) = default;\n  SelectionTree &operator=(SelectionTree &&) = default;\n\n  // Describes to what extent an AST node is covered by the selection.\n  enum Selection : unsigned char {\n    // The AST node owns no characters covered by the selection.\n    // Note that characters owned by children don't count:\n    //   if (x == 0) scream();\n    //       ^^^^^^\n    // The IfStmt would be Unselected because all the selected characters are\n    // associated with its children.\n    // (Invisible nodes like ImplicitCastExpr are always unselected).\n    Unselected,\n    // The AST node owns selected characters, but is not completely covered.\n    Partial,\n    // The AST node owns characters, and is covered by the selection.\n    Complete,\n  };\n  // An AST node that is implicated in the selection.\n  // (Either selected directly, or some descendant is selected).\n  struct Node {\n    // The parent within the selection tree. nullptr for TranslationUnitDecl.\n    Node *Parent;\n    // Direct children within the selection tree.\n    llvm::SmallVector<const Node *> Children;\n    // The corresponding node from the full AST.\n    DynTypedNode ASTNode;\n    // The extent to which this node is covered by the selection.\n    Selection Selected;\n    // Walk up the AST to get the DeclContext of this Node,\n    // which is not the node itself.\n    const DeclContext &getDeclContext() const;\n    // Printable node kind, like \"CXXRecordDecl\" or \"AutoTypeLoc\".\n    std::string kind() const;\n    // If this node is a wrapper with no syntax (e.g. implicit cast), return\n    // its contents. (If multiple wrappers are present, unwraps all of them).\n    const Node &ignoreImplicit() const;\n    // If this node is inside a wrapper with no syntax (e.g. implicit cast),\n    // return that wrapper. (If multiple are present, unwraps all of them).\n    const Node &outerImplicit() const;\n  };\n  // The most specific common ancestor of all the selected nodes.\n  // Returns nullptr if the common ancestor is the root.\n  // (This is to avoid accidentally traversing the TUDecl and thus preamble).\n  const Node *commonAncestor() const;\n  // The selection node corresponding to TranslationUnitDecl.\n  const Node &root() const { return *Root; }\n\nprivate:\n  // Creates a selection tree for the given range in the main file.\n  // The range includes bytes [Start, End).\n  SelectionTree(ASTContext &AST, const syntax::TokenBuffer &Tokens,\n                unsigned Start, unsigned End);\n\n  std::deque<Node> Nodes; // Stable-pointer storage.\n  const Node *Root;\n  clang::PrintingPolicy PrintPolicy;\n\n  void print(llvm::raw_ostream &OS, const Node &N, int Indent) const;\n  friend llvm::raw_ostream &operator<<(llvm::raw_ostream &OS,\n                                       const SelectionTree &T) {\n    T.print(OS, T.root(), 1);\n    return OS;\n  }\n};\n\n} // namespace clangd\n} // namespace clang\n#endif\n"}, "12": {"id": 12, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/SourceCode.h", "content": "//===--- SourceCode.h - Manipulating source code as strings -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Various code that examines C++ source code without using heavy AST machinery\n// (and often not even the lexer). To be used sparingly!\n//\n//===----------------------------------------------------------------------===//\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_SOURCECODE_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_SOURCECODE_H\n\n#include \"Protocol.h\"\n#include \"support/Context.h\"\n#include \"support/ThreadsafeFS.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Format/Format.h\"\n#include \"clang/Tooling/Core/Replacement.h\"\n#include \"clang/Tooling/Syntax/Tokens.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/StringSet.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/SHA1.h\"\n#include <string>\n\nnamespace clang {\nclass SourceManager;\n\nnamespace clangd {\n\n// We tend to generate digests for source codes in a lot of different places.\n// This represents the type for those digests to prevent us hard coding details\n// of hashing function at every place that needs to store this information.\nusing FileDigest = std::array<uint8_t, 8>;\nFileDigest digest(StringRef Content);\nOptional<FileDigest> digestFile(const SourceManager &SM, FileID FID);\n\n// This context variable controls the behavior of functions in this file\n// that convert between LSP offsets and native clang byte offsets.\n// If not set, defaults to UTF-16 for backwards-compatibility.\nextern Key<OffsetEncoding> kCurrentOffsetEncoding;\n\n// Counts the number of UTF-16 code units needed to represent a string (LSP\n// specifies string lengths in UTF-16 code units).\n// Use of UTF-16 may be overridden by kCurrentOffsetEncoding.\nsize_t lspLength(StringRef Code);\n\n/// Turn a [line, column] pair into an offset in Code.\n///\n/// If P.character exceeds the line length, returns the offset at end-of-line.\n/// (If !AllowColumnsBeyondLineLength, then returns an error instead).\n/// If the line number is out of range, returns an error.\n///\n/// The returned value is in the range [0, Code.size()].\nllvm::Expected<size_t>\npositionToOffset(llvm::StringRef Code, Position P,\n                 bool AllowColumnsBeyondLineLength = true);\n\n/// Turn an offset in Code into a [line, column] pair.\n/// The offset must be in range [0, Code.size()].\nPosition offsetToPosition(llvm::StringRef Code, size_t Offset);\n\n/// Turn a SourceLocation into a [line, column] pair.\n/// FIXME: This should return an error if the location is invalid.\nPosition sourceLocToPosition(const SourceManager &SM, SourceLocation Loc);\n\n/// Return the file location, corresponding to \\p P. Note that one should take\n/// care to avoid comparing the result with expansion locations.\nllvm::Expected<SourceLocation> sourceLocationInMainFile(const SourceManager &SM,\n                                                        Position P);\n\n/// Returns true iff \\p Loc is inside the main file. This function handles\n/// file & macro locations. For macro locations, returns iff the macro is being\n/// expanded inside the main file.\n///\n/// The function is usually used to check whether a declaration is inside the\n/// the main file.\nbool isInsideMainFile(SourceLocation Loc, const SourceManager &SM);\n\n/// Returns the #include location through which IncludedFIle was loaded.\n/// Where SM.getIncludeLoc() returns the location of the *filename*, which may\n/// be in a macro, includeHashLoc() returns the location of the #.\nSourceLocation includeHashLoc(FileID IncludedFile, const SourceManager &SM);\n\n/// Returns true if the token at Loc is spelled in the source code.\n/// This is not the case for:\n///   * symbols formed via macro concatenation, the spelling location will\n///     be \"<scratch space>\"\n///   * symbols controlled and defined by a compile command-line option\n///     `-DName=foo`, the spelling location will be \"<command line>\".\nbool isSpelledInSource(SourceLocation Loc, const SourceManager &SM);\n\n/// Turns a token range into a half-open range and checks its correctness.\n/// The resulting range will have only valid source location on both sides, both\n/// of which are file locations.\n///\n/// File locations always point to a particular offset in a file, i.e. they\n/// never refer to a location inside a macro expansion. Turning locations from\n/// macro expansions into file locations is ambiguous - one can use\n/// SourceManager::{getExpansion|getFile|getSpelling}Loc. This function\n/// calls SourceManager::getFileLoc on both ends of \\p R to do the conversion.\n///\n/// User input (e.g. cursor position) is expressed as a file location, so this\n/// function can be viewed as a way to normalize the ranges used in the clang\n/// AST so that they are comparable with ranges coming from the user input.\nllvm::Optional<SourceRange> toHalfOpenFileRange(const SourceManager &Mgr,\n                                                const LangOptions &LangOpts,\n                                                SourceRange R);\n\n/// Returns true iff all of the following conditions hold:\n///   - start and end locations are valid,\n///   - start and end locations are file locations from the same file\n///     (i.e. expansion locations are not taken into account).\n///   - start offset <= end offset.\n/// FIXME: introduce a type for source range with this invariant.\nbool isValidFileRange(const SourceManager &Mgr, SourceRange R);\n\n/// Returns the source code covered by the source range.\n/// EXPECTS: isValidFileRange(R) == true.\nllvm::StringRef toSourceCode(const SourceManager &SM, SourceRange R);\n\n// Converts a half-open clang source range to an LSP range.\n// Note that clang also uses closed source ranges, which this can't handle!\nRange halfOpenToRange(const SourceManager &SM, CharSourceRange R);\n\n// Converts an offset to a clang line/column (1-based, columns are bytes).\n// The offset must be in range [0, Code.size()].\n// Prefer to use SourceManager if one is available.\nstd::pair<size_t, size_t> offsetToClangLineColumn(llvm::StringRef Code,\n                                                  size_t Offset);\n\n/// From \"a::b::c\", return {\"a::b::\", \"c\"}. Scope is empty if there's no\n/// qualifier.\nstd::pair<llvm::StringRef, llvm::StringRef>\nsplitQualifiedName(llvm::StringRef QName);\n\nTextEdit replacementToEdit(StringRef Code, const tooling::Replacement &R);\n\nstd::vector<TextEdit> replacementsToEdits(StringRef Code,\n                                          const tooling::Replacements &Repls);\n\nTextEdit toTextEdit(const FixItHint &FixIt, const SourceManager &M,\n                    const LangOptions &L);\n\n/// Get the canonical path of \\p F.  This means:\n///\n///   - Absolute path\n///   - Symlinks resolved\n///   - No \".\" or \"..\" component\n///   - No duplicate or trailing directory separator\n///\n/// This function should be used when paths needs to be used outside the\n/// component that generate it, so that paths are normalized as much as\n/// possible.\nllvm::Optional<std::string> getCanonicalPath(const FileEntry *F,\n                                             const SourceManager &SourceMgr);\n\n/// Choose the clang-format style we should apply to a certain file.\n/// This will usually use FS to look for .clang-format directories.\n/// FIXME: should we be caching the .clang-format file search?\n/// This uses format::DefaultFormatStyle and format::DefaultFallbackStyle,\n/// though the latter may have been overridden in main()!\nformat::FormatStyle getFormatStyleForFile(llvm::StringRef File,\n                                          llvm::StringRef Content,\n                                          const ThreadsafeFS &TFS);\n\n/// Cleanup and format the given replacements.\nllvm::Expected<tooling::Replacements>\ncleanupAndFormat(StringRef Code, const tooling::Replacements &Replaces,\n                 const format::FormatStyle &Style);\n\n/// A set of edits generated for a single file. Can verify whether it is safe to\n/// apply these edits to a code block.\nstruct Edit {\n  tooling::Replacements Replacements;\n  std::string InitialCode;\n\n  Edit() = default;\n\n  Edit(llvm::StringRef Code, tooling::Replacements Reps)\n      : Replacements(std::move(Reps)), InitialCode(Code) {}\n\n  /// Returns the file contents after changes are applied.\n  llvm::Expected<std::string> apply() const;\n\n  /// Represents Replacements as TextEdits that are available for use in LSP.\n  std::vector<TextEdit> asTextEdits() const;\n\n  /// Checks whether the Replacements are applicable to given Code.\n  bool canApplyTo(llvm::StringRef Code) const;\n};\n/// A mapping from absolute file path (the one used for accessing the underlying\n/// VFS) to edits.\nusing FileEdits = llvm::StringMap<Edit>;\n\n/// Formats the edits and code around it according to Style. Changes\n/// Replacements to formatted ones if succeeds.\nllvm::Error reformatEdit(Edit &E, const format::FormatStyle &Style);\n\n/// Apply an incremental update to a text document.\nllvm::Error applyChange(std::string &Contents,\n                        const TextDocumentContentChangeEvent &Change);\n\n/// Collects identifiers with counts in the source code.\nllvm::StringMap<unsigned> collectIdentifiers(llvm::StringRef Content,\n                                             const format::FormatStyle &Style);\n\n/// Collects all ranges of the given identifier in the source code.\nstd::vector<Range> collectIdentifierRanges(llvm::StringRef Identifier,\n                                           llvm::StringRef Content,\n                                           const LangOptions &LangOpts);\n\n/// Collects words from the source code.\n/// Unlike collectIdentifiers:\n/// - also finds text in comments:\n/// - splits text into words\n/// - drops stopwords like \"get\" and \"for\"\nllvm::StringSet<> collectWords(llvm::StringRef Content);\n\n// Something that looks like a word in the source code.\n// Could be a \"real\" token that's \"live\" in the AST, a spelled token consumed by\n// the preprocessor, or part of a spelled token (e.g. word in a comment).\nstruct SpelledWord {\n  // (Spelling) location of the start of the word.\n  SourceLocation Location;\n  // The range of the word itself, excluding any quotes.\n  // This is a subrange of the file buffer.\n  llvm::StringRef Text;\n  // Whether this word is likely to refer to an identifier. True if:\n  // - the word is a spelled identifier token\n  // - Text is identifier-like (e.g. \"foo_bar\")\n  // - Text is surrounded by backticks (e.g. Foo in \"// returns `Foo`\")\n  bool LikelyIdentifier = false;\n  // Set if the word is contained in a token spelled in the file.\n  // (This should always be true, but comments aren't retained by TokenBuffer).\n  const syntax::Token *PartOfSpelledToken = nullptr;\n  // Set if the word is exactly a token spelled in the file.\n  const syntax::Token *SpelledToken = nullptr;\n  // Set if the word is a token spelled in the file, and that token survives\n  // preprocessing to emit an expanded token spelled the same way.\n  const syntax::Token *ExpandedToken = nullptr;\n\n  // Find the unique word that contains SpelledLoc or starts/ends there.\n  static llvm::Optional<SpelledWord> touching(SourceLocation SpelledLoc,\n                                              const syntax::TokenBuffer &TB,\n                                              const LangOptions &LangOpts);\n};\n\n/// Return true if the \\p TokenName is in the list of reversed keywords of the\n/// language.\nbool isKeyword(llvm::StringRef TokenName, const LangOptions &LangOpts);\n\n/// Heuristically determine namespaces visible at a point, without parsing Code.\n/// This considers using-directives and enclosing namespace-declarations that\n/// are visible (and not obfuscated) in the file itself (not headers).\n/// Code should be truncated at the point of interest.\n///\n/// The returned vector is always non-empty.\n/// - The first element is the namespace that encloses the point: a declaration\n///   near the point would be within this namespace.\n/// - The elements are the namespaces in scope at the point: an unqualified\n///   lookup would search within these namespaces.\n///\n/// Using directives are resolved against all enclosing scopes, but no other\n/// namespace directives.\n///\n/// example:\n///   using namespace a;\n///   namespace foo {\n///     using namespace b;\n///\n/// visibleNamespaces are {\"foo::\", \"\", \"a::\", \"b::\", \"foo::b::\"}, not \"a::b::\".\nstd::vector<std::string> visibleNamespaces(llvm::StringRef Code,\n                                           const LangOptions &LangOpts);\n\n/// Represents locations that can accept a definition.\nstruct EligibleRegion {\n  /// Namespace that owns all of the EligiblePoints, e.g.\n  /// namespace a{ namespace b {^ void foo();^} }\n  /// It will be \u201ca::b\u201d for both carrot locations.\n  std::string EnclosingNamespace;\n  /// Offsets into the code marking eligible points to insert a function\n  /// definition.\n  std::vector<Position> EligiblePoints;\n};\n\n/// Returns most eligible region to insert a definition for \\p\n/// FullyQualifiedName in the \\p Code.\n/// Pseudo parses \\pCode under the hood to determine namespace decls and\n/// possible insertion points. Choses the region that matches the longest prefix\n/// of \\p FullyQualifiedName. Returns EOF if there are no shared namespaces.\n/// \\p FullyQualifiedName should not contain anonymous namespaces.\nEligibleRegion getEligiblePoints(llvm::StringRef Code,\n                                 llvm::StringRef FullyQualifiedName,\n                                 const LangOptions &LangOpts);\n\nstruct DefinedMacro {\n  llvm::StringRef Name;\n  const MacroInfo *Info;\n  /// Location of the identifier that names the macro.\n  /// Unlike Info->Location, this translates preamble-patch locations to\n  /// main-file locations.\n  SourceLocation NameLoc;\n};\n/// Gets the macro referenced by \\p SpelledTok. It must be a spelled token\n/// aligned to the beginning of an identifier.\nllvm::Optional<DefinedMacro> locateMacroAt(const syntax::Token &SpelledTok,\n                                           Preprocessor &PP);\n\n/// Infers whether this is a header from the FileName and LangOpts (if\n/// presents).\nbool isHeaderFile(llvm::StringRef FileName,\n                  llvm::Optional<LangOptions> LangOpts = llvm::None);\n\n/// Returns true if the given location is in a generated protobuf file.\nbool isProtoFile(SourceLocation Loc, const SourceManager &SourceMgr);\n\n} // namespace clangd\n} // namespace clang\n#endif\n"}, "13": {"id": 13, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/URI.h", "content": "//===--- URI.h - File URIs with schemes --------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_PATHURI_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_PATHURI_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/Registry.h\"\n\nnamespace clang {\nnamespace clangd {\n\n/// A URI describes the location of a source file.\n/// In the simplest case, this is a \"file\" URI that directly encodes the\n/// absolute path to a file. More abstract cases are possible: a shared index\n/// service might expose repo:// URIs that are relative to the source control\n/// root.\n///\n/// Clangd handles URIs of the form <scheme>:[//<authority>]<body>. It doesn't\n/// further split the authority or body into constituent parts (e.g. query\n/// strings is included in the body).\nclass URI {\npublic:\n  URI(llvm::StringRef Scheme, llvm::StringRef Authority, llvm::StringRef Body);\n\n  /// Returns decoded scheme e.g. \"https\"\n  llvm::StringRef scheme() const { return Scheme; }\n  /// Returns decoded authority e.g. \"reviews.lvm.org\"\n  llvm::StringRef authority() const { return Authority; }\n  /// Returns decoded body e.g. \"/D41946\"\n  llvm::StringRef body() const { return Body; }\n\n  /// Returns a string URI with all components percent-encoded.\n  std::string toString() const;\n\n  /// Creates a URI for a file in the given scheme. \\p Scheme must be\n  /// registered. The URI is percent-encoded.\n  static llvm::Expected<URI> create(llvm::StringRef AbsolutePath,\n                                    llvm::StringRef Scheme);\n\n  // Similar to above except this picks a registered scheme that works. If none\n  // works, this falls back to \"file\" scheme.\n  static URI create(llvm::StringRef AbsolutePath);\n\n  /// This creates a file:// URI for \\p AbsolutePath. The path must be absolute.\n  static URI createFile(llvm::StringRef AbsolutePath);\n\n  /// Parse a URI string \"<scheme>:[//<authority>/]<path>\". Percent-encoded\n  /// characters in the URI will be decoded.\n  static llvm::Expected<URI> parse(llvm::StringRef Uri);\n\n  /// Resolves the absolute path of \\p U. If there is no matching scheme, or the\n  /// URI is invalid in the scheme, this returns an error.\n  ///\n  /// \\p HintPath A related path, such as the current file or working directory,\n  /// which can help disambiguate when the same file exists in many workspaces.\n  static llvm::Expected<std::string> resolve(const URI &U,\n                                             llvm::StringRef HintPath = \"\");\n\n  /// Same as above, in addition it parses the \\p FileURI using URI::parse.\n  static llvm::Expected<std::string> resolve(llvm::StringRef FileURI,\n                                             llvm::StringRef HintPath = \"\");\n\n  /// Resolves \\p AbsPath into a canonical path of its URI, by converting\n  /// \\p AbsPath to URI and resolving the URI to get th canonical path.\n  /// This ensures that paths with the same URI are resolved into consistent\n  /// file path.\n  static llvm::Expected<std::string> resolvePath(llvm::StringRef AbsPath,\n                                                 llvm::StringRef HintPath = \"\");\n\n  /// Gets the preferred spelling of this file for #include, if there is one,\n  /// e.g. <system_header.h>, \"path/to/x.h\".\n  ///\n  /// This allows URI schemas to provide their customized include paths.\n  ///\n  /// Returns an empty string if normal include-shortening based on the absolute\n  /// path should be used.\n  /// Fails if the URI is not valid in the schema.\n  static llvm::Expected<std::string> includeSpelling(const URI &U);\n\n  friend bool operator==(const URI &LHS, const URI &RHS) {\n    return std::tie(LHS.Scheme, LHS.Authority, LHS.Body) ==\n           std::tie(RHS.Scheme, RHS.Authority, RHS.Body);\n  }\n\n  friend bool operator<(const URI &LHS, const URI &RHS) {\n    return std::tie(LHS.Scheme, LHS.Authority, LHS.Body) <\n           std::tie(RHS.Scheme, RHS.Authority, RHS.Body);\n  }\n\nprivate:\n  URI() = default;\n\n  std::string Scheme;\n  std::string Authority;\n  std::string Body;\n};\n\n/// URIScheme is an extension point for teaching clangd to recognize a custom\n/// URI scheme. This is expected to be implemented and exposed via the\n/// URISchemeRegistry.\nclass URIScheme {\npublic:\n  virtual ~URIScheme() = default;\n\n  /// Returns the absolute path of the file corresponding to the URI\n  /// authority+body in the file system. See URI::resolve for semantics of\n  /// \\p HintPath.\n  virtual llvm::Expected<std::string>\n  getAbsolutePath(llvm::StringRef Authority, llvm::StringRef Body,\n                  llvm::StringRef HintPath) const = 0;\n\n  virtual llvm::Expected<URI>\n  uriFromAbsolutePath(llvm::StringRef AbsolutePath) const = 0;\n\n  /// Returns the include path of the file (e.g. <path>, \"path\"), which can be\n  /// #included directly. See URI::includeSpelling for details.\n  virtual llvm::Expected<std::string> getIncludeSpelling(const URI &U) const {\n    return \"\"; // no customized include path for this scheme.\n  }\n};\n\n/// By default, a \"file\" scheme is supported where URI paths are always absolute\n/// in the file system.\ntypedef llvm::Registry<URIScheme> URISchemeRegistry;\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_PATHURI_H\n"}, "14": {"id": 14, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Index.h", "content": "//===--- Index.h -------------------------------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_INDEX_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_INDEX_H\n\n#include \"Ref.h\"\n#include \"Relation.h\"\n#include \"Symbol.h\"\n#include \"SymbolID.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/FunctionExtras.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"llvm/Support/JSON.h\"\n#include <mutex>\n#include <string>\n\nnamespace clang {\nnamespace clangd {\n\nstruct FuzzyFindRequest {\n  /// A query string for the fuzzy find. This is matched against symbols'\n  /// un-qualified identifiers and should not contain qualifiers like \"::\".\n  std::string Query;\n  /// If this is non-empty, symbols must be in at least one of the scopes\n  /// (e.g. namespaces) excluding nested scopes. For example, if a scope \"xyz::\"\n  /// is provided, the matched symbols must be defined in namespace xyz but not\n  /// namespace xyz::abc.\n  ///\n  /// The global scope is \"\", a top level scope is \"foo::\", etc.\n  std::vector<std::string> Scopes;\n  /// If set to true, allow symbols from any scope. Scopes explicitly listed\n  /// above will be ranked higher.\n  bool AnyScope = false;\n  /// The number of top candidates to return. The index may choose to\n  /// return more than this, e.g. if it doesn't know which candidates are best.\n  llvm::Optional<uint32_t> Limit;\n  /// If set to true, only symbols for completion support will be considered.\n  bool RestrictForCodeCompletion = false;\n  /// Contextually relevant files (e.g. the file we're code-completing in).\n  /// Paths should be absolute.\n  std::vector<std::string> ProximityPaths;\n  /// Preferred types of symbols. These are raw representation of `OpaqueType`.\n  std::vector<std::string> PreferredTypes;\n\n  bool operator==(const FuzzyFindRequest &Req) const {\n    return std::tie(Query, Scopes, Limit, RestrictForCodeCompletion,\n                    ProximityPaths, PreferredTypes) ==\n           std::tie(Req.Query, Req.Scopes, Req.Limit,\n                    Req.RestrictForCodeCompletion, Req.ProximityPaths,\n                    Req.PreferredTypes);\n  }\n  bool operator!=(const FuzzyFindRequest &Req) const { return !(*this == Req); }\n};\nbool fromJSON(const llvm::json::Value &Value, FuzzyFindRequest &Request,\n              llvm::json::Path);\nllvm::json::Value toJSON(const FuzzyFindRequest &Request);\n\nstruct LookupRequest {\n  llvm::DenseSet<SymbolID> IDs;\n};\n\nstruct RefsRequest {\n  llvm::DenseSet<SymbolID> IDs;\n  RefKind Filter = RefKind::All;\n  /// If set, limit the number of refers returned from the index. The index may\n  /// choose to return less than this, e.g. it tries to avoid returning stale\n  /// results.\n  llvm::Optional<uint32_t> Limit;\n};\n\nstruct RelationsRequest {\n  llvm::DenseSet<SymbolID> Subjects;\n  RelationKind Predicate;\n  /// If set, limit the number of relations returned from the index.\n  llvm::Optional<uint32_t> Limit;\n};\n\n/// Describes what data is covered by an index.\n///\n/// Indexes may contain symbols but not references from a file, etc.\n/// This affects merging: if a staler index contains a reference but a fresher\n/// one does not, we want to trust the fresher index *only* if it actually\n/// includes references in general.\nenum class IndexContents : uint8_t {\n  None = 0,\n  Symbols = 1 << 1,\n  References = 1 << 2,\n  Relations = 1 << 3,\n  All = Symbols | References | Relations\n};\n\ninline constexpr IndexContents operator&(IndexContents L, IndexContents R) {\n  return static_cast<IndexContents>(static_cast<uint8_t>(L) &\n                                    static_cast<uint8_t>(R));\n}\n\ninline constexpr IndexContents operator|(IndexContents L, IndexContents R) {\n  return static_cast<IndexContents>(static_cast<uint8_t>(L) |\n                                    static_cast<uint8_t>(R));\n}\n\n/// Interface for symbol indexes that can be used for searching or\n/// matching symbols among a set of symbols based on names or unique IDs.\nclass SymbolIndex {\npublic:\n  virtual ~SymbolIndex() = default;\n\n  /// Matches symbols in the index fuzzily and applies \\p Callback on\n  /// each matched symbol before returning.\n  /// If returned Symbols are used outside Callback, they must be deep-copied!\n  ///\n  /// Returns true if there may be more results (limited by Req.Limit).\n  virtual bool\n  fuzzyFind(const FuzzyFindRequest &Req,\n            llvm::function_ref<void(const Symbol &)> Callback) const = 0;\n\n  /// Looks up symbols with any of the given symbol IDs and applies \\p Callback\n  /// on each matched symbol.\n  /// The returned symbol must be deep-copied if it's used outside Callback.\n  virtual void\n  lookup(const LookupRequest &Req,\n         llvm::function_ref<void(const Symbol &)> Callback) const = 0;\n\n  /// Finds all occurrences (e.g. references, declarations, definitions) of\n  /// symbols and applies \\p Callback on each result.\n  ///\n  /// Results should be returned in arbitrary order.\n  /// The returned result must be deep-copied if it's used outside Callback.\n  /// FIXME: there's no indication which result references which symbol.\n  ///\n  /// Returns true if there will be more results (limited by Req.Limit);\n  virtual bool refs(const RefsRequest &Req,\n                    llvm::function_ref<void(const Ref &)> Callback) const = 0;\n\n  /// Finds all relations (S, P, O) stored in the index such that S is among\n  /// Req.Subjects and P is Req.Predicate, and invokes \\p Callback for (S, O) in\n  /// each.\n  virtual void relations(\n      const RelationsRequest &Req,\n      llvm::function_ref<void(const SymbolID &Subject, const Symbol &Object)>\n          Callback) const = 0;\n\n  /// Returns function which checks if the specified file was used to build this\n  /// index or not. The function must only be called while the index is alive.\n  virtual llvm::unique_function<IndexContents(llvm::StringRef) const>\n  indexedFiles() const = 0;\n\n  /// Returns estimated size of index (in bytes).\n  virtual size_t estimateMemoryUsage() const = 0;\n};\n\n// Delegating implementation of SymbolIndex whose delegate can be swapped out.\nclass SwapIndex : public SymbolIndex {\npublic:\n  // If an index is not provided, reset() must be called.\n  SwapIndex(std::unique_ptr<SymbolIndex> Index = nullptr)\n      : Index(std::move(Index)) {}\n  void reset(std::unique_ptr<SymbolIndex>);\n\n  // SymbolIndex methods delegate to the current index, which is kept alive\n  // until the call returns (even if reset() is called).\n  bool fuzzyFind(const FuzzyFindRequest &,\n                 llvm::function_ref<void(const Symbol &)>) const override;\n  void lookup(const LookupRequest &,\n              llvm::function_ref<void(const Symbol &)>) const override;\n  bool refs(const RefsRequest &,\n            llvm::function_ref<void(const Ref &)>) const override;\n  void relations(const RelationsRequest &,\n                 llvm::function_ref<void(const SymbolID &, const Symbol &)>)\n      const override;\n\n  llvm::unique_function<IndexContents(llvm::StringRef) const>\n  indexedFiles() const override;\n\n  size_t estimateMemoryUsage() const override;\n\nprivate:\n  std::shared_ptr<SymbolIndex> snapshot() const;\n  mutable std::mutex Mutex;\n  std::shared_ptr<SymbolIndex> Index;\n};\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_INDEX_H\n"}, "15": {"id": 15, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Ref.h", "content": "//===--- Ref.h ---------------------------------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_REF_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_REF_H\n\n#include \"SymbolID.h\"\n#include \"SymbolLocation.h\"\n#include \"clang/Index/IndexSymbol.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/Hashing.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/StringSaver.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cstdint>\n#include <set>\n#include <utility>\n\nnamespace clang {\nnamespace clangd {\n\n/// Describes the kind of a cross-reference.\n///\n/// This is a bitfield which can be combined from different kinds.\nenum class RefKind : uint8_t {\n  Unknown = 0,\n  // Points to symbol declaration. Example:\n  //\n  // class Foo;\n  //       ^ Foo declaration\n  // Foo foo;\n  // ^ this does not reference Foo declaration\n  Declaration = 1 << 0,\n  // Points to symbol definition. Example:\n  //\n  // int foo();\n  //     ^ references foo declaration, but not foo definition\n  // int foo() { return 42; }\n  //     ^ references foo definition, but not declaration\n  // bool bar() { return true; }\n  //      ^ references both definition and declaration\n  Definition = 1 << 1,\n  // Points to symbol reference. Example:\n  //\n  // int Foo = 42;\n  // int Bar = Foo + 1;\n  //           ^ this is a reference to Foo\n  Reference = 1 << 2,\n  // The reference explicitly spells out declaration's name. Such references can\n  // not come from macro expansions or implicit AST nodes.\n  //\n  // class Foo { public: Foo() {} };\n  //       ^ references declaration, definition and explicitly spells out name\n  // #define MACRO Foo\n  //     v there is an implicit constructor call here which is not a spelled ref\n  // Foo foo;\n  // ^ this reference explicitly spells out Foo's name\n  // struct Bar {\n  //   MACRO Internal;\n  //   ^ this references Foo, but does not explicitly spell out its name\n  // };\n  Spelled = 1 << 3,\n  All = Declaration | Definition | Reference | Spelled,\n};\n\ninline RefKind operator|(RefKind L, RefKind R) {\n  return static_cast<RefKind>(static_cast<uint8_t>(L) |\n                              static_cast<uint8_t>(R));\n}\ninline RefKind &operator|=(RefKind &L, RefKind R) { return L = L | R; }\ninline RefKind operator&(RefKind A, RefKind B) {\n  return static_cast<RefKind>(static_cast<uint8_t>(A) &\n                              static_cast<uint8_t>(B));\n}\n\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, RefKind);\n\n/// Represents a symbol occurrence in the source file.\n/// Despite the name, it could be a declaration/definition/reference.\n///\n/// WARNING: Location does not own the underlying data - Copies are shallow.\nstruct Ref {\n  /// The source location where the symbol is named.\n  SymbolLocation Location;\n  RefKind Kind = RefKind::Unknown;\n  /// The ID of the symbol whose definition contains this reference.\n  /// For example, for a reference inside a function body, this would\n  /// be that function. For top-level definitions this isNull().\n  SymbolID Container;\n};\n\ninline bool operator<(const Ref &L, const Ref &R) {\n  return std::tie(L.Location, L.Kind, L.Container) <\n         std::tie(R.Location, R.Kind, R.Container);\n}\ninline bool operator==(const Ref &L, const Ref &R) {\n  return std::tie(L.Location, L.Kind, L.Container) ==\n         std::tie(R.Location, R.Kind, R.Container);\n}\n\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const Ref &);\n\n/// An efficient structure of storing large set of symbol references in memory.\n/// Filenames are deduplicated.\nclass RefSlab {\npublic:\n  // Refs are stored in order.\n  using value_type = std::pair<SymbolID, llvm::ArrayRef<Ref>>;\n  using const_iterator = std::vector<value_type>::const_iterator;\n  using iterator = const_iterator;\n\n  RefSlab() = default;\n  RefSlab(RefSlab &&Slab) = default;\n  RefSlab &operator=(RefSlab &&RHS) = default;\n\n  const_iterator begin() const { return Refs.begin(); }\n  const_iterator end() const { return Refs.end(); }\n  /// Gets the number of symbols.\n  size_t size() const { return Refs.size(); }\n  size_t numRefs() const { return NumRefs; }\n  bool empty() const { return Refs.empty(); }\n\n  size_t bytes() const {\n    return sizeof(*this) + Arena.getTotalMemory() +\n           sizeof(value_type) * Refs.capacity();\n  }\n\n  /// RefSlab::Builder is a mutable container that can 'freeze' to RefSlab.\n  class Builder {\n  public:\n    Builder() : UniqueStrings(Arena) {}\n    /// Adds a ref to the slab. Deep copy: Strings will be owned by the slab.\n    void insert(const SymbolID &ID, const Ref &S);\n    /// Consumes the builder to finalize the slab.\n    RefSlab build() &&;\n\n  private:\n    // A ref we're storing with its symbol to consume with build().\n    // All strings are interned, so DenseMapInfo can use pointer comparisons.\n    struct Entry {\n      SymbolID Symbol;\n      Ref Reference;\n    };\n    friend struct llvm::DenseMapInfo<Entry>;\n\n    llvm::BumpPtrAllocator Arena;\n    llvm::UniqueStringSaver UniqueStrings; // Contents on the arena.\n    llvm::DenseSet<Entry> Entries;\n  };\n\nprivate:\n  RefSlab(std::vector<value_type> Refs, llvm::BumpPtrAllocator Arena,\n          size_t NumRefs)\n      : Arena(std::move(Arena)), Refs(std::move(Refs)), NumRefs(NumRefs) {}\n\n  llvm::BumpPtrAllocator Arena;\n  std::vector<value_type> Refs;\n  /// Number of all references.\n  size_t NumRefs = 0;\n};\n\n} // namespace clangd\n} // namespace clang\n\nnamespace llvm {\ntemplate <> struct DenseMapInfo<clang::clangd::RefSlab::Builder::Entry> {\n  using Entry = clang::clangd::RefSlab::Builder::Entry;\n  static inline Entry getEmptyKey() {\n    static Entry E{clang::clangd::SymbolID(\"\"), {}};\n    return E;\n  }\n  static inline Entry getTombstoneKey() {\n    static Entry E{clang::clangd::SymbolID(\"TOMBSTONE\"), {}};\n    return E;\n  }\n  static unsigned getHashValue(const Entry &Val) {\n    return llvm::hash_combine(\n        Val.Symbol, reinterpret_cast<uintptr_t>(Val.Reference.Location.FileURI),\n        Val.Reference.Location.Start.rep(), Val.Reference.Location.End.rep());\n  }\n  static bool isEqual(const Entry &LHS, const Entry &RHS) {\n    return std::tie(LHS.Symbol, LHS.Reference.Location.FileURI,\n                    LHS.Reference.Kind) ==\n               std::tie(RHS.Symbol, RHS.Reference.Location.FileURI,\n                        RHS.Reference.Kind) &&\n           LHS.Reference.Location.Start == RHS.Reference.Location.Start &&\n           LHS.Reference.Location.End == RHS.Reference.Location.End;\n  }\n};\n} // namespace llvm\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_REF_H\n"}, "16": {"id": 16, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Relation.h", "content": "//===--- Relation.h ----------------------------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_RELATION_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_RELATION_H\n\n#include \"SymbolID.h\"\n#include \"SymbolLocation.h\"\n#include \"clang/Index/IndexSymbol.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include <cstdint>\n#include <utility>\n\nnamespace clang {\nnamespace clangd {\n\nenum class RelationKind : uint8_t {\n  BaseOf,\n  OverriddenBy,\n};\n\n/// Represents a relation between two symbols.\n/// For an example:\n///   - \"A is a base class of B\" is represented as\n///     { Subject = A, Predicate = BaseOf, Object = B }.\n///   - \"Derived::Foo overrides Base::Foo\" is represented as\n///     { Subject = Base::Foo, Predicate = OverriddenBy, Object = Derived::Foo\n///     }.\nstruct Relation {\n  SymbolID Subject;\n  RelationKind Predicate;\n  SymbolID Object;\n\n  bool operator==(const Relation &Other) const {\n    return std::tie(Subject, Predicate, Object) ==\n           std::tie(Other.Subject, Other.Predicate, Other.Object);\n  }\n  // SPO order\n  bool operator<(const Relation &Other) const {\n    return std::tie(Subject, Predicate, Object) <\n           std::tie(Other.Subject, Other.Predicate, Other.Object);\n  }\n};\nllvm::raw_ostream &operator<<(llvm::raw_ostream &OS, const RelationKind R);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &OS, const Relation &R);\n\nclass RelationSlab {\npublic:\n  using value_type = Relation;\n  using const_iterator = std::vector<value_type>::const_iterator;\n  using iterator = const_iterator;\n\n  RelationSlab() = default;\n  RelationSlab(RelationSlab &&Slab) = default;\n  RelationSlab &operator=(RelationSlab &&RHS) = default;\n\n  const_iterator begin() const { return Relations.begin(); }\n  const_iterator end() const { return Relations.end(); }\n  size_t size() const { return Relations.size(); }\n  bool empty() const { return Relations.empty(); }\n\n  size_t bytes() const {\n    return sizeof(*this) + sizeof(value_type) * Relations.capacity();\n  }\n\n  /// Lookup all relations matching the given subject and predicate.\n  llvm::iterator_range<iterator> lookup(const SymbolID &Subject,\n                                        RelationKind Predicate) const;\n\n  /// RelationSlab::Builder is a mutable container that can 'freeze' to\n  /// RelationSlab.\n  class Builder {\n  public:\n    /// Adds a relation to the slab.\n    void insert(const Relation &R) { Relations.push_back(R); }\n\n    /// Consumes the builder to finalize the slab.\n    RelationSlab build() &&;\n\n  private:\n    std::vector<Relation> Relations;\n  };\n\nprivate:\n  RelationSlab(std::vector<Relation> Relations)\n      : Relations(std::move(Relations)) {}\n\n  std::vector<Relation> Relations;\n};\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_RELATION_H\n"}, "17": {"id": 17, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Symbol.h", "content": "//===--- Symbol.h ------------------------------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOL_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOL_H\n\n#include \"SymbolID.h\"\n#include \"SymbolLocation.h\"\n#include \"SymbolOrigin.h\"\n#include \"clang/Index/IndexSymbol.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/StringSaver.h\"\n\nnamespace clang {\nnamespace clangd {\n\n/// The class presents a C++ symbol, e.g. class, function.\n///\n/// WARNING: Symbols do not own much of their underlying data - typically\n/// strings are owned by a SymbolSlab. They should be treated as non-owning\n/// references. Copies are shallow.\n///\n/// When adding new unowned data fields to Symbol, remember to update:\n///   - SymbolSlab::Builder in Index.cpp, to copy them to the slab's storage.\n///   - mergeSymbol in Merge.cpp, to properly combine two Symbols.\n///\n/// A fully documented symbol can be split as:\n/// size_type std::map<k, t>::count(const K& key) const\n/// | Return  |     Scope     |Name|    Signature     |\n/// We split up these components to allow display flexibility later.\nstruct Symbol {\n  /// The ID of the symbol.\n  SymbolID ID;\n  /// The symbol information, like symbol kind.\n  index::SymbolInfo SymInfo = index::SymbolInfo();\n  /// The unqualified name of the symbol, e.g. \"bar\" (for ns::bar).\n  llvm::StringRef Name;\n  /// The containing namespace. e.g. \"\" (global), \"ns::\" (top-level namespace).\n  llvm::StringRef Scope;\n  /// The location of the symbol's definition, if one was found.\n  /// This just covers the symbol name (e.g. without class/function body).\n  SymbolLocation Definition;\n  /// The location of the preferred declaration of the symbol.\n  /// This just covers the symbol name.\n  /// This may be the same as Definition.\n  ///\n  /// A C++ symbol may have multiple declarations, and we pick one to prefer.\n  ///   * For classes, the canonical declaration should be the definition.\n  ///   * For non-inline functions, the canonical declaration typically appears\n  ///     in the \".h\" file corresponding to the definition.\n  SymbolLocation CanonicalDeclaration;\n  /// The number of translation units that reference this symbol from their main\n  /// file. This number is only meaningful if aggregated in an index.\n  unsigned References = 0;\n  /// Where this symbol came from. Usually an index provides a constant value.\n  SymbolOrigin Origin = SymbolOrigin::Unknown;\n  /// A brief description of the symbol that can be appended in the completion\n  /// candidate list. For example, \"(X x, Y y) const\" is a function signature.\n  /// Only set when the symbol is indexed for completion.\n  llvm::StringRef Signature;\n  /// Argument list in human-readable format, will be displayed to help\n  /// disambiguate between different specializations of a template. Empty for\n  /// non-specializations. Example: \"<int, bool, 3>\"\n  llvm::StringRef TemplateSpecializationArgs;\n  /// What to insert when completing this symbol, after the symbol name.\n  /// This is in LSP snippet syntax (e.g. \"({$0})\" for a no-args function).\n  /// (When snippets are disabled, the symbol name alone is used).\n  /// Only set when the symbol is indexed for completion.\n  llvm::StringRef CompletionSnippetSuffix;\n  /// Documentation including comment for the symbol declaration.\n  llvm::StringRef Documentation;\n  /// Type when this symbol is used in an expression. (Short display form).\n  /// e.g. return type of a function, or type of a variable.\n  /// Only set when the symbol is indexed for completion.\n  llvm::StringRef ReturnType;\n\n  /// Raw representation of the OpaqueType of the symbol, used for scoring\n  /// purposes.\n  /// Only set when the symbol is indexed for completion.\n  llvm::StringRef Type;\n\n  struct IncludeHeaderWithReferences {\n    IncludeHeaderWithReferences() = default;\n\n    IncludeHeaderWithReferences(llvm::StringRef IncludeHeader,\n                                unsigned References)\n        : IncludeHeader(IncludeHeader), References(References) {}\n\n    /// This can be either a URI of the header to be #include'd\n    /// for this symbol, or a literal header quoted with <> or \"\" that is\n    /// suitable to be included directly. When it is a URI, the exact #include\n    /// path needs to be calculated according to the URI scheme.\n    ///\n    /// Note that the include header is a canonical include for the symbol and\n    /// can be different from FileURI in the CanonicalDeclaration.\n    llvm::StringRef IncludeHeader = \"\";\n    /// The number of translation units that reference this symbol and include\n    /// this header. This number is only meaningful if aggregated in an index.\n    unsigned References = 0;\n  };\n  /// One Symbol can potentially be included via different headers.\n  ///   - If we haven't seen a definition, this covers all declarations.\n  ///   - If we have seen a definition, this covers declarations visible from\n  ///   any definition.\n  /// Only set when the symbol is indexed for completion.\n  llvm::SmallVector<IncludeHeaderWithReferences, 1> IncludeHeaders;\n\n  enum SymbolFlag : uint8_t {\n    None = 0,\n    /// Whether or not this symbol is meant to be used for the code completion.\n    /// See also isIndexedForCodeCompletion().\n    /// Note that we don't store completion information (signature, snippet,\n    /// type, includes) if the symbol is not indexed for code completion.\n    IndexedForCodeCompletion = 1 << 0,\n    /// Indicates if the symbol is deprecated.\n    Deprecated = 1 << 1,\n    /// Symbol is an implementation detail.\n    ImplementationDetail = 1 << 2,\n    /// Symbol is visible to other files (not e.g. a static helper function).\n    VisibleOutsideFile = 1 << 3,\n  };\n\n  SymbolFlag Flags = SymbolFlag::None;\n  /// FIXME: also add deprecation message and fixit?\n};\n\ninline Symbol::SymbolFlag operator|(Symbol::SymbolFlag A,\n                                    Symbol::SymbolFlag B) {\n  return static_cast<Symbol::SymbolFlag>(static_cast<uint8_t>(A) |\n                                         static_cast<uint8_t>(B));\n}\ninline Symbol::SymbolFlag &operator|=(Symbol::SymbolFlag &A,\n                                      Symbol::SymbolFlag B) {\n  return A = A | B;\n}\n\nllvm::raw_ostream &operator<<(llvm::raw_ostream &OS, const Symbol &S);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &OS, Symbol::SymbolFlag);\n\n/// Invokes Callback with each StringRef& contained in the Symbol.\n/// Useful for deduplicating backing strings.\ntemplate <typename Callback> void visitStrings(Symbol &S, const Callback &CB) {\n  CB(S.Name);\n  CB(S.Scope);\n  CB(S.TemplateSpecializationArgs);\n  CB(S.Signature);\n  CB(S.CompletionSnippetSuffix);\n  CB(S.Documentation);\n  CB(S.ReturnType);\n  CB(S.Type);\n  auto RawCharPointerCB = [&CB](const char *&P) {\n    llvm::StringRef S(P);\n    CB(S);\n    assert(!S.data()[S.size()] && \"Visited StringRef must be null-terminated\");\n    P = S.data();\n  };\n  RawCharPointerCB(S.CanonicalDeclaration.FileURI);\n  RawCharPointerCB(S.Definition.FileURI);\n\n  for (auto &Include : S.IncludeHeaders)\n    CB(Include.IncludeHeader);\n}\n\n/// Computes query-independent quality score for a Symbol.\n/// This currently falls in the range [1, ln(#indexed documents)].\n/// FIXME: this should probably be split into symbol -> signals\n///        and signals -> score, so it can be reused for Sema completions.\nfloat quality(const Symbol &S);\n\n/// An immutable symbol container that stores a set of symbols.\n/// The container will maintain the lifetime of the symbols.\nclass SymbolSlab {\npublic:\n  using const_iterator = std::vector<Symbol>::const_iterator;\n  using iterator = const_iterator;\n  using value_type = Symbol;\n\n  SymbolSlab() = default;\n\n  const_iterator begin() const { return Symbols.begin(); }\n  const_iterator end() const { return Symbols.end(); }\n  const_iterator find(const SymbolID &SymID) const;\n\n  using size_type = size_t;\n  size_type size() const { return Symbols.size(); }\n  bool empty() const { return Symbols.empty(); }\n  // Estimates the total memory usage.\n  size_t bytes() const {\n    return sizeof(*this) + Arena.getTotalMemory() +\n           Symbols.capacity() * sizeof(Symbol);\n  }\n\n  /// SymbolSlab::Builder is a mutable container that can 'freeze' to\n  /// SymbolSlab. The frozen SymbolSlab will use less memory.\n  class Builder {\n  public:\n    Builder() : UniqueStrings(Arena) {}\n\n    /// Adds a symbol, overwriting any existing one with the same ID.\n    /// This is a deep copy: underlying strings will be owned by the slab.\n    void insert(const Symbol &S);\n\n    /// Removes the symbol with an ID, if it exists.\n    void erase(const SymbolID &ID) { Symbols.erase(ID); }\n\n    /// Returns the symbol with an ID, if it exists. Valid until insert/remove.\n    const Symbol *find(const SymbolID &ID) {\n      auto I = Symbols.find(ID);\n      return I == Symbols.end() ? nullptr : &I->second;\n    }\n\n    /// Consumes the builder to finalize the slab.\n    SymbolSlab build() &&;\n\n  private:\n    llvm::BumpPtrAllocator Arena;\n    /// Intern table for strings. Contents are on the arena.\n    llvm::UniqueStringSaver UniqueStrings;\n    /// Values are indices into Symbols vector.\n    llvm::DenseMap<SymbolID, Symbol> Symbols;\n  };\n\nprivate:\n  SymbolSlab(llvm::BumpPtrAllocator Arena, std::vector<Symbol> Symbols)\n      : Arena(std::move(Arena)), Symbols(std::move(Symbols)) {}\n\n  llvm::BumpPtrAllocator Arena; // Owns Symbol data that the Symbols do not.\n  std::vector<Symbol> Symbols;  // Sorted by SymbolID to allow lookup.\n};\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOL_H\n"}, "18": {"id": 18, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolLocation.h", "content": "//===--- SymbolLocation.h ----------------------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOL_LOCATION_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOL_LOCATION_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cstdint>\n\nnamespace clang {\nnamespace clangd {\n\nstruct SymbolLocation {\n  // Specify a position (Line, Column) of symbol. Using Line/Column allows us to\n  // build LSP responses without reading the file content.\n  //\n  // clangd uses the following definitions, which differ slightly from LSP:\n  //  - Line is the number of newline characters (\\n) before the point.\n  //  - Column is (by default) the number of UTF-16 code between the last \\n\n  //    (or start of file) and the point.\n  //    If the `offsetEncoding` protocol extension is used to negotiate UTF-8,\n  //    then it is instead the number of *bytes* since the last \\n.\n  //\n  // Position is encoded into 32 bits to save space.\n  // If Line/Column overflow, the value will be their maximum value.\n  struct Position {\n    Position() : LineColumnPacked(0) {}\n    void setLine(uint32_t Line);\n    uint32_t line() const { return LineColumnPacked >> ColumnBits; }\n    void setColumn(uint32_t Column);\n    uint32_t column() const { return LineColumnPacked & MaxColumn; }\n    uint32_t rep() const { return LineColumnPacked; }\n\n    bool hasOverflow() const {\n      return line() == MaxLine || column() == MaxColumn;\n    }\n\n    static constexpr unsigned ColumnBits = 12;\n    static constexpr uint32_t MaxLine = (1 << (32 - ColumnBits)) - 1;\n    static constexpr uint32_t MaxColumn = (1 << ColumnBits) - 1;\n\n  private:\n    uint32_t LineColumnPacked; // Top 20 bit line, bottom 12 bits column.\n  };\n\n  /// The symbol range, using half-open range [Start, End).\n  Position Start;\n  Position End;\n\n  explicit operator bool() const { return !llvm::StringRef(FileURI).empty(); }\n\n  // The URI of the source file where a symbol occurs.\n  // The string must be null-terminated.\n  //\n  // We avoid using llvm::StringRef here to save memory.\n  // WARNING: unless you know what you are doing, it is recommended to use it\n  // via llvm::StringRef.\n  const char *FileURI = \"\";\n};\n\ninline bool operator==(const SymbolLocation::Position &L,\n                       const SymbolLocation::Position &R) {\n  return std::make_tuple(L.line(), L.column()) ==\n         std::make_tuple(R.line(), R.column());\n}\ninline bool operator<(const SymbolLocation::Position &L,\n                      const SymbolLocation::Position &R) {\n  return std::make_tuple(L.line(), L.column()) <\n         std::make_tuple(R.line(), R.column());\n}\ninline bool operator==(const SymbolLocation &L, const SymbolLocation &R) {\n  assert(L.FileURI && R.FileURI);\n  return !std::strcmp(L.FileURI, R.FileURI) &&\n         std::tie(L.Start, L.End) == std::tie(R.Start, R.End);\n}\ninline bool operator<(const SymbolLocation &L, const SymbolLocation &R) {\n  assert(L.FileURI && R.FileURI);\n  int Cmp = std::strcmp(L.FileURI, R.FileURI);\n  if (Cmp != 0)\n    return Cmp < 0;\n  return std::tie(L.Start, L.End) < std::tie(R.Start, R.End);\n}\n\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const SymbolLocation &);\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOL_LOCATION_H\n"}, "19": {"id": 19, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/Context.h", "content": "//===--- Context.h - Mechanism for passing implicit data --------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Context for storing and retrieving implicit data. Useful for passing implicit\n// parameters on a per-request basis.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_SUPPORT_CONTEXT_H_\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_SUPPORT_CONTEXT_H_\n\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/Support/Compiler.h\"\n#include <memory>\n#include <type_traits>\n\nnamespace clang {\nnamespace clangd {\n\n/// Values in a Context are indexed by typed keys.\n/// Key<T> serves two purposes:\n///   - it provides a lookup key for the context (each Key is unique),\n///   - it makes lookup type-safe: a Key<T> can only map to a T (or nothing).\n///\n/// Example:\n///    Key<int> RequestID;\n///    Key<int> Version;\n///\n///    Context Ctx = Context::empty().derive(RequestID, 10).derive(Version, 3);\n///    assert(*Ctx.get(RequestID) == 10);\n///    assert(*Ctx.get(Version) == 3);\n///\n/// Keys are typically used across multiple functions, so most of the time you\n/// would want to make them static class members or global variables.\ntemplate <class Type> class Key {\npublic:\n  static_assert(!std::is_reference<Type>::value,\n                \"Reference arguments to Key<> are not allowed\");\n\n  constexpr Key() = default;\n\n  Key(Key const &) = delete;\n  Key &operator=(Key const &) = delete;\n  Key(Key &&) = delete;\n  Key &operator=(Key &&) = delete;\n};\n\n/// A context is an immutable container for per-request data that must be\n/// propagated through layers that don't care about it. An example is a request\n/// ID that we may want to use when logging.\n///\n/// Conceptually, a context is a heterogeneous map<Key<T>, T>. Each key has\n/// an associated value type, which allows the map to be typesafe.\n///\n/// There is an \"ambient\" context for each thread, Context::current().\n/// Most functions should read from this, and use WithContextValue or\n/// WithContext to extend or replace the context within a block scope.\n/// Only code dealing with threads and extension points should need to use\n/// other Context objects.\n///\n/// You can't add data to an existing context, instead you create a new\n/// immutable context derived from it with extra data added. When you retrieve\n/// data, the context will walk up the parent chain until the key is found.\nclass Context {\npublic:\n  /// Returns an empty root context that contains no data.\n  static Context empty();\n  /// Returns the context for the current thread, creating it if needed.\n  static const Context &current();\n  // Sets the current() context to Replacement, and returns the old context.\n  // Prefer to use WithContext or WithContextValue to do this safely.\n  static Context swapCurrent(Context Replacement);\n\nprivate:\n  struct Data;\n  Context(std::shared_ptr<const Data> DataPtr);\n\npublic:\n  /// Same as Context::empty(), please use Context::empty() instead.\n  Context() = default;\n\n  /// Copy operations for this class are deleted, use an explicit clone() method\n  /// when you need a copy of the context instead.\n  Context(Context const &) = delete;\n  Context &operator=(const Context &) = delete;\n\n  Context(Context &&) = default;\n  Context &operator=(Context &&) = default;\n\n  /// Get data stored for a typed \\p Key. If values are not found\n  /// \\returns Pointer to the data associated with \\p Key. If no data is\n  /// specified for \\p Key, return null.\n  template <class Type> const Type *get(const Key<Type> &Key) const {\n    for (const Data *DataPtr = this->DataPtr.get(); DataPtr != nullptr;\n         DataPtr = DataPtr->Parent.get()) {\n      if (DataPtr->KeyPtr == &Key)\n        return static_cast<const Type *>(DataPtr->Value->getValuePtr());\n    }\n    return nullptr;\n  }\n\n  /// A helper to get a reference to a \\p Key that must exist in the map.\n  /// Must not be called for keys that are not in the map.\n  template <class Type> const Type &getExisting(const Key<Type> &Key) const {\n    auto Val = get(Key);\n    assert(Val && \"Key does not exist\");\n    return *Val;\n  }\n\n  /// Derives a child context\n  /// It is safe to move or destroy a parent context after calling derive().\n  /// The child will keep its parent alive, and its data remains accessible.\n  template <class Type>\n  Context derive(const Key<Type> &Key,\n                 typename std::decay<Type>::type Value) const & {\n    return Context(std::make_shared<Data>(\n        Data{/*Parent=*/DataPtr, &Key,\n             std::make_unique<TypedAnyStorage<typename std::decay<Type>::type>>(\n                 std::move(Value))}));\n  }\n\n  template <class Type>\n  Context\n  derive(const Key<Type> &Key,\n         typename std::decay<Type>::type Value) && /* takes ownership */ {\n    return Context(std::make_shared<Data>(\n        Data{/*Parent=*/std::move(DataPtr), &Key,\n             std::make_unique<TypedAnyStorage<typename std::decay<Type>::type>>(\n                 std::move(Value))}));\n  }\n\n  /// Derives a child context, using an anonymous key.\n  /// Intended for objects stored only for their destructor's side-effect.\n  template <class Type> Context derive(Type &&Value) const & {\n    static Key<typename std::decay<Type>::type> Private;\n    return derive(Private, std::forward<Type>(Value));\n  }\n\n  template <class Type> Context derive(Type &&Value) && {\n    static Key<typename std::decay<Type>::type> Private;\n    return std::move(*this).derive(Private, std::forward<Type>(Value));\n  }\n\n  /// Clone this context object.\n  Context clone() const;\n\nprivate:\n  class AnyStorage {\n  public:\n    virtual ~AnyStorage() = default;\n    virtual void *getValuePtr() = 0;\n  };\n\n  template <class T> class TypedAnyStorage : public Context::AnyStorage {\n    static_assert(std::is_same<typename std::decay<T>::type, T>::value,\n                  \"Argument to TypedAnyStorage must be decayed\");\n\n  public:\n    TypedAnyStorage(T &&Value) : Value(std::move(Value)) {}\n\n    void *getValuePtr() override { return &Value; }\n\n  private:\n    T Value;\n  };\n\n  struct Data {\n    // We need to make sure Parent outlives the Value, so the order of members\n    // is important. We do that to allow classes stored in Context's child\n    // layers to store references to the data in the parent layers.\n    std::shared_ptr<const Data> Parent;\n    const void *KeyPtr;\n    std::unique_ptr<AnyStorage> Value;\n  };\n\n  std::shared_ptr<const Data> DataPtr;\n};\n\n/// WithContext replaces Context::current() with a provided scope.\n/// When the WithContext is destroyed, the original scope is restored.\n/// For extending the current context with new value, prefer WithContextValue.\nclass LLVM_NODISCARD WithContext {\npublic:\n  WithContext(Context C) : Restore(Context::swapCurrent(std::move(C))) {}\n  ~WithContext() { Context::swapCurrent(std::move(Restore)); }\n  WithContext(const WithContext &) = delete;\n  WithContext &operator=(const WithContext &) = delete;\n  WithContext(WithContext &&) = delete;\n  WithContext &operator=(WithContext &&) = delete;\n\nprivate:\n  Context Restore;\n};\n\n/// WithContextValue extends Context::current() with a single value.\n/// When the WithContextValue is destroyed, the original scope is restored.\nclass LLVM_NODISCARD WithContextValue {\npublic:\n  template <typename T>\n  WithContextValue(const Key<T> &K, typename std::decay<T>::type V)\n      : Restore(Context::current().derive(K, std::move(V))) {}\n\n  // Anonymous values can be used for the destructor side-effect.\n  template <typename T>\n  WithContextValue(T &&V)\n      : Restore(Context::current().derive(std::forward<T>(V))) {}\n\nprivate:\n  WithContext Restore;\n};\n\n} // namespace clangd\n} // namespace clang\n\n#endif\n"}, "20": {"id": 20, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/Function.h", "content": "//===--- Function.h - Utility callable wrappers  -----------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file provides utilities for callable objects.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_SUPPORT_FUNCTION_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_SUPPORT_FUNCTION_H\n\n#include \"llvm/ADT/FunctionExtras.h\"\n#include \"llvm/Support/Error.h\"\n#include <mutex>\n#include <tuple>\n#include <utility>\n\nnamespace clang {\nnamespace clangd {\n\n/// A Callback<T> is a void function that accepts Expected<T>.\n/// This is accepted by ClangdServer functions that logically return T.\ntemplate <typename T>\nusing Callback = llvm::unique_function<void(llvm::Expected<T>)>;\n\n/// An Event<T> allows events of type T to be broadcast to listeners.\ntemplate <typename T> class Event {\npublic:\n  // A Listener is the callback through which events are delivered.\n  using Listener = std::function<void(const T &)>;\n\n  // A subscription defines the scope of when a listener should receive events.\n  // After destroying the subscription, no more events are received.\n  class LLVM_NODISCARD Subscription {\n    Event *Parent;\n    unsigned ListenerID;\n\n    Subscription(Event *Parent, unsigned ListenerID)\n        : Parent(Parent), ListenerID(ListenerID) {}\n    friend Event;\n\n  public:\n    Subscription() : Parent(nullptr) {}\n    Subscription(Subscription &&Other) : Parent(nullptr) {\n      *this = std::move(Other);\n    }\n    Subscription &operator=(Subscription &&Other) {\n      // If *this is active, unsubscribe.\n      if (Parent) {\n        std::lock_guard<std::recursive_mutex> Lock(Parent->ListenersMu);\n        llvm::erase_if(Parent->Listeners,\n                       [&](const std::pair<Listener, unsigned> &P) {\n                         return P.second == ListenerID;\n                       });\n      }\n      // Take over the other subscription, and mark it inactive.\n      std::tie(Parent, ListenerID) = std::tie(Other.Parent, Other.ListenerID);\n      Other.Parent = nullptr;\n      return *this;\n    }\n    // Destroying a subscription may block if an event is being broadcast.\n    ~Subscription() {\n      if (Parent)\n        *this = Subscription(); // Unsubscribe.\n    }\n  };\n\n  // Adds a listener that will observe all future events until the returned\n  // subscription is destroyed.\n  // May block if an event is currently being broadcast.\n  Subscription observe(Listener L) {\n    std::lock_guard<std::recursive_mutex> Lock(ListenersMu);\n    Listeners.push_back({std::move(L), ++ListenerCount});\n    return Subscription(this, ListenerCount);\n  }\n\n  // Synchronously sends an event to all registered listeners.\n  // Must not be called from a listener to this event.\n  void broadcast(const T &V) {\n    // FIXME: it would be nice to dynamically check non-reentrancy here.\n    std::lock_guard<std::recursive_mutex> Lock(ListenersMu);\n    for (const auto &L : Listeners)\n      L.first(V);\n  }\n\n  ~Event() {\n    std::lock_guard<std::recursive_mutex> Lock(ListenersMu);\n    assert(Listeners.empty());\n  }\n\nprivate:\n  static_assert(std::is_same<typename std::decay<T>::type, T>::value,\n                \"use a plain type: event values are always passed by const&\");\n\n  std::recursive_mutex ListenersMu;\n  bool IsBroadcasting = false;\n  std::vector<std::pair<Listener, unsigned>> Listeners;\n  unsigned ListenerCount = 0;\n};\n\n} // namespace clangd\n} // namespace clang\n\n#endif\n"}, "21": {"id": 21, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/MemoryTree.h", "content": "//===--- MemoryTree.h - A special tree for components and sizes -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_SUPPORT_MEMORYTREE_H_\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_SUPPORT_MEMORYTREE_H_\n\n#include \"Trace.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/StringSaver.h\"\n#include <cstddef>\n#include <string>\n#include <vector>\n\nnamespace clang {\nnamespace clangd {\n\n/// A tree that can be used to represent memory usage of nested components while\n/// preserving the hierarchy.\n/// Edges have associated names. An edge that might not be interesting to all\n/// traversers or costly to copy (e.g. file names) can be marked as \"detail\".\n/// Tree construction allows chosing between a detailed and brief mode, in brief\n/// mode all \"detail\" edges are ignored and tree is constructed without any\n/// string copies.\nstruct MemoryTree {\npublic:\n  /// If Alloc is nullptr, tree is in brief mode and will ignore detail edges.\n  MemoryTree(llvm::BumpPtrAllocator *DetailAlloc = nullptr)\n      : DetailAlloc(DetailAlloc) {}\n\n  /// No copy of the \\p Name.\n  /// Note that returned pointers are invalidated with subsequent calls to\n  /// child/detail.\n  MemoryTree &child(llvm::StringLiteral Name) { return createChild(Name); }\n\n  MemoryTree(const MemoryTree &) = delete;\n  MemoryTree &operator=(const MemoryTree &) = delete;\n\n  MemoryTree(MemoryTree &&) = default;\n  MemoryTree &operator=(MemoryTree &&) = default;\n\n  /// Makes a copy of the \\p Name in detailed mode, returns current node\n  /// otherwise.\n  /// Note that returned pointers are invalidated with subsequent calls to\n  /// child/detail.\n  MemoryTree &detail(llvm::StringRef Name) {\n    return DetailAlloc ? createChild(Name.copy(*DetailAlloc)) : *this;\n  }\n\n  /// Increases size of current node by \\p Increment.\n  void addUsage(size_t Increment) { Size += Increment; }\n\n  /// Returns edges to direct children of this node.\n  const llvm::DenseMap<llvm::StringRef, MemoryTree> &children() const;\n\n  /// Returns total number of bytes used by this sub-tree. Performs a traversal.\n  size_t total() const;\n\n  /// Returns total number of bytes used by this node only.\n  size_t self() const { return Size; }\n\nprivate:\n  /// Adds a child with an edge labeled as \\p Name. Multiple calls to this\n  /// function returns the same node.\n  MemoryTree &createChild(llvm::StringRef Name);\n\n  /// Allocator to use for detailed edge names.\n  llvm::BumpPtrAllocator *DetailAlloc = nullptr;\n\n  /// Bytes owned by this component specifically.\n  size_t Size = 0;\n\n  /// Edges from current node to its children. Keys are the labels for edges.\n  llvm::DenseMap<llvm::StringRef, MemoryTree> Children;\n};\n\n/// Records total memory usage of each node under \\p Out. Labels are edges on\n/// the path joined with \".\", starting with \\p RootName.\nvoid record(const MemoryTree &MT, std::string RootName,\n            const trace::Metric &Out);\n\n} // namespace clangd\n} // namespace clang\n\n#endif\n"}, "22": {"id": 22, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/Threading.h", "content": "//===--- Threading.h - Abstractions for multithreading -----------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_SUPPORT_THREADING_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_SUPPORT_THREADING_H\n\n#include \"support/Context.h\"\n#include \"llvm/ADT/FunctionExtras.h\"\n#include \"llvm/ADT/Twine.h\"\n#include <cassert>\n#include <condition_variable>\n#include <future>\n#include <memory>\n#include <mutex>\n#include <thread>\n#include <vector>\n\nnamespace clang {\nnamespace clangd {\n\n/// A threadsafe flag that is initially clear.\nclass Notification {\npublic:\n  // Sets the flag. No-op if already set.\n  void notify();\n  // Blocks until flag is set.\n  void wait() const;\n\nprivate:\n  bool Notified = false;\n  mutable std::condition_variable CV;\n  mutable std::mutex Mu;\n};\n\n/// Limits the number of threads that can acquire the lock at the same time.\nclass Semaphore {\npublic:\n  Semaphore(std::size_t MaxLocks);\n\n  bool try_lock();\n  void lock();\n  void unlock();\n\nprivate:\n  std::mutex Mutex;\n  std::condition_variable SlotsChanged;\n  std::size_t FreeSlots;\n};\n\n/// A point in time we can wait for.\n/// Can be zero (don't wait) or infinity (wait forever).\n/// (Not time_point::max(), because many std::chrono implementations overflow).\nclass Deadline {\npublic:\n  Deadline(std::chrono::steady_clock::time_point Time)\n      : Type(Finite), Time(Time) {}\n  static Deadline zero() { return Deadline(Zero); }\n  static Deadline infinity() { return Deadline(Infinite); }\n\n  std::chrono::steady_clock::time_point time() const {\n    assert(Type == Finite);\n    return Time;\n  }\n  bool expired() const {\n    return (Type == Zero) ||\n           (Type == Finite && Time < std::chrono::steady_clock::now());\n  }\n  bool operator==(const Deadline &Other) const {\n    return (Type == Other.Type) && (Type != Finite || Time == Other.Time);\n  }\n\nprivate:\n  enum Type { Zero, Infinite, Finite };\n\n  Deadline(enum Type Type) : Type(Type) {}\n  enum Type Type;\n  std::chrono::steady_clock::time_point Time;\n};\n\n/// Makes a deadline from a timeout in seconds. None means wait forever.\nDeadline timeoutSeconds(llvm::Optional<double> Seconds);\n/// Wait once on CV for the specified duration.\nvoid wait(std::unique_lock<std::mutex> &Lock, std::condition_variable &CV,\n          Deadline D);\n/// Waits on a condition variable until F() is true or D expires.\ntemplate <typename Func>\nLLVM_NODISCARD bool wait(std::unique_lock<std::mutex> &Lock,\n                         std::condition_variable &CV, Deadline D, Func F) {\n  while (!F()) {\n    if (D.expired())\n      return false;\n    wait(Lock, CV, D);\n  }\n  return true;\n}\n\n/// Runs tasks on separate (detached) threads and wait for all tasks to finish.\n/// Objects that need to spawn threads can own an AsyncTaskRunner to ensure they\n/// all complete on destruction.\nclass AsyncTaskRunner {\npublic:\n  /// Destructor waits for all pending tasks to finish.\n  ~AsyncTaskRunner();\n\n  void wait() const { (void)wait(Deadline::infinity()); }\n  LLVM_NODISCARD bool wait(Deadline D) const;\n  // The name is used for tracing and debugging (e.g. to name a spawned thread).\n  void runAsync(const llvm::Twine &Name, llvm::unique_function<void()> Action);\n\nprivate:\n  mutable std::mutex Mutex;\n  mutable std::condition_variable TasksReachedZero;\n  std::size_t InFlightTasks = 0;\n};\n\n/// Runs \\p Action asynchronously with a new std::thread. The context will be\n/// propagated.\ntemplate <typename T>\nstd::future<T> runAsync(llvm::unique_function<T()> Action) {\n  return std::async(\n      std::launch::async,\n      [](llvm::unique_function<T()> &&Action, Context Ctx) {\n        WithContext WithCtx(std::move(Ctx));\n        return Action();\n      },\n      std::move(Action), Context::current().clone());\n}\n\n/// Memoize is a cache to store and reuse computation results based on a key.\n///\n///   Memoize<DenseMap<int, bool>> PrimeCache;\n///   for (int I : RepetitiveNumbers)\n///     if (PrimeCache.get(I, [&] { return expensiveIsPrime(I); }))\n///       llvm::errs() << \"Prime: \" << I << \"\\n\";\n///\n/// The computation will only be run once for each key.\n/// This class is threadsafe. Concurrent calls for the same key may run the\n/// computation multiple times, but each call will return the same result.\ntemplate <typename Container> class Memoize {\n  mutable Container Cache;\n  std::unique_ptr<std::mutex> Mu;\n\npublic:\n  Memoize() : Mu(std::make_unique<std::mutex>()) {}\n\n  template <typename T, typename Func>\n  typename Container::mapped_type get(T &&Key, Func Compute) const {\n    {\n      std::lock_guard<std::mutex> Lock(*Mu);\n      auto It = Cache.find(Key);\n      if (It != Cache.end())\n        return It->second;\n    }\n    // Don't hold the mutex while computing.\n    auto V = Compute();\n    {\n      std::lock_guard<std::mutex> Lock(*Mu);\n      auto R = Cache.try_emplace(std::forward<T>(Key), V);\n      // Insert into cache may fail if we raced with another thread.\n      if (!R.second)\n        return R.first->second; // Canonical value, from other thread.\n    }\n    return V;\n  }\n};\n\n/// Used to guard an operation that should run at most every N seconds.\n///\n/// Usage:\n///   mutable PeriodicThrottler ShouldLog(std::chrono::seconds(1));\n///   void calledFrequently() {\n///     if (ShouldLog())\n///       log(\"this is not spammy\");\n///   }\n///\n/// This class is threadsafe. If multiple threads are involved, then the guarded\n/// operation still needs to be threadsafe!\nclass PeriodicThrottler {\n  using Stopwatch = std::chrono::steady_clock;\n  using Rep = Stopwatch::duration::rep;\n\n  Rep Period;\n  std::atomic<Rep> Next;\n\npublic:\n  /// If Period is zero, the throttler will return true every time.\n  PeriodicThrottler(Stopwatch::duration Period, Stopwatch::duration Delay = {})\n      : Period(Period.count()),\n        Next((Stopwatch::now() + Delay).time_since_epoch().count()) {}\n\n  /// Returns whether the operation should run at this time.\n  /// operator() is safe to call concurrently.\n  bool operator()();\n};\n\n} // namespace clangd\n} // namespace clang\n#endif\n"}, "23": {"id": 23, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/ThreadsafeFS.h", "content": "//===--- ThreadsafeFS.h ------------------------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_SUPPORT_THREADSAFEFS_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_SUPPORT_THREADSAFEFS_H\n\n#include \"Path.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/Support/VirtualFileSystem.h\"\n#include <memory>\n\nnamespace clang {\nnamespace clangd {\n\n/// Wrapper for vfs::FileSystem for use in multithreaded programs like clangd.\n/// As FileSystem is not threadsafe, concurrent threads must each obtain one.\n/// Implementations may choose to depend on Context::current() e.g. to implement\n/// snapshot semantics. clangd will not create vfs::FileSystems for use in\n/// different contexts, so either ThreadsafeFS::view or the returned FS may\n/// contain this logic.\nclass ThreadsafeFS {\npublic:\n  virtual ~ThreadsafeFS() = default;\n\n  /// Obtain a vfs::FileSystem with an arbitrary initial working directory.\n  llvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem>\n  view(llvm::NoneType CWD) const {\n    return viewImpl();\n  }\n\n  /// Obtain a vfs::FileSystem with a specified working directory.\n  /// If the working directory can't be set (e.g. doesn't exist), logs and\n  /// returns the FS anyway.\n  llvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem> view(PathRef CWD) const;\n\nprivate:\n  /// Overridden by implementations to provide a vfs::FileSystem.\n  /// This is distinct from view(NoneType) to avoid GCC's -Woverloaded-virtual.\n  virtual llvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem> viewImpl() const = 0;\n};\n\nclass RealThreadsafeFS : public ThreadsafeFS {\nprivate:\n  llvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem> viewImpl() const override;\n};\n\n} // namespace clangd\n} // namespace clang\n\n#endif\n"}, "24": {"id": 24, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/Trace.h", "content": "//===--- Trace.h - Performance tracing facilities ---------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Supports writing performance traces describing clangd's behavior.\n// Traces are consumed by implementations of the EventTracer interface.\n//\n//\n// All APIs are no-ops unless a Session is active (created by ClangdMain).\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_SUPPORT_TRACE_H_\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_SUPPORT_TRACE_H_\n\n#include \"support/Context.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/Support/JSON.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <chrono>\n#include <string>\n#include <vector>\n\nnamespace clang {\nnamespace clangd {\nnamespace trace {\n\n/// Represents measurements of clangd events, e.g. operation latency. Those\n/// measurements are recorded per-label, defaulting to an empty one for metrics\n/// that don't care about it. This enables aggregation of measurements across\n/// labels. For example a metric tracking accesses to a cache can have labels\n/// named hit and miss.\nstruct Metric {\n  enum MetricType {\n    /// A number whose value is meaningful, and may vary over time.\n    /// Each measurement replaces the current value.\n    Value,\n\n    /// An aggregate number whose rate of change over time is meaningful.\n    /// Each measurement is an increment for the counter.\n    Counter,\n\n    /// A distribution of values with a meaningful mean and count.\n    /// Each measured value is a sample for the distribution.\n    /// The distribution is assumed not to vary, samples are aggregated over\n    /// time.\n    Distribution,\n  };\n  constexpr Metric(llvm::StringLiteral Name, MetricType Type,\n                   llvm::StringLiteral LabelName = llvm::StringLiteral(\"\"))\n      : Name(Name), Type(Type), LabelName(LabelName) {}\n\n  /// Records a measurement for this metric to active tracer.\n  void record(double Value, llvm::StringRef Label = \"\") const;\n\n  /// Uniquely identifies the metric. Should use snake_case identifiers, can use\n  /// dots for hierarchy if needed. e.g. method_latency, foo.bar.\n  const llvm::StringLiteral Name;\n  const MetricType Type;\n  /// Indicates what measurement labels represent, e.g. \"operation_name\" for a\n  /// metric tracking latencies. If non empty all measurements must also have a\n  /// non-empty label.\n  const llvm::StringLiteral LabelName;\n};\n\n/// A consumer of trace events and measurements. The events are produced by\n/// Spans and trace::log, the measurements are produced by Metrics::record.\n/// Implementations of this interface must be thread-safe.\nclass EventTracer {\npublic:\n  virtual ~EventTracer() = default;\n\n  /// Called when event that has a duration starts. \\p Name describes the event.\n  /// Returns a derived context that will be destroyed when the event ends.\n  /// Usually implementations will store an object in the returned context\n  /// whose destructor records the end of the event.\n  /// The tracer may capture event details provided in SPAN_ATTACH() calls.\n  /// In this case it should call AttachDetails(), and pass in an empty Object\n  /// to hold them. This Object should be owned by the context, and the data\n  /// will be complete by the time the context is destroyed.\n  virtual Context\n  beginSpan(llvm::StringRef Name,\n            llvm::function_ref<void(llvm::json::Object *)> AttachDetails);\n  // Called when a Span is destroyed (it may still be active on other threads).\n  // beginSpan() and endSpan() will always form a proper stack on each thread.\n  // The Context returned by beginSpan is active, but Args is not ready.\n  // Tracers should not override this unless they need to observe strict\n  // per-thread nesting. Instead they should observe context destruction.\n  virtual void endSpan() {}\n\n  /// Called for instant events.\n  virtual void instant(llvm::StringRef Name, llvm::json::Object &&Args) {}\n\n  /// Called whenever a metrics records a measurement.\n  virtual void record(const Metric &Metric, double Value,\n                      llvm::StringRef Label) {}\n};\n\n/// Sets up a global EventTracer that consumes events produced by Span and\n/// trace::log. Only one TracingSession can be active at a time and it should be\n/// set up before calling any clangd-specific functions.\nclass Session {\npublic:\n  Session(EventTracer &Tracer);\n  ~Session();\n};\n\n/// Create an instance of EventTracer that produces an output in the Trace Event\n/// format supported by Chrome's trace viewer (chrome://tracing).\n///\n/// FIXME: Metrics are not recorded, some could become counter events.\n///\n/// The format is documented here:\n/// https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/preview\nstd::unique_ptr<EventTracer> createJSONTracer(llvm::raw_ostream &OS,\n                                              bool Pretty = false);\n\n/// Create an instance of EventTracer that outputs metric measurements as CSV.\n///\n/// Trace spans and instant events are ignored.\nstd::unique_ptr<EventTracer> createCSVMetricTracer(llvm::raw_ostream &OS);\n\n/// Records a single instant event, associated with the current thread.\nvoid log(const llvm::Twine &Name);\n\n/// Returns true if there is an active tracer.\nbool enabled();\n\n/// Records an event whose duration is the lifetime of the Span object.\n/// This lifetime is extended when the span's context is reused.\n///\n/// This is the main public interface for producing tracing events.\n///\n/// Arbitrary JSON metadata can be attached while this span is active:\n///   SPAN_ATTACH(MySpan, \"Payload\", SomeJSONExpr);\n///\n/// SomeJSONExpr is evaluated and copied only if actually needed.\nclass Span {\npublic:\n  Span(llvm::Twine Name);\n  /// Records span's duration in seconds to \\p LatencyMetric with \\p Name as the\n  /// label.\n  Span(llvm::Twine Name, const Metric &LatencyMetric);\n  ~Span();\n\n  /// Mutable metadata, if this span is interested.\n  /// Prefer to use SPAN_ATTACH rather than accessing this directly.\n  /// The lifetime of Args is the whole event, even if the Span dies.\n  llvm::json::Object *const Args;\n\nprivate:\n  // Awkward constructor works around constant initialization.\n  Span(std::pair<Context, llvm::json::Object *>);\n  WithContext RestoreCtx;\n};\n\n/// Attach a key-value pair to a Span event.\n/// This is not threadsafe when used with the same Span.\n#define SPAN_ATTACH(S, Name, Expr)                                             \\\n  do {                                                                         \\\n    if (auto *Args = (S).Args)                                                 \\\n      (*Args)[Name] = Expr;                                                    \\\n  } while (0)\n\n} // namespace trace\n} // namespace clangd\n} // namespace clang\n\n#endif\n"}, "25": {"id": 25, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/APValue.h", "content": "//===--- APValue.h - Union class for APFloat/APSInt/Complex -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the APValue class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_APVALUE_H\n#define LLVM_CLANG_AST_APVALUE_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/APFixedPoint.h\"\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/Support/AlignOf.h\"\n\nnamespace clang {\nnamespace serialization {\ntemplate <typename T> class BasicReaderBase;\n} // end namespace serialization\n\n  class AddrLabelExpr;\n  class ASTContext;\n  class CharUnits;\n  class CXXRecordDecl;\n  class Decl;\n  class DiagnosticBuilder;\n  class Expr;\n  class FieldDecl;\n  struct PrintingPolicy;\n  class Type;\n  class ValueDecl;\n  class QualType;\n\n/// Symbolic representation of typeid(T) for some type T.\nclass TypeInfoLValue {\n  const Type *T;\n\npublic:\n  TypeInfoLValue() : T() {}\n  explicit TypeInfoLValue(const Type *T);\n\n  const Type *getType() const { return T; }\n  explicit operator bool() const { return T; }\n\n  void *getOpaqueValue() { return const_cast<Type*>(T); }\n  static TypeInfoLValue getFromOpaqueValue(void *Value) {\n    TypeInfoLValue V;\n    V.T = reinterpret_cast<const Type*>(Value);\n    return V;\n  }\n\n  void print(llvm::raw_ostream &Out, const PrintingPolicy &Policy) const;\n};\n\n/// Symbolic representation of a dynamic allocation.\nclass DynamicAllocLValue {\n  unsigned Index;\n\npublic:\n  DynamicAllocLValue() : Index(0) {}\n  explicit DynamicAllocLValue(unsigned Index) : Index(Index + 1) {}\n  unsigned getIndex() { return Index - 1; }\n\n  explicit operator bool() const { return Index != 0; }\n\n  void *getOpaqueValue() {\n    return reinterpret_cast<void *>(static_cast<uintptr_t>(Index)\n                                    << NumLowBitsAvailable);\n  }\n  static DynamicAllocLValue getFromOpaqueValue(void *Value) {\n    DynamicAllocLValue V;\n    V.Index = reinterpret_cast<uintptr_t>(Value) >> NumLowBitsAvailable;\n    return V;\n  }\n\n  static unsigned getMaxIndex() {\n    return (std::numeric_limits<unsigned>::max() >> NumLowBitsAvailable) - 1;\n  }\n\n  static constexpr int NumLowBitsAvailable = 3;\n};\n}\n\nnamespace llvm {\ntemplate<> struct PointerLikeTypeTraits<clang::TypeInfoLValue> {\n  static void *getAsVoidPointer(clang::TypeInfoLValue V) {\n    return V.getOpaqueValue();\n  }\n  static clang::TypeInfoLValue getFromVoidPointer(void *P) {\n    return clang::TypeInfoLValue::getFromOpaqueValue(P);\n  }\n  // Validated by static_assert in APValue.cpp; hardcoded to avoid needing\n  // to include Type.h.\n  static constexpr int NumLowBitsAvailable = 3;\n};\n\ntemplate<> struct PointerLikeTypeTraits<clang::DynamicAllocLValue> {\n  static void *getAsVoidPointer(clang::DynamicAllocLValue V) {\n    return V.getOpaqueValue();\n  }\n  static clang::DynamicAllocLValue getFromVoidPointer(void *P) {\n    return clang::DynamicAllocLValue::getFromOpaqueValue(P);\n  }\n  static constexpr int NumLowBitsAvailable =\n      clang::DynamicAllocLValue::NumLowBitsAvailable;\n};\n}\n\nnamespace clang {\n/// APValue - This class implements a discriminated union of [uninitialized]\n/// [APSInt] [APFloat], [Complex APSInt] [Complex APFloat], [Expr + Offset],\n/// [Vector: N * APValue], [Array: N * APValue]\nclass APValue {\n  typedef llvm::APFixedPoint APFixedPoint;\n  typedef llvm::APSInt APSInt;\n  typedef llvm::APFloat APFloat;\npublic:\n  enum ValueKind {\n    /// There is no such object (it's outside its lifetime).\n    None,\n    /// This object has an indeterminate value (C++ [basic.indet]).\n    Indeterminate,\n    Int,\n    Float,\n    FixedPoint,\n    ComplexInt,\n    ComplexFloat,\n    LValue,\n    Vector,\n    Array,\n    Struct,\n    Union,\n    MemberPointer,\n    AddrLabelDiff\n  };\n\n  class LValueBase {\n    typedef llvm::PointerUnion<const ValueDecl *, const Expr *, TypeInfoLValue,\n                               DynamicAllocLValue>\n        PtrTy;\n\n  public:\n    LValueBase() : Local{} {}\n    LValueBase(const ValueDecl *P, unsigned I = 0, unsigned V = 0);\n    LValueBase(const Expr *P, unsigned I = 0, unsigned V = 0);\n    static LValueBase getDynamicAlloc(DynamicAllocLValue LV, QualType Type);\n    static LValueBase getTypeInfo(TypeInfoLValue LV, QualType TypeInfo);\n\n    void Profile(llvm::FoldingSetNodeID &ID) const;\n\n    template <class T>\n    bool is() const { return Ptr.is<T>(); }\n\n    template <class T>\n    T get() const { return Ptr.get<T>(); }\n\n    template <class T>\n    T dyn_cast() const { return Ptr.dyn_cast<T>(); }\n\n    void *getOpaqueValue() const;\n\n    bool isNull() const;\n\n    explicit operator bool() const;\n\n    unsigned getCallIndex() const;\n    unsigned getVersion() const;\n    QualType getTypeInfoType() const;\n    QualType getDynamicAllocType() const;\n\n    QualType getType() const;\n\n    friend bool operator==(const LValueBase &LHS, const LValueBase &RHS);\n    friend bool operator!=(const LValueBase &LHS, const LValueBase &RHS) {\n      return !(LHS == RHS);\n    }\n    friend llvm::hash_code hash_value(const LValueBase &Base);\n    friend struct llvm::DenseMapInfo<LValueBase>;\n\n  private:\n    PtrTy Ptr;\n    struct LocalState {\n      unsigned CallIndex, Version;\n    };\n    union {\n      LocalState Local;\n      /// The type std::type_info, if this is a TypeInfoLValue.\n      void *TypeInfoType;\n      /// The QualType, if this is a DynamicAllocLValue.\n      void *DynamicAllocType;\n    };\n  };\n\n  /// A FieldDecl or CXXRecordDecl, along with a flag indicating whether we\n  /// mean a virtual or non-virtual base class subobject.\n  typedef llvm::PointerIntPair<const Decl *, 1, bool> BaseOrMemberType;\n\n  /// A non-discriminated union of a base, field, or array index.\n  class LValuePathEntry {\n    static_assert(sizeof(uintptr_t) <= sizeof(uint64_t),\n                  \"pointer doesn't fit in 64 bits?\");\n    uint64_t Value;\n\n  public:\n    LValuePathEntry() : Value() {}\n    LValuePathEntry(BaseOrMemberType BaseOrMember);\n    static LValuePathEntry ArrayIndex(uint64_t Index) {\n      LValuePathEntry Result;\n      Result.Value = Index;\n      return Result;\n    }\n\n    BaseOrMemberType getAsBaseOrMember() const {\n      return BaseOrMemberType::getFromOpaqueValue(\n          reinterpret_cast<void *>(Value));\n    }\n    uint64_t getAsArrayIndex() const { return Value; }\n\n    void Profile(llvm::FoldingSetNodeID &ID) const;\n\n    friend bool operator==(LValuePathEntry A, LValuePathEntry B) {\n      return A.Value == B.Value;\n    }\n    friend bool operator!=(LValuePathEntry A, LValuePathEntry B) {\n      return A.Value != B.Value;\n    }\n    friend llvm::hash_code hash_value(LValuePathEntry A) {\n      return llvm::hash_value(A.Value);\n    }\n  };\n  class LValuePathSerializationHelper {\n    const void *ElemTy;\n\n  public:\n    ArrayRef<LValuePathEntry> Path;\n\n    LValuePathSerializationHelper(ArrayRef<LValuePathEntry>, QualType);\n    QualType getType();\n  };\n  struct NoLValuePath {};\n  struct UninitArray {};\n  struct UninitStruct {};\n\n  template <typename Impl> friend class clang::serialization::BasicReaderBase;\n  friend class ASTImporter;\n  friend class ASTNodeImporter;\n\nprivate:\n  ValueKind Kind;\n\n  struct ComplexAPSInt {\n    APSInt Real, Imag;\n    ComplexAPSInt() : Real(1), Imag(1) {}\n  };\n  struct ComplexAPFloat {\n    APFloat Real, Imag;\n    ComplexAPFloat() : Real(0.0), Imag(0.0) {}\n  };\n  struct LV;\n  struct Vec {\n    APValue *Elts;\n    unsigned NumElts;\n    Vec() : Elts(nullptr), NumElts(0) {}\n    ~Vec() { delete[] Elts; }\n  };\n  struct Arr {\n    APValue *Elts;\n    unsigned NumElts, ArrSize;\n    Arr(unsigned NumElts, unsigned ArrSize);\n    ~Arr();\n  };\n  struct StructData {\n    APValue *Elts;\n    unsigned NumBases;\n    unsigned NumFields;\n    StructData(unsigned NumBases, unsigned NumFields);\n    ~StructData();\n  };\n  struct UnionData {\n    const FieldDecl *Field;\n    APValue *Value;\n    UnionData();\n    ~UnionData();\n  };\n  struct AddrLabelDiffData {\n    const AddrLabelExpr* LHSExpr;\n    const AddrLabelExpr* RHSExpr;\n  };\n  struct MemberPointerData;\n\n  // We ensure elsewhere that Data is big enough for LV and MemberPointerData.\n  typedef llvm::AlignedCharArrayUnion<void *, APSInt, APFloat, ComplexAPSInt,\n                                      ComplexAPFloat, Vec, Arr, StructData,\n                                      UnionData, AddrLabelDiffData> DataType;\n  static const size_t DataSize = sizeof(DataType);\n\n  DataType Data;\n\npublic:\n  APValue() : Kind(None) {}\n  explicit APValue(APSInt I) : Kind(None) {\n    MakeInt(); setInt(std::move(I));\n  }\n  explicit APValue(APFloat F) : Kind(None) {\n    MakeFloat(); setFloat(std::move(F));\n  }\n  explicit APValue(APFixedPoint FX) : Kind(None) {\n    MakeFixedPoint(std::move(FX));\n  }\n  explicit APValue(const APValue *E, unsigned N) : Kind(None) {\n    MakeVector(); setVector(E, N);\n  }\n  APValue(APSInt R, APSInt I) : Kind(None) {\n    MakeComplexInt(); setComplexInt(std::move(R), std::move(I));\n  }\n  APValue(APFloat R, APFloat I) : Kind(None) {\n    MakeComplexFloat(); setComplexFloat(std::move(R), std::move(I));\n  }\n  APValue(const APValue &RHS);\n  APValue(APValue &&RHS);\n  APValue(LValueBase B, const CharUnits &O, NoLValuePath N,\n          bool IsNullPtr = false)\n      : Kind(None) {\n    MakeLValue(); setLValue(B, O, N, IsNullPtr);\n  }\n  APValue(LValueBase B, const CharUnits &O, ArrayRef<LValuePathEntry> Path,\n          bool OnePastTheEnd, bool IsNullPtr = false)\n      : Kind(None) {\n    MakeLValue(); setLValue(B, O, Path, OnePastTheEnd, IsNullPtr);\n  }\n  APValue(UninitArray, unsigned InitElts, unsigned Size) : Kind(None) {\n    MakeArray(InitElts, Size);\n  }\n  APValue(UninitStruct, unsigned B, unsigned M) : Kind(None) {\n    MakeStruct(B, M);\n  }\n  explicit APValue(const FieldDecl *D, const APValue &V = APValue())\n      : Kind(None) {\n    MakeUnion(); setUnion(D, V);\n  }\n  APValue(const ValueDecl *Member, bool IsDerivedMember,\n          ArrayRef<const CXXRecordDecl*> Path) : Kind(None) {\n    MakeMemberPointer(Member, IsDerivedMember, Path);\n  }\n  APValue(const AddrLabelExpr* LHSExpr, const AddrLabelExpr* RHSExpr)\n      : Kind(None) {\n    MakeAddrLabelDiff(); setAddrLabelDiff(LHSExpr, RHSExpr);\n  }\n  static APValue IndeterminateValue() {\n    APValue Result;\n    Result.Kind = Indeterminate;\n    return Result;\n  }\n\n  APValue &operator=(const APValue &RHS);\n  APValue &operator=(APValue &&RHS);\n\n  ~APValue() {\n    if (Kind != None && Kind != Indeterminate)\n      DestroyDataAndMakeUninit();\n  }\n\n  /// Returns whether the object performed allocations.\n  ///\n  /// If APValues are constructed via placement new, \\c needsCleanup()\n  /// indicates whether the destructor must be called in order to correctly\n  /// free all allocated memory.\n  bool needsCleanup() const;\n\n  /// Swaps the contents of this and the given APValue.\n  void swap(APValue &RHS);\n\n  /// profile this value. There is no guarantee that values of different\n  /// types will not produce the same profiled value, so the type should\n  /// typically also be profiled if it's not implied by the context.\n  void Profile(llvm::FoldingSetNodeID &ID) const;\n\n  ValueKind getKind() const { return Kind; }\n\n  bool isAbsent() const { return Kind == None; }\n  bool isIndeterminate() const { return Kind == Indeterminate; }\n  bool hasValue() const { return Kind != None && Kind != Indeterminate; }\n\n  bool isInt() const { return Kind == Int; }\n  bool isFloat() const { return Kind == Float; }\n  bool isFixedPoint() const { return Kind == FixedPoint; }\n  bool isComplexInt() const { return Kind == ComplexInt; }\n  bool isComplexFloat() const { return Kind == ComplexFloat; }\n  bool isLValue() const { return Kind == LValue; }\n  bool isVector() const { return Kind == Vector; }\n  bool isArray() const { return Kind == Array; }\n  bool isStruct() const { return Kind == Struct; }\n  bool isUnion() const { return Kind == Union; }\n  bool isMemberPointer() const { return Kind == MemberPointer; }\n  bool isAddrLabelDiff() const { return Kind == AddrLabelDiff; }\n\n  void dump() const;\n  void dump(raw_ostream &OS, const ASTContext &Context) const;\n\n  void printPretty(raw_ostream &OS, const ASTContext &Ctx, QualType Ty) const;\n  void printPretty(raw_ostream &OS, const PrintingPolicy &Policy, QualType Ty,\n                   const ASTContext *Ctx = nullptr) const;\n\n  std::string getAsString(const ASTContext &Ctx, QualType Ty) const;\n\n  APSInt &getInt() {\n    assert(isInt() && \"Invalid accessor\");\n    return *(APSInt *)(char *)&Data;\n  }\n  const APSInt &getInt() const {\n    return const_cast<APValue*>(this)->getInt();\n  }\n\n  /// Try to convert this value to an integral constant. This works if it's an\n  /// integer, null pointer, or offset from a null pointer. Returns true on\n  /// success.\n  bool toIntegralConstant(APSInt &Result, QualType SrcTy,\n                          const ASTContext &Ctx) const;\n\n  APFloat &getFloat() {\n    assert(isFloat() && \"Invalid accessor\");\n    return *(APFloat *)(char *)&Data;\n  }\n  const APFloat &getFloat() const {\n    return const_cast<APValue*>(this)->getFloat();\n  }\n\n  APFixedPoint &getFixedPoint() {\n    assert(isFixedPoint() && \"Invalid accessor\");\n    return *(APFixedPoint *)(char *)&Data;\n  }\n  const APFixedPoint &getFixedPoint() const {\n    return const_cast<APValue *>(this)->getFixedPoint();\n  }\n\n  APSInt &getComplexIntReal() {\n    assert(isComplexInt() && \"Invalid accessor\");\n    return ((ComplexAPSInt *)(char *)&Data)->Real;\n  }\n  const APSInt &getComplexIntReal() const {\n    return const_cast<APValue*>(this)->getComplexIntReal();\n  }\n\n  APSInt &getComplexIntImag() {\n    assert(isComplexInt() && \"Invalid accessor\");\n    return ((ComplexAPSInt *)(char *)&Data)->Imag;\n  }\n  const APSInt &getComplexIntImag() const {\n    return const_cast<APValue*>(this)->getComplexIntImag();\n  }\n\n  APFloat &getComplexFloatReal() {\n    assert(isComplexFloat() && \"Invalid accessor\");\n    return ((ComplexAPFloat *)(char *)&Data)->Real;\n  }\n  const APFloat &getComplexFloatReal() const {\n    return const_cast<APValue*>(this)->getComplexFloatReal();\n  }\n\n  APFloat &getComplexFloatImag() {\n    assert(isComplexFloat() && \"Invalid accessor\");\n    return ((ComplexAPFloat *)(char *)&Data)->Imag;\n  }\n  const APFloat &getComplexFloatImag() const {\n    return const_cast<APValue*>(this)->getComplexFloatImag();\n  }\n\n  const LValueBase getLValueBase() const;\n  CharUnits &getLValueOffset();\n  const CharUnits &getLValueOffset() const {\n    return const_cast<APValue*>(this)->getLValueOffset();\n  }\n  bool isLValueOnePastTheEnd() const;\n  bool hasLValuePath() const;\n  ArrayRef<LValuePathEntry> getLValuePath() const;\n  unsigned getLValueCallIndex() const;\n  unsigned getLValueVersion() const;\n  bool isNullPointer() const;\n\n  APValue &getVectorElt(unsigned I) {\n    assert(isVector() && \"Invalid accessor\");\n    assert(I < getVectorLength() && \"Index out of range\");\n    return ((Vec *)(char *)&Data)->Elts[I];\n  }\n  const APValue &getVectorElt(unsigned I) const {\n    return const_cast<APValue*>(this)->getVectorElt(I);\n  }\n  unsigned getVectorLength() const {\n    assert(isVector() && \"Invalid accessor\");\n    return ((const Vec *)(const void *)&Data)->NumElts;\n  }\n\n  APValue &getArrayInitializedElt(unsigned I) {\n    assert(isArray() && \"Invalid accessor\");\n    assert(I < getArrayInitializedElts() && \"Index out of range\");\n    return ((Arr *)(char *)&Data)->Elts[I];\n  }\n  const APValue &getArrayInitializedElt(unsigned I) const {\n    return const_cast<APValue*>(this)->getArrayInitializedElt(I);\n  }\n  bool hasArrayFiller() const {\n    return getArrayInitializedElts() != getArraySize();\n  }\n  APValue &getArrayFiller() {\n    assert(isArray() && \"Invalid accessor\");\n    assert(hasArrayFiller() && \"No array filler\");\n    return ((Arr *)(char *)&Data)->Elts[getArrayInitializedElts()];\n  }\n  const APValue &getArrayFiller() const {\n    return const_cast<APValue*>(this)->getArrayFiller();\n  }\n  unsigned getArrayInitializedElts() const {\n    assert(isArray() && \"Invalid accessor\");\n    return ((const Arr *)(const void *)&Data)->NumElts;\n  }\n  unsigned getArraySize() const {\n    assert(isArray() && \"Invalid accessor\");\n    return ((const Arr *)(const void *)&Data)->ArrSize;\n  }\n\n  unsigned getStructNumBases() const {\n    assert(isStruct() && \"Invalid accessor\");\n    return ((const StructData *)(const char *)&Data)->NumBases;\n  }\n  unsigned getStructNumFields() const {\n    assert(isStruct() && \"Invalid accessor\");\n    return ((const StructData *)(const char *)&Data)->NumFields;\n  }\n  APValue &getStructBase(unsigned i) {\n    assert(isStruct() && \"Invalid accessor\");\n    assert(i < getStructNumBases() && \"base class index OOB\");\n    return ((StructData *)(char *)&Data)->Elts[i];\n  }\n  APValue &getStructField(unsigned i) {\n    assert(isStruct() && \"Invalid accessor\");\n    assert(i < getStructNumFields() && \"field index OOB\");\n    return ((StructData *)(char *)&Data)->Elts[getStructNumBases() + i];\n  }\n  const APValue &getStructBase(unsigned i) const {\n    return const_cast<APValue*>(this)->getStructBase(i);\n  }\n  const APValue &getStructField(unsigned i) const {\n    return const_cast<APValue*>(this)->getStructField(i);\n  }\n\n  const FieldDecl *getUnionField() const {\n    assert(isUnion() && \"Invalid accessor\");\n    return ((const UnionData *)(const char *)&Data)->Field;\n  }\n  APValue &getUnionValue() {\n    assert(isUnion() && \"Invalid accessor\");\n    return *((UnionData *)(char *)&Data)->Value;\n  }\n  const APValue &getUnionValue() const {\n    return const_cast<APValue*>(this)->getUnionValue();\n  }\n\n  const ValueDecl *getMemberPointerDecl() const;\n  bool isMemberPointerToDerivedMember() const;\n  ArrayRef<const CXXRecordDecl*> getMemberPointerPath() const;\n\n  const AddrLabelExpr* getAddrLabelDiffLHS() const {\n    assert(isAddrLabelDiff() && \"Invalid accessor\");\n    return ((const AddrLabelDiffData *)(const char *)&Data)->LHSExpr;\n  }\n  const AddrLabelExpr* getAddrLabelDiffRHS() const {\n    assert(isAddrLabelDiff() && \"Invalid accessor\");\n    return ((const AddrLabelDiffData *)(const char *)&Data)->RHSExpr;\n  }\n\n  void setInt(APSInt I) {\n    assert(isInt() && \"Invalid accessor\");\n    *(APSInt *)(char *)&Data = std::move(I);\n  }\n  void setFloat(APFloat F) {\n    assert(isFloat() && \"Invalid accessor\");\n    *(APFloat *)(char *)&Data = std::move(F);\n  }\n  void setFixedPoint(APFixedPoint FX) {\n    assert(isFixedPoint() && \"Invalid accessor\");\n    *(APFixedPoint *)(char *)&Data = std::move(FX);\n  }\n  void setVector(const APValue *E, unsigned N) {\n    MutableArrayRef<APValue> InternalElts = setVectorUninit(N);\n    for (unsigned i = 0; i != N; ++i)\n      InternalElts[i] = E[i];\n  }\n  void setComplexInt(APSInt R, APSInt I) {\n    assert(R.getBitWidth() == I.getBitWidth() &&\n           \"Invalid complex int (type mismatch).\");\n    assert(isComplexInt() && \"Invalid accessor\");\n    ((ComplexAPSInt *)(char *)&Data)->Real = std::move(R);\n    ((ComplexAPSInt *)(char *)&Data)->Imag = std::move(I);\n  }\n  void setComplexFloat(APFloat R, APFloat I) {\n    assert(&R.getSemantics() == &I.getSemantics() &&\n           \"Invalid complex float (type mismatch).\");\n    assert(isComplexFloat() && \"Invalid accessor\");\n    ((ComplexAPFloat *)(char *)&Data)->Real = std::move(R);\n    ((ComplexAPFloat *)(char *)&Data)->Imag = std::move(I);\n  }\n  void setLValue(LValueBase B, const CharUnits &O, NoLValuePath,\n                 bool IsNullPtr);\n  void setLValue(LValueBase B, const CharUnits &O,\n                 ArrayRef<LValuePathEntry> Path, bool OnePastTheEnd,\n                 bool IsNullPtr);\n  void setUnion(const FieldDecl *Field, const APValue &Value);\n  void setAddrLabelDiff(const AddrLabelExpr* LHSExpr,\n                        const AddrLabelExpr* RHSExpr) {\n    ((AddrLabelDiffData *)(char *)&Data)->LHSExpr = LHSExpr;\n    ((AddrLabelDiffData *)(char *)&Data)->RHSExpr = RHSExpr;\n  }\n\nprivate:\n  void DestroyDataAndMakeUninit();\n  void MakeInt() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)&Data) APSInt(1);\n    Kind = Int;\n  }\n  void MakeFloat() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) APFloat(0.0);\n    Kind = Float;\n  }\n  void MakeFixedPoint(APFixedPoint &&FX) {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) APFixedPoint(std::move(FX));\n    Kind = FixedPoint;\n  }\n  void MakeVector() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) Vec();\n    Kind = Vector;\n  }\n  void MakeComplexInt() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) ComplexAPSInt();\n    Kind = ComplexInt;\n  }\n  void MakeComplexFloat() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) ComplexAPFloat();\n    Kind = ComplexFloat;\n  }\n  void MakeLValue();\n  void MakeArray(unsigned InitElts, unsigned Size);\n  void MakeStruct(unsigned B, unsigned M) {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) StructData(B, M);\n    Kind = Struct;\n  }\n  void MakeUnion() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) UnionData();\n    Kind = Union;\n  }\n  void MakeMemberPointer(const ValueDecl *Member, bool IsDerivedMember,\n                         ArrayRef<const CXXRecordDecl*> Path);\n  void MakeAddrLabelDiff() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) AddrLabelDiffData();\n    Kind = AddrLabelDiff;\n  }\n\nprivate:\n  /// The following functions are used as part of initialization, during\n  /// deserialization and importing. Reserve the space so that it can be\n  /// filled in by those steps.\n  MutableArrayRef<APValue> setVectorUninit(unsigned N) {\n    assert(isVector() && \"Invalid accessor\");\n    Vec *V = ((Vec *)(char *)&Data);\n    V->Elts = new APValue[N];\n    V->NumElts = N;\n    return {V->Elts, V->NumElts};\n  }\n  MutableArrayRef<LValuePathEntry>\n  setLValueUninit(LValueBase B, const CharUnits &O, unsigned Size,\n                  bool OnePastTheEnd, bool IsNullPtr);\n  MutableArrayRef<const CXXRecordDecl *>\n  setMemberPointerUninit(const ValueDecl *Member, bool IsDerivedMember,\n                         unsigned Size);\n};\n\n} // end namespace clang.\n\nnamespace llvm {\ntemplate<> struct DenseMapInfo<clang::APValue::LValueBase> {\n  static clang::APValue::LValueBase getEmptyKey();\n  static clang::APValue::LValueBase getTombstoneKey();\n  static unsigned getHashValue(const clang::APValue::LValueBase &Base);\n  static bool isEqual(const clang::APValue::LValueBase &LHS,\n                      const clang::APValue::LValueBase &RHS);\n};\n}\n\n#endif\n"}, "28": {"id": 28, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Decl.h", "content": "//===- Decl.h - Classes for representing declarations -----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the Decl subclasses.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_DECL_H\n#define LLVM_CLANG_AST_DECL_H\n\n#include \"clang/AST/APValue.h\"\n#include \"clang/AST/ASTContextAllocate.h\"\n#include \"clang/AST/DeclAccessPair.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/ExternalASTSource.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/Redeclarable.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/AddressSpaces.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/Linkage.h\"\n#include \"clang/Basic/OperatorKinds.h\"\n#include \"clang/Basic/PartialDiagnostic.h\"\n#include \"clang/Basic/PragmaKinds.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Basic/Visibility.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <string>\n#include <utility>\n\nnamespace clang {\n\nclass ASTContext;\nstruct ASTTemplateArgumentListInfo;\nclass Attr;\nclass CompoundStmt;\nclass DependentFunctionTemplateSpecializationInfo;\nclass EnumDecl;\nclass Expr;\nclass FunctionTemplateDecl;\nclass FunctionTemplateSpecializationInfo;\nclass FunctionTypeLoc;\nclass LabelStmt;\nclass MemberSpecializationInfo;\nclass Module;\nclass NamespaceDecl;\nclass ParmVarDecl;\nclass RecordDecl;\nclass Stmt;\nclass StringLiteral;\nclass TagDecl;\nclass TemplateArgumentList;\nclass TemplateArgumentListInfo;\nclass TemplateParameterList;\nclass TypeAliasTemplateDecl;\nclass TypeLoc;\nclass UnresolvedSetImpl;\nclass VarTemplateDecl;\n\n/// The top declaration context.\nclass TranslationUnitDecl : public Decl, public DeclContext {\n  ASTContext &Ctx;\n\n  /// The (most recently entered) anonymous namespace for this\n  /// translation unit, if one has been created.\n  NamespaceDecl *AnonymousNamespace = nullptr;\n\n  explicit TranslationUnitDecl(ASTContext &ctx);\n\n  virtual void anchor();\n\npublic:\n  ASTContext &getASTContext() const { return Ctx; }\n\n  NamespaceDecl *getAnonymousNamespace() const { return AnonymousNamespace; }\n  void setAnonymousNamespace(NamespaceDecl *D) { AnonymousNamespace = D; }\n\n  static TranslationUnitDecl *Create(ASTContext &C);\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == TranslationUnit; }\n  static DeclContext *castToDeclContext(const TranslationUnitDecl *D) {\n    return static_cast<DeclContext *>(const_cast<TranslationUnitDecl*>(D));\n  }\n  static TranslationUnitDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<TranslationUnitDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Represents a `#pragma comment` line. Always a child of\n/// TranslationUnitDecl.\nclass PragmaCommentDecl final\n    : public Decl,\n      private llvm::TrailingObjects<PragmaCommentDecl, char> {\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend TrailingObjects;\n\n  PragmaMSCommentKind CommentKind;\n\n  PragmaCommentDecl(TranslationUnitDecl *TU, SourceLocation CommentLoc,\n                    PragmaMSCommentKind CommentKind)\n      : Decl(PragmaComment, TU, CommentLoc), CommentKind(CommentKind) {}\n\n  virtual void anchor();\n\npublic:\n  static PragmaCommentDecl *Create(const ASTContext &C, TranslationUnitDecl *DC,\n                                   SourceLocation CommentLoc,\n                                   PragmaMSCommentKind CommentKind,\n                                   StringRef Arg);\n  static PragmaCommentDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                               unsigned ArgSize);\n\n  PragmaMSCommentKind getCommentKind() const { return CommentKind; }\n\n  StringRef getArg() const { return getTrailingObjects<char>(); }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == PragmaComment; }\n};\n\n/// Represents a `#pragma detect_mismatch` line. Always a child of\n/// TranslationUnitDecl.\nclass PragmaDetectMismatchDecl final\n    : public Decl,\n      private llvm::TrailingObjects<PragmaDetectMismatchDecl, char> {\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend TrailingObjects;\n\n  size_t ValueStart;\n\n  PragmaDetectMismatchDecl(TranslationUnitDecl *TU, SourceLocation Loc,\n                           size_t ValueStart)\n      : Decl(PragmaDetectMismatch, TU, Loc), ValueStart(ValueStart) {}\n\n  virtual void anchor();\n\npublic:\n  static PragmaDetectMismatchDecl *Create(const ASTContext &C,\n                                          TranslationUnitDecl *DC,\n                                          SourceLocation Loc, StringRef Name,\n                                          StringRef Value);\n  static PragmaDetectMismatchDecl *\n  CreateDeserialized(ASTContext &C, unsigned ID, unsigned NameValueSize);\n\n  StringRef getName() const { return getTrailingObjects<char>(); }\n  StringRef getValue() const { return getTrailingObjects<char>() + ValueStart; }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == PragmaDetectMismatch; }\n};\n\n/// Declaration context for names declared as extern \"C\" in C++. This\n/// is neither the semantic nor lexical context for such declarations, but is\n/// used to check for conflicts with other extern \"C\" declarations. Example:\n///\n/// \\code\n///   namespace N { extern \"C\" void f(); } // #1\n///   void N::f() {}                       // #2\n///   namespace M { extern \"C\" void f(); } // #3\n/// \\endcode\n///\n/// The semantic context of #1 is namespace N and its lexical context is the\n/// LinkageSpecDecl; the semantic context of #2 is namespace N and its lexical\n/// context is the TU. However, both declarations are also visible in the\n/// extern \"C\" context.\n///\n/// The declaration at #3 finds it is a redeclaration of \\c N::f through\n/// lookup in the extern \"C\" context.\nclass ExternCContextDecl : public Decl, public DeclContext {\n  explicit ExternCContextDecl(TranslationUnitDecl *TU)\n    : Decl(ExternCContext, TU, SourceLocation()),\n      DeclContext(ExternCContext) {}\n\n  virtual void anchor();\n\npublic:\n  static ExternCContextDecl *Create(const ASTContext &C,\n                                    TranslationUnitDecl *TU);\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ExternCContext; }\n  static DeclContext *castToDeclContext(const ExternCContextDecl *D) {\n    return static_cast<DeclContext *>(const_cast<ExternCContextDecl*>(D));\n  }\n  static ExternCContextDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<ExternCContextDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// This represents a decl that may have a name.  Many decls have names such\n/// as ObjCMethodDecl, but not \\@class, etc.\n///\n/// Note that not every NamedDecl is actually named (e.g., a struct might\n/// be anonymous), and not every name is an identifier.\nclass NamedDecl : public Decl {\n  /// The name of this declaration, which is typically a normal\n  /// identifier but may also be a special kind of name (C++\n  /// constructor, Objective-C selector, etc.)\n  DeclarationName Name;\n\n  virtual void anchor();\n\nprivate:\n  NamedDecl *getUnderlyingDeclImpl() LLVM_READONLY;\n\nprotected:\n  NamedDecl(Kind DK, DeclContext *DC, SourceLocation L, DeclarationName N)\n      : Decl(DK, DC, L), Name(N) {}\n\npublic:\n  /// Get the identifier that names this declaration, if there is one.\n  ///\n  /// This will return NULL if this declaration has no name (e.g., for\n  /// an unnamed class) or if the name is a special name (C++ constructor,\n  /// Objective-C selector, etc.).\n  IdentifierInfo *getIdentifier() const { return Name.getAsIdentifierInfo(); }\n\n  /// Get the name of identifier for this declaration as a StringRef.\n  ///\n  /// This requires that the declaration have a name and that it be a simple\n  /// identifier.\n  StringRef getName() const {\n    assert(Name.isIdentifier() && \"Name is not a simple identifier\");\n    return getIdentifier() ? getIdentifier()->getName() : \"\";\n  }\n\n  /// Get a human-readable name for the declaration, even if it is one of the\n  /// special kinds of names (C++ constructor, Objective-C selector, etc).\n  ///\n  /// Creating this name requires expensive string manipulation, so it should\n  /// be called only when performance doesn't matter. For simple declarations,\n  /// getNameAsCString() should suffice.\n  //\n  // FIXME: This function should be renamed to indicate that it is not just an\n  // alternate form of getName(), and clients should move as appropriate.\n  //\n  // FIXME: Deprecated, move clients to getName().\n  std::string getNameAsString() const { return Name.getAsString(); }\n\n  /// Pretty-print the unqualified name of this declaration. Can be overloaded\n  /// by derived classes to provide a more user-friendly name when appropriate.\n  virtual void printName(raw_ostream &os) const;\n\n  /// Get the actual, stored name of the declaration, which may be a special\n  /// name.\n  ///\n  /// Note that generally in diagnostics, the non-null \\p NamedDecl* itself\n  /// should be sent into the diagnostic instead of using the result of\n  /// \\p getDeclName().\n  ///\n  /// A \\p DeclarationName in a diagnostic will just be streamed to the output,\n  /// which will directly result in a call to \\p DeclarationName::print.\n  ///\n  /// A \\p NamedDecl* in a diagnostic will also ultimately result in a call to\n  /// \\p DeclarationName::print, but with two customisation points along the\n  /// way (\\p getNameForDiagnostic and \\p printName). These are used to print\n  /// the template arguments if any, and to provide a user-friendly name for\n  /// some entities (such as unnamed variables and anonymous records).\n  DeclarationName getDeclName() const { return Name; }\n\n  /// Set the name of this declaration.\n  void setDeclName(DeclarationName N) { Name = N; }\n\n  /// Returns a human-readable qualified name for this declaration, like\n  /// A::B::i, for i being member of namespace A::B.\n  ///\n  /// If the declaration is not a member of context which can be named (record,\n  /// namespace), it will return the same result as printName().\n  ///\n  /// Creating this name is expensive, so it should be called only when\n  /// performance doesn't matter.\n  void printQualifiedName(raw_ostream &OS) const;\n  void printQualifiedName(raw_ostream &OS, const PrintingPolicy &Policy) const;\n\n  /// Print only the nested name specifier part of a fully-qualified name,\n  /// including the '::' at the end. E.g.\n  ///    when `printQualifiedName(D)` prints \"A::B::i\",\n  ///    this function prints \"A::B::\".\n  void printNestedNameSpecifier(raw_ostream &OS) const;\n  void printNestedNameSpecifier(raw_ostream &OS,\n                                const PrintingPolicy &Policy) const;\n\n  // FIXME: Remove string version.\n  std::string getQualifiedNameAsString() const;\n\n  /// Appends a human-readable name for this declaration into the given stream.\n  ///\n  /// This is the method invoked by Sema when displaying a NamedDecl\n  /// in a diagnostic.  It does not necessarily produce the same\n  /// result as printName(); for example, class template\n  /// specializations are printed with their template arguments.\n  virtual void getNameForDiagnostic(raw_ostream &OS,\n                                    const PrintingPolicy &Policy,\n                                    bool Qualified) const;\n\n  /// Determine whether this declaration, if known to be well-formed within\n  /// its context, will replace the declaration OldD if introduced into scope.\n  ///\n  /// A declaration will replace another declaration if, for example, it is\n  /// a redeclaration of the same variable or function, but not if it is a\n  /// declaration of a different kind (function vs. class) or an overloaded\n  /// function.\n  ///\n  /// \\param IsKnownNewer \\c true if this declaration is known to be newer\n  /// than \\p OldD (for instance, if this declaration is newly-created).\n  bool declarationReplaces(NamedDecl *OldD, bool IsKnownNewer = true) const;\n\n  /// Determine whether this declaration has linkage.\n  bool hasLinkage() const;\n\n  using Decl::isModulePrivate;\n  using Decl::setModulePrivate;\n\n  /// Determine whether this declaration is a C++ class member.\n  bool isCXXClassMember() const {\n    const DeclContext *DC = getDeclContext();\n\n    // C++0x [class.mem]p1:\n    //   The enumerators of an unscoped enumeration defined in\n    //   the class are members of the class.\n    if (isa<EnumDecl>(DC))\n      DC = DC->getRedeclContext();\n\n    return DC->isRecord();\n  }\n\n  /// Determine whether the given declaration is an instance member of\n  /// a C++ class.\n  bool isCXXInstanceMember() const;\n\n  /// Determine what kind of linkage this entity has.\n  ///\n  /// This is not the linkage as defined by the standard or the codegen notion\n  /// of linkage. It is just an implementation detail that is used to compute\n  /// those.\n  Linkage getLinkageInternal() const;\n\n  /// Get the linkage from a semantic point of view. Entities in\n  /// anonymous namespaces are external (in c++98).\n  Linkage getFormalLinkage() const {\n    return clang::getFormalLinkage(getLinkageInternal());\n  }\n\n  /// True if this decl has external linkage.\n  bool hasExternalFormalLinkage() const {\n    return isExternalFormalLinkage(getLinkageInternal());\n  }\n\n  bool isExternallyVisible() const {\n    return clang::isExternallyVisible(getLinkageInternal());\n  }\n\n  /// Determine whether this declaration can be redeclared in a\n  /// different translation unit.\n  bool isExternallyDeclarable() const {\n    return isExternallyVisible() && !getOwningModuleForLinkage();\n  }\n\n  /// Determines the visibility of this entity.\n  Visibility getVisibility() const {\n    return getLinkageAndVisibility().getVisibility();\n  }\n\n  /// Determines the linkage and visibility of this entity.\n  LinkageInfo getLinkageAndVisibility() const;\n\n  /// Kinds of explicit visibility.\n  enum ExplicitVisibilityKind {\n    /// Do an LV computation for, ultimately, a type.\n    /// Visibility may be restricted by type visibility settings and\n    /// the visibility of template arguments.\n    VisibilityForType,\n\n    /// Do an LV computation for, ultimately, a non-type declaration.\n    /// Visibility may be restricted by value visibility settings and\n    /// the visibility of template arguments.\n    VisibilityForValue\n  };\n\n  /// If visibility was explicitly specified for this\n  /// declaration, return that visibility.\n  Optional<Visibility>\n  getExplicitVisibility(ExplicitVisibilityKind kind) const;\n\n  /// True if the computed linkage is valid. Used for consistency\n  /// checking. Should always return true.\n  bool isLinkageValid() const;\n\n  /// True if something has required us to compute the linkage\n  /// of this declaration.\n  ///\n  /// Language features which can retroactively change linkage (like a\n  /// typedef name for linkage purposes) may need to consider this,\n  /// but hopefully only in transitory ways during parsing.\n  bool hasLinkageBeenComputed() const {\n    return hasCachedLinkage();\n  }\n\n  /// Looks through UsingDecls and ObjCCompatibleAliasDecls for\n  /// the underlying named decl.\n  NamedDecl *getUnderlyingDecl() {\n    // Fast-path the common case.\n    if (this->getKind() != UsingShadow &&\n        this->getKind() != ConstructorUsingShadow &&\n        this->getKind() != ObjCCompatibleAlias &&\n        this->getKind() != NamespaceAlias)\n      return this;\n\n    return getUnderlyingDeclImpl();\n  }\n  const NamedDecl *getUnderlyingDecl() const {\n    return const_cast<NamedDecl*>(this)->getUnderlyingDecl();\n  }\n\n  NamedDecl *getMostRecentDecl() {\n    return cast<NamedDecl>(static_cast<Decl *>(this)->getMostRecentDecl());\n  }\n  const NamedDecl *getMostRecentDecl() const {\n    return const_cast<NamedDecl*>(this)->getMostRecentDecl();\n  }\n\n  ObjCStringFormatFamily getObjCFStringFormattingFamily() const;\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K >= firstNamed && K <= lastNamed; }\n};\n\ninline raw_ostream &operator<<(raw_ostream &OS, const NamedDecl &ND) {\n  ND.printName(OS);\n  return OS;\n}\n\n/// Represents the declaration of a label.  Labels also have a\n/// corresponding LabelStmt, which indicates the position that the label was\n/// defined at.  For normal labels, the location of the decl is the same as the\n/// location of the statement.  For GNU local labels (__label__), the decl\n/// location is where the __label__ is.\nclass LabelDecl : public NamedDecl {\n  LabelStmt *TheStmt;\n  StringRef MSAsmName;\n  bool MSAsmNameResolved = false;\n\n  /// For normal labels, this is the same as the main declaration\n  /// label, i.e., the location of the identifier; for GNU local labels,\n  /// this is the location of the __label__ keyword.\n  SourceLocation LocStart;\n\n  LabelDecl(DeclContext *DC, SourceLocation IdentL, IdentifierInfo *II,\n            LabelStmt *S, SourceLocation StartL)\n      : NamedDecl(Label, DC, IdentL, II), TheStmt(S), LocStart(StartL) {}\n\n  void anchor() override;\n\npublic:\n  static LabelDecl *Create(ASTContext &C, DeclContext *DC,\n                           SourceLocation IdentL, IdentifierInfo *II);\n  static LabelDecl *Create(ASTContext &C, DeclContext *DC,\n                           SourceLocation IdentL, IdentifierInfo *II,\n                           SourceLocation GnuLabelL);\n  static LabelDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  LabelStmt *getStmt() const { return TheStmt; }\n  void setStmt(LabelStmt *T) { TheStmt = T; }\n\n  bool isGnuLocal() const { return LocStart != getLocation(); }\n  void setLocStart(SourceLocation L) { LocStart = L; }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(LocStart, getLocation());\n  }\n\n  bool isMSAsmLabel() const { return !MSAsmName.empty(); }\n  bool isResolvedMSAsmLabel() const { return isMSAsmLabel() && MSAsmNameResolved; }\n  void setMSAsmLabel(StringRef Name);\n  StringRef getMSAsmLabel() const { return MSAsmName; }\n  void setMSAsmLabelResolved() { MSAsmNameResolved = true; }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Label; }\n};\n\n/// Represent a C++ namespace.\nclass NamespaceDecl : public NamedDecl, public DeclContext,\n                      public Redeclarable<NamespaceDecl>\n{\n  /// The starting location of the source range, pointing\n  /// to either the namespace or the inline keyword.\n  SourceLocation LocStart;\n\n  /// The ending location of the source range.\n  SourceLocation RBraceLoc;\n\n  /// A pointer to either the anonymous namespace that lives just inside\n  /// this namespace or to the first namespace in the chain (the latter case\n  /// only when this is not the first in the chain), along with a\n  /// boolean value indicating whether this is an inline namespace.\n  llvm::PointerIntPair<NamespaceDecl *, 1, bool> AnonOrFirstNamespaceAndInline;\n\n  NamespaceDecl(ASTContext &C, DeclContext *DC, bool Inline,\n                SourceLocation StartLoc, SourceLocation IdLoc,\n                IdentifierInfo *Id, NamespaceDecl *PrevDecl);\n\n  using redeclarable_base = Redeclarable<NamespaceDecl>;\n\n  NamespaceDecl *getNextRedeclarationImpl() override;\n  NamespaceDecl *getPreviousDeclImpl() override;\n  NamespaceDecl *getMostRecentDeclImpl() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static NamespaceDecl *Create(ASTContext &C, DeclContext *DC,\n                               bool Inline, SourceLocation StartLoc,\n                               SourceLocation IdLoc, IdentifierInfo *Id,\n                               NamespaceDecl *PrevDecl);\n\n  static NamespaceDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  /// Returns true if this is an anonymous namespace declaration.\n  ///\n  /// For example:\n  /// \\code\n  ///   namespace {\n  ///     ...\n  ///   };\n  /// \\endcode\n  /// q.v. C++ [namespace.unnamed]\n  bool isAnonymousNamespace() const {\n    return !getIdentifier();\n  }\n\n  /// Returns true if this is an inline namespace declaration.\n  bool isInline() const {\n    return AnonOrFirstNamespaceAndInline.getInt();\n  }\n\n  /// Set whether this is an inline namespace declaration.\n  void setInline(bool Inline) {\n    AnonOrFirstNamespaceAndInline.setInt(Inline);\n  }\n\n  /// Get the original (first) namespace declaration.\n  NamespaceDecl *getOriginalNamespace();\n\n  /// Get the original (first) namespace declaration.\n  const NamespaceDecl *getOriginalNamespace() const;\n\n  /// Return true if this declaration is an original (first) declaration\n  /// of the namespace. This is false for non-original (subsequent) namespace\n  /// declarations and anonymous namespaces.\n  bool isOriginalNamespace() const;\n\n  /// Retrieve the anonymous namespace nested inside this namespace,\n  /// if any.\n  NamespaceDecl *getAnonymousNamespace() const {\n    return getOriginalNamespace()->AnonOrFirstNamespaceAndInline.getPointer();\n  }\n\n  void setAnonymousNamespace(NamespaceDecl *D) {\n    getOriginalNamespace()->AnonOrFirstNamespaceAndInline.setPointer(D);\n  }\n\n  /// Retrieves the canonical declaration of this namespace.\n  NamespaceDecl *getCanonicalDecl() override {\n    return getOriginalNamespace();\n  }\n  const NamespaceDecl *getCanonicalDecl() const {\n    return getOriginalNamespace();\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(LocStart, RBraceLoc);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return LocStart; }\n  SourceLocation getRBraceLoc() const { return RBraceLoc; }\n  void setLocStart(SourceLocation L) { LocStart = L; }\n  void setRBraceLoc(SourceLocation L) { RBraceLoc = L; }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Namespace; }\n  static DeclContext *castToDeclContext(const NamespaceDecl *D) {\n    return static_cast<DeclContext *>(const_cast<NamespaceDecl*>(D));\n  }\n  static NamespaceDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<NamespaceDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Represent the declaration of a variable (in which case it is\n/// an lvalue) a function (in which case it is a function designator) or\n/// an enum constant.\nclass ValueDecl : public NamedDecl {\n  QualType DeclType;\n\n  void anchor() override;\n\nprotected:\n  ValueDecl(Kind DK, DeclContext *DC, SourceLocation L,\n            DeclarationName N, QualType T)\n    : NamedDecl(DK, DC, L, N), DeclType(T) {}\n\npublic:\n  QualType getType() const { return DeclType; }\n  void setType(QualType newType) { DeclType = newType; }\n\n  /// Determine whether this symbol is weakly-imported,\n  ///        or declared with the weak or weak-ref attr.\n  bool isWeak() const;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K >= firstValue && K <= lastValue; }\n};\n\n/// A struct with extended info about a syntactic\n/// name qualifier, to be used for the case of out-of-line declarations.\nstruct QualifierInfo {\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// The number of \"outer\" template parameter lists.\n  /// The count includes all of the template parameter lists that were matched\n  /// against the template-ids occurring into the NNS and possibly (in the\n  /// case of an explicit specialization) a final \"template <>\".\n  unsigned NumTemplParamLists = 0;\n\n  /// A new-allocated array of size NumTemplParamLists,\n  /// containing pointers to the \"outer\" template parameter lists.\n  /// It includes all of the template parameter lists that were matched\n  /// against the template-ids occurring into the NNS and possibly (in the\n  /// case of an explicit specialization) a final \"template <>\".\n  TemplateParameterList** TemplParamLists = nullptr;\n\n  QualifierInfo() = default;\n  QualifierInfo(const QualifierInfo &) = delete;\n  QualifierInfo& operator=(const QualifierInfo &) = delete;\n\n  /// Sets info about \"outer\" template parameter lists.\n  void setTemplateParameterListsInfo(ASTContext &Context,\n                                     ArrayRef<TemplateParameterList *> TPLists);\n};\n\n/// Represents a ValueDecl that came out of a declarator.\n/// Contains type source information through TypeSourceInfo.\nclass DeclaratorDecl : public ValueDecl {\n  // A struct representing a TInfo, a trailing requires-clause and a syntactic\n  // qualifier, to be used for the (uncommon) case of out-of-line declarations\n  // and constrained function decls.\n  struct ExtInfo : public QualifierInfo {\n    TypeSourceInfo *TInfo;\n    Expr *TrailingRequiresClause = nullptr;\n  };\n\n  llvm::PointerUnion<TypeSourceInfo *, ExtInfo *> DeclInfo;\n\n  /// The start of the source range for this declaration,\n  /// ignoring outer template declarations.\n  SourceLocation InnerLocStart;\n\n  bool hasExtInfo() const { return DeclInfo.is<ExtInfo*>(); }\n  ExtInfo *getExtInfo() { return DeclInfo.get<ExtInfo*>(); }\n  const ExtInfo *getExtInfo() const { return DeclInfo.get<ExtInfo*>(); }\n\nprotected:\n  DeclaratorDecl(Kind DK, DeclContext *DC, SourceLocation L,\n                 DeclarationName N, QualType T, TypeSourceInfo *TInfo,\n                 SourceLocation StartL)\n      : ValueDecl(DK, DC, L, N, T), DeclInfo(TInfo), InnerLocStart(StartL) {}\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return hasExtInfo()\n      ? getExtInfo()->TInfo\n      : DeclInfo.get<TypeSourceInfo*>();\n  }\n\n  void setTypeSourceInfo(TypeSourceInfo *TI) {\n    if (hasExtInfo())\n      getExtInfo()->TInfo = TI;\n    else\n      DeclInfo = TI;\n  }\n\n  /// Return start of source range ignoring outer template declarations.\n  SourceLocation getInnerLocStart() const { return InnerLocStart; }\n  void setInnerLocStart(SourceLocation L) { InnerLocStart = L; }\n\n  /// Return start of source range taking into account any outer template\n  /// declarations.\n  SourceLocation getOuterLocStart() const;\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getOuterLocStart();\n  }\n\n  /// Retrieve the nested-name-specifier that qualifies the name of this\n  /// declaration, if it was present in the source.\n  NestedNameSpecifier *getQualifier() const {\n    return hasExtInfo() ? getExtInfo()->QualifierLoc.getNestedNameSpecifier()\n                        : nullptr;\n  }\n\n  /// Retrieve the nested-name-specifier (with source-location\n  /// information) that qualifies the name of this declaration, if it was\n  /// present in the source.\n  NestedNameSpecifierLoc getQualifierLoc() const {\n    return hasExtInfo() ? getExtInfo()->QualifierLoc\n                        : NestedNameSpecifierLoc();\n  }\n\n  void setQualifierInfo(NestedNameSpecifierLoc QualifierLoc);\n\n  /// \\brief Get the constraint-expression introduced by the trailing\n  /// requires-clause in the function/member declaration, or null if no\n  /// requires-clause was provided.\n  Expr *getTrailingRequiresClause() {\n    return hasExtInfo() ? getExtInfo()->TrailingRequiresClause\n                        : nullptr;\n  }\n\n  const Expr *getTrailingRequiresClause() const {\n    return hasExtInfo() ? getExtInfo()->TrailingRequiresClause\n                        : nullptr;\n  }\n\n  void setTrailingRequiresClause(Expr *TrailingRequiresClause);\n\n  unsigned getNumTemplateParameterLists() const {\n    return hasExtInfo() ? getExtInfo()->NumTemplParamLists : 0;\n  }\n\n  TemplateParameterList *getTemplateParameterList(unsigned index) const {\n    assert(index < getNumTemplateParameterLists());\n    return getExtInfo()->TemplParamLists[index];\n  }\n\n  void setTemplateParameterListsInfo(ASTContext &Context,\n                                     ArrayRef<TemplateParameterList *> TPLists);\n\n  SourceLocation getTypeSpecStartLoc() const;\n  SourceLocation getTypeSpecEndLoc() const;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K >= firstDeclarator && K <= lastDeclarator;\n  }\n};\n\n/// Structure used to store a statement, the constant value to\n/// which it was evaluated (if any), and whether or not the statement\n/// is an integral constant expression (if known).\nstruct EvaluatedStmt {\n  /// Whether this statement was already evaluated.\n  bool WasEvaluated : 1;\n\n  /// Whether this statement is being evaluated.\n  bool IsEvaluating : 1;\n\n  /// Whether this variable is known to have constant initialization. This is\n  /// currently only computed in C++, for static / thread storage duration\n  /// variables that might have constant initialization and for variables that\n  /// are usable in constant expressions.\n  bool HasConstantInitialization : 1;\n\n  /// Whether this variable is known to have constant destruction. That is,\n  /// whether running the destructor on the initial value is a side-effect\n  /// (and doesn't inspect any state that might have changed during program\n  /// execution). This is currently only computed if the destructor is\n  /// non-trivial.\n  bool HasConstantDestruction : 1;\n\n  /// In C++98, whether the initializer is an ICE. This affects whether the\n  /// variable is usable in constant expressions.\n  bool HasICEInit : 1;\n  bool CheckedForICEInit : 1;\n\n  Stmt *Value;\n  APValue Evaluated;\n\n  EvaluatedStmt()\n      : WasEvaluated(false), IsEvaluating(false),\n        HasConstantInitialization(false), HasConstantDestruction(false),\n        HasICEInit(false), CheckedForICEInit(false) {}\n};\n\n/// Represents a variable declaration or definition.\nclass VarDecl : public DeclaratorDecl, public Redeclarable<VarDecl> {\npublic:\n  /// Initialization styles.\n  enum InitializationStyle {\n    /// C-style initialization with assignment\n    CInit,\n\n    /// Call-style initialization (C++98)\n    CallInit,\n\n    /// Direct list-initialization (C++11)\n    ListInit\n  };\n\n  /// Kinds of thread-local storage.\n  enum TLSKind {\n    /// Not a TLS variable.\n    TLS_None,\n\n    /// TLS with a known-constant initializer.\n    TLS_Static,\n\n    /// TLS with a dynamic initializer.\n    TLS_Dynamic\n  };\n\n  /// Return the string used to specify the storage class \\p SC.\n  ///\n  /// It is illegal to call this function with SC == None.\n  static const char *getStorageClassSpecifierString(StorageClass SC);\n\nprotected:\n  // A pointer union of Stmt * and EvaluatedStmt *. When an EvaluatedStmt, we\n  // have allocated the auxiliary struct of information there.\n  //\n  // TODO: It is a bit unfortunate to use a PointerUnion inside the VarDecl for\n  // this as *many* VarDecls are ParmVarDecls that don't have default\n  // arguments. We could save some space by moving this pointer union to be\n  // allocated in trailing space when necessary.\n  using InitType = llvm::PointerUnion<Stmt *, EvaluatedStmt *>;\n\n  /// The initializer for this variable or, for a ParmVarDecl, the\n  /// C++ default argument.\n  mutable InitType Init;\n\nprivate:\n  friend class ASTDeclReader;\n  friend class ASTNodeImporter;\n  friend class StmtIteratorBase;\n\n  class VarDeclBitfields {\n    friend class ASTDeclReader;\n    friend class VarDecl;\n\n    unsigned SClass : 3;\n    unsigned TSCSpec : 2;\n    unsigned InitStyle : 2;\n\n    /// Whether this variable is an ARC pseudo-__strong variable; see\n    /// isARCPseudoStrong() for details.\n    unsigned ARCPseudoStrong : 1;\n  };\n  enum { NumVarDeclBits = 8 };\n\nprotected:\n  enum { NumParameterIndexBits = 8 };\n\n  enum DefaultArgKind {\n    DAK_None,\n    DAK_Unparsed,\n    DAK_Uninstantiated,\n    DAK_Normal\n  };\n\n  enum { NumScopeDepthOrObjCQualsBits = 7 };\n\n  class ParmVarDeclBitfields {\n    friend class ASTDeclReader;\n    friend class ParmVarDecl;\n\n    unsigned : NumVarDeclBits;\n\n    /// Whether this parameter inherits a default argument from a\n    /// prior declaration.\n    unsigned HasInheritedDefaultArg : 1;\n\n    /// Describes the kind of default argument for this parameter. By default\n    /// this is none. If this is normal, then the default argument is stored in\n    /// the \\c VarDecl initializer expression unless we were unable to parse\n    /// (even an invalid) expression for the default argument.\n    unsigned DefaultArgKind : 2;\n\n    /// Whether this parameter undergoes K&R argument promotion.\n    unsigned IsKNRPromoted : 1;\n\n    /// Whether this parameter is an ObjC method parameter or not.\n    unsigned IsObjCMethodParam : 1;\n\n    /// If IsObjCMethodParam, a Decl::ObjCDeclQualifier.\n    /// Otherwise, the number of function parameter scopes enclosing\n    /// the function parameter scope in which this parameter was\n    /// declared.\n    unsigned ScopeDepthOrObjCQuals : NumScopeDepthOrObjCQualsBits;\n\n    /// The number of parameters preceding this parameter in the\n    /// function parameter scope in which it was declared.\n    unsigned ParameterIndex : NumParameterIndexBits;\n  };\n\n  class NonParmVarDeclBitfields {\n    friend class ASTDeclReader;\n    friend class ImplicitParamDecl;\n    friend class VarDecl;\n\n    unsigned : NumVarDeclBits;\n\n    // FIXME: We need something similar to CXXRecordDecl::DefinitionData.\n    /// Whether this variable is a definition which was demoted due to\n    /// module merge.\n    unsigned IsThisDeclarationADemotedDefinition : 1;\n\n    /// Whether this variable is the exception variable in a C++ catch\n    /// or an Objective-C @catch statement.\n    unsigned ExceptionVar : 1;\n\n    /// Whether this local variable could be allocated in the return\n    /// slot of its function, enabling the named return value optimization\n    /// (NRVO).\n    unsigned NRVOVariable : 1;\n\n    /// Whether this variable is the for-range-declaration in a C++0x\n    /// for-range statement.\n    unsigned CXXForRangeDecl : 1;\n\n    /// Whether this variable is the for-in loop declaration in Objective-C.\n    unsigned ObjCForDecl : 1;\n\n    /// Whether this variable is (C++1z) inline.\n    unsigned IsInline : 1;\n\n    /// Whether this variable has (C++1z) inline explicitly specified.\n    unsigned IsInlineSpecified : 1;\n\n    /// Whether this variable is (C++0x) constexpr.\n    unsigned IsConstexpr : 1;\n\n    /// Whether this variable is the implicit variable for a lambda\n    /// init-capture.\n    unsigned IsInitCapture : 1;\n\n    /// Whether this local extern variable's previous declaration was\n    /// declared in the same block scope. This controls whether we should merge\n    /// the type of this declaration with its previous declaration.\n    unsigned PreviousDeclInSameBlockScope : 1;\n\n    /// Defines kind of the ImplicitParamDecl: 'this', 'self', 'vtt', '_cmd' or\n    /// something else.\n    unsigned ImplicitParamKind : 3;\n\n    unsigned EscapingByref : 1;\n  };\n\n  union {\n    unsigned AllBits;\n    VarDeclBitfields VarDeclBits;\n    ParmVarDeclBitfields ParmVarDeclBits;\n    NonParmVarDeclBitfields NonParmVarDeclBits;\n  };\n\n  VarDecl(Kind DK, ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n          SourceLocation IdLoc, IdentifierInfo *Id, QualType T,\n          TypeSourceInfo *TInfo, StorageClass SC);\n\n  using redeclarable_base = Redeclarable<VarDecl>;\n\n  VarDecl *getNextRedeclarationImpl() override {\n    return getNextRedeclaration();\n  }\n\n  VarDecl *getPreviousDeclImpl() override {\n    return getPreviousDecl();\n  }\n\n  VarDecl *getMostRecentDeclImpl() override {\n    return getMostRecentDecl();\n  }\n\npublic:\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  static VarDecl *Create(ASTContext &C, DeclContext *DC,\n                         SourceLocation StartLoc, SourceLocation IdLoc,\n                         IdentifierInfo *Id, QualType T, TypeSourceInfo *TInfo,\n                         StorageClass S);\n\n  static VarDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  /// Returns the storage class as written in the source. For the\n  /// computed linkage of symbol, see getLinkage.\n  StorageClass getStorageClass() const {\n    return (StorageClass) VarDeclBits.SClass;\n  }\n  void setStorageClass(StorageClass SC);\n\n  void setTSCSpec(ThreadStorageClassSpecifier TSC) {\n    VarDeclBits.TSCSpec = TSC;\n    assert(VarDeclBits.TSCSpec == TSC && \"truncation\");\n  }\n  ThreadStorageClassSpecifier getTSCSpec() const {\n    return static_cast<ThreadStorageClassSpecifier>(VarDeclBits.TSCSpec);\n  }\n  TLSKind getTLSKind() const;\n\n  /// Returns true if a variable with function scope is a non-static local\n  /// variable.\n  bool hasLocalStorage() const {\n    if (getStorageClass() == SC_None) {\n      // OpenCL v1.2 s6.5.3: The __constant or constant address space name is\n      // used to describe variables allocated in global memory and which are\n      // accessed inside a kernel(s) as read-only variables. As such, variables\n      // in constant address space cannot have local storage.\n      if (getType().getAddressSpace() == LangAS::opencl_constant)\n        return false;\n      // Second check is for C++11 [dcl.stc]p4.\n      return !isFileVarDecl() && getTSCSpec() == TSCS_unspecified;\n    }\n\n    // Global Named Register (GNU extension)\n    if (getStorageClass() == SC_Register && !isLocalVarDeclOrParm())\n      return false;\n\n    // Return true for:  Auto, Register.\n    // Return false for: Extern, Static, PrivateExtern, OpenCLWorkGroupLocal.\n\n    return getStorageClass() >= SC_Auto;\n  }\n\n  /// Returns true if a variable with function scope is a static local\n  /// variable.\n  bool isStaticLocal() const {\n    return (getStorageClass() == SC_Static ||\n            // C++11 [dcl.stc]p4\n            (getStorageClass() == SC_None && getTSCSpec() == TSCS_thread_local))\n      && !isFileVarDecl();\n  }\n\n  /// Returns true if a variable has extern or __private_extern__\n  /// storage.\n  bool hasExternalStorage() const {\n    return getStorageClass() == SC_Extern ||\n           getStorageClass() == SC_PrivateExtern;\n  }\n\n  /// Returns true for all variables that do not have local storage.\n  ///\n  /// This includes all global variables as well as static variables declared\n  /// within a function.\n  bool hasGlobalStorage() const { return !hasLocalStorage(); }\n\n  /// Get the storage duration of this variable, per C++ [basic.stc].\n  StorageDuration getStorageDuration() const {\n    return hasLocalStorage() ? SD_Automatic :\n           getTSCSpec() ? SD_Thread : SD_Static;\n  }\n\n  /// Compute the language linkage.\n  LanguageLinkage getLanguageLinkage() const;\n\n  /// Determines whether this variable is a variable with external, C linkage.\n  bool isExternC() const;\n\n  /// Determines whether this variable's context is, or is nested within,\n  /// a C++ extern \"C\" linkage spec.\n  bool isInExternCContext() const;\n\n  /// Determines whether this variable's context is, or is nested within,\n  /// a C++ extern \"C++\" linkage spec.\n  bool isInExternCXXContext() const;\n\n  /// Returns true for local variable declarations other than parameters.\n  /// Note that this includes static variables inside of functions. It also\n  /// includes variables inside blocks.\n  ///\n  ///   void foo() { int x; static int y; extern int z; }\n  bool isLocalVarDecl() const {\n    if (getKind() != Decl::Var && getKind() != Decl::Decomposition)\n      return false;\n    if (const DeclContext *DC = getLexicalDeclContext())\n      return DC->getRedeclContext()->isFunctionOrMethod();\n    return false;\n  }\n\n  /// Similar to isLocalVarDecl but also includes parameters.\n  bool isLocalVarDeclOrParm() const {\n    return isLocalVarDecl() || getKind() == Decl::ParmVar;\n  }\n\n  /// Similar to isLocalVarDecl, but excludes variables declared in blocks.\n  bool isFunctionOrMethodVarDecl() const {\n    if (getKind() != Decl::Var && getKind() != Decl::Decomposition)\n      return false;\n    const DeclContext *DC = getLexicalDeclContext()->getRedeclContext();\n    return DC->isFunctionOrMethod() && DC->getDeclKind() != Decl::Block;\n  }\n\n  /// Determines whether this is a static data member.\n  ///\n  /// This will only be true in C++, and applies to, e.g., the\n  /// variable 'x' in:\n  /// \\code\n  /// struct S {\n  ///   static int x;\n  /// };\n  /// \\endcode\n  bool isStaticDataMember() const {\n    // If it wasn't static, it would be a FieldDecl.\n    return getKind() != Decl::ParmVar && getDeclContext()->isRecord();\n  }\n\n  VarDecl *getCanonicalDecl() override;\n  const VarDecl *getCanonicalDecl() const {\n    return const_cast<VarDecl*>(this)->getCanonicalDecl();\n  }\n\n  enum DefinitionKind {\n    /// This declaration is only a declaration.\n    DeclarationOnly,\n\n    /// This declaration is a tentative definition.\n    TentativeDefinition,\n\n    /// This declaration is definitely a definition.\n    Definition\n  };\n\n  /// Check whether this declaration is a definition. If this could be\n  /// a tentative definition (in C), don't check whether there's an overriding\n  /// definition.\n  DefinitionKind isThisDeclarationADefinition(ASTContext &) const;\n  DefinitionKind isThisDeclarationADefinition() const {\n    return isThisDeclarationADefinition(getASTContext());\n  }\n\n  /// Check whether this variable is defined in this translation unit.\n  DefinitionKind hasDefinition(ASTContext &) const;\n  DefinitionKind hasDefinition() const {\n    return hasDefinition(getASTContext());\n  }\n\n  /// Get the tentative definition that acts as the real definition in a TU.\n  /// Returns null if there is a proper definition available.\n  VarDecl *getActingDefinition();\n  const VarDecl *getActingDefinition() const {\n    return const_cast<VarDecl*>(this)->getActingDefinition();\n  }\n\n  /// Get the real (not just tentative) definition for this declaration.\n  VarDecl *getDefinition(ASTContext &);\n  const VarDecl *getDefinition(ASTContext &C) const {\n    return const_cast<VarDecl*>(this)->getDefinition(C);\n  }\n  VarDecl *getDefinition() {\n    return getDefinition(getASTContext());\n  }\n  const VarDecl *getDefinition() const {\n    return const_cast<VarDecl*>(this)->getDefinition();\n  }\n\n  /// Determine whether this is or was instantiated from an out-of-line\n  /// definition of a static data member.\n  bool isOutOfLine() const override;\n\n  /// Returns true for file scoped variable declaration.\n  bool isFileVarDecl() const {\n    Kind K = getKind();\n    if (K == ParmVar || K == ImplicitParam)\n      return false;\n\n    if (getLexicalDeclContext()->getRedeclContext()->isFileContext())\n      return true;\n\n    if (isStaticDataMember())\n      return true;\n\n    return false;\n  }\n\n  /// Get the initializer for this variable, no matter which\n  /// declaration it is attached to.\n  const Expr *getAnyInitializer() const {\n    const VarDecl *D;\n    return getAnyInitializer(D);\n  }\n\n  /// Get the initializer for this variable, no matter which\n  /// declaration it is attached to. Also get that declaration.\n  const Expr *getAnyInitializer(const VarDecl *&D) const;\n\n  bool hasInit() const;\n  const Expr *getInit() const {\n    return const_cast<VarDecl *>(this)->getInit();\n  }\n  Expr *getInit();\n\n  /// Retrieve the address of the initializer expression.\n  Stmt **getInitAddress();\n\n  void setInit(Expr *I);\n\n  /// Get the initializing declaration of this variable, if any. This is\n  /// usually the definition, except that for a static data member it can be\n  /// the in-class declaration.\n  VarDecl *getInitializingDeclaration();\n  const VarDecl *getInitializingDeclaration() const {\n    return const_cast<VarDecl *>(this)->getInitializingDeclaration();\n  }\n\n  /// Determine whether this variable's value might be usable in a\n  /// constant expression, according to the relevant language standard.\n  /// This only checks properties of the declaration, and does not check\n  /// whether the initializer is in fact a constant expression.\n  ///\n  /// This corresponds to C++20 [expr.const]p3's notion of a\n  /// \"potentially-constant\" variable.\n  bool mightBeUsableInConstantExpressions(const ASTContext &C) const;\n\n  /// Determine whether this variable's value can be used in a\n  /// constant expression, according to the relevant language standard,\n  /// including checking whether it was initialized by a constant expression.\n  bool isUsableInConstantExpressions(const ASTContext &C) const;\n\n  EvaluatedStmt *ensureEvaluatedStmt() const;\n  EvaluatedStmt *getEvaluatedStmt() const;\n\n  /// Attempt to evaluate the value of the initializer attached to this\n  /// declaration, and produce notes explaining why it cannot be evaluated.\n  /// Returns a pointer to the value if evaluation succeeded, 0 otherwise.\n  APValue *evaluateValue() const;\n\nprivate:\n  APValue *evaluateValueImpl(SmallVectorImpl<PartialDiagnosticAt> &Notes,\n                             bool IsConstantInitialization) const;\n\npublic:\n  /// Return the already-evaluated value of this variable's\n  /// initializer, or NULL if the value is not yet known. Returns pointer\n  /// to untyped APValue if the value could not be evaluated.\n  APValue *getEvaluatedValue() const;\n\n  /// Evaluate the destruction of this variable to determine if it constitutes\n  /// constant destruction.\n  ///\n  /// \\pre hasConstantInitialization()\n  /// \\return \\c true if this variable has constant destruction, \\c false if\n  ///         not.\n  bool evaluateDestruction(SmallVectorImpl<PartialDiagnosticAt> &Notes) const;\n\n  /// Determine whether this variable has constant initialization.\n  ///\n  /// This is only set in two cases: when the language semantics require\n  /// constant initialization (globals in C and some globals in C++), and when\n  /// the variable is usable in constant expressions (constexpr, const int, and\n  /// reference variables in C++).\n  bool hasConstantInitialization() const;\n\n  /// Determine whether the initializer of this variable is an integer constant\n  /// expression. For use in C++98, where this affects whether the variable is\n  /// usable in constant expressions.\n  bool hasICEInitializer(const ASTContext &Context) const;\n\n  /// Evaluate the initializer of this variable to determine whether it's a\n  /// constant initializer. Should only be called once, after completing the\n  /// definition of the variable.\n  bool checkForConstantInitialization(\n      SmallVectorImpl<PartialDiagnosticAt> &Notes) const;\n\n  void setInitStyle(InitializationStyle Style) {\n    VarDeclBits.InitStyle = Style;\n  }\n\n  /// The style of initialization for this declaration.\n  ///\n  /// C-style initialization is \"int x = 1;\". Call-style initialization is\n  /// a C++98 direct-initializer, e.g. \"int x(1);\". The Init expression will be\n  /// the expression inside the parens or a \"ClassType(a,b,c)\" class constructor\n  /// expression for class types. List-style initialization is C++11 syntax,\n  /// e.g. \"int x{1};\". Clients can distinguish between different forms of\n  /// initialization by checking this value. In particular, \"int x = {1};\" is\n  /// C-style, \"int x({1})\" is call-style, and \"int x{1};\" is list-style; the\n  /// Init expression in all three cases is an InitListExpr.\n  InitializationStyle getInitStyle() const {\n    return static_cast<InitializationStyle>(VarDeclBits.InitStyle);\n  }\n\n  /// Whether the initializer is a direct-initializer (list or call).\n  bool isDirectInit() const {\n    return getInitStyle() != CInit;\n  }\n\n  /// If this definition should pretend to be a declaration.\n  bool isThisDeclarationADemotedDefinition() const {\n    return isa<ParmVarDecl>(this) ? false :\n      NonParmVarDeclBits.IsThisDeclarationADemotedDefinition;\n  }\n\n  /// This is a definition which should be demoted to a declaration.\n  ///\n  /// In some cases (mostly module merging) we can end up with two visible\n  /// definitions one of which needs to be demoted to a declaration to keep\n  /// the AST invariants.\n  void demoteThisDefinitionToDeclaration() {\n    assert(isThisDeclarationADefinition() && \"Not a definition!\");\n    assert(!isa<ParmVarDecl>(this) && \"Cannot demote ParmVarDecls!\");\n    NonParmVarDeclBits.IsThisDeclarationADemotedDefinition = 1;\n  }\n\n  /// Determine whether this variable is the exception variable in a\n  /// C++ catch statememt or an Objective-C \\@catch statement.\n  bool isExceptionVariable() const {\n    return isa<ParmVarDecl>(this) ? false : NonParmVarDeclBits.ExceptionVar;\n  }\n  void setExceptionVariable(bool EV) {\n    assert(!isa<ParmVarDecl>(this));\n    NonParmVarDeclBits.ExceptionVar = EV;\n  }\n\n  /// Determine whether this local variable can be used with the named\n  /// return value optimization (NRVO).\n  ///\n  /// The named return value optimization (NRVO) works by marking certain\n  /// non-volatile local variables of class type as NRVO objects. These\n  /// locals can be allocated within the return slot of their containing\n  /// function, in which case there is no need to copy the object to the\n  /// return slot when returning from the function. Within the function body,\n  /// each return that returns the NRVO object will have this variable as its\n  /// NRVO candidate.\n  bool isNRVOVariable() const {\n    return isa<ParmVarDecl>(this) ? false : NonParmVarDeclBits.NRVOVariable;\n  }\n  void setNRVOVariable(bool NRVO) {\n    assert(!isa<ParmVarDecl>(this));\n    NonParmVarDeclBits.NRVOVariable = NRVO;\n  }\n\n  /// Determine whether this variable is the for-range-declaration in\n  /// a C++0x for-range statement.\n  bool isCXXForRangeDecl() const {\n    return isa<ParmVarDecl>(this) ? false : NonParmVarDeclBits.CXXForRangeDecl;\n  }\n  void setCXXForRangeDecl(bool FRD) {\n    assert(!isa<ParmVarDecl>(this));\n    NonParmVarDeclBits.CXXForRangeDecl = FRD;\n  }\n\n  /// Determine whether this variable is a for-loop declaration for a\n  /// for-in statement in Objective-C.\n  bool isObjCForDecl() const {\n    return NonParmVarDeclBits.ObjCForDecl;\n  }\n\n  void setObjCForDecl(bool FRD) {\n    NonParmVarDeclBits.ObjCForDecl = FRD;\n  }\n\n  /// Determine whether this variable is an ARC pseudo-__strong variable. A\n  /// pseudo-__strong variable has a __strong-qualified type but does not\n  /// actually retain the object written into it. Generally such variables are\n  /// also 'const' for safety. There are 3 cases where this will be set, 1) if\n  /// the variable is annotated with the objc_externally_retained attribute, 2)\n  /// if its 'self' in a non-init method, or 3) if its the variable in an for-in\n  /// loop.\n  bool isARCPseudoStrong() const { return VarDeclBits.ARCPseudoStrong; }\n  void setARCPseudoStrong(bool PS) { VarDeclBits.ARCPseudoStrong = PS; }\n\n  /// Whether this variable is (C++1z) inline.\n  bool isInline() const {\n    return isa<ParmVarDecl>(this) ? false : NonParmVarDeclBits.IsInline;\n  }\n  bool isInlineSpecified() const {\n    return isa<ParmVarDecl>(this) ? false\n                                  : NonParmVarDeclBits.IsInlineSpecified;\n  }\n  void setInlineSpecified() {\n    assert(!isa<ParmVarDecl>(this));\n    NonParmVarDeclBits.IsInline = true;\n    NonParmVarDeclBits.IsInlineSpecified = true;\n  }\n  void setImplicitlyInline() {\n    assert(!isa<ParmVarDecl>(this));\n    NonParmVarDeclBits.IsInline = true;\n  }\n\n  /// Whether this variable is (C++11) constexpr.\n  bool isConstexpr() const {\n    return isa<ParmVarDecl>(this) ? false : NonParmVarDeclBits.IsConstexpr;\n  }\n  void setConstexpr(bool IC) {\n    assert(!isa<ParmVarDecl>(this));\n    NonParmVarDeclBits.IsConstexpr = IC;\n  }\n\n  /// Whether this variable is the implicit variable for a lambda init-capture.\n  bool isInitCapture() const {\n    return isa<ParmVarDecl>(this) ? false : NonParmVarDeclBits.IsInitCapture;\n  }\n  void setInitCapture(bool IC) {\n    assert(!isa<ParmVarDecl>(this));\n    NonParmVarDeclBits.IsInitCapture = IC;\n  }\n\n  /// Determine whether this variable is actually a function parameter pack or\n  /// init-capture pack.\n  bool isParameterPack() const;\n\n  /// Whether this local extern variable declaration's previous declaration\n  /// was declared in the same block scope. Only correct in C++.\n  bool isPreviousDeclInSameBlockScope() const {\n    return isa<ParmVarDecl>(this)\n               ? false\n               : NonParmVarDeclBits.PreviousDeclInSameBlockScope;\n  }\n  void setPreviousDeclInSameBlockScope(bool Same) {\n    assert(!isa<ParmVarDecl>(this));\n    NonParmVarDeclBits.PreviousDeclInSameBlockScope = Same;\n  }\n\n  /// Indicates the capture is a __block variable that is captured by a block\n  /// that can potentially escape (a block for which BlockDecl::doesNotEscape\n  /// returns false).\n  bool isEscapingByref() const;\n\n  /// Indicates the capture is a __block variable that is never captured by an\n  /// escaping block.\n  bool isNonEscapingByref() const;\n\n  void setEscapingByref() {\n    NonParmVarDeclBits.EscapingByref = true;\n  }\n\n  /// Retrieve the variable declaration from which this variable could\n  /// be instantiated, if it is an instantiation (rather than a non-template).\n  VarDecl *getTemplateInstantiationPattern() const;\n\n  /// If this variable is an instantiated static data member of a\n  /// class template specialization, returns the templated static data member\n  /// from which it was instantiated.\n  VarDecl *getInstantiatedFromStaticDataMember() const;\n\n  /// If this variable is an instantiation of a variable template or a\n  /// static data member of a class template, determine what kind of\n  /// template specialization or instantiation this is.\n  TemplateSpecializationKind getTemplateSpecializationKind() const;\n\n  /// Get the template specialization kind of this variable for the purposes of\n  /// template instantiation. This differs from getTemplateSpecializationKind()\n  /// for an instantiation of a class-scope explicit specialization.\n  TemplateSpecializationKind\n  getTemplateSpecializationKindForInstantiation() const;\n\n  /// If this variable is an instantiation of a variable template or a\n  /// static data member of a class template, determine its point of\n  /// instantiation.\n  SourceLocation getPointOfInstantiation() const;\n\n  /// If this variable is an instantiation of a static data member of a\n  /// class template specialization, retrieves the member specialization\n  /// information.\n  MemberSpecializationInfo *getMemberSpecializationInfo() const;\n\n  /// For a static data member that was instantiated from a static\n  /// data member of a class template, set the template specialiation kind.\n  void setTemplateSpecializationKind(TemplateSpecializationKind TSK,\n                        SourceLocation PointOfInstantiation = SourceLocation());\n\n  /// Specify that this variable is an instantiation of the\n  /// static data member VD.\n  void setInstantiationOfStaticDataMember(VarDecl *VD,\n                                          TemplateSpecializationKind TSK);\n\n  /// Retrieves the variable template that is described by this\n  /// variable declaration.\n  ///\n  /// Every variable template is represented as a VarTemplateDecl and a\n  /// VarDecl. The former contains template properties (such as\n  /// the template parameter lists) while the latter contains the\n  /// actual description of the template's\n  /// contents. VarTemplateDecl::getTemplatedDecl() retrieves the\n  /// VarDecl that from a VarTemplateDecl, while\n  /// getDescribedVarTemplate() retrieves the VarTemplateDecl from\n  /// a VarDecl.\n  VarTemplateDecl *getDescribedVarTemplate() const;\n\n  void setDescribedVarTemplate(VarTemplateDecl *Template);\n\n  // Is this variable known to have a definition somewhere in the complete\n  // program? This may be true even if the declaration has internal linkage and\n  // has no definition within this source file.\n  bool isKnownToBeDefined() const;\n\n  /// Is destruction of this variable entirely suppressed? If so, the variable\n  /// need not have a usable destructor at all.\n  bool isNoDestroy(const ASTContext &) const;\n\n  /// Would the destruction of this variable have any effect, and if so, what\n  /// kind?\n  QualType::DestructionKind needsDestruction(const ASTContext &Ctx) const;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K >= firstVar && K <= lastVar; }\n};\n\nclass ImplicitParamDecl : public VarDecl {\n  void anchor() override;\n\npublic:\n  /// Defines the kind of the implicit parameter: is this an implicit parameter\n  /// with pointer to 'this', 'self', '_cmd', virtual table pointers, captured\n  /// context or something else.\n  enum ImplicitParamKind : unsigned {\n    /// Parameter for Objective-C 'self' argument\n    ObjCSelf,\n\n    /// Parameter for Objective-C '_cmd' argument\n    ObjCCmd,\n\n    /// Parameter for C++ 'this' argument\n    CXXThis,\n\n    /// Parameter for C++ virtual table pointers\n    CXXVTT,\n\n    /// Parameter for captured context\n    CapturedContext,\n\n    /// Other implicit parameter\n    Other,\n  };\n\n  /// Create implicit parameter.\n  static ImplicitParamDecl *Create(ASTContext &C, DeclContext *DC,\n                                   SourceLocation IdLoc, IdentifierInfo *Id,\n                                   QualType T, ImplicitParamKind ParamKind);\n  static ImplicitParamDecl *Create(ASTContext &C, QualType T,\n                                   ImplicitParamKind ParamKind);\n\n  static ImplicitParamDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  ImplicitParamDecl(ASTContext &C, DeclContext *DC, SourceLocation IdLoc,\n                    IdentifierInfo *Id, QualType Type,\n                    ImplicitParamKind ParamKind)\n      : VarDecl(ImplicitParam, C, DC, IdLoc, IdLoc, Id, Type,\n                /*TInfo=*/nullptr, SC_None) {\n    NonParmVarDeclBits.ImplicitParamKind = ParamKind;\n    setImplicit();\n  }\n\n  ImplicitParamDecl(ASTContext &C, QualType Type, ImplicitParamKind ParamKind)\n      : VarDecl(ImplicitParam, C, /*DC=*/nullptr, SourceLocation(),\n                SourceLocation(), /*Id=*/nullptr, Type,\n                /*TInfo=*/nullptr, SC_None) {\n    NonParmVarDeclBits.ImplicitParamKind = ParamKind;\n    setImplicit();\n  }\n\n  /// Returns the implicit parameter kind.\n  ImplicitParamKind getParameterKind() const {\n    return static_cast<ImplicitParamKind>(NonParmVarDeclBits.ImplicitParamKind);\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ImplicitParam; }\n};\n\n/// Represents a parameter to a function.\nclass ParmVarDecl : public VarDecl {\npublic:\n  enum { MaxFunctionScopeDepth = 255 };\n  enum { MaxFunctionScopeIndex = 255 };\n\nprotected:\n  ParmVarDecl(Kind DK, ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n              SourceLocation IdLoc, IdentifierInfo *Id, QualType T,\n              TypeSourceInfo *TInfo, StorageClass S, Expr *DefArg)\n      : VarDecl(DK, C, DC, StartLoc, IdLoc, Id, T, TInfo, S) {\n    assert(ParmVarDeclBits.HasInheritedDefaultArg == false);\n    assert(ParmVarDeclBits.DefaultArgKind == DAK_None);\n    assert(ParmVarDeclBits.IsKNRPromoted == false);\n    assert(ParmVarDeclBits.IsObjCMethodParam == false);\n    setDefaultArg(DefArg);\n  }\n\npublic:\n  static ParmVarDecl *Create(ASTContext &C, DeclContext *DC,\n                             SourceLocation StartLoc,\n                             SourceLocation IdLoc, IdentifierInfo *Id,\n                             QualType T, TypeSourceInfo *TInfo,\n                             StorageClass S, Expr *DefArg);\n\n  static ParmVarDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  void setObjCMethodScopeInfo(unsigned parameterIndex) {\n    ParmVarDeclBits.IsObjCMethodParam = true;\n    setParameterIndex(parameterIndex);\n  }\n\n  void setScopeInfo(unsigned scopeDepth, unsigned parameterIndex) {\n    assert(!ParmVarDeclBits.IsObjCMethodParam);\n\n    ParmVarDeclBits.ScopeDepthOrObjCQuals = scopeDepth;\n    assert(ParmVarDeclBits.ScopeDepthOrObjCQuals == scopeDepth\n           && \"truncation!\");\n\n    setParameterIndex(parameterIndex);\n  }\n\n  bool isObjCMethodParameter() const {\n    return ParmVarDeclBits.IsObjCMethodParam;\n  }\n\n  /// Determines whether this parameter is destroyed in the callee function.\n  bool isDestroyedInCallee() const;\n\n  unsigned getFunctionScopeDepth() const {\n    if (ParmVarDeclBits.IsObjCMethodParam) return 0;\n    return ParmVarDeclBits.ScopeDepthOrObjCQuals;\n  }\n\n  static constexpr unsigned getMaxFunctionScopeDepth() {\n    return (1u << NumScopeDepthOrObjCQualsBits) - 1;\n  }\n\n  /// Returns the index of this parameter in its prototype or method scope.\n  unsigned getFunctionScopeIndex() const {\n    return getParameterIndex();\n  }\n\n  ObjCDeclQualifier getObjCDeclQualifier() const {\n    if (!ParmVarDeclBits.IsObjCMethodParam) return OBJC_TQ_None;\n    return ObjCDeclQualifier(ParmVarDeclBits.ScopeDepthOrObjCQuals);\n  }\n  void setObjCDeclQualifier(ObjCDeclQualifier QTVal) {\n    assert(ParmVarDeclBits.IsObjCMethodParam);\n    ParmVarDeclBits.ScopeDepthOrObjCQuals = QTVal;\n  }\n\n  /// True if the value passed to this parameter must undergo\n  /// K&R-style default argument promotion:\n  ///\n  /// C99 6.5.2.2.\n  ///   If the expression that denotes the called function has a type\n  ///   that does not include a prototype, the integer promotions are\n  ///   performed on each argument, and arguments that have type float\n  ///   are promoted to double.\n  bool isKNRPromoted() const {\n    return ParmVarDeclBits.IsKNRPromoted;\n  }\n  void setKNRPromoted(bool promoted) {\n    ParmVarDeclBits.IsKNRPromoted = promoted;\n  }\n\n  Expr *getDefaultArg();\n  const Expr *getDefaultArg() const {\n    return const_cast<ParmVarDecl *>(this)->getDefaultArg();\n  }\n\n  void setDefaultArg(Expr *defarg);\n\n  /// Retrieve the source range that covers the entire default\n  /// argument.\n  SourceRange getDefaultArgRange() const;\n  void setUninstantiatedDefaultArg(Expr *arg);\n  Expr *getUninstantiatedDefaultArg();\n  const Expr *getUninstantiatedDefaultArg() const {\n    return const_cast<ParmVarDecl *>(this)->getUninstantiatedDefaultArg();\n  }\n\n  /// Determines whether this parameter has a default argument,\n  /// either parsed or not.\n  bool hasDefaultArg() const;\n\n  /// Determines whether this parameter has a default argument that has not\n  /// yet been parsed. This will occur during the processing of a C++ class\n  /// whose member functions have default arguments, e.g.,\n  /// @code\n  ///   class X {\n  ///   public:\n  ///     void f(int x = 17); // x has an unparsed default argument now\n  ///   }; // x has a regular default argument now\n  /// @endcode\n  bool hasUnparsedDefaultArg() const {\n    return ParmVarDeclBits.DefaultArgKind == DAK_Unparsed;\n  }\n\n  bool hasUninstantiatedDefaultArg() const {\n    return ParmVarDeclBits.DefaultArgKind == DAK_Uninstantiated;\n  }\n\n  /// Specify that this parameter has an unparsed default argument.\n  /// The argument will be replaced with a real default argument via\n  /// setDefaultArg when the class definition enclosing the function\n  /// declaration that owns this default argument is completed.\n  void setUnparsedDefaultArg() {\n    ParmVarDeclBits.DefaultArgKind = DAK_Unparsed;\n  }\n\n  bool hasInheritedDefaultArg() const {\n    return ParmVarDeclBits.HasInheritedDefaultArg;\n  }\n\n  void setHasInheritedDefaultArg(bool I = true) {\n    ParmVarDeclBits.HasInheritedDefaultArg = I;\n  }\n\n  QualType getOriginalType() const;\n\n  /// Sets the function declaration that owns this\n  /// ParmVarDecl. Since ParmVarDecls are often created before the\n  /// FunctionDecls that own them, this routine is required to update\n  /// the DeclContext appropriately.\n  void setOwningFunction(DeclContext *FD) { setDeclContext(FD); }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ParmVar; }\n\nprivate:\n  enum { ParameterIndexSentinel = (1 << NumParameterIndexBits) - 1 };\n\n  void setParameterIndex(unsigned parameterIndex) {\n    if (parameterIndex >= ParameterIndexSentinel) {\n      setParameterIndexLarge(parameterIndex);\n      return;\n    }\n\n    ParmVarDeclBits.ParameterIndex = parameterIndex;\n    assert(ParmVarDeclBits.ParameterIndex == parameterIndex && \"truncation!\");\n  }\n  unsigned getParameterIndex() const {\n    unsigned d = ParmVarDeclBits.ParameterIndex;\n    return d == ParameterIndexSentinel ? getParameterIndexLarge() : d;\n  }\n\n  void setParameterIndexLarge(unsigned parameterIndex);\n  unsigned getParameterIndexLarge() const;\n};\n\nenum class MultiVersionKind {\n  None,\n  Target,\n  CPUSpecific,\n  CPUDispatch\n};\n\n/// Represents a function declaration or definition.\n///\n/// Since a given function can be declared several times in a program,\n/// there may be several FunctionDecls that correspond to that\n/// function. Only one of those FunctionDecls will be found when\n/// traversing the list of declarations in the context of the\n/// FunctionDecl (e.g., the translation unit); this FunctionDecl\n/// contains all of the information known about the function. Other,\n/// previous declarations of the function are available via the\n/// getPreviousDecl() chain.\nclass FunctionDecl : public DeclaratorDecl,\n                     public DeclContext,\n                     public Redeclarable<FunctionDecl> {\n  // This class stores some data in DeclContext::FunctionDeclBits\n  // to save some space. Use the provided accessors to access it.\npublic:\n  /// The kind of templated function a FunctionDecl can be.\n  enum TemplatedKind {\n    // Not templated.\n    TK_NonTemplate,\n    // The pattern in a function template declaration.\n    TK_FunctionTemplate,\n    // A non-template function that is an instantiation or explicit\n    // specialization of a member of a templated class.\n    TK_MemberSpecialization,\n    // An instantiation or explicit specialization of a function template.\n    // Note: this might have been instantiated from a templated class if it\n    // is a class-scope explicit specialization.\n    TK_FunctionTemplateSpecialization,\n    // A function template specialization that hasn't yet been resolved to a\n    // particular specialized function template.\n    TK_DependentFunctionTemplateSpecialization\n  };\n\n  /// Stashed information about a defaulted function definition whose body has\n  /// not yet been lazily generated.\n  class DefaultedFunctionInfo final\n      : llvm::TrailingObjects<DefaultedFunctionInfo, DeclAccessPair> {\n    friend TrailingObjects;\n    unsigned NumLookups;\n\n  public:\n    static DefaultedFunctionInfo *Create(ASTContext &Context,\n                                         ArrayRef<DeclAccessPair> Lookups);\n    /// Get the unqualified lookup results that should be used in this\n    /// defaulted function definition.\n    ArrayRef<DeclAccessPair> getUnqualifiedLookups() const {\n      return {getTrailingObjects<DeclAccessPair>(), NumLookups};\n    }\n  };\n\nprivate:\n  /// A new[]'d array of pointers to VarDecls for the formal\n  /// parameters of this function.  This is null if a prototype or if there are\n  /// no formals.\n  ParmVarDecl **ParamInfo = nullptr;\n\n  /// The active member of this union is determined by\n  /// FunctionDeclBits.HasDefaultedFunctionInfo.\n  union {\n    /// The body of the function.\n    LazyDeclStmtPtr Body;\n    /// Information about a future defaulted function definition.\n    DefaultedFunctionInfo *DefaultedInfo;\n  };\n\n  unsigned ODRHash;\n\n  /// End part of this FunctionDecl's source range.\n  ///\n  /// We could compute the full range in getSourceRange(). However, when we're\n  /// dealing with a function definition deserialized from a PCH/AST file,\n  /// we can only compute the full range once the function body has been\n  /// de-serialized, so it's far better to have the (sometimes-redundant)\n  /// EndRangeLoc.\n  SourceLocation EndRangeLoc;\n\n  /// The template or declaration that this declaration\n  /// describes or was instantiated from, respectively.\n  ///\n  /// For non-templates, this value will be NULL. For function\n  /// declarations that describe a function template, this will be a\n  /// pointer to a FunctionTemplateDecl. For member functions\n  /// of class template specializations, this will be a MemberSpecializationInfo\n  /// pointer containing information about the specialization.\n  /// For function template specializations, this will be a\n  /// FunctionTemplateSpecializationInfo, which contains information about\n  /// the template being specialized and the template arguments involved in\n  /// that specialization.\n  llvm::PointerUnion<FunctionTemplateDecl *,\n                     MemberSpecializationInfo *,\n                     FunctionTemplateSpecializationInfo *,\n                     DependentFunctionTemplateSpecializationInfo *>\n    TemplateOrSpecialization;\n\n  /// Provides source/type location info for the declaration name embedded in\n  /// the DeclaratorDecl base class.\n  DeclarationNameLoc DNLoc;\n\n  /// Specify that this function declaration is actually a function\n  /// template specialization.\n  ///\n  /// \\param C the ASTContext.\n  ///\n  /// \\param Template the function template that this function template\n  /// specialization specializes.\n  ///\n  /// \\param TemplateArgs the template arguments that produced this\n  /// function template specialization from the template.\n  ///\n  /// \\param InsertPos If non-NULL, the position in the function template\n  /// specialization set where the function template specialization data will\n  /// be inserted.\n  ///\n  /// \\param TSK the kind of template specialization this is.\n  ///\n  /// \\param TemplateArgsAsWritten location info of template arguments.\n  ///\n  /// \\param PointOfInstantiation point at which the function template\n  /// specialization was first instantiated.\n  void setFunctionTemplateSpecialization(ASTContext &C,\n                                         FunctionTemplateDecl *Template,\n                                       const TemplateArgumentList *TemplateArgs,\n                                         void *InsertPos,\n                                         TemplateSpecializationKind TSK,\n                          const TemplateArgumentListInfo *TemplateArgsAsWritten,\n                                         SourceLocation PointOfInstantiation);\n\n  /// Specify that this record is an instantiation of the\n  /// member function FD.\n  void setInstantiationOfMemberFunction(ASTContext &C, FunctionDecl *FD,\n                                        TemplateSpecializationKind TSK);\n\n  void setParams(ASTContext &C, ArrayRef<ParmVarDecl *> NewParamInfo);\n\n  // This is unfortunately needed because ASTDeclWriter::VisitFunctionDecl\n  // need to access this bit but we want to avoid making ASTDeclWriter\n  // a friend of FunctionDeclBitfields just for this.\n  bool isDeletedBit() const { return FunctionDeclBits.IsDeleted; }\n\n  /// Whether an ODRHash has been stored.\n  bool hasODRHash() const { return FunctionDeclBits.HasODRHash; }\n\n  /// State that an ODRHash has been stored.\n  void setHasODRHash(bool B = true) { FunctionDeclBits.HasODRHash = B; }\n\nprotected:\n  FunctionDecl(Kind DK, ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n               const DeclarationNameInfo &NameInfo, QualType T,\n               TypeSourceInfo *TInfo, StorageClass S, bool isInlineSpecified,\n               ConstexprSpecKind ConstexprKind,\n               Expr *TrailingRequiresClause = nullptr);\n\n  using redeclarable_base = Redeclarable<FunctionDecl>;\n\n  FunctionDecl *getNextRedeclarationImpl() override {\n    return getNextRedeclaration();\n  }\n\n  FunctionDecl *getPreviousDeclImpl() override {\n    return getPreviousDecl();\n  }\n\n  FunctionDecl *getMostRecentDeclImpl() override {\n    return getMostRecentDecl();\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  static FunctionDecl *\n  Create(ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n         SourceLocation NLoc, DeclarationName N, QualType T,\n         TypeSourceInfo *TInfo, StorageClass SC, bool isInlineSpecified = false,\n         bool hasWrittenPrototype = true,\n         ConstexprSpecKind ConstexprKind = ConstexprSpecKind::Unspecified,\n         Expr *TrailingRequiresClause = nullptr) {\n    DeclarationNameInfo NameInfo(N, NLoc);\n    return FunctionDecl::Create(C, DC, StartLoc, NameInfo, T, TInfo, SC,\n                                isInlineSpecified, hasWrittenPrototype,\n                                ConstexprKind, TrailingRequiresClause);\n  }\n\n  static FunctionDecl *Create(ASTContext &C, DeclContext *DC,\n                              SourceLocation StartLoc,\n                              const DeclarationNameInfo &NameInfo, QualType T,\n                              TypeSourceInfo *TInfo, StorageClass SC,\n                              bool isInlineSpecified, bool hasWrittenPrototype,\n                              ConstexprSpecKind ConstexprKind,\n                              Expr *TrailingRequiresClause);\n\n  static FunctionDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  DeclarationNameInfo getNameInfo() const {\n    return DeclarationNameInfo(getDeclName(), getLocation(), DNLoc);\n  }\n\n  void getNameForDiagnostic(raw_ostream &OS, const PrintingPolicy &Policy,\n                            bool Qualified) const override;\n\n  void setRangeEnd(SourceLocation E) { EndRangeLoc = E; }\n\n  /// Returns the location of the ellipsis of a variadic function.\n  SourceLocation getEllipsisLoc() const {\n    const auto *FPT = getType()->getAs<FunctionProtoType>();\n    if (FPT && FPT->isVariadic())\n      return FPT->getEllipsisLoc();\n    return SourceLocation();\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  // Function definitions.\n  //\n  // A function declaration may be:\n  // - a non defining declaration,\n  // - a definition. A function may be defined because:\n  //   - it has a body, or will have it in the case of late parsing.\n  //   - it has an uninstantiated body. The body does not exist because the\n  //     function is not used yet, but the declaration is considered a\n  //     definition and does not allow other definition of this function.\n  //   - it does not have a user specified body, but it does not allow\n  //     redefinition, because it is deleted/defaulted or is defined through\n  //     some other mechanism (alias, ifunc).\n\n  /// Returns true if the function has a body.\n  ///\n  /// The function body might be in any of the (re-)declarations of this\n  /// function. The variant that accepts a FunctionDecl pointer will set that\n  /// function declaration to the actual declaration containing the body (if\n  /// there is one).\n  bool hasBody(const FunctionDecl *&Definition) const;\n\n  bool hasBody() const override {\n    const FunctionDecl* Definition;\n    return hasBody(Definition);\n  }\n\n  /// Returns whether the function has a trivial body that does not require any\n  /// specific codegen.\n  bool hasTrivialBody() const;\n\n  /// Returns true if the function has a definition that does not need to be\n  /// instantiated.\n  ///\n  /// The variant that accepts a FunctionDecl pointer will set that function\n  /// declaration to the declaration that is a definition (if there is one).\n  ///\n  /// \\param CheckForPendingFriendDefinition If \\c true, also check for friend\n  ///        declarations that were instantiataed from function definitions.\n  ///        Such a declaration behaves as if it is a definition for the\n  ///        purpose of redefinition checking, but isn't actually a \"real\"\n  ///        definition until its body is instantiated.\n  bool isDefined(const FunctionDecl *&Definition,\n                 bool CheckForPendingFriendDefinition = false) const;\n\n  bool isDefined() const {\n    const FunctionDecl* Definition;\n    return isDefined(Definition);\n  }\n\n  /// Get the definition for this declaration.\n  FunctionDecl *getDefinition() {\n    const FunctionDecl *Definition;\n    if (isDefined(Definition))\n      return const_cast<FunctionDecl *>(Definition);\n    return nullptr;\n  }\n  const FunctionDecl *getDefinition() const {\n    return const_cast<FunctionDecl *>(this)->getDefinition();\n  }\n\n  /// Retrieve the body (definition) of the function. The function body might be\n  /// in any of the (re-)declarations of this function. The variant that accepts\n  /// a FunctionDecl pointer will set that function declaration to the actual\n  /// declaration containing the body (if there is one).\n  /// NOTE: For checking if there is a body, use hasBody() instead, to avoid\n  /// unnecessary AST de-serialization of the body.\n  Stmt *getBody(const FunctionDecl *&Definition) const;\n\n  Stmt *getBody() const override {\n    const FunctionDecl* Definition;\n    return getBody(Definition);\n  }\n\n  /// Returns whether this specific declaration of the function is also a\n  /// definition that does not contain uninstantiated body.\n  ///\n  /// This does not determine whether the function has been defined (e.g., in a\n  /// previous definition); for that information, use isDefined.\n  ///\n  /// Note: the function declaration does not become a definition until the\n  /// parser reaches the definition, if called before, this function will return\n  /// `false`.\n  bool isThisDeclarationADefinition() const {\n    return isDeletedAsWritten() || isDefaulted() ||\n           doesThisDeclarationHaveABody() || hasSkippedBody() ||\n           willHaveBody() || hasDefiningAttr();\n  }\n\n  /// Determine whether this specific declaration of the function is a friend\n  /// declaration that was instantiated from a function definition. Such\n  /// declarations behave like definitions in some contexts.\n  bool isThisDeclarationInstantiatedFromAFriendDefinition() const;\n\n  /// Returns whether this specific declaration of the function has a body.\n  bool doesThisDeclarationHaveABody() const {\n    return (!FunctionDeclBits.HasDefaultedFunctionInfo && Body) ||\n           isLateTemplateParsed();\n  }\n\n  void setBody(Stmt *B);\n  void setLazyBody(uint64_t Offset) {\n    FunctionDeclBits.HasDefaultedFunctionInfo = false;\n    Body = LazyDeclStmtPtr(Offset);\n  }\n\n  void setDefaultedFunctionInfo(DefaultedFunctionInfo *Info);\n  DefaultedFunctionInfo *getDefaultedFunctionInfo() const;\n\n  /// Whether this function is variadic.\n  bool isVariadic() const;\n\n  /// Whether this function is marked as virtual explicitly.\n  bool isVirtualAsWritten() const {\n    return FunctionDeclBits.IsVirtualAsWritten;\n  }\n\n  /// State that this function is marked as virtual explicitly.\n  void setVirtualAsWritten(bool V) { FunctionDeclBits.IsVirtualAsWritten = V; }\n\n  /// Whether this virtual function is pure, i.e. makes the containing class\n  /// abstract.\n  bool isPure() const { return FunctionDeclBits.IsPure; }\n  void setPure(bool P = true);\n\n  /// Whether this templated function will be late parsed.\n  bool isLateTemplateParsed() const {\n    return FunctionDeclBits.IsLateTemplateParsed;\n  }\n\n  /// State that this templated function will be late parsed.\n  void setLateTemplateParsed(bool ILT = true) {\n    FunctionDeclBits.IsLateTemplateParsed = ILT;\n  }\n\n  /// Whether this function is \"trivial\" in some specialized C++ senses.\n  /// Can only be true for default constructors, copy constructors,\n  /// copy assignment operators, and destructors.  Not meaningful until\n  /// the class has been fully built by Sema.\n  bool isTrivial() const { return FunctionDeclBits.IsTrivial; }\n  void setTrivial(bool IT) { FunctionDeclBits.IsTrivial = IT; }\n\n  bool isTrivialForCall() const { return FunctionDeclBits.IsTrivialForCall; }\n  void setTrivialForCall(bool IT) { FunctionDeclBits.IsTrivialForCall = IT; }\n\n  /// Whether this function is defaulted. Valid for e.g.\n  /// special member functions, defaulted comparisions (not methods!).\n  bool isDefaulted() const { return FunctionDeclBits.IsDefaulted; }\n  void setDefaulted(bool D = true) { FunctionDeclBits.IsDefaulted = D; }\n\n  /// Whether this function is explicitly defaulted.\n  bool isExplicitlyDefaulted() const {\n    return FunctionDeclBits.IsExplicitlyDefaulted;\n  }\n\n  /// State that this function is explicitly defaulted.\n  void setExplicitlyDefaulted(bool ED = true) {\n    FunctionDeclBits.IsExplicitlyDefaulted = ED;\n  }\n\n  /// True if this method is user-declared and was not\n  /// deleted or defaulted on its first declaration.\n  bool isUserProvided() const {\n    auto *DeclAsWritten = this;\n    if (FunctionDecl *Pattern = getTemplateInstantiationPattern())\n      DeclAsWritten = Pattern;\n    return !(DeclAsWritten->isDeleted() ||\n             DeclAsWritten->getCanonicalDecl()->isDefaulted());\n  }\n\n  /// Whether falling off this function implicitly returns null/zero.\n  /// If a more specific implicit return value is required, front-ends\n  /// should synthesize the appropriate return statements.\n  bool hasImplicitReturnZero() const {\n    return FunctionDeclBits.HasImplicitReturnZero;\n  }\n\n  /// State that falling off this function implicitly returns null/zero.\n  /// If a more specific implicit return value is required, front-ends\n  /// should synthesize the appropriate return statements.\n  void setHasImplicitReturnZero(bool IRZ) {\n    FunctionDeclBits.HasImplicitReturnZero = IRZ;\n  }\n\n  /// Whether this function has a prototype, either because one\n  /// was explicitly written or because it was \"inherited\" by merging\n  /// a declaration without a prototype with a declaration that has a\n  /// prototype.\n  bool hasPrototype() const {\n    return hasWrittenPrototype() || hasInheritedPrototype();\n  }\n\n  /// Whether this function has a written prototype.\n  bool hasWrittenPrototype() const {\n    return FunctionDeclBits.HasWrittenPrototype;\n  }\n\n  /// State that this function has a written prototype.\n  void setHasWrittenPrototype(bool P = true) {\n    FunctionDeclBits.HasWrittenPrototype = P;\n  }\n\n  /// Whether this function inherited its prototype from a\n  /// previous declaration.\n  bool hasInheritedPrototype() const {\n    return FunctionDeclBits.HasInheritedPrototype;\n  }\n\n  /// State that this function inherited its prototype from a\n  /// previous declaration.\n  void setHasInheritedPrototype(bool P = true) {\n    FunctionDeclBits.HasInheritedPrototype = P;\n  }\n\n  /// Whether this is a (C++11) constexpr function or constexpr constructor.\n  bool isConstexpr() const {\n    return getConstexprKind() != ConstexprSpecKind::Unspecified;\n  }\n  void setConstexprKind(ConstexprSpecKind CSK) {\n    FunctionDeclBits.ConstexprKind = static_cast<uint64_t>(CSK);\n  }\n  ConstexprSpecKind getConstexprKind() const {\n    return static_cast<ConstexprSpecKind>(FunctionDeclBits.ConstexprKind);\n  }\n  bool isConstexprSpecified() const {\n    return getConstexprKind() == ConstexprSpecKind::Constexpr;\n  }\n  bool isConsteval() const {\n    return getConstexprKind() == ConstexprSpecKind::Consteval;\n  }\n\n  /// Whether the instantiation of this function is pending.\n  /// This bit is set when the decision to instantiate this function is made\n  /// and unset if and when the function body is created. That leaves out\n  /// cases where instantiation did not happen because the template definition\n  /// was not seen in this TU. This bit remains set in those cases, under the\n  /// assumption that the instantiation will happen in some other TU.\n  bool instantiationIsPending() const {\n    return FunctionDeclBits.InstantiationIsPending;\n  }\n\n  /// State that the instantiation of this function is pending.\n  /// (see instantiationIsPending)\n  void setInstantiationIsPending(bool IC) {\n    FunctionDeclBits.InstantiationIsPending = IC;\n  }\n\n  /// Indicates the function uses __try.\n  bool usesSEHTry() const { return FunctionDeclBits.UsesSEHTry; }\n  void setUsesSEHTry(bool UST) { FunctionDeclBits.UsesSEHTry = UST; }\n\n  /// Whether this function has been deleted.\n  ///\n  /// A function that is \"deleted\" (via the C++0x \"= delete\" syntax)\n  /// acts like a normal function, except that it cannot actually be\n  /// called or have its address taken. Deleted functions are\n  /// typically used in C++ overload resolution to attract arguments\n  /// whose type or lvalue/rvalue-ness would permit the use of a\n  /// different overload that would behave incorrectly. For example,\n  /// one might use deleted functions to ban implicit conversion from\n  /// a floating-point number to an Integer type:\n  ///\n  /// @code\n  /// struct Integer {\n  ///   Integer(long); // construct from a long\n  ///   Integer(double) = delete; // no construction from float or double\n  ///   Integer(long double) = delete; // no construction from long double\n  /// };\n  /// @endcode\n  // If a function is deleted, its first declaration must be.\n  bool isDeleted() const {\n    return getCanonicalDecl()->FunctionDeclBits.IsDeleted;\n  }\n\n  bool isDeletedAsWritten() const {\n    return FunctionDeclBits.IsDeleted && !isDefaulted();\n  }\n\n  void setDeletedAsWritten(bool D = true) { FunctionDeclBits.IsDeleted = D; }\n\n  /// Determines whether this function is \"main\", which is the\n  /// entry point into an executable program.\n  bool isMain() const;\n\n  /// Determines whether this function is a MSVCRT user defined entry\n  /// point.\n  bool isMSVCRTEntryPoint() const;\n\n  /// Determines whether this operator new or delete is one\n  /// of the reserved global placement operators:\n  ///    void *operator new(size_t, void *);\n  ///    void *operator new[](size_t, void *);\n  ///    void operator delete(void *, void *);\n  ///    void operator delete[](void *, void *);\n  /// These functions have special behavior under [new.delete.placement]:\n  ///    These functions are reserved, a C++ program may not define\n  ///    functions that displace the versions in the Standard C++ library.\n  ///    The provisions of [basic.stc.dynamic] do not apply to these\n  ///    reserved placement forms of operator new and operator delete.\n  ///\n  /// This function must be an allocation or deallocation function.\n  bool isReservedGlobalPlacementOperator() const;\n\n  /// Determines whether this function is one of the replaceable\n  /// global allocation functions:\n  ///    void *operator new(size_t);\n  ///    void *operator new(size_t, const std::nothrow_t &) noexcept;\n  ///    void *operator new[](size_t);\n  ///    void *operator new[](size_t, const std::nothrow_t &) noexcept;\n  ///    void operator delete(void *) noexcept;\n  ///    void operator delete(void *, std::size_t) noexcept;      [C++1y]\n  ///    void operator delete(void *, const std::nothrow_t &) noexcept;\n  ///    void operator delete[](void *) noexcept;\n  ///    void operator delete[](void *, std::size_t) noexcept;    [C++1y]\n  ///    void operator delete[](void *, const std::nothrow_t &) noexcept;\n  /// These functions have special behavior under C++1y [expr.new]:\n  ///    An implementation is allowed to omit a call to a replaceable global\n  ///    allocation function. [...]\n  ///\n  /// If this function is an aligned allocation/deallocation function, return\n  /// the parameter number of the requested alignment through AlignmentParam.\n  ///\n  /// If this function is an allocation/deallocation function that takes\n  /// the `std::nothrow_t` tag, return true through IsNothrow,\n  bool isReplaceableGlobalAllocationFunction(\n      Optional<unsigned> *AlignmentParam = nullptr,\n      bool *IsNothrow = nullptr) const;\n\n  /// Determine if this function provides an inline implementation of a builtin.\n  bool isInlineBuiltinDeclaration() const;\n\n  /// Determine whether this is a destroying operator delete.\n  bool isDestroyingOperatorDelete() const;\n\n  /// Compute the language linkage.\n  LanguageLinkage getLanguageLinkage() const;\n\n  /// Determines whether this function is a function with\n  /// external, C linkage.\n  bool isExternC() const;\n\n  /// Determines whether this function's context is, or is nested within,\n  /// a C++ extern \"C\" linkage spec.\n  bool isInExternCContext() const;\n\n  /// Determines whether this function's context is, or is nested within,\n  /// a C++ extern \"C++\" linkage spec.\n  bool isInExternCXXContext() const;\n\n  /// Determines whether this is a global function.\n  bool isGlobal() const;\n\n  /// Determines whether this function is known to be 'noreturn', through\n  /// an attribute on its declaration or its type.\n  bool isNoReturn() const;\n\n  /// True if the function was a definition but its body was skipped.\n  bool hasSkippedBody() const { return FunctionDeclBits.HasSkippedBody; }\n  void setHasSkippedBody(bool Skipped = true) {\n    FunctionDeclBits.HasSkippedBody = Skipped;\n  }\n\n  /// True if this function will eventually have a body, once it's fully parsed.\n  bool willHaveBody() const { return FunctionDeclBits.WillHaveBody; }\n  void setWillHaveBody(bool V = true) { FunctionDeclBits.WillHaveBody = V; }\n\n  /// True if this function is considered a multiversioned function.\n  bool isMultiVersion() const {\n    return getCanonicalDecl()->FunctionDeclBits.IsMultiVersion;\n  }\n\n  /// Sets the multiversion state for this declaration and all of its\n  /// redeclarations.\n  void setIsMultiVersion(bool V = true) {\n    getCanonicalDecl()->FunctionDeclBits.IsMultiVersion = V;\n  }\n\n  /// Gets the kind of multiversioning attribute this declaration has. Note that\n  /// this can return a value even if the function is not multiversion, such as\n  /// the case of 'target'.\n  MultiVersionKind getMultiVersionKind() const;\n\n\n  /// True if this function is a multiversioned dispatch function as a part of\n  /// the cpu_specific/cpu_dispatch functionality.\n  bool isCPUDispatchMultiVersion() const;\n  /// True if this function is a multiversioned processor specific function as a\n  /// part of the cpu_specific/cpu_dispatch functionality.\n  bool isCPUSpecificMultiVersion() const;\n\n  /// True if this function is a multiversioned dispatch function as a part of\n  /// the target functionality.\n  bool isTargetMultiVersion() const;\n\n  /// \\brief Get the associated-constraints of this function declaration.\n  /// Currently, this will either be a vector of size 1 containing the\n  /// trailing-requires-clause or an empty vector.\n  ///\n  /// Use this instead of getTrailingRequiresClause for concepts APIs that\n  /// accept an ArrayRef of constraint expressions.\n  void getAssociatedConstraints(SmallVectorImpl<const Expr *> &AC) const {\n    if (auto *TRC = getTrailingRequiresClause())\n      AC.push_back(TRC);\n  }\n\n  void setPreviousDeclaration(FunctionDecl * PrevDecl);\n\n  FunctionDecl *getCanonicalDecl() override;\n  const FunctionDecl *getCanonicalDecl() const {\n    return const_cast<FunctionDecl*>(this)->getCanonicalDecl();\n  }\n\n  unsigned getBuiltinID(bool ConsiderWrapperFunctions = false) const;\n\n  // ArrayRef interface to parameters.\n  ArrayRef<ParmVarDecl *> parameters() const {\n    return {ParamInfo, getNumParams()};\n  }\n  MutableArrayRef<ParmVarDecl *> parameters() {\n    return {ParamInfo, getNumParams()};\n  }\n\n  // Iterator access to formal parameters.\n  using param_iterator = MutableArrayRef<ParmVarDecl *>::iterator;\n  using param_const_iterator = ArrayRef<ParmVarDecl *>::const_iterator;\n\n  bool param_empty() const { return parameters().empty(); }\n  param_iterator param_begin() { return parameters().begin(); }\n  param_iterator param_end() { return parameters().end(); }\n  param_const_iterator param_begin() const { return parameters().begin(); }\n  param_const_iterator param_end() const { return parameters().end(); }\n  size_t param_size() const { return parameters().size(); }\n\n  /// Return the number of parameters this function must have based on its\n  /// FunctionType.  This is the length of the ParamInfo array after it has been\n  /// created.\n  unsigned getNumParams() const;\n\n  const ParmVarDecl *getParamDecl(unsigned i) const {\n    assert(i < getNumParams() && \"Illegal param #\");\n    return ParamInfo[i];\n  }\n  ParmVarDecl *getParamDecl(unsigned i) {\n    assert(i < getNumParams() && \"Illegal param #\");\n    return ParamInfo[i];\n  }\n  void setParams(ArrayRef<ParmVarDecl *> NewParamInfo) {\n    setParams(getASTContext(), NewParamInfo);\n  }\n\n  /// Returns the minimum number of arguments needed to call this function. This\n  /// may be fewer than the number of function parameters, if some of the\n  /// parameters have default arguments (in C++).\n  unsigned getMinRequiredArguments() const;\n\n  /// Determine whether this function has a single parameter, or multiple\n  /// parameters where all but the first have default arguments.\n  ///\n  /// This notion is used in the definition of copy/move constructors and\n  /// initializer list constructors. Note that, unlike getMinRequiredArguments,\n  /// parameter packs are not treated specially here.\n  bool hasOneParamOrDefaultArgs() const;\n\n  /// Find the source location information for how the type of this function\n  /// was written. May be absent (for example if the function was declared via\n  /// a typedef) and may contain a different type from that of the function\n  /// (for example if the function type was adjusted by an attribute).\n  FunctionTypeLoc getFunctionTypeLoc() const;\n\n  QualType getReturnType() const {\n    return getType()->castAs<FunctionType>()->getReturnType();\n  }\n\n  /// Attempt to compute an informative source range covering the\n  /// function return type. This may omit qualifiers and other information with\n  /// limited representation in the AST.\n  SourceRange getReturnTypeSourceRange() const;\n\n  /// Attempt to compute an informative source range covering the\n  /// function parameters, including the ellipsis of a variadic function.\n  /// The source range excludes the parentheses, and is invalid if there are\n  /// no parameters and no ellipsis.\n  SourceRange getParametersSourceRange() const;\n\n  /// Get the declared return type, which may differ from the actual return\n  /// type if the return type is deduced.\n  QualType getDeclaredReturnType() const {\n    auto *TSI = getTypeSourceInfo();\n    QualType T = TSI ? TSI->getType() : getType();\n    return T->castAs<FunctionType>()->getReturnType();\n  }\n\n  /// Gets the ExceptionSpecificationType as declared.\n  ExceptionSpecificationType getExceptionSpecType() const {\n    auto *TSI = getTypeSourceInfo();\n    QualType T = TSI ? TSI->getType() : getType();\n    const auto *FPT = T->getAs<FunctionProtoType>();\n    return FPT ? FPT->getExceptionSpecType() : EST_None;\n  }\n\n  /// Attempt to compute an informative source range covering the\n  /// function exception specification, if any.\n  SourceRange getExceptionSpecSourceRange() const;\n\n  /// Determine the type of an expression that calls this function.\n  QualType getCallResultType() const {\n    return getType()->castAs<FunctionType>()->getCallResultType(\n        getASTContext());\n  }\n\n  /// Returns the storage class as written in the source. For the\n  /// computed linkage of symbol, see getLinkage.\n  StorageClass getStorageClass() const {\n    return static_cast<StorageClass>(FunctionDeclBits.SClass);\n  }\n\n  /// Sets the storage class as written in the source.\n  void setStorageClass(StorageClass SClass) {\n    FunctionDeclBits.SClass = SClass;\n  }\n\n  /// Determine whether the \"inline\" keyword was specified for this\n  /// function.\n  bool isInlineSpecified() const { return FunctionDeclBits.IsInlineSpecified; }\n\n  /// Set whether the \"inline\" keyword was specified for this function.\n  void setInlineSpecified(bool I) {\n    FunctionDeclBits.IsInlineSpecified = I;\n    FunctionDeclBits.IsInline = I;\n  }\n\n  /// Flag that this function is implicitly inline.\n  void setImplicitlyInline(bool I = true) { FunctionDeclBits.IsInline = I; }\n\n  /// Determine whether this function should be inlined, because it is\n  /// either marked \"inline\" or \"constexpr\" or is a member function of a class\n  /// that was defined in the class body.\n  bool isInlined() const { return FunctionDeclBits.IsInline; }\n\n  bool isInlineDefinitionExternallyVisible() const;\n\n  bool isMSExternInline() const;\n\n  bool doesDeclarationForceExternallyVisibleDefinition() const;\n\n  bool isStatic() const { return getStorageClass() == SC_Static; }\n\n  /// Whether this function declaration represents an C++ overloaded\n  /// operator, e.g., \"operator+\".\n  bool isOverloadedOperator() const {\n    return getOverloadedOperator() != OO_None;\n  }\n\n  OverloadedOperatorKind getOverloadedOperator() const;\n\n  const IdentifierInfo *getLiteralIdentifier() const;\n\n  /// If this function is an instantiation of a member function\n  /// of a class template specialization, retrieves the function from\n  /// which it was instantiated.\n  ///\n  /// This routine will return non-NULL for (non-templated) member\n  /// functions of class templates and for instantiations of function\n  /// templates. For example, given:\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   void f(T);\n  /// };\n  /// \\endcode\n  ///\n  /// The declaration for X<int>::f is a (non-templated) FunctionDecl\n  /// whose parent is the class template specialization X<int>. For\n  /// this declaration, getInstantiatedFromFunction() will return\n  /// the FunctionDecl X<T>::A. When a complete definition of\n  /// X<int>::A is required, it will be instantiated from the\n  /// declaration returned by getInstantiatedFromMemberFunction().\n  FunctionDecl *getInstantiatedFromMemberFunction() const;\n\n  /// What kind of templated function this is.\n  TemplatedKind getTemplatedKind() const;\n\n  /// If this function is an instantiation of a member function of a\n  /// class template specialization, retrieves the member specialization\n  /// information.\n  MemberSpecializationInfo *getMemberSpecializationInfo() const;\n\n  /// Specify that this record is an instantiation of the\n  /// member function FD.\n  void setInstantiationOfMemberFunction(FunctionDecl *FD,\n                                        TemplateSpecializationKind TSK) {\n    setInstantiationOfMemberFunction(getASTContext(), FD, TSK);\n  }\n\n  /// Retrieves the function template that is described by this\n  /// function declaration.\n  ///\n  /// Every function template is represented as a FunctionTemplateDecl\n  /// and a FunctionDecl (or something derived from FunctionDecl). The\n  /// former contains template properties (such as the template\n  /// parameter lists) while the latter contains the actual\n  /// description of the template's\n  /// contents. FunctionTemplateDecl::getTemplatedDecl() retrieves the\n  /// FunctionDecl that describes the function template,\n  /// getDescribedFunctionTemplate() retrieves the\n  /// FunctionTemplateDecl from a FunctionDecl.\n  FunctionTemplateDecl *getDescribedFunctionTemplate() const;\n\n  void setDescribedFunctionTemplate(FunctionTemplateDecl *Template);\n\n  /// Determine whether this function is a function template\n  /// specialization.\n  bool isFunctionTemplateSpecialization() const {\n    return getPrimaryTemplate() != nullptr;\n  }\n\n  /// If this function is actually a function template specialization,\n  /// retrieve information about this function template specialization.\n  /// Otherwise, returns NULL.\n  FunctionTemplateSpecializationInfo *getTemplateSpecializationInfo() const;\n\n  /// Determines whether this function is a function template\n  /// specialization or a member of a class template specialization that can\n  /// be implicitly instantiated.\n  bool isImplicitlyInstantiable() const;\n\n  /// Determines if the given function was instantiated from a\n  /// function template.\n  bool isTemplateInstantiation() const;\n\n  /// Retrieve the function declaration from which this function could\n  /// be instantiated, if it is an instantiation (rather than a non-template\n  /// or a specialization, for example).\n  ///\n  /// If \\p ForDefinition is \\c false, explicit specializations will be treated\n  /// as if they were implicit instantiations. This will then find the pattern\n  /// corresponding to non-definition portions of the declaration, such as\n  /// default arguments and the exception specification.\n  FunctionDecl *\n  getTemplateInstantiationPattern(bool ForDefinition = true) const;\n\n  /// Retrieve the primary template that this function template\n  /// specialization either specializes or was instantiated from.\n  ///\n  /// If this function declaration is not a function template specialization,\n  /// returns NULL.\n  FunctionTemplateDecl *getPrimaryTemplate() const;\n\n  /// Retrieve the template arguments used to produce this function\n  /// template specialization from the primary template.\n  ///\n  /// If this function declaration is not a function template specialization,\n  /// returns NULL.\n  const TemplateArgumentList *getTemplateSpecializationArgs() const;\n\n  /// Retrieve the template argument list as written in the sources,\n  /// if any.\n  ///\n  /// If this function declaration is not a function template specialization\n  /// or if it had no explicit template argument list, returns NULL.\n  /// Note that it an explicit template argument list may be written empty,\n  /// e.g., template<> void foo<>(char* s);\n  const ASTTemplateArgumentListInfo*\n  getTemplateSpecializationArgsAsWritten() const;\n\n  /// Specify that this function declaration is actually a function\n  /// template specialization.\n  ///\n  /// \\param Template the function template that this function template\n  /// specialization specializes.\n  ///\n  /// \\param TemplateArgs the template arguments that produced this\n  /// function template specialization from the template.\n  ///\n  /// \\param InsertPos If non-NULL, the position in the function template\n  /// specialization set where the function template specialization data will\n  /// be inserted.\n  ///\n  /// \\param TSK the kind of template specialization this is.\n  ///\n  /// \\param TemplateArgsAsWritten location info of template arguments.\n  ///\n  /// \\param PointOfInstantiation point at which the function template\n  /// specialization was first instantiated.\n  void setFunctionTemplateSpecialization(FunctionTemplateDecl *Template,\n                const TemplateArgumentList *TemplateArgs,\n                void *InsertPos,\n                TemplateSpecializationKind TSK = TSK_ImplicitInstantiation,\n                const TemplateArgumentListInfo *TemplateArgsAsWritten = nullptr,\n                SourceLocation PointOfInstantiation = SourceLocation()) {\n    setFunctionTemplateSpecialization(getASTContext(), Template, TemplateArgs,\n                                      InsertPos, TSK, TemplateArgsAsWritten,\n                                      PointOfInstantiation);\n  }\n\n  /// Specifies that this function declaration is actually a\n  /// dependent function template specialization.\n  void setDependentTemplateSpecialization(ASTContext &Context,\n                             const UnresolvedSetImpl &Templates,\n                      const TemplateArgumentListInfo &TemplateArgs);\n\n  DependentFunctionTemplateSpecializationInfo *\n  getDependentSpecializationInfo() const;\n\n  /// Determine what kind of template instantiation this function\n  /// represents.\n  TemplateSpecializationKind getTemplateSpecializationKind() const;\n\n  /// Determine the kind of template specialization this function represents\n  /// for the purpose of template instantiation.\n  TemplateSpecializationKind\n  getTemplateSpecializationKindForInstantiation() const;\n\n  /// Determine what kind of template instantiation this function\n  /// represents.\n  void setTemplateSpecializationKind(TemplateSpecializationKind TSK,\n                        SourceLocation PointOfInstantiation = SourceLocation());\n\n  /// Retrieve the (first) point of instantiation of a function template\n  /// specialization or a member of a class template specialization.\n  ///\n  /// \\returns the first point of instantiation, if this function was\n  /// instantiated from a template; otherwise, returns an invalid source\n  /// location.\n  SourceLocation getPointOfInstantiation() const;\n\n  /// Determine whether this is or was instantiated from an out-of-line\n  /// definition of a member function.\n  bool isOutOfLine() const override;\n\n  /// Identify a memory copying or setting function.\n  /// If the given function is a memory copy or setting function, returns\n  /// the corresponding Builtin ID. If the function is not a memory function,\n  /// returns 0.\n  unsigned getMemoryFunctionKind() const;\n\n  /// Returns ODRHash of the function.  This value is calculated and\n  /// stored on first call, then the stored value returned on the other calls.\n  unsigned getODRHash();\n\n  /// Returns cached ODRHash of the function.  This must have been previously\n  /// computed and stored.\n  unsigned getODRHash() const;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K >= firstFunction && K <= lastFunction;\n  }\n  static DeclContext *castToDeclContext(const FunctionDecl *D) {\n    return static_cast<DeclContext *>(const_cast<FunctionDecl*>(D));\n  }\n  static FunctionDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<FunctionDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Represents a member of a struct/union/class.\nclass FieldDecl : public DeclaratorDecl, public Mergeable<FieldDecl> {\n  unsigned BitField : 1;\n  unsigned Mutable : 1;\n  mutable unsigned CachedFieldIndex : 30;\n\n  /// The kinds of value we can store in InitializerOrBitWidth.\n  ///\n  /// Note that this is compatible with InClassInitStyle except for\n  /// ISK_CapturedVLAType.\n  enum InitStorageKind {\n    /// If the pointer is null, there's nothing special.  Otherwise,\n    /// this is a bitfield and the pointer is the Expr* storing the\n    /// bit-width.\n    ISK_NoInit = (unsigned) ICIS_NoInit,\n\n    /// The pointer is an (optional due to delayed parsing) Expr*\n    /// holding the copy-initializer.\n    ISK_InClassCopyInit = (unsigned) ICIS_CopyInit,\n\n    /// The pointer is an (optional due to delayed parsing) Expr*\n    /// holding the list-initializer.\n    ISK_InClassListInit = (unsigned) ICIS_ListInit,\n\n    /// The pointer is a VariableArrayType* that's been captured;\n    /// the enclosing context is a lambda or captured statement.\n    ISK_CapturedVLAType,\n  };\n\n  /// If this is a bitfield with a default member initializer, this\n  /// structure is used to represent the two expressions.\n  struct InitAndBitWidth {\n    Expr *Init;\n    Expr *BitWidth;\n  };\n\n  /// Storage for either the bit-width, the in-class initializer, or\n  /// both (via InitAndBitWidth), or the captured variable length array bound.\n  ///\n  /// If the storage kind is ISK_InClassCopyInit or\n  /// ISK_InClassListInit, but the initializer is null, then this\n  /// field has an in-class initializer that has not yet been parsed\n  /// and attached.\n  // FIXME: Tail-allocate this to reduce the size of FieldDecl in the\n  // overwhelmingly common case that we have none of these things.\n  llvm::PointerIntPair<void *, 2, InitStorageKind> InitStorage;\n\nprotected:\n  FieldDecl(Kind DK, DeclContext *DC, SourceLocation StartLoc,\n            SourceLocation IdLoc, IdentifierInfo *Id,\n            QualType T, TypeSourceInfo *TInfo, Expr *BW, bool Mutable,\n            InClassInitStyle InitStyle)\n    : DeclaratorDecl(DK, DC, IdLoc, Id, T, TInfo, StartLoc),\n      BitField(false), Mutable(Mutable), CachedFieldIndex(0),\n      InitStorage(nullptr, (InitStorageKind) InitStyle) {\n    if (BW)\n      setBitWidth(BW);\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static FieldDecl *Create(const ASTContext &C, DeclContext *DC,\n                           SourceLocation StartLoc, SourceLocation IdLoc,\n                           IdentifierInfo *Id, QualType T,\n                           TypeSourceInfo *TInfo, Expr *BW, bool Mutable,\n                           InClassInitStyle InitStyle);\n\n  static FieldDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// Returns the index of this field within its record,\n  /// as appropriate for passing to ASTRecordLayout::getFieldOffset.\n  unsigned getFieldIndex() const;\n\n  /// Determines whether this field is mutable (C++ only).\n  bool isMutable() const { return Mutable; }\n\n  /// Determines whether this field is a bitfield.\n  bool isBitField() const { return BitField; }\n\n  /// Determines whether this is an unnamed bitfield.\n  bool isUnnamedBitfield() const { return isBitField() && !getDeclName(); }\n\n  /// Determines whether this field is a\n  /// representative for an anonymous struct or union. Such fields are\n  /// unnamed and are implicitly generated by the implementation to\n  /// store the data for the anonymous union or struct.\n  bool isAnonymousStructOrUnion() const;\n\n  Expr *getBitWidth() const {\n    if (!BitField)\n      return nullptr;\n    void *Ptr = InitStorage.getPointer();\n    if (getInClassInitStyle())\n      return static_cast<InitAndBitWidth*>(Ptr)->BitWidth;\n    return static_cast<Expr*>(Ptr);\n  }\n\n  unsigned getBitWidthValue(const ASTContext &Ctx) const;\n\n  /// Set the bit-field width for this member.\n  // Note: used by some clients (i.e., do not remove it).\n  void setBitWidth(Expr *Width) {\n    assert(!hasCapturedVLAType() && !BitField &&\n           \"bit width or captured type already set\");\n    assert(Width && \"no bit width specified\");\n    InitStorage.setPointer(\n        InitStorage.getInt()\n            ? new (getASTContext())\n                  InitAndBitWidth{getInClassInitializer(), Width}\n            : static_cast<void*>(Width));\n    BitField = true;\n  }\n\n  /// Remove the bit-field width from this member.\n  // Note: used by some clients (i.e., do not remove it).\n  void removeBitWidth() {\n    assert(isBitField() && \"no bitfield width to remove\");\n    InitStorage.setPointer(getInClassInitializer());\n    BitField = false;\n  }\n\n  /// Is this a zero-length bit-field? Such bit-fields aren't really bit-fields\n  /// at all and instead act as a separator between contiguous runs of other\n  /// bit-fields.\n  bool isZeroLengthBitField(const ASTContext &Ctx) const;\n\n  /// Determine if this field is a subobject of zero size, that is, either a\n  /// zero-length bit-field or a field of empty class type with the\n  /// [[no_unique_address]] attribute.\n  bool isZeroSize(const ASTContext &Ctx) const;\n\n  /// Get the kind of (C++11) default member initializer that this field has.\n  InClassInitStyle getInClassInitStyle() const {\n    InitStorageKind storageKind = InitStorage.getInt();\n    return (storageKind == ISK_CapturedVLAType\n              ? ICIS_NoInit : (InClassInitStyle) storageKind);\n  }\n\n  /// Determine whether this member has a C++11 default member initializer.\n  bool hasInClassInitializer() const {\n    return getInClassInitStyle() != ICIS_NoInit;\n  }\n\n  /// Get the C++11 default member initializer for this member, or null if one\n  /// has not been set. If a valid declaration has a default member initializer,\n  /// but this returns null, then we have not parsed and attached it yet.\n  Expr *getInClassInitializer() const {\n    if (!hasInClassInitializer())\n      return nullptr;\n    void *Ptr = InitStorage.getPointer();\n    if (BitField)\n      return static_cast<InitAndBitWidth*>(Ptr)->Init;\n    return static_cast<Expr*>(Ptr);\n  }\n\n  /// Set the C++11 in-class initializer for this member.\n  void setInClassInitializer(Expr *Init) {\n    assert(hasInClassInitializer() && !getInClassInitializer());\n    if (BitField)\n      static_cast<InitAndBitWidth*>(InitStorage.getPointer())->Init = Init;\n    else\n      InitStorage.setPointer(Init);\n  }\n\n  /// Remove the C++11 in-class initializer from this member.\n  void removeInClassInitializer() {\n    assert(hasInClassInitializer() && \"no initializer to remove\");\n    InitStorage.setPointerAndInt(getBitWidth(), ISK_NoInit);\n  }\n\n  /// Determine whether this member captures the variable length array\n  /// type.\n  bool hasCapturedVLAType() const {\n    return InitStorage.getInt() == ISK_CapturedVLAType;\n  }\n\n  /// Get the captured variable length array type.\n  const VariableArrayType *getCapturedVLAType() const {\n    return hasCapturedVLAType() ? static_cast<const VariableArrayType *>(\n                                      InitStorage.getPointer())\n                                : nullptr;\n  }\n\n  /// Set the captured variable length array type for this field.\n  void setCapturedVLAType(const VariableArrayType *VLAType);\n\n  /// Returns the parent of this field declaration, which\n  /// is the struct in which this field is defined.\n  ///\n  /// Returns null if this is not a normal class/struct field declaration, e.g.\n  /// ObjCAtDefsFieldDecl, ObjCIvarDecl.\n  const RecordDecl *getParent() const {\n    return dyn_cast<RecordDecl>(getDeclContext());\n  }\n\n  RecordDecl *getParent() {\n    return dyn_cast<RecordDecl>(getDeclContext());\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  /// Retrieves the canonical declaration of this field.\n  FieldDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const FieldDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K >= firstField && K <= lastField; }\n};\n\n/// An instance of this object exists for each enum constant\n/// that is defined.  For example, in \"enum X {a,b}\", each of a/b are\n/// EnumConstantDecl's, X is an instance of EnumDecl, and the type of a/b is a\n/// TagType for the X EnumDecl.\nclass EnumConstantDecl : public ValueDecl, public Mergeable<EnumConstantDecl> {\n  Stmt *Init; // an integer constant expression\n  llvm::APSInt Val; // The value.\n\nprotected:\n  EnumConstantDecl(DeclContext *DC, SourceLocation L,\n                   IdentifierInfo *Id, QualType T, Expr *E,\n                   const llvm::APSInt &V)\n    : ValueDecl(EnumConstant, DC, L, Id, T), Init((Stmt*)E), Val(V) {}\n\npublic:\n  friend class StmtIteratorBase;\n\n  static EnumConstantDecl *Create(ASTContext &C, EnumDecl *DC,\n                                  SourceLocation L, IdentifierInfo *Id,\n                                  QualType T, Expr *E,\n                                  const llvm::APSInt &V);\n  static EnumConstantDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  const Expr *getInitExpr() const { return (const Expr*) Init; }\n  Expr *getInitExpr() { return (Expr*) Init; }\n  const llvm::APSInt &getInitVal() const { return Val; }\n\n  void setInitExpr(Expr *E) { Init = (Stmt*) E; }\n  void setInitVal(const llvm::APSInt &V) { Val = V; }\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  /// Retrieves the canonical declaration of this enumerator.\n  EnumConstantDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const EnumConstantDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == EnumConstant; }\n};\n\n/// Represents a field injected from an anonymous union/struct into the parent\n/// scope. These are always implicit.\nclass IndirectFieldDecl : public ValueDecl,\n                          public Mergeable<IndirectFieldDecl> {\n  NamedDecl **Chaining;\n  unsigned ChainingSize;\n\n  IndirectFieldDecl(ASTContext &C, DeclContext *DC, SourceLocation L,\n                    DeclarationName N, QualType T,\n                    MutableArrayRef<NamedDecl *> CH);\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n\n  static IndirectFieldDecl *Create(ASTContext &C, DeclContext *DC,\n                                   SourceLocation L, IdentifierInfo *Id,\n                                   QualType T, llvm::MutableArrayRef<NamedDecl *> CH);\n\n  static IndirectFieldDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  using chain_iterator = ArrayRef<NamedDecl *>::const_iterator;\n\n  ArrayRef<NamedDecl *> chain() const {\n    return llvm::makeArrayRef(Chaining, ChainingSize);\n  }\n  chain_iterator chain_begin() const { return chain().begin(); }\n  chain_iterator chain_end() const { return chain().end(); }\n\n  unsigned getChainingSize() const { return ChainingSize; }\n\n  FieldDecl *getAnonField() const {\n    assert(chain().size() >= 2);\n    return cast<FieldDecl>(chain().back());\n  }\n\n  VarDecl *getVarDecl() const {\n    assert(chain().size() >= 2);\n    return dyn_cast<VarDecl>(chain().front());\n  }\n\n  IndirectFieldDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const IndirectFieldDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == IndirectField; }\n};\n\n/// Represents a declaration of a type.\nclass TypeDecl : public NamedDecl {\n  friend class ASTContext;\n\n  /// This indicates the Type object that represents\n  /// this TypeDecl.  It is a cache maintained by\n  /// ASTContext::getTypedefType, ASTContext::getTagDeclType, and\n  /// ASTContext::getTemplateTypeParmType, and TemplateTypeParmDecl.\n  mutable const Type *TypeForDecl = nullptr;\n\n  /// The start of the source range for this declaration.\n  SourceLocation LocStart;\n\n  void anchor() override;\n\nprotected:\n  TypeDecl(Kind DK, DeclContext *DC, SourceLocation L, IdentifierInfo *Id,\n           SourceLocation StartL = SourceLocation())\n    : NamedDecl(DK, DC, L, Id), LocStart(StartL) {}\n\npublic:\n  // Low-level accessor. If you just want the type defined by this node,\n  // check out ASTContext::getTypeDeclType or one of\n  // ASTContext::getTypedefType, ASTContext::getRecordType, etc. if you\n  // already know the specific kind of node this is.\n  const Type *getTypeForDecl() const { return TypeForDecl; }\n  void setTypeForDecl(const Type *TD) { TypeForDecl = TD; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return LocStart; }\n  void setLocStart(SourceLocation L) { LocStart = L; }\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    if (LocStart.isValid())\n      return SourceRange(LocStart, getLocation());\n    else\n      return SourceRange(getLocation());\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K >= firstType && K <= lastType; }\n};\n\n/// Base class for declarations which introduce a typedef-name.\nclass TypedefNameDecl : public TypeDecl, public Redeclarable<TypedefNameDecl> {\n  struct alignas(8) ModedTInfo {\n    TypeSourceInfo *first;\n    QualType second;\n  };\n\n  /// If int part is 0, we have not computed IsTransparentTag.\n  /// Otherwise, IsTransparentTag is (getInt() >> 1).\n  mutable llvm::PointerIntPair<\n      llvm::PointerUnion<TypeSourceInfo *, ModedTInfo *>, 2>\n      MaybeModedTInfo;\n\n  void anchor() override;\n\nprotected:\n  TypedefNameDecl(Kind DK, ASTContext &C, DeclContext *DC,\n                  SourceLocation StartLoc, SourceLocation IdLoc,\n                  IdentifierInfo *Id, TypeSourceInfo *TInfo)\n      : TypeDecl(DK, DC, IdLoc, Id, StartLoc), redeclarable_base(C),\n        MaybeModedTInfo(TInfo, 0) {}\n\n  using redeclarable_base = Redeclarable<TypedefNameDecl>;\n\n  TypedefNameDecl *getNextRedeclarationImpl() override {\n    return getNextRedeclaration();\n  }\n\n  TypedefNameDecl *getPreviousDeclImpl() override {\n    return getPreviousDecl();\n  }\n\n  TypedefNameDecl *getMostRecentDeclImpl() override {\n    return getMostRecentDecl();\n  }\n\npublic:\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  bool isModed() const {\n    return MaybeModedTInfo.getPointer().is<ModedTInfo *>();\n  }\n\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return isModed() ? MaybeModedTInfo.getPointer().get<ModedTInfo *>()->first\n                     : MaybeModedTInfo.getPointer().get<TypeSourceInfo *>();\n  }\n\n  QualType getUnderlyingType() const {\n    return isModed() ? MaybeModedTInfo.getPointer().get<ModedTInfo *>()->second\n                     : MaybeModedTInfo.getPointer()\n                           .get<TypeSourceInfo *>()\n                           ->getType();\n  }\n\n  void setTypeSourceInfo(TypeSourceInfo *newType) {\n    MaybeModedTInfo.setPointer(newType);\n  }\n\n  void setModedTypeSourceInfo(TypeSourceInfo *unmodedTSI, QualType modedTy) {\n    MaybeModedTInfo.setPointer(new (getASTContext(), 8)\n                                   ModedTInfo({unmodedTSI, modedTy}));\n  }\n\n  /// Retrieves the canonical declaration of this typedef-name.\n  TypedefNameDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const TypedefNameDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  /// Retrieves the tag declaration for which this is the typedef name for\n  /// linkage purposes, if any.\n  ///\n  /// \\param AnyRedecl Look for the tag declaration in any redeclaration of\n  /// this typedef declaration.\n  TagDecl *getAnonDeclWithTypedefName(bool AnyRedecl = false) const;\n\n  /// Determines if this typedef shares a name and spelling location with its\n  /// underlying tag type, as is the case with the NS_ENUM macro.\n  bool isTransparentTag() const {\n    if (MaybeModedTInfo.getInt())\n      return MaybeModedTInfo.getInt() & 0x2;\n    return isTransparentTagSlow();\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K >= firstTypedefName && K <= lastTypedefName;\n  }\n\nprivate:\n  bool isTransparentTagSlow() const;\n};\n\n/// Represents the declaration of a typedef-name via the 'typedef'\n/// type specifier.\nclass TypedefDecl : public TypedefNameDecl {\n  TypedefDecl(ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n              SourceLocation IdLoc, IdentifierInfo *Id, TypeSourceInfo *TInfo)\n      : TypedefNameDecl(Typedef, C, DC, StartLoc, IdLoc, Id, TInfo) {}\n\npublic:\n  static TypedefDecl *Create(ASTContext &C, DeclContext *DC,\n                             SourceLocation StartLoc, SourceLocation IdLoc,\n                             IdentifierInfo *Id, TypeSourceInfo *TInfo);\n  static TypedefDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Typedef; }\n};\n\n/// Represents the declaration of a typedef-name via a C++11\n/// alias-declaration.\nclass TypeAliasDecl : public TypedefNameDecl {\n  /// The template for which this is the pattern, if any.\n  TypeAliasTemplateDecl *Template;\n\n  TypeAliasDecl(ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n                SourceLocation IdLoc, IdentifierInfo *Id, TypeSourceInfo *TInfo)\n      : TypedefNameDecl(TypeAlias, C, DC, StartLoc, IdLoc, Id, TInfo),\n        Template(nullptr) {}\n\npublic:\n  static TypeAliasDecl *Create(ASTContext &C, DeclContext *DC,\n                               SourceLocation StartLoc, SourceLocation IdLoc,\n                               IdentifierInfo *Id, TypeSourceInfo *TInfo);\n  static TypeAliasDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  TypeAliasTemplateDecl *getDescribedAliasTemplate() const { return Template; }\n  void setDescribedAliasTemplate(TypeAliasTemplateDecl *TAT) { Template = TAT; }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == TypeAlias; }\n};\n\n/// Represents the declaration of a struct/union/class/enum.\nclass TagDecl : public TypeDecl,\n                public DeclContext,\n                public Redeclarable<TagDecl> {\n  // This class stores some data in DeclContext::TagDeclBits\n  // to save some space. Use the provided accessors to access it.\npublic:\n  // This is really ugly.\n  using TagKind = TagTypeKind;\n\nprivate:\n  SourceRange BraceRange;\n\n  // A struct representing syntactic qualifier info,\n  // to be used for the (uncommon) case of out-of-line declarations.\n  using ExtInfo = QualifierInfo;\n\n  /// If the (out-of-line) tag declaration name\n  /// is qualified, it points to the qualifier info (nns and range);\n  /// otherwise, if the tag declaration is anonymous and it is part of\n  /// a typedef or alias, it points to the TypedefNameDecl (used for mangling);\n  /// otherwise, if the tag declaration is anonymous and it is used as a\n  /// declaration specifier for variables, it points to the first VarDecl (used\n  /// for mangling);\n  /// otherwise, it is a null (TypedefNameDecl) pointer.\n  llvm::PointerUnion<TypedefNameDecl *, ExtInfo *> TypedefNameDeclOrQualifier;\n\n  bool hasExtInfo() const { return TypedefNameDeclOrQualifier.is<ExtInfo *>(); }\n  ExtInfo *getExtInfo() { return TypedefNameDeclOrQualifier.get<ExtInfo *>(); }\n  const ExtInfo *getExtInfo() const {\n    return TypedefNameDeclOrQualifier.get<ExtInfo *>();\n  }\n\nprotected:\n  TagDecl(Kind DK, TagKind TK, const ASTContext &C, DeclContext *DC,\n          SourceLocation L, IdentifierInfo *Id, TagDecl *PrevDecl,\n          SourceLocation StartL);\n\n  using redeclarable_base = Redeclarable<TagDecl>;\n\n  TagDecl *getNextRedeclarationImpl() override {\n    return getNextRedeclaration();\n  }\n\n  TagDecl *getPreviousDeclImpl() override {\n    return getPreviousDecl();\n  }\n\n  TagDecl *getMostRecentDeclImpl() override {\n    return getMostRecentDecl();\n  }\n\n  /// Completes the definition of this tag declaration.\n  ///\n  /// This is a helper function for derived classes.\n  void completeDefinition();\n\n  /// True if this decl is currently being defined.\n  void setBeingDefined(bool V = true) { TagDeclBits.IsBeingDefined = V; }\n\n  /// Indicates whether it is possible for declarations of this kind\n  /// to have an out-of-date definition.\n  ///\n  /// This option is only enabled when modules are enabled.\n  void setMayHaveOutOfDateDef(bool V = true) {\n    TagDeclBits.MayHaveOutOfDateDef = V;\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  SourceRange getBraceRange() const { return BraceRange; }\n  void setBraceRange(SourceRange R) { BraceRange = R; }\n\n  /// Return SourceLocation representing start of source\n  /// range ignoring outer template declarations.\n  SourceLocation getInnerLocStart() const { return getBeginLoc(); }\n\n  /// Return SourceLocation representing start of source\n  /// range taking into account any outer template declarations.\n  SourceLocation getOuterLocStart() const;\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  TagDecl *getCanonicalDecl() override;\n  const TagDecl *getCanonicalDecl() const {\n    return const_cast<TagDecl*>(this)->getCanonicalDecl();\n  }\n\n  /// Return true if this declaration is a completion definition of the type.\n  /// Provided for consistency.\n  bool isThisDeclarationADefinition() const {\n    return isCompleteDefinition();\n  }\n\n  /// Return true if this decl has its body fully specified.\n  bool isCompleteDefinition() const { return TagDeclBits.IsCompleteDefinition; }\n\n  /// True if this decl has its body fully specified.\n  void setCompleteDefinition(bool V = true) {\n    TagDeclBits.IsCompleteDefinition = V;\n  }\n\n  /// Return true if this complete decl is\n  /// required to be complete for some existing use.\n  bool isCompleteDefinitionRequired() const {\n    return TagDeclBits.IsCompleteDefinitionRequired;\n  }\n\n  /// True if this complete decl is\n  /// required to be complete for some existing use.\n  void setCompleteDefinitionRequired(bool V = true) {\n    TagDeclBits.IsCompleteDefinitionRequired = V;\n  }\n\n  /// Return true if this decl is currently being defined.\n  bool isBeingDefined() const { return TagDeclBits.IsBeingDefined; }\n\n  /// True if this tag declaration is \"embedded\" (i.e., defined or declared\n  /// for the very first time) in the syntax of a declarator.\n  bool isEmbeddedInDeclarator() const {\n    return TagDeclBits.IsEmbeddedInDeclarator;\n  }\n\n  /// True if this tag declaration is \"embedded\" (i.e., defined or declared\n  /// for the very first time) in the syntax of a declarator.\n  void setEmbeddedInDeclarator(bool isInDeclarator) {\n    TagDeclBits.IsEmbeddedInDeclarator = isInDeclarator;\n  }\n\n  /// True if this tag is free standing, e.g. \"struct foo;\".\n  bool isFreeStanding() const { return TagDeclBits.IsFreeStanding; }\n\n  /// True if this tag is free standing, e.g. \"struct foo;\".\n  void setFreeStanding(bool isFreeStanding = true) {\n    TagDeclBits.IsFreeStanding = isFreeStanding;\n  }\n\n  /// Indicates whether it is possible for declarations of this kind\n  /// to have an out-of-date definition.\n  ///\n  /// This option is only enabled when modules are enabled.\n  bool mayHaveOutOfDateDef() const { return TagDeclBits.MayHaveOutOfDateDef; }\n\n  /// Whether this declaration declares a type that is\n  /// dependent, i.e., a type that somehow depends on template\n  /// parameters.\n  bool isDependentType() const { return isDependentContext(); }\n\n  /// Starts the definition of this tag declaration.\n  ///\n  /// This method should be invoked at the beginning of the definition\n  /// of this tag declaration. It will set the tag type into a state\n  /// where it is in the process of being defined.\n  void startDefinition();\n\n  /// Returns the TagDecl that actually defines this\n  ///  struct/union/class/enum.  When determining whether or not a\n  ///  struct/union/class/enum has a definition, one should use this\n  ///  method as opposed to 'isDefinition'.  'isDefinition' indicates\n  ///  whether or not a specific TagDecl is defining declaration, not\n  ///  whether or not the struct/union/class/enum type is defined.\n  ///  This method returns NULL if there is no TagDecl that defines\n  ///  the struct/union/class/enum.\n  TagDecl *getDefinition() const;\n\n  StringRef getKindName() const {\n    return TypeWithKeyword::getTagTypeKindName(getTagKind());\n  }\n\n  TagKind getTagKind() const {\n    return static_cast<TagKind>(TagDeclBits.TagDeclKind);\n  }\n\n  void setTagKind(TagKind TK) { TagDeclBits.TagDeclKind = TK; }\n\n  bool isStruct() const { return getTagKind() == TTK_Struct; }\n  bool isInterface() const { return getTagKind() == TTK_Interface; }\n  bool isClass()  const { return getTagKind() == TTK_Class; }\n  bool isUnion()  const { return getTagKind() == TTK_Union; }\n  bool isEnum()   const { return getTagKind() == TTK_Enum; }\n\n  /// Is this tag type named, either directly or via being defined in\n  /// a typedef of this type?\n  ///\n  /// C++11 [basic.link]p8:\n  ///   A type is said to have linkage if and only if:\n  ///     - it is a class or enumeration type that is named (or has a\n  ///       name for linkage purposes) and the name has linkage; ...\n  /// C++11 [dcl.typedef]p9:\n  ///   If the typedef declaration defines an unnamed class (or enum),\n  ///   the first typedef-name declared by the declaration to be that\n  ///   class type (or enum type) is used to denote the class type (or\n  ///   enum type) for linkage purposes only.\n  ///\n  /// C does not have an analogous rule, but the same concept is\n  /// nonetheless useful in some places.\n  bool hasNameForLinkage() const {\n    return (getDeclName() || getTypedefNameForAnonDecl());\n  }\n\n  TypedefNameDecl *getTypedefNameForAnonDecl() const {\n    return hasExtInfo() ? nullptr\n                        : TypedefNameDeclOrQualifier.get<TypedefNameDecl *>();\n  }\n\n  void setTypedefNameForAnonDecl(TypedefNameDecl *TDD);\n\n  /// Retrieve the nested-name-specifier that qualifies the name of this\n  /// declaration, if it was present in the source.\n  NestedNameSpecifier *getQualifier() const {\n    return hasExtInfo() ? getExtInfo()->QualifierLoc.getNestedNameSpecifier()\n                        : nullptr;\n  }\n\n  /// Retrieve the nested-name-specifier (with source-location\n  /// information) that qualifies the name of this declaration, if it was\n  /// present in the source.\n  NestedNameSpecifierLoc getQualifierLoc() const {\n    return hasExtInfo() ? getExtInfo()->QualifierLoc\n                        : NestedNameSpecifierLoc();\n  }\n\n  void setQualifierInfo(NestedNameSpecifierLoc QualifierLoc);\n\n  unsigned getNumTemplateParameterLists() const {\n    return hasExtInfo() ? getExtInfo()->NumTemplParamLists : 0;\n  }\n\n  TemplateParameterList *getTemplateParameterList(unsigned i) const {\n    assert(i < getNumTemplateParameterLists());\n    return getExtInfo()->TemplParamLists[i];\n  }\n\n  void setTemplateParameterListsInfo(ASTContext &Context,\n                                     ArrayRef<TemplateParameterList *> TPLists);\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K >= firstTag && K <= lastTag; }\n\n  static DeclContext *castToDeclContext(const TagDecl *D) {\n    return static_cast<DeclContext *>(const_cast<TagDecl*>(D));\n  }\n\n  static TagDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<TagDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Represents an enum.  In C++11, enums can be forward-declared\n/// with a fixed underlying type, and in C we allow them to be forward-declared\n/// with no underlying type as an extension.\nclass EnumDecl : public TagDecl {\n  // This class stores some data in DeclContext::EnumDeclBits\n  // to save some space. Use the provided accessors to access it.\n\n  /// This represent the integer type that the enum corresponds\n  /// to for code generation purposes.  Note that the enumerator constants may\n  /// have a different type than this does.\n  ///\n  /// If the underlying integer type was explicitly stated in the source\n  /// code, this is a TypeSourceInfo* for that type. Otherwise this type\n  /// was automatically deduced somehow, and this is a Type*.\n  ///\n  /// Normally if IsFixed(), this would contain a TypeSourceInfo*, but in\n  /// some cases it won't.\n  ///\n  /// The underlying type of an enumeration never has any qualifiers, so\n  /// we can get away with just storing a raw Type*, and thus save an\n  /// extra pointer when TypeSourceInfo is needed.\n  llvm::PointerUnion<const Type *, TypeSourceInfo *> IntegerType;\n\n  /// The integer type that values of this type should\n  /// promote to.  In C, enumerators are generally of an integer type\n  /// directly, but gcc-style large enumerators (and all enumerators\n  /// in C++) are of the enum type instead.\n  QualType PromotionType;\n\n  /// If this enumeration is an instantiation of a member enumeration\n  /// of a class template specialization, this is the member specialization\n  /// information.\n  MemberSpecializationInfo *SpecializationInfo = nullptr;\n\n  /// Store the ODRHash after first calculation.\n  /// The corresponding flag HasODRHash is in EnumDeclBits\n  /// and can be accessed with the provided accessors.\n  unsigned ODRHash;\n\n  EnumDecl(ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n           SourceLocation IdLoc, IdentifierInfo *Id, EnumDecl *PrevDecl,\n           bool Scoped, bool ScopedUsingClassTag, bool Fixed);\n\n  void anchor() override;\n\n  void setInstantiationOfMemberEnum(ASTContext &C, EnumDecl *ED,\n                                    TemplateSpecializationKind TSK);\n\n  /// Sets the width in bits required to store all the\n  /// non-negative enumerators of this enum.\n  void setNumPositiveBits(unsigned Num) {\n    EnumDeclBits.NumPositiveBits = Num;\n    assert(EnumDeclBits.NumPositiveBits == Num && \"can't store this bitcount\");\n  }\n\n  /// Returns the width in bits required to store all the\n  /// negative enumerators of this enum. (see getNumNegativeBits)\n  void setNumNegativeBits(unsigned Num) { EnumDeclBits.NumNegativeBits = Num; }\n\npublic:\n  /// True if this tag declaration is a scoped enumeration. Only\n  /// possible in C++11 mode.\n  void setScoped(bool Scoped = true) { EnumDeclBits.IsScoped = Scoped; }\n\n  /// If this tag declaration is a scoped enum,\n  /// then this is true if the scoped enum was declared using the class\n  /// tag, false if it was declared with the struct tag. No meaning is\n  /// associated if this tag declaration is not a scoped enum.\n  void setScopedUsingClassTag(bool ScopedUCT = true) {\n    EnumDeclBits.IsScopedUsingClassTag = ScopedUCT;\n  }\n\n  /// True if this is an Objective-C, C++11, or\n  /// Microsoft-style enumeration with a fixed underlying type.\n  void setFixed(bool Fixed = true) { EnumDeclBits.IsFixed = Fixed; }\n\nprivate:\n  /// True if a valid hash is stored in ODRHash.\n  bool hasODRHash() const { return EnumDeclBits.HasODRHash; }\n  void setHasODRHash(bool Hash = true) { EnumDeclBits.HasODRHash = Hash; }\n\npublic:\n  friend class ASTDeclReader;\n\n  EnumDecl *getCanonicalDecl() override {\n    return cast<EnumDecl>(TagDecl::getCanonicalDecl());\n  }\n  const EnumDecl *getCanonicalDecl() const {\n    return const_cast<EnumDecl*>(this)->getCanonicalDecl();\n  }\n\n  EnumDecl *getPreviousDecl() {\n    return cast_or_null<EnumDecl>(\n            static_cast<TagDecl *>(this)->getPreviousDecl());\n  }\n  const EnumDecl *getPreviousDecl() const {\n    return const_cast<EnumDecl*>(this)->getPreviousDecl();\n  }\n\n  EnumDecl *getMostRecentDecl() {\n    return cast<EnumDecl>(static_cast<TagDecl *>(this)->getMostRecentDecl());\n  }\n  const EnumDecl *getMostRecentDecl() const {\n    return const_cast<EnumDecl*>(this)->getMostRecentDecl();\n  }\n\n  EnumDecl *getDefinition() const {\n    return cast_or_null<EnumDecl>(TagDecl::getDefinition());\n  }\n\n  static EnumDecl *Create(ASTContext &C, DeclContext *DC,\n                          SourceLocation StartLoc, SourceLocation IdLoc,\n                          IdentifierInfo *Id, EnumDecl *PrevDecl,\n                          bool IsScoped, bool IsScopedUsingClassTag,\n                          bool IsFixed);\n  static EnumDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// When created, the EnumDecl corresponds to a\n  /// forward-declared enum. This method is used to mark the\n  /// declaration as being defined; its enumerators have already been\n  /// added (via DeclContext::addDecl). NewType is the new underlying\n  /// type of the enumeration type.\n  void completeDefinition(QualType NewType,\n                          QualType PromotionType,\n                          unsigned NumPositiveBits,\n                          unsigned NumNegativeBits);\n\n  // Iterates through the enumerators of this enumeration.\n  using enumerator_iterator = specific_decl_iterator<EnumConstantDecl>;\n  using enumerator_range =\n      llvm::iterator_range<specific_decl_iterator<EnumConstantDecl>>;\n\n  enumerator_range enumerators() const {\n    return enumerator_range(enumerator_begin(), enumerator_end());\n  }\n\n  enumerator_iterator enumerator_begin() const {\n    const EnumDecl *E = getDefinition();\n    if (!E)\n      E = this;\n    return enumerator_iterator(E->decls_begin());\n  }\n\n  enumerator_iterator enumerator_end() const {\n    const EnumDecl *E = getDefinition();\n    if (!E)\n      E = this;\n    return enumerator_iterator(E->decls_end());\n  }\n\n  /// Return the integer type that enumerators should promote to.\n  QualType getPromotionType() const { return PromotionType; }\n\n  /// Set the promotion type.\n  void setPromotionType(QualType T) { PromotionType = T; }\n\n  /// Return the integer type this enum decl corresponds to.\n  /// This returns a null QualType for an enum forward definition with no fixed\n  /// underlying type.\n  QualType getIntegerType() const {\n    if (!IntegerType)\n      return QualType();\n    if (const Type *T = IntegerType.dyn_cast<const Type*>())\n      return QualType(T, 0);\n    return IntegerType.get<TypeSourceInfo*>()->getType().getUnqualifiedType();\n  }\n\n  /// Set the underlying integer type.\n  void setIntegerType(QualType T) { IntegerType = T.getTypePtrOrNull(); }\n\n  /// Set the underlying integer type source info.\n  void setIntegerTypeSourceInfo(TypeSourceInfo *TInfo) { IntegerType = TInfo; }\n\n  /// Return the type source info for the underlying integer type,\n  /// if no type source info exists, return 0.\n  TypeSourceInfo *getIntegerTypeSourceInfo() const {\n    return IntegerType.dyn_cast<TypeSourceInfo*>();\n  }\n\n  /// Retrieve the source range that covers the underlying type if\n  /// specified.\n  SourceRange getIntegerTypeRange() const LLVM_READONLY;\n\n  /// Returns the width in bits required to store all the\n  /// non-negative enumerators of this enum.\n  unsigned getNumPositiveBits() const { return EnumDeclBits.NumPositiveBits; }\n\n  /// Returns the width in bits required to store all the\n  /// negative enumerators of this enum.  These widths include\n  /// the rightmost leading 1;  that is:\n  ///\n  /// MOST NEGATIVE ENUMERATOR     PATTERN     NUM NEGATIVE BITS\n  /// ------------------------     -------     -----------------\n  ///                       -1     1111111                     1\n  ///                      -10     1110110                     5\n  ///                     -101     1001011                     8\n  unsigned getNumNegativeBits() const { return EnumDeclBits.NumNegativeBits; }\n\n  /// Returns true if this is a C++11 scoped enumeration.\n  bool isScoped() const { return EnumDeclBits.IsScoped; }\n\n  /// Returns true if this is a C++11 scoped enumeration.\n  bool isScopedUsingClassTag() const {\n    return EnumDeclBits.IsScopedUsingClassTag;\n  }\n\n  /// Returns true if this is an Objective-C, C++11, or\n  /// Microsoft-style enumeration with a fixed underlying type.\n  bool isFixed() const { return EnumDeclBits.IsFixed; }\n\n  unsigned getODRHash();\n\n  /// Returns true if this can be considered a complete type.\n  bool isComplete() const {\n    // IntegerType is set for fixed type enums and non-fixed but implicitly\n    // int-sized Microsoft enums.\n    return isCompleteDefinition() || IntegerType;\n  }\n\n  /// Returns true if this enum is either annotated with\n  /// enum_extensibility(closed) or isn't annotated with enum_extensibility.\n  bool isClosed() const;\n\n  /// Returns true if this enum is annotated with flag_enum and isn't annotated\n  /// with enum_extensibility(open).\n  bool isClosedFlag() const;\n\n  /// Returns true if this enum is annotated with neither flag_enum nor\n  /// enum_extensibility(open).\n  bool isClosedNonFlag() const;\n\n  /// Retrieve the enum definition from which this enumeration could\n  /// be instantiated, if it is an instantiation (rather than a non-template).\n  EnumDecl *getTemplateInstantiationPattern() const;\n\n  /// Returns the enumeration (declared within the template)\n  /// from which this enumeration type was instantiated, or NULL if\n  /// this enumeration was not instantiated from any template.\n  EnumDecl *getInstantiatedFromMemberEnum() const;\n\n  /// If this enumeration is a member of a specialization of a\n  /// templated class, determine what kind of template specialization\n  /// or instantiation this is.\n  TemplateSpecializationKind getTemplateSpecializationKind() const;\n\n  /// For an enumeration member that was instantiated from a member\n  /// enumeration of a templated class, set the template specialiation kind.\n  void setTemplateSpecializationKind(TemplateSpecializationKind TSK,\n                        SourceLocation PointOfInstantiation = SourceLocation());\n\n  /// If this enumeration is an instantiation of a member enumeration of\n  /// a class template specialization, retrieves the member specialization\n  /// information.\n  MemberSpecializationInfo *getMemberSpecializationInfo() const {\n    return SpecializationInfo;\n  }\n\n  /// Specify that this enumeration is an instantiation of the\n  /// member enumeration ED.\n  void setInstantiationOfMemberEnum(EnumDecl *ED,\n                                    TemplateSpecializationKind TSK) {\n    setInstantiationOfMemberEnum(getASTContext(), ED, TSK);\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Enum; }\n};\n\n/// Represents a struct/union/class.  For example:\n///   struct X;                  // Forward declaration, no \"body\".\n///   union Y { int A, B; };     // Has body with members A and B (FieldDecls).\n/// This decl will be marked invalid if *any* members are invalid.\nclass RecordDecl : public TagDecl {\n  // This class stores some data in DeclContext::RecordDeclBits\n  // to save some space. Use the provided accessors to access it.\npublic:\n  friend class DeclContext;\n  /// Enum that represents the different ways arguments are passed to and\n  /// returned from function calls. This takes into account the target-specific\n  /// and version-specific rules along with the rules determined by the\n  /// language.\n  enum ArgPassingKind : unsigned {\n    /// The argument of this type can be passed directly in registers.\n    APK_CanPassInRegs,\n\n    /// The argument of this type cannot be passed directly in registers.\n    /// Records containing this type as a subobject are not forced to be passed\n    /// indirectly. This value is used only in C++. This value is required by\n    /// C++ because, in uncommon situations, it is possible for a class to have\n    /// only trivial copy/move constructors even when one of its subobjects has\n    /// a non-trivial copy/move constructor (if e.g. the corresponding copy/move\n    /// constructor in the derived class is deleted).\n    APK_CannotPassInRegs,\n\n    /// The argument of this type cannot be passed directly in registers.\n    /// Records containing this type as a subobject are forced to be passed\n    /// indirectly.\n    APK_CanNeverPassInRegs\n  };\n\nprotected:\n  RecordDecl(Kind DK, TagKind TK, const ASTContext &C, DeclContext *DC,\n             SourceLocation StartLoc, SourceLocation IdLoc,\n             IdentifierInfo *Id, RecordDecl *PrevDecl);\n\npublic:\n  static RecordDecl *Create(const ASTContext &C, TagKind TK, DeclContext *DC,\n                            SourceLocation StartLoc, SourceLocation IdLoc,\n                            IdentifierInfo *Id, RecordDecl* PrevDecl = nullptr);\n  static RecordDecl *CreateDeserialized(const ASTContext &C, unsigned ID);\n\n  RecordDecl *getPreviousDecl() {\n    return cast_or_null<RecordDecl>(\n            static_cast<TagDecl *>(this)->getPreviousDecl());\n  }\n  const RecordDecl *getPreviousDecl() const {\n    return const_cast<RecordDecl*>(this)->getPreviousDecl();\n  }\n\n  RecordDecl *getMostRecentDecl() {\n    return cast<RecordDecl>(static_cast<TagDecl *>(this)->getMostRecentDecl());\n  }\n  const RecordDecl *getMostRecentDecl() const {\n    return const_cast<RecordDecl*>(this)->getMostRecentDecl();\n  }\n\n  bool hasFlexibleArrayMember() const {\n    return RecordDeclBits.HasFlexibleArrayMember;\n  }\n\n  void setHasFlexibleArrayMember(bool V) {\n    RecordDeclBits.HasFlexibleArrayMember = V;\n  }\n\n  /// Whether this is an anonymous struct or union. To be an anonymous\n  /// struct or union, it must have been declared without a name and\n  /// there must be no objects of this type declared, e.g.,\n  /// @code\n  ///   union { int i; float f; };\n  /// @endcode\n  /// is an anonymous union but neither of the following are:\n  /// @code\n  ///  union X { int i; float f; };\n  ///  union { int i; float f; } obj;\n  /// @endcode\n  bool isAnonymousStructOrUnion() const {\n    return RecordDeclBits.AnonymousStructOrUnion;\n  }\n\n  void setAnonymousStructOrUnion(bool Anon) {\n    RecordDeclBits.AnonymousStructOrUnion = Anon;\n  }\n\n  bool hasObjectMember() const { return RecordDeclBits.HasObjectMember; }\n  void setHasObjectMember(bool val) { RecordDeclBits.HasObjectMember = val; }\n\n  bool hasVolatileMember() const { return RecordDeclBits.HasVolatileMember; }\n\n  void setHasVolatileMember(bool val) {\n    RecordDeclBits.HasVolatileMember = val;\n  }\n\n  bool hasLoadedFieldsFromExternalStorage() const {\n    return RecordDeclBits.LoadedFieldsFromExternalStorage;\n  }\n\n  void setHasLoadedFieldsFromExternalStorage(bool val) const {\n    RecordDeclBits.LoadedFieldsFromExternalStorage = val;\n  }\n\n  /// Functions to query basic properties of non-trivial C structs.\n  bool isNonTrivialToPrimitiveDefaultInitialize() const {\n    return RecordDeclBits.NonTrivialToPrimitiveDefaultInitialize;\n  }\n\n  void setNonTrivialToPrimitiveDefaultInitialize(bool V) {\n    RecordDeclBits.NonTrivialToPrimitiveDefaultInitialize = V;\n  }\n\n  bool isNonTrivialToPrimitiveCopy() const {\n    return RecordDeclBits.NonTrivialToPrimitiveCopy;\n  }\n\n  void setNonTrivialToPrimitiveCopy(bool V) {\n    RecordDeclBits.NonTrivialToPrimitiveCopy = V;\n  }\n\n  bool isNonTrivialToPrimitiveDestroy() const {\n    return RecordDeclBits.NonTrivialToPrimitiveDestroy;\n  }\n\n  void setNonTrivialToPrimitiveDestroy(bool V) {\n    RecordDeclBits.NonTrivialToPrimitiveDestroy = V;\n  }\n\n  bool hasNonTrivialToPrimitiveDefaultInitializeCUnion() const {\n    return RecordDeclBits.HasNonTrivialToPrimitiveDefaultInitializeCUnion;\n  }\n\n  void setHasNonTrivialToPrimitiveDefaultInitializeCUnion(bool V) {\n    RecordDeclBits.HasNonTrivialToPrimitiveDefaultInitializeCUnion = V;\n  }\n\n  bool hasNonTrivialToPrimitiveDestructCUnion() const {\n    return RecordDeclBits.HasNonTrivialToPrimitiveDestructCUnion;\n  }\n\n  void setHasNonTrivialToPrimitiveDestructCUnion(bool V) {\n    RecordDeclBits.HasNonTrivialToPrimitiveDestructCUnion = V;\n  }\n\n  bool hasNonTrivialToPrimitiveCopyCUnion() const {\n    return RecordDeclBits.HasNonTrivialToPrimitiveCopyCUnion;\n  }\n\n  void setHasNonTrivialToPrimitiveCopyCUnion(bool V) {\n    RecordDeclBits.HasNonTrivialToPrimitiveCopyCUnion = V;\n  }\n\n  /// Determine whether this class can be passed in registers. In C++ mode,\n  /// it must have at least one trivial, non-deleted copy or move constructor.\n  /// FIXME: This should be set as part of completeDefinition.\n  bool canPassInRegisters() const {\n    return getArgPassingRestrictions() == APK_CanPassInRegs;\n  }\n\n  ArgPassingKind getArgPassingRestrictions() const {\n    return static_cast<ArgPassingKind>(RecordDeclBits.ArgPassingRestrictions);\n  }\n\n  void setArgPassingRestrictions(ArgPassingKind Kind) {\n    RecordDeclBits.ArgPassingRestrictions = Kind;\n  }\n\n  bool isParamDestroyedInCallee() const {\n    return RecordDeclBits.ParamDestroyedInCallee;\n  }\n\n  void setParamDestroyedInCallee(bool V) {\n    RecordDeclBits.ParamDestroyedInCallee = V;\n  }\n\n  /// Determines whether this declaration represents the\n  /// injected class name.\n  ///\n  /// The injected class name in C++ is the name of the class that\n  /// appears inside the class itself. For example:\n  ///\n  /// \\code\n  /// struct C {\n  ///   // C is implicitly declared here as a synonym for the class name.\n  /// };\n  ///\n  /// C::C c; // same as \"C c;\"\n  /// \\endcode\n  bool isInjectedClassName() const;\n\n  /// Determine whether this record is a class describing a lambda\n  /// function object.\n  bool isLambda() const;\n\n  /// Determine whether this record is a record for captured variables in\n  /// CapturedStmt construct.\n  bool isCapturedRecord() const;\n\n  /// Mark the record as a record for captured variables in CapturedStmt\n  /// construct.\n  void setCapturedRecord();\n\n  /// Returns the RecordDecl that actually defines\n  ///  this struct/union/class.  When determining whether or not a\n  ///  struct/union/class is completely defined, one should use this\n  ///  method as opposed to 'isCompleteDefinition'.\n  ///  'isCompleteDefinition' indicates whether or not a specific\n  ///  RecordDecl is a completed definition, not whether or not the\n  ///  record type is defined.  This method returns NULL if there is\n  ///  no RecordDecl that defines the struct/union/tag.\n  RecordDecl *getDefinition() const {\n    return cast_or_null<RecordDecl>(TagDecl::getDefinition());\n  }\n\n  /// Returns whether this record is a union, or contains (at any nesting level)\n  /// a union member. This is used by CMSE to warn about possible information\n  /// leaks.\n  bool isOrContainsUnion() const;\n\n  // Iterator access to field members. The field iterator only visits\n  // the non-static data members of this class, ignoring any static\n  // data members, functions, constructors, destructors, etc.\n  using field_iterator = specific_decl_iterator<FieldDecl>;\n  using field_range = llvm::iterator_range<specific_decl_iterator<FieldDecl>>;\n\n  field_range fields() const { return field_range(field_begin(), field_end()); }\n  field_iterator field_begin() const;\n\n  field_iterator field_end() const {\n    return field_iterator(decl_iterator());\n  }\n\n  // Whether there are any fields (non-static data members) in this record.\n  bool field_empty() const {\n    return field_begin() == field_end();\n  }\n\n  /// Note that the definition of this type is now complete.\n  virtual void completeDefinition();\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K >= firstRecord && K <= lastRecord;\n  }\n\n  /// Get whether or not this is an ms_struct which can\n  /// be turned on with an attribute, pragma, or -mms-bitfields\n  /// commandline option.\n  bool isMsStruct(const ASTContext &C) const;\n\n  /// Whether we are allowed to insert extra padding between fields.\n  /// These padding are added to help AddressSanitizer detect\n  /// intra-object-overflow bugs.\n  bool mayInsertExtraPadding(bool EmitRemark = false) const;\n\n  /// Finds the first data member which has a name.\n  /// nullptr is returned if no named data member exists.\n  const FieldDecl *findFirstNamedDataMember() const;\n\nprivate:\n  /// Deserialize just the fields.\n  void LoadFieldsFromExternalStorage() const;\n};\n\nclass FileScopeAsmDecl : public Decl {\n  StringLiteral *AsmString;\n  SourceLocation RParenLoc;\n\n  FileScopeAsmDecl(DeclContext *DC, StringLiteral *asmstring,\n                   SourceLocation StartL, SourceLocation EndL)\n    : Decl(FileScopeAsm, DC, StartL), AsmString(asmstring), RParenLoc(EndL) {}\n\n  virtual void anchor();\n\npublic:\n  static FileScopeAsmDecl *Create(ASTContext &C, DeclContext *DC,\n                                  StringLiteral *Str, SourceLocation AsmLoc,\n                                  SourceLocation RParenLoc);\n\n  static FileScopeAsmDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceLocation getAsmLoc() const { return getLocation(); }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(getAsmLoc(), getRParenLoc());\n  }\n\n  const StringLiteral *getAsmString() const { return AsmString; }\n  StringLiteral *getAsmString() { return AsmString; }\n  void setAsmString(StringLiteral *Asm) { AsmString = Asm; }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == FileScopeAsm; }\n};\n\n/// Represents a block literal declaration, which is like an\n/// unnamed FunctionDecl.  For example:\n/// ^{ statement-body }   or   ^(int arg1, float arg2){ statement-body }\nclass BlockDecl : public Decl, public DeclContext {\n  // This class stores some data in DeclContext::BlockDeclBits\n  // to save some space. Use the provided accessors to access it.\npublic:\n  /// A class which contains all the information about a particular\n  /// captured value.\n  class Capture {\n    enum {\n      flag_isByRef = 0x1,\n      flag_isNested = 0x2\n    };\n\n    /// The variable being captured.\n    llvm::PointerIntPair<VarDecl*, 2> VariableAndFlags;\n\n    /// The copy expression, expressed in terms of a DeclRef (or\n    /// BlockDeclRef) to the captured variable.  Only required if the\n    /// variable has a C++ class type.\n    Expr *CopyExpr;\n\n  public:\n    Capture(VarDecl *variable, bool byRef, bool nested, Expr *copy)\n      : VariableAndFlags(variable,\n                  (byRef ? flag_isByRef : 0) | (nested ? flag_isNested : 0)),\n        CopyExpr(copy) {}\n\n    /// The variable being captured.\n    VarDecl *getVariable() const { return VariableAndFlags.getPointer(); }\n\n    /// Whether this is a \"by ref\" capture, i.e. a capture of a __block\n    /// variable.\n    bool isByRef() const { return VariableAndFlags.getInt() & flag_isByRef; }\n\n    bool isEscapingByref() const {\n      return getVariable()->isEscapingByref();\n    }\n\n    bool isNonEscapingByref() const {\n      return getVariable()->isNonEscapingByref();\n    }\n\n    /// Whether this is a nested capture, i.e. the variable captured\n    /// is not from outside the immediately enclosing function/block.\n    bool isNested() const { return VariableAndFlags.getInt() & flag_isNested; }\n\n    bool hasCopyExpr() const { return CopyExpr != nullptr; }\n    Expr *getCopyExpr() const { return CopyExpr; }\n    void setCopyExpr(Expr *e) { CopyExpr = e; }\n  };\n\nprivate:\n  /// A new[]'d array of pointers to ParmVarDecls for the formal\n  /// parameters of this function.  This is null if a prototype or if there are\n  /// no formals.\n  ParmVarDecl **ParamInfo = nullptr;\n  unsigned NumParams = 0;\n\n  Stmt *Body = nullptr;\n  TypeSourceInfo *SignatureAsWritten = nullptr;\n\n  const Capture *Captures = nullptr;\n  unsigned NumCaptures = 0;\n\n  unsigned ManglingNumber = 0;\n  Decl *ManglingContextDecl = nullptr;\n\nprotected:\n  BlockDecl(DeclContext *DC, SourceLocation CaretLoc);\n\npublic:\n  static BlockDecl *Create(ASTContext &C, DeclContext *DC, SourceLocation L);\n  static BlockDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceLocation getCaretLocation() const { return getLocation(); }\n\n  bool isVariadic() const { return BlockDeclBits.IsVariadic; }\n  void setIsVariadic(bool value) { BlockDeclBits.IsVariadic = value; }\n\n  CompoundStmt *getCompoundBody() const { return (CompoundStmt*) Body; }\n  Stmt *getBody() const override { return (Stmt*) Body; }\n  void setBody(CompoundStmt *B) { Body = (Stmt*) B; }\n\n  void setSignatureAsWritten(TypeSourceInfo *Sig) { SignatureAsWritten = Sig; }\n  TypeSourceInfo *getSignatureAsWritten() const { return SignatureAsWritten; }\n\n  // ArrayRef access to formal parameters.\n  ArrayRef<ParmVarDecl *> parameters() const {\n    return {ParamInfo, getNumParams()};\n  }\n  MutableArrayRef<ParmVarDecl *> parameters() {\n    return {ParamInfo, getNumParams()};\n  }\n\n  // Iterator access to formal parameters.\n  using param_iterator = MutableArrayRef<ParmVarDecl *>::iterator;\n  using param_const_iterator = ArrayRef<ParmVarDecl *>::const_iterator;\n\n  bool param_empty() const { return parameters().empty(); }\n  param_iterator param_begin() { return parameters().begin(); }\n  param_iterator param_end() { return parameters().end(); }\n  param_const_iterator param_begin() const { return parameters().begin(); }\n  param_const_iterator param_end() const { return parameters().end(); }\n  size_t param_size() const { return parameters().size(); }\n\n  unsigned getNumParams() const { return NumParams; }\n\n  const ParmVarDecl *getParamDecl(unsigned i) const {\n    assert(i < getNumParams() && \"Illegal param #\");\n    return ParamInfo[i];\n  }\n  ParmVarDecl *getParamDecl(unsigned i) {\n    assert(i < getNumParams() && \"Illegal param #\");\n    return ParamInfo[i];\n  }\n\n  void setParams(ArrayRef<ParmVarDecl *> NewParamInfo);\n\n  /// True if this block (or its nested blocks) captures\n  /// anything of local storage from its enclosing scopes.\n  bool hasCaptures() const { return NumCaptures || capturesCXXThis(); }\n\n  /// Returns the number of captured variables.\n  /// Does not include an entry for 'this'.\n  unsigned getNumCaptures() const { return NumCaptures; }\n\n  using capture_const_iterator = ArrayRef<Capture>::const_iterator;\n\n  ArrayRef<Capture> captures() const { return {Captures, NumCaptures}; }\n\n  capture_const_iterator capture_begin() const { return captures().begin(); }\n  capture_const_iterator capture_end() const { return captures().end(); }\n\n  bool capturesCXXThis() const { return BlockDeclBits.CapturesCXXThis; }\n  void setCapturesCXXThis(bool B = true) { BlockDeclBits.CapturesCXXThis = B; }\n\n  bool blockMissingReturnType() const {\n    return BlockDeclBits.BlockMissingReturnType;\n  }\n\n  void setBlockMissingReturnType(bool val = true) {\n    BlockDeclBits.BlockMissingReturnType = val;\n  }\n\n  bool isConversionFromLambda() const {\n    return BlockDeclBits.IsConversionFromLambda;\n  }\n\n  void setIsConversionFromLambda(bool val = true) {\n    BlockDeclBits.IsConversionFromLambda = val;\n  }\n\n  bool doesNotEscape() const { return BlockDeclBits.DoesNotEscape; }\n  void setDoesNotEscape(bool B = true) { BlockDeclBits.DoesNotEscape = B; }\n\n  bool canAvoidCopyToHeap() const {\n    return BlockDeclBits.CanAvoidCopyToHeap;\n  }\n  void setCanAvoidCopyToHeap(bool B = true) {\n    BlockDeclBits.CanAvoidCopyToHeap = B;\n  }\n\n  bool capturesVariable(const VarDecl *var) const;\n\n  void setCaptures(ASTContext &Context, ArrayRef<Capture> Captures,\n                   bool CapturesCXXThis);\n\n  unsigned getBlockManglingNumber() const { return ManglingNumber; }\n\n  Decl *getBlockManglingContextDecl() const { return ManglingContextDecl; }\n\n  void setBlockMangling(unsigned Number, Decl *Ctx) {\n    ManglingNumber = Number;\n    ManglingContextDecl = Ctx;\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Block; }\n  static DeclContext *castToDeclContext(const BlockDecl *D) {\n    return static_cast<DeclContext *>(const_cast<BlockDecl*>(D));\n  }\n  static BlockDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<BlockDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Represents the body of a CapturedStmt, and serves as its DeclContext.\nclass CapturedDecl final\n    : public Decl,\n      public DeclContext,\n      private llvm::TrailingObjects<CapturedDecl, ImplicitParamDecl *> {\nprotected:\n  size_t numTrailingObjects(OverloadToken<ImplicitParamDecl>) {\n    return NumParams;\n  }\n\nprivate:\n  /// The number of parameters to the outlined function.\n  unsigned NumParams;\n\n  /// The position of context parameter in list of parameters.\n  unsigned ContextParam;\n\n  /// The body of the outlined function.\n  llvm::PointerIntPair<Stmt *, 1, bool> BodyAndNothrow;\n\n  explicit CapturedDecl(DeclContext *DC, unsigned NumParams);\n\n  ImplicitParamDecl *const *getParams() const {\n    return getTrailingObjects<ImplicitParamDecl *>();\n  }\n\n  ImplicitParamDecl **getParams() {\n    return getTrailingObjects<ImplicitParamDecl *>();\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend TrailingObjects;\n\n  static CapturedDecl *Create(ASTContext &C, DeclContext *DC,\n                              unsigned NumParams);\n  static CapturedDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                          unsigned NumParams);\n\n  Stmt *getBody() const override;\n  void setBody(Stmt *B);\n\n  bool isNothrow() const;\n  void setNothrow(bool Nothrow = true);\n\n  unsigned getNumParams() const { return NumParams; }\n\n  ImplicitParamDecl *getParam(unsigned i) const {\n    assert(i < NumParams);\n    return getParams()[i];\n  }\n  void setParam(unsigned i, ImplicitParamDecl *P) {\n    assert(i < NumParams);\n    getParams()[i] = P;\n  }\n\n  // ArrayRef interface to parameters.\n  ArrayRef<ImplicitParamDecl *> parameters() const {\n    return {getParams(), getNumParams()};\n  }\n  MutableArrayRef<ImplicitParamDecl *> parameters() {\n    return {getParams(), getNumParams()};\n  }\n\n  /// Retrieve the parameter containing captured variables.\n  ImplicitParamDecl *getContextParam() const {\n    assert(ContextParam < NumParams);\n    return getParam(ContextParam);\n  }\n  void setContextParam(unsigned i, ImplicitParamDecl *P) {\n    assert(i < NumParams);\n    ContextParam = i;\n    setParam(i, P);\n  }\n  unsigned getContextParamPosition() const { return ContextParam; }\n\n  using param_iterator = ImplicitParamDecl *const *;\n  using param_range = llvm::iterator_range<param_iterator>;\n\n  /// Retrieve an iterator pointing to the first parameter decl.\n  param_iterator param_begin() const { return getParams(); }\n  /// Retrieve an iterator one past the last parameter decl.\n  param_iterator param_end() const { return getParams() + NumParams; }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Captured; }\n  static DeclContext *castToDeclContext(const CapturedDecl *D) {\n    return static_cast<DeclContext *>(const_cast<CapturedDecl *>(D));\n  }\n  static CapturedDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<CapturedDecl *>(const_cast<DeclContext *>(DC));\n  }\n};\n\n/// Describes a module import declaration, which makes the contents\n/// of the named module visible in the current translation unit.\n///\n/// An import declaration imports the named module (or submodule). For example:\n/// \\code\n///   @import std.vector;\n/// \\endcode\n///\n/// Import declarations can also be implicitly generated from\n/// \\#include/\\#import directives.\nclass ImportDecl final : public Decl,\n                         llvm::TrailingObjects<ImportDecl, SourceLocation> {\n  friend class ASTContext;\n  friend class ASTDeclReader;\n  friend class ASTReader;\n  friend TrailingObjects;\n\n  /// The imported module.\n  Module *ImportedModule = nullptr;\n\n  /// The next import in the list of imports local to the translation\n  /// unit being parsed (not loaded from an AST file).\n  ///\n  /// Includes a bit that indicates whether we have source-location information\n  /// for each identifier in the module name.\n  ///\n  /// When the bit is false, we only have a single source location for the\n  /// end of the import declaration.\n  llvm::PointerIntPair<ImportDecl *, 1, bool> NextLocalImportAndComplete;\n\n  ImportDecl(DeclContext *DC, SourceLocation StartLoc, Module *Imported,\n             ArrayRef<SourceLocation> IdentifierLocs);\n\n  ImportDecl(DeclContext *DC, SourceLocation StartLoc, Module *Imported,\n             SourceLocation EndLoc);\n\n  ImportDecl(EmptyShell Empty) : Decl(Import, Empty) {}\n\n  bool isImportComplete() const { return NextLocalImportAndComplete.getInt(); }\n\n  void setImportComplete(bool C) { NextLocalImportAndComplete.setInt(C); }\n\n  /// The next import in the list of imports local to the translation\n  /// unit being parsed (not loaded from an AST file).\n  ImportDecl *getNextLocalImport() const {\n    return NextLocalImportAndComplete.getPointer();\n  }\n\n  void setNextLocalImport(ImportDecl *Import) {\n    NextLocalImportAndComplete.setPointer(Import);\n  }\n\npublic:\n  /// Create a new module import declaration.\n  static ImportDecl *Create(ASTContext &C, DeclContext *DC,\n                            SourceLocation StartLoc, Module *Imported,\n                            ArrayRef<SourceLocation> IdentifierLocs);\n\n  /// Create a new module import declaration for an implicitly-generated\n  /// import.\n  static ImportDecl *CreateImplicit(ASTContext &C, DeclContext *DC,\n                                    SourceLocation StartLoc, Module *Imported,\n                                    SourceLocation EndLoc);\n\n  /// Create a new, deserialized module import declaration.\n  static ImportDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                        unsigned NumLocations);\n\n  /// Retrieve the module that was imported by the import declaration.\n  Module *getImportedModule() const { return ImportedModule; }\n\n  /// Retrieves the locations of each of the identifiers that make up\n  /// the complete module name in the import declaration.\n  ///\n  /// This will return an empty array if the locations of the individual\n  /// identifiers aren't available.\n  ArrayRef<SourceLocation> getIdentifierLocs() const;\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Import; }\n};\n\n/// Represents a C++ Modules TS module export declaration.\n///\n/// For example:\n/// \\code\n///   export void foo();\n/// \\endcode\nclass ExportDecl final : public Decl, public DeclContext {\n  virtual void anchor();\n\nprivate:\n  friend class ASTDeclReader;\n\n  /// The source location for the right brace (if valid).\n  SourceLocation RBraceLoc;\n\n  ExportDecl(DeclContext *DC, SourceLocation ExportLoc)\n      : Decl(Export, DC, ExportLoc), DeclContext(Export),\n        RBraceLoc(SourceLocation()) {}\n\npublic:\n  static ExportDecl *Create(ASTContext &C, DeclContext *DC,\n                            SourceLocation ExportLoc);\n  static ExportDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceLocation getExportLoc() const { return getLocation(); }\n  SourceLocation getRBraceLoc() const { return RBraceLoc; }\n  void setRBraceLoc(SourceLocation L) { RBraceLoc = L; }\n\n  bool hasBraces() const { return RBraceLoc.isValid(); }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    if (hasBraces())\n      return RBraceLoc;\n    // No braces: get the end location of the (only) declaration in context\n    // (if present).\n    return decls_empty() ? getLocation() : decls_begin()->getEndLoc();\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(getLocation(), getEndLoc());\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Export; }\n  static DeclContext *castToDeclContext(const ExportDecl *D) {\n    return static_cast<DeclContext *>(const_cast<ExportDecl*>(D));\n  }\n  static ExportDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<ExportDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Represents an empty-declaration.\nclass EmptyDecl : public Decl {\n  EmptyDecl(DeclContext *DC, SourceLocation L) : Decl(Empty, DC, L) {}\n\n  virtual void anchor();\n\npublic:\n  static EmptyDecl *Create(ASTContext &C, DeclContext *DC,\n                           SourceLocation L);\n  static EmptyDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Empty; }\n};\n\n/// Insertion operator for diagnostics.  This allows sending NamedDecl's\n/// into a diagnostic with <<.\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &PD,\n                                             const NamedDecl *ND) {\n  PD.AddTaggedVal(reinterpret_cast<intptr_t>(ND),\n                  DiagnosticsEngine::ak_nameddecl);\n  return PD;\n}\n\ntemplate<typename decl_type>\nvoid Redeclarable<decl_type>::setPreviousDecl(decl_type *PrevDecl) {\n  // Note: This routine is implemented here because we need both NamedDecl\n  // and Redeclarable to be defined.\n  assert(RedeclLink.isFirst() &&\n         \"setPreviousDecl on a decl already in a redeclaration chain\");\n\n  if (PrevDecl) {\n    // Point to previous. Make sure that this is actually the most recent\n    // redeclaration, or we can build invalid chains. If the most recent\n    // redeclaration is invalid, it won't be PrevDecl, but we want it anyway.\n    First = PrevDecl->getFirstDecl();\n    assert(First->RedeclLink.isFirst() && \"Expected first\");\n    decl_type *MostRecent = First->getNextRedeclaration();\n    RedeclLink = PreviousDeclLink(cast<decl_type>(MostRecent));\n\n    // If the declaration was previously visible, a redeclaration of it remains\n    // visible even if it wouldn't be visible by itself.\n    static_cast<decl_type*>(this)->IdentifierNamespace |=\n      MostRecent->getIdentifierNamespace() &\n      (Decl::IDNS_Ordinary | Decl::IDNS_Tag | Decl::IDNS_Type);\n  } else {\n    // Make this first.\n    First = static_cast<decl_type*>(this);\n  }\n\n  // First one will point to this one as latest.\n  First->RedeclLink.setLatest(static_cast<decl_type*>(this));\n\n  assert(!isa<NamedDecl>(static_cast<decl_type*>(this)) ||\n         cast<NamedDecl>(static_cast<decl_type*>(this))->isLinkageValid());\n}\n\n// Inline function definitions.\n\n/// Check if the given decl is complete.\n///\n/// We use this function to break a cycle between the inline definitions in\n/// Type.h and Decl.h.\ninline bool IsEnumDeclComplete(EnumDecl *ED) {\n  return ED->isComplete();\n}\n\n/// Check if the given decl is scoped.\n///\n/// We use this function to break a cycle between the inline definitions in\n/// Type.h and Decl.h.\ninline bool IsEnumDeclScoped(EnumDecl *ED) {\n  return ED->isScoped();\n}\n\n/// OpenMP variants are mangled early based on their OpenMP context selector.\n/// The new name looks likes this:\n///  <name> + OpenMPVariantManglingSeparatorStr + <mangled OpenMP context>\nstatic constexpr StringRef getOpenMPVariantManglingSeparatorStr() {\n  return \"$ompvariant\";\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_DECL_H\n"}, "30": {"id": 30, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclCXX.h", "content": "//===- DeclCXX.h - Classes for representing C++ declarations --*- C++ -*-=====//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the C++ Decl subclasses, other than those for templates\n/// (found in DeclTemplate.h) and friends (in DeclFriend.h).\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_DECLCXX_H\n#define LLVM_CLANG_AST_DECLCXX_H\n\n#include \"clang/AST/ASTUnresolvedSet.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExternalASTSource.h\"\n#include \"clang/AST/LambdaCapture.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/Redeclarable.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/AST/TypeLoc.h\"\n#include \"clang/AST/UnresolvedSet.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/Lambda.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/OperatorKinds.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/TinyPtrVector.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <memory>\n#include <vector>\n\nnamespace clang {\n\nclass ASTContext;\nclass ClassTemplateDecl;\nclass ConstructorUsingShadowDecl;\nclass CXXBasePath;\nclass CXXBasePaths;\nclass CXXConstructorDecl;\nclass CXXDestructorDecl;\nclass CXXFinalOverriderMap;\nclass CXXIndirectPrimaryBaseSet;\nclass CXXMethodDecl;\nclass DecompositionDecl;\nclass DiagnosticBuilder;\nclass FriendDecl;\nclass FunctionTemplateDecl;\nclass IdentifierInfo;\nclass MemberSpecializationInfo;\nclass TemplateDecl;\nclass TemplateParameterList;\nclass UsingDecl;\n\n/// Represents an access specifier followed by colon ':'.\n///\n/// An objects of this class represents sugar for the syntactic occurrence\n/// of an access specifier followed by a colon in the list of member\n/// specifiers of a C++ class definition.\n///\n/// Note that they do not represent other uses of access specifiers,\n/// such as those occurring in a list of base specifiers.\n/// Also note that this class has nothing to do with so-called\n/// \"access declarations\" (C++98 11.3 [class.access.dcl]).\nclass AccessSpecDecl : public Decl {\n  /// The location of the ':'.\n  SourceLocation ColonLoc;\n\n  AccessSpecDecl(AccessSpecifier AS, DeclContext *DC,\n                 SourceLocation ASLoc, SourceLocation ColonLoc)\n    : Decl(AccessSpec, DC, ASLoc), ColonLoc(ColonLoc) {\n    setAccess(AS);\n  }\n\n  AccessSpecDecl(EmptyShell Empty) : Decl(AccessSpec, Empty) {}\n\n  virtual void anchor();\n\npublic:\n  /// The location of the access specifier.\n  SourceLocation getAccessSpecifierLoc() const { return getLocation(); }\n\n  /// Sets the location of the access specifier.\n  void setAccessSpecifierLoc(SourceLocation ASLoc) { setLocation(ASLoc); }\n\n  /// The location of the colon following the access specifier.\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  /// Sets the location of the colon.\n  void setColonLoc(SourceLocation CLoc) { ColonLoc = CLoc; }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(getAccessSpecifierLoc(), getColonLoc());\n  }\n\n  static AccessSpecDecl *Create(ASTContext &C, AccessSpecifier AS,\n                                DeclContext *DC, SourceLocation ASLoc,\n                                SourceLocation ColonLoc) {\n    return new (C, DC) AccessSpecDecl(AS, DC, ASLoc, ColonLoc);\n  }\n\n  static AccessSpecDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == AccessSpec; }\n};\n\n/// Represents a base class of a C++ class.\n///\n/// Each CXXBaseSpecifier represents a single, direct base class (or\n/// struct) of a C++ class (or struct). It specifies the type of that\n/// base class, whether it is a virtual or non-virtual base, and what\n/// level of access (public, protected, private) is used for the\n/// derivation. For example:\n///\n/// \\code\n///   class A { };\n///   class B { };\n///   class C : public virtual A, protected B { };\n/// \\endcode\n///\n/// In this code, C will have two CXXBaseSpecifiers, one for \"public\n/// virtual A\" and the other for \"protected B\".\nclass CXXBaseSpecifier {\n  /// The source code range that covers the full base\n  /// specifier, including the \"virtual\" (if present) and access\n  /// specifier (if present).\n  SourceRange Range;\n\n  /// The source location of the ellipsis, if this is a pack\n  /// expansion.\n  SourceLocation EllipsisLoc;\n\n  /// Whether this is a virtual base class or not.\n  unsigned Virtual : 1;\n\n  /// Whether this is the base of a class (true) or of a struct (false).\n  ///\n  /// This determines the mapping from the access specifier as written in the\n  /// source code to the access specifier used for semantic analysis.\n  unsigned BaseOfClass : 1;\n\n  /// Access specifier as written in the source code (may be AS_none).\n  ///\n  /// The actual type of data stored here is an AccessSpecifier, but we use\n  /// \"unsigned\" here to work around a VC++ bug.\n  unsigned Access : 2;\n\n  /// Whether the class contains a using declaration\n  /// to inherit the named class's constructors.\n  unsigned InheritConstructors : 1;\n\n  /// The type of the base class.\n  ///\n  /// This will be a class or struct (or a typedef of such). The source code\n  /// range does not include the \\c virtual or the access specifier.\n  TypeSourceInfo *BaseTypeInfo;\n\npublic:\n  CXXBaseSpecifier() = default;\n  CXXBaseSpecifier(SourceRange R, bool V, bool BC, AccessSpecifier A,\n                   TypeSourceInfo *TInfo, SourceLocation EllipsisLoc)\n    : Range(R), EllipsisLoc(EllipsisLoc), Virtual(V), BaseOfClass(BC),\n      Access(A), InheritConstructors(false), BaseTypeInfo(TInfo) {}\n\n  /// Retrieves the source range that contains the entire base specifier.\n  SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n\n  /// Get the location at which the base class type was written.\n  SourceLocation getBaseTypeLoc() const LLVM_READONLY {\n    return BaseTypeInfo->getTypeLoc().getBeginLoc();\n  }\n\n  /// Determines whether the base class is a virtual base class (or not).\n  bool isVirtual() const { return Virtual; }\n\n  /// Determine whether this base class is a base of a class declared\n  /// with the 'class' keyword (vs. one declared with the 'struct' keyword).\n  bool isBaseOfClass() const { return BaseOfClass; }\n\n  /// Determine whether this base specifier is a pack expansion.\n  bool isPackExpansion() const { return EllipsisLoc.isValid(); }\n\n  /// Determine whether this base class's constructors get inherited.\n  bool getInheritConstructors() const { return InheritConstructors; }\n\n  /// Set that this base class's constructors should be inherited.\n  void setInheritConstructors(bool Inherit = true) {\n    InheritConstructors = Inherit;\n  }\n\n  /// For a pack expansion, determine the location of the ellipsis.\n  SourceLocation getEllipsisLoc() const {\n    return EllipsisLoc;\n  }\n\n  /// Returns the access specifier for this base specifier.\n  ///\n  /// This is the actual base specifier as used for semantic analysis, so\n  /// the result can never be AS_none. To retrieve the access specifier as\n  /// written in the source code, use getAccessSpecifierAsWritten().\n  AccessSpecifier getAccessSpecifier() const {\n    if ((AccessSpecifier)Access == AS_none)\n      return BaseOfClass? AS_private : AS_public;\n    else\n      return (AccessSpecifier)Access;\n  }\n\n  /// Retrieves the access specifier as written in the source code\n  /// (which may mean that no access specifier was explicitly written).\n  ///\n  /// Use getAccessSpecifier() to retrieve the access specifier for use in\n  /// semantic analysis.\n  AccessSpecifier getAccessSpecifierAsWritten() const {\n    return (AccessSpecifier)Access;\n  }\n\n  /// Retrieves the type of the base class.\n  ///\n  /// This type will always be an unqualified class type.\n  QualType getType() const {\n    return BaseTypeInfo->getType().getUnqualifiedType();\n  }\n\n  /// Retrieves the type and source location of the base class.\n  TypeSourceInfo *getTypeSourceInfo() const { return BaseTypeInfo; }\n};\n\n/// Represents a C++ struct/union/class.\nclass CXXRecordDecl : public RecordDecl {\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend class ASTNodeImporter;\n  friend class ASTReader;\n  friend class ASTRecordWriter;\n  friend class ASTWriter;\n  friend class DeclContext;\n  friend class LambdaExpr;\n\n  friend void FunctionDecl::setPure(bool);\n  friend void TagDecl::startDefinition();\n\n  /// Values used in DefinitionData fields to represent special members.\n  enum SpecialMemberFlags {\n    SMF_DefaultConstructor = 0x1,\n    SMF_CopyConstructor = 0x2,\n    SMF_MoveConstructor = 0x4,\n    SMF_CopyAssignment = 0x8,\n    SMF_MoveAssignment = 0x10,\n    SMF_Destructor = 0x20,\n    SMF_All = 0x3f\n  };\n\n  struct DefinitionData {\n    #define FIELD(Name, Width, Merge) \\\n    unsigned Name : Width;\n    #include \"CXXRecordDeclDefinitionBits.def\"\n\n    /// Whether this class describes a C++ lambda.\n    unsigned IsLambda : 1;\n\n    /// Whether we are currently parsing base specifiers.\n    unsigned IsParsingBaseSpecifiers : 1;\n\n    /// True when visible conversion functions are already computed\n    /// and are available.\n    unsigned ComputedVisibleConversions : 1;\n\n    unsigned HasODRHash : 1;\n\n    /// A hash of parts of the class to help in ODR checking.\n    unsigned ODRHash = 0;\n\n    /// The number of base class specifiers in Bases.\n    unsigned NumBases = 0;\n\n    /// The number of virtual base class specifiers in VBases.\n    unsigned NumVBases = 0;\n\n    /// Base classes of this class.\n    ///\n    /// FIXME: This is wasted space for a union.\n    LazyCXXBaseSpecifiersPtr Bases;\n\n    /// direct and indirect virtual base classes of this class.\n    LazyCXXBaseSpecifiersPtr VBases;\n\n    /// The conversion functions of this C++ class (but not its\n    /// inherited conversion functions).\n    ///\n    /// Each of the entries in this overload set is a CXXConversionDecl.\n    LazyASTUnresolvedSet Conversions;\n\n    /// The conversion functions of this C++ class and all those\n    /// inherited conversion functions that are visible in this class.\n    ///\n    /// Each of the entries in this overload set is a CXXConversionDecl or a\n    /// FunctionTemplateDecl.\n    LazyASTUnresolvedSet VisibleConversions;\n\n    /// The declaration which defines this record.\n    CXXRecordDecl *Definition;\n\n    /// The first friend declaration in this class, or null if there\n    /// aren't any.\n    ///\n    /// This is actually currently stored in reverse order.\n    LazyDeclPtr FirstFriend;\n\n    DefinitionData(CXXRecordDecl *D);\n\n    /// Retrieve the set of direct base classes.\n    CXXBaseSpecifier *getBases() const {\n      if (!Bases.isOffset())\n        return Bases.get(nullptr);\n      return getBasesSlowCase();\n    }\n\n    /// Retrieve the set of virtual base classes.\n    CXXBaseSpecifier *getVBases() const {\n      if (!VBases.isOffset())\n        return VBases.get(nullptr);\n      return getVBasesSlowCase();\n    }\n\n    ArrayRef<CXXBaseSpecifier> bases() const {\n      return llvm::makeArrayRef(getBases(), NumBases);\n    }\n\n    ArrayRef<CXXBaseSpecifier> vbases() const {\n      return llvm::makeArrayRef(getVBases(), NumVBases);\n    }\n\n  private:\n    CXXBaseSpecifier *getBasesSlowCase() const;\n    CXXBaseSpecifier *getVBasesSlowCase() const;\n  };\n\n  struct DefinitionData *DefinitionData;\n\n  /// Describes a C++ closure type (generated by a lambda expression).\n  struct LambdaDefinitionData : public DefinitionData {\n    using Capture = LambdaCapture;\n\n    /// Whether this lambda is known to be dependent, even if its\n    /// context isn't dependent.\n    ///\n    /// A lambda with a non-dependent context can be dependent if it occurs\n    /// within the default argument of a function template, because the\n    /// lambda will have been created with the enclosing context as its\n    /// declaration context, rather than function. This is an unfortunate\n    /// artifact of having to parse the default arguments before.\n    unsigned Dependent : 1;\n\n    /// Whether this lambda is a generic lambda.\n    unsigned IsGenericLambda : 1;\n\n    /// The Default Capture.\n    unsigned CaptureDefault : 2;\n\n    /// The number of captures in this lambda is limited 2^NumCaptures.\n    unsigned NumCaptures : 15;\n\n    /// The number of explicit captures in this lambda.\n    unsigned NumExplicitCaptures : 13;\n\n    /// Has known `internal` linkage.\n    unsigned HasKnownInternalLinkage : 1;\n\n    /// The number used to indicate this lambda expression for name\n    /// mangling in the Itanium C++ ABI.\n    unsigned ManglingNumber : 31;\n\n    /// The declaration that provides context for this lambda, if the\n    /// actual DeclContext does not suffice. This is used for lambdas that\n    /// occur within default arguments of function parameters within the class\n    /// or within a data member initializer.\n    LazyDeclPtr ContextDecl;\n\n    /// The list of captures, both explicit and implicit, for this\n    /// lambda.\n    Capture *Captures = nullptr;\n\n    /// The type of the call method.\n    TypeSourceInfo *MethodTyInfo;\n\n    LambdaDefinitionData(CXXRecordDecl *D, TypeSourceInfo *Info, bool Dependent,\n                         bool IsGeneric, LambdaCaptureDefault CaptureDefault)\n        : DefinitionData(D), Dependent(Dependent), IsGenericLambda(IsGeneric),\n          CaptureDefault(CaptureDefault), NumCaptures(0),\n          NumExplicitCaptures(0), HasKnownInternalLinkage(0), ManglingNumber(0),\n          MethodTyInfo(Info) {\n      IsLambda = true;\n\n      // C++1z [expr.prim.lambda]p4:\n      //   This class type is not an aggregate type.\n      Aggregate = false;\n      PlainOldData = false;\n    }\n  };\n\n  struct DefinitionData *dataPtr() const {\n    // Complete the redecl chain (if necessary).\n    getMostRecentDecl();\n    return DefinitionData;\n  }\n\n  struct DefinitionData &data() const {\n    auto *DD = dataPtr();\n    assert(DD && \"queried property of class with no definition\");\n    return *DD;\n  }\n\n  struct LambdaDefinitionData &getLambdaData() const {\n    // No update required: a merged definition cannot change any lambda\n    // properties.\n    auto *DD = DefinitionData;\n    assert(DD && DD->IsLambda && \"queried lambda property of non-lambda class\");\n    return static_cast<LambdaDefinitionData&>(*DD);\n  }\n\n  /// The template or declaration that this declaration\n  /// describes or was instantiated from, respectively.\n  ///\n  /// For non-templates, this value will be null. For record\n  /// declarations that describe a class template, this will be a\n  /// pointer to a ClassTemplateDecl. For member\n  /// classes of class template specializations, this will be the\n  /// MemberSpecializationInfo referring to the member class that was\n  /// instantiated or specialized.\n  llvm::PointerUnion<ClassTemplateDecl *, MemberSpecializationInfo *>\n      TemplateOrInstantiation;\n\n  /// Called from setBases and addedMember to notify the class that a\n  /// direct or virtual base class or a member of class type has been added.\n  void addedClassSubobject(CXXRecordDecl *Base);\n\n  /// Notify the class that member has been added.\n  ///\n  /// This routine helps maintain information about the class based on which\n  /// members have been added. It will be invoked by DeclContext::addDecl()\n  /// whenever a member is added to this record.\n  void addedMember(Decl *D);\n\n  void markedVirtualFunctionPure();\n\n  /// Get the head of our list of friend declarations, possibly\n  /// deserializing the friends from an external AST source.\n  FriendDecl *getFirstFriend() const;\n\n  /// Determine whether this class has an empty base class subobject of type X\n  /// or of one of the types that might be at offset 0 within X (per the C++\n  /// \"standard layout\" rules).\n  bool hasSubobjectAtOffsetZeroOfEmptyBaseType(ASTContext &Ctx,\n                                               const CXXRecordDecl *X);\n\nprotected:\n  CXXRecordDecl(Kind K, TagKind TK, const ASTContext &C, DeclContext *DC,\n                SourceLocation StartLoc, SourceLocation IdLoc,\n                IdentifierInfo *Id, CXXRecordDecl *PrevDecl);\n\npublic:\n  /// Iterator that traverses the base classes of a class.\n  using base_class_iterator = CXXBaseSpecifier *;\n\n  /// Iterator that traverses the base classes of a class.\n  using base_class_const_iterator = const CXXBaseSpecifier *;\n\n  CXXRecordDecl *getCanonicalDecl() override {\n    return cast<CXXRecordDecl>(RecordDecl::getCanonicalDecl());\n  }\n\n  const CXXRecordDecl *getCanonicalDecl() const {\n    return const_cast<CXXRecordDecl*>(this)->getCanonicalDecl();\n  }\n\n  CXXRecordDecl *getPreviousDecl() {\n    return cast_or_null<CXXRecordDecl>(\n            static_cast<RecordDecl *>(this)->getPreviousDecl());\n  }\n\n  const CXXRecordDecl *getPreviousDecl() const {\n    return const_cast<CXXRecordDecl*>(this)->getPreviousDecl();\n  }\n\n  CXXRecordDecl *getMostRecentDecl() {\n    return cast<CXXRecordDecl>(\n            static_cast<RecordDecl *>(this)->getMostRecentDecl());\n  }\n\n  const CXXRecordDecl *getMostRecentDecl() const {\n    return const_cast<CXXRecordDecl*>(this)->getMostRecentDecl();\n  }\n\n  CXXRecordDecl *getMostRecentNonInjectedDecl() {\n    CXXRecordDecl *Recent =\n        static_cast<CXXRecordDecl *>(this)->getMostRecentDecl();\n    while (Recent->isInjectedClassName()) {\n      // FIXME: Does injected class name need to be in the redeclarations chain?\n      assert(Recent->getPreviousDecl());\n      Recent = Recent->getPreviousDecl();\n    }\n    return Recent;\n  }\n\n  const CXXRecordDecl *getMostRecentNonInjectedDecl() const {\n    return const_cast<CXXRecordDecl*>(this)->getMostRecentNonInjectedDecl();\n  }\n\n  CXXRecordDecl *getDefinition() const {\n    // We only need an update if we don't already know which\n    // declaration is the definition.\n    auto *DD = DefinitionData ? DefinitionData : dataPtr();\n    return DD ? DD->Definition : nullptr;\n  }\n\n  bool hasDefinition() const { return DefinitionData || dataPtr(); }\n\n  static CXXRecordDecl *Create(const ASTContext &C, TagKind TK, DeclContext *DC,\n                               SourceLocation StartLoc, SourceLocation IdLoc,\n                               IdentifierInfo *Id,\n                               CXXRecordDecl *PrevDecl = nullptr,\n                               bool DelayTypeCreation = false);\n  static CXXRecordDecl *CreateLambda(const ASTContext &C, DeclContext *DC,\n                                     TypeSourceInfo *Info, SourceLocation Loc,\n                                     bool DependentLambda, bool IsGeneric,\n                                     LambdaCaptureDefault CaptureDefault);\n  static CXXRecordDecl *CreateDeserialized(const ASTContext &C, unsigned ID);\n\n  bool isDynamicClass() const {\n    return data().Polymorphic || data().NumVBases != 0;\n  }\n\n  /// @returns true if class is dynamic or might be dynamic because the\n  /// definition is incomplete of dependent.\n  bool mayBeDynamicClass() const {\n    return !hasDefinition() || isDynamicClass() || hasAnyDependentBases();\n  }\n\n  /// @returns true if class is non dynamic or might be non dynamic because the\n  /// definition is incomplete of dependent.\n  bool mayBeNonDynamicClass() const {\n    return !hasDefinition() || !isDynamicClass() || hasAnyDependentBases();\n  }\n\n  void setIsParsingBaseSpecifiers() { data().IsParsingBaseSpecifiers = true; }\n\n  bool isParsingBaseSpecifiers() const {\n    return data().IsParsingBaseSpecifiers;\n  }\n\n  unsigned getODRHash() const;\n\n  /// Sets the base classes of this struct or class.\n  void setBases(CXXBaseSpecifier const * const *Bases, unsigned NumBases);\n\n  /// Retrieves the number of base classes of this class.\n  unsigned getNumBases() const { return data().NumBases; }\n\n  using base_class_range = llvm::iterator_range<base_class_iterator>;\n  using base_class_const_range =\n      llvm::iterator_range<base_class_const_iterator>;\n\n  base_class_range bases() {\n    return base_class_range(bases_begin(), bases_end());\n  }\n  base_class_const_range bases() const {\n    return base_class_const_range(bases_begin(), bases_end());\n  }\n\n  base_class_iterator bases_begin() { return data().getBases(); }\n  base_class_const_iterator bases_begin() const { return data().getBases(); }\n  base_class_iterator bases_end() { return bases_begin() + data().NumBases; }\n  base_class_const_iterator bases_end() const {\n    return bases_begin() + data().NumBases;\n  }\n\n  /// Retrieves the number of virtual base classes of this class.\n  unsigned getNumVBases() const { return data().NumVBases; }\n\n  base_class_range vbases() {\n    return base_class_range(vbases_begin(), vbases_end());\n  }\n  base_class_const_range vbases() const {\n    return base_class_const_range(vbases_begin(), vbases_end());\n  }\n\n  base_class_iterator vbases_begin() { return data().getVBases(); }\n  base_class_const_iterator vbases_begin() const { return data().getVBases(); }\n  base_class_iterator vbases_end() { return vbases_begin() + data().NumVBases; }\n  base_class_const_iterator vbases_end() const {\n    return vbases_begin() + data().NumVBases;\n  }\n\n  /// Determine whether this class has any dependent base classes which\n  /// are not the current instantiation.\n  bool hasAnyDependentBases() const;\n\n  /// Iterator access to method members.  The method iterator visits\n  /// all method members of the class, including non-instance methods,\n  /// special methods, etc.\n  using method_iterator = specific_decl_iterator<CXXMethodDecl>;\n  using method_range =\n      llvm::iterator_range<specific_decl_iterator<CXXMethodDecl>>;\n\n  method_range methods() const {\n    return method_range(method_begin(), method_end());\n  }\n\n  /// Method begin iterator.  Iterates in the order the methods\n  /// were declared.\n  method_iterator method_begin() const {\n    return method_iterator(decls_begin());\n  }\n\n  /// Method past-the-end iterator.\n  method_iterator method_end() const {\n    return method_iterator(decls_end());\n  }\n\n  /// Iterator access to constructor members.\n  using ctor_iterator = specific_decl_iterator<CXXConstructorDecl>;\n  using ctor_range =\n      llvm::iterator_range<specific_decl_iterator<CXXConstructorDecl>>;\n\n  ctor_range ctors() const { return ctor_range(ctor_begin(), ctor_end()); }\n\n  ctor_iterator ctor_begin() const {\n    return ctor_iterator(decls_begin());\n  }\n\n  ctor_iterator ctor_end() const {\n    return ctor_iterator(decls_end());\n  }\n\n  /// An iterator over friend declarations.  All of these are defined\n  /// in DeclFriend.h.\n  class friend_iterator;\n  using friend_range = llvm::iterator_range<friend_iterator>;\n\n  friend_range friends() const;\n  friend_iterator friend_begin() const;\n  friend_iterator friend_end() const;\n  void pushFriendDecl(FriendDecl *FD);\n\n  /// Determines whether this record has any friends.\n  bool hasFriends() const {\n    return data().FirstFriend.isValid();\n  }\n\n  /// \\c true if a defaulted copy constructor for this class would be\n  /// deleted.\n  bool defaultedCopyConstructorIsDeleted() const {\n    assert((!needsOverloadResolutionForCopyConstructor() ||\n            (data().DeclaredSpecialMembers & SMF_CopyConstructor)) &&\n           \"this property has not yet been computed by Sema\");\n    return data().DefaultedCopyConstructorIsDeleted;\n  }\n\n  /// \\c true if a defaulted move constructor for this class would be\n  /// deleted.\n  bool defaultedMoveConstructorIsDeleted() const {\n    assert((!needsOverloadResolutionForMoveConstructor() ||\n            (data().DeclaredSpecialMembers & SMF_MoveConstructor)) &&\n           \"this property has not yet been computed by Sema\");\n    return data().DefaultedMoveConstructorIsDeleted;\n  }\n\n  /// \\c true if a defaulted destructor for this class would be deleted.\n  bool defaultedDestructorIsDeleted() const {\n    assert((!needsOverloadResolutionForDestructor() ||\n            (data().DeclaredSpecialMembers & SMF_Destructor)) &&\n           \"this property has not yet been computed by Sema\");\n    return data().DefaultedDestructorIsDeleted;\n  }\n\n  /// \\c true if we know for sure that this class has a single,\n  /// accessible, unambiguous copy constructor that is not deleted.\n  bool hasSimpleCopyConstructor() const {\n    return !hasUserDeclaredCopyConstructor() &&\n           !data().DefaultedCopyConstructorIsDeleted;\n  }\n\n  /// \\c true if we know for sure that this class has a single,\n  /// accessible, unambiguous move constructor that is not deleted.\n  bool hasSimpleMoveConstructor() const {\n    return !hasUserDeclaredMoveConstructor() && hasMoveConstructor() &&\n           !data().DefaultedMoveConstructorIsDeleted;\n  }\n\n  /// \\c true if we know for sure that this class has a single,\n  /// accessible, unambiguous copy assignment operator that is not deleted.\n  bool hasSimpleCopyAssignment() const {\n    return !hasUserDeclaredCopyAssignment() &&\n           !data().DefaultedCopyAssignmentIsDeleted;\n  }\n\n  /// \\c true if we know for sure that this class has a single,\n  /// accessible, unambiguous move assignment operator that is not deleted.\n  bool hasSimpleMoveAssignment() const {\n    return !hasUserDeclaredMoveAssignment() && hasMoveAssignment() &&\n           !data().DefaultedMoveAssignmentIsDeleted;\n  }\n\n  /// \\c true if we know for sure that this class has an accessible\n  /// destructor that is not deleted.\n  bool hasSimpleDestructor() const {\n    return !hasUserDeclaredDestructor() &&\n           !data().DefaultedDestructorIsDeleted;\n  }\n\n  /// Determine whether this class has any default constructors.\n  bool hasDefaultConstructor() const {\n    return (data().DeclaredSpecialMembers & SMF_DefaultConstructor) ||\n           needsImplicitDefaultConstructor();\n  }\n\n  /// Determine if we need to declare a default constructor for\n  /// this class.\n  ///\n  /// This value is used for lazy creation of default constructors.\n  bool needsImplicitDefaultConstructor() const {\n    return (!data().UserDeclaredConstructor &&\n            !(data().DeclaredSpecialMembers & SMF_DefaultConstructor) &&\n            (!isLambda() || lambdaIsDefaultConstructibleAndAssignable())) ||\n           // FIXME: Proposed fix to core wording issue: if a class inherits\n           // a default constructor and doesn't explicitly declare one, one\n           // is declared implicitly.\n           (data().HasInheritedDefaultConstructor &&\n            !(data().DeclaredSpecialMembers & SMF_DefaultConstructor));\n  }\n\n  /// Determine whether this class has any user-declared constructors.\n  ///\n  /// When true, a default constructor will not be implicitly declared.\n  bool hasUserDeclaredConstructor() const {\n    return data().UserDeclaredConstructor;\n  }\n\n  /// Whether this class has a user-provided default constructor\n  /// per C++11.\n  bool hasUserProvidedDefaultConstructor() const {\n    return data().UserProvidedDefaultConstructor;\n  }\n\n  /// Determine whether this class has a user-declared copy constructor.\n  ///\n  /// When false, a copy constructor will be implicitly declared.\n  bool hasUserDeclaredCopyConstructor() const {\n    return data().UserDeclaredSpecialMembers & SMF_CopyConstructor;\n  }\n\n  /// Determine whether this class needs an implicit copy\n  /// constructor to be lazily declared.\n  bool needsImplicitCopyConstructor() const {\n    return !(data().DeclaredSpecialMembers & SMF_CopyConstructor);\n  }\n\n  /// Determine whether we need to eagerly declare a defaulted copy\n  /// constructor for this class.\n  bool needsOverloadResolutionForCopyConstructor() const {\n    // C++17 [class.copy.ctor]p6:\n    //   If the class definition declares a move constructor or move assignment\n    //   operator, the implicitly declared copy constructor is defined as\n    //   deleted.\n    // In MSVC mode, sometimes a declared move assignment does not delete an\n    // implicit copy constructor, so defer this choice to Sema.\n    if (data().UserDeclaredSpecialMembers &\n        (SMF_MoveConstructor | SMF_MoveAssignment))\n      return true;\n    return data().NeedOverloadResolutionForCopyConstructor;\n  }\n\n  /// Determine whether an implicit copy constructor for this type\n  /// would have a parameter with a const-qualified reference type.\n  bool implicitCopyConstructorHasConstParam() const {\n    return data().ImplicitCopyConstructorCanHaveConstParamForNonVBase &&\n           (isAbstract() ||\n            data().ImplicitCopyConstructorCanHaveConstParamForVBase);\n  }\n\n  /// Determine whether this class has a copy constructor with\n  /// a parameter type which is a reference to a const-qualified type.\n  bool hasCopyConstructorWithConstParam() const {\n    return data().HasDeclaredCopyConstructorWithConstParam ||\n           (needsImplicitCopyConstructor() &&\n            implicitCopyConstructorHasConstParam());\n  }\n\n  /// Whether this class has a user-declared move constructor or\n  /// assignment operator.\n  ///\n  /// When false, a move constructor and assignment operator may be\n  /// implicitly declared.\n  bool hasUserDeclaredMoveOperation() const {\n    return data().UserDeclaredSpecialMembers &\n             (SMF_MoveConstructor | SMF_MoveAssignment);\n  }\n\n  /// Determine whether this class has had a move constructor\n  /// declared by the user.\n  bool hasUserDeclaredMoveConstructor() const {\n    return data().UserDeclaredSpecialMembers & SMF_MoveConstructor;\n  }\n\n  /// Determine whether this class has a move constructor.\n  bool hasMoveConstructor() const {\n    return (data().DeclaredSpecialMembers & SMF_MoveConstructor) ||\n           needsImplicitMoveConstructor();\n  }\n\n  /// Set that we attempted to declare an implicit copy\n  /// constructor, but overload resolution failed so we deleted it.\n  void setImplicitCopyConstructorIsDeleted() {\n    assert((data().DefaultedCopyConstructorIsDeleted ||\n            needsOverloadResolutionForCopyConstructor()) &&\n           \"Copy constructor should not be deleted\");\n    data().DefaultedCopyConstructorIsDeleted = true;\n  }\n\n  /// Set that we attempted to declare an implicit move\n  /// constructor, but overload resolution failed so we deleted it.\n  void setImplicitMoveConstructorIsDeleted() {\n    assert((data().DefaultedMoveConstructorIsDeleted ||\n            needsOverloadResolutionForMoveConstructor()) &&\n           \"move constructor should not be deleted\");\n    data().DefaultedMoveConstructorIsDeleted = true;\n  }\n\n  /// Set that we attempted to declare an implicit destructor,\n  /// but overload resolution failed so we deleted it.\n  void setImplicitDestructorIsDeleted() {\n    assert((data().DefaultedDestructorIsDeleted ||\n            needsOverloadResolutionForDestructor()) &&\n           \"destructor should not be deleted\");\n    data().DefaultedDestructorIsDeleted = true;\n  }\n\n  /// Determine whether this class should get an implicit move\n  /// constructor or if any existing special member function inhibits this.\n  bool needsImplicitMoveConstructor() const {\n    return !(data().DeclaredSpecialMembers & SMF_MoveConstructor) &&\n           !hasUserDeclaredCopyConstructor() &&\n           !hasUserDeclaredCopyAssignment() &&\n           !hasUserDeclaredMoveAssignment() &&\n           !hasUserDeclaredDestructor();\n  }\n\n  /// Determine whether we need to eagerly declare a defaulted move\n  /// constructor for this class.\n  bool needsOverloadResolutionForMoveConstructor() const {\n    return data().NeedOverloadResolutionForMoveConstructor;\n  }\n\n  /// Determine whether this class has a user-declared copy assignment\n  /// operator.\n  ///\n  /// When false, a copy assignment operator will be implicitly declared.\n  bool hasUserDeclaredCopyAssignment() const {\n    return data().UserDeclaredSpecialMembers & SMF_CopyAssignment;\n  }\n\n  /// Set that we attempted to declare an implicit copy assignment\n  /// operator, but overload resolution failed so we deleted it.\n  void setImplicitCopyAssignmentIsDeleted() {\n    assert((data().DefaultedCopyAssignmentIsDeleted ||\n            needsOverloadResolutionForCopyAssignment()) &&\n           \"copy assignment should not be deleted\");\n    data().DefaultedCopyAssignmentIsDeleted = true;\n  }\n\n  /// Determine whether this class needs an implicit copy\n  /// assignment operator to be lazily declared.\n  bool needsImplicitCopyAssignment() const {\n    return !(data().DeclaredSpecialMembers & SMF_CopyAssignment);\n  }\n\n  /// Determine whether we need to eagerly declare a defaulted copy\n  /// assignment operator for this class.\n  bool needsOverloadResolutionForCopyAssignment() const {\n    // C++20 [class.copy.assign]p2:\n    //   If the class definition declares a move constructor or move assignment\n    //   operator, the implicitly declared copy assignment operator is defined\n    //   as deleted.\n    // In MSVC mode, sometimes a declared move constructor does not delete an\n    // implicit copy assignment, so defer this choice to Sema.\n    if (data().UserDeclaredSpecialMembers &\n        (SMF_MoveConstructor | SMF_MoveAssignment))\n      return true;\n    return data().NeedOverloadResolutionForCopyAssignment;\n  }\n\n  /// Determine whether an implicit copy assignment operator for this\n  /// type would have a parameter with a const-qualified reference type.\n  bool implicitCopyAssignmentHasConstParam() const {\n    return data().ImplicitCopyAssignmentHasConstParam;\n  }\n\n  /// Determine whether this class has a copy assignment operator with\n  /// a parameter type which is a reference to a const-qualified type or is not\n  /// a reference.\n  bool hasCopyAssignmentWithConstParam() const {\n    return data().HasDeclaredCopyAssignmentWithConstParam ||\n           (needsImplicitCopyAssignment() &&\n            implicitCopyAssignmentHasConstParam());\n  }\n\n  /// Determine whether this class has had a move assignment\n  /// declared by the user.\n  bool hasUserDeclaredMoveAssignment() const {\n    return data().UserDeclaredSpecialMembers & SMF_MoveAssignment;\n  }\n\n  /// Determine whether this class has a move assignment operator.\n  bool hasMoveAssignment() const {\n    return (data().DeclaredSpecialMembers & SMF_MoveAssignment) ||\n           needsImplicitMoveAssignment();\n  }\n\n  /// Set that we attempted to declare an implicit move assignment\n  /// operator, but overload resolution failed so we deleted it.\n  void setImplicitMoveAssignmentIsDeleted() {\n    assert((data().DefaultedMoveAssignmentIsDeleted ||\n            needsOverloadResolutionForMoveAssignment()) &&\n           \"move assignment should not be deleted\");\n    data().DefaultedMoveAssignmentIsDeleted = true;\n  }\n\n  /// Determine whether this class should get an implicit move\n  /// assignment operator or if any existing special member function inhibits\n  /// this.\n  bool needsImplicitMoveAssignment() const {\n    return !(data().DeclaredSpecialMembers & SMF_MoveAssignment) &&\n           !hasUserDeclaredCopyConstructor() &&\n           !hasUserDeclaredCopyAssignment() &&\n           !hasUserDeclaredMoveConstructor() &&\n           !hasUserDeclaredDestructor() &&\n           (!isLambda() || lambdaIsDefaultConstructibleAndAssignable());\n  }\n\n  /// Determine whether we need to eagerly declare a move assignment\n  /// operator for this class.\n  bool needsOverloadResolutionForMoveAssignment() const {\n    return data().NeedOverloadResolutionForMoveAssignment;\n  }\n\n  /// Determine whether this class has a user-declared destructor.\n  ///\n  /// When false, a destructor will be implicitly declared.\n  bool hasUserDeclaredDestructor() const {\n    return data().UserDeclaredSpecialMembers & SMF_Destructor;\n  }\n\n  /// Determine whether this class needs an implicit destructor to\n  /// be lazily declared.\n  bool needsImplicitDestructor() const {\n    return !(data().DeclaredSpecialMembers & SMF_Destructor);\n  }\n\n  /// Determine whether we need to eagerly declare a destructor for this\n  /// class.\n  bool needsOverloadResolutionForDestructor() const {\n    return data().NeedOverloadResolutionForDestructor;\n  }\n\n  /// Determine whether this class describes a lambda function object.\n  bool isLambda() const {\n    // An update record can't turn a non-lambda into a lambda.\n    auto *DD = DefinitionData;\n    return DD && DD->IsLambda;\n  }\n\n  /// Determine whether this class describes a generic\n  /// lambda function object (i.e. function call operator is\n  /// a template).\n  bool isGenericLambda() const;\n\n  /// Determine whether this lambda should have an implicit default constructor\n  /// and copy and move assignment operators.\n  bool lambdaIsDefaultConstructibleAndAssignable() const;\n\n  /// Retrieve the lambda call operator of the closure type\n  /// if this is a closure type.\n  CXXMethodDecl *getLambdaCallOperator() const;\n\n  /// Retrieve the dependent lambda call operator of the closure type\n  /// if this is a templated closure type.\n  FunctionTemplateDecl *getDependentLambdaCallOperator() const;\n\n  /// Retrieve the lambda static invoker, the address of which\n  /// is returned by the conversion operator, and the body of which\n  /// is forwarded to the lambda call operator. The version that does not\n  /// take a calling convention uses the 'default' calling convention for free\n  /// functions if the Lambda's calling convention was not modified via\n  /// attribute. Otherwise, it will return the calling convention specified for\n  /// the lambda.\n  CXXMethodDecl *getLambdaStaticInvoker() const;\n  CXXMethodDecl *getLambdaStaticInvoker(CallingConv CC) const;\n\n  /// Retrieve the generic lambda's template parameter list.\n  /// Returns null if the class does not represent a lambda or a generic\n  /// lambda.\n  TemplateParameterList *getGenericLambdaTemplateParameterList() const;\n\n  /// Retrieve the lambda template parameters that were specified explicitly.\n  ArrayRef<NamedDecl *> getLambdaExplicitTemplateParameters() const;\n\n  LambdaCaptureDefault getLambdaCaptureDefault() const {\n    assert(isLambda());\n    return static_cast<LambdaCaptureDefault>(getLambdaData().CaptureDefault);\n  }\n\n  /// Set the captures for this lambda closure type.\n  void setCaptures(ASTContext &Context, ArrayRef<LambdaCapture> Captures);\n\n  /// For a closure type, retrieve the mapping from captured\n  /// variables and \\c this to the non-static data members that store the\n  /// values or references of the captures.\n  ///\n  /// \\param Captures Will be populated with the mapping from captured\n  /// variables to the corresponding fields.\n  ///\n  /// \\param ThisCapture Will be set to the field declaration for the\n  /// \\c this capture.\n  ///\n  /// \\note No entries will be added for init-captures, as they do not capture\n  /// variables.\n  void getCaptureFields(llvm::DenseMap<const VarDecl *, FieldDecl *> &Captures,\n                        FieldDecl *&ThisCapture) const;\n\n  using capture_const_iterator = const LambdaCapture *;\n  using capture_const_range = llvm::iterator_range<capture_const_iterator>;\n\n  capture_const_range captures() const {\n    return capture_const_range(captures_begin(), captures_end());\n  }\n\n  capture_const_iterator captures_begin() const {\n    return isLambda() ? getLambdaData().Captures : nullptr;\n  }\n\n  capture_const_iterator captures_end() const {\n    return isLambda() ? captures_begin() + getLambdaData().NumCaptures\n                      : nullptr;\n  }\n\n  unsigned capture_size() const { return getLambdaData().NumCaptures; }\n\n  using conversion_iterator = UnresolvedSetIterator;\n\n  conversion_iterator conversion_begin() const {\n    return data().Conversions.get(getASTContext()).begin();\n  }\n\n  conversion_iterator conversion_end() const {\n    return data().Conversions.get(getASTContext()).end();\n  }\n\n  /// Removes a conversion function from this class.  The conversion\n  /// function must currently be a member of this class.  Furthermore,\n  /// this class must currently be in the process of being defined.\n  void removeConversion(const NamedDecl *Old);\n\n  /// Get all conversion functions visible in current class,\n  /// including conversion function templates.\n  llvm::iterator_range<conversion_iterator>\n  getVisibleConversionFunctions() const;\n\n  /// Determine whether this class is an aggregate (C++ [dcl.init.aggr]),\n  /// which is a class with no user-declared constructors, no private\n  /// or protected non-static data members, no base classes, and no virtual\n  /// functions (C++ [dcl.init.aggr]p1).\n  bool isAggregate() const { return data().Aggregate; }\n\n  /// Whether this class has any in-class initializers\n  /// for non-static data members (including those in anonymous unions or\n  /// structs).\n  bool hasInClassInitializer() const { return data().HasInClassInitializer; }\n\n  /// Whether this class or any of its subobjects has any members of\n  /// reference type which would make value-initialization ill-formed.\n  ///\n  /// Per C++03 [dcl.init]p5:\n  ///  - if T is a non-union class type without a user-declared constructor,\n  ///    then every non-static data member and base-class component of T is\n  ///    value-initialized [...] A program that calls for [...]\n  ///    value-initialization of an entity of reference type is ill-formed.\n  bool hasUninitializedReferenceMember() const {\n    return !isUnion() && !hasUserDeclaredConstructor() &&\n           data().HasUninitializedReferenceMember;\n  }\n\n  /// Whether this class is a POD-type (C++ [class]p4)\n  ///\n  /// For purposes of this function a class is POD if it is an aggregate\n  /// that has no non-static non-POD data members, no reference data\n  /// members, no user-defined copy assignment operator and no\n  /// user-defined destructor.\n  ///\n  /// Note that this is the C++ TR1 definition of POD.\n  bool isPOD() const { return data().PlainOldData; }\n\n  /// True if this class is C-like, without C++-specific features, e.g.\n  /// it contains only public fields, no bases, tag kind is not 'class', etc.\n  bool isCLike() const;\n\n  /// Determine whether this is an empty class in the sense of\n  /// (C++11 [meta.unary.prop]).\n  ///\n  /// The CXXRecordDecl is a class type, but not a union type,\n  /// with no non-static data members other than bit-fields of length 0,\n  /// no virtual member functions, no virtual base classes,\n  /// and no base class B for which is_empty<B>::value is false.\n  ///\n  /// \\note This does NOT include a check for union-ness.\n  bool isEmpty() const { return data().Empty; }\n\n  bool hasPrivateFields() const {\n    return data().HasPrivateFields;\n  }\n\n  bool hasProtectedFields() const {\n    return data().HasProtectedFields;\n  }\n\n  /// Determine whether this class has direct non-static data members.\n  bool hasDirectFields() const {\n    auto &D = data();\n    return D.HasPublicFields || D.HasProtectedFields || D.HasPrivateFields;\n  }\n\n  /// Whether this class is polymorphic (C++ [class.virtual]),\n  /// which means that the class contains or inherits a virtual function.\n  bool isPolymorphic() const { return data().Polymorphic; }\n\n  /// Determine whether this class has a pure virtual function.\n  ///\n  /// The class is is abstract per (C++ [class.abstract]p2) if it declares\n  /// a pure virtual function or inherits a pure virtual function that is\n  /// not overridden.\n  bool isAbstract() const { return data().Abstract; }\n\n  /// Determine whether this class is standard-layout per\n  /// C++ [class]p7.\n  bool isStandardLayout() const { return data().IsStandardLayout; }\n\n  /// Determine whether this class was standard-layout per\n  /// C++11 [class]p7, specifically using the C++11 rules without any DRs.\n  bool isCXX11StandardLayout() const { return data().IsCXX11StandardLayout; }\n\n  /// Determine whether this class, or any of its class subobjects,\n  /// contains a mutable field.\n  bool hasMutableFields() const { return data().HasMutableFields; }\n\n  /// Determine whether this class has any variant members.\n  bool hasVariantMembers() const { return data().HasVariantMembers; }\n\n  /// Determine whether this class has a trivial default constructor\n  /// (C++11 [class.ctor]p5).\n  bool hasTrivialDefaultConstructor() const {\n    return hasDefaultConstructor() &&\n           (data().HasTrivialSpecialMembers & SMF_DefaultConstructor);\n  }\n\n  /// Determine whether this class has a non-trivial default constructor\n  /// (C++11 [class.ctor]p5).\n  bool hasNonTrivialDefaultConstructor() const {\n    return (data().DeclaredNonTrivialSpecialMembers & SMF_DefaultConstructor) ||\n           (needsImplicitDefaultConstructor() &&\n            !(data().HasTrivialSpecialMembers & SMF_DefaultConstructor));\n  }\n\n  /// Determine whether this class has at least one constexpr constructor\n  /// other than the copy or move constructors.\n  bool hasConstexprNonCopyMoveConstructor() const {\n    return data().HasConstexprNonCopyMoveConstructor ||\n           (needsImplicitDefaultConstructor() &&\n            defaultedDefaultConstructorIsConstexpr());\n  }\n\n  /// Determine whether a defaulted default constructor for this class\n  /// would be constexpr.\n  bool defaultedDefaultConstructorIsConstexpr() const {\n    return data().DefaultedDefaultConstructorIsConstexpr &&\n           (!isUnion() || hasInClassInitializer() || !hasVariantMembers() ||\n            getLangOpts().CPlusPlus20);\n  }\n\n  /// Determine whether this class has a constexpr default constructor.\n  bool hasConstexprDefaultConstructor() const {\n    return data().HasConstexprDefaultConstructor ||\n           (needsImplicitDefaultConstructor() &&\n            defaultedDefaultConstructorIsConstexpr());\n  }\n\n  /// Determine whether this class has a trivial copy constructor\n  /// (C++ [class.copy]p6, C++11 [class.copy]p12)\n  bool hasTrivialCopyConstructor() const {\n    return data().HasTrivialSpecialMembers & SMF_CopyConstructor;\n  }\n\n  bool hasTrivialCopyConstructorForCall() const {\n    return data().HasTrivialSpecialMembersForCall & SMF_CopyConstructor;\n  }\n\n  /// Determine whether this class has a non-trivial copy constructor\n  /// (C++ [class.copy]p6, C++11 [class.copy]p12)\n  bool hasNonTrivialCopyConstructor() const {\n    return data().DeclaredNonTrivialSpecialMembers & SMF_CopyConstructor ||\n           !hasTrivialCopyConstructor();\n  }\n\n  bool hasNonTrivialCopyConstructorForCall() const {\n    return (data().DeclaredNonTrivialSpecialMembersForCall &\n            SMF_CopyConstructor) ||\n           !hasTrivialCopyConstructorForCall();\n  }\n\n  /// Determine whether this class has a trivial move constructor\n  /// (C++11 [class.copy]p12)\n  bool hasTrivialMoveConstructor() const {\n    return hasMoveConstructor() &&\n           (data().HasTrivialSpecialMembers & SMF_MoveConstructor);\n  }\n\n  bool hasTrivialMoveConstructorForCall() const {\n    return hasMoveConstructor() &&\n           (data().HasTrivialSpecialMembersForCall & SMF_MoveConstructor);\n  }\n\n  /// Determine whether this class has a non-trivial move constructor\n  /// (C++11 [class.copy]p12)\n  bool hasNonTrivialMoveConstructor() const {\n    return (data().DeclaredNonTrivialSpecialMembers & SMF_MoveConstructor) ||\n           (needsImplicitMoveConstructor() &&\n            !(data().HasTrivialSpecialMembers & SMF_MoveConstructor));\n  }\n\n  bool hasNonTrivialMoveConstructorForCall() const {\n    return (data().DeclaredNonTrivialSpecialMembersForCall &\n            SMF_MoveConstructor) ||\n           (needsImplicitMoveConstructor() &&\n            !(data().HasTrivialSpecialMembersForCall & SMF_MoveConstructor));\n  }\n\n  /// Determine whether this class has a trivial copy assignment operator\n  /// (C++ [class.copy]p11, C++11 [class.copy]p25)\n  bool hasTrivialCopyAssignment() const {\n    return data().HasTrivialSpecialMembers & SMF_CopyAssignment;\n  }\n\n  /// Determine whether this class has a non-trivial copy assignment\n  /// operator (C++ [class.copy]p11, C++11 [class.copy]p25)\n  bool hasNonTrivialCopyAssignment() const {\n    return data().DeclaredNonTrivialSpecialMembers & SMF_CopyAssignment ||\n           !hasTrivialCopyAssignment();\n  }\n\n  /// Determine whether this class has a trivial move assignment operator\n  /// (C++11 [class.copy]p25)\n  bool hasTrivialMoveAssignment() const {\n    return hasMoveAssignment() &&\n           (data().HasTrivialSpecialMembers & SMF_MoveAssignment);\n  }\n\n  /// Determine whether this class has a non-trivial move assignment\n  /// operator (C++11 [class.copy]p25)\n  bool hasNonTrivialMoveAssignment() const {\n    return (data().DeclaredNonTrivialSpecialMembers & SMF_MoveAssignment) ||\n           (needsImplicitMoveAssignment() &&\n            !(data().HasTrivialSpecialMembers & SMF_MoveAssignment));\n  }\n\n  /// Determine whether a defaulted default constructor for this class\n  /// would be constexpr.\n  bool defaultedDestructorIsConstexpr() const {\n    return data().DefaultedDestructorIsConstexpr &&\n           getLangOpts().CPlusPlus20;\n  }\n\n  /// Determine whether this class has a constexpr destructor.\n  bool hasConstexprDestructor() const;\n\n  /// Determine whether this class has a trivial destructor\n  /// (C++ [class.dtor]p3)\n  bool hasTrivialDestructor() const {\n    return data().HasTrivialSpecialMembers & SMF_Destructor;\n  }\n\n  bool hasTrivialDestructorForCall() const {\n    return data().HasTrivialSpecialMembersForCall & SMF_Destructor;\n  }\n\n  /// Determine whether this class has a non-trivial destructor\n  /// (C++ [class.dtor]p3)\n  bool hasNonTrivialDestructor() const {\n    return !(data().HasTrivialSpecialMembers & SMF_Destructor);\n  }\n\n  bool hasNonTrivialDestructorForCall() const {\n    return !(data().HasTrivialSpecialMembersForCall & SMF_Destructor);\n  }\n\n  void setHasTrivialSpecialMemberForCall() {\n    data().HasTrivialSpecialMembersForCall =\n        (SMF_CopyConstructor | SMF_MoveConstructor | SMF_Destructor);\n  }\n\n  /// Determine whether declaring a const variable with this type is ok\n  /// per core issue 253.\n  bool allowConstDefaultInit() const {\n    return !data().HasUninitializedFields ||\n           !(data().HasDefaultedDefaultConstructor ||\n             needsImplicitDefaultConstructor());\n  }\n\n  /// Determine whether this class has a destructor which has no\n  /// semantic effect.\n  ///\n  /// Any such destructor will be trivial, public, defaulted and not deleted,\n  /// and will call only irrelevant destructors.\n  bool hasIrrelevantDestructor() const {\n    return data().HasIrrelevantDestructor;\n  }\n\n  /// Determine whether this class has a non-literal or/ volatile type\n  /// non-static data member or base class.\n  bool hasNonLiteralTypeFieldsOrBases() const {\n    return data().HasNonLiteralTypeFieldsOrBases;\n  }\n\n  /// Determine whether this class has a using-declaration that names\n  /// a user-declared base class constructor.\n  bool hasInheritedConstructor() const {\n    return data().HasInheritedConstructor;\n  }\n\n  /// Determine whether this class has a using-declaration that names\n  /// a base class assignment operator.\n  bool hasInheritedAssignment() const {\n    return data().HasInheritedAssignment;\n  }\n\n  /// Determine whether this class is considered trivially copyable per\n  /// (C++11 [class]p6).\n  bool isTriviallyCopyable() const;\n\n  /// Determine whether this class is considered trivial.\n  ///\n  /// C++11 [class]p6:\n  ///    \"A trivial class is a class that has a trivial default constructor and\n  ///    is trivially copyable.\"\n  bool isTrivial() const {\n    return isTriviallyCopyable() && hasTrivialDefaultConstructor();\n  }\n\n  /// Determine whether this class is a literal type.\n  ///\n  /// C++11 [basic.types]p10:\n  ///   A class type that has all the following properties:\n  ///     - it has a trivial destructor\n  ///     - every constructor call and full-expression in the\n  ///       brace-or-equal-intializers for non-static data members (if any) is\n  ///       a constant expression.\n  ///     - it is an aggregate type or has at least one constexpr constructor\n  ///       or constructor template that is not a copy or move constructor, and\n  ///     - all of its non-static data members and base classes are of literal\n  ///       types\n  ///\n  /// We resolve DR1361 by ignoring the second bullet. We resolve DR1452 by\n  /// treating types with trivial default constructors as literal types.\n  ///\n  /// Only in C++17 and beyond, are lambdas literal types.\n  bool isLiteral() const {\n    const LangOptions &LangOpts = getLangOpts();\n    return (LangOpts.CPlusPlus20 ? hasConstexprDestructor()\n                                          : hasTrivialDestructor()) &&\n           (!isLambda() || LangOpts.CPlusPlus17) &&\n           !hasNonLiteralTypeFieldsOrBases() &&\n           (isAggregate() || isLambda() ||\n            hasConstexprNonCopyMoveConstructor() ||\n            hasTrivialDefaultConstructor());\n  }\n\n  /// Determine whether this is a structural type.\n  bool isStructural() const {\n    return isLiteral() && data().StructuralIfLiteral;\n  }\n\n  /// If this record is an instantiation of a member class,\n  /// retrieves the member class from which it was instantiated.\n  ///\n  /// This routine will return non-null for (non-templated) member\n  /// classes of class templates. For example, given:\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   struct A { };\n  /// };\n  /// \\endcode\n  ///\n  /// The declaration for X<int>::A is a (non-templated) CXXRecordDecl\n  /// whose parent is the class template specialization X<int>. For\n  /// this declaration, getInstantiatedFromMemberClass() will return\n  /// the CXXRecordDecl X<T>::A. When a complete definition of\n  /// X<int>::A is required, it will be instantiated from the\n  /// declaration returned by getInstantiatedFromMemberClass().\n  CXXRecordDecl *getInstantiatedFromMemberClass() const;\n\n  /// If this class is an instantiation of a member class of a\n  /// class template specialization, retrieves the member specialization\n  /// information.\n  MemberSpecializationInfo *getMemberSpecializationInfo() const;\n\n  /// Specify that this record is an instantiation of the\n  /// member class \\p RD.\n  void setInstantiationOfMemberClass(CXXRecordDecl *RD,\n                                     TemplateSpecializationKind TSK);\n\n  /// Retrieves the class template that is described by this\n  /// class declaration.\n  ///\n  /// Every class template is represented as a ClassTemplateDecl and a\n  /// CXXRecordDecl. The former contains template properties (such as\n  /// the template parameter lists) while the latter contains the\n  /// actual description of the template's\n  /// contents. ClassTemplateDecl::getTemplatedDecl() retrieves the\n  /// CXXRecordDecl that from a ClassTemplateDecl, while\n  /// getDescribedClassTemplate() retrieves the ClassTemplateDecl from\n  /// a CXXRecordDecl.\n  ClassTemplateDecl *getDescribedClassTemplate() const;\n\n  void setDescribedClassTemplate(ClassTemplateDecl *Template);\n\n  /// Determine whether this particular class is a specialization or\n  /// instantiation of a class template or member class of a class template,\n  /// and how it was instantiated or specialized.\n  TemplateSpecializationKind getTemplateSpecializationKind() const;\n\n  /// Set the kind of specialization or template instantiation this is.\n  void setTemplateSpecializationKind(TemplateSpecializationKind TSK);\n\n  /// Retrieve the record declaration from which this record could be\n  /// instantiated. Returns null if this class is not a template instantiation.\n  const CXXRecordDecl *getTemplateInstantiationPattern() const;\n\n  CXXRecordDecl *getTemplateInstantiationPattern() {\n    return const_cast<CXXRecordDecl *>(const_cast<const CXXRecordDecl *>(this)\n                                           ->getTemplateInstantiationPattern());\n  }\n\n  /// Returns the destructor decl for this class.\n  CXXDestructorDecl *getDestructor() const;\n\n  /// Returns true if the class destructor, or any implicitly invoked\n  /// destructors are marked noreturn.\n  bool isAnyDestructorNoReturn() const;\n\n  /// If the class is a local class [class.local], returns\n  /// the enclosing function declaration.\n  const FunctionDecl *isLocalClass() const {\n    if (const auto *RD = dyn_cast<CXXRecordDecl>(getDeclContext()))\n      return RD->isLocalClass();\n\n    return dyn_cast<FunctionDecl>(getDeclContext());\n  }\n\n  FunctionDecl *isLocalClass() {\n    return const_cast<FunctionDecl*>(\n        const_cast<const CXXRecordDecl*>(this)->isLocalClass());\n  }\n\n  /// Determine whether this dependent class is a current instantiation,\n  /// when viewed from within the given context.\n  bool isCurrentInstantiation(const DeclContext *CurContext) const;\n\n  /// Determine whether this class is derived from the class \\p Base.\n  ///\n  /// This routine only determines whether this class is derived from \\p Base,\n  /// but does not account for factors that may make a Derived -> Base class\n  /// ill-formed, such as private/protected inheritance or multiple, ambiguous\n  /// base class subobjects.\n  ///\n  /// \\param Base the base class we are searching for.\n  ///\n  /// \\returns true if this class is derived from Base, false otherwise.\n  bool isDerivedFrom(const CXXRecordDecl *Base) const;\n\n  /// Determine whether this class is derived from the type \\p Base.\n  ///\n  /// This routine only determines whether this class is derived from \\p Base,\n  /// but does not account for factors that may make a Derived -> Base class\n  /// ill-formed, such as private/protected inheritance or multiple, ambiguous\n  /// base class subobjects.\n  ///\n  /// \\param Base the base class we are searching for.\n  ///\n  /// \\param Paths will contain the paths taken from the current class to the\n  /// given \\p Base class.\n  ///\n  /// \\returns true if this class is derived from \\p Base, false otherwise.\n  ///\n  /// \\todo add a separate parameter to configure IsDerivedFrom, rather than\n  /// tangling input and output in \\p Paths\n  bool isDerivedFrom(const CXXRecordDecl *Base, CXXBasePaths &Paths) const;\n\n  /// Determine whether this class is virtually derived from\n  /// the class \\p Base.\n  ///\n  /// This routine only determines whether this class is virtually\n  /// derived from \\p Base, but does not account for factors that may\n  /// make a Derived -> Base class ill-formed, such as\n  /// private/protected inheritance or multiple, ambiguous base class\n  /// subobjects.\n  ///\n  /// \\param Base the base class we are searching for.\n  ///\n  /// \\returns true if this class is virtually derived from Base,\n  /// false otherwise.\n  bool isVirtuallyDerivedFrom(const CXXRecordDecl *Base) const;\n\n  /// Determine whether this class is provably not derived from\n  /// the type \\p Base.\n  bool isProvablyNotDerivedFrom(const CXXRecordDecl *Base) const;\n\n  /// Function type used by forallBases() as a callback.\n  ///\n  /// \\param BaseDefinition the definition of the base class\n  ///\n  /// \\returns true if this base matched the search criteria\n  using ForallBasesCallback =\n      llvm::function_ref<bool(const CXXRecordDecl *BaseDefinition)>;\n\n  /// Determines if the given callback holds for all the direct\n  /// or indirect base classes of this type.\n  ///\n  /// The class itself does not count as a base class.  This routine\n  /// returns false if the class has non-computable base classes.\n  ///\n  /// \\param BaseMatches Callback invoked for each (direct or indirect) base\n  /// class of this type until a call returns false.\n  bool forallBases(ForallBasesCallback BaseMatches) const;\n\n  /// Function type used by lookupInBases() to determine whether a\n  /// specific base class subobject matches the lookup criteria.\n  ///\n  /// \\param Specifier the base-class specifier that describes the inheritance\n  /// from the base class we are trying to match.\n  ///\n  /// \\param Path the current path, from the most-derived class down to the\n  /// base named by the \\p Specifier.\n  ///\n  /// \\returns true if this base matched the search criteria, false otherwise.\n  using BaseMatchesCallback =\n      llvm::function_ref<bool(const CXXBaseSpecifier *Specifier,\n                              CXXBasePath &Path)>;\n\n  /// Look for entities within the base classes of this C++ class,\n  /// transitively searching all base class subobjects.\n  ///\n  /// This routine uses the callback function \\p BaseMatches to find base\n  /// classes meeting some search criteria, walking all base class subobjects\n  /// and populating the given \\p Paths structure with the paths through the\n  /// inheritance hierarchy that resulted in a match. On a successful search,\n  /// the \\p Paths structure can be queried to retrieve the matching paths and\n  /// to determine if there were any ambiguities.\n  ///\n  /// \\param BaseMatches callback function used to determine whether a given\n  /// base matches the user-defined search criteria.\n  ///\n  /// \\param Paths used to record the paths from this class to its base class\n  /// subobjects that match the search criteria.\n  ///\n  /// \\param LookupInDependent can be set to true to extend the search to\n  /// dependent base classes.\n  ///\n  /// \\returns true if there exists any path from this class to a base class\n  /// subobject that matches the search criteria.\n  bool lookupInBases(BaseMatchesCallback BaseMatches, CXXBasePaths &Paths,\n                     bool LookupInDependent = false) const;\n\n  /// Base-class lookup callback that determines whether the given\n  /// base class specifier refers to a specific class declaration.\n  ///\n  /// This callback can be used with \\c lookupInBases() to determine whether\n  /// a given derived class has is a base class subobject of a particular type.\n  /// The base record pointer should refer to the canonical CXXRecordDecl of the\n  /// base class that we are searching for.\n  static bool FindBaseClass(const CXXBaseSpecifier *Specifier,\n                            CXXBasePath &Path, const CXXRecordDecl *BaseRecord);\n\n  /// Base-class lookup callback that determines whether the\n  /// given base class specifier refers to a specific class\n  /// declaration and describes virtual derivation.\n  ///\n  /// This callback can be used with \\c lookupInBases() to determine\n  /// whether a given derived class has is a virtual base class\n  /// subobject of a particular type.  The base record pointer should\n  /// refer to the canonical CXXRecordDecl of the base class that we\n  /// are searching for.\n  static bool FindVirtualBaseClass(const CXXBaseSpecifier *Specifier,\n                                   CXXBasePath &Path,\n                                   const CXXRecordDecl *BaseRecord);\n\n  /// Retrieve the final overriders for each virtual member\n  /// function in the class hierarchy where this class is the\n  /// most-derived class in the class hierarchy.\n  void getFinalOverriders(CXXFinalOverriderMap &FinaOverriders) const;\n\n  /// Get the indirect primary bases for this class.\n  void getIndirectPrimaryBases(CXXIndirectPrimaryBaseSet& Bases) const;\n\n  /// Determine whether this class has a member with the given name, possibly\n  /// in a non-dependent base class.\n  ///\n  /// No check for ambiguity is performed, so this should never be used when\n  /// implementing language semantics, but it may be appropriate for warnings,\n  /// static analysis, or similar.\n  bool hasMemberName(DeclarationName N) const;\n\n  /// Performs an imprecise lookup of a dependent name in this class.\n  ///\n  /// This function does not follow strict semantic rules and should be used\n  /// only when lookup rules can be relaxed, e.g. indexing.\n  std::vector<const NamedDecl *>\n  lookupDependentName(DeclarationName Name,\n                      llvm::function_ref<bool(const NamedDecl *ND)> Filter);\n\n  /// Renders and displays an inheritance diagram\n  /// for this C++ class and all of its base classes (transitively) using\n  /// GraphViz.\n  void viewInheritance(ASTContext& Context) const;\n\n  /// Calculates the access of a decl that is reached\n  /// along a path.\n  static AccessSpecifier MergeAccess(AccessSpecifier PathAccess,\n                                     AccessSpecifier DeclAccess) {\n    assert(DeclAccess != AS_none);\n    if (DeclAccess == AS_private) return AS_none;\n    return (PathAccess > DeclAccess ? PathAccess : DeclAccess);\n  }\n\n  /// Indicates that the declaration of a defaulted or deleted special\n  /// member function is now complete.\n  void finishedDefaultedOrDeletedMember(CXXMethodDecl *MD);\n\n  void setTrivialForCallFlags(CXXMethodDecl *MD);\n\n  /// Indicates that the definition of this class is now complete.\n  void completeDefinition() override;\n\n  /// Indicates that the definition of this class is now complete,\n  /// and provides a final overrider map to help determine\n  ///\n  /// \\param FinalOverriders The final overrider map for this class, which can\n  /// be provided as an optimization for abstract-class checking. If NULL,\n  /// final overriders will be computed if they are needed to complete the\n  /// definition.\n  void completeDefinition(CXXFinalOverriderMap *FinalOverriders);\n\n  /// Determine whether this class may end up being abstract, even though\n  /// it is not yet known to be abstract.\n  ///\n  /// \\returns true if this class is not known to be abstract but has any\n  /// base classes that are abstract. In this case, \\c completeDefinition()\n  /// will need to compute final overriders to determine whether the class is\n  /// actually abstract.\n  bool mayBeAbstract() const;\n\n  /// Determine whether it's impossible for a class to be derived from this\n  /// class. This is best-effort, and may conservatively return false.\n  bool isEffectivelyFinal() const;\n\n  /// If this is the closure type of a lambda expression, retrieve the\n  /// number to be used for name mangling in the Itanium C++ ABI.\n  ///\n  /// Zero indicates that this closure type has internal linkage, so the\n  /// mangling number does not matter, while a non-zero value indicates which\n  /// lambda expression this is in this particular context.\n  unsigned getLambdaManglingNumber() const {\n    assert(isLambda() && \"Not a lambda closure type!\");\n    return getLambdaData().ManglingNumber;\n  }\n\n  /// The lambda is known to has internal linkage no matter whether it has name\n  /// mangling number.\n  bool hasKnownLambdaInternalLinkage() const {\n    assert(isLambda() && \"Not a lambda closure type!\");\n    return getLambdaData().HasKnownInternalLinkage;\n  }\n\n  /// Retrieve the declaration that provides additional context for a\n  /// lambda, when the normal declaration context is not specific enough.\n  ///\n  /// Certain contexts (default arguments of in-class function parameters and\n  /// the initializers of data members) have separate name mangling rules for\n  /// lambdas within the Itanium C++ ABI. For these cases, this routine provides\n  /// the declaration in which the lambda occurs, e.g., the function parameter\n  /// or the non-static data member. Otherwise, it returns NULL to imply that\n  /// the declaration context suffices.\n  Decl *getLambdaContextDecl() const;\n\n  /// Set the mangling number and context declaration for a lambda\n  /// class.\n  void setLambdaMangling(unsigned ManglingNumber, Decl *ContextDecl,\n                         bool HasKnownInternalLinkage = false) {\n    assert(isLambda() && \"Not a lambda closure type!\");\n    getLambdaData().ManglingNumber = ManglingNumber;\n    getLambdaData().ContextDecl = ContextDecl;\n    getLambdaData().HasKnownInternalLinkage = HasKnownInternalLinkage;\n  }\n\n  /// Set the device side mangling number.\n  void setDeviceLambdaManglingNumber(unsigned Num) const;\n\n  /// Retrieve the device side mangling number.\n  unsigned getDeviceLambdaManglingNumber() const;\n\n  /// Returns the inheritance model used for this record.\n  MSInheritanceModel getMSInheritanceModel() const;\n\n  /// Calculate what the inheritance model would be for this class.\n  MSInheritanceModel calculateInheritanceModel() const;\n\n  /// In the Microsoft C++ ABI, use zero for the field offset of a null data\n  /// member pointer if we can guarantee that zero is not a valid field offset,\n  /// or if the member pointer has multiple fields.  Polymorphic classes have a\n  /// vfptr at offset zero, so we can use zero for null.  If there are multiple\n  /// fields, we can use zero even if it is a valid field offset because\n  /// null-ness testing will check the other fields.\n  bool nullFieldOffsetIsZero() const;\n\n  /// Controls when vtordisps will be emitted if this record is used as a\n  /// virtual base.\n  MSVtorDispMode getMSVtorDispMode() const;\n\n  /// Determine whether this lambda expression was known to be dependent\n  /// at the time it was created, even if its context does not appear to be\n  /// dependent.\n  ///\n  /// This flag is a workaround for an issue with parsing, where default\n  /// arguments are parsed before their enclosing function declarations have\n  /// been created. This means that any lambda expressions within those\n  /// default arguments will have as their DeclContext the context enclosing\n  /// the function declaration, which may be non-dependent even when the\n  /// function declaration itself is dependent. This flag indicates when we\n  /// know that the lambda is dependent despite that.\n  bool isDependentLambda() const {\n    return isLambda() && getLambdaData().Dependent;\n  }\n\n  TypeSourceInfo *getLambdaTypeInfo() const {\n    return getLambdaData().MethodTyInfo;\n  }\n\n  // Determine whether this type is an Interface Like type for\n  // __interface inheritance purposes.\n  bool isInterfaceLike() const;\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K >= firstCXXRecord && K <= lastCXXRecord;\n  }\n};\n\n/// Store information needed for an explicit specifier.\n/// Used by CXXDeductionGuideDecl, CXXConstructorDecl and CXXConversionDecl.\nclass ExplicitSpecifier {\n  llvm::PointerIntPair<Expr *, 2, ExplicitSpecKind> ExplicitSpec{\n      nullptr, ExplicitSpecKind::ResolvedFalse};\n\npublic:\n  ExplicitSpecifier() = default;\n  ExplicitSpecifier(Expr *Expression, ExplicitSpecKind Kind)\n      : ExplicitSpec(Expression, Kind) {}\n  ExplicitSpecKind getKind() const { return ExplicitSpec.getInt(); }\n  const Expr *getExpr() const { return ExplicitSpec.getPointer(); }\n  Expr *getExpr() { return ExplicitSpec.getPointer(); }\n\n  /// Determine if the declaration had an explicit specifier of any kind.\n  bool isSpecified() const {\n    return ExplicitSpec.getInt() != ExplicitSpecKind::ResolvedFalse ||\n           ExplicitSpec.getPointer();\n  }\n\n  /// Check for equivalence of explicit specifiers.\n  /// \\return true if the explicit specifier are equivalent, false otherwise.\n  bool isEquivalent(const ExplicitSpecifier Other) const;\n  /// Determine whether this specifier is known to correspond to an explicit\n  /// declaration. Returns false if the specifier is absent or has an\n  /// expression that is value-dependent or evaluates to false.\n  bool isExplicit() const {\n    return ExplicitSpec.getInt() == ExplicitSpecKind::ResolvedTrue;\n  }\n  /// Determine if the explicit specifier is invalid.\n  /// This state occurs after a substitution failures.\n  bool isInvalid() const {\n    return ExplicitSpec.getInt() == ExplicitSpecKind::Unresolved &&\n           !ExplicitSpec.getPointer();\n  }\n  void setKind(ExplicitSpecKind Kind) { ExplicitSpec.setInt(Kind); }\n  void setExpr(Expr *E) { ExplicitSpec.setPointer(E); }\n  // Retrieve the explicit specifier in the given declaration, if any.\n  static ExplicitSpecifier getFromDecl(FunctionDecl *Function);\n  static const ExplicitSpecifier getFromDecl(const FunctionDecl *Function) {\n    return getFromDecl(const_cast<FunctionDecl *>(Function));\n  }\n  static ExplicitSpecifier Invalid() {\n    return ExplicitSpecifier(nullptr, ExplicitSpecKind::Unresolved);\n  }\n};\n\n/// Represents a C++ deduction guide declaration.\n///\n/// \\code\n/// template<typename T> struct A { A(); A(T); };\n/// A() -> A<int>;\n/// \\endcode\n///\n/// In this example, there will be an explicit deduction guide from the\n/// second line, and implicit deduction guide templates synthesized from\n/// the constructors of \\c A.\nclass CXXDeductionGuideDecl : public FunctionDecl {\n  void anchor() override;\n\nprivate:\n  CXXDeductionGuideDecl(ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n                        ExplicitSpecifier ES,\n                        const DeclarationNameInfo &NameInfo, QualType T,\n                        TypeSourceInfo *TInfo, SourceLocation EndLocation)\n      : FunctionDecl(CXXDeductionGuide, C, DC, StartLoc, NameInfo, T, TInfo,\n                     SC_None, false, ConstexprSpecKind::Unspecified),\n        ExplicitSpec(ES) {\n    if (EndLocation.isValid())\n      setRangeEnd(EndLocation);\n    setIsCopyDeductionCandidate(false);\n  }\n\n  ExplicitSpecifier ExplicitSpec;\n  void setExplicitSpecifier(ExplicitSpecifier ES) { ExplicitSpec = ES; }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static CXXDeductionGuideDecl *\n  Create(ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n         ExplicitSpecifier ES, const DeclarationNameInfo &NameInfo, QualType T,\n         TypeSourceInfo *TInfo, SourceLocation EndLocation);\n\n  static CXXDeductionGuideDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  ExplicitSpecifier getExplicitSpecifier() { return ExplicitSpec; }\n  const ExplicitSpecifier getExplicitSpecifier() const { return ExplicitSpec; }\n\n  /// Return true if the declartion is already resolved to be explicit.\n  bool isExplicit() const { return ExplicitSpec.isExplicit(); }\n\n  /// Get the template for which this guide performs deduction.\n  TemplateDecl *getDeducedTemplate() const {\n    return getDeclName().getCXXDeductionGuideTemplate();\n  }\n\n  void setIsCopyDeductionCandidate(bool isCDC = true) {\n    FunctionDeclBits.IsCopyDeductionCandidate = isCDC;\n  }\n\n  bool isCopyDeductionCandidate() const {\n    return FunctionDeclBits.IsCopyDeductionCandidate;\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == CXXDeductionGuide; }\n};\n\n/// \\brief Represents the body of a requires-expression.\n///\n/// This decl exists merely to serve as the DeclContext for the local\n/// parameters of the requires expression as well as other declarations inside\n/// it.\n///\n/// \\code\n/// template<typename T> requires requires (T t) { {t++} -> regular; }\n/// \\endcode\n///\n/// In this example, a RequiresExpr object will be generated for the expression,\n/// and a RequiresExprBodyDecl will be created to hold the parameter t and the\n/// template argument list imposed by the compound requirement.\nclass RequiresExprBodyDecl : public Decl, public DeclContext {\n  RequiresExprBodyDecl(ASTContext &C, DeclContext *DC, SourceLocation StartLoc)\n      : Decl(RequiresExprBody, DC, StartLoc), DeclContext(RequiresExprBody) {}\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static RequiresExprBodyDecl *Create(ASTContext &C, DeclContext *DC,\n                                      SourceLocation StartLoc);\n\n  static RequiresExprBodyDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == RequiresExprBody; }\n};\n\n/// Represents a static or instance method of a struct/union/class.\n///\n/// In the terminology of the C++ Standard, these are the (static and\n/// non-static) member functions, whether virtual or not.\nclass CXXMethodDecl : public FunctionDecl {\n  void anchor() override;\n\nprotected:\n  CXXMethodDecl(Kind DK, ASTContext &C, CXXRecordDecl *RD,\n                SourceLocation StartLoc, const DeclarationNameInfo &NameInfo,\n                QualType T, TypeSourceInfo *TInfo, StorageClass SC,\n                bool isInline, ConstexprSpecKind ConstexprKind,\n                SourceLocation EndLocation,\n                Expr *TrailingRequiresClause = nullptr)\n      : FunctionDecl(DK, C, RD, StartLoc, NameInfo, T, TInfo, SC, isInline,\n                     ConstexprKind, TrailingRequiresClause) {\n    if (EndLocation.isValid())\n      setRangeEnd(EndLocation);\n  }\n\npublic:\n  static CXXMethodDecl *Create(ASTContext &C, CXXRecordDecl *RD,\n                               SourceLocation StartLoc,\n                               const DeclarationNameInfo &NameInfo, QualType T,\n                               TypeSourceInfo *TInfo, StorageClass SC,\n                               bool isInline, ConstexprSpecKind ConstexprKind,\n                               SourceLocation EndLocation,\n                               Expr *TrailingRequiresClause = nullptr);\n\n  static CXXMethodDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  bool isStatic() const;\n  bool isInstance() const { return !isStatic(); }\n\n  /// Returns true if the given operator is implicitly static in a record\n  /// context.\n  static bool isStaticOverloadedOperator(OverloadedOperatorKind OOK) {\n    // [class.free]p1:\n    // Any allocation function for a class T is a static member\n    // (even if not explicitly declared static).\n    // [class.free]p6 Any deallocation function for a class X is a static member\n    // (even if not explicitly declared static).\n    return OOK == OO_New || OOK == OO_Array_New || OOK == OO_Delete ||\n           OOK == OO_Array_Delete;\n  }\n\n  bool isConst() const { return getType()->castAs<FunctionType>()->isConst(); }\n  bool isVolatile() const { return getType()->castAs<FunctionType>()->isVolatile(); }\n\n  bool isVirtual() const {\n    CXXMethodDecl *CD = const_cast<CXXMethodDecl*>(this)->getCanonicalDecl();\n\n    // Member function is virtual if it is marked explicitly so, or if it is\n    // declared in __interface -- then it is automatically pure virtual.\n    if (CD->isVirtualAsWritten() || CD->isPure())\n      return true;\n\n    return CD->size_overridden_methods() != 0;\n  }\n\n  /// If it's possible to devirtualize a call to this method, return the called\n  /// function. Otherwise, return null.\n\n  /// \\param Base The object on which this virtual function is called.\n  /// \\param IsAppleKext True if we are compiling for Apple kext.\n  CXXMethodDecl *getDevirtualizedMethod(const Expr *Base, bool IsAppleKext);\n\n  const CXXMethodDecl *getDevirtualizedMethod(const Expr *Base,\n                                              bool IsAppleKext) const {\n    return const_cast<CXXMethodDecl *>(this)->getDevirtualizedMethod(\n        Base, IsAppleKext);\n  }\n\n  /// Determine whether this is a usual deallocation function (C++\n  /// [basic.stc.dynamic.deallocation]p2), which is an overloaded delete or\n  /// delete[] operator with a particular signature. Populates \\p PreventedBy\n  /// with the declarations of the functions of the same kind if they were the\n  /// reason for this function returning false. This is used by\n  /// Sema::isUsualDeallocationFunction to reconsider the answer based on the\n  /// context.\n  bool isUsualDeallocationFunction(\n      SmallVectorImpl<const FunctionDecl *> &PreventedBy) const;\n\n  /// Determine whether this is a copy-assignment operator, regardless\n  /// of whether it was declared implicitly or explicitly.\n  bool isCopyAssignmentOperator() const;\n\n  /// Determine whether this is a move assignment operator.\n  bool isMoveAssignmentOperator() const;\n\n  CXXMethodDecl *getCanonicalDecl() override {\n    return cast<CXXMethodDecl>(FunctionDecl::getCanonicalDecl());\n  }\n  const CXXMethodDecl *getCanonicalDecl() const {\n    return const_cast<CXXMethodDecl*>(this)->getCanonicalDecl();\n  }\n\n  CXXMethodDecl *getMostRecentDecl() {\n    return cast<CXXMethodDecl>(\n            static_cast<FunctionDecl *>(this)->getMostRecentDecl());\n  }\n  const CXXMethodDecl *getMostRecentDecl() const {\n    return const_cast<CXXMethodDecl*>(this)->getMostRecentDecl();\n  }\n\n  void addOverriddenMethod(const CXXMethodDecl *MD);\n\n  using method_iterator = const CXXMethodDecl *const *;\n\n  method_iterator begin_overridden_methods() const;\n  method_iterator end_overridden_methods() const;\n  unsigned size_overridden_methods() const;\n\n  using overridden_method_range = llvm::iterator_range<\n      llvm::TinyPtrVector<const CXXMethodDecl *>::const_iterator>;\n\n  overridden_method_range overridden_methods() const;\n\n  /// Return the parent of this method declaration, which\n  /// is the class in which this method is defined.\n  const CXXRecordDecl *getParent() const {\n    return cast<CXXRecordDecl>(FunctionDecl::getParent());\n  }\n\n  /// Return the parent of this method declaration, which\n  /// is the class in which this method is defined.\n  CXXRecordDecl *getParent() {\n    return const_cast<CXXRecordDecl *>(\n             cast<CXXRecordDecl>(FunctionDecl::getParent()));\n  }\n\n  /// Return the type of the \\c this pointer.\n  ///\n  /// Should only be called for instance (i.e., non-static) methods. Note\n  /// that for the call operator of a lambda closure type, this returns the\n  /// desugared 'this' type (a pointer to the closure type), not the captured\n  /// 'this' type.\n  QualType getThisType() const;\n\n  /// Return the type of the object pointed by \\c this.\n  ///\n  /// See getThisType() for usage restriction.\n  QualType getThisObjectType() const;\n\n  static QualType getThisType(const FunctionProtoType *FPT,\n                              const CXXRecordDecl *Decl);\n\n  static QualType getThisObjectType(const FunctionProtoType *FPT,\n                                    const CXXRecordDecl *Decl);\n\n  Qualifiers getMethodQualifiers() const {\n    return getType()->castAs<FunctionProtoType>()->getMethodQuals();\n  }\n\n  /// Retrieve the ref-qualifier associated with this method.\n  ///\n  /// In the following example, \\c f() has an lvalue ref-qualifier, \\c g()\n  /// has an rvalue ref-qualifier, and \\c h() has no ref-qualifier.\n  /// @code\n  /// struct X {\n  ///   void f() &;\n  ///   void g() &&;\n  ///   void h();\n  /// };\n  /// @endcode\n  RefQualifierKind getRefQualifier() const {\n    return getType()->castAs<FunctionProtoType>()->getRefQualifier();\n  }\n\n  bool hasInlineBody() const;\n\n  /// Determine whether this is a lambda closure type's static member\n  /// function that is used for the result of the lambda's conversion to\n  /// function pointer (for a lambda with no captures).\n  ///\n  /// The function itself, if used, will have a placeholder body that will be\n  /// supplied by IR generation to either forward to the function call operator\n  /// or clone the function call operator.\n  bool isLambdaStaticInvoker() const;\n\n  /// Find the method in \\p RD that corresponds to this one.\n  ///\n  /// Find if \\p RD or one of the classes it inherits from override this method.\n  /// If so, return it. \\p RD is assumed to be a subclass of the class defining\n  /// this method (or be the class itself), unless \\p MayBeBase is set to true.\n  CXXMethodDecl *\n  getCorrespondingMethodInClass(const CXXRecordDecl *RD,\n                                bool MayBeBase = false);\n\n  const CXXMethodDecl *\n  getCorrespondingMethodInClass(const CXXRecordDecl *RD,\n                                bool MayBeBase = false) const {\n    return const_cast<CXXMethodDecl *>(this)\n              ->getCorrespondingMethodInClass(RD, MayBeBase);\n  }\n\n  /// Find if \\p RD declares a function that overrides this function, and if so,\n  /// return it. Does not search base classes.\n  CXXMethodDecl *getCorrespondingMethodDeclaredInClass(const CXXRecordDecl *RD,\n                                                       bool MayBeBase = false);\n  const CXXMethodDecl *\n  getCorrespondingMethodDeclaredInClass(const CXXRecordDecl *RD,\n                                        bool MayBeBase = false) const {\n    return const_cast<CXXMethodDecl *>(this)\n        ->getCorrespondingMethodDeclaredInClass(RD, MayBeBase);\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K >= firstCXXMethod && K <= lastCXXMethod;\n  }\n};\n\n/// Represents a C++ base or member initializer.\n///\n/// This is part of a constructor initializer that\n/// initializes one non-static member variable or one base class. For\n/// example, in the following, both 'A(a)' and 'f(3.14159)' are member\n/// initializers:\n///\n/// \\code\n/// class A { };\n/// class B : public A {\n///   float f;\n/// public:\n///   B(A& a) : A(a), f(3.14159) { }\n/// };\n/// \\endcode\nclass CXXCtorInitializer final {\n  /// Either the base class name/delegating constructor type (stored as\n  /// a TypeSourceInfo*), an normal field (FieldDecl), or an anonymous field\n  /// (IndirectFieldDecl*) being initialized.\n  llvm::PointerUnion<TypeSourceInfo *, FieldDecl *, IndirectFieldDecl *>\n      Initializee;\n\n  /// The argument used to initialize the base or member, which may\n  /// end up constructing an object (when multiple arguments are involved).\n  Stmt *Init;\n\n  /// The source location for the field name or, for a base initializer\n  /// pack expansion, the location of the ellipsis.\n  ///\n  /// In the case of a delegating\n  /// constructor, it will still include the type's source location as the\n  /// Initializee points to the CXXConstructorDecl (to allow loop detection).\n  SourceLocation MemberOrEllipsisLocation;\n\n  /// Location of the left paren of the ctor-initializer.\n  SourceLocation LParenLoc;\n\n  /// Location of the right paren of the ctor-initializer.\n  SourceLocation RParenLoc;\n\n  /// If the initializee is a type, whether that type makes this\n  /// a delegating initialization.\n  unsigned IsDelegating : 1;\n\n  /// If the initializer is a base initializer, this keeps track\n  /// of whether the base is virtual or not.\n  unsigned IsVirtual : 1;\n\n  /// Whether or not the initializer is explicitly written\n  /// in the sources.\n  unsigned IsWritten : 1;\n\n  /// If IsWritten is true, then this number keeps track of the textual order\n  /// of this initializer in the original sources, counting from 0.\n  unsigned SourceOrder : 13;\n\npublic:\n  /// Creates a new base-class initializer.\n  explicit\n  CXXCtorInitializer(ASTContext &Context, TypeSourceInfo *TInfo, bool IsVirtual,\n                     SourceLocation L, Expr *Init, SourceLocation R,\n                     SourceLocation EllipsisLoc);\n\n  /// Creates a new member initializer.\n  explicit\n  CXXCtorInitializer(ASTContext &Context, FieldDecl *Member,\n                     SourceLocation MemberLoc, SourceLocation L, Expr *Init,\n                     SourceLocation R);\n\n  /// Creates a new anonymous field initializer.\n  explicit\n  CXXCtorInitializer(ASTContext &Context, IndirectFieldDecl *Member,\n                     SourceLocation MemberLoc, SourceLocation L, Expr *Init,\n                     SourceLocation R);\n\n  /// Creates a new delegating initializer.\n  explicit\n  CXXCtorInitializer(ASTContext &Context, TypeSourceInfo *TInfo,\n                     SourceLocation L, Expr *Init, SourceLocation R);\n\n  /// \\return Unique reproducible object identifier.\n  int64_t getID(const ASTContext &Context) const;\n\n  /// Determine whether this initializer is initializing a base class.\n  bool isBaseInitializer() const {\n    return Initializee.is<TypeSourceInfo*>() && !IsDelegating;\n  }\n\n  /// Determine whether this initializer is initializing a non-static\n  /// data member.\n  bool isMemberInitializer() const { return Initializee.is<FieldDecl*>(); }\n\n  bool isAnyMemberInitializer() const {\n    return isMemberInitializer() || isIndirectMemberInitializer();\n  }\n\n  bool isIndirectMemberInitializer() const {\n    return Initializee.is<IndirectFieldDecl*>();\n  }\n\n  /// Determine whether this initializer is an implicit initializer\n  /// generated for a field with an initializer defined on the member\n  /// declaration.\n  ///\n  /// In-class member initializers (also known as \"non-static data member\n  /// initializations\", NSDMIs) were introduced in C++11.\n  bool isInClassMemberInitializer() const {\n    return Init->getStmtClass() == Stmt::CXXDefaultInitExprClass;\n  }\n\n  /// Determine whether this initializer is creating a delegating\n  /// constructor.\n  bool isDelegatingInitializer() const {\n    return Initializee.is<TypeSourceInfo*>() && IsDelegating;\n  }\n\n  /// Determine whether this initializer is a pack expansion.\n  bool isPackExpansion() const {\n    return isBaseInitializer() && MemberOrEllipsisLocation.isValid();\n  }\n\n  // For a pack expansion, returns the location of the ellipsis.\n  SourceLocation getEllipsisLoc() const {\n    assert(isPackExpansion() && \"Initializer is not a pack expansion\");\n    return MemberOrEllipsisLocation;\n  }\n\n  /// If this is a base class initializer, returns the type of the\n  /// base class with location information. Otherwise, returns an NULL\n  /// type location.\n  TypeLoc getBaseClassLoc() const;\n\n  /// If this is a base class initializer, returns the type of the base class.\n  /// Otherwise, returns null.\n  const Type *getBaseClass() const;\n\n  /// Returns whether the base is virtual or not.\n  bool isBaseVirtual() const {\n    assert(isBaseInitializer() && \"Must call this on base initializer!\");\n\n    return IsVirtual;\n  }\n\n  /// Returns the declarator information for a base class or delegating\n  /// initializer.\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return Initializee.dyn_cast<TypeSourceInfo *>();\n  }\n\n  /// If this is a member initializer, returns the declaration of the\n  /// non-static data member being initialized. Otherwise, returns null.\n  FieldDecl *getMember() const {\n    if (isMemberInitializer())\n      return Initializee.get<FieldDecl*>();\n    return nullptr;\n  }\n\n  FieldDecl *getAnyMember() const {\n    if (isMemberInitializer())\n      return Initializee.get<FieldDecl*>();\n    if (isIndirectMemberInitializer())\n      return Initializee.get<IndirectFieldDecl*>()->getAnonField();\n    return nullptr;\n  }\n\n  IndirectFieldDecl *getIndirectMember() const {\n    if (isIndirectMemberInitializer())\n      return Initializee.get<IndirectFieldDecl*>();\n    return nullptr;\n  }\n\n  SourceLocation getMemberLocation() const {\n    return MemberOrEllipsisLocation;\n  }\n\n  /// Determine the source location of the initializer.\n  SourceLocation getSourceLocation() const;\n\n  /// Determine the source range covering the entire initializer.\n  SourceRange getSourceRange() const LLVM_READONLY;\n\n  /// Determine whether this initializer is explicitly written\n  /// in the source code.\n  bool isWritten() const { return IsWritten; }\n\n  /// Return the source position of the initializer, counting from 0.\n  /// If the initializer was implicit, -1 is returned.\n  int getSourceOrder() const {\n    return IsWritten ? static_cast<int>(SourceOrder) : -1;\n  }\n\n  /// Set the source order of this initializer.\n  ///\n  /// This can only be called once for each initializer; it cannot be called\n  /// on an initializer having a positive number of (implicit) array indices.\n  ///\n  /// This assumes that the initializer was written in the source code, and\n  /// ensures that isWritten() returns true.\n  void setSourceOrder(int Pos) {\n    assert(!IsWritten &&\n           \"setSourceOrder() used on implicit initializer\");\n    assert(SourceOrder == 0 &&\n           \"calling twice setSourceOrder() on the same initializer\");\n    assert(Pos >= 0 &&\n           \"setSourceOrder() used to make an initializer implicit\");\n    IsWritten = true;\n    SourceOrder = static_cast<unsigned>(Pos);\n  }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n\n  /// Get the initializer.\n  Expr *getInit() const { return static_cast<Expr *>(Init); }\n};\n\n/// Description of a constructor that was inherited from a base class.\nclass InheritedConstructor {\n  ConstructorUsingShadowDecl *Shadow = nullptr;\n  CXXConstructorDecl *BaseCtor = nullptr;\n\npublic:\n  InheritedConstructor() = default;\n  InheritedConstructor(ConstructorUsingShadowDecl *Shadow,\n                       CXXConstructorDecl *BaseCtor)\n      : Shadow(Shadow), BaseCtor(BaseCtor) {}\n\n  explicit operator bool() const { return Shadow; }\n\n  ConstructorUsingShadowDecl *getShadowDecl() const { return Shadow; }\n  CXXConstructorDecl *getConstructor() const { return BaseCtor; }\n};\n\n/// Represents a C++ constructor within a class.\n///\n/// For example:\n///\n/// \\code\n/// class X {\n/// public:\n///   explicit X(int); // represented by a CXXConstructorDecl.\n/// };\n/// \\endcode\nclass CXXConstructorDecl final\n    : public CXXMethodDecl,\n      private llvm::TrailingObjects<CXXConstructorDecl, InheritedConstructor,\n                                    ExplicitSpecifier> {\n  // This class stores some data in DeclContext::CXXConstructorDeclBits\n  // to save some space. Use the provided accessors to access it.\n\n  /// \\name Support for base and member initializers.\n  /// \\{\n  /// The arguments used to initialize the base or member.\n  LazyCXXCtorInitializersPtr CtorInitializers;\n\n  CXXConstructorDecl(ASTContext &C, CXXRecordDecl *RD, SourceLocation StartLoc,\n                     const DeclarationNameInfo &NameInfo, QualType T,\n                     TypeSourceInfo *TInfo, ExplicitSpecifier ES, bool isInline,\n                     bool isImplicitlyDeclared, ConstexprSpecKind ConstexprKind,\n                     InheritedConstructor Inherited,\n                     Expr *TrailingRequiresClause);\n\n  void anchor() override;\n\n  size_t numTrailingObjects(OverloadToken<InheritedConstructor>) const {\n    return CXXConstructorDeclBits.IsInheritingConstructor;\n  }\n  size_t numTrailingObjects(OverloadToken<ExplicitSpecifier>) const {\n    return CXXConstructorDeclBits.HasTrailingExplicitSpecifier;\n  }\n\n  ExplicitSpecifier getExplicitSpecifierInternal() const {\n    if (CXXConstructorDeclBits.HasTrailingExplicitSpecifier)\n      return *getTrailingObjects<ExplicitSpecifier>();\n    return ExplicitSpecifier(\n        nullptr, CXXConstructorDeclBits.IsSimpleExplicit\n                     ? ExplicitSpecKind::ResolvedTrue\n                     : ExplicitSpecKind::ResolvedFalse);\n  }\n\n  enum TraillingAllocKind {\n    TAKInheritsConstructor = 1,\n    TAKHasTailExplicit = 1 << 1,\n  };\n\n  uint64_t getTraillingAllocKind() const {\n    return numTrailingObjects(OverloadToken<InheritedConstructor>()) |\n           (numTrailingObjects(OverloadToken<ExplicitSpecifier>()) << 1);\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend TrailingObjects;\n\n  static CXXConstructorDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                                uint64_t AllocKind);\n  static CXXConstructorDecl *\n  Create(ASTContext &C, CXXRecordDecl *RD, SourceLocation StartLoc,\n         const DeclarationNameInfo &NameInfo, QualType T, TypeSourceInfo *TInfo,\n         ExplicitSpecifier ES, bool isInline, bool isImplicitlyDeclared,\n         ConstexprSpecKind ConstexprKind,\n         InheritedConstructor Inherited = InheritedConstructor(),\n         Expr *TrailingRequiresClause = nullptr);\n\n  void setExplicitSpecifier(ExplicitSpecifier ES) {\n    assert((!ES.getExpr() ||\n            CXXConstructorDeclBits.HasTrailingExplicitSpecifier) &&\n           \"cannot set this explicit specifier. no trail-allocated space for \"\n           \"explicit\");\n    if (ES.getExpr())\n      *getCanonicalDecl()->getTrailingObjects<ExplicitSpecifier>() = ES;\n    else\n      CXXConstructorDeclBits.IsSimpleExplicit = ES.isExplicit();\n  }\n\n  ExplicitSpecifier getExplicitSpecifier() {\n    return getCanonicalDecl()->getExplicitSpecifierInternal();\n  }\n  const ExplicitSpecifier getExplicitSpecifier() const {\n    return getCanonicalDecl()->getExplicitSpecifierInternal();\n  }\n\n  /// Return true if the declartion is already resolved to be explicit.\n  bool isExplicit() const { return getExplicitSpecifier().isExplicit(); }\n\n  /// Iterates through the member/base initializer list.\n  using init_iterator = CXXCtorInitializer **;\n\n  /// Iterates through the member/base initializer list.\n  using init_const_iterator = CXXCtorInitializer *const *;\n\n  using init_range = llvm::iterator_range<init_iterator>;\n  using init_const_range = llvm::iterator_range<init_const_iterator>;\n\n  init_range inits() { return init_range(init_begin(), init_end()); }\n  init_const_range inits() const {\n    return init_const_range(init_begin(), init_end());\n  }\n\n  /// Retrieve an iterator to the first initializer.\n  init_iterator init_begin() {\n    const auto *ConstThis = this;\n    return const_cast<init_iterator>(ConstThis->init_begin());\n  }\n\n  /// Retrieve an iterator to the first initializer.\n  init_const_iterator init_begin() const;\n\n  /// Retrieve an iterator past the last initializer.\n  init_iterator       init_end()       {\n    return init_begin() + getNumCtorInitializers();\n  }\n\n  /// Retrieve an iterator past the last initializer.\n  init_const_iterator init_end() const {\n    return init_begin() + getNumCtorInitializers();\n  }\n\n  using init_reverse_iterator = std::reverse_iterator<init_iterator>;\n  using init_const_reverse_iterator =\n      std::reverse_iterator<init_const_iterator>;\n\n  init_reverse_iterator init_rbegin() {\n    return init_reverse_iterator(init_end());\n  }\n  init_const_reverse_iterator init_rbegin() const {\n    return init_const_reverse_iterator(init_end());\n  }\n\n  init_reverse_iterator init_rend() {\n    return init_reverse_iterator(init_begin());\n  }\n  init_const_reverse_iterator init_rend() const {\n    return init_const_reverse_iterator(init_begin());\n  }\n\n  /// Determine the number of arguments used to initialize the member\n  /// or base.\n  unsigned getNumCtorInitializers() const {\n      return CXXConstructorDeclBits.NumCtorInitializers;\n  }\n\n  void setNumCtorInitializers(unsigned numCtorInitializers) {\n    CXXConstructorDeclBits.NumCtorInitializers = numCtorInitializers;\n    // This assert added because NumCtorInitializers is stored\n    // in CXXConstructorDeclBits as a bitfield and its width has\n    // been shrunk from 32 bits to fit into CXXConstructorDeclBitfields.\n    assert(CXXConstructorDeclBits.NumCtorInitializers ==\n           numCtorInitializers && \"NumCtorInitializers overflow!\");\n  }\n\n  void setCtorInitializers(CXXCtorInitializer **Initializers) {\n    CtorInitializers = Initializers;\n  }\n\n  /// Determine whether this constructor is a delegating constructor.\n  bool isDelegatingConstructor() const {\n    return (getNumCtorInitializers() == 1) &&\n           init_begin()[0]->isDelegatingInitializer();\n  }\n\n  /// When this constructor delegates to another, retrieve the target.\n  CXXConstructorDecl *getTargetConstructor() const;\n\n  /// Whether this constructor is a default\n  /// constructor (C++ [class.ctor]p5), which can be used to\n  /// default-initialize a class of this type.\n  bool isDefaultConstructor() const;\n\n  /// Whether this constructor is a copy constructor (C++ [class.copy]p2,\n  /// which can be used to copy the class.\n  ///\n  /// \\p TypeQuals will be set to the qualifiers on the\n  /// argument type. For example, \\p TypeQuals would be set to \\c\n  /// Qualifiers::Const for the following copy constructor:\n  ///\n  /// \\code\n  /// class X {\n  /// public:\n  ///   X(const X&);\n  /// };\n  /// \\endcode\n  bool isCopyConstructor(unsigned &TypeQuals) const;\n\n  /// Whether this constructor is a copy\n  /// constructor (C++ [class.copy]p2, which can be used to copy the\n  /// class.\n  bool isCopyConstructor() const {\n    unsigned TypeQuals = 0;\n    return isCopyConstructor(TypeQuals);\n  }\n\n  /// Determine whether this constructor is a move constructor\n  /// (C++11 [class.copy]p3), which can be used to move values of the class.\n  ///\n  /// \\param TypeQuals If this constructor is a move constructor, will be set\n  /// to the type qualifiers on the referent of the first parameter's type.\n  bool isMoveConstructor(unsigned &TypeQuals) const;\n\n  /// Determine whether this constructor is a move constructor\n  /// (C++11 [class.copy]p3), which can be used to move values of the class.\n  bool isMoveConstructor() const {\n    unsigned TypeQuals = 0;\n    return isMoveConstructor(TypeQuals);\n  }\n\n  /// Determine whether this is a copy or move constructor.\n  ///\n  /// \\param TypeQuals Will be set to the type qualifiers on the reference\n  /// parameter, if in fact this is a copy or move constructor.\n  bool isCopyOrMoveConstructor(unsigned &TypeQuals) const;\n\n  /// Determine whether this a copy or move constructor.\n  bool isCopyOrMoveConstructor() const {\n    unsigned Quals;\n    return isCopyOrMoveConstructor(Quals);\n  }\n\n  /// Whether this constructor is a\n  /// converting constructor (C++ [class.conv.ctor]), which can be\n  /// used for user-defined conversions.\n  bool isConvertingConstructor(bool AllowExplicit) const;\n\n  /// Determine whether this is a member template specialization that\n  /// would copy the object to itself. Such constructors are never used to copy\n  /// an object.\n  bool isSpecializationCopyingObject() const;\n\n  /// Determine whether this is an implicit constructor synthesized to\n  /// model a call to a constructor inherited from a base class.\n  bool isInheritingConstructor() const {\n    return CXXConstructorDeclBits.IsInheritingConstructor;\n  }\n\n  /// State that this is an implicit constructor synthesized to\n  /// model a call to a constructor inherited from a base class.\n  void setInheritingConstructor(bool isIC = true) {\n    CXXConstructorDeclBits.IsInheritingConstructor = isIC;\n  }\n\n  /// Get the constructor that this inheriting constructor is based on.\n  InheritedConstructor getInheritedConstructor() const {\n    return isInheritingConstructor() ?\n      *getTrailingObjects<InheritedConstructor>() : InheritedConstructor();\n  }\n\n  CXXConstructorDecl *getCanonicalDecl() override {\n    return cast<CXXConstructorDecl>(FunctionDecl::getCanonicalDecl());\n  }\n  const CXXConstructorDecl *getCanonicalDecl() const {\n    return const_cast<CXXConstructorDecl*>(this)->getCanonicalDecl();\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == CXXConstructor; }\n};\n\n/// Represents a C++ destructor within a class.\n///\n/// For example:\n///\n/// \\code\n/// class X {\n/// public:\n///   ~X(); // represented by a CXXDestructorDecl.\n/// };\n/// \\endcode\nclass CXXDestructorDecl : public CXXMethodDecl {\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  // FIXME: Don't allocate storage for these except in the first declaration\n  // of a virtual destructor.\n  FunctionDecl *OperatorDelete = nullptr;\n  Expr *OperatorDeleteThisArg = nullptr;\n\n  CXXDestructorDecl(ASTContext &C, CXXRecordDecl *RD, SourceLocation StartLoc,\n                    const DeclarationNameInfo &NameInfo, QualType T,\n                    TypeSourceInfo *TInfo, bool isInline,\n                    bool isImplicitlyDeclared, ConstexprSpecKind ConstexprKind,\n                    Expr *TrailingRequiresClause = nullptr)\n      : CXXMethodDecl(CXXDestructor, C, RD, StartLoc, NameInfo, T, TInfo,\n                      SC_None, isInline, ConstexprKind, SourceLocation(),\n                      TrailingRequiresClause) {\n    setImplicit(isImplicitlyDeclared);\n  }\n\n  void anchor() override;\n\npublic:\n  static CXXDestructorDecl *Create(ASTContext &C, CXXRecordDecl *RD,\n                                   SourceLocation StartLoc,\n                                   const DeclarationNameInfo &NameInfo,\n                                   QualType T, TypeSourceInfo *TInfo,\n                                   bool isInline, bool isImplicitlyDeclared,\n                                   ConstexprSpecKind ConstexprKind,\n                                   Expr *TrailingRequiresClause = nullptr);\n  static CXXDestructorDecl *CreateDeserialized(ASTContext & C, unsigned ID);\n\n  void setOperatorDelete(FunctionDecl *OD, Expr *ThisArg);\n\n  const FunctionDecl *getOperatorDelete() const {\n    return getCanonicalDecl()->OperatorDelete;\n  }\n\n  Expr *getOperatorDeleteThisArg() const {\n    return getCanonicalDecl()->OperatorDeleteThisArg;\n  }\n\n  CXXDestructorDecl *getCanonicalDecl() override {\n    return cast<CXXDestructorDecl>(FunctionDecl::getCanonicalDecl());\n  }\n  const CXXDestructorDecl *getCanonicalDecl() const {\n    return const_cast<CXXDestructorDecl*>(this)->getCanonicalDecl();\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == CXXDestructor; }\n};\n\n/// Represents a C++ conversion function within a class.\n///\n/// For example:\n///\n/// \\code\n/// class X {\n/// public:\n///   operator bool();\n/// };\n/// \\endcode\nclass CXXConversionDecl : public CXXMethodDecl {\n  CXXConversionDecl(ASTContext &C, CXXRecordDecl *RD, SourceLocation StartLoc,\n                    const DeclarationNameInfo &NameInfo, QualType T,\n                    TypeSourceInfo *TInfo, bool isInline, ExplicitSpecifier ES,\n                    ConstexprSpecKind ConstexprKind, SourceLocation EndLocation,\n                    Expr *TrailingRequiresClause = nullptr)\n      : CXXMethodDecl(CXXConversion, C, RD, StartLoc, NameInfo, T, TInfo,\n                      SC_None, isInline, ConstexprKind, EndLocation,\n                      TrailingRequiresClause),\n        ExplicitSpec(ES) {}\n  void anchor() override;\n\n  ExplicitSpecifier ExplicitSpec;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static CXXConversionDecl *\n  Create(ASTContext &C, CXXRecordDecl *RD, SourceLocation StartLoc,\n         const DeclarationNameInfo &NameInfo, QualType T, TypeSourceInfo *TInfo,\n         bool isInline, ExplicitSpecifier ES, ConstexprSpecKind ConstexprKind,\n         SourceLocation EndLocation, Expr *TrailingRequiresClause = nullptr);\n  static CXXConversionDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  ExplicitSpecifier getExplicitSpecifier() {\n    return getCanonicalDecl()->ExplicitSpec;\n  }\n\n  const ExplicitSpecifier getExplicitSpecifier() const {\n    return getCanonicalDecl()->ExplicitSpec;\n  }\n\n  /// Return true if the declartion is already resolved to be explicit.\n  bool isExplicit() const { return getExplicitSpecifier().isExplicit(); }\n  void setExplicitSpecifier(ExplicitSpecifier ES) { ExplicitSpec = ES; }\n\n  /// Returns the type that this conversion function is converting to.\n  QualType getConversionType() const {\n    return getType()->castAs<FunctionType>()->getReturnType();\n  }\n\n  /// Determine whether this conversion function is a conversion from\n  /// a lambda closure type to a block pointer.\n  bool isLambdaToBlockPointerConversion() const;\n\n  CXXConversionDecl *getCanonicalDecl() override {\n    return cast<CXXConversionDecl>(FunctionDecl::getCanonicalDecl());\n  }\n  const CXXConversionDecl *getCanonicalDecl() const {\n    return const_cast<CXXConversionDecl*>(this)->getCanonicalDecl();\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == CXXConversion; }\n};\n\n/// Represents a linkage specification.\n///\n/// For example:\n/// \\code\n///   extern \"C\" void foo();\n/// \\endcode\nclass LinkageSpecDecl : public Decl, public DeclContext {\n  virtual void anchor();\n  // This class stores some data in DeclContext::LinkageSpecDeclBits to save\n  // some space. Use the provided accessors to access it.\npublic:\n  /// Represents the language in a linkage specification.\n  ///\n  /// The values are part of the serialization ABI for\n  /// ASTs and cannot be changed without altering that ABI.\n  enum LanguageIDs { lang_c = 1, lang_cxx = 2 };\n\nprivate:\n  /// The source location for the extern keyword.\n  SourceLocation ExternLoc;\n\n  /// The source location for the right brace (if valid).\n  SourceLocation RBraceLoc;\n\n  LinkageSpecDecl(DeclContext *DC, SourceLocation ExternLoc,\n                  SourceLocation LangLoc, LanguageIDs lang, bool HasBraces);\n\npublic:\n  static LinkageSpecDecl *Create(ASTContext &C, DeclContext *DC,\n                                 SourceLocation ExternLoc,\n                                 SourceLocation LangLoc, LanguageIDs Lang,\n                                 bool HasBraces);\n  static LinkageSpecDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// Return the language specified by this linkage specification.\n  LanguageIDs getLanguage() const {\n    return static_cast<LanguageIDs>(LinkageSpecDeclBits.Language);\n  }\n\n  /// Set the language specified by this linkage specification.\n  void setLanguage(LanguageIDs L) { LinkageSpecDeclBits.Language = L; }\n\n  /// Determines whether this linkage specification had braces in\n  /// its syntactic form.\n  bool hasBraces() const {\n    assert(!RBraceLoc.isValid() || LinkageSpecDeclBits.HasBraces);\n    return LinkageSpecDeclBits.HasBraces;\n  }\n\n  SourceLocation getExternLoc() const { return ExternLoc; }\n  SourceLocation getRBraceLoc() const { return RBraceLoc; }\n  void setExternLoc(SourceLocation L) { ExternLoc = L; }\n  void setRBraceLoc(SourceLocation L) {\n    RBraceLoc = L;\n    LinkageSpecDeclBits.HasBraces = RBraceLoc.isValid();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    if (hasBraces())\n      return getRBraceLoc();\n    // No braces: get the end location of the (only) declaration in context\n    // (if present).\n    return decls_empty() ? getLocation() : decls_begin()->getEndLoc();\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(ExternLoc, getEndLoc());\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == LinkageSpec; }\n\n  static DeclContext *castToDeclContext(const LinkageSpecDecl *D) {\n    return static_cast<DeclContext *>(const_cast<LinkageSpecDecl*>(D));\n  }\n\n  static LinkageSpecDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<LinkageSpecDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Represents C++ using-directive.\n///\n/// For example:\n/// \\code\n///    using namespace std;\n/// \\endcode\n///\n/// \\note UsingDirectiveDecl should be Decl not NamedDecl, but we provide\n/// artificial names for all using-directives in order to store\n/// them in DeclContext effectively.\nclass UsingDirectiveDecl : public NamedDecl {\n  /// The location of the \\c using keyword.\n  SourceLocation UsingLoc;\n\n  /// The location of the \\c namespace keyword.\n  SourceLocation NamespaceLoc;\n\n  /// The nested-name-specifier that precedes the namespace.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// The namespace nominated by this using-directive.\n  NamedDecl *NominatedNamespace;\n\n  /// Enclosing context containing both using-directive and nominated\n  /// namespace.\n  DeclContext *CommonAncestor;\n\n  UsingDirectiveDecl(DeclContext *DC, SourceLocation UsingLoc,\n                     SourceLocation NamespcLoc,\n                     NestedNameSpecifierLoc QualifierLoc,\n                     SourceLocation IdentLoc,\n                     NamedDecl *Nominated,\n                     DeclContext *CommonAncestor)\n      : NamedDecl(UsingDirective, DC, IdentLoc, getName()), UsingLoc(UsingLoc),\n        NamespaceLoc(NamespcLoc), QualifierLoc(QualifierLoc),\n        NominatedNamespace(Nominated), CommonAncestor(CommonAncestor) {}\n\n  /// Returns special DeclarationName used by using-directives.\n  ///\n  /// This is only used by DeclContext for storing UsingDirectiveDecls in\n  /// its lookup structure.\n  static DeclarationName getName() {\n    return DeclarationName::getUsingDirectiveName();\n  }\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n\n  // Friend for getUsingDirectiveName.\n  friend class DeclContext;\n\n  /// Retrieve the nested-name-specifier that qualifies the\n  /// name of the namespace, with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the nested-name-specifier that qualifies the\n  /// name of the namespace.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  NamedDecl *getNominatedNamespaceAsWritten() { return NominatedNamespace; }\n  const NamedDecl *getNominatedNamespaceAsWritten() const {\n    return NominatedNamespace;\n  }\n\n  /// Returns the namespace nominated by this using-directive.\n  NamespaceDecl *getNominatedNamespace();\n\n  const NamespaceDecl *getNominatedNamespace() const {\n    return const_cast<UsingDirectiveDecl*>(this)->getNominatedNamespace();\n  }\n\n  /// Returns the common ancestor context of this using-directive and\n  /// its nominated namespace.\n  DeclContext *getCommonAncestor() { return CommonAncestor; }\n  const DeclContext *getCommonAncestor() const { return CommonAncestor; }\n\n  /// Return the location of the \\c using keyword.\n  SourceLocation getUsingLoc() const { return UsingLoc; }\n\n  // FIXME: Could omit 'Key' in name.\n  /// Returns the location of the \\c namespace keyword.\n  SourceLocation getNamespaceKeyLocation() const { return NamespaceLoc; }\n\n  /// Returns the location of this using declaration's identifier.\n  SourceLocation getIdentLocation() const { return getLocation(); }\n\n  static UsingDirectiveDecl *Create(ASTContext &C, DeclContext *DC,\n                                    SourceLocation UsingLoc,\n                                    SourceLocation NamespaceLoc,\n                                    NestedNameSpecifierLoc QualifierLoc,\n                                    SourceLocation IdentLoc,\n                                    NamedDecl *Nominated,\n                                    DeclContext *CommonAncestor);\n  static UsingDirectiveDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(UsingLoc, getLocation());\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == UsingDirective; }\n};\n\n/// Represents a C++ namespace alias.\n///\n/// For example:\n///\n/// \\code\n/// namespace Foo = Bar;\n/// \\endcode\nclass NamespaceAliasDecl : public NamedDecl,\n                           public Redeclarable<NamespaceAliasDecl> {\n  friend class ASTDeclReader;\n\n  /// The location of the \\c namespace keyword.\n  SourceLocation NamespaceLoc;\n\n  /// The location of the namespace's identifier.\n  ///\n  /// This is accessed by TargetNameLoc.\n  SourceLocation IdentLoc;\n\n  /// The nested-name-specifier that precedes the namespace.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// The Decl that this alias points to, either a NamespaceDecl or\n  /// a NamespaceAliasDecl.\n  NamedDecl *Namespace;\n\n  NamespaceAliasDecl(ASTContext &C, DeclContext *DC,\n                     SourceLocation NamespaceLoc, SourceLocation AliasLoc,\n                     IdentifierInfo *Alias, NestedNameSpecifierLoc QualifierLoc,\n                     SourceLocation IdentLoc, NamedDecl *Namespace)\n      : NamedDecl(NamespaceAlias, DC, AliasLoc, Alias), redeclarable_base(C),\n        NamespaceLoc(NamespaceLoc), IdentLoc(IdentLoc),\n        QualifierLoc(QualifierLoc), Namespace(Namespace) {}\n\n  void anchor() override;\n\n  using redeclarable_base = Redeclarable<NamespaceAliasDecl>;\n\n  NamespaceAliasDecl *getNextRedeclarationImpl() override;\n  NamespaceAliasDecl *getPreviousDeclImpl() override;\n  NamespaceAliasDecl *getMostRecentDeclImpl() override;\n\npublic:\n  static NamespaceAliasDecl *Create(ASTContext &C, DeclContext *DC,\n                                    SourceLocation NamespaceLoc,\n                                    SourceLocation AliasLoc,\n                                    IdentifierInfo *Alias,\n                                    NestedNameSpecifierLoc QualifierLoc,\n                                    SourceLocation IdentLoc,\n                                    NamedDecl *Namespace);\n\n  static NamespaceAliasDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n\n  NamespaceAliasDecl *getCanonicalDecl() override {\n    return getFirstDecl();\n  }\n  const NamespaceAliasDecl *getCanonicalDecl() const {\n    return getFirstDecl();\n  }\n\n  /// Retrieve the nested-name-specifier that qualifies the\n  /// name of the namespace, with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the nested-name-specifier that qualifies the\n  /// name of the namespace.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  /// Retrieve the namespace declaration aliased by this directive.\n  NamespaceDecl *getNamespace() {\n    if (auto *AD = dyn_cast<NamespaceAliasDecl>(Namespace))\n      return AD->getNamespace();\n\n    return cast<NamespaceDecl>(Namespace);\n  }\n\n  const NamespaceDecl *getNamespace() const {\n    return const_cast<NamespaceAliasDecl *>(this)->getNamespace();\n  }\n\n  /// Returns the location of the alias name, i.e. 'foo' in\n  /// \"namespace foo = ns::bar;\".\n  SourceLocation getAliasLoc() const { return getLocation(); }\n\n  /// Returns the location of the \\c namespace keyword.\n  SourceLocation getNamespaceLoc() const { return NamespaceLoc; }\n\n  /// Returns the location of the identifier in the named namespace.\n  SourceLocation getTargetNameLoc() const { return IdentLoc; }\n\n  /// Retrieve the namespace that this alias refers to, which\n  /// may either be a NamespaceDecl or a NamespaceAliasDecl.\n  NamedDecl *getAliasedNamespace() const { return Namespace; }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(NamespaceLoc, IdentLoc);\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == NamespaceAlias; }\n};\n\n/// Implicit declaration of a temporary that was materialized by\n/// a MaterializeTemporaryExpr and lifetime-extended by a declaration\nclass LifetimeExtendedTemporaryDecl final\n    : public Decl,\n      public Mergeable<LifetimeExtendedTemporaryDecl> {\n  friend class MaterializeTemporaryExpr;\n  friend class ASTDeclReader;\n\n  Stmt *ExprWithTemporary = nullptr;\n\n  /// The declaration which lifetime-extended this reference, if any.\n  /// Either a VarDecl, or (for a ctor-initializer) a FieldDecl.\n  ValueDecl *ExtendingDecl = nullptr;\n  unsigned ManglingNumber;\n\n  mutable APValue *Value = nullptr;\n\n  virtual void anchor();\n\n  LifetimeExtendedTemporaryDecl(Expr *Temp, ValueDecl *EDecl, unsigned Mangling)\n      : Decl(Decl::LifetimeExtendedTemporary, EDecl->getDeclContext(),\n             EDecl->getLocation()),\n        ExprWithTemporary(Temp), ExtendingDecl(EDecl),\n        ManglingNumber(Mangling) {}\n\n  LifetimeExtendedTemporaryDecl(EmptyShell)\n      : Decl(Decl::LifetimeExtendedTemporary, EmptyShell{}) {}\n\npublic:\n  static LifetimeExtendedTemporaryDecl *Create(Expr *Temp, ValueDecl *EDec,\n                                               unsigned Mangling) {\n    return new (EDec->getASTContext(), EDec->getDeclContext())\n        LifetimeExtendedTemporaryDecl(Temp, EDec, Mangling);\n  }\n  static LifetimeExtendedTemporaryDecl *CreateDeserialized(ASTContext &C,\n                                                           unsigned ID) {\n    return new (C, ID) LifetimeExtendedTemporaryDecl(EmptyShell{});\n  }\n\n  ValueDecl *getExtendingDecl() { return ExtendingDecl; }\n  const ValueDecl *getExtendingDecl() const { return ExtendingDecl; }\n\n  /// Retrieve the storage duration for the materialized temporary.\n  StorageDuration getStorageDuration() const;\n\n  /// Retrieve the expression to which the temporary materialization conversion\n  /// was applied. This isn't necessarily the initializer of the temporary due\n  /// to the C++98 delayed materialization rules, but\n  /// skipRValueSubobjectAdjustments can be used to find said initializer within\n  /// the subexpression.\n  Expr *getTemporaryExpr() { return cast<Expr>(ExprWithTemporary); }\n  const Expr *getTemporaryExpr() const { return cast<Expr>(ExprWithTemporary); }\n\n  unsigned getManglingNumber() const { return ManglingNumber; }\n\n  /// Get the storage for the constant value of a materialized temporary\n  /// of static storage duration.\n  APValue *getOrCreateValue(bool MayCreate) const;\n\n  APValue *getValue() const { return Value; }\n\n  // Iterators\n  Stmt::child_range childrenExpr() {\n    return Stmt::child_range(&ExprWithTemporary, &ExprWithTemporary + 1);\n  }\n\n  Stmt::const_child_range childrenExpr() const {\n    return Stmt::const_child_range(&ExprWithTemporary, &ExprWithTemporary + 1);\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K == Decl::LifetimeExtendedTemporary;\n  }\n};\n\n/// Represents a shadow declaration introduced into a scope by a\n/// (resolved) using declaration.\n///\n/// For example,\n/// \\code\n/// namespace A {\n///   void foo();\n/// }\n/// namespace B {\n///   using A::foo; // <- a UsingDecl\n///                 // Also creates a UsingShadowDecl for A::foo() in B\n/// }\n/// \\endcode\nclass UsingShadowDecl : public NamedDecl, public Redeclarable<UsingShadowDecl> {\n  friend class UsingDecl;\n\n  /// The referenced declaration.\n  NamedDecl *Underlying = nullptr;\n\n  /// The using declaration which introduced this decl or the next using\n  /// shadow declaration contained in the aforementioned using declaration.\n  NamedDecl *UsingOrNextShadow = nullptr;\n\n  void anchor() override;\n\n  using redeclarable_base = Redeclarable<UsingShadowDecl>;\n\n  UsingShadowDecl *getNextRedeclarationImpl() override {\n    return getNextRedeclaration();\n  }\n\n  UsingShadowDecl *getPreviousDeclImpl() override {\n    return getPreviousDecl();\n  }\n\n  UsingShadowDecl *getMostRecentDeclImpl() override {\n    return getMostRecentDecl();\n  }\n\nprotected:\n  UsingShadowDecl(Kind K, ASTContext &C, DeclContext *DC, SourceLocation Loc,\n                  UsingDecl *Using, NamedDecl *Target);\n  UsingShadowDecl(Kind K, ASTContext &C, EmptyShell);\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static UsingShadowDecl *Create(ASTContext &C, DeclContext *DC,\n                                 SourceLocation Loc, UsingDecl *Using,\n                                 NamedDecl *Target) {\n    return new (C, DC) UsingShadowDecl(UsingShadow, C, DC, Loc, Using, Target);\n  }\n\n  static UsingShadowDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  UsingShadowDecl *getCanonicalDecl() override {\n    return getFirstDecl();\n  }\n  const UsingShadowDecl *getCanonicalDecl() const {\n    return getFirstDecl();\n  }\n\n  /// Gets the underlying declaration which has been brought into the\n  /// local scope.\n  NamedDecl *getTargetDecl() const { return Underlying; }\n\n  /// Sets the underlying declaration which has been brought into the\n  /// local scope.\n  void setTargetDecl(NamedDecl *ND) {\n    assert(ND && \"Target decl is null!\");\n    Underlying = ND;\n    // A UsingShadowDecl is never a friend or local extern declaration, even\n    // if it is a shadow declaration for one.\n    IdentifierNamespace =\n        ND->getIdentifierNamespace() &\n        ~(IDNS_OrdinaryFriend | IDNS_TagFriend | IDNS_LocalExtern);\n  }\n\n  /// Gets the using declaration to which this declaration is tied.\n  UsingDecl *getUsingDecl() const;\n\n  /// The next using shadow declaration contained in the shadow decl\n  /// chain of the using declaration which introduced this decl.\n  UsingShadowDecl *getNextUsingShadowDecl() const {\n    return dyn_cast_or_null<UsingShadowDecl>(UsingOrNextShadow);\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K == Decl::UsingShadow || K == Decl::ConstructorUsingShadow;\n  }\n};\n\n/// Represents a shadow constructor declaration introduced into a\n/// class by a C++11 using-declaration that names a constructor.\n///\n/// For example:\n/// \\code\n/// struct Base { Base(int); };\n/// struct Derived {\n///    using Base::Base; // creates a UsingDecl and a ConstructorUsingShadowDecl\n/// };\n/// \\endcode\nclass ConstructorUsingShadowDecl final : public UsingShadowDecl {\n  /// If this constructor using declaration inherted the constructor\n  /// from an indirect base class, this is the ConstructorUsingShadowDecl\n  /// in the named direct base class from which the declaration was inherited.\n  ConstructorUsingShadowDecl *NominatedBaseClassShadowDecl = nullptr;\n\n  /// If this constructor using declaration inherted the constructor\n  /// from an indirect base class, this is the ConstructorUsingShadowDecl\n  /// that will be used to construct the unique direct or virtual base class\n  /// that receives the constructor arguments.\n  ConstructorUsingShadowDecl *ConstructedBaseClassShadowDecl = nullptr;\n\n  /// \\c true if the constructor ultimately named by this using shadow\n  /// declaration is within a virtual base class subobject of the class that\n  /// contains this declaration.\n  unsigned IsVirtual : 1;\n\n  ConstructorUsingShadowDecl(ASTContext &C, DeclContext *DC, SourceLocation Loc,\n                             UsingDecl *Using, NamedDecl *Target,\n                             bool TargetInVirtualBase)\n      : UsingShadowDecl(ConstructorUsingShadow, C, DC, Loc, Using,\n                        Target->getUnderlyingDecl()),\n        NominatedBaseClassShadowDecl(\n            dyn_cast<ConstructorUsingShadowDecl>(Target)),\n        ConstructedBaseClassShadowDecl(NominatedBaseClassShadowDecl),\n        IsVirtual(TargetInVirtualBase) {\n    // If we found a constructor that chains to a constructor for a virtual\n    // base, we should directly call that virtual base constructor instead.\n    // FIXME: This logic belongs in Sema.\n    if (NominatedBaseClassShadowDecl &&\n        NominatedBaseClassShadowDecl->constructsVirtualBase()) {\n      ConstructedBaseClassShadowDecl =\n          NominatedBaseClassShadowDecl->ConstructedBaseClassShadowDecl;\n      IsVirtual = true;\n    }\n  }\n\n  ConstructorUsingShadowDecl(ASTContext &C, EmptyShell Empty)\n      : UsingShadowDecl(ConstructorUsingShadow, C, Empty), IsVirtual(false) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static ConstructorUsingShadowDecl *Create(ASTContext &C, DeclContext *DC,\n                                            SourceLocation Loc,\n                                            UsingDecl *Using, NamedDecl *Target,\n                                            bool IsVirtual);\n  static ConstructorUsingShadowDecl *CreateDeserialized(ASTContext &C,\n                                                        unsigned ID);\n\n  /// Returns the parent of this using shadow declaration, which\n  /// is the class in which this is declared.\n  //@{\n  const CXXRecordDecl *getParent() const {\n    return cast<CXXRecordDecl>(getDeclContext());\n  }\n  CXXRecordDecl *getParent() {\n    return cast<CXXRecordDecl>(getDeclContext());\n  }\n  //@}\n\n  /// Get the inheriting constructor declaration for the direct base\n  /// class from which this using shadow declaration was inherited, if there is\n  /// one. This can be different for each redeclaration of the same shadow decl.\n  ConstructorUsingShadowDecl *getNominatedBaseClassShadowDecl() const {\n    return NominatedBaseClassShadowDecl;\n  }\n\n  /// Get the inheriting constructor declaration for the base class\n  /// for which we don't have an explicit initializer, if there is one.\n  ConstructorUsingShadowDecl *getConstructedBaseClassShadowDecl() const {\n    return ConstructedBaseClassShadowDecl;\n  }\n\n  /// Get the base class that was named in the using declaration. This\n  /// can be different for each redeclaration of this same shadow decl.\n  CXXRecordDecl *getNominatedBaseClass() const;\n\n  /// Get the base class whose constructor or constructor shadow\n  /// declaration is passed the constructor arguments.\n  CXXRecordDecl *getConstructedBaseClass() const {\n    return cast<CXXRecordDecl>((ConstructedBaseClassShadowDecl\n                                    ? ConstructedBaseClassShadowDecl\n                                    : getTargetDecl())\n                                   ->getDeclContext());\n  }\n\n  /// Returns \\c true if the constructed base class is a virtual base\n  /// class subobject of this declaration's class.\n  bool constructsVirtualBase() const {\n    return IsVirtual;\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ConstructorUsingShadow; }\n};\n\n/// Represents a C++ using-declaration.\n///\n/// For example:\n/// \\code\n///    using someNameSpace::someIdentifier;\n/// \\endcode\nclass UsingDecl : public NamedDecl, public Mergeable<UsingDecl> {\n  /// The source location of the 'using' keyword itself.\n  SourceLocation UsingLocation;\n\n  /// The nested-name-specifier that precedes the name.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// Provides source/type location info for the declaration name\n  /// embedded in the ValueDecl base class.\n  DeclarationNameLoc DNLoc;\n\n  /// The first shadow declaration of the shadow decl chain associated\n  /// with this using declaration.\n  ///\n  /// The bool member of the pair store whether this decl has the \\c typename\n  /// keyword.\n  llvm::PointerIntPair<UsingShadowDecl *, 1, bool> FirstUsingShadow;\n\n  UsingDecl(DeclContext *DC, SourceLocation UL,\n            NestedNameSpecifierLoc QualifierLoc,\n            const DeclarationNameInfo &NameInfo, bool HasTypenameKeyword)\n    : NamedDecl(Using, DC, NameInfo.getLoc(), NameInfo.getName()),\n      UsingLocation(UL), QualifierLoc(QualifierLoc),\n      DNLoc(NameInfo.getInfo()), FirstUsingShadow(nullptr, HasTypenameKeyword) {\n  }\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Return the source location of the 'using' keyword.\n  SourceLocation getUsingLoc() const { return UsingLocation; }\n\n  /// Set the source location of the 'using' keyword.\n  void setUsingLoc(SourceLocation L) { UsingLocation = L; }\n\n  /// Retrieve the nested-name-specifier that qualifies the name,\n  /// with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the nested-name-specifier that qualifies the name.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  DeclarationNameInfo getNameInfo() const {\n    return DeclarationNameInfo(getDeclName(), getLocation(), DNLoc);\n  }\n\n  /// Return true if it is a C++03 access declaration (no 'using').\n  bool isAccessDeclaration() const { return UsingLocation.isInvalid(); }\n\n  /// Return true if the using declaration has 'typename'.\n  bool hasTypename() const { return FirstUsingShadow.getInt(); }\n\n  /// Sets whether the using declaration has 'typename'.\n  void setTypename(bool TN) { FirstUsingShadow.setInt(TN); }\n\n  /// Iterates through the using shadow declarations associated with\n  /// this using declaration.\n  class shadow_iterator {\n    /// The current using shadow declaration.\n    UsingShadowDecl *Current = nullptr;\n\n  public:\n    using value_type = UsingShadowDecl *;\n    using reference = UsingShadowDecl *;\n    using pointer = UsingShadowDecl *;\n    using iterator_category = std::forward_iterator_tag;\n    using difference_type = std::ptrdiff_t;\n\n    shadow_iterator() = default;\n    explicit shadow_iterator(UsingShadowDecl *C) : Current(C) {}\n\n    reference operator*() const { return Current; }\n    pointer operator->() const { return Current; }\n\n    shadow_iterator& operator++() {\n      Current = Current->getNextUsingShadowDecl();\n      return *this;\n    }\n\n    shadow_iterator operator++(int) {\n      shadow_iterator tmp(*this);\n      ++(*this);\n      return tmp;\n    }\n\n    friend bool operator==(shadow_iterator x, shadow_iterator y) {\n      return x.Current == y.Current;\n    }\n    friend bool operator!=(shadow_iterator x, shadow_iterator y) {\n      return x.Current != y.Current;\n    }\n  };\n\n  using shadow_range = llvm::iterator_range<shadow_iterator>;\n\n  shadow_range shadows() const {\n    return shadow_range(shadow_begin(), shadow_end());\n  }\n\n  shadow_iterator shadow_begin() const {\n    return shadow_iterator(FirstUsingShadow.getPointer());\n  }\n\n  shadow_iterator shadow_end() const { return shadow_iterator(); }\n\n  /// Return the number of shadowed declarations associated with this\n  /// using declaration.\n  unsigned shadow_size() const {\n    return std::distance(shadow_begin(), shadow_end());\n  }\n\n  void addShadowDecl(UsingShadowDecl *S);\n  void removeShadowDecl(UsingShadowDecl *S);\n\n  static UsingDecl *Create(ASTContext &C, DeclContext *DC,\n                           SourceLocation UsingL,\n                           NestedNameSpecifierLoc QualifierLoc,\n                           const DeclarationNameInfo &NameInfo,\n                           bool HasTypenameKeyword);\n\n  static UsingDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  /// Retrieves the canonical declaration of this declaration.\n  UsingDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const UsingDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Using; }\n};\n\n/// Represents a pack of using declarations that a single\n/// using-declarator pack-expanded into.\n///\n/// \\code\n/// template<typename ...T> struct X : T... {\n///   using T::operator()...;\n///   using T::operator T...;\n/// };\n/// \\endcode\n///\n/// In the second case above, the UsingPackDecl will have the name\n/// 'operator T' (which contains an unexpanded pack), but the individual\n/// UsingDecls and UsingShadowDecls will have more reasonable names.\nclass UsingPackDecl final\n    : public NamedDecl, public Mergeable<UsingPackDecl>,\n      private llvm::TrailingObjects<UsingPackDecl, NamedDecl *> {\n  /// The UnresolvedUsingValueDecl or UnresolvedUsingTypenameDecl from\n  /// which this waas instantiated.\n  NamedDecl *InstantiatedFrom;\n\n  /// The number of using-declarations created by this pack expansion.\n  unsigned NumExpansions;\n\n  UsingPackDecl(DeclContext *DC, NamedDecl *InstantiatedFrom,\n                ArrayRef<NamedDecl *> UsingDecls)\n      : NamedDecl(UsingPack, DC,\n                  InstantiatedFrom ? InstantiatedFrom->getLocation()\n                                   : SourceLocation(),\n                  InstantiatedFrom ? InstantiatedFrom->getDeclName()\n                                   : DeclarationName()),\n        InstantiatedFrom(InstantiatedFrom), NumExpansions(UsingDecls.size()) {\n    std::uninitialized_copy(UsingDecls.begin(), UsingDecls.end(),\n                            getTrailingObjects<NamedDecl *>());\n  }\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend TrailingObjects;\n\n  /// Get the using declaration from which this was instantiated. This will\n  /// always be an UnresolvedUsingValueDecl or an UnresolvedUsingTypenameDecl\n  /// that is a pack expansion.\n  NamedDecl *getInstantiatedFromUsingDecl() const { return InstantiatedFrom; }\n\n  /// Get the set of using declarations that this pack expanded into. Note that\n  /// some of these may still be unresolved.\n  ArrayRef<NamedDecl *> expansions() const {\n    return llvm::makeArrayRef(getTrailingObjects<NamedDecl *>(), NumExpansions);\n  }\n\n  static UsingPackDecl *Create(ASTContext &C, DeclContext *DC,\n                               NamedDecl *InstantiatedFrom,\n                               ArrayRef<NamedDecl *> UsingDecls);\n\n  static UsingPackDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                           unsigned NumExpansions);\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return InstantiatedFrom->getSourceRange();\n  }\n\n  UsingPackDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const UsingPackDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == UsingPack; }\n};\n\n/// Represents a dependent using declaration which was not marked with\n/// \\c typename.\n///\n/// Unlike non-dependent using declarations, these *only* bring through\n/// non-types; otherwise they would break two-phase lookup.\n///\n/// \\code\n/// template \\<class T> class A : public Base<T> {\n///   using Base<T>::foo;\n/// };\n/// \\endcode\nclass UnresolvedUsingValueDecl : public ValueDecl,\n                                 public Mergeable<UnresolvedUsingValueDecl> {\n  /// The source location of the 'using' keyword\n  SourceLocation UsingLocation;\n\n  /// If this is a pack expansion, the location of the '...'.\n  SourceLocation EllipsisLoc;\n\n  /// The nested-name-specifier that precedes the name.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// Provides source/type location info for the declaration name\n  /// embedded in the ValueDecl base class.\n  DeclarationNameLoc DNLoc;\n\n  UnresolvedUsingValueDecl(DeclContext *DC, QualType Ty,\n                           SourceLocation UsingLoc,\n                           NestedNameSpecifierLoc QualifierLoc,\n                           const DeclarationNameInfo &NameInfo,\n                           SourceLocation EllipsisLoc)\n      : ValueDecl(UnresolvedUsingValue, DC,\n                  NameInfo.getLoc(), NameInfo.getName(), Ty),\n        UsingLocation(UsingLoc), EllipsisLoc(EllipsisLoc),\n        QualifierLoc(QualifierLoc), DNLoc(NameInfo.getInfo()) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Returns the source location of the 'using' keyword.\n  SourceLocation getUsingLoc() const { return UsingLocation; }\n\n  /// Set the source location of the 'using' keyword.\n  void setUsingLoc(SourceLocation L) { UsingLocation = L; }\n\n  /// Return true if it is a C++03 access declaration (no 'using').\n  bool isAccessDeclaration() const { return UsingLocation.isInvalid(); }\n\n  /// Retrieve the nested-name-specifier that qualifies the name,\n  /// with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the nested-name-specifier that qualifies the name.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  DeclarationNameInfo getNameInfo() const {\n    return DeclarationNameInfo(getDeclName(), getLocation(), DNLoc);\n  }\n\n  /// Determine whether this is a pack expansion.\n  bool isPackExpansion() const {\n    return EllipsisLoc.isValid();\n  }\n\n  /// Get the location of the ellipsis if this is a pack expansion.\n  SourceLocation getEllipsisLoc() const {\n    return EllipsisLoc;\n  }\n\n  static UnresolvedUsingValueDecl *\n    Create(ASTContext &C, DeclContext *DC, SourceLocation UsingLoc,\n           NestedNameSpecifierLoc QualifierLoc,\n           const DeclarationNameInfo &NameInfo, SourceLocation EllipsisLoc);\n\n  static UnresolvedUsingValueDecl *\n  CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  /// Retrieves the canonical declaration of this declaration.\n  UnresolvedUsingValueDecl *getCanonicalDecl() override {\n    return getFirstDecl();\n  }\n  const UnresolvedUsingValueDecl *getCanonicalDecl() const {\n    return getFirstDecl();\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == UnresolvedUsingValue; }\n};\n\n/// Represents a dependent using declaration which was marked with\n/// \\c typename.\n///\n/// \\code\n/// template \\<class T> class A : public Base<T> {\n///   using typename Base<T>::foo;\n/// };\n/// \\endcode\n///\n/// The type associated with an unresolved using typename decl is\n/// currently always a typename type.\nclass UnresolvedUsingTypenameDecl\n    : public TypeDecl,\n      public Mergeable<UnresolvedUsingTypenameDecl> {\n  friend class ASTDeclReader;\n\n  /// The source location of the 'typename' keyword\n  SourceLocation TypenameLocation;\n\n  /// If this is a pack expansion, the location of the '...'.\n  SourceLocation EllipsisLoc;\n\n  /// The nested-name-specifier that precedes the name.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  UnresolvedUsingTypenameDecl(DeclContext *DC, SourceLocation UsingLoc,\n                              SourceLocation TypenameLoc,\n                              NestedNameSpecifierLoc QualifierLoc,\n                              SourceLocation TargetNameLoc,\n                              IdentifierInfo *TargetName,\n                              SourceLocation EllipsisLoc)\n    : TypeDecl(UnresolvedUsingTypename, DC, TargetNameLoc, TargetName,\n               UsingLoc),\n      TypenameLocation(TypenameLoc), EllipsisLoc(EllipsisLoc),\n      QualifierLoc(QualifierLoc) {}\n\n  void anchor() override;\n\npublic:\n  /// Returns the source location of the 'using' keyword.\n  SourceLocation getUsingLoc() const { return getBeginLoc(); }\n\n  /// Returns the source location of the 'typename' keyword.\n  SourceLocation getTypenameLoc() const { return TypenameLocation; }\n\n  /// Retrieve the nested-name-specifier that qualifies the name,\n  /// with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the nested-name-specifier that qualifies the name.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  DeclarationNameInfo getNameInfo() const {\n    return DeclarationNameInfo(getDeclName(), getLocation());\n  }\n\n  /// Determine whether this is a pack expansion.\n  bool isPackExpansion() const {\n    return EllipsisLoc.isValid();\n  }\n\n  /// Get the location of the ellipsis if this is a pack expansion.\n  SourceLocation getEllipsisLoc() const {\n    return EllipsisLoc;\n  }\n\n  static UnresolvedUsingTypenameDecl *\n    Create(ASTContext &C, DeclContext *DC, SourceLocation UsingLoc,\n           SourceLocation TypenameLoc, NestedNameSpecifierLoc QualifierLoc,\n           SourceLocation TargetNameLoc, DeclarationName TargetName,\n           SourceLocation EllipsisLoc);\n\n  static UnresolvedUsingTypenameDecl *\n  CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// Retrieves the canonical declaration of this declaration.\n  UnresolvedUsingTypenameDecl *getCanonicalDecl() override {\n    return getFirstDecl();\n  }\n  const UnresolvedUsingTypenameDecl *getCanonicalDecl() const {\n    return getFirstDecl();\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == UnresolvedUsingTypename; }\n};\n\n/// Represents a C++11 static_assert declaration.\nclass StaticAssertDecl : public Decl {\n  llvm::PointerIntPair<Expr *, 1, bool> AssertExprAndFailed;\n  StringLiteral *Message;\n  SourceLocation RParenLoc;\n\n  StaticAssertDecl(DeclContext *DC, SourceLocation StaticAssertLoc,\n                   Expr *AssertExpr, StringLiteral *Message,\n                   SourceLocation RParenLoc, bool Failed)\n      : Decl(StaticAssert, DC, StaticAssertLoc),\n        AssertExprAndFailed(AssertExpr, Failed), Message(Message),\n        RParenLoc(RParenLoc) {}\n\n  virtual void anchor();\n\npublic:\n  friend class ASTDeclReader;\n\n  static StaticAssertDecl *Create(ASTContext &C, DeclContext *DC,\n                                  SourceLocation StaticAssertLoc,\n                                  Expr *AssertExpr, StringLiteral *Message,\n                                  SourceLocation RParenLoc, bool Failed);\n  static StaticAssertDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  Expr *getAssertExpr() { return AssertExprAndFailed.getPointer(); }\n  const Expr *getAssertExpr() const { return AssertExprAndFailed.getPointer(); }\n\n  StringLiteral *getMessage() { return Message; }\n  const StringLiteral *getMessage() const { return Message; }\n\n  bool isFailed() const { return AssertExprAndFailed.getInt(); }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(getLocation(), getRParenLoc());\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == StaticAssert; }\n};\n\n/// A binding in a decomposition declaration. For instance, given:\n///\n///   int n[3];\n///   auto &[a, b, c] = n;\n///\n/// a, b, and c are BindingDecls, whose bindings are the expressions\n/// x[0], x[1], and x[2] respectively, where x is the implicit\n/// DecompositionDecl of type 'int (&)[3]'.\nclass BindingDecl : public ValueDecl {\n  /// The declaration that this binding binds to part of.\n  LazyDeclPtr Decomp;\n  /// The binding represented by this declaration. References to this\n  /// declaration are effectively equivalent to this expression (except\n  /// that it is only evaluated once at the point of declaration of the\n  /// binding).\n  Expr *Binding = nullptr;\n\n  BindingDecl(DeclContext *DC, SourceLocation IdLoc, IdentifierInfo *Id)\n      : ValueDecl(Decl::Binding, DC, IdLoc, Id, QualType()) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n\n  static BindingDecl *Create(ASTContext &C, DeclContext *DC,\n                             SourceLocation IdLoc, IdentifierInfo *Id);\n  static BindingDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// Get the expression to which this declaration is bound. This may be null\n  /// in two different cases: while parsing the initializer for the\n  /// decomposition declaration, and when the initializer is type-dependent.\n  Expr *getBinding() const { return Binding; }\n\n  /// Get the decomposition declaration that this binding represents a\n  /// decomposition of.\n  ValueDecl *getDecomposedDecl() const;\n\n  /// Get the variable (if any) that holds the value of evaluating the binding.\n  /// Only present for user-defined bindings for tuple-like types.\n  VarDecl *getHoldingVar() const;\n\n  /// Set the binding for this BindingDecl, along with its declared type (which\n  /// should be a possibly-cv-qualified form of the type of the binding, or a\n  /// reference to such a type).\n  void setBinding(QualType DeclaredType, Expr *Binding) {\n    setType(DeclaredType);\n    this->Binding = Binding;\n  }\n\n  /// Set the decomposed variable for this BindingDecl.\n  void setDecomposedDecl(ValueDecl *Decomposed) { Decomp = Decomposed; }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Decl::Binding; }\n};\n\n/// A decomposition declaration. For instance, given:\n///\n///   int n[3];\n///   auto &[a, b, c] = n;\n///\n/// the second line declares a DecompositionDecl of type 'int (&)[3]', and\n/// three BindingDecls (named a, b, and c). An instance of this class is always\n/// unnamed, but behaves in almost all other respects like a VarDecl.\nclass DecompositionDecl final\n    : public VarDecl,\n      private llvm::TrailingObjects<DecompositionDecl, BindingDecl *> {\n  /// The number of BindingDecl*s following this object.\n  unsigned NumBindings;\n\n  DecompositionDecl(ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n                    SourceLocation LSquareLoc, QualType T,\n                    TypeSourceInfo *TInfo, StorageClass SC,\n                    ArrayRef<BindingDecl *> Bindings)\n      : VarDecl(Decomposition, C, DC, StartLoc, LSquareLoc, nullptr, T, TInfo,\n                SC),\n        NumBindings(Bindings.size()) {\n    std::uninitialized_copy(Bindings.begin(), Bindings.end(),\n                            getTrailingObjects<BindingDecl *>());\n    for (auto *B : Bindings)\n      B->setDecomposedDecl(this);\n  }\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend TrailingObjects;\n\n  static DecompositionDecl *Create(ASTContext &C, DeclContext *DC,\n                                   SourceLocation StartLoc,\n                                   SourceLocation LSquareLoc,\n                                   QualType T, TypeSourceInfo *TInfo,\n                                   StorageClass S,\n                                   ArrayRef<BindingDecl *> Bindings);\n  static DecompositionDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                               unsigned NumBindings);\n\n  ArrayRef<BindingDecl *> bindings() const {\n    return llvm::makeArrayRef(getTrailingObjects<BindingDecl *>(), NumBindings);\n  }\n\n  void printName(raw_ostream &os) const override;\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Decomposition; }\n};\n\n/// An instance of this class represents the declaration of a property\n/// member.  This is a Microsoft extension to C++, first introduced in\n/// Visual Studio .NET 2003 as a parallel to similar features in C#\n/// and Managed C++.\n///\n/// A property must always be a non-static class member.\n///\n/// A property member superficially resembles a non-static data\n/// member, except preceded by a property attribute:\n///   __declspec(property(get=GetX, put=PutX)) int x;\n/// Either (but not both) of the 'get' and 'put' names may be omitted.\n///\n/// A reference to a property is always an lvalue.  If the lvalue\n/// undergoes lvalue-to-rvalue conversion, then a getter name is\n/// required, and that member is called with no arguments.\n/// If the lvalue is assigned into, then a setter name is required,\n/// and that member is called with one argument, the value assigned.\n/// Both operations are potentially overloaded.  Compound assignments\n/// are permitted, as are the increment and decrement operators.\n///\n/// The getter and putter methods are permitted to be overloaded,\n/// although their return and parameter types are subject to certain\n/// restrictions according to the type of the property.\n///\n/// A property declared using an incomplete array type may\n/// additionally be subscripted, adding extra parameters to the getter\n/// and putter methods.\nclass MSPropertyDecl : public DeclaratorDecl {\n  IdentifierInfo *GetterId, *SetterId;\n\n  MSPropertyDecl(DeclContext *DC, SourceLocation L, DeclarationName N,\n                 QualType T, TypeSourceInfo *TInfo, SourceLocation StartL,\n                 IdentifierInfo *Getter, IdentifierInfo *Setter)\n      : DeclaratorDecl(MSProperty, DC, L, N, T, TInfo, StartL),\n        GetterId(Getter), SetterId(Setter) {}\n\n  void anchor() override;\npublic:\n  friend class ASTDeclReader;\n\n  static MSPropertyDecl *Create(ASTContext &C, DeclContext *DC,\n                                SourceLocation L, DeclarationName N, QualType T,\n                                TypeSourceInfo *TInfo, SourceLocation StartL,\n                                IdentifierInfo *Getter, IdentifierInfo *Setter);\n  static MSPropertyDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  static bool classof(const Decl *D) { return D->getKind() == MSProperty; }\n\n  bool hasGetter() const { return GetterId != nullptr; }\n  IdentifierInfo* getGetterId() const { return GetterId; }\n  bool hasSetter() const { return SetterId != nullptr; }\n  IdentifierInfo* getSetterId() const { return SetterId; }\n};\n\n/// Parts of a decomposed MSGuidDecl. Factored out to avoid unnecessary\n/// dependencies on DeclCXX.h.\nstruct MSGuidDeclParts {\n  /// {01234567-...\n  uint32_t Part1;\n  /// ...-89ab-...\n  uint16_t Part2;\n  /// ...-cdef-...\n  uint16_t Part3;\n  /// ...-0123-456789abcdef}\n  uint8_t Part4And5[8];\n\n  uint64_t getPart4And5AsUint64() const {\n    uint64_t Val;\n    memcpy(&Val, &Part4And5, sizeof(Part4And5));\n    return Val;\n  }\n};\n\n/// A global _GUID constant. These are implicitly created by UuidAttrs.\n///\n///   struct _declspec(uuid(\"01234567-89ab-cdef-0123-456789abcdef\")) X{};\n///\n/// X is a CXXRecordDecl that contains a UuidAttr that references the (unique)\n/// MSGuidDecl for the specified UUID.\nclass MSGuidDecl : public ValueDecl,\n                   public Mergeable<MSGuidDecl>,\n                   public llvm::FoldingSetNode {\npublic:\n  using Parts = MSGuidDeclParts;\n\nprivate:\n  /// The decomposed form of the UUID.\n  Parts PartVal;\n\n  /// The resolved value of the UUID as an APValue. Computed on demand and\n  /// cached.\n  mutable APValue APVal;\n\n  void anchor() override;\n\n  MSGuidDecl(DeclContext *DC, QualType T, Parts P);\n\n  static MSGuidDecl *Create(const ASTContext &C, QualType T, Parts P);\n  static MSGuidDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  // Only ASTContext::getMSGuidDecl and deserialization create these.\n  friend class ASTContext;\n  friend class ASTReader;\n  friend class ASTDeclReader;\n\npublic:\n  /// Print this UUID in a human-readable format.\n  void printName(llvm::raw_ostream &OS) const override;\n\n  /// Get the decomposed parts of this declaration.\n  Parts getParts() const { return PartVal; }\n\n  /// Get the value of this MSGuidDecl as an APValue. This may fail and return\n  /// an absent APValue if the type of the declaration is not of the expected\n  /// shape.\n  APValue &getAsAPValue() const;\n\n  static void Profile(llvm::FoldingSetNodeID &ID, Parts P) {\n    ID.AddInteger(P.Part1);\n    ID.AddInteger(P.Part2);\n    ID.AddInteger(P.Part3);\n    ID.AddInteger(P.getPart4And5AsUint64());\n  }\n  void Profile(llvm::FoldingSetNodeID &ID) { Profile(ID, PartVal); }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Decl::MSGuid; }\n};\n\n/// Insertion operator for diagnostics.  This allows sending an AccessSpecifier\n/// into a diagnostic with <<.\nconst StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                      AccessSpecifier AS);\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_DECLCXX_H\n"}, "32": {"id": 32, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclTemplate.h", "content": "//===- DeclTemplate.h - Classes for representing C++ templates --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the C++ template declaration subclasses.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_DECLTEMPLATE_H\n#define LLVM_CLANG_AST_DECLTEMPLATE_H\n\n#include \"clang/AST/ASTConcept.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/Redeclarable.h\"\n#include \"clang/AST/TemplateBase.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <utility>\n\nnamespace clang {\n\nenum BuiltinTemplateKind : int;\nclass ClassTemplateDecl;\nclass ClassTemplatePartialSpecializationDecl;\nclass Expr;\nclass FunctionTemplateDecl;\nclass IdentifierInfo;\nclass NonTypeTemplateParmDecl;\nclass TemplateDecl;\nclass TemplateTemplateParmDecl;\nclass TemplateTypeParmDecl;\nclass ConceptDecl;\nclass UnresolvedSetImpl;\nclass VarTemplateDecl;\nclass VarTemplatePartialSpecializationDecl;\n\n/// Stores a template parameter of any kind.\nusing TemplateParameter =\n    llvm::PointerUnion<TemplateTypeParmDecl *, NonTypeTemplateParmDecl *,\n                       TemplateTemplateParmDecl *>;\n\nNamedDecl *getAsNamedDecl(TemplateParameter P);\n\n/// Stores a list of template parameters for a TemplateDecl and its\n/// derived classes.\nclass TemplateParameterList final\n    : private llvm::TrailingObjects<TemplateParameterList, NamedDecl *,\n                                    Expr *> {\n  /// The location of the 'template' keyword.\n  SourceLocation TemplateLoc;\n\n  /// The locations of the '<' and '>' angle brackets.\n  SourceLocation LAngleLoc, RAngleLoc;\n\n  /// The number of template parameters in this template\n  /// parameter list.\n  unsigned NumParams : 29;\n\n  /// Whether this template parameter list contains an unexpanded parameter\n  /// pack.\n  unsigned ContainsUnexpandedParameterPack : 1;\n\n  /// Whether this template parameter list has a requires clause.\n  unsigned HasRequiresClause : 1;\n\n  /// Whether any of the template parameters has constrained-parameter\n  /// constraint-expression.\n  unsigned HasConstrainedParameters : 1;\n\nprotected:\n  TemplateParameterList(const ASTContext& C, SourceLocation TemplateLoc,\n                        SourceLocation LAngleLoc, ArrayRef<NamedDecl *> Params,\n                        SourceLocation RAngleLoc, Expr *RequiresClause);\n\n  size_t numTrailingObjects(OverloadToken<NamedDecl *>) const {\n    return NumParams;\n  }\n\n  size_t numTrailingObjects(OverloadToken<Expr *>) const {\n    return HasRequiresClause ? 1 : 0;\n  }\n\npublic:\n  template <size_t N, bool HasRequiresClause>\n  friend class FixedSizeTemplateParameterListStorage;\n  friend TrailingObjects;\n\n  static TemplateParameterList *Create(const ASTContext &C,\n                                       SourceLocation TemplateLoc,\n                                       SourceLocation LAngleLoc,\n                                       ArrayRef<NamedDecl *> Params,\n                                       SourceLocation RAngleLoc,\n                                       Expr *RequiresClause);\n\n  /// Iterates through the template parameters in this list.\n  using iterator = NamedDecl **;\n\n  /// Iterates through the template parameters in this list.\n  using const_iterator = NamedDecl * const *;\n\n  iterator begin() { return getTrailingObjects<NamedDecl *>(); }\n  const_iterator begin() const { return getTrailingObjects<NamedDecl *>(); }\n  iterator end() { return begin() + NumParams; }\n  const_iterator end() const { return begin() + NumParams; }\n\n  unsigned size() const { return NumParams; }\n\n  ArrayRef<NamedDecl*> asArray() {\n    return llvm::makeArrayRef(begin(), end());\n  }\n  ArrayRef<const NamedDecl*> asArray() const {\n    return llvm::makeArrayRef(begin(), size());\n  }\n\n  NamedDecl* getParam(unsigned Idx) {\n    assert(Idx < size() && \"Template parameter index out-of-range\");\n    return begin()[Idx];\n  }\n  const NamedDecl* getParam(unsigned Idx) const {\n    assert(Idx < size() && \"Template parameter index out-of-range\");\n    return begin()[Idx];\n  }\n\n  /// Returns the minimum number of arguments needed to form a\n  /// template specialization.\n  ///\n  /// This may be fewer than the number of template parameters, if some of\n  /// the parameters have default arguments or if there is a parameter pack.\n  unsigned getMinRequiredArguments() const;\n\n  /// Get the depth of this template parameter list in the set of\n  /// template parameter lists.\n  ///\n  /// The first template parameter list in a declaration will have depth 0,\n  /// the second template parameter list will have depth 1, etc.\n  unsigned getDepth() const;\n\n  /// Determine whether this template parameter list contains an\n  /// unexpanded parameter pack.\n  bool containsUnexpandedParameterPack() const {\n    return ContainsUnexpandedParameterPack;\n  }\n\n  /// Determine whether this template parameter list contains a parameter pack.\n  bool hasParameterPack() const {\n    for (const NamedDecl *P : asArray())\n      if (P->isParameterPack())\n        return true;\n    return false;\n  }\n\n  /// The constraint-expression of the associated requires-clause.\n  Expr *getRequiresClause() {\n    return HasRequiresClause ? getTrailingObjects<Expr *>()[0] : nullptr;\n  }\n\n  /// The constraint-expression of the associated requires-clause.\n  const Expr *getRequiresClause() const {\n    return HasRequiresClause ? getTrailingObjects<Expr *>()[0] : nullptr;\n  }\n\n  /// \\brief All associated constraints derived from this template parameter\n  /// list, including the requires clause and any constraints derived from\n  /// constrained-parameters.\n  ///\n  /// The constraints in the resulting list are to be treated as if in a\n  /// conjunction (\"and\").\n  void getAssociatedConstraints(llvm::SmallVectorImpl<const Expr *> &AC) const;\n\n  bool hasAssociatedConstraints() const;\n\n  SourceLocation getTemplateLoc() const { return TemplateLoc; }\n  SourceLocation getLAngleLoc() const { return LAngleLoc; }\n  SourceLocation getRAngleLoc() const { return RAngleLoc; }\n\n  SourceRange getSourceRange() const LLVM_READONLY {\n    return SourceRange(TemplateLoc, RAngleLoc);\n  }\n\n  void print(raw_ostream &Out, const ASTContext &Context,\n             bool OmitTemplateKW = false) const;\n  void print(raw_ostream &Out, const ASTContext &Context,\n             const PrintingPolicy &Policy, bool OmitTemplateKW = false) const;\n};\n\n/// Stores a list of template parameters and the associated\n/// requires-clause (if any) for a TemplateDecl and its derived classes.\n/// Suitable for creating on the stack.\ntemplate <size_t N, bool HasRequiresClause>\nclass FixedSizeTemplateParameterListStorage\n    : public TemplateParameterList::FixedSizeStorageOwner {\n  typename TemplateParameterList::FixedSizeStorage<\n      NamedDecl *, Expr *>::with_counts<\n      N, HasRequiresClause ? 1u : 0u\n      >::type storage;\n\npublic:\n  FixedSizeTemplateParameterListStorage(const ASTContext &C,\n                                        SourceLocation TemplateLoc,\n                                        SourceLocation LAngleLoc,\n                                        ArrayRef<NamedDecl *> Params,\n                                        SourceLocation RAngleLoc,\n                                        Expr *RequiresClause)\n      : FixedSizeStorageOwner(\n            (assert(N == Params.size()),\n             assert(HasRequiresClause == (RequiresClause != nullptr)),\n             new (static_cast<void *>(&storage)) TemplateParameterList(C,\n                 TemplateLoc, LAngleLoc, Params, RAngleLoc, RequiresClause))) {}\n};\n\n/// A template argument list.\nclass TemplateArgumentList final\n    : private llvm::TrailingObjects<TemplateArgumentList, TemplateArgument> {\n  /// The template argument list.\n  const TemplateArgument *Arguments;\n\n  /// The number of template arguments in this template\n  /// argument list.\n  unsigned NumArguments;\n\n  // Constructs an instance with an internal Argument list, containing\n  // a copy of the Args array. (Called by CreateCopy)\n  TemplateArgumentList(ArrayRef<TemplateArgument> Args);\n\npublic:\n  friend TrailingObjects;\n\n  TemplateArgumentList(const TemplateArgumentList &) = delete;\n  TemplateArgumentList &operator=(const TemplateArgumentList &) = delete;\n\n  /// Type used to indicate that the template argument list itself is a\n  /// stack object. It does not own its template arguments.\n  enum OnStackType { OnStack };\n\n  /// Create a new template argument list that copies the given set of\n  /// template arguments.\n  static TemplateArgumentList *CreateCopy(ASTContext &Context,\n                                          ArrayRef<TemplateArgument> Args);\n\n  /// Construct a new, temporary template argument list on the stack.\n  ///\n  /// The template argument list does not own the template arguments\n  /// provided.\n  explicit TemplateArgumentList(OnStackType, ArrayRef<TemplateArgument> Args)\n      : Arguments(Args.data()), NumArguments(Args.size()) {}\n\n  /// Produces a shallow copy of the given template argument list.\n  ///\n  /// This operation assumes that the input argument list outlives it.\n  /// This takes the list as a pointer to avoid looking like a copy\n  /// constructor, since this really really isn't safe to use that\n  /// way.\n  explicit TemplateArgumentList(const TemplateArgumentList *Other)\n      : Arguments(Other->data()), NumArguments(Other->size()) {}\n\n  /// Retrieve the template argument at a given index.\n  const TemplateArgument &get(unsigned Idx) const {\n    assert(Idx < NumArguments && \"Invalid template argument index\");\n    return data()[Idx];\n  }\n\n  /// Retrieve the template argument at a given index.\n  const TemplateArgument &operator[](unsigned Idx) const { return get(Idx); }\n\n  /// Produce this as an array ref.\n  ArrayRef<TemplateArgument> asArray() const {\n    return llvm::makeArrayRef(data(), size());\n  }\n\n  /// Retrieve the number of template arguments in this\n  /// template argument list.\n  unsigned size() const { return NumArguments; }\n\n  /// Retrieve a pointer to the template argument list.\n  const TemplateArgument *data() const { return Arguments; }\n};\n\nvoid *allocateDefaultArgStorageChain(const ASTContext &C);\n\n/// Storage for a default argument. This is conceptually either empty, or an\n/// argument value, or a pointer to a previous declaration that had a default\n/// argument.\n///\n/// However, this is complicated by modules: while we require all the default\n/// arguments for a template to be equivalent, there may be more than one, and\n/// we need to track all the originating parameters to determine if the default\n/// argument is visible.\ntemplate<typename ParmDecl, typename ArgType>\nclass DefaultArgStorage {\n  /// Storage for both the value *and* another parameter from which we inherit\n  /// the default argument. This is used when multiple default arguments for a\n  /// parameter are merged together from different modules.\n  struct Chain {\n    ParmDecl *PrevDeclWithDefaultArg;\n    ArgType Value;\n  };\n  static_assert(sizeof(Chain) == sizeof(void *) * 2,\n                \"non-pointer argument type?\");\n\n  llvm::PointerUnion<ArgType, ParmDecl*, Chain*> ValueOrInherited;\n\n  static ParmDecl *getParmOwningDefaultArg(ParmDecl *Parm) {\n    const DefaultArgStorage &Storage = Parm->getDefaultArgStorage();\n    if (auto *Prev = Storage.ValueOrInherited.template dyn_cast<ParmDecl *>())\n      Parm = Prev;\n    assert(!Parm->getDefaultArgStorage()\n                .ValueOrInherited.template is<ParmDecl *>() &&\n           \"should only be one level of indirection\");\n    return Parm;\n  }\n\npublic:\n  DefaultArgStorage() : ValueOrInherited(ArgType()) {}\n\n  /// Determine whether there is a default argument for this parameter.\n  bool isSet() const { return !ValueOrInherited.isNull(); }\n\n  /// Determine whether the default argument for this parameter was inherited\n  /// from a previous declaration of the same entity.\n  bool isInherited() const { return ValueOrInherited.template is<ParmDecl*>(); }\n\n  /// Get the default argument's value. This does not consider whether the\n  /// default argument is visible.\n  ArgType get() const {\n    const DefaultArgStorage *Storage = this;\n    if (const auto *Prev = ValueOrInherited.template dyn_cast<ParmDecl *>())\n      Storage = &Prev->getDefaultArgStorage();\n    if (const auto *C = Storage->ValueOrInherited.template dyn_cast<Chain *>())\n      return C->Value;\n    return Storage->ValueOrInherited.template get<ArgType>();\n  }\n\n  /// Get the parameter from which we inherit the default argument, if any.\n  /// This is the parameter on which the default argument was actually written.\n  const ParmDecl *getInheritedFrom() const {\n    if (const auto *D = ValueOrInherited.template dyn_cast<ParmDecl *>())\n      return D;\n    if (const auto *C = ValueOrInherited.template dyn_cast<Chain *>())\n      return C->PrevDeclWithDefaultArg;\n    return nullptr;\n  }\n\n  /// Set the default argument.\n  void set(ArgType Arg) {\n    assert(!isSet() && \"default argument already set\");\n    ValueOrInherited = Arg;\n  }\n\n  /// Set that the default argument was inherited from another parameter.\n  void setInherited(const ASTContext &C, ParmDecl *InheritedFrom) {\n    assert(!isInherited() && \"default argument already inherited\");\n    InheritedFrom = getParmOwningDefaultArg(InheritedFrom);\n    if (!isSet())\n      ValueOrInherited = InheritedFrom;\n    else\n      ValueOrInherited = new (allocateDefaultArgStorageChain(C))\n          Chain{InheritedFrom, ValueOrInherited.template get<ArgType>()};\n  }\n\n  /// Remove the default argument, even if it was inherited.\n  void clear() {\n    ValueOrInherited = ArgType();\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Kinds of Templates\n//===----------------------------------------------------------------------===//\n\n/// \\brief The base class of all kinds of template declarations (e.g.,\n/// class, function, etc.).\n///\n/// The TemplateDecl class stores the list of template parameters and a\n/// reference to the templated scoped declaration: the underlying AST node.\nclass TemplateDecl : public NamedDecl {\n  void anchor() override;\n\nprotected:\n  // Construct a template decl with name, parameters, and templated element.\n  TemplateDecl(Kind DK, DeclContext *DC, SourceLocation L, DeclarationName Name,\n               TemplateParameterList *Params, NamedDecl *Decl);\n\n  // Construct a template decl with the given name and parameters.\n  // Used when there is no templated element (e.g., for tt-params).\n  TemplateDecl(Kind DK, DeclContext *DC, SourceLocation L, DeclarationName Name,\n               TemplateParameterList *Params)\n      : TemplateDecl(DK, DC, L, Name, Params, nullptr) {}\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Get the list of template parameters\n  TemplateParameterList *getTemplateParameters() const {\n    return TemplateParams;\n  }\n\n  /// \\brief Get the total constraint-expression associated with this template,\n  /// including constraint-expressions derived from the requires-clause,\n  /// trailing requires-clause (for functions and methods) and constrained\n  /// template parameters.\n  void getAssociatedConstraints(llvm::SmallVectorImpl<const Expr *> &AC) const;\n\n  bool hasAssociatedConstraints() const;\n\n  /// Get the underlying, templated declaration.\n  NamedDecl *getTemplatedDecl() const { return TemplatedDecl; }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K >= firstTemplate && K <= lastTemplate;\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(getTemplateParameters()->getTemplateLoc(),\n                       TemplatedDecl->getSourceRange().getEnd());\n  }\n\nprotected:\n  NamedDecl *TemplatedDecl;\n  TemplateParameterList *TemplateParams;\n\n  void setTemplateParameters(TemplateParameterList *TParams) {\n    TemplateParams = TParams;\n  }\n\npublic:\n  /// Initialize the underlying templated declaration and\n  /// template parameters.\n  void init(NamedDecl *templatedDecl, TemplateParameterList* templateParams) {\n    assert(!TemplatedDecl && \"TemplatedDecl already set!\");\n    assert(!TemplateParams && \"TemplateParams already set!\");\n    TemplatedDecl = templatedDecl;\n    TemplateParams = templateParams;\n  }\n};\n\n/// Provides information about a function template specialization,\n/// which is a FunctionDecl that has been explicitly specialization or\n/// instantiated from a function template.\nclass FunctionTemplateSpecializationInfo final\n    : public llvm::FoldingSetNode,\n      private llvm::TrailingObjects<FunctionTemplateSpecializationInfo,\n                                    MemberSpecializationInfo *> {\n  /// The function template specialization that this structure describes and a\n  /// flag indicating if the function is a member specialization.\n  llvm::PointerIntPair<FunctionDecl *, 1, bool> Function;\n\n  /// The function template from which this function template\n  /// specialization was generated.\n  ///\n  /// The two bits contain the top 4 values of TemplateSpecializationKind.\n  llvm::PointerIntPair<FunctionTemplateDecl *, 2> Template;\n\npublic:\n  /// The template arguments used to produce the function template\n  /// specialization from the function template.\n  const TemplateArgumentList *TemplateArguments;\n\n  /// The template arguments as written in the sources, if provided.\n  /// FIXME: Normally null; tail-allocate this.\n  const ASTTemplateArgumentListInfo *TemplateArgumentsAsWritten;\n\n  /// The point at which this function template specialization was\n  /// first instantiated.\n  SourceLocation PointOfInstantiation;\n\nprivate:\n  FunctionTemplateSpecializationInfo(\n      FunctionDecl *FD, FunctionTemplateDecl *Template,\n      TemplateSpecializationKind TSK, const TemplateArgumentList *TemplateArgs,\n      const ASTTemplateArgumentListInfo *TemplateArgsAsWritten,\n      SourceLocation POI, MemberSpecializationInfo *MSInfo)\n      : Function(FD, MSInfo ? 1 : 0), Template(Template, TSK - 1),\n        TemplateArguments(TemplateArgs),\n        TemplateArgumentsAsWritten(TemplateArgsAsWritten),\n        PointOfInstantiation(POI) {\n    if (MSInfo)\n      getTrailingObjects<MemberSpecializationInfo *>()[0] = MSInfo;\n  }\n\n  size_t numTrailingObjects(OverloadToken<MemberSpecializationInfo*>) const {\n    return Function.getInt();\n  }\n\npublic:\n  friend TrailingObjects;\n\n  static FunctionTemplateSpecializationInfo *\n  Create(ASTContext &C, FunctionDecl *FD, FunctionTemplateDecl *Template,\n         TemplateSpecializationKind TSK,\n         const TemplateArgumentList *TemplateArgs,\n         const TemplateArgumentListInfo *TemplateArgsAsWritten,\n         SourceLocation POI, MemberSpecializationInfo *MSInfo);\n\n  /// Retrieve the declaration of the function template specialization.\n  FunctionDecl *getFunction() const { return Function.getPointer(); }\n\n  /// Retrieve the template from which this function was specialized.\n  FunctionTemplateDecl *getTemplate() const { return Template.getPointer(); }\n\n  /// Determine what kind of template specialization this is.\n  TemplateSpecializationKind getTemplateSpecializationKind() const {\n    return (TemplateSpecializationKind)(Template.getInt() + 1);\n  }\n\n  bool isExplicitSpecialization() const {\n    return getTemplateSpecializationKind() == TSK_ExplicitSpecialization;\n  }\n\n  /// True if this declaration is an explicit specialization,\n  /// explicit instantiation declaration, or explicit instantiation\n  /// definition.\n  bool isExplicitInstantiationOrSpecialization() const {\n    return isTemplateExplicitInstantiationOrSpecialization(\n        getTemplateSpecializationKind());\n  }\n\n  /// Set the template specialization kind.\n  void setTemplateSpecializationKind(TemplateSpecializationKind TSK) {\n    assert(TSK != TSK_Undeclared &&\n         \"Cannot encode TSK_Undeclared for a function template specialization\");\n    Template.setInt(TSK - 1);\n  }\n\n  /// Retrieve the first point of instantiation of this function\n  /// template specialization.\n  ///\n  /// The point of instantiation may be an invalid source location if this\n  /// function has yet to be instantiated.\n  SourceLocation getPointOfInstantiation() const {\n    return PointOfInstantiation;\n  }\n\n  /// Set the (first) point of instantiation of this function template\n  /// specialization.\n  void setPointOfInstantiation(SourceLocation POI) {\n    PointOfInstantiation = POI;\n  }\n\n  /// Get the specialization info if this function template specialization is\n  /// also a member specialization:\n  ///\n  /// \\code\n  /// template<typename> struct A {\n  ///   template<typename> void f();\n  ///   template<> void f<int>(); // ClassScopeFunctionSpecializationDecl\n  /// };\n  /// \\endcode\n  ///\n  /// Here, A<int>::f<int> is a function template specialization that is\n  /// an explicit specialization of A<int>::f, but it's also a member\n  /// specialization (an implicit instantiation in this case) of A::f<int>.\n  /// Further:\n  ///\n  /// \\code\n  /// template<> template<> void A<int>::f<int>() {}\n  /// \\endcode\n  ///\n  /// ... declares a function template specialization that is an explicit\n  /// specialization of A<int>::f, and is also an explicit member\n  /// specialization of A::f<int>.\n  ///\n  /// Note that the TemplateSpecializationKind of the MemberSpecializationInfo\n  /// need not be the same as that returned by getTemplateSpecializationKind(),\n  /// and represents the relationship between the function and the class-scope\n  /// explicit specialization in the original templated class -- whereas our\n  /// TemplateSpecializationKind represents the relationship between the\n  /// function and the function template, and should always be\n  /// TSK_ExplicitSpecialization whenever we have MemberSpecializationInfo.\n  MemberSpecializationInfo *getMemberSpecializationInfo() const {\n    return numTrailingObjects(OverloadToken<MemberSpecializationInfo *>())\n               ? getTrailingObjects<MemberSpecializationInfo *>()[0]\n               : nullptr;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, TemplateArguments->asArray(), getFunction()->getASTContext());\n  }\n\n  static void\n  Profile(llvm::FoldingSetNodeID &ID, ArrayRef<TemplateArgument> TemplateArgs,\n          ASTContext &Context) {\n    ID.AddInteger(TemplateArgs.size());\n    for (const TemplateArgument &TemplateArg : TemplateArgs)\n      TemplateArg.Profile(ID, Context);\n  }\n};\n\n/// Provides information a specialization of a member of a class\n/// template, which may be a member function, static data member,\n/// member class or member enumeration.\nclass MemberSpecializationInfo {\n  // The member declaration from which this member was instantiated, and the\n  // manner in which the instantiation occurred (in the lower two bits).\n  llvm::PointerIntPair<NamedDecl *, 2> MemberAndTSK;\n\n  // The point at which this member was first instantiated.\n  SourceLocation PointOfInstantiation;\n\npublic:\n  explicit\n  MemberSpecializationInfo(NamedDecl *IF, TemplateSpecializationKind TSK,\n                           SourceLocation POI = SourceLocation())\n      : MemberAndTSK(IF, TSK - 1), PointOfInstantiation(POI) {\n    assert(TSK != TSK_Undeclared &&\n           \"Cannot encode undeclared template specializations for members\");\n  }\n\n  /// Retrieve the member declaration from which this member was\n  /// instantiated.\n  NamedDecl *getInstantiatedFrom() const { return MemberAndTSK.getPointer(); }\n\n  /// Determine what kind of template specialization this is.\n  TemplateSpecializationKind getTemplateSpecializationKind() const {\n    return (TemplateSpecializationKind)(MemberAndTSK.getInt() + 1);\n  }\n\n  bool isExplicitSpecialization() const {\n    return getTemplateSpecializationKind() == TSK_ExplicitSpecialization;\n  }\n\n  /// Set the template specialization kind.\n  void setTemplateSpecializationKind(TemplateSpecializationKind TSK) {\n    assert(TSK != TSK_Undeclared &&\n           \"Cannot encode undeclared template specializations for members\");\n    MemberAndTSK.setInt(TSK - 1);\n  }\n\n  /// Retrieve the first point of instantiation of this member.\n  /// If the point of instantiation is an invalid location, then this member\n  /// has not yet been instantiated.\n  SourceLocation getPointOfInstantiation() const {\n    return PointOfInstantiation;\n  }\n\n  /// Set the first point of instantiation.\n  void setPointOfInstantiation(SourceLocation POI) {\n    PointOfInstantiation = POI;\n  }\n};\n\n/// Provides information about a dependent function-template\n/// specialization declaration.\n///\n/// Since explicit function template specialization and instantiation\n/// declarations can only appear in namespace scope, and you can only\n/// specialize a member of a fully-specialized class, the only way to\n/// get one of these is in a friend declaration like the following:\n///\n/// \\code\n///   template \\<class T> void foo(T);\n///   template \\<class T> class A {\n///     friend void foo<>(T);\n///   };\n/// \\endcode\nclass DependentFunctionTemplateSpecializationInfo final\n    : private llvm::TrailingObjects<DependentFunctionTemplateSpecializationInfo,\n                                    TemplateArgumentLoc,\n                                    FunctionTemplateDecl *> {\n  /// The number of potential template candidates.\n  unsigned NumTemplates;\n\n  /// The number of template arguments.\n  unsigned NumArgs;\n\n  /// The locations of the left and right angle brackets.\n  SourceRange AngleLocs;\n\n  size_t numTrailingObjects(OverloadToken<TemplateArgumentLoc>) const {\n    return NumArgs;\n  }\n  size_t numTrailingObjects(OverloadToken<FunctionTemplateDecl *>) const {\n    return NumTemplates;\n  }\n\n  DependentFunctionTemplateSpecializationInfo(\n                                 const UnresolvedSetImpl &Templates,\n                                 const TemplateArgumentListInfo &TemplateArgs);\n\npublic:\n  friend TrailingObjects;\n\n  static DependentFunctionTemplateSpecializationInfo *\n  Create(ASTContext &Context, const UnresolvedSetImpl &Templates,\n         const TemplateArgumentListInfo &TemplateArgs);\n\n  /// Returns the number of function templates that this might\n  /// be a specialization of.\n  unsigned getNumTemplates() const { return NumTemplates; }\n\n  /// Returns the i'th template candidate.\n  FunctionTemplateDecl *getTemplate(unsigned I) const {\n    assert(I < getNumTemplates() && \"template index out of range\");\n    return getTrailingObjects<FunctionTemplateDecl *>()[I];\n  }\n\n  /// Returns the explicit template arguments that were given.\n  const TemplateArgumentLoc *getTemplateArgs() const {\n    return getTrailingObjects<TemplateArgumentLoc>();\n  }\n\n  /// Returns the number of explicit template arguments that were given.\n  unsigned getNumTemplateArgs() const { return NumArgs; }\n\n  /// Returns the nth template argument.\n  const TemplateArgumentLoc &getTemplateArg(unsigned I) const {\n    assert(I < getNumTemplateArgs() && \"template arg index out of range\");\n    return getTemplateArgs()[I];\n  }\n\n  SourceLocation getLAngleLoc() const {\n    return AngleLocs.getBegin();\n  }\n\n  SourceLocation getRAngleLoc() const {\n    return AngleLocs.getEnd();\n  }\n};\n\n/// Declaration of a redeclarable template.\nclass RedeclarableTemplateDecl : public TemplateDecl,\n                                 public Redeclarable<RedeclarableTemplateDecl>\n{\n  using redeclarable_base = Redeclarable<RedeclarableTemplateDecl>;\n\n  RedeclarableTemplateDecl *getNextRedeclarationImpl() override {\n    return getNextRedeclaration();\n  }\n\n  RedeclarableTemplateDecl *getPreviousDeclImpl() override {\n    return getPreviousDecl();\n  }\n\n  RedeclarableTemplateDecl *getMostRecentDeclImpl() override {\n    return getMostRecentDecl();\n  }\n\n  void anchor() override;\nprotected:\n  template <typename EntryType> struct SpecEntryTraits {\n    using DeclType = EntryType;\n\n    static DeclType *getDecl(EntryType *D) {\n      return D;\n    }\n\n    static ArrayRef<TemplateArgument> getTemplateArgs(EntryType *D) {\n      return D->getTemplateArgs().asArray();\n    }\n  };\n\n  template <typename EntryType, typename SETraits = SpecEntryTraits<EntryType>,\n            typename DeclType = typename SETraits::DeclType>\n  struct SpecIterator\n      : llvm::iterator_adaptor_base<\n            SpecIterator<EntryType, SETraits, DeclType>,\n            typename llvm::FoldingSetVector<EntryType>::iterator,\n            typename std::iterator_traits<typename llvm::FoldingSetVector<\n                EntryType>::iterator>::iterator_category,\n            DeclType *, ptrdiff_t, DeclType *, DeclType *> {\n    SpecIterator() = default;\n    explicit SpecIterator(\n        typename llvm::FoldingSetVector<EntryType>::iterator SetIter)\n        : SpecIterator::iterator_adaptor_base(std::move(SetIter)) {}\n\n    DeclType *operator*() const {\n      return SETraits::getDecl(&*this->I)->getMostRecentDecl();\n    }\n\n    DeclType *operator->() const { return **this; }\n  };\n\n  template <typename EntryType>\n  static SpecIterator<EntryType>\n  makeSpecIterator(llvm::FoldingSetVector<EntryType> &Specs, bool isEnd) {\n    return SpecIterator<EntryType>(isEnd ? Specs.end() : Specs.begin());\n  }\n\n  void loadLazySpecializationsImpl() const;\n\n  template <class EntryType, typename ...ProfileArguments>\n  typename SpecEntryTraits<EntryType>::DeclType*\n  findSpecializationImpl(llvm::FoldingSetVector<EntryType> &Specs,\n                         void *&InsertPos, ProfileArguments &&...ProfileArgs);\n\n  template <class Derived, class EntryType>\n  void addSpecializationImpl(llvm::FoldingSetVector<EntryType> &Specs,\n                             EntryType *Entry, void *InsertPos);\n\n  struct CommonBase {\n    CommonBase() : InstantiatedFromMember(nullptr, false) {}\n\n    /// The template from which this was most\n    /// directly instantiated (or null).\n    ///\n    /// The boolean value indicates whether this template\n    /// was explicitly specialized.\n    llvm::PointerIntPair<RedeclarableTemplateDecl*, 1, bool>\n      InstantiatedFromMember;\n\n    /// If non-null, points to an array of specializations (including\n    /// partial specializations) known only by their external declaration IDs.\n    ///\n    /// The first value in the array is the number of specializations/partial\n    /// specializations that follow.\n    uint32_t *LazySpecializations = nullptr;\n  };\n\n  /// Pointer to the common data shared by all declarations of this\n  /// template.\n  mutable CommonBase *Common = nullptr;\n\n  /// Retrieves the \"common\" pointer shared by all (re-)declarations of\n  /// the same template. Calling this routine may implicitly allocate memory\n  /// for the common pointer.\n  CommonBase *getCommonPtr() const;\n\n  virtual CommonBase *newCommon(ASTContext &C) const = 0;\n\n  // Construct a template decl with name, parameters, and templated element.\n  RedeclarableTemplateDecl(Kind DK, ASTContext &C, DeclContext *DC,\n                           SourceLocation L, DeclarationName Name,\n                           TemplateParameterList *Params, NamedDecl *Decl)\n      : TemplateDecl(DK, DC, L, Name, Params, Decl), redeclarable_base(C) {}\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend class ASTReader;\n  template <class decl_type> friend class RedeclarableTemplate;\n\n  /// Retrieves the canonical declaration of this template.\n  RedeclarableTemplateDecl *getCanonicalDecl() override {\n    return getFirstDecl();\n  }\n  const RedeclarableTemplateDecl *getCanonicalDecl() const {\n    return getFirstDecl();\n  }\n\n  /// Determines whether this template was a specialization of a\n  /// member template.\n  ///\n  /// In the following example, the function template \\c X<int>::f and the\n  /// member template \\c X<int>::Inner are member specializations.\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   template<typename U> void f(T, U);\n  ///   template<typename U> struct Inner;\n  /// };\n  ///\n  /// template<> template<typename T>\n  /// void X<int>::f(int, T);\n  /// template<> template<typename T>\n  /// struct X<int>::Inner { /* ... */ };\n  /// \\endcode\n  bool isMemberSpecialization() const {\n    return getCommonPtr()->InstantiatedFromMember.getInt();\n  }\n\n  /// Note that this member template is a specialization.\n  void setMemberSpecialization() {\n    assert(getCommonPtr()->InstantiatedFromMember.getPointer() &&\n           \"Only member templates can be member template specializations\");\n    getCommonPtr()->InstantiatedFromMember.setInt(true);\n  }\n\n  /// Retrieve the member template from which this template was\n  /// instantiated, or nullptr if this template was not instantiated from a\n  /// member template.\n  ///\n  /// A template is instantiated from a member template when the member\n  /// template itself is part of a class template (or member thereof). For\n  /// example, given\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   template<typename U> void f(T, U);\n  /// };\n  ///\n  /// void test(X<int> x) {\n  ///   x.f(1, 'a');\n  /// };\n  /// \\endcode\n  ///\n  /// \\c X<int>::f is a FunctionTemplateDecl that describes the function\n  /// template\n  ///\n  /// \\code\n  /// template<typename U> void X<int>::f(int, U);\n  /// \\endcode\n  ///\n  /// which was itself created during the instantiation of \\c X<int>. Calling\n  /// getInstantiatedFromMemberTemplate() on this FunctionTemplateDecl will\n  /// retrieve the FunctionTemplateDecl for the original template \\c f within\n  /// the class template \\c X<T>, i.e.,\n  ///\n  /// \\code\n  /// template<typename T>\n  /// template<typename U>\n  /// void X<T>::f(T, U);\n  /// \\endcode\n  RedeclarableTemplateDecl *getInstantiatedFromMemberTemplate() const {\n    return getCommonPtr()->InstantiatedFromMember.getPointer();\n  }\n\n  void setInstantiatedFromMemberTemplate(RedeclarableTemplateDecl *TD) {\n    assert(!getCommonPtr()->InstantiatedFromMember.getPointer());\n    getCommonPtr()->InstantiatedFromMember.setPointer(TD);\n  }\n\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K >= firstRedeclarableTemplate && K <= lastRedeclarableTemplate;\n  }\n};\n\ntemplate <> struct RedeclarableTemplateDecl::\nSpecEntryTraits<FunctionTemplateSpecializationInfo> {\n  using DeclType = FunctionDecl;\n\n  static DeclType *getDecl(FunctionTemplateSpecializationInfo *I) {\n    return I->getFunction();\n  }\n\n  static ArrayRef<TemplateArgument>\n  getTemplateArgs(FunctionTemplateSpecializationInfo *I) {\n    return I->TemplateArguments->asArray();\n  }\n};\n\n/// Declaration of a template function.\nclass FunctionTemplateDecl : public RedeclarableTemplateDecl {\nprotected:\n  friend class FunctionDecl;\n\n  /// Data that is common to all of the declarations of a given\n  /// function template.\n  struct Common : CommonBase {\n    /// The function template specializations for this function\n    /// template, including explicit specializations and instantiations.\n    llvm::FoldingSetVector<FunctionTemplateSpecializationInfo> Specializations;\n\n    /// The set of \"injected\" template arguments used within this\n    /// function template.\n    ///\n    /// This pointer refers to the template arguments (there are as\n    /// many template arguments as template parameaters) for the function\n    /// template, and is allocated lazily, since most function templates do not\n    /// require the use of this information.\n    TemplateArgument *InjectedArgs = nullptr;\n\n    Common() = default;\n  };\n\n  FunctionTemplateDecl(ASTContext &C, DeclContext *DC, SourceLocation L,\n                       DeclarationName Name, TemplateParameterList *Params,\n                       NamedDecl *Decl)\n      : RedeclarableTemplateDecl(FunctionTemplate, C, DC, L, Name, Params,\n                                 Decl) {}\n\n  CommonBase *newCommon(ASTContext &C) const override;\n\n  Common *getCommonPtr() const {\n    return static_cast<Common *>(RedeclarableTemplateDecl::getCommonPtr());\n  }\n\n  /// Retrieve the set of function template specializations of this\n  /// function template.\n  llvm::FoldingSetVector<FunctionTemplateSpecializationInfo> &\n  getSpecializations() const;\n\n  /// Add a specialization of this function template.\n  ///\n  /// \\param InsertPos Insert position in the FoldingSetVector, must have been\n  ///        retrieved by an earlier call to findSpecialization().\n  void addSpecialization(FunctionTemplateSpecializationInfo* Info,\n                         void *InsertPos);\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Load any lazily-loaded specializations from the external source.\n  void LoadLazySpecializations() const;\n\n  /// Get the underlying function declaration of the template.\n  FunctionDecl *getTemplatedDecl() const {\n    return static_cast<FunctionDecl *>(TemplatedDecl);\n  }\n\n  /// Returns whether this template declaration defines the primary\n  /// pattern.\n  bool isThisDeclarationADefinition() const {\n    return getTemplatedDecl()->isThisDeclarationADefinition();\n  }\n\n  /// Return the specialization with the provided arguments if it exists,\n  /// otherwise return the insertion point.\n  FunctionDecl *findSpecialization(ArrayRef<TemplateArgument> Args,\n                                   void *&InsertPos);\n\n  FunctionTemplateDecl *getCanonicalDecl() override {\n    return cast<FunctionTemplateDecl>(\n             RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n  const FunctionTemplateDecl *getCanonicalDecl() const {\n    return cast<FunctionTemplateDecl>(\n             RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n\n  /// Retrieve the previous declaration of this function template, or\n  /// nullptr if no such declaration exists.\n  FunctionTemplateDecl *getPreviousDecl() {\n    return cast_or_null<FunctionTemplateDecl>(\n             static_cast<RedeclarableTemplateDecl *>(this)->getPreviousDecl());\n  }\n  const FunctionTemplateDecl *getPreviousDecl() const {\n    return cast_or_null<FunctionTemplateDecl>(\n       static_cast<const RedeclarableTemplateDecl *>(this)->getPreviousDecl());\n  }\n\n  FunctionTemplateDecl *getMostRecentDecl() {\n    return cast<FunctionTemplateDecl>(\n        static_cast<RedeclarableTemplateDecl *>(this)\n            ->getMostRecentDecl());\n  }\n  const FunctionTemplateDecl *getMostRecentDecl() const {\n    return const_cast<FunctionTemplateDecl*>(this)->getMostRecentDecl();\n  }\n\n  FunctionTemplateDecl *getInstantiatedFromMemberTemplate() const {\n    return cast_or_null<FunctionTemplateDecl>(\n             RedeclarableTemplateDecl::getInstantiatedFromMemberTemplate());\n  }\n\n  using spec_iterator = SpecIterator<FunctionTemplateSpecializationInfo>;\n  using spec_range = llvm::iterator_range<spec_iterator>;\n\n  spec_range specializations() const {\n    return spec_range(spec_begin(), spec_end());\n  }\n\n  spec_iterator spec_begin() const {\n    return makeSpecIterator(getSpecializations(), false);\n  }\n\n  spec_iterator spec_end() const {\n    return makeSpecIterator(getSpecializations(), true);\n  }\n\n  /// Retrieve the \"injected\" template arguments that correspond to the\n  /// template parameters of this function template.\n  ///\n  /// Although the C++ standard has no notion of the \"injected\" template\n  /// arguments for a function template, the notion is convenient when\n  /// we need to perform substitutions inside the definition of a function\n  /// template.\n  ArrayRef<TemplateArgument> getInjectedTemplateArgs();\n\n  /// Return whether this function template is an abbreviated function template,\n  /// e.g. `void foo(auto x)` or `template<typename T> void foo(auto x)`\n  bool isAbbreviated() const {\n    // Since the invented template parameters generated from 'auto' parameters\n    // are either appended to the end of the explicit template parameter list or\n    // form a new template paramter list, we can simply observe the last\n    // parameter to determine if such a thing happened.\n    const TemplateParameterList *TPL = getTemplateParameters();\n    return TPL->getParam(TPL->size() - 1)->isImplicit();\n  }\n\n  /// Merge \\p Prev with our RedeclarableTemplateDecl::Common.\n  void mergePrevDecl(FunctionTemplateDecl *Prev);\n\n  /// Create a function template node.\n  static FunctionTemplateDecl *Create(ASTContext &C, DeclContext *DC,\n                                      SourceLocation L,\n                                      DeclarationName Name,\n                                      TemplateParameterList *Params,\n                                      NamedDecl *Decl);\n\n  /// Create an empty function template node.\n  static FunctionTemplateDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  // Implement isa/cast/dyncast support\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == FunctionTemplate; }\n};\n\n//===----------------------------------------------------------------------===//\n// Kinds of Template Parameters\n//===----------------------------------------------------------------------===//\n\n/// Defines the position of a template parameter within a template\n/// parameter list.\n///\n/// Because template parameter can be listed\n/// sequentially for out-of-line template members, each template parameter is\n/// given a Depth - the nesting of template parameter scopes - and a Position -\n/// the occurrence within the parameter list.\n/// This class is inheritedly privately by different kinds of template\n/// parameters and is not part of the Decl hierarchy. Just a facility.\nclass TemplateParmPosition {\nprotected:\n  // FIXME: These probably don't need to be ints. int:5 for depth, int:8 for\n  // position? Maybe?\n  unsigned Depth;\n  unsigned Position;\n\n  TemplateParmPosition(unsigned D, unsigned P) : Depth(D), Position(P) {}\n\npublic:\n  TemplateParmPosition() = delete;\n\n  /// Get the nesting depth of the template parameter.\n  unsigned getDepth() const { return Depth; }\n  void setDepth(unsigned D) { Depth = D; }\n\n  /// Get the position of the template parameter within its parameter list.\n  unsigned getPosition() const { return Position; }\n  void setPosition(unsigned P) { Position = P; }\n\n  /// Get the index of the template parameter within its parameter list.\n  unsigned getIndex() const { return Position; }\n};\n\n/// Declaration of a template type parameter.\n///\n/// For example, \"T\" in\n/// \\code\n/// template<typename T> class vector;\n/// \\endcode\nclass TemplateTypeParmDecl final : public TypeDecl,\n    private llvm::TrailingObjects<TemplateTypeParmDecl, TypeConstraint> {\n  /// Sema creates these on the stack during auto type deduction.\n  friend class Sema;\n  friend TrailingObjects;\n  friend class ASTDeclReader;\n\n  /// Whether this template type parameter was declaration with\n  /// the 'typename' keyword.\n  ///\n  /// If false, it was declared with the 'class' keyword.\n  bool Typename : 1;\n\n  /// Whether this template type parameter has a type-constraint construct.\n  bool HasTypeConstraint : 1;\n\n  /// Whether the type constraint has been initialized. This can be false if the\n  /// constraint was not initialized yet or if there was an error forming the\n  /// type constriant.\n  bool TypeConstraintInitialized : 1;\n\n  /// Whether this non-type template parameter is an \"expanded\"\n  /// parameter pack, meaning that its type is a pack expansion and we\n  /// already know the set of types that expansion expands to.\n  bool ExpandedParameterPack : 1;\n\n  /// The number of type parameters in an expanded parameter pack.\n  unsigned NumExpanded = 0;\n\n  /// The default template argument, if any.\n  using DefArgStorage =\n      DefaultArgStorage<TemplateTypeParmDecl, TypeSourceInfo *>;\n  DefArgStorage DefaultArgument;\n\n  TemplateTypeParmDecl(DeclContext *DC, SourceLocation KeyLoc,\n                       SourceLocation IdLoc, IdentifierInfo *Id,\n                       bool Typename, bool HasTypeConstraint,\n                       Optional<unsigned> NumExpanded)\n      : TypeDecl(TemplateTypeParm, DC, IdLoc, Id, KeyLoc), Typename(Typename),\n      HasTypeConstraint(HasTypeConstraint), TypeConstraintInitialized(false),\n      ExpandedParameterPack(NumExpanded),\n      NumExpanded(NumExpanded ? *NumExpanded : 0) {}\n\npublic:\n  static TemplateTypeParmDecl *Create(const ASTContext &C, DeclContext *DC,\n                                      SourceLocation KeyLoc,\n                                      SourceLocation NameLoc,\n                                      unsigned D, unsigned P,\n                                      IdentifierInfo *Id, bool Typename,\n                                      bool ParameterPack,\n                                      bool HasTypeConstraint = false,\n                                      Optional<unsigned> NumExpanded = None);\n  static TemplateTypeParmDecl *CreateDeserialized(const ASTContext &C,\n                                                  unsigned ID);\n  static TemplateTypeParmDecl *CreateDeserialized(const ASTContext &C,\n                                                  unsigned ID,\n                                                  bool HasTypeConstraint);\n\n  /// Whether this template type parameter was declared with\n  /// the 'typename' keyword.\n  ///\n  /// If not, it was either declared with the 'class' keyword or with a\n  /// type-constraint (see hasTypeConstraint()).\n  bool wasDeclaredWithTypename() const {\n    return Typename && !HasTypeConstraint;\n  }\n\n  const DefArgStorage &getDefaultArgStorage() const { return DefaultArgument; }\n\n  /// Determine whether this template parameter has a default\n  /// argument.\n  bool hasDefaultArgument() const { return DefaultArgument.isSet(); }\n\n  /// Retrieve the default argument, if any.\n  QualType getDefaultArgument() const {\n    return DefaultArgument.get()->getType();\n  }\n\n  /// Retrieves the default argument's source information, if any.\n  TypeSourceInfo *getDefaultArgumentInfo() const {\n    return DefaultArgument.get();\n  }\n\n  /// Retrieves the location of the default argument declaration.\n  SourceLocation getDefaultArgumentLoc() const;\n\n  /// Determines whether the default argument was inherited\n  /// from a previous declaration of this template.\n  bool defaultArgumentWasInherited() const {\n    return DefaultArgument.isInherited();\n  }\n\n  /// Set the default argument for this template parameter.\n  void setDefaultArgument(TypeSourceInfo *DefArg) {\n    DefaultArgument.set(DefArg);\n  }\n\n  /// Set that this default argument was inherited from another\n  /// parameter.\n  void setInheritedDefaultArgument(const ASTContext &C,\n                                   TemplateTypeParmDecl *Prev) {\n    DefaultArgument.setInherited(C, Prev);\n  }\n\n  /// Removes the default argument of this template parameter.\n  void removeDefaultArgument() {\n    DefaultArgument.clear();\n  }\n\n  /// Set whether this template type parameter was declared with\n  /// the 'typename' or 'class' keyword.\n  void setDeclaredWithTypename(bool withTypename) { Typename = withTypename; }\n\n  /// Retrieve the depth of the template parameter.\n  unsigned getDepth() const;\n\n  /// Retrieve the index of the template parameter.\n  unsigned getIndex() const;\n\n  /// Returns whether this is a parameter pack.\n  bool isParameterPack() const;\n\n  /// Whether this parameter pack is a pack expansion.\n  ///\n  /// A template type template parameter pack can be a pack expansion if its\n  /// type-constraint contains an unexpanded parameter pack.\n  bool isPackExpansion() const {\n    if (!isParameterPack())\n      return false;\n    if (const TypeConstraint *TC = getTypeConstraint())\n      if (TC->hasExplicitTemplateArgs())\n        for (const auto &ArgLoc : TC->getTemplateArgsAsWritten()->arguments())\n          if (ArgLoc.getArgument().containsUnexpandedParameterPack())\n            return true;\n    return false;\n  }\n\n  /// Whether this parameter is a template type parameter pack that has a known\n  /// list of different type-constraints at different positions.\n  ///\n  /// A parameter pack is an expanded parameter pack when the original\n  /// parameter pack's type-constraint was itself a pack expansion, and that\n  /// expansion has already been expanded. For example, given:\n  ///\n  /// \\code\n  /// template<typename ...Types>\n  /// struct X {\n  ///   template<convertible_to<Types> ...Convertibles>\n  ///   struct Y { /* ... */ };\n  /// };\n  /// \\endcode\n  ///\n  /// The parameter pack \\c Convertibles has (convertible_to<Types> && ...) as\n  /// its type-constraint. When \\c Types is supplied with template arguments by\n  /// instantiating \\c X, the instantiation of \\c Convertibles becomes an\n  /// expanded parameter pack. For example, instantiating\n  /// \\c X<int, unsigned int> results in \\c Convertibles being an expanded\n  /// parameter pack of size 2 (use getNumExpansionTypes() to get this number).\n  bool isExpandedParameterPack() const { return ExpandedParameterPack; }\n\n  /// Retrieves the number of parameters in an expanded parameter pack.\n  unsigned getNumExpansionParameters() const {\n    assert(ExpandedParameterPack && \"Not an expansion parameter pack\");\n    return NumExpanded;\n  }\n\n  /// Returns the type constraint associated with this template parameter (if\n  /// any).\n  const TypeConstraint *getTypeConstraint() const {\n    return TypeConstraintInitialized ? getTrailingObjects<TypeConstraint>() :\n         nullptr;\n  }\n\n  void setTypeConstraint(NestedNameSpecifierLoc NNS,\n                         DeclarationNameInfo NameInfo, NamedDecl *FoundDecl,\n                         ConceptDecl *CD,\n                         const ASTTemplateArgumentListInfo *ArgsAsWritten,\n                         Expr *ImmediatelyDeclaredConstraint);\n\n  /// Determine whether this template parameter has a type-constraint.\n  bool hasTypeConstraint() const {\n    return HasTypeConstraint;\n  }\n\n  /// \\brief Get the associated-constraints of this template parameter.\n  /// This will either be the immediately-introduced constraint or empty.\n  ///\n  /// Use this instead of getConstraintExpression for concepts APIs that\n  /// accept an ArrayRef of constraint expressions.\n  void getAssociatedConstraints(llvm::SmallVectorImpl<const Expr *> &AC) const {\n    if (HasTypeConstraint)\n      AC.push_back(getTypeConstraint()->getImmediatelyDeclaredConstraint());\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == TemplateTypeParm; }\n};\n\n/// NonTypeTemplateParmDecl - Declares a non-type template parameter,\n/// e.g., \"Size\" in\n/// @code\n/// template<int Size> class array { };\n/// @endcode\nclass NonTypeTemplateParmDecl final\n    : public DeclaratorDecl,\n      protected TemplateParmPosition,\n      private llvm::TrailingObjects<NonTypeTemplateParmDecl,\n                                    std::pair<QualType, TypeSourceInfo *>,\n                                    Expr *> {\n  friend class ASTDeclReader;\n  friend TrailingObjects;\n\n  /// The default template argument, if any, and whether or not\n  /// it was inherited.\n  using DefArgStorage = DefaultArgStorage<NonTypeTemplateParmDecl, Expr *>;\n  DefArgStorage DefaultArgument;\n\n  // FIXME: Collapse this into TemplateParamPosition; or, just move depth/index\n  // down here to save memory.\n\n  /// Whether this non-type template parameter is a parameter pack.\n  bool ParameterPack;\n\n  /// Whether this non-type template parameter is an \"expanded\"\n  /// parameter pack, meaning that its type is a pack expansion and we\n  /// already know the set of types that expansion expands to.\n  bool ExpandedParameterPack = false;\n\n  /// The number of types in an expanded parameter pack.\n  unsigned NumExpandedTypes = 0;\n\n  size_t numTrailingObjects(\n      OverloadToken<std::pair<QualType, TypeSourceInfo *>>) const {\n    return NumExpandedTypes;\n  }\n\n  NonTypeTemplateParmDecl(DeclContext *DC, SourceLocation StartLoc,\n                          SourceLocation IdLoc, unsigned D, unsigned P,\n                          IdentifierInfo *Id, QualType T,\n                          bool ParameterPack, TypeSourceInfo *TInfo)\n      : DeclaratorDecl(NonTypeTemplateParm, DC, IdLoc, Id, T, TInfo, StartLoc),\n        TemplateParmPosition(D, P), ParameterPack(ParameterPack) {}\n\n  NonTypeTemplateParmDecl(DeclContext *DC, SourceLocation StartLoc,\n                          SourceLocation IdLoc, unsigned D, unsigned P,\n                          IdentifierInfo *Id, QualType T,\n                          TypeSourceInfo *TInfo,\n                          ArrayRef<QualType> ExpandedTypes,\n                          ArrayRef<TypeSourceInfo *> ExpandedTInfos);\n\npublic:\n  static NonTypeTemplateParmDecl *\n  Create(const ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n         SourceLocation IdLoc, unsigned D, unsigned P, IdentifierInfo *Id,\n         QualType T, bool ParameterPack, TypeSourceInfo *TInfo);\n\n  static NonTypeTemplateParmDecl *\n  Create(const ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n         SourceLocation IdLoc, unsigned D, unsigned P, IdentifierInfo *Id,\n         QualType T, TypeSourceInfo *TInfo, ArrayRef<QualType> ExpandedTypes,\n         ArrayRef<TypeSourceInfo *> ExpandedTInfos);\n\n  static NonTypeTemplateParmDecl *CreateDeserialized(ASTContext &C,\n                                                     unsigned ID,\n                                                     bool HasTypeConstraint);\n  static NonTypeTemplateParmDecl *CreateDeserialized(ASTContext &C,\n                                                     unsigned ID,\n                                                     unsigned NumExpandedTypes,\n                                                     bool HasTypeConstraint);\n\n  using TemplateParmPosition::getDepth;\n  using TemplateParmPosition::setDepth;\n  using TemplateParmPosition::getPosition;\n  using TemplateParmPosition::setPosition;\n  using TemplateParmPosition::getIndex;\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  const DefArgStorage &getDefaultArgStorage() const { return DefaultArgument; }\n\n  /// Determine whether this template parameter has a default\n  /// argument.\n  bool hasDefaultArgument() const { return DefaultArgument.isSet(); }\n\n  /// Retrieve the default argument, if any.\n  Expr *getDefaultArgument() const { return DefaultArgument.get(); }\n\n  /// Retrieve the location of the default argument, if any.\n  SourceLocation getDefaultArgumentLoc() const;\n\n  /// Determines whether the default argument was inherited\n  /// from a previous declaration of this template.\n  bool defaultArgumentWasInherited() const {\n    return DefaultArgument.isInherited();\n  }\n\n  /// Set the default argument for this template parameter, and\n  /// whether that default argument was inherited from another\n  /// declaration.\n  void setDefaultArgument(Expr *DefArg) { DefaultArgument.set(DefArg); }\n  void setInheritedDefaultArgument(const ASTContext &C,\n                                   NonTypeTemplateParmDecl *Parm) {\n    DefaultArgument.setInherited(C, Parm);\n  }\n\n  /// Removes the default argument of this template parameter.\n  void removeDefaultArgument() { DefaultArgument.clear(); }\n\n  /// Whether this parameter is a non-type template parameter pack.\n  ///\n  /// If the parameter is a parameter pack, the type may be a\n  /// \\c PackExpansionType. In the following example, the \\c Dims parameter\n  /// is a parameter pack (whose type is 'unsigned').\n  ///\n  /// \\code\n  /// template<typename T, unsigned ...Dims> struct multi_array;\n  /// \\endcode\n  bool isParameterPack() const { return ParameterPack; }\n\n  /// Whether this parameter pack is a pack expansion.\n  ///\n  /// A non-type template parameter pack is a pack expansion if its type\n  /// contains an unexpanded parameter pack. In this case, we will have\n  /// built a PackExpansionType wrapping the type.\n  bool isPackExpansion() const {\n    return ParameterPack && getType()->getAs<PackExpansionType>();\n  }\n\n  /// Whether this parameter is a non-type template parameter pack\n  /// that has a known list of different types at different positions.\n  ///\n  /// A parameter pack is an expanded parameter pack when the original\n  /// parameter pack's type was itself a pack expansion, and that expansion\n  /// has already been expanded. For example, given:\n  ///\n  /// \\code\n  /// template<typename ...Types>\n  /// struct X {\n  ///   template<Types ...Values>\n  ///   struct Y { /* ... */ };\n  /// };\n  /// \\endcode\n  ///\n  /// The parameter pack \\c Values has a \\c PackExpansionType as its type,\n  /// which expands \\c Types. When \\c Types is supplied with template arguments\n  /// by instantiating \\c X, the instantiation of \\c Values becomes an\n  /// expanded parameter pack. For example, instantiating\n  /// \\c X<int, unsigned int> results in \\c Values being an expanded parameter\n  /// pack with expansion types \\c int and \\c unsigned int.\n  ///\n  /// The \\c getExpansionType() and \\c getExpansionTypeSourceInfo() functions\n  /// return the expansion types.\n  bool isExpandedParameterPack() const { return ExpandedParameterPack; }\n\n  /// Retrieves the number of expansion types in an expanded parameter\n  /// pack.\n  unsigned getNumExpansionTypes() const {\n    assert(ExpandedParameterPack && \"Not an expansion parameter pack\");\n    return NumExpandedTypes;\n  }\n\n  /// Retrieve a particular expansion type within an expanded parameter\n  /// pack.\n  QualType getExpansionType(unsigned I) const {\n    assert(I < NumExpandedTypes && \"Out-of-range expansion type index\");\n    auto TypesAndInfos =\n        getTrailingObjects<std::pair<QualType, TypeSourceInfo *>>();\n    return TypesAndInfos[I].first;\n  }\n\n  /// Retrieve a particular expansion type source info within an\n  /// expanded parameter pack.\n  TypeSourceInfo *getExpansionTypeSourceInfo(unsigned I) const {\n    assert(I < NumExpandedTypes && \"Out-of-range expansion type index\");\n    auto TypesAndInfos =\n        getTrailingObjects<std::pair<QualType, TypeSourceInfo *>>();\n    return TypesAndInfos[I].second;\n  }\n\n  /// Return the constraint introduced by the placeholder type of this non-type\n  /// template parameter (if any).\n  Expr *getPlaceholderTypeConstraint() const {\n    return hasPlaceholderTypeConstraint() ? *getTrailingObjects<Expr *>() :\n        nullptr;\n  }\n\n  void setPlaceholderTypeConstraint(Expr *E) {\n    *getTrailingObjects<Expr *>() = E;\n  }\n\n  /// Determine whether this non-type template parameter's type has a\n  /// placeholder with a type-constraint.\n  bool hasPlaceholderTypeConstraint() const {\n    auto *AT = getType()->getContainedAutoType();\n    return AT && AT->isConstrained();\n  }\n\n  /// \\brief Get the associated-constraints of this template parameter.\n  /// This will either be a vector of size 1 containing the immediately-declared\n  /// constraint introduced by the placeholder type, or an empty vector.\n  ///\n  /// Use this instead of getPlaceholderImmediatelyDeclaredConstraint for\n  /// concepts APIs that accept an ArrayRef of constraint expressions.\n  void getAssociatedConstraints(llvm::SmallVectorImpl<const Expr *> &AC) const {\n    if (Expr *E = getPlaceholderTypeConstraint())\n      AC.push_back(E);\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == NonTypeTemplateParm; }\n};\n\n/// TemplateTemplateParmDecl - Declares a template template parameter,\n/// e.g., \"T\" in\n/// @code\n/// template <template <typename> class T> class container { };\n/// @endcode\n/// A template template parameter is a TemplateDecl because it defines the\n/// name of a template and the template parameters allowable for substitution.\nclass TemplateTemplateParmDecl final\n    : public TemplateDecl,\n      protected TemplateParmPosition,\n      private llvm::TrailingObjects<TemplateTemplateParmDecl,\n                                    TemplateParameterList *> {\n  /// The default template argument, if any.\n  using DefArgStorage =\n      DefaultArgStorage<TemplateTemplateParmDecl, TemplateArgumentLoc *>;\n  DefArgStorage DefaultArgument;\n\n  /// Whether this parameter is a parameter pack.\n  bool ParameterPack;\n\n  /// Whether this template template parameter is an \"expanded\"\n  /// parameter pack, meaning that it is a pack expansion and we\n  /// already know the set of template parameters that expansion expands to.\n  bool ExpandedParameterPack = false;\n\n  /// The number of parameters in an expanded parameter pack.\n  unsigned NumExpandedParams = 0;\n\n  TemplateTemplateParmDecl(DeclContext *DC, SourceLocation L,\n                           unsigned D, unsigned P, bool ParameterPack,\n                           IdentifierInfo *Id, TemplateParameterList *Params)\n      : TemplateDecl(TemplateTemplateParm, DC, L, Id, Params),\n        TemplateParmPosition(D, P), ParameterPack(ParameterPack) {}\n\n  TemplateTemplateParmDecl(DeclContext *DC, SourceLocation L,\n                           unsigned D, unsigned P,\n                           IdentifierInfo *Id, TemplateParameterList *Params,\n                           ArrayRef<TemplateParameterList *> Expansions);\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend TrailingObjects;\n\n  static TemplateTemplateParmDecl *Create(const ASTContext &C, DeclContext *DC,\n                                          SourceLocation L, unsigned D,\n                                          unsigned P, bool ParameterPack,\n                                          IdentifierInfo *Id,\n                                          TemplateParameterList *Params);\n  static TemplateTemplateParmDecl *Create(const ASTContext &C, DeclContext *DC,\n                                          SourceLocation L, unsigned D,\n                                          unsigned P,\n                                          IdentifierInfo *Id,\n                                          TemplateParameterList *Params,\n                                 ArrayRef<TemplateParameterList *> Expansions);\n\n  static TemplateTemplateParmDecl *CreateDeserialized(ASTContext &C,\n                                                      unsigned ID);\n  static TemplateTemplateParmDecl *CreateDeserialized(ASTContext &C,\n                                                      unsigned ID,\n                                                      unsigned NumExpansions);\n\n  using TemplateParmPosition::getDepth;\n  using TemplateParmPosition::setDepth;\n  using TemplateParmPosition::getPosition;\n  using TemplateParmPosition::setPosition;\n  using TemplateParmPosition::getIndex;\n\n  /// Whether this template template parameter is a template\n  /// parameter pack.\n  ///\n  /// \\code\n  /// template<template <class T> ...MetaFunctions> struct Apply;\n  /// \\endcode\n  bool isParameterPack() const { return ParameterPack; }\n\n  /// Whether this parameter pack is a pack expansion.\n  ///\n  /// A template template parameter pack is a pack expansion if its template\n  /// parameter list contains an unexpanded parameter pack.\n  bool isPackExpansion() const {\n    return ParameterPack &&\n           getTemplateParameters()->containsUnexpandedParameterPack();\n  }\n\n  /// Whether this parameter is a template template parameter pack that\n  /// has a known list of different template parameter lists at different\n  /// positions.\n  ///\n  /// A parameter pack is an expanded parameter pack when the original parameter\n  /// pack's template parameter list was itself a pack expansion, and that\n  /// expansion has already been expanded. For exampe, given:\n  ///\n  /// \\code\n  /// template<typename...Types> struct Outer {\n  ///   template<template<Types> class...Templates> struct Inner;\n  /// };\n  /// \\endcode\n  ///\n  /// The parameter pack \\c Templates is a pack expansion, which expands the\n  /// pack \\c Types. When \\c Types is supplied with template arguments by\n  /// instantiating \\c Outer, the instantiation of \\c Templates is an expanded\n  /// parameter pack.\n  bool isExpandedParameterPack() const { return ExpandedParameterPack; }\n\n  /// Retrieves the number of expansion template parameters in\n  /// an expanded parameter pack.\n  unsigned getNumExpansionTemplateParameters() const {\n    assert(ExpandedParameterPack && \"Not an expansion parameter pack\");\n    return NumExpandedParams;\n  }\n\n  /// Retrieve a particular expansion type within an expanded parameter\n  /// pack.\n  TemplateParameterList *getExpansionTemplateParameters(unsigned I) const {\n    assert(I < NumExpandedParams && \"Out-of-range expansion type index\");\n    return getTrailingObjects<TemplateParameterList *>()[I];\n  }\n\n  const DefArgStorage &getDefaultArgStorage() const { return DefaultArgument; }\n\n  /// Determine whether this template parameter has a default\n  /// argument.\n  bool hasDefaultArgument() const { return DefaultArgument.isSet(); }\n\n  /// Retrieve the default argument, if any.\n  const TemplateArgumentLoc &getDefaultArgument() const {\n    static const TemplateArgumentLoc NoneLoc;\n    return DefaultArgument.isSet() ? *DefaultArgument.get() : NoneLoc;\n  }\n\n  /// Retrieve the location of the default argument, if any.\n  SourceLocation getDefaultArgumentLoc() const;\n\n  /// Determines whether the default argument was inherited\n  /// from a previous declaration of this template.\n  bool defaultArgumentWasInherited() const {\n    return DefaultArgument.isInherited();\n  }\n\n  /// Set the default argument for this template parameter, and\n  /// whether that default argument was inherited from another\n  /// declaration.\n  void setDefaultArgument(const ASTContext &C,\n                          const TemplateArgumentLoc &DefArg);\n  void setInheritedDefaultArgument(const ASTContext &C,\n                                   TemplateTemplateParmDecl *Prev) {\n    DefaultArgument.setInherited(C, Prev);\n  }\n\n  /// Removes the default argument of this template parameter.\n  void removeDefaultArgument() { DefaultArgument.clear(); }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    SourceLocation End = getLocation();\n    if (hasDefaultArgument() && !defaultArgumentWasInherited())\n      End = getDefaultArgument().getSourceRange().getEnd();\n    return SourceRange(getTemplateParameters()->getTemplateLoc(), End);\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == TemplateTemplateParm; }\n};\n\n/// Represents the builtin template declaration which is used to\n/// implement __make_integer_seq and other builtin templates.  It serves\n/// no real purpose beyond existing as a place to hold template parameters.\nclass BuiltinTemplateDecl : public TemplateDecl {\n  BuiltinTemplateKind BTK;\n\n  BuiltinTemplateDecl(const ASTContext &C, DeclContext *DC,\n                      DeclarationName Name, BuiltinTemplateKind BTK);\n\n  void anchor() override;\n\npublic:\n  // Implement isa/cast/dyncast support\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == BuiltinTemplate; }\n\n  static BuiltinTemplateDecl *Create(const ASTContext &C, DeclContext *DC,\n                                     DeclarationName Name,\n                                     BuiltinTemplateKind BTK) {\n    return new (C, DC) BuiltinTemplateDecl(C, DC, Name, BTK);\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return {};\n  }\n\n  BuiltinTemplateKind getBuiltinTemplateKind() const { return BTK; }\n};\n\n/// Represents a class template specialization, which refers to\n/// a class template with a given set of template arguments.\n///\n/// Class template specializations represent both explicit\n/// specialization of class templates, as in the example below, and\n/// implicit instantiations of class templates.\n///\n/// \\code\n/// template<typename T> class array;\n///\n/// template<>\n/// class array<bool> { }; // class template specialization array<bool>\n/// \\endcode\nclass ClassTemplateSpecializationDecl\n  : public CXXRecordDecl, public llvm::FoldingSetNode {\n  /// Structure that stores information about a class template\n  /// specialization that was instantiated from a class template partial\n  /// specialization.\n  struct SpecializedPartialSpecialization {\n    /// The class template partial specialization from which this\n    /// class template specialization was instantiated.\n    ClassTemplatePartialSpecializationDecl *PartialSpecialization;\n\n    /// The template argument list deduced for the class template\n    /// partial specialization itself.\n    const TemplateArgumentList *TemplateArgs;\n  };\n\n  /// The template that this specialization specializes\n  llvm::PointerUnion<ClassTemplateDecl *, SpecializedPartialSpecialization *>\n    SpecializedTemplate;\n\n  /// Further info for explicit template specialization/instantiation.\n  struct ExplicitSpecializationInfo {\n    /// The type-as-written.\n    TypeSourceInfo *TypeAsWritten = nullptr;\n\n    /// The location of the extern keyword.\n    SourceLocation ExternLoc;\n\n    /// The location of the template keyword.\n    SourceLocation TemplateKeywordLoc;\n\n    ExplicitSpecializationInfo() = default;\n  };\n\n  /// Further info for explicit template specialization/instantiation.\n  /// Does not apply to implicit specializations.\n  ExplicitSpecializationInfo *ExplicitInfo = nullptr;\n\n  /// The template arguments used to describe this specialization.\n  const TemplateArgumentList *TemplateArgs;\n\n  /// The point where this template was instantiated (if any)\n  SourceLocation PointOfInstantiation;\n\n  /// The kind of specialization this declaration refers to.\n  /// Really a value of type TemplateSpecializationKind.\n  unsigned SpecializationKind : 3;\n\nprotected:\n  ClassTemplateSpecializationDecl(ASTContext &Context, Kind DK, TagKind TK,\n                                  DeclContext *DC, SourceLocation StartLoc,\n                                  SourceLocation IdLoc,\n                                  ClassTemplateDecl *SpecializedTemplate,\n                                  ArrayRef<TemplateArgument> Args,\n                                  ClassTemplateSpecializationDecl *PrevDecl);\n\n  explicit ClassTemplateSpecializationDecl(ASTContext &C, Kind DK);\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static ClassTemplateSpecializationDecl *\n  Create(ASTContext &Context, TagKind TK, DeclContext *DC,\n         SourceLocation StartLoc, SourceLocation IdLoc,\n         ClassTemplateDecl *SpecializedTemplate,\n         ArrayRef<TemplateArgument> Args,\n         ClassTemplateSpecializationDecl *PrevDecl);\n  static ClassTemplateSpecializationDecl *\n  CreateDeserialized(ASTContext &C, unsigned ID);\n\n  void getNameForDiagnostic(raw_ostream &OS, const PrintingPolicy &Policy,\n                            bool Qualified) const override;\n\n  // FIXME: This is broken. CXXRecordDecl::getMostRecentDecl() returns a\n  // different \"most recent\" declaration from this function for the same\n  // declaration, because we don't override getMostRecentDeclImpl(). But\n  // it's not clear that we should override that, because the most recent\n  // declaration as a CXXRecordDecl sometimes is the injected-class-name.\n  ClassTemplateSpecializationDecl *getMostRecentDecl() {\n    return cast<ClassTemplateSpecializationDecl>(\n        getMostRecentNonInjectedDecl());\n  }\n\n  /// Retrieve the template that this specialization specializes.\n  ClassTemplateDecl *getSpecializedTemplate() const;\n\n  /// Retrieve the template arguments of the class template\n  /// specialization.\n  const TemplateArgumentList &getTemplateArgs() const {\n    return *TemplateArgs;\n  }\n\n  void setTemplateArgs(TemplateArgumentList *Args) {\n    TemplateArgs = Args;\n  }\n\n  /// Determine the kind of specialization that this\n  /// declaration represents.\n  TemplateSpecializationKind getSpecializationKind() const {\n    return static_cast<TemplateSpecializationKind>(SpecializationKind);\n  }\n\n  bool isExplicitSpecialization() const {\n    return getSpecializationKind() == TSK_ExplicitSpecialization;\n  }\n\n  /// Is this an explicit specialization at class scope (within the class that\n  /// owns the primary template)? For example:\n  ///\n  /// \\code\n  /// template<typename T> struct Outer {\n  ///   template<typename U> struct Inner;\n  ///   template<> struct Inner; // class-scope explicit specialization\n  /// };\n  /// \\endcode\n  bool isClassScopeExplicitSpecialization() const {\n    return isExplicitSpecialization() &&\n           isa<CXXRecordDecl>(getLexicalDeclContext());\n  }\n\n  /// True if this declaration is an explicit specialization,\n  /// explicit instantiation declaration, or explicit instantiation\n  /// definition.\n  bool isExplicitInstantiationOrSpecialization() const {\n    return isTemplateExplicitInstantiationOrSpecialization(\n        getTemplateSpecializationKind());\n  }\n\n  void setSpecializedTemplate(ClassTemplateDecl *Specialized) {\n    SpecializedTemplate = Specialized;\n  }\n\n  void setSpecializationKind(TemplateSpecializationKind TSK) {\n    SpecializationKind = TSK;\n  }\n\n  /// Get the point of instantiation (if any), or null if none.\n  SourceLocation getPointOfInstantiation() const {\n    return PointOfInstantiation;\n  }\n\n  void setPointOfInstantiation(SourceLocation Loc) {\n    assert(Loc.isValid() && \"point of instantiation must be valid!\");\n    PointOfInstantiation = Loc;\n  }\n\n  /// If this class template specialization is an instantiation of\n  /// a template (rather than an explicit specialization), return the\n  /// class template or class template partial specialization from which it\n  /// was instantiated.\n  llvm::PointerUnion<ClassTemplateDecl *,\n                     ClassTemplatePartialSpecializationDecl *>\n  getInstantiatedFrom() const {\n    if (!isTemplateInstantiation(getSpecializationKind()))\n      return llvm::PointerUnion<ClassTemplateDecl *,\n                                ClassTemplatePartialSpecializationDecl *>();\n\n    return getSpecializedTemplateOrPartial();\n  }\n\n  /// Retrieve the class template or class template partial\n  /// specialization which was specialized by this.\n  llvm::PointerUnion<ClassTemplateDecl *,\n                     ClassTemplatePartialSpecializationDecl *>\n  getSpecializedTemplateOrPartial() const {\n    if (const auto *PartialSpec =\n            SpecializedTemplate.dyn_cast<SpecializedPartialSpecialization *>())\n      return PartialSpec->PartialSpecialization;\n\n    return SpecializedTemplate.get<ClassTemplateDecl*>();\n  }\n\n  /// Retrieve the set of template arguments that should be used\n  /// to instantiate members of the class template or class template partial\n  /// specialization from which this class template specialization was\n  /// instantiated.\n  ///\n  /// \\returns For a class template specialization instantiated from the primary\n  /// template, this function will return the same template arguments as\n  /// getTemplateArgs(). For a class template specialization instantiated from\n  /// a class template partial specialization, this function will return the\n  /// deduced template arguments for the class template partial specialization\n  /// itself.\n  const TemplateArgumentList &getTemplateInstantiationArgs() const {\n    if (const auto *PartialSpec =\n            SpecializedTemplate.dyn_cast<SpecializedPartialSpecialization *>())\n      return *PartialSpec->TemplateArgs;\n\n    return getTemplateArgs();\n  }\n\n  /// Note that this class template specialization is actually an\n  /// instantiation of the given class template partial specialization whose\n  /// template arguments have been deduced.\n  void setInstantiationOf(ClassTemplatePartialSpecializationDecl *PartialSpec,\n                          const TemplateArgumentList *TemplateArgs) {\n    assert(!SpecializedTemplate.is<SpecializedPartialSpecialization*>() &&\n           \"Already set to a class template partial specialization!\");\n    auto *PS = new (getASTContext()) SpecializedPartialSpecialization();\n    PS->PartialSpecialization = PartialSpec;\n    PS->TemplateArgs = TemplateArgs;\n    SpecializedTemplate = PS;\n  }\n\n  /// Note that this class template specialization is an instantiation\n  /// of the given class template.\n  void setInstantiationOf(ClassTemplateDecl *TemplDecl) {\n    assert(!SpecializedTemplate.is<SpecializedPartialSpecialization*>() &&\n           \"Previously set to a class template partial specialization!\");\n    SpecializedTemplate = TemplDecl;\n  }\n\n  /// Sets the type of this specialization as it was written by\n  /// the user. This will be a class template specialization type.\n  void setTypeAsWritten(TypeSourceInfo *T) {\n    if (!ExplicitInfo)\n      ExplicitInfo = new (getASTContext()) ExplicitSpecializationInfo;\n    ExplicitInfo->TypeAsWritten = T;\n  }\n\n  /// Gets the type of this specialization as it was written by\n  /// the user, if it was so written.\n  TypeSourceInfo *getTypeAsWritten() const {\n    return ExplicitInfo ? ExplicitInfo->TypeAsWritten : nullptr;\n  }\n\n  /// Gets the location of the extern keyword, if present.\n  SourceLocation getExternLoc() const {\n    return ExplicitInfo ? ExplicitInfo->ExternLoc : SourceLocation();\n  }\n\n  /// Sets the location of the extern keyword.\n  void setExternLoc(SourceLocation Loc) {\n    if (!ExplicitInfo)\n      ExplicitInfo = new (getASTContext()) ExplicitSpecializationInfo;\n    ExplicitInfo->ExternLoc = Loc;\n  }\n\n  /// Sets the location of the template keyword.\n  void setTemplateKeywordLoc(SourceLocation Loc) {\n    if (!ExplicitInfo)\n      ExplicitInfo = new (getASTContext()) ExplicitSpecializationInfo;\n    ExplicitInfo->TemplateKeywordLoc = Loc;\n  }\n\n  /// Gets the location of the template keyword, if present.\n  SourceLocation getTemplateKeywordLoc() const {\n    return ExplicitInfo ? ExplicitInfo->TemplateKeywordLoc : SourceLocation();\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    Profile(ID, TemplateArgs->asArray(), getASTContext());\n  }\n\n  static void\n  Profile(llvm::FoldingSetNodeID &ID, ArrayRef<TemplateArgument> TemplateArgs,\n          ASTContext &Context) {\n    ID.AddInteger(TemplateArgs.size());\n    for (const TemplateArgument &TemplateArg : TemplateArgs)\n      TemplateArg.Profile(ID, Context);\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K >= firstClassTemplateSpecialization &&\n           K <= lastClassTemplateSpecialization;\n  }\n};\n\nclass ClassTemplatePartialSpecializationDecl\n  : public ClassTemplateSpecializationDecl {\n  /// The list of template parameters\n  TemplateParameterList* TemplateParams = nullptr;\n\n  /// The source info for the template arguments as written.\n  /// FIXME: redundant with TypeAsWritten?\n  const ASTTemplateArgumentListInfo *ArgsAsWritten = nullptr;\n\n  /// The class template partial specialization from which this\n  /// class template partial specialization was instantiated.\n  ///\n  /// The boolean value will be true to indicate that this class template\n  /// partial specialization was specialized at this level.\n  llvm::PointerIntPair<ClassTemplatePartialSpecializationDecl *, 1, bool>\n      InstantiatedFromMember;\n\n  ClassTemplatePartialSpecializationDecl(ASTContext &Context, TagKind TK,\n                                         DeclContext *DC,\n                                         SourceLocation StartLoc,\n                                         SourceLocation IdLoc,\n                                         TemplateParameterList *Params,\n                                         ClassTemplateDecl *SpecializedTemplate,\n                                         ArrayRef<TemplateArgument> Args,\n                               const ASTTemplateArgumentListInfo *ArgsAsWritten,\n                               ClassTemplatePartialSpecializationDecl *PrevDecl);\n\n  ClassTemplatePartialSpecializationDecl(ASTContext &C)\n    : ClassTemplateSpecializationDecl(C, ClassTemplatePartialSpecialization),\n      InstantiatedFromMember(nullptr, false) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static ClassTemplatePartialSpecializationDecl *\n  Create(ASTContext &Context, TagKind TK, DeclContext *DC,\n         SourceLocation StartLoc, SourceLocation IdLoc,\n         TemplateParameterList *Params,\n         ClassTemplateDecl *SpecializedTemplate,\n         ArrayRef<TemplateArgument> Args,\n         const TemplateArgumentListInfo &ArgInfos,\n         QualType CanonInjectedType,\n         ClassTemplatePartialSpecializationDecl *PrevDecl);\n\n  static ClassTemplatePartialSpecializationDecl *\n  CreateDeserialized(ASTContext &C, unsigned ID);\n\n  ClassTemplatePartialSpecializationDecl *getMostRecentDecl() {\n    return cast<ClassTemplatePartialSpecializationDecl>(\n             static_cast<ClassTemplateSpecializationDecl *>(\n               this)->getMostRecentDecl());\n  }\n\n  /// Get the list of template parameters\n  TemplateParameterList *getTemplateParameters() const {\n    return TemplateParams;\n  }\n\n  /// \\brief All associated constraints of this partial specialization,\n  /// including the requires clause and any constraints derived from\n  /// constrained-parameters.\n  ///\n  /// The constraints in the resulting list are to be treated as if in a\n  /// conjunction (\"and\").\n  void getAssociatedConstraints(llvm::SmallVectorImpl<const Expr *> &AC) const {\n    TemplateParams->getAssociatedConstraints(AC);\n  }\n\n  bool hasAssociatedConstraints() const {\n    return TemplateParams->hasAssociatedConstraints();\n  }\n\n  /// Get the template arguments as written.\n  const ASTTemplateArgumentListInfo *getTemplateArgsAsWritten() const {\n    return ArgsAsWritten;\n  }\n\n  /// Retrieve the member class template partial specialization from\n  /// which this particular class template partial specialization was\n  /// instantiated.\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct Outer {\n  ///   template<typename U> struct Inner;\n  ///   template<typename U> struct Inner<U*> { }; // #1\n  /// };\n  ///\n  /// Outer<float>::Inner<int*> ii;\n  /// \\endcode\n  ///\n  /// In this example, the instantiation of \\c Outer<float>::Inner<int*> will\n  /// end up instantiating the partial specialization\n  /// \\c Outer<float>::Inner<U*>, which itself was instantiated from the class\n  /// template partial specialization \\c Outer<T>::Inner<U*>. Given\n  /// \\c Outer<float>::Inner<U*>, this function would return\n  /// \\c Outer<T>::Inner<U*>.\n  ClassTemplatePartialSpecializationDecl *getInstantiatedFromMember() const {\n    const auto *First =\n        cast<ClassTemplatePartialSpecializationDecl>(getFirstDecl());\n    return First->InstantiatedFromMember.getPointer();\n  }\n  ClassTemplatePartialSpecializationDecl *\n  getInstantiatedFromMemberTemplate() const {\n    return getInstantiatedFromMember();\n  }\n\n  void setInstantiatedFromMember(\n                          ClassTemplatePartialSpecializationDecl *PartialSpec) {\n    auto *First = cast<ClassTemplatePartialSpecializationDecl>(getFirstDecl());\n    First->InstantiatedFromMember.setPointer(PartialSpec);\n  }\n\n  /// Determines whether this class template partial specialization\n  /// template was a specialization of a member partial specialization.\n  ///\n  /// In the following example, the member template partial specialization\n  /// \\c X<int>::Inner<T*> is a member specialization.\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   template<typename U> struct Inner;\n  ///   template<typename U> struct Inner<U*>;\n  /// };\n  ///\n  /// template<> template<typename T>\n  /// struct X<int>::Inner<T*> { /* ... */ };\n  /// \\endcode\n  bool isMemberSpecialization() {\n    const auto *First =\n        cast<ClassTemplatePartialSpecializationDecl>(getFirstDecl());\n    return First->InstantiatedFromMember.getInt();\n  }\n\n  /// Note that this member template is a specialization.\n  void setMemberSpecialization() {\n    auto *First = cast<ClassTemplatePartialSpecializationDecl>(getFirstDecl());\n    assert(First->InstantiatedFromMember.getPointer() &&\n           \"Only member templates can be member template specializations\");\n    return First->InstantiatedFromMember.setInt(true);\n  }\n\n  /// Retrieves the injected specialization type for this partial\n  /// specialization.  This is not the same as the type-decl-type for\n  /// this partial specialization, which is an InjectedClassNameType.\n  QualType getInjectedSpecializationType() const {\n    assert(getTypeForDecl() && \"partial specialization has no type set!\");\n    return cast<InjectedClassNameType>(getTypeForDecl())\n             ->getInjectedSpecializationType();\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    Profile(ID, getTemplateArgs().asArray(), getTemplateParameters(),\n            getASTContext());\n  }\n\n  static void\n  Profile(llvm::FoldingSetNodeID &ID, ArrayRef<TemplateArgument> TemplateArgs,\n          TemplateParameterList *TPL, ASTContext &Context);\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K == ClassTemplatePartialSpecialization;\n  }\n};\n\n/// Declaration of a class template.\nclass ClassTemplateDecl : public RedeclarableTemplateDecl {\nprotected:\n  /// Data that is common to all of the declarations of a given\n  /// class template.\n  struct Common : CommonBase {\n    /// The class template specializations for this class\n    /// template, including explicit specializations and instantiations.\n    llvm::FoldingSetVector<ClassTemplateSpecializationDecl> Specializations;\n\n    /// The class template partial specializations for this class\n    /// template.\n    llvm::FoldingSetVector<ClassTemplatePartialSpecializationDecl>\n      PartialSpecializations;\n\n    /// The injected-class-name type for this class template.\n    QualType InjectedClassNameType;\n\n    Common() = default;\n  };\n\n  /// Retrieve the set of specializations of this class template.\n  llvm::FoldingSetVector<ClassTemplateSpecializationDecl> &\n  getSpecializations() const;\n\n  /// Retrieve the set of partial specializations of this class\n  /// template.\n  llvm::FoldingSetVector<ClassTemplatePartialSpecializationDecl> &\n  getPartialSpecializations() const;\n\n  ClassTemplateDecl(ASTContext &C, DeclContext *DC, SourceLocation L,\n                    DeclarationName Name, TemplateParameterList *Params,\n                    NamedDecl *Decl)\n      : RedeclarableTemplateDecl(ClassTemplate, C, DC, L, Name, Params, Decl) {}\n\n  CommonBase *newCommon(ASTContext &C) const override;\n\n  Common *getCommonPtr() const {\n    return static_cast<Common *>(RedeclarableTemplateDecl::getCommonPtr());\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Load any lazily-loaded specializations from the external source.\n  void LoadLazySpecializations() const;\n\n  /// Get the underlying class declarations of the template.\n  CXXRecordDecl *getTemplatedDecl() const {\n    return static_cast<CXXRecordDecl *>(TemplatedDecl);\n  }\n\n  /// Returns whether this template declaration defines the primary\n  /// class pattern.\n  bool isThisDeclarationADefinition() const {\n    return getTemplatedDecl()->isThisDeclarationADefinition();\n  }\n\n  /// \\brief Create a class template node.\n  static ClassTemplateDecl *Create(ASTContext &C, DeclContext *DC,\n                                   SourceLocation L,\n                                   DeclarationName Name,\n                                   TemplateParameterList *Params,\n                                   NamedDecl *Decl);\n\n  /// Create an empty class template node.\n  static ClassTemplateDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// Return the specialization with the provided arguments if it exists,\n  /// otherwise return the insertion point.\n  ClassTemplateSpecializationDecl *\n  findSpecialization(ArrayRef<TemplateArgument> Args, void *&InsertPos);\n\n  /// Insert the specified specialization knowing that it is not already\n  /// in. InsertPos must be obtained from findSpecialization.\n  void AddSpecialization(ClassTemplateSpecializationDecl *D, void *InsertPos);\n\n  ClassTemplateDecl *getCanonicalDecl() override {\n    return cast<ClassTemplateDecl>(\n             RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n  const ClassTemplateDecl *getCanonicalDecl() const {\n    return cast<ClassTemplateDecl>(\n             RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n\n  /// Retrieve the previous declaration of this class template, or\n  /// nullptr if no such declaration exists.\n  ClassTemplateDecl *getPreviousDecl() {\n    return cast_or_null<ClassTemplateDecl>(\n             static_cast<RedeclarableTemplateDecl *>(this)->getPreviousDecl());\n  }\n  const ClassTemplateDecl *getPreviousDecl() const {\n    return cast_or_null<ClassTemplateDecl>(\n             static_cast<const RedeclarableTemplateDecl *>(\n               this)->getPreviousDecl());\n  }\n\n  ClassTemplateDecl *getMostRecentDecl() {\n    return cast<ClassTemplateDecl>(\n        static_cast<RedeclarableTemplateDecl *>(this)->getMostRecentDecl());\n  }\n  const ClassTemplateDecl *getMostRecentDecl() const {\n    return const_cast<ClassTemplateDecl*>(this)->getMostRecentDecl();\n  }\n\n  ClassTemplateDecl *getInstantiatedFromMemberTemplate() const {\n    return cast_or_null<ClassTemplateDecl>(\n             RedeclarableTemplateDecl::getInstantiatedFromMemberTemplate());\n  }\n\n  /// Return the partial specialization with the provided arguments if it\n  /// exists, otherwise return the insertion point.\n  ClassTemplatePartialSpecializationDecl *\n  findPartialSpecialization(ArrayRef<TemplateArgument> Args,\n                            TemplateParameterList *TPL, void *&InsertPos);\n\n  /// Insert the specified partial specialization knowing that it is not\n  /// already in. InsertPos must be obtained from findPartialSpecialization.\n  void AddPartialSpecialization(ClassTemplatePartialSpecializationDecl *D,\n                                void *InsertPos);\n\n  /// Retrieve the partial specializations as an ordered list.\n  void getPartialSpecializations(\n      SmallVectorImpl<ClassTemplatePartialSpecializationDecl *> &PS) const;\n\n  /// Find a class template partial specialization with the given\n  /// type T.\n  ///\n  /// \\param T a dependent type that names a specialization of this class\n  /// template.\n  ///\n  /// \\returns the class template partial specialization that exactly matches\n  /// the type \\p T, or nullptr if no such partial specialization exists.\n  ClassTemplatePartialSpecializationDecl *findPartialSpecialization(QualType T);\n\n  /// Find a class template partial specialization which was instantiated\n  /// from the given member partial specialization.\n  ///\n  /// \\param D a member class template partial specialization.\n  ///\n  /// \\returns the class template partial specialization which was instantiated\n  /// from the given member partial specialization, or nullptr if no such\n  /// partial specialization exists.\n  ClassTemplatePartialSpecializationDecl *\n  findPartialSpecInstantiatedFromMember(\n                                     ClassTemplatePartialSpecializationDecl *D);\n\n  /// Retrieve the template specialization type of the\n  /// injected-class-name for this class template.\n  ///\n  /// The injected-class-name for a class template \\c X is \\c\n  /// X<template-args>, where \\c template-args is formed from the\n  /// template arguments that correspond to the template parameters of\n  /// \\c X. For example:\n  ///\n  /// \\code\n  /// template<typename T, int N>\n  /// struct array {\n  ///   typedef array this_type; // \"array\" is equivalent to \"array<T, N>\"\n  /// };\n  /// \\endcode\n  QualType getInjectedClassNameSpecialization();\n\n  using spec_iterator = SpecIterator<ClassTemplateSpecializationDecl>;\n  using spec_range = llvm::iterator_range<spec_iterator>;\n\n  spec_range specializations() const {\n    return spec_range(spec_begin(), spec_end());\n  }\n\n  spec_iterator spec_begin() const {\n    return makeSpecIterator(getSpecializations(), false);\n  }\n\n  spec_iterator spec_end() const {\n    return makeSpecIterator(getSpecializations(), true);\n  }\n\n  // Implement isa/cast/dyncast support\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ClassTemplate; }\n};\n\n/// Declaration of a friend template.\n///\n/// For example:\n/// \\code\n/// template \\<typename T> class A {\n///   friend class MyVector<T>; // not a friend template\n///   template \\<typename U> friend class B; // not a friend template\n///   template \\<typename U> friend class Foo<T>::Nested; // friend template\n/// };\n/// \\endcode\n///\n/// \\note This class is not currently in use.  All of the above\n/// will yield a FriendDecl, not a FriendTemplateDecl.\nclass FriendTemplateDecl : public Decl {\n  virtual void anchor();\n\npublic:\n  using FriendUnion = llvm::PointerUnion<NamedDecl *,TypeSourceInfo *>;\n\nprivate:\n  // The number of template parameters;  always non-zero.\n  unsigned NumParams = 0;\n\n  // The parameter list.\n  TemplateParameterList **Params = nullptr;\n\n  // The declaration that's a friend of this class.\n  FriendUnion Friend;\n\n  // Location of the 'friend' specifier.\n  SourceLocation FriendLoc;\n\n  FriendTemplateDecl(DeclContext *DC, SourceLocation Loc,\n                     MutableArrayRef<TemplateParameterList *> Params,\n                     FriendUnion Friend, SourceLocation FriendLoc)\n      : Decl(Decl::FriendTemplate, DC, Loc), NumParams(Params.size()),\n        Params(Params.data()), Friend(Friend), FriendLoc(FriendLoc) {}\n\n  FriendTemplateDecl(EmptyShell Empty) : Decl(Decl::FriendTemplate, Empty) {}\n\npublic:\n  friend class ASTDeclReader;\n\n  static FriendTemplateDecl *\n  Create(ASTContext &Context, DeclContext *DC, SourceLocation Loc,\n         MutableArrayRef<TemplateParameterList *> Params, FriendUnion Friend,\n         SourceLocation FriendLoc);\n\n  static FriendTemplateDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// If this friend declaration names a templated type (or\n  /// a dependent member type of a templated type), return that\n  /// type;  otherwise return null.\n  TypeSourceInfo *getFriendType() const {\n    return Friend.dyn_cast<TypeSourceInfo*>();\n  }\n\n  /// If this friend declaration names a templated function (or\n  /// a member function of a templated type), return that type;\n  /// otherwise return null.\n  NamedDecl *getFriendDecl() const {\n    return Friend.dyn_cast<NamedDecl*>();\n  }\n\n  /// Retrieves the location of the 'friend' keyword.\n  SourceLocation getFriendLoc() const {\n    return FriendLoc;\n  }\n\n  TemplateParameterList *getTemplateParameterList(unsigned i) const {\n    assert(i <= NumParams);\n    return Params[i];\n  }\n\n  unsigned getNumTemplateParameters() const {\n    return NumParams;\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Decl::FriendTemplate; }\n};\n\n/// Declaration of an alias template.\n///\n/// For example:\n/// \\code\n/// template \\<typename T> using V = std::map<T*, int, MyCompare<T>>;\n/// \\endcode\nclass TypeAliasTemplateDecl : public RedeclarableTemplateDecl {\nprotected:\n  using Common = CommonBase;\n\n  TypeAliasTemplateDecl(ASTContext &C, DeclContext *DC, SourceLocation L,\n                        DeclarationName Name, TemplateParameterList *Params,\n                        NamedDecl *Decl)\n      : RedeclarableTemplateDecl(TypeAliasTemplate, C, DC, L, Name, Params,\n                                 Decl) {}\n\n  CommonBase *newCommon(ASTContext &C) const override;\n\n  Common *getCommonPtr() {\n    return static_cast<Common *>(RedeclarableTemplateDecl::getCommonPtr());\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Get the underlying function declaration of the template.\n  TypeAliasDecl *getTemplatedDecl() const {\n    return static_cast<TypeAliasDecl *>(TemplatedDecl);\n  }\n\n\n  TypeAliasTemplateDecl *getCanonicalDecl() override {\n    return cast<TypeAliasTemplateDecl>(\n             RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n  const TypeAliasTemplateDecl *getCanonicalDecl() const {\n    return cast<TypeAliasTemplateDecl>(\n             RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n\n  /// Retrieve the previous declaration of this function template, or\n  /// nullptr if no such declaration exists.\n  TypeAliasTemplateDecl *getPreviousDecl() {\n    return cast_or_null<TypeAliasTemplateDecl>(\n             static_cast<RedeclarableTemplateDecl *>(this)->getPreviousDecl());\n  }\n  const TypeAliasTemplateDecl *getPreviousDecl() const {\n    return cast_or_null<TypeAliasTemplateDecl>(\n             static_cast<const RedeclarableTemplateDecl *>(\n               this)->getPreviousDecl());\n  }\n\n  TypeAliasTemplateDecl *getInstantiatedFromMemberTemplate() const {\n    return cast_or_null<TypeAliasTemplateDecl>(\n             RedeclarableTemplateDecl::getInstantiatedFromMemberTemplate());\n  }\n\n  /// Create a function template node.\n  static TypeAliasTemplateDecl *Create(ASTContext &C, DeclContext *DC,\n                                       SourceLocation L,\n                                       DeclarationName Name,\n                                       TemplateParameterList *Params,\n                                       NamedDecl *Decl);\n\n  /// Create an empty alias template node.\n  static TypeAliasTemplateDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  // Implement isa/cast/dyncast support\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == TypeAliasTemplate; }\n};\n\n/// Declaration of a function specialization at template class scope.\n///\n/// For example:\n/// \\code\n/// template <class T>\n/// class A {\n///    template <class U> void foo(U a) { }\n///    template<> void foo(int a) { }\n/// }\n/// \\endcode\n///\n/// \"template<> foo(int a)\" will be saved in Specialization as a normal\n/// CXXMethodDecl. Then during an instantiation of class A, it will be\n/// transformed into an actual function specialization.\n///\n/// FIXME: This is redundant; we could store the same information directly on\n/// the CXXMethodDecl as a DependentFunctionTemplateSpecializationInfo.\nclass ClassScopeFunctionSpecializationDecl : public Decl {\n  CXXMethodDecl *Specialization;\n  const ASTTemplateArgumentListInfo *TemplateArgs;\n\n  ClassScopeFunctionSpecializationDecl(\n      DeclContext *DC, SourceLocation Loc, CXXMethodDecl *FD,\n      const ASTTemplateArgumentListInfo *TemplArgs)\n      : Decl(Decl::ClassScopeFunctionSpecialization, DC, Loc),\n        Specialization(FD), TemplateArgs(TemplArgs) {}\n\n  ClassScopeFunctionSpecializationDecl(EmptyShell Empty)\n      : Decl(Decl::ClassScopeFunctionSpecialization, Empty) {}\n\n  virtual void anchor();\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  CXXMethodDecl *getSpecialization() const { return Specialization; }\n  bool hasExplicitTemplateArgs() const { return TemplateArgs; }\n  const ASTTemplateArgumentListInfo *getTemplateArgsAsWritten() const {\n    return TemplateArgs;\n  }\n\n  static ClassScopeFunctionSpecializationDecl *\n  Create(ASTContext &C, DeclContext *DC, SourceLocation Loc, CXXMethodDecl *FD,\n         bool HasExplicitTemplateArgs,\n         const TemplateArgumentListInfo &TemplateArgs) {\n    return new (C, DC) ClassScopeFunctionSpecializationDecl(\n        DC, Loc, FD,\n        HasExplicitTemplateArgs\n            ? ASTTemplateArgumentListInfo::Create(C, TemplateArgs)\n            : nullptr);\n  }\n\n  static ClassScopeFunctionSpecializationDecl *\n  CreateDeserialized(ASTContext &Context, unsigned ID);\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K == Decl::ClassScopeFunctionSpecialization;\n  }\n};\n\n/// Represents a variable template specialization, which refers to\n/// a variable template with a given set of template arguments.\n///\n/// Variable template specializations represent both explicit\n/// specializations of variable templates, as in the example below, and\n/// implicit instantiations of variable templates.\n///\n/// \\code\n/// template<typename T> constexpr T pi = T(3.1415926535897932385);\n///\n/// template<>\n/// constexpr float pi<float>; // variable template specialization pi<float>\n/// \\endcode\nclass VarTemplateSpecializationDecl : public VarDecl,\n                                      public llvm::FoldingSetNode {\n\n  /// Structure that stores information about a variable template\n  /// specialization that was instantiated from a variable template partial\n  /// specialization.\n  struct SpecializedPartialSpecialization {\n    /// The variable template partial specialization from which this\n    /// variable template specialization was instantiated.\n    VarTemplatePartialSpecializationDecl *PartialSpecialization;\n\n    /// The template argument list deduced for the variable template\n    /// partial specialization itself.\n    const TemplateArgumentList *TemplateArgs;\n  };\n\n  /// The template that this specialization specializes.\n  llvm::PointerUnion<VarTemplateDecl *, SpecializedPartialSpecialization *>\n  SpecializedTemplate;\n\n  /// Further info for explicit template specialization/instantiation.\n  struct ExplicitSpecializationInfo {\n    /// The type-as-written.\n    TypeSourceInfo *TypeAsWritten = nullptr;\n\n    /// The location of the extern keyword.\n    SourceLocation ExternLoc;\n\n    /// The location of the template keyword.\n    SourceLocation TemplateKeywordLoc;\n\n    ExplicitSpecializationInfo() = default;\n  };\n\n  /// Further info for explicit template specialization/instantiation.\n  /// Does not apply to implicit specializations.\n  ExplicitSpecializationInfo *ExplicitInfo = nullptr;\n\n  /// The template arguments used to describe this specialization.\n  const TemplateArgumentList *TemplateArgs;\n  TemplateArgumentListInfo TemplateArgsInfo;\n\n  /// The point where this template was instantiated (if any).\n  SourceLocation PointOfInstantiation;\n\n  /// The kind of specialization this declaration refers to.\n  /// Really a value of type TemplateSpecializationKind.\n  unsigned SpecializationKind : 3;\n\n  /// Whether this declaration is a complete definition of the\n  /// variable template specialization. We can't otherwise tell apart\n  /// an instantiated declaration from an instantiated definition with\n  /// no initializer.\n  unsigned IsCompleteDefinition : 1;\n\nprotected:\n  VarTemplateSpecializationDecl(Kind DK, ASTContext &Context, DeclContext *DC,\n                                SourceLocation StartLoc, SourceLocation IdLoc,\n                                VarTemplateDecl *SpecializedTemplate,\n                                QualType T, TypeSourceInfo *TInfo,\n                                StorageClass S,\n                                ArrayRef<TemplateArgument> Args);\n\n  explicit VarTemplateSpecializationDecl(Kind DK, ASTContext &Context);\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend class VarDecl;\n\n  static VarTemplateSpecializationDecl *\n  Create(ASTContext &Context, DeclContext *DC, SourceLocation StartLoc,\n         SourceLocation IdLoc, VarTemplateDecl *SpecializedTemplate, QualType T,\n         TypeSourceInfo *TInfo, StorageClass S,\n         ArrayRef<TemplateArgument> Args);\n  static VarTemplateSpecializationDecl *CreateDeserialized(ASTContext &C,\n                                                           unsigned ID);\n\n  void getNameForDiagnostic(raw_ostream &OS, const PrintingPolicy &Policy,\n                            bool Qualified) const override;\n\n  VarTemplateSpecializationDecl *getMostRecentDecl() {\n    VarDecl *Recent = static_cast<VarDecl *>(this)->getMostRecentDecl();\n    return cast<VarTemplateSpecializationDecl>(Recent);\n  }\n\n  /// Retrieve the template that this specialization specializes.\n  VarTemplateDecl *getSpecializedTemplate() const;\n\n  /// Retrieve the template arguments of the variable template\n  /// specialization.\n  const TemplateArgumentList &getTemplateArgs() const { return *TemplateArgs; }\n\n  // TODO: Always set this when creating the new specialization?\n  void setTemplateArgsInfo(const TemplateArgumentListInfo &ArgsInfo);\n\n  const TemplateArgumentListInfo &getTemplateArgsInfo() const {\n    return TemplateArgsInfo;\n  }\n\n  /// Determine the kind of specialization that this\n  /// declaration represents.\n  TemplateSpecializationKind getSpecializationKind() const {\n    return static_cast<TemplateSpecializationKind>(SpecializationKind);\n  }\n\n  bool isExplicitSpecialization() const {\n    return getSpecializationKind() == TSK_ExplicitSpecialization;\n  }\n\n  bool isClassScopeExplicitSpecialization() const {\n    return isExplicitSpecialization() &&\n           isa<CXXRecordDecl>(getLexicalDeclContext());\n  }\n\n  /// True if this declaration is an explicit specialization,\n  /// explicit instantiation declaration, or explicit instantiation\n  /// definition.\n  bool isExplicitInstantiationOrSpecialization() const {\n    return isTemplateExplicitInstantiationOrSpecialization(\n        getTemplateSpecializationKind());\n  }\n\n  void setSpecializationKind(TemplateSpecializationKind TSK) {\n    SpecializationKind = TSK;\n  }\n\n  /// Get the point of instantiation (if any), or null if none.\n  SourceLocation getPointOfInstantiation() const {\n    return PointOfInstantiation;\n  }\n\n  void setPointOfInstantiation(SourceLocation Loc) {\n    assert(Loc.isValid() && \"point of instantiation must be valid!\");\n    PointOfInstantiation = Loc;\n  }\n\n  void setCompleteDefinition() { IsCompleteDefinition = true; }\n\n  /// If this variable template specialization is an instantiation of\n  /// a template (rather than an explicit specialization), return the\n  /// variable template or variable template partial specialization from which\n  /// it was instantiated.\n  llvm::PointerUnion<VarTemplateDecl *, VarTemplatePartialSpecializationDecl *>\n  getInstantiatedFrom() const {\n    if (!isTemplateInstantiation(getSpecializationKind()))\n      return llvm::PointerUnion<VarTemplateDecl *,\n                                VarTemplatePartialSpecializationDecl *>();\n\n    return getSpecializedTemplateOrPartial();\n  }\n\n  /// Retrieve the variable template or variable template partial\n  /// specialization which was specialized by this.\n  llvm::PointerUnion<VarTemplateDecl *, VarTemplatePartialSpecializationDecl *>\n  getSpecializedTemplateOrPartial() const {\n    if (const auto *PartialSpec =\n            SpecializedTemplate.dyn_cast<SpecializedPartialSpecialization *>())\n      return PartialSpec->PartialSpecialization;\n\n    return SpecializedTemplate.get<VarTemplateDecl *>();\n  }\n\n  /// Retrieve the set of template arguments that should be used\n  /// to instantiate the initializer of the variable template or variable\n  /// template partial specialization from which this variable template\n  /// specialization was instantiated.\n  ///\n  /// \\returns For a variable template specialization instantiated from the\n  /// primary template, this function will return the same template arguments\n  /// as getTemplateArgs(). For a variable template specialization instantiated\n  /// from a variable template partial specialization, this function will the\n  /// return deduced template arguments for the variable template partial\n  /// specialization itself.\n  const TemplateArgumentList &getTemplateInstantiationArgs() const {\n    if (const auto *PartialSpec =\n            SpecializedTemplate.dyn_cast<SpecializedPartialSpecialization *>())\n      return *PartialSpec->TemplateArgs;\n\n    return getTemplateArgs();\n  }\n\n  /// Note that this variable template specialization is actually an\n  /// instantiation of the given variable template partial specialization whose\n  /// template arguments have been deduced.\n  void setInstantiationOf(VarTemplatePartialSpecializationDecl *PartialSpec,\n                          const TemplateArgumentList *TemplateArgs) {\n    assert(!SpecializedTemplate.is<SpecializedPartialSpecialization *>() &&\n           \"Already set to a variable template partial specialization!\");\n    auto *PS = new (getASTContext()) SpecializedPartialSpecialization();\n    PS->PartialSpecialization = PartialSpec;\n    PS->TemplateArgs = TemplateArgs;\n    SpecializedTemplate = PS;\n  }\n\n  /// Note that this variable template specialization is an instantiation\n  /// of the given variable template.\n  void setInstantiationOf(VarTemplateDecl *TemplDecl) {\n    assert(!SpecializedTemplate.is<SpecializedPartialSpecialization *>() &&\n           \"Previously set to a variable template partial specialization!\");\n    SpecializedTemplate = TemplDecl;\n  }\n\n  /// Sets the type of this specialization as it was written by\n  /// the user.\n  void setTypeAsWritten(TypeSourceInfo *T) {\n    if (!ExplicitInfo)\n      ExplicitInfo = new (getASTContext()) ExplicitSpecializationInfo;\n    ExplicitInfo->TypeAsWritten = T;\n  }\n\n  /// Gets the type of this specialization as it was written by\n  /// the user, if it was so written.\n  TypeSourceInfo *getTypeAsWritten() const {\n    return ExplicitInfo ? ExplicitInfo->TypeAsWritten : nullptr;\n  }\n\n  /// Gets the location of the extern keyword, if present.\n  SourceLocation getExternLoc() const {\n    return ExplicitInfo ? ExplicitInfo->ExternLoc : SourceLocation();\n  }\n\n  /// Sets the location of the extern keyword.\n  void setExternLoc(SourceLocation Loc) {\n    if (!ExplicitInfo)\n      ExplicitInfo = new (getASTContext()) ExplicitSpecializationInfo;\n    ExplicitInfo->ExternLoc = Loc;\n  }\n\n  /// Sets the location of the template keyword.\n  void setTemplateKeywordLoc(SourceLocation Loc) {\n    if (!ExplicitInfo)\n      ExplicitInfo = new (getASTContext()) ExplicitSpecializationInfo;\n    ExplicitInfo->TemplateKeywordLoc = Loc;\n  }\n\n  /// Gets the location of the template keyword, if present.\n  SourceLocation getTemplateKeywordLoc() const {\n    return ExplicitInfo ? ExplicitInfo->TemplateKeywordLoc : SourceLocation();\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    Profile(ID, TemplateArgs->asArray(), getASTContext());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      ArrayRef<TemplateArgument> TemplateArgs,\n                      ASTContext &Context) {\n    ID.AddInteger(TemplateArgs.size());\n    for (const TemplateArgument &TemplateArg : TemplateArgs)\n      TemplateArg.Profile(ID, Context);\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K >= firstVarTemplateSpecialization &&\n           K <= lastVarTemplateSpecialization;\n  }\n};\n\nclass VarTemplatePartialSpecializationDecl\n    : public VarTemplateSpecializationDecl {\n  /// The list of template parameters\n  TemplateParameterList *TemplateParams = nullptr;\n\n  /// The source info for the template arguments as written.\n  /// FIXME: redundant with TypeAsWritten?\n  const ASTTemplateArgumentListInfo *ArgsAsWritten = nullptr;\n\n  /// The variable template partial specialization from which this\n  /// variable template partial specialization was instantiated.\n  ///\n  /// The boolean value will be true to indicate that this variable template\n  /// partial specialization was specialized at this level.\n  llvm::PointerIntPair<VarTemplatePartialSpecializationDecl *, 1, bool>\n  InstantiatedFromMember;\n\n  VarTemplatePartialSpecializationDecl(\n      ASTContext &Context, DeclContext *DC, SourceLocation StartLoc,\n      SourceLocation IdLoc, TemplateParameterList *Params,\n      VarTemplateDecl *SpecializedTemplate, QualType T, TypeSourceInfo *TInfo,\n      StorageClass S, ArrayRef<TemplateArgument> Args,\n      const ASTTemplateArgumentListInfo *ArgInfos);\n\n  VarTemplatePartialSpecializationDecl(ASTContext &Context)\n      : VarTemplateSpecializationDecl(VarTemplatePartialSpecialization,\n                                      Context),\n        InstantiatedFromMember(nullptr, false) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static VarTemplatePartialSpecializationDecl *\n  Create(ASTContext &Context, DeclContext *DC, SourceLocation StartLoc,\n         SourceLocation IdLoc, TemplateParameterList *Params,\n         VarTemplateDecl *SpecializedTemplate, QualType T,\n         TypeSourceInfo *TInfo, StorageClass S, ArrayRef<TemplateArgument> Args,\n         const TemplateArgumentListInfo &ArgInfos);\n\n  static VarTemplatePartialSpecializationDecl *CreateDeserialized(ASTContext &C,\n                                                                  unsigned ID);\n\n  VarTemplatePartialSpecializationDecl *getMostRecentDecl() {\n    return cast<VarTemplatePartialSpecializationDecl>(\n             static_cast<VarTemplateSpecializationDecl *>(\n               this)->getMostRecentDecl());\n  }\n\n  /// Get the list of template parameters\n  TemplateParameterList *getTemplateParameters() const {\n    return TemplateParams;\n  }\n\n  /// Get the template arguments as written.\n  const ASTTemplateArgumentListInfo *getTemplateArgsAsWritten() const {\n    return ArgsAsWritten;\n  }\n\n  /// \\brief All associated constraints of this partial specialization,\n  /// including the requires clause and any constraints derived from\n  /// constrained-parameters.\n  ///\n  /// The constraints in the resulting list are to be treated as if in a\n  /// conjunction (\"and\").\n  void getAssociatedConstraints(llvm::SmallVectorImpl<const Expr *> &AC) const {\n    TemplateParams->getAssociatedConstraints(AC);\n  }\n\n  bool hasAssociatedConstraints() const {\n    return TemplateParams->hasAssociatedConstraints();\n  }\n\n  /// \\brief Retrieve the member variable template partial specialization from\n  /// which this particular variable template partial specialization was\n  /// instantiated.\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct Outer {\n  ///   template<typename U> U Inner;\n  ///   template<typename U> U* Inner<U*> = (U*)(0); // #1\n  /// };\n  ///\n  /// template int* Outer<float>::Inner<int*>;\n  /// \\endcode\n  ///\n  /// In this example, the instantiation of \\c Outer<float>::Inner<int*> will\n  /// end up instantiating the partial specialization\n  /// \\c Outer<float>::Inner<U*>, which itself was instantiated from the\n  /// variable template partial specialization \\c Outer<T>::Inner<U*>. Given\n  /// \\c Outer<float>::Inner<U*>, this function would return\n  /// \\c Outer<T>::Inner<U*>.\n  VarTemplatePartialSpecializationDecl *getInstantiatedFromMember() const {\n    const auto *First =\n        cast<VarTemplatePartialSpecializationDecl>(getFirstDecl());\n    return First->InstantiatedFromMember.getPointer();\n  }\n\n  void\n  setInstantiatedFromMember(VarTemplatePartialSpecializationDecl *PartialSpec) {\n    auto *First = cast<VarTemplatePartialSpecializationDecl>(getFirstDecl());\n    First->InstantiatedFromMember.setPointer(PartialSpec);\n  }\n\n  /// Determines whether this variable template partial specialization\n  /// was a specialization of a member partial specialization.\n  ///\n  /// In the following example, the member template partial specialization\n  /// \\c X<int>::Inner<T*> is a member specialization.\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   template<typename U> U Inner;\n  ///   template<typename U> U* Inner<U*> = (U*)(0);\n  /// };\n  ///\n  /// template<> template<typename T>\n  /// U* X<int>::Inner<T*> = (T*)(0) + 1;\n  /// \\endcode\n  bool isMemberSpecialization() {\n    const auto *First =\n        cast<VarTemplatePartialSpecializationDecl>(getFirstDecl());\n    return First->InstantiatedFromMember.getInt();\n  }\n\n  /// Note that this member template is a specialization.\n  void setMemberSpecialization() {\n    auto *First = cast<VarTemplatePartialSpecializationDecl>(getFirstDecl());\n    assert(First->InstantiatedFromMember.getPointer() &&\n           \"Only member templates can be member template specializations\");\n    return First->InstantiatedFromMember.setInt(true);\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    Profile(ID, getTemplateArgs().asArray(), getTemplateParameters(),\n            getASTContext());\n  }\n\n  static void\n  Profile(llvm::FoldingSetNodeID &ID, ArrayRef<TemplateArgument> TemplateArgs,\n          TemplateParameterList *TPL, ASTContext &Context);\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K == VarTemplatePartialSpecialization;\n  }\n};\n\n/// Declaration of a variable template.\nclass VarTemplateDecl : public RedeclarableTemplateDecl {\nprotected:\n  /// Data that is common to all of the declarations of a given\n  /// variable template.\n  struct Common : CommonBase {\n    /// The variable template specializations for this variable\n    /// template, including explicit specializations and instantiations.\n    llvm::FoldingSetVector<VarTemplateSpecializationDecl> Specializations;\n\n    /// The variable template partial specializations for this variable\n    /// template.\n    llvm::FoldingSetVector<VarTemplatePartialSpecializationDecl>\n    PartialSpecializations;\n\n    Common() = default;\n  };\n\n  /// Retrieve the set of specializations of this variable template.\n  llvm::FoldingSetVector<VarTemplateSpecializationDecl> &\n  getSpecializations() const;\n\n  /// Retrieve the set of partial specializations of this class\n  /// template.\n  llvm::FoldingSetVector<VarTemplatePartialSpecializationDecl> &\n  getPartialSpecializations() const;\n\n  VarTemplateDecl(ASTContext &C, DeclContext *DC, SourceLocation L,\n                  DeclarationName Name, TemplateParameterList *Params,\n                  NamedDecl *Decl)\n      : RedeclarableTemplateDecl(VarTemplate, C, DC, L, Name, Params, Decl) {}\n\n  CommonBase *newCommon(ASTContext &C) const override;\n\n  Common *getCommonPtr() const {\n    return static_cast<Common *>(RedeclarableTemplateDecl::getCommonPtr());\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Load any lazily-loaded specializations from the external source.\n  void LoadLazySpecializations() const;\n\n  /// Get the underlying variable declarations of the template.\n  VarDecl *getTemplatedDecl() const {\n    return static_cast<VarDecl *>(TemplatedDecl);\n  }\n\n  /// Returns whether this template declaration defines the primary\n  /// variable pattern.\n  bool isThisDeclarationADefinition() const {\n    return getTemplatedDecl()->isThisDeclarationADefinition();\n  }\n\n  VarTemplateDecl *getDefinition();\n\n  /// Create a variable template node.\n  static VarTemplateDecl *Create(ASTContext &C, DeclContext *DC,\n                                 SourceLocation L, DeclarationName Name,\n                                 TemplateParameterList *Params,\n                                 VarDecl *Decl);\n\n  /// Create an empty variable template node.\n  static VarTemplateDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// Return the specialization with the provided arguments if it exists,\n  /// otherwise return the insertion point.\n  VarTemplateSpecializationDecl *\n  findSpecialization(ArrayRef<TemplateArgument> Args, void *&InsertPos);\n\n  /// Insert the specified specialization knowing that it is not already\n  /// in. InsertPos must be obtained from findSpecialization.\n  void AddSpecialization(VarTemplateSpecializationDecl *D, void *InsertPos);\n\n  VarTemplateDecl *getCanonicalDecl() override {\n    return cast<VarTemplateDecl>(RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n  const VarTemplateDecl *getCanonicalDecl() const {\n    return cast<VarTemplateDecl>(RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n\n  /// Retrieve the previous declaration of this variable template, or\n  /// nullptr if no such declaration exists.\n  VarTemplateDecl *getPreviousDecl() {\n    return cast_or_null<VarTemplateDecl>(\n        static_cast<RedeclarableTemplateDecl *>(this)->getPreviousDecl());\n  }\n  const VarTemplateDecl *getPreviousDecl() const {\n    return cast_or_null<VarTemplateDecl>(\n            static_cast<const RedeclarableTemplateDecl *>(\n              this)->getPreviousDecl());\n  }\n\n  VarTemplateDecl *getMostRecentDecl() {\n    return cast<VarTemplateDecl>(\n        static_cast<RedeclarableTemplateDecl *>(this)->getMostRecentDecl());\n  }\n  const VarTemplateDecl *getMostRecentDecl() const {\n    return const_cast<VarTemplateDecl *>(this)->getMostRecentDecl();\n  }\n\n  VarTemplateDecl *getInstantiatedFromMemberTemplate() const {\n    return cast_or_null<VarTemplateDecl>(\n        RedeclarableTemplateDecl::getInstantiatedFromMemberTemplate());\n  }\n\n  /// Return the partial specialization with the provided arguments if it\n  /// exists, otherwise return the insertion point.\n  VarTemplatePartialSpecializationDecl *\n  findPartialSpecialization(ArrayRef<TemplateArgument> Args,\n                            TemplateParameterList *TPL, void *&InsertPos);\n\n  /// Insert the specified partial specialization knowing that it is not\n  /// already in. InsertPos must be obtained from findPartialSpecialization.\n  void AddPartialSpecialization(VarTemplatePartialSpecializationDecl *D,\n                                void *InsertPos);\n\n  /// Retrieve the partial specializations as an ordered list.\n  void getPartialSpecializations(\n      SmallVectorImpl<VarTemplatePartialSpecializationDecl *> &PS) const;\n\n  /// Find a variable template partial specialization which was\n  /// instantiated\n  /// from the given member partial specialization.\n  ///\n  /// \\param D a member variable template partial specialization.\n  ///\n  /// \\returns the variable template partial specialization which was\n  /// instantiated\n  /// from the given member partial specialization, or nullptr if no such\n  /// partial specialization exists.\n  VarTemplatePartialSpecializationDecl *findPartialSpecInstantiatedFromMember(\n      VarTemplatePartialSpecializationDecl *D);\n\n  using spec_iterator = SpecIterator<VarTemplateSpecializationDecl>;\n  using spec_range = llvm::iterator_range<spec_iterator>;\n\n  spec_range specializations() const {\n    return spec_range(spec_begin(), spec_end());\n  }\n\n  spec_iterator spec_begin() const {\n    return makeSpecIterator(getSpecializations(), false);\n  }\n\n  spec_iterator spec_end() const {\n    return makeSpecIterator(getSpecializations(), true);\n  }\n\n  // Implement isa/cast/dyncast support\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == VarTemplate; }\n};\n\n/// Declaration of a C++2a concept.\nclass ConceptDecl : public TemplateDecl, public Mergeable<ConceptDecl> {\nprotected:\n  Expr *ConstraintExpr;\n\n  ConceptDecl(DeclContext *DC, SourceLocation L, DeclarationName Name,\n              TemplateParameterList *Params, Expr *ConstraintExpr)\n      : TemplateDecl(Concept, DC, L, Name, Params),\n        ConstraintExpr(ConstraintExpr) {};\npublic:\n  static ConceptDecl *Create(ASTContext &C, DeclContext *DC,\n                             SourceLocation L, DeclarationName Name,\n                             TemplateParameterList *Params,\n                             Expr *ConstraintExpr);\n  static ConceptDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  Expr *getConstraintExpr() const {\n    return ConstraintExpr;\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(getTemplateParameters()->getTemplateLoc(),\n                       ConstraintExpr->getEndLoc());\n  }\n\n  bool isTypeConcept() const {\n    return isa<TemplateTypeParmDecl>(getTemplateParameters()->getParam(0));\n  }\n\n  ConceptDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const ConceptDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Concept; }\n\n  friend class ASTReader;\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n};\n\n/// A template parameter object.\n///\n/// Template parameter objects represent values of class type used as template\n/// arguments. There is one template parameter object for each such distinct\n/// value used as a template argument across the program.\n///\n/// \\code\n/// struct A { int x, y; };\n/// template<A> struct S;\n/// S<A{1, 2}> s1;\n/// S<A{1, 2}> s2; // same type, argument is same TemplateParamObjectDecl.\n/// \\endcode\nclass TemplateParamObjectDecl : public ValueDecl,\n                                public Mergeable<TemplateParamObjectDecl>,\n                                public llvm::FoldingSetNode {\nprivate:\n  /// The value of this template parameter object.\n  APValue Value;\n\n  TemplateParamObjectDecl(DeclContext *DC, QualType T, const APValue &V)\n      : ValueDecl(TemplateParamObject, DC, SourceLocation(), DeclarationName(),\n                  T),\n        Value(V) {}\n\n  static TemplateParamObjectDecl *Create(const ASTContext &C, QualType T,\n                                         const APValue &V);\n  static TemplateParamObjectDecl *CreateDeserialized(ASTContext &C,\n                                                     unsigned ID);\n\n  /// Only ASTContext::getTemplateParamObjectDecl and deserialization\n  /// create these.\n  friend class ASTContext;\n  friend class ASTReader;\n  friend class ASTDeclReader;\n\npublic:\n  /// Print this template parameter object in a human-readable format.\n  void printName(llvm::raw_ostream &OS) const override;\n\n  /// Print this object as an equivalent expression.\n  void printAsExpr(llvm::raw_ostream &OS) const;\n\n  /// Print this object as an initializer suitable for a variable of the\n  /// object's type.\n  void printAsInit(llvm::raw_ostream &OS) const;\n\n  const APValue &getValue() const { return Value; }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType T,\n                      const APValue &V) {\n    ID.AddPointer(T.getCanonicalType().getAsOpaquePtr());\n    V.Profile(ID);\n  }\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getType(), getValue());\n  }\n\n  TemplateParamObjectDecl *getCanonicalDecl() override {\n    return getFirstDecl();\n  }\n  const TemplateParamObjectDecl *getCanonicalDecl() const {\n    return getFirstDecl();\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == TemplateParamObject; }\n};\n\ninline NamedDecl *getAsNamedDecl(TemplateParameter P) {\n  if (auto *PD = P.dyn_cast<TemplateTypeParmDecl *>())\n    return PD;\n  if (auto *PD = P.dyn_cast<NonTypeTemplateParmDecl *>())\n    return PD;\n  return P.get<TemplateTemplateParmDecl *>();\n}\n\ninline TemplateDecl *getAsTypeTemplateDecl(Decl *D) {\n  auto *TD = dyn_cast<TemplateDecl>(D);\n  return TD && (isa<ClassTemplateDecl>(TD) ||\n                isa<ClassTemplatePartialSpecializationDecl>(TD) ||\n                isa<TypeAliasTemplateDecl>(TD) ||\n                isa<TemplateTemplateParmDecl>(TD))\n             ? TD\n             : nullptr;\n}\n\n/// Check whether the template parameter is a pack expansion, and if so,\n/// determine the number of parameters produced by that expansion. For instance:\n///\n/// \\code\n/// template<typename ...Ts> struct A {\n///   template<Ts ...NTs, template<Ts> class ...TTs, typename ...Us> struct B;\n/// };\n/// \\endcode\n///\n/// In \\c A<int,int>::B, \\c NTs and \\c TTs have expanded pack size 2, and \\c Us\n/// is not a pack expansion, so returns an empty Optional.\ninline Optional<unsigned> getExpandedPackSize(const NamedDecl *Param) {\n  if (const auto *TTP = dyn_cast<TemplateTypeParmDecl>(Param)) {\n    if (TTP->isExpandedParameterPack())\n      return TTP->getNumExpansionParameters();\n  }\n\n  if (const auto *NTTP = dyn_cast<NonTypeTemplateParmDecl>(Param)) {\n    if (NTTP->isExpandedParameterPack())\n      return NTTP->getNumExpansionTypes();\n  }\n\n  if (const auto *TTP = dyn_cast<TemplateTemplateParmDecl>(Param)) {\n    if (TTP->isExpandedParameterPack())\n      return TTP->getNumExpansionTemplateParameters();\n  }\n\n  return None;\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_DECLTEMPLATE_H\n"}, "34": {"id": 34, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "content": "//===--- Expr.h - Classes for representing expressions ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the Expr interface and subclasses.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_EXPR_H\n#define LLVM_CLANG_AST_EXPR_H\n\n#include \"clang/AST/APValue.h\"\n#include \"clang/AST/ASTVector.h\"\n#include \"clang/AST/ComputeDependence.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclAccessPair.h\"\n#include \"clang/AST/DependenceFlags.h\"\n#include \"clang/AST/OperationKinds.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/TemplateBase.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/CharInfo.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/SyncScope.h\"\n#include \"clang/Basic/TypeTraits.h\"\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/AtomicOrdering.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n\nnamespace clang {\n  class APValue;\n  class ASTContext;\n  class BlockDecl;\n  class CXXBaseSpecifier;\n  class CXXMemberCallExpr;\n  class CXXOperatorCallExpr;\n  class CastExpr;\n  class Decl;\n  class IdentifierInfo;\n  class MaterializeTemporaryExpr;\n  class NamedDecl;\n  class ObjCPropertyRefExpr;\n  class OpaqueValueExpr;\n  class ParmVarDecl;\n  class StringLiteral;\n  class TargetInfo;\n  class ValueDecl;\n\n/// A simple array of base specifiers.\ntypedef SmallVector<CXXBaseSpecifier*, 4> CXXCastPath;\n\n/// An adjustment to be made to the temporary created when emitting a\n/// reference binding, which accesses a particular subobject of that temporary.\nstruct SubobjectAdjustment {\n  enum {\n    DerivedToBaseAdjustment,\n    FieldAdjustment,\n    MemberPointerAdjustment\n  } Kind;\n\n  struct DTB {\n    const CastExpr *BasePath;\n    const CXXRecordDecl *DerivedClass;\n  };\n\n  struct P {\n    const MemberPointerType *MPT;\n    Expr *RHS;\n  };\n\n  union {\n    struct DTB DerivedToBase;\n    FieldDecl *Field;\n    struct P Ptr;\n  };\n\n  SubobjectAdjustment(const CastExpr *BasePath,\n                      const CXXRecordDecl *DerivedClass)\n    : Kind(DerivedToBaseAdjustment) {\n    DerivedToBase.BasePath = BasePath;\n    DerivedToBase.DerivedClass = DerivedClass;\n  }\n\n  SubobjectAdjustment(FieldDecl *Field)\n    : Kind(FieldAdjustment) {\n    this->Field = Field;\n  }\n\n  SubobjectAdjustment(const MemberPointerType *MPT, Expr *RHS)\n    : Kind(MemberPointerAdjustment) {\n    this->Ptr.MPT = MPT;\n    this->Ptr.RHS = RHS;\n  }\n};\n\n/// This represents one expression.  Note that Expr's are subclasses of Stmt.\n/// This allows an expression to be transparently used any place a Stmt is\n/// required.\nclass Expr : public ValueStmt {\n  QualType TR;\n\npublic:\n  Expr() = delete;\n  Expr(const Expr&) = delete;\n  Expr(Expr &&) = delete;\n  Expr &operator=(const Expr&) = delete;\n  Expr &operator=(Expr&&) = delete;\n\nprotected:\n  Expr(StmtClass SC, QualType T, ExprValueKind VK, ExprObjectKind OK)\n      : ValueStmt(SC) {\n    ExprBits.Dependent = 0;\n    ExprBits.ValueKind = VK;\n    ExprBits.ObjectKind = OK;\n    assert(ExprBits.ObjectKind == OK && \"truncated kind\");\n    setType(T);\n  }\n\n  /// Construct an empty expression.\n  explicit Expr(StmtClass SC, EmptyShell) : ValueStmt(SC) { }\n\n  /// Each concrete expr subclass is expected to compute its dependence and call\n  /// this in the constructor.\n  void setDependence(ExprDependence Deps) {\n    ExprBits.Dependent = static_cast<unsigned>(Deps);\n  }\n  friend class ASTImporter; // Sets dependence dircetly.\n  friend class ASTStmtReader; // Sets dependence dircetly.\n\npublic:\n  QualType getType() const { return TR; }\n  void setType(QualType t) {\n    // In C++, the type of an expression is always adjusted so that it\n    // will not have reference type (C++ [expr]p6). Use\n    // QualType::getNonReferenceType() to retrieve the non-reference\n    // type. Additionally, inspect Expr::isLvalue to determine whether\n    // an expression that is adjusted in this manner should be\n    // considered an lvalue.\n    assert((t.isNull() || !t->isReferenceType()) &&\n           \"Expressions can't have reference type\");\n\n    TR = t;\n  }\n\n  ExprDependence getDependence() const {\n    return static_cast<ExprDependence>(ExprBits.Dependent);\n  }\n\n  /// Determines whether the value of this expression depends on\n  ///   - a template parameter (C++ [temp.dep.constexpr])\n  ///   - or an error, whose resolution is unknown\n  ///\n  /// For example, the array bound of \"Chars\" in the following example is\n  /// value-dependent.\n  /// @code\n  /// template<int Size, char (&Chars)[Size]> struct meta_string;\n  /// @endcode\n  bool isValueDependent() const {\n    return static_cast<bool>(getDependence() & ExprDependence::Value);\n  }\n\n  /// Determines whether the type of this expression depends on\n  ///   - a template paramter (C++ [temp.dep.expr], which means that its type\n  ///     could change from one template instantiation to the next)\n  ///   - or an error\n  ///\n  /// For example, the expressions \"x\" and \"x + y\" are type-dependent in\n  /// the following code, but \"y\" is not type-dependent:\n  /// @code\n  /// template<typename T>\n  /// void add(T x, int y) {\n  ///   x + y;\n  /// }\n  /// @endcode\n  bool isTypeDependent() const {\n    return static_cast<bool>(getDependence() & ExprDependence::Type);\n  }\n\n  /// Whether this expression is instantiation-dependent, meaning that\n  /// it depends in some way on\n  ///    - a template parameter (even if neither its type nor (constant) value\n  ///      can change due to the template instantiation)\n  ///    - or an error\n  ///\n  /// In the following example, the expression \\c sizeof(sizeof(T() + T())) is\n  /// instantiation-dependent (since it involves a template parameter \\c T), but\n  /// is neither type- nor value-dependent, since the type of the inner\n  /// \\c sizeof is known (\\c std::size_t) and therefore the size of the outer\n  /// \\c sizeof is known.\n  ///\n  /// \\code\n  /// template<typename T>\n  /// void f(T x, T y) {\n  ///   sizeof(sizeof(T() + T());\n  /// }\n  /// \\endcode\n  ///\n  /// \\code\n  /// void func(int) {\n  ///   func(); // the expression is instantiation-dependent, because it depends\n  ///           // on an error.\n  /// }\n  /// \\endcode\n  bool isInstantiationDependent() const {\n    return static_cast<bool>(getDependence() & ExprDependence::Instantiation);\n  }\n\n  /// Whether this expression contains an unexpanded parameter\n  /// pack (for C++11 variadic templates).\n  ///\n  /// Given the following function template:\n  ///\n  /// \\code\n  /// template<typename F, typename ...Types>\n  /// void forward(const F &f, Types &&...args) {\n  ///   f(static_cast<Types&&>(args)...);\n  /// }\n  /// \\endcode\n  ///\n  /// The expressions \\c args and \\c static_cast<Types&&>(args) both\n  /// contain parameter packs.\n  bool containsUnexpandedParameterPack() const {\n    return static_cast<bool>(getDependence() & ExprDependence::UnexpandedPack);\n  }\n\n  /// Whether this expression contains subexpressions which had errors, e.g. a\n  /// TypoExpr.\n  bool containsErrors() const {\n    return static_cast<bool>(getDependence() & ExprDependence::Error);\n  }\n\n  /// getExprLoc - Return the preferred location for the arrow when diagnosing\n  /// a problem with a generic expression.\n  SourceLocation getExprLoc() const LLVM_READONLY;\n\n  /// Determine whether an lvalue-to-rvalue conversion should implicitly be\n  /// applied to this expression if it appears as a discarded-value expression\n  /// in C++11 onwards. This applies to certain forms of volatile glvalues.\n  bool isReadIfDiscardedInCPlusPlus11() const;\n\n  /// isUnusedResultAWarning - Return true if this immediate expression should\n  /// be warned about if the result is unused.  If so, fill in expr, location,\n  /// and ranges with expr to warn on and source locations/ranges appropriate\n  /// for a warning.\n  bool isUnusedResultAWarning(const Expr *&WarnExpr, SourceLocation &Loc,\n                              SourceRange &R1, SourceRange &R2,\n                              ASTContext &Ctx) const;\n\n  /// isLValue - True if this expression is an \"l-value\" according to\n  /// the rules of the current language.  C and C++ give somewhat\n  /// different rules for this concept, but in general, the result of\n  /// an l-value expression identifies a specific object whereas the\n  /// result of an r-value expression is a value detached from any\n  /// specific storage.\n  ///\n  /// C++11 divides the concept of \"r-value\" into pure r-values\n  /// (\"pr-values\") and so-called expiring values (\"x-values\"), which\n  /// identify specific objects that can be safely cannibalized for\n  /// their resources.  This is an unfortunate abuse of terminology on\n  /// the part of the C++ committee.  In Clang, when we say \"r-value\",\n  /// we generally mean a pr-value.\n  bool isLValue() const { return getValueKind() == VK_LValue; }\n  bool isRValue() const { return getValueKind() == VK_RValue; }\n  bool isXValue() const { return getValueKind() == VK_XValue; }\n  bool isGLValue() const { return getValueKind() != VK_RValue; }\n\n  enum LValueClassification {\n    LV_Valid,\n    LV_NotObjectType,\n    LV_IncompleteVoidType,\n    LV_DuplicateVectorComponents,\n    LV_InvalidExpression,\n    LV_InvalidMessageExpression,\n    LV_MemberFunction,\n    LV_SubObjCPropertySetting,\n    LV_ClassTemporary,\n    LV_ArrayTemporary\n  };\n  /// Reasons why an expression might not be an l-value.\n  LValueClassification ClassifyLValue(ASTContext &Ctx) const;\n\n  enum isModifiableLvalueResult {\n    MLV_Valid,\n    MLV_NotObjectType,\n    MLV_IncompleteVoidType,\n    MLV_DuplicateVectorComponents,\n    MLV_InvalidExpression,\n    MLV_LValueCast,           // Specialized form of MLV_InvalidExpression.\n    MLV_IncompleteType,\n    MLV_ConstQualified,\n    MLV_ConstQualifiedField,\n    MLV_ConstAddrSpace,\n    MLV_ArrayType,\n    MLV_NoSetterProperty,\n    MLV_MemberFunction,\n    MLV_SubObjCPropertySetting,\n    MLV_InvalidMessageExpression,\n    MLV_ClassTemporary,\n    MLV_ArrayTemporary\n  };\n  /// isModifiableLvalue - C99 6.3.2.1: an lvalue that does not have array type,\n  /// does not have an incomplete type, does not have a const-qualified type,\n  /// and if it is a structure or union, does not have any member (including,\n  /// recursively, any member or element of all contained aggregates or unions)\n  /// with a const-qualified type.\n  ///\n  /// \\param Loc [in,out] - A source location which *may* be filled\n  /// in with the location of the expression making this a\n  /// non-modifiable lvalue, if specified.\n  isModifiableLvalueResult\n  isModifiableLvalue(ASTContext &Ctx, SourceLocation *Loc = nullptr) const;\n\n  /// The return type of classify(). Represents the C++11 expression\n  ///        taxonomy.\n  class Classification {\n  public:\n    /// The various classification results. Most of these mean prvalue.\n    enum Kinds {\n      CL_LValue,\n      CL_XValue,\n      CL_Function, // Functions cannot be lvalues in C.\n      CL_Void, // Void cannot be an lvalue in C.\n      CL_AddressableVoid, // Void expression whose address can be taken in C.\n      CL_DuplicateVectorComponents, // A vector shuffle with dupes.\n      CL_MemberFunction, // An expression referring to a member function\n      CL_SubObjCPropertySetting,\n      CL_ClassTemporary, // A temporary of class type, or subobject thereof.\n      CL_ArrayTemporary, // A temporary of array type.\n      CL_ObjCMessageRValue, // ObjC message is an rvalue\n      CL_PRValue // A prvalue for any other reason, of any other type\n    };\n    /// The results of modification testing.\n    enum ModifiableType {\n      CM_Untested, // testModifiable was false.\n      CM_Modifiable,\n      CM_RValue, // Not modifiable because it's an rvalue\n      CM_Function, // Not modifiable because it's a function; C++ only\n      CM_LValueCast, // Same as CM_RValue, but indicates GCC cast-as-lvalue ext\n      CM_NoSetterProperty,// Implicit assignment to ObjC property without setter\n      CM_ConstQualified,\n      CM_ConstQualifiedField,\n      CM_ConstAddrSpace,\n      CM_ArrayType,\n      CM_IncompleteType\n    };\n\n  private:\n    friend class Expr;\n\n    unsigned short Kind;\n    unsigned short Modifiable;\n\n    explicit Classification(Kinds k, ModifiableType m)\n      : Kind(k), Modifiable(m)\n    {}\n\n  public:\n    Classification() {}\n\n    Kinds getKind() const { return static_cast<Kinds>(Kind); }\n    ModifiableType getModifiable() const {\n      assert(Modifiable != CM_Untested && \"Did not test for modifiability.\");\n      return static_cast<ModifiableType>(Modifiable);\n    }\n    bool isLValue() const { return Kind == CL_LValue; }\n    bool isXValue() const { return Kind == CL_XValue; }\n    bool isGLValue() const { return Kind <= CL_XValue; }\n    bool isPRValue() const { return Kind >= CL_Function; }\n    bool isRValue() const { return Kind >= CL_XValue; }\n    bool isModifiable() const { return getModifiable() == CM_Modifiable; }\n\n    /// Create a simple, modifiably lvalue\n    static Classification makeSimpleLValue() {\n      return Classification(CL_LValue, CM_Modifiable);\n    }\n\n  };\n  /// Classify - Classify this expression according to the C++11\n  ///        expression taxonomy.\n  ///\n  /// C++11 defines ([basic.lval]) a new taxonomy of expressions to replace the\n  /// old lvalue vs rvalue. This function determines the type of expression this\n  /// is. There are three expression types:\n  /// - lvalues are classical lvalues as in C++03.\n  /// - prvalues are equivalent to rvalues in C++03.\n  /// - xvalues are expressions yielding unnamed rvalue references, e.g. a\n  ///   function returning an rvalue reference.\n  /// lvalues and xvalues are collectively referred to as glvalues, while\n  /// prvalues and xvalues together form rvalues.\n  Classification Classify(ASTContext &Ctx) const {\n    return ClassifyImpl(Ctx, nullptr);\n  }\n\n  /// ClassifyModifiable - Classify this expression according to the\n  ///        C++11 expression taxonomy, and see if it is valid on the left side\n  ///        of an assignment.\n  ///\n  /// This function extends classify in that it also tests whether the\n  /// expression is modifiable (C99 6.3.2.1p1).\n  /// \\param Loc A source location that might be filled with a relevant location\n  ///            if the expression is not modifiable.\n  Classification ClassifyModifiable(ASTContext &Ctx, SourceLocation &Loc) const{\n    return ClassifyImpl(Ctx, &Loc);\n  }\n\n  /// Returns the set of floating point options that apply to this expression.\n  /// Only meaningful for operations on floating point values.\n  FPOptions getFPFeaturesInEffect(const LangOptions &LO) const;\n\n  /// getValueKindForType - Given a formal return or parameter type,\n  /// give its value kind.\n  static ExprValueKind getValueKindForType(QualType T) {\n    if (const ReferenceType *RT = T->getAs<ReferenceType>())\n      return (isa<LValueReferenceType>(RT)\n                ? VK_LValue\n                : (RT->getPointeeType()->isFunctionType()\n                     ? VK_LValue : VK_XValue));\n    return VK_RValue;\n  }\n\n  /// getValueKind - The value kind that this expression produces.\n  ExprValueKind getValueKind() const {\n    return static_cast<ExprValueKind>(ExprBits.ValueKind);\n  }\n\n  /// getObjectKind - The object kind that this expression produces.\n  /// Object kinds are meaningful only for expressions that yield an\n  /// l-value or x-value.\n  ExprObjectKind getObjectKind() const {\n    return static_cast<ExprObjectKind>(ExprBits.ObjectKind);\n  }\n\n  bool isOrdinaryOrBitFieldObject() const {\n    ExprObjectKind OK = getObjectKind();\n    return (OK == OK_Ordinary || OK == OK_BitField);\n  }\n\n  /// setValueKind - Set the value kind produced by this expression.\n  void setValueKind(ExprValueKind Cat) { ExprBits.ValueKind = Cat; }\n\n  /// setObjectKind - Set the object kind produced by this expression.\n  void setObjectKind(ExprObjectKind Cat) { ExprBits.ObjectKind = Cat; }\n\nprivate:\n  Classification ClassifyImpl(ASTContext &Ctx, SourceLocation *Loc) const;\n\npublic:\n\n  /// Returns true if this expression is a gl-value that\n  /// potentially refers to a bit-field.\n  ///\n  /// In C++, whether a gl-value refers to a bitfield is essentially\n  /// an aspect of the value-kind type system.\n  bool refersToBitField() const { return getObjectKind() == OK_BitField; }\n\n  /// If this expression refers to a bit-field, retrieve the\n  /// declaration of that bit-field.\n  ///\n  /// Note that this returns a non-null pointer in subtly different\n  /// places than refersToBitField returns true.  In particular, this can\n  /// return a non-null pointer even for r-values loaded from\n  /// bit-fields, but it will return null for a conditional bit-field.\n  FieldDecl *getSourceBitField();\n\n  const FieldDecl *getSourceBitField() const {\n    return const_cast<Expr*>(this)->getSourceBitField();\n  }\n\n  Decl *getReferencedDeclOfCallee();\n  const Decl *getReferencedDeclOfCallee() const {\n    return const_cast<Expr*>(this)->getReferencedDeclOfCallee();\n  }\n\n  /// If this expression is an l-value for an Objective C\n  /// property, find the underlying property reference expression.\n  const ObjCPropertyRefExpr *getObjCProperty() const;\n\n  /// Check if this expression is the ObjC 'self' implicit parameter.\n  bool isObjCSelfExpr() const;\n\n  /// Returns whether this expression refers to a vector element.\n  bool refersToVectorElement() const;\n\n  /// Returns whether this expression refers to a matrix element.\n  bool refersToMatrixElement() const {\n    return getObjectKind() == OK_MatrixComponent;\n  }\n\n  /// Returns whether this expression refers to a global register\n  /// variable.\n  bool refersToGlobalRegisterVar() const;\n\n  /// Returns whether this expression has a placeholder type.\n  bool hasPlaceholderType() const {\n    return getType()->isPlaceholderType();\n  }\n\n  /// Returns whether this expression has a specific placeholder type.\n  bool hasPlaceholderType(BuiltinType::Kind K) const {\n    assert(BuiltinType::isPlaceholderTypeKind(K));\n    if (const BuiltinType *BT = dyn_cast<BuiltinType>(getType()))\n      return BT->getKind() == K;\n    return false;\n  }\n\n  /// isKnownToHaveBooleanValue - Return true if this is an integer expression\n  /// that is known to return 0 or 1.  This happens for _Bool/bool expressions\n  /// but also int expressions which are produced by things like comparisons in\n  /// C.\n  ///\n  /// \\param Semantic If true, only return true for expressions that are known\n  /// to be semantically boolean, which might not be true even for expressions\n  /// that are known to evaluate to 0/1. For instance, reading an unsigned\n  /// bit-field with width '1' will evaluate to 0/1, but doesn't necessarily\n  /// semantically correspond to a bool.\n  bool isKnownToHaveBooleanValue(bool Semantic = true) const;\n\n  /// isIntegerConstantExpr - Return the value if this expression is a valid\n  /// integer constant expression.  If not a valid i-c-e, return None and fill\n  /// in Loc (if specified) with the location of the invalid expression.\n  ///\n  /// Note: This does not perform the implicit conversions required by C++11\n  /// [expr.const]p5.\n  Optional<llvm::APSInt> getIntegerConstantExpr(const ASTContext &Ctx,\n                                                SourceLocation *Loc = nullptr,\n                                                bool isEvaluated = true) const;\n  bool isIntegerConstantExpr(const ASTContext &Ctx,\n                             SourceLocation *Loc = nullptr) const;\n\n  /// isCXX98IntegralConstantExpr - Return true if this expression is an\n  /// integral constant expression in C++98. Can only be used in C++.\n  bool isCXX98IntegralConstantExpr(const ASTContext &Ctx) const;\n\n  /// isCXX11ConstantExpr - Return true if this expression is a constant\n  /// expression in C++11. Can only be used in C++.\n  ///\n  /// Note: This does not perform the implicit conversions required by C++11\n  /// [expr.const]p5.\n  bool isCXX11ConstantExpr(const ASTContext &Ctx, APValue *Result = nullptr,\n                           SourceLocation *Loc = nullptr) const;\n\n  /// isPotentialConstantExpr - Return true if this function's definition\n  /// might be usable in a constant expression in C++11, if it were marked\n  /// constexpr. Return false if the function can never produce a constant\n  /// expression, along with diagnostics describing why not.\n  static bool isPotentialConstantExpr(const FunctionDecl *FD,\n                                      SmallVectorImpl<\n                                        PartialDiagnosticAt> &Diags);\n\n  /// isPotentialConstantExprUnevaluted - Return true if this expression might\n  /// be usable in a constant expression in C++11 in an unevaluated context, if\n  /// it were in function FD marked constexpr. Return false if the function can\n  /// never produce a constant expression, along with diagnostics describing\n  /// why not.\n  static bool isPotentialConstantExprUnevaluated(Expr *E,\n                                                 const FunctionDecl *FD,\n                                                 SmallVectorImpl<\n                                                   PartialDiagnosticAt> &Diags);\n\n  /// isConstantInitializer - Returns true if this expression can be emitted to\n  /// IR as a constant, and thus can be used as a constant initializer in C.\n  /// If this expression is not constant and Culprit is non-null,\n  /// it is used to store the address of first non constant expr.\n  bool isConstantInitializer(ASTContext &Ctx, bool ForRef,\n                             const Expr **Culprit = nullptr) const;\n\n  /// EvalStatus is a struct with detailed info about an evaluation in progress.\n  struct EvalStatus {\n    /// Whether the evaluated expression has side effects.\n    /// For example, (f() && 0) can be folded, but it still has side effects.\n    bool HasSideEffects;\n\n    /// Whether the evaluation hit undefined behavior.\n    /// For example, 1.0 / 0.0 can be folded to Inf, but has undefined behavior.\n    /// Likewise, INT_MAX + 1 can be folded to INT_MIN, but has UB.\n    bool HasUndefinedBehavior;\n\n    /// Diag - If this is non-null, it will be filled in with a stack of notes\n    /// indicating why evaluation failed (or why it failed to produce a constant\n    /// expression).\n    /// If the expression is unfoldable, the notes will indicate why it's not\n    /// foldable. If the expression is foldable, but not a constant expression,\n    /// the notes will describes why it isn't a constant expression. If the\n    /// expression *is* a constant expression, no notes will be produced.\n    SmallVectorImpl<PartialDiagnosticAt> *Diag;\n\n    EvalStatus()\n        : HasSideEffects(false), HasUndefinedBehavior(false), Diag(nullptr) {}\n\n    // hasSideEffects - Return true if the evaluated expression has\n    // side effects.\n    bool hasSideEffects() const {\n      return HasSideEffects;\n    }\n  };\n\n  /// EvalResult is a struct with detailed info about an evaluated expression.\n  struct EvalResult : EvalStatus {\n    /// Val - This is the value the expression can be folded to.\n    APValue Val;\n\n    // isGlobalLValue - Return true if the evaluated lvalue expression\n    // is global.\n    bool isGlobalLValue() const;\n  };\n\n  /// EvaluateAsRValue - Return true if this is a constant which we can fold to\n  /// an rvalue using any crazy technique (that has nothing to do with language\n  /// standards) that we want to, even if the expression has side-effects. If\n  /// this function returns true, it returns the folded constant in Result. If\n  /// the expression is a glvalue, an lvalue-to-rvalue conversion will be\n  /// applied.\n  bool EvaluateAsRValue(EvalResult &Result, const ASTContext &Ctx,\n                        bool InConstantContext = false) const;\n\n  /// EvaluateAsBooleanCondition - Return true if this is a constant\n  /// which we can fold and convert to a boolean condition using\n  /// any crazy technique that we want to, even if the expression has\n  /// side-effects.\n  bool EvaluateAsBooleanCondition(bool &Result, const ASTContext &Ctx,\n                                  bool InConstantContext = false) const;\n\n  enum SideEffectsKind {\n    SE_NoSideEffects,          ///< Strictly evaluate the expression.\n    SE_AllowUndefinedBehavior, ///< Allow UB that we can give a value, but not\n                               ///< arbitrary unmodeled side effects.\n    SE_AllowSideEffects        ///< Allow any unmodeled side effect.\n  };\n\n  /// EvaluateAsInt - Return true if this is a constant which we can fold and\n  /// convert to an integer, using any crazy technique that we want to.\n  bool EvaluateAsInt(EvalResult &Result, const ASTContext &Ctx,\n                     SideEffectsKind AllowSideEffects = SE_NoSideEffects,\n                     bool InConstantContext = false) const;\n\n  /// EvaluateAsFloat - Return true if this is a constant which we can fold and\n  /// convert to a floating point value, using any crazy technique that we\n  /// want to.\n  bool EvaluateAsFloat(llvm::APFloat &Result, const ASTContext &Ctx,\n                       SideEffectsKind AllowSideEffects = SE_NoSideEffects,\n                       bool InConstantContext = false) const;\n\n  /// EvaluateAsFloat - Return true if this is a constant which we can fold and\n  /// convert to a fixed point value.\n  bool EvaluateAsFixedPoint(EvalResult &Result, const ASTContext &Ctx,\n                            SideEffectsKind AllowSideEffects = SE_NoSideEffects,\n                            bool InConstantContext = false) const;\n\n  /// isEvaluatable - Call EvaluateAsRValue to see if this expression can be\n  /// constant folded without side-effects, but discard the result.\n  bool isEvaluatable(const ASTContext &Ctx,\n                     SideEffectsKind AllowSideEffects = SE_NoSideEffects) const;\n\n  /// HasSideEffects - This routine returns true for all those expressions\n  /// which have any effect other than producing a value. Example is a function\n  /// call, volatile variable read, or throwing an exception. If\n  /// IncludePossibleEffects is false, this call treats certain expressions with\n  /// potential side effects (such as function call-like expressions,\n  /// instantiation-dependent expressions, or invocations from a macro) as not\n  /// having side effects.\n  bool HasSideEffects(const ASTContext &Ctx,\n                      bool IncludePossibleEffects = true) const;\n\n  /// Determine whether this expression involves a call to any function\n  /// that is not trivial.\n  bool hasNonTrivialCall(const ASTContext &Ctx) const;\n\n  /// EvaluateKnownConstInt - Call EvaluateAsRValue and return the folded\n  /// integer. This must be called on an expression that constant folds to an\n  /// integer.\n  llvm::APSInt EvaluateKnownConstInt(\n      const ASTContext &Ctx,\n      SmallVectorImpl<PartialDiagnosticAt> *Diag = nullptr) const;\n\n  llvm::APSInt EvaluateKnownConstIntCheckOverflow(\n      const ASTContext &Ctx,\n      SmallVectorImpl<PartialDiagnosticAt> *Diag = nullptr) const;\n\n  void EvaluateForOverflow(const ASTContext &Ctx) const;\n\n  /// EvaluateAsLValue - Evaluate an expression to see if we can fold it to an\n  /// lvalue with link time known address, with no side-effects.\n  bool EvaluateAsLValue(EvalResult &Result, const ASTContext &Ctx,\n                        bool InConstantContext = false) const;\n\n  /// EvaluateAsInitializer - Evaluate an expression as if it were the\n  /// initializer of the given declaration. Returns true if the initializer\n  /// can be folded to a constant, and produces any relevant notes. In C++11,\n  /// notes will be produced if the expression is not a constant expression.\n  bool EvaluateAsInitializer(APValue &Result, const ASTContext &Ctx,\n                             const VarDecl *VD,\n                             SmallVectorImpl<PartialDiagnosticAt> &Notes,\n                             bool IsConstantInitializer) const;\n\n  /// EvaluateWithSubstitution - Evaluate an expression as if from the context\n  /// of a call to the given function with the given arguments, inside an\n  /// unevaluated context. Returns true if the expression could be folded to a\n  /// constant.\n  bool EvaluateWithSubstitution(APValue &Value, ASTContext &Ctx,\n                                const FunctionDecl *Callee,\n                                ArrayRef<const Expr*> Args,\n                                const Expr *This = nullptr) const;\n\n  enum class ConstantExprKind {\n    /// An integer constant expression (an array bound, enumerator, case value,\n    /// bit-field width, or similar) or similar.\n    Normal,\n    /// A non-class template argument. Such a value is only used for mangling,\n    /// not for code generation, so can refer to dllimported functions.\n    NonClassTemplateArgument,\n    /// A class template argument. Such a value is used for code generation.\n    ClassTemplateArgument,\n    /// An immediate invocation. The destruction of the end result of this\n    /// evaluation is not part of the evaluation, but all other temporaries\n    /// are destroyed.\n    ImmediateInvocation,\n  };\n\n  /// Evaluate an expression that is required to be a constant expression. Does\n  /// not check the syntactic constraints for C and C++98 constant expressions.\n  bool EvaluateAsConstantExpr(\n      EvalResult &Result, const ASTContext &Ctx,\n      ConstantExprKind Kind = ConstantExprKind::Normal) const;\n\n  /// If the current Expr is a pointer, this will try to statically\n  /// determine the number of bytes available where the pointer is pointing.\n  /// Returns true if all of the above holds and we were able to figure out the\n  /// size, false otherwise.\n  ///\n  /// \\param Type - How to evaluate the size of the Expr, as defined by the\n  /// \"type\" parameter of __builtin_object_size\n  bool tryEvaluateObjectSize(uint64_t &Result, ASTContext &Ctx,\n                             unsigned Type) const;\n\n  /// Enumeration used to describe the kind of Null pointer constant\n  /// returned from \\c isNullPointerConstant().\n  enum NullPointerConstantKind {\n    /// Expression is not a Null pointer constant.\n    NPCK_NotNull = 0,\n\n    /// Expression is a Null pointer constant built from a zero integer\n    /// expression that is not a simple, possibly parenthesized, zero literal.\n    /// C++ Core Issue 903 will classify these expressions as \"not pointers\"\n    /// once it is adopted.\n    /// http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#903\n    NPCK_ZeroExpression,\n\n    /// Expression is a Null pointer constant built from a literal zero.\n    NPCK_ZeroLiteral,\n\n    /// Expression is a C++11 nullptr.\n    NPCK_CXX11_nullptr,\n\n    /// Expression is a GNU-style __null constant.\n    NPCK_GNUNull\n  };\n\n  /// Enumeration used to describe how \\c isNullPointerConstant()\n  /// should cope with value-dependent expressions.\n  enum NullPointerConstantValueDependence {\n    /// Specifies that the expression should never be value-dependent.\n    NPC_NeverValueDependent = 0,\n\n    /// Specifies that a value-dependent expression of integral or\n    /// dependent type should be considered a null pointer constant.\n    NPC_ValueDependentIsNull,\n\n    /// Specifies that a value-dependent expression should be considered\n    /// to never be a null pointer constant.\n    NPC_ValueDependentIsNotNull\n  };\n\n  /// isNullPointerConstant - C99 6.3.2.3p3 - Test if this reduces down to\n  /// a Null pointer constant. The return value can further distinguish the\n  /// kind of NULL pointer constant that was detected.\n  NullPointerConstantKind isNullPointerConstant(\n      ASTContext &Ctx,\n      NullPointerConstantValueDependence NPC) const;\n\n  /// isOBJCGCCandidate - Return true if this expression may be used in a read/\n  /// write barrier.\n  bool isOBJCGCCandidate(ASTContext &Ctx) const;\n\n  /// Returns true if this expression is a bound member function.\n  bool isBoundMemberFunction(ASTContext &Ctx) const;\n\n  /// Given an expression of bound-member type, find the type\n  /// of the member.  Returns null if this is an *overloaded* bound\n  /// member expression.\n  static QualType findBoundMemberType(const Expr *expr);\n\n  /// Skip past any invisble AST nodes which might surround this\n  /// statement, such as ExprWithCleanups or ImplicitCastExpr nodes,\n  /// but also injected CXXMemberExpr and CXXConstructExpr which represent\n  /// implicit conversions.\n  Expr *IgnoreUnlessSpelledInSource();\n  const Expr *IgnoreUnlessSpelledInSource() const {\n    return const_cast<Expr *>(this)->IgnoreUnlessSpelledInSource();\n  }\n\n  /// Skip past any implicit casts which might surround this expression until\n  /// reaching a fixed point. Skips:\n  /// * ImplicitCastExpr\n  /// * FullExpr\n  Expr *IgnoreImpCasts() LLVM_READONLY;\n  const Expr *IgnoreImpCasts() const {\n    return const_cast<Expr *>(this)->IgnoreImpCasts();\n  }\n\n  /// Skip past any casts which might surround this expression until reaching\n  /// a fixed point. Skips:\n  /// * CastExpr\n  /// * FullExpr\n  /// * MaterializeTemporaryExpr\n  /// * SubstNonTypeTemplateParmExpr\n  Expr *IgnoreCasts() LLVM_READONLY;\n  const Expr *IgnoreCasts() const {\n    return const_cast<Expr *>(this)->IgnoreCasts();\n  }\n\n  /// Skip past any implicit AST nodes which might surround this expression\n  /// until reaching a fixed point. Skips:\n  /// * What IgnoreImpCasts() skips\n  /// * MaterializeTemporaryExpr\n  /// * CXXBindTemporaryExpr\n  Expr *IgnoreImplicit() LLVM_READONLY;\n  const Expr *IgnoreImplicit() const {\n    return const_cast<Expr *>(this)->IgnoreImplicit();\n  }\n\n  /// Skip past any implicit AST nodes which might surround this expression\n  /// until reaching a fixed point. Same as IgnoreImplicit, except that it\n  /// also skips over implicit calls to constructors and conversion functions.\n  ///\n  /// FIXME: Should IgnoreImplicit do this?\n  Expr *IgnoreImplicitAsWritten() LLVM_READONLY;\n  const Expr *IgnoreImplicitAsWritten() const {\n    return const_cast<Expr *>(this)->IgnoreImplicitAsWritten();\n  }\n\n  /// Skip past any parentheses which might surround this expression until\n  /// reaching a fixed point. Skips:\n  /// * ParenExpr\n  /// * UnaryOperator if `UO_Extension`\n  /// * GenericSelectionExpr if `!isResultDependent()`\n  /// * ChooseExpr if `!isConditionDependent()`\n  /// * ConstantExpr\n  Expr *IgnoreParens() LLVM_READONLY;\n  const Expr *IgnoreParens() const {\n    return const_cast<Expr *>(this)->IgnoreParens();\n  }\n\n  /// Skip past any parentheses and implicit casts which might surround this\n  /// expression until reaching a fixed point.\n  /// FIXME: IgnoreParenImpCasts really ought to be equivalent to\n  /// IgnoreParens() + IgnoreImpCasts() until reaching a fixed point. However\n  /// this is currently not the case. Instead IgnoreParenImpCasts() skips:\n  /// * What IgnoreParens() skips\n  /// * What IgnoreImpCasts() skips\n  /// * MaterializeTemporaryExpr\n  /// * SubstNonTypeTemplateParmExpr\n  Expr *IgnoreParenImpCasts() LLVM_READONLY;\n  const Expr *IgnoreParenImpCasts() const {\n    return const_cast<Expr *>(this)->IgnoreParenImpCasts();\n  }\n\n  /// Skip past any parentheses and casts which might surround this expression\n  /// until reaching a fixed point. Skips:\n  /// * What IgnoreParens() skips\n  /// * What IgnoreCasts() skips\n  Expr *IgnoreParenCasts() LLVM_READONLY;\n  const Expr *IgnoreParenCasts() const {\n    return const_cast<Expr *>(this)->IgnoreParenCasts();\n  }\n\n  /// Skip conversion operators. If this Expr is a call to a conversion\n  /// operator, return the argument.\n  Expr *IgnoreConversionOperatorSingleStep() LLVM_READONLY;\n  const Expr *IgnoreConversionOperatorSingleStep() const {\n    return const_cast<Expr *>(this)->IgnoreConversionOperatorSingleStep();\n  }\n\n  /// Skip past any parentheses and lvalue casts which might surround this\n  /// expression until reaching a fixed point. Skips:\n  /// * What IgnoreParens() skips\n  /// * What IgnoreCasts() skips, except that only lvalue-to-rvalue\n  ///   casts are skipped\n  /// FIXME: This is intended purely as a temporary workaround for code\n  /// that hasn't yet been rewritten to do the right thing about those\n  /// casts, and may disappear along with the last internal use.\n  Expr *IgnoreParenLValueCasts() LLVM_READONLY;\n  const Expr *IgnoreParenLValueCasts() const {\n    return const_cast<Expr *>(this)->IgnoreParenLValueCasts();\n  }\n\n  /// Skip past any parenthese and casts which do not change the value\n  /// (including ptr->int casts of the same size) until reaching a fixed point.\n  /// Skips:\n  /// * What IgnoreParens() skips\n  /// * CastExpr which do not change the value\n  /// * SubstNonTypeTemplateParmExpr\n  Expr *IgnoreParenNoopCasts(const ASTContext &Ctx) LLVM_READONLY;\n  const Expr *IgnoreParenNoopCasts(const ASTContext &Ctx) const {\n    return const_cast<Expr *>(this)->IgnoreParenNoopCasts(Ctx);\n  }\n\n  /// Skip past any parentheses and derived-to-base casts until reaching a\n  /// fixed point. Skips:\n  /// * What IgnoreParens() skips\n  /// * CastExpr which represent a derived-to-base cast (CK_DerivedToBase,\n  ///   CK_UncheckedDerivedToBase and CK_NoOp)\n  Expr *IgnoreParenBaseCasts() LLVM_READONLY;\n  const Expr *IgnoreParenBaseCasts() const {\n    return const_cast<Expr *>(this)->IgnoreParenBaseCasts();\n  }\n\n  /// Determine whether this expression is a default function argument.\n  ///\n  /// Default arguments are implicitly generated in the abstract syntax tree\n  /// by semantic analysis for function calls, object constructions, etc. in\n  /// C++. Default arguments are represented by \\c CXXDefaultArgExpr nodes;\n  /// this routine also looks through any implicit casts to determine whether\n  /// the expression is a default argument.\n  bool isDefaultArgument() const;\n\n  /// Determine whether the result of this expression is a\n  /// temporary object of the given class type.\n  bool isTemporaryObject(ASTContext &Ctx, const CXXRecordDecl *TempTy) const;\n\n  /// Whether this expression is an implicit reference to 'this' in C++.\n  bool isImplicitCXXThis() const;\n\n  static bool hasAnyTypeDependentArguments(ArrayRef<Expr *> Exprs);\n\n  /// For an expression of class type or pointer to class type,\n  /// return the most derived class decl the expression is known to refer to.\n  ///\n  /// If this expression is a cast, this method looks through it to find the\n  /// most derived decl that can be inferred from the expression.\n  /// This is valid because derived-to-base conversions have undefined\n  /// behavior if the object isn't dynamically of the derived type.\n  const CXXRecordDecl *getBestDynamicClassType() const;\n\n  /// Get the inner expression that determines the best dynamic class.\n  /// If this is a prvalue, we guarantee that it is of the most-derived type\n  /// for the object itself.\n  const Expr *getBestDynamicClassTypeExpr() const;\n\n  /// Walk outwards from an expression we want to bind a reference to and\n  /// find the expression whose lifetime needs to be extended. Record\n  /// the LHSs of comma expressions and adjustments needed along the path.\n  const Expr *skipRValueSubobjectAdjustments(\n      SmallVectorImpl<const Expr *> &CommaLHS,\n      SmallVectorImpl<SubobjectAdjustment> &Adjustments) const;\n  const Expr *skipRValueSubobjectAdjustments() const {\n    SmallVector<const Expr *, 8> CommaLHSs;\n    SmallVector<SubobjectAdjustment, 8> Adjustments;\n    return skipRValueSubobjectAdjustments(CommaLHSs, Adjustments);\n  }\n\n  /// Checks that the two Expr's will refer to the same value as a comparison\n  /// operand.  The caller must ensure that the values referenced by the Expr's\n  /// are not modified between E1 and E2 or the result my be invalid.\n  static bool isSameComparisonOperand(const Expr* E1, const Expr* E2);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() >= firstExprConstant &&\n           T->getStmtClass() <= lastExprConstant;\n  }\n};\n// PointerLikeTypeTraits is specialized so it can be used with a forward-decl of\n// Expr. Verify that we got it right.\nstatic_assert(llvm::PointerLikeTypeTraits<Expr *>::NumLowBitsAvailable <=\n                  llvm::detail::ConstantLog2<alignof(Expr)>::value,\n              \"PointerLikeTypeTraits<Expr*> assumes too much alignment.\");\n\nusing ConstantExprKind = Expr::ConstantExprKind;\n\n//===----------------------------------------------------------------------===//\n// Wrapper Expressions.\n//===----------------------------------------------------------------------===//\n\n/// FullExpr - Represents a \"full-expression\" node.\nclass FullExpr : public Expr {\nprotected:\n Stmt *SubExpr;\n\n FullExpr(StmtClass SC, Expr *subexpr)\n     : Expr(SC, subexpr->getType(), subexpr->getValueKind(),\n            subexpr->getObjectKind()),\n       SubExpr(subexpr) {\n   setDependence(computeDependence(this));\n }\n  FullExpr(StmtClass SC, EmptyShell Empty)\n    : Expr(SC, Empty) {}\npublic:\n  const Expr *getSubExpr() const { return cast<Expr>(SubExpr); }\n  Expr *getSubExpr() { return cast<Expr>(SubExpr); }\n\n  /// As with any mutator of the AST, be very careful when modifying an\n  /// existing AST to preserve its invariants.\n  void setSubExpr(Expr *E) { SubExpr = E; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() >= firstFullExprConstant &&\n           T->getStmtClass() <= lastFullExprConstant;\n  }\n};\n\n/// ConstantExpr - An expression that occurs in a constant context and\n/// optionally the result of evaluating the expression.\nclass ConstantExpr final\n    : public FullExpr,\n      private llvm::TrailingObjects<ConstantExpr, APValue, uint64_t> {\n  static_assert(std::is_same<uint64_t, llvm::APInt::WordType>::value,\n                \"ConstantExpr assumes that llvm::APInt::WordType is uint64_t \"\n                \"for tail-allocated storage\");\n  friend TrailingObjects;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\npublic:\n  /// Describes the kind of result that can be tail-allocated.\n  enum ResultStorageKind { RSK_None, RSK_Int64, RSK_APValue };\n\nprivate:\n  size_t numTrailingObjects(OverloadToken<APValue>) const {\n    return ConstantExprBits.ResultKind == ConstantExpr::RSK_APValue;\n  }\n  size_t numTrailingObjects(OverloadToken<uint64_t>) const {\n    return ConstantExprBits.ResultKind == ConstantExpr::RSK_Int64;\n  }\n\n  uint64_t &Int64Result() {\n    assert(ConstantExprBits.ResultKind == ConstantExpr::RSK_Int64 &&\n           \"invalid accessor\");\n    return *getTrailingObjects<uint64_t>();\n  }\n  const uint64_t &Int64Result() const {\n    return const_cast<ConstantExpr *>(this)->Int64Result();\n  }\n  APValue &APValueResult() {\n    assert(ConstantExprBits.ResultKind == ConstantExpr::RSK_APValue &&\n           \"invalid accessor\");\n    return *getTrailingObjects<APValue>();\n  }\n  APValue &APValueResult() const {\n    return const_cast<ConstantExpr *>(this)->APValueResult();\n  }\n\n  ConstantExpr(Expr *SubExpr, ResultStorageKind StorageKind,\n               bool IsImmediateInvocation);\n  ConstantExpr(EmptyShell Empty, ResultStorageKind StorageKind);\n\npublic:\n  static ConstantExpr *Create(const ASTContext &Context, Expr *E,\n                              const APValue &Result);\n  static ConstantExpr *Create(const ASTContext &Context, Expr *E,\n                              ResultStorageKind Storage = RSK_None,\n                              bool IsImmediateInvocation = false);\n  static ConstantExpr *CreateEmpty(const ASTContext &Context,\n                                   ResultStorageKind StorageKind);\n\n  static ResultStorageKind getStorageKind(const APValue &Value);\n  static ResultStorageKind getStorageKind(const Type *T,\n                                          const ASTContext &Context);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return SubExpr->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return SubExpr->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ConstantExprClass;\n  }\n\n  void SetResult(APValue Value, const ASTContext &Context) {\n    MoveIntoResult(Value, Context);\n  }\n  void MoveIntoResult(APValue &Value, const ASTContext &Context);\n\n  APValue::ValueKind getResultAPValueKind() const {\n    return static_cast<APValue::ValueKind>(ConstantExprBits.APValueKind);\n  }\n  ResultStorageKind getResultStorageKind() const {\n    return static_cast<ResultStorageKind>(ConstantExprBits.ResultKind);\n  }\n  bool isImmediateInvocation() const {\n    return ConstantExprBits.IsImmediateInvocation;\n  }\n  bool hasAPValueResult() const {\n    return ConstantExprBits.APValueKind != APValue::None;\n  }\n  APValue getAPValueResult() const;\n  APValue &getResultAsAPValue() const { return APValueResult(); }\n  llvm::APSInt getResultAsAPSInt() const;\n  // Iterators\n  child_range children() { return child_range(&SubExpr, &SubExpr+1); }\n  const_child_range children() const {\n    return const_child_range(&SubExpr, &SubExpr + 1);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Primary Expressions.\n//===----------------------------------------------------------------------===//\n\n/// OpaqueValueExpr - An expression referring to an opaque object of a\n/// fixed type and value class.  These don't correspond to concrete\n/// syntax; instead they're used to express operations (usually copy\n/// operations) on values whose source is generally obvious from\n/// context.\nclass OpaqueValueExpr : public Expr {\n  friend class ASTStmtReader;\n  Expr *SourceExpr;\n\npublic:\n  OpaqueValueExpr(SourceLocation Loc, QualType T, ExprValueKind VK,\n                  ExprObjectKind OK = OK_Ordinary, Expr *SourceExpr = nullptr)\n      : Expr(OpaqueValueExprClass, T, VK, OK), SourceExpr(SourceExpr) {\n    setIsUnique(false);\n    OpaqueValueExprBits.Loc = Loc;\n    setDependence(computeDependence(this));\n  }\n\n  /// Given an expression which invokes a copy constructor --- i.e.  a\n  /// CXXConstructExpr, possibly wrapped in an ExprWithCleanups ---\n  /// find the OpaqueValueExpr that's the source of the construction.\n  static const OpaqueValueExpr *findInCopyConstruct(const Expr *expr);\n\n  explicit OpaqueValueExpr(EmptyShell Empty)\n    : Expr(OpaqueValueExprClass, Empty) {}\n\n  /// Retrieve the location of this expression.\n  SourceLocation getLocation() const { return OpaqueValueExprBits.Loc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return SourceExpr ? SourceExpr->getBeginLoc() : getLocation();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return SourceExpr ? SourceExpr->getEndLoc() : getLocation();\n  }\n  SourceLocation getExprLoc() const LLVM_READONLY {\n    return SourceExpr ? SourceExpr->getExprLoc() : getLocation();\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  /// The source expression of an opaque value expression is the\n  /// expression which originally generated the value.  This is\n  /// provided as a convenience for analyses that don't wish to\n  /// precisely model the execution behavior of the program.\n  ///\n  /// The source expression is typically set when building the\n  /// expression which binds the opaque value expression in the first\n  /// place.\n  Expr *getSourceExpr() const { return SourceExpr; }\n\n  void setIsUnique(bool V) {\n    assert((!V || SourceExpr) &&\n           \"unique OVEs are expected to have source expressions\");\n    OpaqueValueExprBits.IsUnique = V;\n  }\n\n  bool isUnique() const { return OpaqueValueExprBits.IsUnique; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OpaqueValueExprClass;\n  }\n};\n\n/// A reference to a declared variable, function, enum, etc.\n/// [C99 6.5.1p2]\n///\n/// This encodes all the information about how a declaration is referenced\n/// within an expression.\n///\n/// There are several optional constructs attached to DeclRefExprs only when\n/// they apply in order to conserve memory. These are laid out past the end of\n/// the object, and flags in the DeclRefExprBitfield track whether they exist:\n///\n///   DeclRefExprBits.HasQualifier:\n///       Specifies when this declaration reference expression has a C++\n///       nested-name-specifier.\n///   DeclRefExprBits.HasFoundDecl:\n///       Specifies when this declaration reference expression has a record of\n///       a NamedDecl (different from the referenced ValueDecl) which was found\n///       during name lookup and/or overload resolution.\n///   DeclRefExprBits.HasTemplateKWAndArgsInfo:\n///       Specifies when this declaration reference expression has an explicit\n///       C++ template keyword and/or template argument list.\n///   DeclRefExprBits.RefersToEnclosingVariableOrCapture\n///       Specifies when this declaration reference expression (validly)\n///       refers to an enclosed local or a captured variable.\nclass DeclRefExpr final\n    : public Expr,\n      private llvm::TrailingObjects<DeclRefExpr, NestedNameSpecifierLoc,\n                                    NamedDecl *, ASTTemplateKWAndArgsInfo,\n                                    TemplateArgumentLoc> {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// The declaration that we are referencing.\n  ValueDecl *D;\n\n  /// Provides source/type location info for the declaration name\n  /// embedded in D.\n  DeclarationNameLoc DNLoc;\n\n  size_t numTrailingObjects(OverloadToken<NestedNameSpecifierLoc>) const {\n    return hasQualifier();\n  }\n\n  size_t numTrailingObjects(OverloadToken<NamedDecl *>) const {\n    return hasFoundDecl();\n  }\n\n  size_t numTrailingObjects(OverloadToken<ASTTemplateKWAndArgsInfo>) const {\n    return hasTemplateKWAndArgsInfo();\n  }\n\n  /// Test whether there is a distinct FoundDecl attached to the end of\n  /// this DRE.\n  bool hasFoundDecl() const { return DeclRefExprBits.HasFoundDecl; }\n\n  DeclRefExpr(const ASTContext &Ctx, NestedNameSpecifierLoc QualifierLoc,\n              SourceLocation TemplateKWLoc, ValueDecl *D,\n              bool RefersToEnlosingVariableOrCapture,\n              const DeclarationNameInfo &NameInfo, NamedDecl *FoundD,\n              const TemplateArgumentListInfo *TemplateArgs, QualType T,\n              ExprValueKind VK, NonOdrUseReason NOUR);\n\n  /// Construct an empty declaration reference expression.\n  explicit DeclRefExpr(EmptyShell Empty) : Expr(DeclRefExprClass, Empty) {}\n\npublic:\n  DeclRefExpr(const ASTContext &Ctx, ValueDecl *D,\n              bool RefersToEnclosingVariableOrCapture, QualType T,\n              ExprValueKind VK, SourceLocation L,\n              const DeclarationNameLoc &LocInfo = DeclarationNameLoc(),\n              NonOdrUseReason NOUR = NOUR_None);\n\n  static DeclRefExpr *\n  Create(const ASTContext &Context, NestedNameSpecifierLoc QualifierLoc,\n         SourceLocation TemplateKWLoc, ValueDecl *D,\n         bool RefersToEnclosingVariableOrCapture, SourceLocation NameLoc,\n         QualType T, ExprValueKind VK, NamedDecl *FoundD = nullptr,\n         const TemplateArgumentListInfo *TemplateArgs = nullptr,\n         NonOdrUseReason NOUR = NOUR_None);\n\n  static DeclRefExpr *\n  Create(const ASTContext &Context, NestedNameSpecifierLoc QualifierLoc,\n         SourceLocation TemplateKWLoc, ValueDecl *D,\n         bool RefersToEnclosingVariableOrCapture,\n         const DeclarationNameInfo &NameInfo, QualType T, ExprValueKind VK,\n         NamedDecl *FoundD = nullptr,\n         const TemplateArgumentListInfo *TemplateArgs = nullptr,\n         NonOdrUseReason NOUR = NOUR_None);\n\n  /// Construct an empty declaration reference expression.\n  static DeclRefExpr *CreateEmpty(const ASTContext &Context, bool HasQualifier,\n                                  bool HasFoundDecl,\n                                  bool HasTemplateKWAndArgsInfo,\n                                  unsigned NumTemplateArgs);\n\n  ValueDecl *getDecl() { return D; }\n  const ValueDecl *getDecl() const { return D; }\n  void setDecl(ValueDecl *NewD);\n\n  DeclarationNameInfo getNameInfo() const {\n    return DeclarationNameInfo(getDecl()->getDeclName(), getLocation(), DNLoc);\n  }\n\n  SourceLocation getLocation() const { return DeclRefExprBits.Loc; }\n  void setLocation(SourceLocation L) { DeclRefExprBits.Loc = L; }\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  /// Determine whether this declaration reference was preceded by a\n  /// C++ nested-name-specifier, e.g., \\c N::foo.\n  bool hasQualifier() const { return DeclRefExprBits.HasQualifier; }\n\n  /// If the name was qualified, retrieves the nested-name-specifier\n  /// that precedes the name, with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const {\n    if (!hasQualifier())\n      return NestedNameSpecifierLoc();\n    return *getTrailingObjects<NestedNameSpecifierLoc>();\n  }\n\n  /// If the name was qualified, retrieves the nested-name-specifier\n  /// that precedes the name. Otherwise, returns NULL.\n  NestedNameSpecifier *getQualifier() const {\n    return getQualifierLoc().getNestedNameSpecifier();\n  }\n\n  /// Get the NamedDecl through which this reference occurred.\n  ///\n  /// This Decl may be different from the ValueDecl actually referred to in the\n  /// presence of using declarations, etc. It always returns non-NULL, and may\n  /// simple return the ValueDecl when appropriate.\n\n  NamedDecl *getFoundDecl() {\n    return hasFoundDecl() ? *getTrailingObjects<NamedDecl *>() : D;\n  }\n\n  /// Get the NamedDecl through which this reference occurred.\n  /// See non-const variant.\n  const NamedDecl *getFoundDecl() const {\n    return hasFoundDecl() ? *getTrailingObjects<NamedDecl *>() : D;\n  }\n\n  bool hasTemplateKWAndArgsInfo() const {\n    return DeclRefExprBits.HasTemplateKWAndArgsInfo;\n  }\n\n  /// Retrieve the location of the template keyword preceding\n  /// this name, if any.\n  SourceLocation getTemplateKeywordLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->TemplateKWLoc;\n  }\n\n  /// Retrieve the location of the left angle bracket starting the\n  /// explicit template argument list following the name, if any.\n  SourceLocation getLAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->LAngleLoc;\n  }\n\n  /// Retrieve the location of the right angle bracket ending the\n  /// explicit template argument list following the name, if any.\n  SourceLocation getRAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->RAngleLoc;\n  }\n\n  /// Determines whether the name in this declaration reference\n  /// was preceded by the template keyword.\n  bool hasTemplateKeyword() const { return getTemplateKeywordLoc().isValid(); }\n\n  /// Determines whether this declaration reference was followed by an\n  /// explicit template argument list.\n  bool hasExplicitTemplateArgs() const { return getLAngleLoc().isValid(); }\n\n  /// Copies the template arguments (if present) into the given\n  /// structure.\n  void copyTemplateArgumentsInto(TemplateArgumentListInfo &List) const {\n    if (hasExplicitTemplateArgs())\n      getTrailingObjects<ASTTemplateKWAndArgsInfo>()->copyInto(\n          getTrailingObjects<TemplateArgumentLoc>(), List);\n  }\n\n  /// Retrieve the template arguments provided as part of this\n  /// template-id.\n  const TemplateArgumentLoc *getTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return nullptr;\n    return getTrailingObjects<TemplateArgumentLoc>();\n  }\n\n  /// Retrieve the number of template arguments provided as part of this\n  /// template-id.\n  unsigned getNumTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return 0;\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->NumTemplateArgs;\n  }\n\n  ArrayRef<TemplateArgumentLoc> template_arguments() const {\n    return {getTemplateArgs(), getNumTemplateArgs()};\n  }\n\n  /// Returns true if this expression refers to a function that\n  /// was resolved from an overloaded set having size greater than 1.\n  bool hadMultipleCandidates() const {\n    return DeclRefExprBits.HadMultipleCandidates;\n  }\n  /// Sets the flag telling whether this expression refers to\n  /// a function that was resolved from an overloaded set having size\n  /// greater than 1.\n  void setHadMultipleCandidates(bool V = true) {\n    DeclRefExprBits.HadMultipleCandidates = V;\n  }\n\n  /// Is this expression a non-odr-use reference, and if so, why?\n  NonOdrUseReason isNonOdrUse() const {\n    return static_cast<NonOdrUseReason>(DeclRefExprBits.NonOdrUseReason);\n  }\n\n  /// Does this DeclRefExpr refer to an enclosing local or a captured\n  /// variable?\n  bool refersToEnclosingVariableOrCapture() const {\n    return DeclRefExprBits.RefersToEnclosingVariableOrCapture;\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == DeclRefExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Used by IntegerLiteral/FloatingLiteral to store the numeric without\n/// leaking memory.\n///\n/// For large floats/integers, APFloat/APInt will allocate memory from the heap\n/// to represent these numbers.  Unfortunately, when we use a BumpPtrAllocator\n/// to allocate IntegerLiteral/FloatingLiteral nodes the memory associated with\n/// the APFloat/APInt values will never get freed. APNumericStorage uses\n/// ASTContext's allocator for memory allocation.\nclass APNumericStorage {\n  union {\n    uint64_t VAL;    ///< Used to store the <= 64 bits integer value.\n    uint64_t *pVal;  ///< Used to store the >64 bits integer value.\n  };\n  unsigned BitWidth;\n\n  bool hasAllocation() const { return llvm::APInt::getNumWords(BitWidth) > 1; }\n\n  APNumericStorage(const APNumericStorage &) = delete;\n  void operator=(const APNumericStorage &) = delete;\n\nprotected:\n  APNumericStorage() : VAL(0), BitWidth(0) { }\n\n  llvm::APInt getIntValue() const {\n    unsigned NumWords = llvm::APInt::getNumWords(BitWidth);\n    if (NumWords > 1)\n      return llvm::APInt(BitWidth, NumWords, pVal);\n    else\n      return llvm::APInt(BitWidth, VAL);\n  }\n  void setIntValue(const ASTContext &C, const llvm::APInt &Val);\n};\n\nclass APIntStorage : private APNumericStorage {\npublic:\n  llvm::APInt getValue() const { return getIntValue(); }\n  void setValue(const ASTContext &C, const llvm::APInt &Val) {\n    setIntValue(C, Val);\n  }\n};\n\nclass APFloatStorage : private APNumericStorage {\npublic:\n  llvm::APFloat getValue(const llvm::fltSemantics &Semantics) const {\n    return llvm::APFloat(Semantics, getIntValue());\n  }\n  void setValue(const ASTContext &C, const llvm::APFloat &Val) {\n    setIntValue(C, Val.bitcastToAPInt());\n  }\n};\n\nclass IntegerLiteral : public Expr, public APIntStorage {\n  SourceLocation Loc;\n\n  /// Construct an empty integer literal.\n  explicit IntegerLiteral(EmptyShell Empty)\n    : Expr(IntegerLiteralClass, Empty) { }\n\npublic:\n  // type should be IntTy, LongTy, LongLongTy, UnsignedIntTy, UnsignedLongTy,\n  // or UnsignedLongLongTy\n  IntegerLiteral(const ASTContext &C, const llvm::APInt &V, QualType type,\n                 SourceLocation l);\n\n  /// Returns a new integer literal with value 'V' and type 'type'.\n  /// \\param type - either IntTy, LongTy, LongLongTy, UnsignedIntTy,\n  /// UnsignedLongTy, or UnsignedLongLongTy which should match the size of V\n  /// \\param V - the value that the returned integer literal contains.\n  static IntegerLiteral *Create(const ASTContext &C, const llvm::APInt &V,\n                                QualType type, SourceLocation l);\n  /// Returns a new empty integer literal.\n  static IntegerLiteral *Create(const ASTContext &C, EmptyShell Empty);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Loc; }\n\n  /// Retrieve the location of the literal.\n  SourceLocation getLocation() const { return Loc; }\n\n  void setLocation(SourceLocation Location) { Loc = Location; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == IntegerLiteralClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\nclass FixedPointLiteral : public Expr, public APIntStorage {\n  SourceLocation Loc;\n  unsigned Scale;\n\n  /// \\brief Construct an empty fixed-point literal.\n  explicit FixedPointLiteral(EmptyShell Empty)\n      : Expr(FixedPointLiteralClass, Empty) {}\n\n public:\n  FixedPointLiteral(const ASTContext &C, const llvm::APInt &V, QualType type,\n                    SourceLocation l, unsigned Scale);\n\n  // Store the int as is without any bit shifting.\n  static FixedPointLiteral *CreateFromRawInt(const ASTContext &C,\n                                             const llvm::APInt &V,\n                                             QualType type, SourceLocation l,\n                                             unsigned Scale);\n\n  /// Returns an empty fixed-point literal.\n  static FixedPointLiteral *Create(const ASTContext &C, EmptyShell Empty);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Loc; }\n\n  /// \\brief Retrieve the location of the literal.\n  SourceLocation getLocation() const { return Loc; }\n\n  void setLocation(SourceLocation Location) { Loc = Location; }\n\n  unsigned getScale() const { return Scale; }\n  void setScale(unsigned S) { Scale = S; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == FixedPointLiteralClass;\n  }\n\n  std::string getValueAsString(unsigned Radix) const;\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\nclass CharacterLiteral : public Expr {\npublic:\n  enum CharacterKind {\n    Ascii,\n    Wide,\n    UTF8,\n    UTF16,\n    UTF32\n  };\n\nprivate:\n  unsigned Value;\n  SourceLocation Loc;\npublic:\n  // type should be IntTy\n  CharacterLiteral(unsigned value, CharacterKind kind, QualType type,\n                   SourceLocation l)\n      : Expr(CharacterLiteralClass, type, VK_RValue, OK_Ordinary), Value(value),\n        Loc(l) {\n    CharacterLiteralBits.Kind = kind;\n    setDependence(ExprDependence::None);\n  }\n\n  /// Construct an empty character literal.\n  CharacterLiteral(EmptyShell Empty) : Expr(CharacterLiteralClass, Empty) { }\n\n  SourceLocation getLocation() const { return Loc; }\n  CharacterKind getKind() const {\n    return static_cast<CharacterKind>(CharacterLiteralBits.Kind);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Loc; }\n\n  unsigned getValue() const { return Value; }\n\n  void setLocation(SourceLocation Location) { Loc = Location; }\n  void setKind(CharacterKind kind) { CharacterLiteralBits.Kind = kind; }\n  void setValue(unsigned Val) { Value = Val; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CharacterLiteralClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\nclass FloatingLiteral : public Expr, private APFloatStorage {\n  SourceLocation Loc;\n\n  FloatingLiteral(const ASTContext &C, const llvm::APFloat &V, bool isexact,\n                  QualType Type, SourceLocation L);\n\n  /// Construct an empty floating-point literal.\n  explicit FloatingLiteral(const ASTContext &C, EmptyShell Empty);\n\npublic:\n  static FloatingLiteral *Create(const ASTContext &C, const llvm::APFloat &V,\n                                 bool isexact, QualType Type, SourceLocation L);\n  static FloatingLiteral *Create(const ASTContext &C, EmptyShell Empty);\n\n  llvm::APFloat getValue() const {\n    return APFloatStorage::getValue(getSemantics());\n  }\n  void setValue(const ASTContext &C, const llvm::APFloat &Val) {\n    assert(&getSemantics() == &Val.getSemantics() && \"Inconsistent semantics\");\n    APFloatStorage::setValue(C, Val);\n  }\n\n  /// Get a raw enumeration value representing the floating-point semantics of\n  /// this literal (32-bit IEEE, x87, ...), suitable for serialisation.\n  llvm::APFloatBase::Semantics getRawSemantics() const {\n    return static_cast<llvm::APFloatBase::Semantics>(\n        FloatingLiteralBits.Semantics);\n  }\n\n  /// Set the raw enumeration value representing the floating-point semantics of\n  /// this literal (32-bit IEEE, x87, ...), suitable for serialisation.\n  void setRawSemantics(llvm::APFloatBase::Semantics Sem) {\n    FloatingLiteralBits.Semantics = Sem;\n  }\n\n  /// Return the APFloat semantics this literal uses.\n  const llvm::fltSemantics &getSemantics() const {\n    return llvm::APFloatBase::EnumToSemantics(\n        static_cast<llvm::APFloatBase::Semantics>(\n            FloatingLiteralBits.Semantics));\n  }\n\n  /// Set the APFloat semantics this literal uses.\n  void setSemantics(const llvm::fltSemantics &Sem) {\n    FloatingLiteralBits.Semantics = llvm::APFloatBase::SemanticsToEnum(Sem);\n  }\n\n  bool isExact() const { return FloatingLiteralBits.IsExact; }\n  void setExact(bool E) { FloatingLiteralBits.IsExact = E; }\n\n  /// getValueAsApproximateDouble - This returns the value as an inaccurate\n  /// double.  Note that this may cause loss of precision, but is useful for\n  /// debugging dumps, etc.\n  double getValueAsApproximateDouble() const;\n\n  SourceLocation getLocation() const { return Loc; }\n  void setLocation(SourceLocation L) { Loc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Loc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == FloatingLiteralClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// ImaginaryLiteral - We support imaginary integer and floating point literals,\n/// like \"1.0i\".  We represent these as a wrapper around FloatingLiteral and\n/// IntegerLiteral classes.  Instances of this class always have a Complex type\n/// whose element type matches the subexpression.\n///\nclass ImaginaryLiteral : public Expr {\n  Stmt *Val;\npublic:\n  ImaginaryLiteral(Expr *val, QualType Ty)\n      : Expr(ImaginaryLiteralClass, Ty, VK_RValue, OK_Ordinary), Val(val) {\n    setDependence(ExprDependence::None);\n  }\n\n  /// Build an empty imaginary literal.\n  explicit ImaginaryLiteral(EmptyShell Empty)\n    : Expr(ImaginaryLiteralClass, Empty) { }\n\n  const Expr *getSubExpr() const { return cast<Expr>(Val); }\n  Expr *getSubExpr() { return cast<Expr>(Val); }\n  void setSubExpr(Expr *E) { Val = E; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return Val->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Val->getEndLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ImaginaryLiteralClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Val, &Val+1); }\n  const_child_range children() const {\n    return const_child_range(&Val, &Val + 1);\n  }\n};\n\n/// StringLiteral - This represents a string literal expression, e.g. \"foo\"\n/// or L\"bar\" (wide strings). The actual string data can be obtained with\n/// getBytes() and is NOT null-terminated. The length of the string data is\n/// determined by calling getByteLength().\n///\n/// The C type for a string is always a ConstantArrayType. In C++, the char\n/// type is const qualified, in C it is not.\n///\n/// Note that strings in C can be formed by concatenation of multiple string\n/// literal pptokens in translation phase #6. This keeps track of the locations\n/// of each of these pieces.\n///\n/// Strings in C can also be truncated and extended by assigning into arrays,\n/// e.g. with constructs like:\n///   char X[2] = \"foobar\";\n/// In this case, getByteLength() will return 6, but the string literal will\n/// have type \"char[2]\".\nclass StringLiteral final\n    : public Expr,\n      private llvm::TrailingObjects<StringLiteral, unsigned, SourceLocation,\n                                    char> {\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  /// StringLiteral is followed by several trailing objects. They are in order:\n  ///\n  /// * A single unsigned storing the length in characters of this string. The\n  ///   length in bytes is this length times the width of a single character.\n  ///   Always present and stored as a trailing objects because storing it in\n  ///   StringLiteral would increase the size of StringLiteral by sizeof(void *)\n  ///   due to alignment requirements. If you add some data to StringLiteral,\n  ///   consider moving it inside StringLiteral.\n  ///\n  /// * An array of getNumConcatenated() SourceLocation, one for each of the\n  ///   token this string is made of.\n  ///\n  /// * An array of getByteLength() char used to store the string data.\n\npublic:\n  enum StringKind { Ascii, Wide, UTF8, UTF16, UTF32 };\n\nprivate:\n  unsigned numTrailingObjects(OverloadToken<unsigned>) const { return 1; }\n  unsigned numTrailingObjects(OverloadToken<SourceLocation>) const {\n    return getNumConcatenated();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<char>) const {\n    return getByteLength();\n  }\n\n  char *getStrDataAsChar() { return getTrailingObjects<char>(); }\n  const char *getStrDataAsChar() const { return getTrailingObjects<char>(); }\n\n  const uint16_t *getStrDataAsUInt16() const {\n    return reinterpret_cast<const uint16_t *>(getTrailingObjects<char>());\n  }\n\n  const uint32_t *getStrDataAsUInt32() const {\n    return reinterpret_cast<const uint32_t *>(getTrailingObjects<char>());\n  }\n\n  /// Build a string literal.\n  StringLiteral(const ASTContext &Ctx, StringRef Str, StringKind Kind,\n                bool Pascal, QualType Ty, const SourceLocation *Loc,\n                unsigned NumConcatenated);\n\n  /// Build an empty string literal.\n  StringLiteral(EmptyShell Empty, unsigned NumConcatenated, unsigned Length,\n                unsigned CharByteWidth);\n\n  /// Map a target and string kind to the appropriate character width.\n  static unsigned mapCharByteWidth(TargetInfo const &Target, StringKind SK);\n\n  /// Set one of the string literal token.\n  void setStrTokenLoc(unsigned TokNum, SourceLocation L) {\n    assert(TokNum < getNumConcatenated() && \"Invalid tok number\");\n    getTrailingObjects<SourceLocation>()[TokNum] = L;\n  }\n\npublic:\n  /// This is the \"fully general\" constructor that allows representation of\n  /// strings formed from multiple concatenated tokens.\n  static StringLiteral *Create(const ASTContext &Ctx, StringRef Str,\n                               StringKind Kind, bool Pascal, QualType Ty,\n                               const SourceLocation *Loc,\n                               unsigned NumConcatenated);\n\n  /// Simple constructor for string literals made from one token.\n  static StringLiteral *Create(const ASTContext &Ctx, StringRef Str,\n                               StringKind Kind, bool Pascal, QualType Ty,\n                               SourceLocation Loc) {\n    return Create(Ctx, Str, Kind, Pascal, Ty, &Loc, 1);\n  }\n\n  /// Construct an empty string literal.\n  static StringLiteral *CreateEmpty(const ASTContext &Ctx,\n                                    unsigned NumConcatenated, unsigned Length,\n                                    unsigned CharByteWidth);\n\n  StringRef getString() const {\n    assert(getCharByteWidth() == 1 &&\n           \"This function is used in places that assume strings use char\");\n    return StringRef(getStrDataAsChar(), getByteLength());\n  }\n\n  /// Allow access to clients that need the byte representation, such as\n  /// ASTWriterStmt::VisitStringLiteral().\n  StringRef getBytes() const {\n    // FIXME: StringRef may not be the right type to use as a result for this.\n    return StringRef(getStrDataAsChar(), getByteLength());\n  }\n\n  void outputString(raw_ostream &OS) const;\n\n  uint32_t getCodeUnit(size_t i) const {\n    assert(i < getLength() && \"out of bounds access\");\n    switch (getCharByteWidth()) {\n    case 1:\n      return static_cast<unsigned char>(getStrDataAsChar()[i]);\n    case 2:\n      return getStrDataAsUInt16()[i];\n    case 4:\n      return getStrDataAsUInt32()[i];\n    }\n    llvm_unreachable(\"Unsupported character width!\");\n  }\n\n  unsigned getByteLength() const { return getCharByteWidth() * getLength(); }\n  unsigned getLength() const { return *getTrailingObjects<unsigned>(); }\n  unsigned getCharByteWidth() const { return StringLiteralBits.CharByteWidth; }\n\n  StringKind getKind() const {\n    return static_cast<StringKind>(StringLiteralBits.Kind);\n  }\n\n  bool isAscii() const { return getKind() == Ascii; }\n  bool isWide() const { return getKind() == Wide; }\n  bool isUTF8() const { return getKind() == UTF8; }\n  bool isUTF16() const { return getKind() == UTF16; }\n  bool isUTF32() const { return getKind() == UTF32; }\n  bool isPascal() const { return StringLiteralBits.IsPascal; }\n\n  bool containsNonAscii() const {\n    for (auto c : getString())\n      if (!isASCII(c))\n        return true;\n    return false;\n  }\n\n  bool containsNonAsciiOrNull() const {\n    for (auto c : getString())\n      if (!isASCII(c) || !c)\n        return true;\n    return false;\n  }\n\n  /// getNumConcatenated - Get the number of string literal tokens that were\n  /// concatenated in translation phase #6 to form this string literal.\n  unsigned getNumConcatenated() const {\n    return StringLiteralBits.NumConcatenated;\n  }\n\n  /// Get one of the string literal token.\n  SourceLocation getStrTokenLoc(unsigned TokNum) const {\n    assert(TokNum < getNumConcatenated() && \"Invalid tok number\");\n    return getTrailingObjects<SourceLocation>()[TokNum];\n  }\n\n  /// getLocationOfByte - Return a source location that points to the specified\n  /// byte of this string literal.\n  ///\n  /// Strings are amazingly complex.  They can be formed from multiple tokens\n  /// and can have escape sequences in them in addition to the usual trigraph\n  /// and escaped newline business.  This routine handles this complexity.\n  ///\n  SourceLocation\n  getLocationOfByte(unsigned ByteNo, const SourceManager &SM,\n                    const LangOptions &Features, const TargetInfo &Target,\n                    unsigned *StartToken = nullptr,\n                    unsigned *StartTokenByteOffset = nullptr) const;\n\n  typedef const SourceLocation *tokloc_iterator;\n\n  tokloc_iterator tokloc_begin() const {\n    return getTrailingObjects<SourceLocation>();\n  }\n\n  tokloc_iterator tokloc_end() const {\n    return getTrailingObjects<SourceLocation>() + getNumConcatenated();\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return *tokloc_begin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return *(tokloc_end() - 1); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == StringLiteralClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// [C99 6.4.2.2] - A predefined identifier such as __func__.\nclass PredefinedExpr final\n    : public Expr,\n      private llvm::TrailingObjects<PredefinedExpr, Stmt *> {\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  // PredefinedExpr is optionally followed by a single trailing\n  // \"Stmt *\" for the predefined identifier. It is present if and only if\n  // hasFunctionName() is true and is always a \"StringLiteral *\".\n\npublic:\n  enum IdentKind {\n    Func,\n    Function,\n    LFunction, // Same as Function, but as wide string.\n    FuncDName,\n    FuncSig,\n    LFuncSig, // Same as FuncSig, but as as wide string\n    PrettyFunction,\n    /// The same as PrettyFunction, except that the\n    /// 'virtual' keyword is omitted for virtual member functions.\n    PrettyFunctionNoVirtual\n  };\n\nprivate:\n  PredefinedExpr(SourceLocation L, QualType FNTy, IdentKind IK,\n                 StringLiteral *SL);\n\n  explicit PredefinedExpr(EmptyShell Empty, bool HasFunctionName);\n\n  /// True if this PredefinedExpr has storage for a function name.\n  bool hasFunctionName() const { return PredefinedExprBits.HasFunctionName; }\n\n  void setFunctionName(StringLiteral *SL) {\n    assert(hasFunctionName() &&\n           \"This PredefinedExpr has no storage for a function name!\");\n    *getTrailingObjects<Stmt *>() = SL;\n  }\n\npublic:\n  /// Create a PredefinedExpr.\n  static PredefinedExpr *Create(const ASTContext &Ctx, SourceLocation L,\n                                QualType FNTy, IdentKind IK, StringLiteral *SL);\n\n  /// Create an empty PredefinedExpr.\n  static PredefinedExpr *CreateEmpty(const ASTContext &Ctx,\n                                     bool HasFunctionName);\n\n  IdentKind getIdentKind() const {\n    return static_cast<IdentKind>(PredefinedExprBits.Kind);\n  }\n\n  SourceLocation getLocation() const { return PredefinedExprBits.Loc; }\n  void setLocation(SourceLocation L) { PredefinedExprBits.Loc = L; }\n\n  StringLiteral *getFunctionName() {\n    return hasFunctionName()\n               ? static_cast<StringLiteral *>(*getTrailingObjects<Stmt *>())\n               : nullptr;\n  }\n\n  const StringLiteral *getFunctionName() const {\n    return hasFunctionName()\n               ? static_cast<StringLiteral *>(*getTrailingObjects<Stmt *>())\n               : nullptr;\n  }\n\n  static StringRef getIdentKindName(IdentKind IK);\n  StringRef getIdentKindName() const {\n    return getIdentKindName(getIdentKind());\n  }\n\n  static std::string ComputeName(IdentKind IK, const Decl *CurrentDecl);\n\n  SourceLocation getBeginLoc() const { return getLocation(); }\n  SourceLocation getEndLoc() const { return getLocation(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == PredefinedExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(getTrailingObjects<Stmt *>(),\n                       getTrailingObjects<Stmt *>() + hasFunctionName());\n  }\n\n  const_child_range children() const {\n    return const_child_range(getTrailingObjects<Stmt *>(),\n                             getTrailingObjects<Stmt *>() + hasFunctionName());\n  }\n};\n\n/// ParenExpr - This represents a parethesized expression, e.g. \"(1)\".  This\n/// AST node is only formed if full location information is requested.\nclass ParenExpr : public Expr {\n  SourceLocation L, R;\n  Stmt *Val;\npublic:\n  ParenExpr(SourceLocation l, SourceLocation r, Expr *val)\n      : Expr(ParenExprClass, val->getType(), val->getValueKind(),\n             val->getObjectKind()),\n        L(l), R(r), Val(val) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Construct an empty parenthesized expression.\n  explicit ParenExpr(EmptyShell Empty)\n    : Expr(ParenExprClass, Empty) { }\n\n  const Expr *getSubExpr() const { return cast<Expr>(Val); }\n  Expr *getSubExpr() { return cast<Expr>(Val); }\n  void setSubExpr(Expr *E) { Val = E; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return L; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return R; }\n\n  /// Get the location of the left parentheses '('.\n  SourceLocation getLParen() const { return L; }\n  void setLParen(SourceLocation Loc) { L = Loc; }\n\n  /// Get the location of the right parentheses ')'.\n  SourceLocation getRParen() const { return R; }\n  void setRParen(SourceLocation Loc) { R = Loc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ParenExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Val, &Val+1); }\n  const_child_range children() const {\n    return const_child_range(&Val, &Val + 1);\n  }\n};\n\n/// UnaryOperator - This represents the unary-expression's (except sizeof and\n/// alignof), the postinc/postdec operators from postfix-expression, and various\n/// extensions.\n///\n/// Notes on various nodes:\n///\n/// Real/Imag - These return the real/imag part of a complex operand.  If\n///   applied to a non-complex value, the former returns its operand and the\n///   later returns zero in the type of the operand.\n///\nclass UnaryOperator final\n    : public Expr,\n      private llvm::TrailingObjects<UnaryOperator, FPOptionsOverride> {\n  Stmt *Val;\n\n  size_t numTrailingObjects(OverloadToken<FPOptionsOverride>) const {\n    return UnaryOperatorBits.HasFPFeatures ? 1 : 0;\n  }\n\n  FPOptionsOverride &getTrailingFPFeatures() {\n    assert(UnaryOperatorBits.HasFPFeatures);\n    return *getTrailingObjects<FPOptionsOverride>();\n  }\n\n  const FPOptionsOverride &getTrailingFPFeatures() const {\n    assert(UnaryOperatorBits.HasFPFeatures);\n    return *getTrailingObjects<FPOptionsOverride>();\n  }\n\npublic:\n  typedef UnaryOperatorKind Opcode;\n\nprotected:\n  UnaryOperator(const ASTContext &Ctx, Expr *input, Opcode opc, QualType type,\n                ExprValueKind VK, ExprObjectKind OK, SourceLocation l,\n                bool CanOverflow, FPOptionsOverride FPFeatures);\n\n  /// Build an empty unary operator.\n  explicit UnaryOperator(bool HasFPFeatures, EmptyShell Empty)\n      : Expr(UnaryOperatorClass, Empty) {\n    UnaryOperatorBits.Opc = UO_AddrOf;\n    UnaryOperatorBits.HasFPFeatures = HasFPFeatures;\n  }\n\npublic:\n  static UnaryOperator *CreateEmpty(const ASTContext &C, bool hasFPFeatures);\n\n  static UnaryOperator *Create(const ASTContext &C, Expr *input, Opcode opc,\n                               QualType type, ExprValueKind VK,\n                               ExprObjectKind OK, SourceLocation l,\n                               bool CanOverflow, FPOptionsOverride FPFeatures);\n\n  Opcode getOpcode() const {\n    return static_cast<Opcode>(UnaryOperatorBits.Opc);\n  }\n  void setOpcode(Opcode Opc) { UnaryOperatorBits.Opc = Opc; }\n\n  Expr *getSubExpr() const { return cast<Expr>(Val); }\n  void setSubExpr(Expr *E) { Val = E; }\n\n  /// getOperatorLoc - Return the location of the operator.\n  SourceLocation getOperatorLoc() const { return UnaryOperatorBits.Loc; }\n  void setOperatorLoc(SourceLocation L) { UnaryOperatorBits.Loc = L; }\n\n  /// Returns true if the unary operator can cause an overflow. For instance,\n  ///   signed int i = INT_MAX; i++;\n  ///   signed char c = CHAR_MAX; c++;\n  /// Due to integer promotions, c++ is promoted to an int before the postfix\n  /// increment, and the result is an int that cannot overflow. However, i++\n  /// can overflow.\n  bool canOverflow() const { return UnaryOperatorBits.CanOverflow; }\n  void setCanOverflow(bool C) { UnaryOperatorBits.CanOverflow = C; }\n\n  // Get the FP contractability status of this operator. Only meaningful for\n  // operations on floating point types.\n  bool isFPContractableWithinStatement(const LangOptions &LO) const {\n    return getFPFeaturesInEffect(LO).allowFPContractWithinStatement();\n  }\n\n  // Get the FENV_ACCESS status of this operator. Only meaningful for\n  // operations on floating point types.\n  bool isFEnvAccessOn(const LangOptions &LO) const {\n    return getFPFeaturesInEffect(LO).getAllowFEnvAccess();\n  }\n\n  /// isPostfix - Return true if this is a postfix operation, like x++.\n  static bool isPostfix(Opcode Op) {\n    return Op == UO_PostInc || Op == UO_PostDec;\n  }\n\n  /// isPrefix - Return true if this is a prefix operation, like --x.\n  static bool isPrefix(Opcode Op) {\n    return Op == UO_PreInc || Op == UO_PreDec;\n  }\n\n  bool isPrefix() const { return isPrefix(getOpcode()); }\n  bool isPostfix() const { return isPostfix(getOpcode()); }\n\n  static bool isIncrementOp(Opcode Op) {\n    return Op == UO_PreInc || Op == UO_PostInc;\n  }\n  bool isIncrementOp() const {\n    return isIncrementOp(getOpcode());\n  }\n\n  static bool isDecrementOp(Opcode Op) {\n    return Op == UO_PreDec || Op == UO_PostDec;\n  }\n  bool isDecrementOp() const {\n    return isDecrementOp(getOpcode());\n  }\n\n  static bool isIncrementDecrementOp(Opcode Op) { return Op <= UO_PreDec; }\n  bool isIncrementDecrementOp() const {\n    return isIncrementDecrementOp(getOpcode());\n  }\n\n  static bool isArithmeticOp(Opcode Op) {\n    return Op >= UO_Plus && Op <= UO_LNot;\n  }\n  bool isArithmeticOp() const { return isArithmeticOp(getOpcode()); }\n\n  /// getOpcodeStr - Turn an Opcode enum value into the punctuation char it\n  /// corresponds to, e.g. \"sizeof\" or \"[pre]++\"\n  static StringRef getOpcodeStr(Opcode Op);\n\n  /// Retrieve the unary opcode that corresponds to the given\n  /// overloaded operator.\n  static Opcode getOverloadedOpcode(OverloadedOperatorKind OO, bool Postfix);\n\n  /// Retrieve the overloaded operator kind that corresponds to\n  /// the given unary opcode.\n  static OverloadedOperatorKind getOverloadedOperator(Opcode Opc);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return isPostfix() ? Val->getBeginLoc() : getOperatorLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return isPostfix() ? getOperatorLoc() : Val->getEndLoc();\n  }\n  SourceLocation getExprLoc() const { return getOperatorLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == UnaryOperatorClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Val, &Val+1); }\n  const_child_range children() const {\n    return const_child_range(&Val, &Val + 1);\n  }\n\n  /// Is FPFeatures in Trailing Storage?\n  bool hasStoredFPFeatures() const { return UnaryOperatorBits.HasFPFeatures; }\n\n  /// Get FPFeatures from trailing storage.\n  FPOptionsOverride getStoredFPFeatures() const {\n    return getTrailingFPFeatures();\n  }\n\nprotected:\n  /// Set FPFeatures in trailing storage, used only by Serialization\n  void setStoredFPFeatures(FPOptionsOverride F) { getTrailingFPFeatures() = F; }\n\npublic:\n  // Get the FP features status of this operator. Only meaningful for\n  // operations on floating point types.\n  FPOptions getFPFeaturesInEffect(const LangOptions &LO) const {\n    if (UnaryOperatorBits.HasFPFeatures)\n      return getStoredFPFeatures().applyOverrides(LO);\n    return FPOptions::defaultWithoutTrailingStorage(LO);\n  }\n  FPOptionsOverride getFPOptionsOverride() const {\n    if (UnaryOperatorBits.HasFPFeatures)\n      return getStoredFPFeatures();\n    return FPOptionsOverride();\n  }\n\n  friend TrailingObjects;\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n};\n\n/// Helper class for OffsetOfExpr.\n\n// __builtin_offsetof(type, identifier(.identifier|[expr])*)\nclass OffsetOfNode {\npublic:\n  /// The kind of offsetof node we have.\n  enum Kind {\n    /// An index into an array.\n    Array = 0x00,\n    /// A field.\n    Field = 0x01,\n    /// A field in a dependent type, known only by its name.\n    Identifier = 0x02,\n    /// An implicit indirection through a C++ base class, when the\n    /// field found is in a base class.\n    Base = 0x03\n  };\n\nprivate:\n  enum { MaskBits = 2, Mask = 0x03 };\n\n  /// The source range that covers this part of the designator.\n  SourceRange Range;\n\n  /// The data describing the designator, which comes in three\n  /// different forms, depending on the lower two bits.\n  ///   - An unsigned index into the array of Expr*'s stored after this node\n  ///     in memory, for [constant-expression] designators.\n  ///   - A FieldDecl*, for references to a known field.\n  ///   - An IdentifierInfo*, for references to a field with a given name\n  ///     when the class type is dependent.\n  ///   - A CXXBaseSpecifier*, for references that look at a field in a\n  ///     base class.\n  uintptr_t Data;\n\npublic:\n  /// Create an offsetof node that refers to an array element.\n  OffsetOfNode(SourceLocation LBracketLoc, unsigned Index,\n               SourceLocation RBracketLoc)\n      : Range(LBracketLoc, RBracketLoc), Data((Index << 2) | Array) {}\n\n  /// Create an offsetof node that refers to a field.\n  OffsetOfNode(SourceLocation DotLoc, FieldDecl *Field, SourceLocation NameLoc)\n      : Range(DotLoc.isValid() ? DotLoc : NameLoc, NameLoc),\n        Data(reinterpret_cast<uintptr_t>(Field) | OffsetOfNode::Field) {}\n\n  /// Create an offsetof node that refers to an identifier.\n  OffsetOfNode(SourceLocation DotLoc, IdentifierInfo *Name,\n               SourceLocation NameLoc)\n      : Range(DotLoc.isValid() ? DotLoc : NameLoc, NameLoc),\n        Data(reinterpret_cast<uintptr_t>(Name) | Identifier) {}\n\n  /// Create an offsetof node that refers into a C++ base class.\n  explicit OffsetOfNode(const CXXBaseSpecifier *Base)\n      : Range(), Data(reinterpret_cast<uintptr_t>(Base) | OffsetOfNode::Base) {}\n\n  /// Determine what kind of offsetof node this is.\n  Kind getKind() const { return static_cast<Kind>(Data & Mask); }\n\n  /// For an array element node, returns the index into the array\n  /// of expressions.\n  unsigned getArrayExprIndex() const {\n    assert(getKind() == Array);\n    return Data >> 2;\n  }\n\n  /// For a field offsetof node, returns the field.\n  FieldDecl *getField() const {\n    assert(getKind() == Field);\n    return reinterpret_cast<FieldDecl *>(Data & ~(uintptr_t)Mask);\n  }\n\n  /// For a field or identifier offsetof node, returns the name of\n  /// the field.\n  IdentifierInfo *getFieldName() const;\n\n  /// For a base class node, returns the base specifier.\n  CXXBaseSpecifier *getBase() const {\n    assert(getKind() == Base);\n    return reinterpret_cast<CXXBaseSpecifier *>(Data & ~(uintptr_t)Mask);\n  }\n\n  /// Retrieve the source range that covers this offsetof node.\n  ///\n  /// For an array element node, the source range contains the locations of\n  /// the square brackets. For a field or identifier node, the source range\n  /// contains the location of the period (if there is one) and the\n  /// identifier.\n  SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n};\n\n/// OffsetOfExpr - [C99 7.17] - This represents an expression of the form\n/// offsetof(record-type, member-designator). For example, given:\n/// @code\n/// struct S {\n///   float f;\n///   double d;\n/// };\n/// struct T {\n///   int i;\n///   struct S s[10];\n/// };\n/// @endcode\n/// we can represent and evaluate the expression @c offsetof(struct T, s[2].d).\n\nclass OffsetOfExpr final\n    : public Expr,\n      private llvm::TrailingObjects<OffsetOfExpr, OffsetOfNode, Expr *> {\n  SourceLocation OperatorLoc, RParenLoc;\n  // Base type;\n  TypeSourceInfo *TSInfo;\n  // Number of sub-components (i.e. instances of OffsetOfNode).\n  unsigned NumComps;\n  // Number of sub-expressions (i.e. array subscript expressions).\n  unsigned NumExprs;\n\n  size_t numTrailingObjects(OverloadToken<OffsetOfNode>) const {\n    return NumComps;\n  }\n\n  OffsetOfExpr(const ASTContext &C, QualType type,\n               SourceLocation OperatorLoc, TypeSourceInfo *tsi,\n               ArrayRef<OffsetOfNode> comps, ArrayRef<Expr*> exprs,\n               SourceLocation RParenLoc);\n\n  explicit OffsetOfExpr(unsigned numComps, unsigned numExprs)\n    : Expr(OffsetOfExprClass, EmptyShell()),\n      TSInfo(nullptr), NumComps(numComps), NumExprs(numExprs) {}\n\npublic:\n\n  static OffsetOfExpr *Create(const ASTContext &C, QualType type,\n                              SourceLocation OperatorLoc, TypeSourceInfo *tsi,\n                              ArrayRef<OffsetOfNode> comps,\n                              ArrayRef<Expr*> exprs, SourceLocation RParenLoc);\n\n  static OffsetOfExpr *CreateEmpty(const ASTContext &C,\n                                   unsigned NumComps, unsigned NumExprs);\n\n  /// getOperatorLoc - Return the location of the operator.\n  SourceLocation getOperatorLoc() const { return OperatorLoc; }\n  void setOperatorLoc(SourceLocation L) { OperatorLoc = L; }\n\n  /// Return the location of the right parentheses.\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation R) { RParenLoc = R; }\n\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return TSInfo;\n  }\n  void setTypeSourceInfo(TypeSourceInfo *tsi) {\n    TSInfo = tsi;\n  }\n\n  const OffsetOfNode &getComponent(unsigned Idx) const {\n    assert(Idx < NumComps && \"Subscript out of range\");\n    return getTrailingObjects<OffsetOfNode>()[Idx];\n  }\n\n  void setComponent(unsigned Idx, OffsetOfNode ON) {\n    assert(Idx < NumComps && \"Subscript out of range\");\n    getTrailingObjects<OffsetOfNode>()[Idx] = ON;\n  }\n\n  unsigned getNumComponents() const {\n    return NumComps;\n  }\n\n  Expr* getIndexExpr(unsigned Idx) {\n    assert(Idx < NumExprs && \"Subscript out of range\");\n    return getTrailingObjects<Expr *>()[Idx];\n  }\n\n  const Expr *getIndexExpr(unsigned Idx) const {\n    assert(Idx < NumExprs && \"Subscript out of range\");\n    return getTrailingObjects<Expr *>()[Idx];\n  }\n\n  void setIndexExpr(unsigned Idx, Expr* E) {\n    assert(Idx < NumComps && \"Subscript out of range\");\n    getTrailingObjects<Expr *>()[Idx] = E;\n  }\n\n  unsigned getNumExpressions() const {\n    return NumExprs;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return OperatorLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OffsetOfExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    Stmt **begin = reinterpret_cast<Stmt **>(getTrailingObjects<Expr *>());\n    return child_range(begin, begin + NumExprs);\n  }\n  const_child_range children() const {\n    Stmt *const *begin =\n        reinterpret_cast<Stmt *const *>(getTrailingObjects<Expr *>());\n    return const_child_range(begin, begin + NumExprs);\n  }\n  friend TrailingObjects;\n};\n\n/// UnaryExprOrTypeTraitExpr - expression with either a type or (unevaluated)\n/// expression operand.  Used for sizeof/alignof (C99 6.5.3.4) and\n/// vec_step (OpenCL 1.1 6.11.12).\nclass UnaryExprOrTypeTraitExpr : public Expr {\n  union {\n    TypeSourceInfo *Ty;\n    Stmt *Ex;\n  } Argument;\n  SourceLocation OpLoc, RParenLoc;\n\npublic:\n  UnaryExprOrTypeTraitExpr(UnaryExprOrTypeTrait ExprKind, TypeSourceInfo *TInfo,\n                           QualType resultType, SourceLocation op,\n                           SourceLocation rp)\n      : Expr(UnaryExprOrTypeTraitExprClass, resultType, VK_RValue, OK_Ordinary),\n        OpLoc(op), RParenLoc(rp) {\n    assert(ExprKind <= UETT_Last && \"invalid enum value!\");\n    UnaryExprOrTypeTraitExprBits.Kind = ExprKind;\n    assert(static_cast<unsigned>(ExprKind) ==\n               UnaryExprOrTypeTraitExprBits.Kind &&\n           \"UnaryExprOrTypeTraitExprBits.Kind overflow!\");\n    UnaryExprOrTypeTraitExprBits.IsType = true;\n    Argument.Ty = TInfo;\n    setDependence(computeDependence(this));\n  }\n\n  UnaryExprOrTypeTraitExpr(UnaryExprOrTypeTrait ExprKind, Expr *E,\n                           QualType resultType, SourceLocation op,\n                           SourceLocation rp);\n\n  /// Construct an empty sizeof/alignof expression.\n  explicit UnaryExprOrTypeTraitExpr(EmptyShell Empty)\n    : Expr(UnaryExprOrTypeTraitExprClass, Empty) { }\n\n  UnaryExprOrTypeTrait getKind() const {\n    return static_cast<UnaryExprOrTypeTrait>(UnaryExprOrTypeTraitExprBits.Kind);\n  }\n  void setKind(UnaryExprOrTypeTrait K) {\n    assert(K <= UETT_Last && \"invalid enum value!\");\n    UnaryExprOrTypeTraitExprBits.Kind = K;\n    assert(static_cast<unsigned>(K) == UnaryExprOrTypeTraitExprBits.Kind &&\n           \"UnaryExprOrTypeTraitExprBits.Kind overflow!\");\n  }\n\n  bool isArgumentType() const { return UnaryExprOrTypeTraitExprBits.IsType; }\n  QualType getArgumentType() const {\n    return getArgumentTypeInfo()->getType();\n  }\n  TypeSourceInfo *getArgumentTypeInfo() const {\n    assert(isArgumentType() && \"calling getArgumentType() when arg is expr\");\n    return Argument.Ty;\n  }\n  Expr *getArgumentExpr() {\n    assert(!isArgumentType() && \"calling getArgumentExpr() when arg is type\");\n    return static_cast<Expr*>(Argument.Ex);\n  }\n  const Expr *getArgumentExpr() const {\n    return const_cast<UnaryExprOrTypeTraitExpr*>(this)->getArgumentExpr();\n  }\n\n  void setArgument(Expr *E) {\n    Argument.Ex = E;\n    UnaryExprOrTypeTraitExprBits.IsType = false;\n  }\n  void setArgument(TypeSourceInfo *TInfo) {\n    Argument.Ty = TInfo;\n    UnaryExprOrTypeTraitExprBits.IsType = true;\n  }\n\n  /// Gets the argument type, or the type of the argument expression, whichever\n  /// is appropriate.\n  QualType getTypeOfArgument() const {\n    return isArgumentType() ? getArgumentType() : getArgumentExpr()->getType();\n  }\n\n  SourceLocation getOperatorLoc() const { return OpLoc; }\n  void setOperatorLoc(SourceLocation L) { OpLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return OpLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == UnaryExprOrTypeTraitExprClass;\n  }\n\n  // Iterators\n  child_range children();\n  const_child_range children() const;\n};\n\n//===----------------------------------------------------------------------===//\n// Postfix Operators.\n//===----------------------------------------------------------------------===//\n\n/// ArraySubscriptExpr - [C99 6.5.2.1] Array Subscripting.\nclass ArraySubscriptExpr : public Expr {\n  enum { LHS, RHS, END_EXPR };\n  Stmt *SubExprs[END_EXPR];\n\n  bool lhsIsBase() const { return getRHS()->getType()->isIntegerType(); }\n\npublic:\n  ArraySubscriptExpr(Expr *lhs, Expr *rhs, QualType t, ExprValueKind VK,\n                     ExprObjectKind OK, SourceLocation rbracketloc)\n      : Expr(ArraySubscriptExprClass, t, VK, OK) {\n    SubExprs[LHS] = lhs;\n    SubExprs[RHS] = rhs;\n    ArrayOrMatrixSubscriptExprBits.RBracketLoc = rbracketloc;\n    setDependence(computeDependence(this));\n  }\n\n  /// Create an empty array subscript expression.\n  explicit ArraySubscriptExpr(EmptyShell Shell)\n    : Expr(ArraySubscriptExprClass, Shell) { }\n\n  /// An array access can be written A[4] or 4[A] (both are equivalent).\n  /// - getBase() and getIdx() always present the normalized view: A[4].\n  ///    In this case getBase() returns \"A\" and getIdx() returns \"4\".\n  /// - getLHS() and getRHS() present the syntactic view. e.g. for\n  ///    4[A] getLHS() returns \"4\".\n  /// Note: Because vector element access is also written A[4] we must\n  /// predicate the format conversion in getBase and getIdx only on the\n  /// the type of the RHS, as it is possible for the LHS to be a vector of\n  /// integer type\n  Expr *getLHS() { return cast<Expr>(SubExprs[LHS]); }\n  const Expr *getLHS() const { return cast<Expr>(SubExprs[LHS]); }\n  void setLHS(Expr *E) { SubExprs[LHS] = E; }\n\n  Expr *getRHS() { return cast<Expr>(SubExprs[RHS]); }\n  const Expr *getRHS() const { return cast<Expr>(SubExprs[RHS]); }\n  void setRHS(Expr *E) { SubExprs[RHS] = E; }\n\n  Expr *getBase() { return lhsIsBase() ? getLHS() : getRHS(); }\n  const Expr *getBase() const { return lhsIsBase() ? getLHS() : getRHS(); }\n\n  Expr *getIdx() { return lhsIsBase() ? getRHS() : getLHS(); }\n  const Expr *getIdx() const { return lhsIsBase() ? getRHS() : getLHS(); }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getLHS()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const { return getRBracketLoc(); }\n\n  SourceLocation getRBracketLoc() const {\n    return ArrayOrMatrixSubscriptExprBits.RBracketLoc;\n  }\n  void setRBracketLoc(SourceLocation L) {\n    ArrayOrMatrixSubscriptExprBits.RBracketLoc = L;\n  }\n\n  SourceLocation getExprLoc() const LLVM_READONLY {\n    return getBase()->getExprLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ArraySubscriptExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0]+END_EXPR);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n};\n\n/// MatrixSubscriptExpr - Matrix subscript expression for the MatrixType\n/// extension.\n/// MatrixSubscriptExpr can be either incomplete (only Base and RowIdx are set\n/// so far, the type is IncompleteMatrixIdx) or complete (Base, RowIdx and\n/// ColumnIdx refer to valid expressions). Incomplete matrix expressions only\n/// exist during the initial construction of the AST.\nclass MatrixSubscriptExpr : public Expr {\n  enum { BASE, ROW_IDX, COLUMN_IDX, END_EXPR };\n  Stmt *SubExprs[END_EXPR];\n\npublic:\n  MatrixSubscriptExpr(Expr *Base, Expr *RowIdx, Expr *ColumnIdx, QualType T,\n                      SourceLocation RBracketLoc)\n      : Expr(MatrixSubscriptExprClass, T, Base->getValueKind(),\n             OK_MatrixComponent) {\n    SubExprs[BASE] = Base;\n    SubExprs[ROW_IDX] = RowIdx;\n    SubExprs[COLUMN_IDX] = ColumnIdx;\n    ArrayOrMatrixSubscriptExprBits.RBracketLoc = RBracketLoc;\n    setDependence(computeDependence(this));\n  }\n\n  /// Create an empty matrix subscript expression.\n  explicit MatrixSubscriptExpr(EmptyShell Shell)\n      : Expr(MatrixSubscriptExprClass, Shell) {}\n\n  bool isIncomplete() const {\n    bool IsIncomplete = hasPlaceholderType(BuiltinType::IncompleteMatrixIdx);\n    assert((SubExprs[COLUMN_IDX] || IsIncomplete) &&\n           \"expressions without column index must be marked as incomplete\");\n    return IsIncomplete;\n  }\n  Expr *getBase() { return cast<Expr>(SubExprs[BASE]); }\n  const Expr *getBase() const { return cast<Expr>(SubExprs[BASE]); }\n  void setBase(Expr *E) { SubExprs[BASE] = E; }\n\n  Expr *getRowIdx() { return cast<Expr>(SubExprs[ROW_IDX]); }\n  const Expr *getRowIdx() const { return cast<Expr>(SubExprs[ROW_IDX]); }\n  void setRowIdx(Expr *E) { SubExprs[ROW_IDX] = E; }\n\n  Expr *getColumnIdx() { return cast_or_null<Expr>(SubExprs[COLUMN_IDX]); }\n  const Expr *getColumnIdx() const {\n    assert(!isIncomplete() &&\n           \"cannot get the column index of an incomplete expression\");\n    return cast<Expr>(SubExprs[COLUMN_IDX]);\n  }\n  void setColumnIdx(Expr *E) { SubExprs[COLUMN_IDX] = E; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getBase()->getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const { return getRBracketLoc(); }\n\n  SourceLocation getExprLoc() const LLVM_READONLY {\n    return getBase()->getExprLoc();\n  }\n\n  SourceLocation getRBracketLoc() const {\n    return ArrayOrMatrixSubscriptExprBits.RBracketLoc;\n  }\n  void setRBracketLoc(SourceLocation L) {\n    ArrayOrMatrixSubscriptExprBits.RBracketLoc = L;\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == MatrixSubscriptExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n};\n\n/// CallExpr - Represents a function call (C99 6.5.2.2, C++ [expr.call]).\n/// CallExpr itself represents a normal function call, e.g., \"f(x, 2)\",\n/// while its subclasses may represent alternative syntax that (semantically)\n/// results in a function call. For example, CXXOperatorCallExpr is\n/// a subclass for overloaded operator calls that use operator syntax, e.g.,\n/// \"str1 + str2\" to resolve to a function call.\nclass CallExpr : public Expr {\n  enum { FN = 0, PREARGS_START = 1 };\n\n  /// The number of arguments in the call expression.\n  unsigned NumArgs;\n\n  /// The location of the right parenthese. This has a different meaning for\n  /// the derived classes of CallExpr.\n  SourceLocation RParenLoc;\n\n  // CallExpr store some data in trailing objects. However since CallExpr\n  // is used a base of other expression classes we cannot use\n  // llvm::TrailingObjects. Instead we manually perform the pointer arithmetic\n  // and casts.\n  //\n  // The trailing objects are in order:\n  //\n  // * A single \"Stmt *\" for the callee expression.\n  //\n  // * An array of getNumPreArgs() \"Stmt *\" for the pre-argument expressions.\n  //\n  // * An array of getNumArgs() \"Stmt *\" for the argument expressions.\n  //\n  // * An optional of type FPOptionsOverride.\n  //\n  // Note that we store the offset in bytes from the this pointer to the start\n  // of the trailing objects. It would be perfectly possible to compute it\n  // based on the dynamic kind of the CallExpr. However 1.) we have plenty of\n  // space in the bit-fields of Stmt. 2.) It was benchmarked to be faster to\n  // compute this once and then load the offset from the bit-fields of Stmt,\n  // instead of re-computing the offset each time the trailing objects are\n  // accessed.\n\n  /// Return a pointer to the start of the trailing array of \"Stmt *\".\n  Stmt **getTrailingStmts() {\n    return reinterpret_cast<Stmt **>(reinterpret_cast<char *>(this) +\n                                     CallExprBits.OffsetToTrailingObjects);\n  }\n  Stmt *const *getTrailingStmts() const {\n    return const_cast<CallExpr *>(this)->getTrailingStmts();\n  }\n\n  /// Map a statement class to the appropriate offset in bytes from the\n  /// this pointer to the trailing objects.\n  static unsigned offsetToTrailingObjects(StmtClass SC);\n\n  unsigned getSizeOfTrailingStmts() const {\n    return (1 + getNumPreArgs() + getNumArgs()) * sizeof(Stmt *);\n  }\n\n  size_t getOffsetOfTrailingFPFeatures() const {\n    assert(hasStoredFPFeatures());\n    return CallExprBits.OffsetToTrailingObjects + getSizeOfTrailingStmts();\n  }\n\npublic:\n  enum class ADLCallKind : bool { NotADL, UsesADL };\n  static constexpr ADLCallKind NotADL = ADLCallKind::NotADL;\n  static constexpr ADLCallKind UsesADL = ADLCallKind::UsesADL;\n\nprotected:\n  /// Build a call expression, assuming that appropriate storage has been\n  /// allocated for the trailing objects.\n  CallExpr(StmtClass SC, Expr *Fn, ArrayRef<Expr *> PreArgs,\n           ArrayRef<Expr *> Args, QualType Ty, ExprValueKind VK,\n           SourceLocation RParenLoc, FPOptionsOverride FPFeatures,\n           unsigned MinNumArgs, ADLCallKind UsesADL);\n\n  /// Build an empty call expression, for deserialization.\n  CallExpr(StmtClass SC, unsigned NumPreArgs, unsigned NumArgs,\n           bool hasFPFeatures, EmptyShell Empty);\n\n  /// Return the size in bytes needed for the trailing objects.\n  /// Used by the derived classes to allocate the right amount of storage.\n  static unsigned sizeOfTrailingObjects(unsigned NumPreArgs, unsigned NumArgs,\n                                        bool HasFPFeatures) {\n    return (1 + NumPreArgs + NumArgs) * sizeof(Stmt *) +\n           HasFPFeatures * sizeof(FPOptionsOverride);\n  }\n\n  Stmt *getPreArg(unsigned I) {\n    assert(I < getNumPreArgs() && \"Prearg access out of range!\");\n    return getTrailingStmts()[PREARGS_START + I];\n  }\n  const Stmt *getPreArg(unsigned I) const {\n    assert(I < getNumPreArgs() && \"Prearg access out of range!\");\n    return getTrailingStmts()[PREARGS_START + I];\n  }\n  void setPreArg(unsigned I, Stmt *PreArg) {\n    assert(I < getNumPreArgs() && \"Prearg access out of range!\");\n    getTrailingStmts()[PREARGS_START + I] = PreArg;\n  }\n\n  unsigned getNumPreArgs() const { return CallExprBits.NumPreArgs; }\n\n  /// Return a pointer to the trailing FPOptions\n  FPOptionsOverride *getTrailingFPFeatures() {\n    assert(hasStoredFPFeatures());\n    return reinterpret_cast<FPOptionsOverride *>(\n        reinterpret_cast<char *>(this) + CallExprBits.OffsetToTrailingObjects +\n        getSizeOfTrailingStmts());\n  }\n  const FPOptionsOverride *getTrailingFPFeatures() const {\n    assert(hasStoredFPFeatures());\n    return reinterpret_cast<const FPOptionsOverride *>(\n        reinterpret_cast<const char *>(this) +\n        CallExprBits.OffsetToTrailingObjects + getSizeOfTrailingStmts());\n  }\n\npublic:\n  /// Create a call expression.\n  /// \\param Fn     The callee expression,\n  /// \\param Args   The argument array,\n  /// \\param Ty     The type of the call expression (which is *not* the return\n  ///               type in general),\n  /// \\param VK     The value kind of the call expression (lvalue, rvalue, ...),\n  /// \\param RParenLoc  The location of the right parenthesis in the call\n  ///                   expression.\n  /// \\param FPFeatures Floating-point features associated with the call,\n  /// \\param MinNumArgs Specifies the minimum number of arguments. The actual\n  ///                   number of arguments will be the greater of Args.size()\n  ///                   and MinNumArgs. This is used in a few places to allocate\n  ///                   enough storage for the default arguments.\n  /// \\param UsesADL    Specifies whether the callee was found through\n  ///                   argument-dependent lookup.\n  ///\n  /// Note that you can use CreateTemporary if you need a temporary call\n  /// expression on the stack.\n  static CallExpr *Create(const ASTContext &Ctx, Expr *Fn,\n                          ArrayRef<Expr *> Args, QualType Ty, ExprValueKind VK,\n                          SourceLocation RParenLoc,\n                          FPOptionsOverride FPFeatures, unsigned MinNumArgs = 0,\n                          ADLCallKind UsesADL = NotADL);\n\n  /// Create a temporary call expression with no arguments in the memory\n  /// pointed to by Mem. Mem must points to at least sizeof(CallExpr)\n  /// + sizeof(Stmt *) bytes of storage, aligned to alignof(CallExpr):\n  ///\n  /// \\code{.cpp}\n  ///   alignas(CallExpr) char Buffer[sizeof(CallExpr) + sizeof(Stmt *)];\n  ///   CallExpr *TheCall = CallExpr::CreateTemporary(Buffer, etc);\n  /// \\endcode\n  static CallExpr *CreateTemporary(void *Mem, Expr *Fn, QualType Ty,\n                                   ExprValueKind VK, SourceLocation RParenLoc,\n                                   ADLCallKind UsesADL = NotADL);\n\n  /// Create an empty call expression, for deserialization.\n  static CallExpr *CreateEmpty(const ASTContext &Ctx, unsigned NumArgs,\n                               bool HasFPFeatures, EmptyShell Empty);\n\n  Expr *getCallee() { return cast<Expr>(getTrailingStmts()[FN]); }\n  const Expr *getCallee() const { return cast<Expr>(getTrailingStmts()[FN]); }\n  void setCallee(Expr *F) { getTrailingStmts()[FN] = F; }\n\n  ADLCallKind getADLCallKind() const {\n    return static_cast<ADLCallKind>(CallExprBits.UsesADL);\n  }\n  void setADLCallKind(ADLCallKind V = UsesADL) {\n    CallExprBits.UsesADL = static_cast<bool>(V);\n  }\n  bool usesADL() const { return getADLCallKind() == UsesADL; }\n\n  bool hasStoredFPFeatures() const { return CallExprBits.HasFPFeatures; }\n\n  Decl *getCalleeDecl() { return getCallee()->getReferencedDeclOfCallee(); }\n  const Decl *getCalleeDecl() const {\n    return getCallee()->getReferencedDeclOfCallee();\n  }\n\n  /// If the callee is a FunctionDecl, return it. Otherwise return null.\n  FunctionDecl *getDirectCallee() {\n    return dyn_cast_or_null<FunctionDecl>(getCalleeDecl());\n  }\n  const FunctionDecl *getDirectCallee() const {\n    return dyn_cast_or_null<FunctionDecl>(getCalleeDecl());\n  }\n\n  /// getNumArgs - Return the number of actual arguments to this call.\n  unsigned getNumArgs() const { return NumArgs; }\n\n  /// Retrieve the call arguments.\n  Expr **getArgs() {\n    return reinterpret_cast<Expr **>(getTrailingStmts() + PREARGS_START +\n                                     getNumPreArgs());\n  }\n  const Expr *const *getArgs() const {\n    return reinterpret_cast<const Expr *const *>(\n        getTrailingStmts() + PREARGS_START + getNumPreArgs());\n  }\n\n  /// getArg - Return the specified argument.\n  Expr *getArg(unsigned Arg) {\n    assert(Arg < getNumArgs() && \"Arg access out of range!\");\n    return getArgs()[Arg];\n  }\n  const Expr *getArg(unsigned Arg) const {\n    assert(Arg < getNumArgs() && \"Arg access out of range!\");\n    return getArgs()[Arg];\n  }\n\n  /// setArg - Set the specified argument.\n  void setArg(unsigned Arg, Expr *ArgExpr) {\n    assert(Arg < getNumArgs() && \"Arg access out of range!\");\n    getArgs()[Arg] = ArgExpr;\n  }\n\n  /// Reduce the number of arguments in this call expression. This is used for\n  /// example during error recovery to drop extra arguments. There is no way\n  /// to perform the opposite because: 1.) We don't track how much storage\n  /// we have for the argument array 2.) This would potentially require growing\n  /// the argument array, something we cannot support since the arguments are\n  /// stored in a trailing array.\n  void shrinkNumArgs(unsigned NewNumArgs) {\n    assert((NewNumArgs <= getNumArgs()) &&\n           \"shrinkNumArgs cannot increase the number of arguments!\");\n    NumArgs = NewNumArgs;\n  }\n\n  /// Bluntly set a new number of arguments without doing any checks whatsoever.\n  /// Only used during construction of a CallExpr in a few places in Sema.\n  /// FIXME: Find a way to remove it.\n  void setNumArgsUnsafe(unsigned NewNumArgs) { NumArgs = NewNumArgs; }\n\n  typedef ExprIterator arg_iterator;\n  typedef ConstExprIterator const_arg_iterator;\n  typedef llvm::iterator_range<arg_iterator> arg_range;\n  typedef llvm::iterator_range<const_arg_iterator> const_arg_range;\n\n  arg_range arguments() { return arg_range(arg_begin(), arg_end()); }\n  const_arg_range arguments() const {\n    return const_arg_range(arg_begin(), arg_end());\n  }\n\n  arg_iterator arg_begin() {\n    return getTrailingStmts() + PREARGS_START + getNumPreArgs();\n  }\n  arg_iterator arg_end() { return arg_begin() + getNumArgs(); }\n\n  const_arg_iterator arg_begin() const {\n    return getTrailingStmts() + PREARGS_START + getNumPreArgs();\n  }\n  const_arg_iterator arg_end() const { return arg_begin() + getNumArgs(); }\n\n  /// This method provides fast access to all the subexpressions of\n  /// a CallExpr without going through the slower virtual child_iterator\n  /// interface.  This provides efficient reverse iteration of the\n  /// subexpressions.  This is currently used for CFG construction.\n  ArrayRef<Stmt *> getRawSubExprs() {\n    return llvm::makeArrayRef(getTrailingStmts(),\n                              PREARGS_START + getNumPreArgs() + getNumArgs());\n  }\n\n  /// getNumCommas - Return the number of commas that must have been present in\n  /// this function call.\n  unsigned getNumCommas() const { return getNumArgs() ? getNumArgs() - 1 : 0; }\n\n  /// Get FPOptionsOverride from trailing storage.\n  FPOptionsOverride getStoredFPFeatures() const {\n    assert(hasStoredFPFeatures());\n    return *getTrailingFPFeatures();\n  }\n  /// Set FPOptionsOverride in trailing storage. Used only by Serialization.\n  void setStoredFPFeatures(FPOptionsOverride F) {\n    assert(hasStoredFPFeatures());\n    *getTrailingFPFeatures() = F;\n  }\n\n  // Get the FP features status of this operator. Only meaningful for\n  // operations on floating point types.\n  FPOptions getFPFeaturesInEffect(const LangOptions &LO) const {\n    if (hasStoredFPFeatures())\n      return getStoredFPFeatures().applyOverrides(LO);\n    return FPOptions::defaultWithoutTrailingStorage(LO);\n  }\n\n  FPOptionsOverride getFPFeatures() const {\n    if (hasStoredFPFeatures())\n      return getStoredFPFeatures();\n    return FPOptionsOverride();\n  }\n\n  /// getBuiltinCallee - If this is a call to a builtin, return the builtin ID\n  /// of the callee. If not, return 0.\n  unsigned getBuiltinCallee() const;\n\n  /// Returns \\c true if this is a call to a builtin which does not\n  /// evaluate side-effects within its arguments.\n  bool isUnevaluatedBuiltinCall(const ASTContext &Ctx) const;\n\n  /// getCallReturnType - Get the return type of the call expr. This is not\n  /// always the type of the expr itself, if the return type is a reference\n  /// type.\n  QualType getCallReturnType(const ASTContext &Ctx) const;\n\n  /// Returns the WarnUnusedResultAttr that is either declared on the called\n  /// function, or its return type declaration.\n  const Attr *getUnusedResultAttr(const ASTContext &Ctx) const;\n\n  /// Returns true if this call expression should warn on unused results.\n  bool hasUnusedResultAttr(const ASTContext &Ctx) const {\n    return getUnusedResultAttr(Ctx) != nullptr;\n  }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  /// Return true if this is a call to __assume() or __builtin_assume() with\n  /// a non-value-dependent constant parameter evaluating as false.\n  bool isBuiltinAssumeFalse(const ASTContext &Ctx) const;\n\n  /// Used by Sema to implement MSVC-compatible delayed name lookup.\n  /// (Usually Exprs themselves should set dependence).\n  void markDependentForPostponedNameLookup() {\n    setDependence(getDependence() | ExprDependence::TypeValueInstantiation);\n  }\n\n  bool isCallToStdMove() const {\n    const FunctionDecl *FD = getDirectCallee();\n    return getNumArgs() == 1 && FD && FD->isInStdNamespace() &&\n           FD->getIdentifier() && FD->getIdentifier()->isStr(\"move\");\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() >= firstCallExprConstant &&\n           T->getStmtClass() <= lastCallExprConstant;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(getTrailingStmts(), getTrailingStmts() + PREARGS_START +\n                                               getNumPreArgs() + getNumArgs());\n  }\n\n  const_child_range children() const {\n    return const_child_range(getTrailingStmts(),\n                             getTrailingStmts() + PREARGS_START +\n                                 getNumPreArgs() + getNumArgs());\n  }\n};\n\n/// Extra data stored in some MemberExpr objects.\nstruct MemberExprNameQualifier {\n  /// The nested-name-specifier that qualifies the name, including\n  /// source-location information.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// The DeclAccessPair through which the MemberDecl was found due to\n  /// name qualifiers.\n  DeclAccessPair FoundDecl;\n};\n\n/// MemberExpr - [C99 6.5.2.3] Structure and Union Members.  X->F and X.F.\n///\nclass MemberExpr final\n    : public Expr,\n      private llvm::TrailingObjects<MemberExpr, MemberExprNameQualifier,\n                                    ASTTemplateKWAndArgsInfo,\n                                    TemplateArgumentLoc> {\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// Base - the expression for the base pointer or structure references.  In\n  /// X.F, this is \"X\".\n  Stmt *Base;\n\n  /// MemberDecl - This is the decl being referenced by the field/member name.\n  /// In X.F, this is the decl referenced by F.\n  ValueDecl *MemberDecl;\n\n  /// MemberDNLoc - Provides source/type location info for the\n  /// declaration name embedded in MemberDecl.\n  DeclarationNameLoc MemberDNLoc;\n\n  /// MemberLoc - This is the location of the member name.\n  SourceLocation MemberLoc;\n\n  size_t numTrailingObjects(OverloadToken<MemberExprNameQualifier>) const {\n    return hasQualifierOrFoundDecl();\n  }\n\n  size_t numTrailingObjects(OverloadToken<ASTTemplateKWAndArgsInfo>) const {\n    return hasTemplateKWAndArgsInfo();\n  }\n\n  bool hasQualifierOrFoundDecl() const {\n    return MemberExprBits.HasQualifierOrFoundDecl;\n  }\n\n  bool hasTemplateKWAndArgsInfo() const {\n    return MemberExprBits.HasTemplateKWAndArgsInfo;\n  }\n\n  MemberExpr(Expr *Base, bool IsArrow, SourceLocation OperatorLoc,\n             ValueDecl *MemberDecl, const DeclarationNameInfo &NameInfo,\n             QualType T, ExprValueKind VK, ExprObjectKind OK,\n             NonOdrUseReason NOUR);\n  MemberExpr(EmptyShell Empty)\n      : Expr(MemberExprClass, Empty), Base(), MemberDecl() {}\n\npublic:\n  static MemberExpr *Create(const ASTContext &C, Expr *Base, bool IsArrow,\n                            SourceLocation OperatorLoc,\n                            NestedNameSpecifierLoc QualifierLoc,\n                            SourceLocation TemplateKWLoc, ValueDecl *MemberDecl,\n                            DeclAccessPair FoundDecl,\n                            DeclarationNameInfo MemberNameInfo,\n                            const TemplateArgumentListInfo *TemplateArgs,\n                            QualType T, ExprValueKind VK, ExprObjectKind OK,\n                            NonOdrUseReason NOUR);\n\n  /// Create an implicit MemberExpr, with no location, qualifier, template\n  /// arguments, and so on. Suitable only for non-static member access.\n  static MemberExpr *CreateImplicit(const ASTContext &C, Expr *Base,\n                                    bool IsArrow, ValueDecl *MemberDecl,\n                                    QualType T, ExprValueKind VK,\n                                    ExprObjectKind OK) {\n    return Create(C, Base, IsArrow, SourceLocation(), NestedNameSpecifierLoc(),\n                  SourceLocation(), MemberDecl,\n                  DeclAccessPair::make(MemberDecl, MemberDecl->getAccess()),\n                  DeclarationNameInfo(), nullptr, T, VK, OK, NOUR_None);\n  }\n\n  static MemberExpr *CreateEmpty(const ASTContext &Context, bool HasQualifier,\n                                 bool HasFoundDecl,\n                                 bool HasTemplateKWAndArgsInfo,\n                                 unsigned NumTemplateArgs);\n\n  void setBase(Expr *E) { Base = E; }\n  Expr *getBase() const { return cast<Expr>(Base); }\n\n  /// Retrieve the member declaration to which this expression refers.\n  ///\n  /// The returned declaration will be a FieldDecl or (in C++) a VarDecl (for\n  /// static data members), a CXXMethodDecl, or an EnumConstantDecl.\n  ValueDecl *getMemberDecl() const { return MemberDecl; }\n  void setMemberDecl(ValueDecl *D);\n\n  /// Retrieves the declaration found by lookup.\n  DeclAccessPair getFoundDecl() const {\n    if (!hasQualifierOrFoundDecl())\n      return DeclAccessPair::make(getMemberDecl(),\n                                  getMemberDecl()->getAccess());\n    return getTrailingObjects<MemberExprNameQualifier>()->FoundDecl;\n  }\n\n  /// Determines whether this member expression actually had\n  /// a C++ nested-name-specifier prior to the name of the member, e.g.,\n  /// x->Base::foo.\n  bool hasQualifier() const { return getQualifier() != nullptr; }\n\n  /// If the member name was qualified, retrieves the\n  /// nested-name-specifier that precedes the member name, with source-location\n  /// information.\n  NestedNameSpecifierLoc getQualifierLoc() const {\n    if (!hasQualifierOrFoundDecl())\n      return NestedNameSpecifierLoc();\n    return getTrailingObjects<MemberExprNameQualifier>()->QualifierLoc;\n  }\n\n  /// If the member name was qualified, retrieves the\n  /// nested-name-specifier that precedes the member name. Otherwise, returns\n  /// NULL.\n  NestedNameSpecifier *getQualifier() const {\n    return getQualifierLoc().getNestedNameSpecifier();\n  }\n\n  /// Retrieve the location of the template keyword preceding\n  /// the member name, if any.\n  SourceLocation getTemplateKeywordLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->TemplateKWLoc;\n  }\n\n  /// Retrieve the location of the left angle bracket starting the\n  /// explicit template argument list following the member name, if any.\n  SourceLocation getLAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->LAngleLoc;\n  }\n\n  /// Retrieve the location of the right angle bracket ending the\n  /// explicit template argument list following the member name, if any.\n  SourceLocation getRAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->RAngleLoc;\n  }\n\n  /// Determines whether the member name was preceded by the template keyword.\n  bool hasTemplateKeyword() const { return getTemplateKeywordLoc().isValid(); }\n\n  /// Determines whether the member name was followed by an\n  /// explicit template argument list.\n  bool hasExplicitTemplateArgs() const { return getLAngleLoc().isValid(); }\n\n  /// Copies the template arguments (if present) into the given\n  /// structure.\n  void copyTemplateArgumentsInto(TemplateArgumentListInfo &List) const {\n    if (hasExplicitTemplateArgs())\n      getTrailingObjects<ASTTemplateKWAndArgsInfo>()->copyInto(\n          getTrailingObjects<TemplateArgumentLoc>(), List);\n  }\n\n  /// Retrieve the template arguments provided as part of this\n  /// template-id.\n  const TemplateArgumentLoc *getTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return nullptr;\n\n    return getTrailingObjects<TemplateArgumentLoc>();\n  }\n\n  /// Retrieve the number of template arguments provided as part of this\n  /// template-id.\n  unsigned getNumTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return 0;\n\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->NumTemplateArgs;\n  }\n\n  ArrayRef<TemplateArgumentLoc> template_arguments() const {\n    return {getTemplateArgs(), getNumTemplateArgs()};\n  }\n\n  /// Retrieve the member declaration name info.\n  DeclarationNameInfo getMemberNameInfo() const {\n    return DeclarationNameInfo(MemberDecl->getDeclName(),\n                               MemberLoc, MemberDNLoc);\n  }\n\n  SourceLocation getOperatorLoc() const { return MemberExprBits.OperatorLoc; }\n\n  bool isArrow() const { return MemberExprBits.IsArrow; }\n  void setArrow(bool A) { MemberExprBits.IsArrow = A; }\n\n  /// getMemberLoc - Return the location of the \"member\", in X->F, it is the\n  /// location of 'F'.\n  SourceLocation getMemberLoc() const { return MemberLoc; }\n  void setMemberLoc(SourceLocation L) { MemberLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  SourceLocation getExprLoc() const LLVM_READONLY { return MemberLoc; }\n\n  /// Determine whether the base of this explicit is implicit.\n  bool isImplicitAccess() const {\n    return getBase() && getBase()->isImplicitCXXThis();\n  }\n\n  /// Returns true if this member expression refers to a method that\n  /// was resolved from an overloaded set having size greater than 1.\n  bool hadMultipleCandidates() const {\n    return MemberExprBits.HadMultipleCandidates;\n  }\n  /// Sets the flag telling whether this expression refers to\n  /// a method that was resolved from an overloaded set having size\n  /// greater than 1.\n  void setHadMultipleCandidates(bool V = true) {\n    MemberExprBits.HadMultipleCandidates = V;\n  }\n\n  /// Returns true if virtual dispatch is performed.\n  /// If the member access is fully qualified, (i.e. X::f()), virtual\n  /// dispatching is not performed. In -fapple-kext mode qualified\n  /// calls to virtual method will still go through the vtable.\n  bool performsVirtualDispatch(const LangOptions &LO) const {\n    return LO.AppleKext || !hasQualifier();\n  }\n\n  /// Is this expression a non-odr-use reference, and if so, why?\n  /// This is only meaningful if the named member is a static member.\n  NonOdrUseReason isNonOdrUse() const {\n    return static_cast<NonOdrUseReason>(MemberExprBits.NonOdrUseReason);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == MemberExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Base, &Base+1); }\n  const_child_range children() const {\n    return const_child_range(&Base, &Base + 1);\n  }\n};\n\n/// CompoundLiteralExpr - [C99 6.5.2.5]\n///\nclass CompoundLiteralExpr : public Expr {\n  /// LParenLoc - If non-null, this is the location of the left paren in a\n  /// compound literal like \"(int){4}\".  This can be null if this is a\n  /// synthesized compound expression.\n  SourceLocation LParenLoc;\n\n  /// The type as written.  This can be an incomplete array type, in\n  /// which case the actual expression type will be different.\n  /// The int part of the pair stores whether this expr is file scope.\n  llvm::PointerIntPair<TypeSourceInfo *, 1, bool> TInfoAndScope;\n  Stmt *Init;\npublic:\n  CompoundLiteralExpr(SourceLocation lparenloc, TypeSourceInfo *tinfo,\n                      QualType T, ExprValueKind VK, Expr *init, bool fileScope)\n      : Expr(CompoundLiteralExprClass, T, VK, OK_Ordinary),\n        LParenLoc(lparenloc), TInfoAndScope(tinfo, fileScope), Init(init) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Construct an empty compound literal.\n  explicit CompoundLiteralExpr(EmptyShell Empty)\n    : Expr(CompoundLiteralExprClass, Empty) { }\n\n  const Expr *getInitializer() const { return cast<Expr>(Init); }\n  Expr *getInitializer() { return cast<Expr>(Init); }\n  void setInitializer(Expr *E) { Init = E; }\n\n  bool isFileScope() const { return TInfoAndScope.getInt(); }\n  void setFileScope(bool FS) { TInfoAndScope.setInt(FS); }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  void setLParenLoc(SourceLocation L) { LParenLoc = L; }\n\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return TInfoAndScope.getPointer();\n  }\n  void setTypeSourceInfo(TypeSourceInfo *tinfo) {\n    TInfoAndScope.setPointer(tinfo);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    // FIXME: Init should never be null.\n    if (!Init)\n      return SourceLocation();\n    if (LParenLoc.isInvalid())\n      return Init->getBeginLoc();\n    return LParenLoc;\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    // FIXME: Init should never be null.\n    if (!Init)\n      return SourceLocation();\n    return Init->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CompoundLiteralExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Init, &Init+1); }\n  const_child_range children() const {\n    return const_child_range(&Init, &Init + 1);\n  }\n};\n\n/// CastExpr - Base class for type casts, including both implicit\n/// casts (ImplicitCastExpr) and explicit casts that have some\n/// representation in the source code (ExplicitCastExpr's derived\n/// classes).\nclass CastExpr : public Expr {\n  Stmt *Op;\n\n  bool CastConsistency() const;\n\n  const CXXBaseSpecifier * const *path_buffer() const {\n    return const_cast<CastExpr*>(this)->path_buffer();\n  }\n  CXXBaseSpecifier **path_buffer();\n\n  friend class ASTStmtReader;\n\nprotected:\n  CastExpr(StmtClass SC, QualType ty, ExprValueKind VK, const CastKind kind,\n           Expr *op, unsigned BasePathSize, bool HasFPFeatures)\n      : Expr(SC, ty, VK, OK_Ordinary), Op(op) {\n    CastExprBits.Kind = kind;\n    CastExprBits.PartOfExplicitCast = false;\n    CastExprBits.BasePathSize = BasePathSize;\n    assert((CastExprBits.BasePathSize == BasePathSize) &&\n           \"BasePathSize overflow!\");\n    setDependence(computeDependence(this));\n    assert(CastConsistency());\n    CastExprBits.HasFPFeatures = HasFPFeatures;\n  }\n\n  /// Construct an empty cast.\n  CastExpr(StmtClass SC, EmptyShell Empty, unsigned BasePathSize,\n           bool HasFPFeatures)\n      : Expr(SC, Empty) {\n    CastExprBits.PartOfExplicitCast = false;\n    CastExprBits.BasePathSize = BasePathSize;\n    CastExprBits.HasFPFeatures = HasFPFeatures;\n    assert((CastExprBits.BasePathSize == BasePathSize) &&\n           \"BasePathSize overflow!\");\n  }\n\n  /// Return a pointer to the trailing FPOptions.\n  /// \\pre hasStoredFPFeatures() == true\n  FPOptionsOverride *getTrailingFPFeatures();\n  const FPOptionsOverride *getTrailingFPFeatures() const {\n    return const_cast<CastExpr *>(this)->getTrailingFPFeatures();\n  }\n\npublic:\n  CastKind getCastKind() const { return (CastKind) CastExprBits.Kind; }\n  void setCastKind(CastKind K) { CastExprBits.Kind = K; }\n\n  static const char *getCastKindName(CastKind CK);\n  const char *getCastKindName() const { return getCastKindName(getCastKind()); }\n\n  Expr *getSubExpr() { return cast<Expr>(Op); }\n  const Expr *getSubExpr() const { return cast<Expr>(Op); }\n  void setSubExpr(Expr *E) { Op = E; }\n\n  /// Retrieve the cast subexpression as it was written in the source\n  /// code, looking through any implicit casts or other intermediate nodes\n  /// introduced by semantic analysis.\n  Expr *getSubExprAsWritten();\n  const Expr *getSubExprAsWritten() const {\n    return const_cast<CastExpr *>(this)->getSubExprAsWritten();\n  }\n\n  /// If this cast applies a user-defined conversion, retrieve the conversion\n  /// function that it invokes.\n  NamedDecl *getConversionFunction() const;\n\n  typedef CXXBaseSpecifier **path_iterator;\n  typedef const CXXBaseSpecifier *const *path_const_iterator;\n  bool path_empty() const { return path_size() == 0; }\n  unsigned path_size() const { return CastExprBits.BasePathSize; }\n  path_iterator path_begin() { return path_buffer(); }\n  path_iterator path_end() { return path_buffer() + path_size(); }\n  path_const_iterator path_begin() const { return path_buffer(); }\n  path_const_iterator path_end() const { return path_buffer() + path_size(); }\n\n  llvm::iterator_range<path_iterator> path() {\n    return llvm::make_range(path_begin(), path_end());\n  }\n  llvm::iterator_range<path_const_iterator> path() const {\n    return llvm::make_range(path_begin(), path_end());\n  }\n\n  const FieldDecl *getTargetUnionField() const {\n    assert(getCastKind() == CK_ToUnion);\n    return getTargetFieldForToUnionCast(getType(), getSubExpr()->getType());\n  }\n\n  bool hasStoredFPFeatures() const { return CastExprBits.HasFPFeatures; }\n\n  /// Get FPOptionsOverride from trailing storage.\n  FPOptionsOverride getStoredFPFeatures() const {\n    assert(hasStoredFPFeatures());\n    return *getTrailingFPFeatures();\n  }\n\n  // Get the FP features status of this operation. Only meaningful for\n  // operations on floating point types.\n  FPOptions getFPFeaturesInEffect(const LangOptions &LO) const {\n    if (hasStoredFPFeatures())\n      return getStoredFPFeatures().applyOverrides(LO);\n    return FPOptions::defaultWithoutTrailingStorage(LO);\n  }\n\n  FPOptionsOverride getFPFeatures() const {\n    if (hasStoredFPFeatures())\n      return getStoredFPFeatures();\n    return FPOptionsOverride();\n  }\n\n  static const FieldDecl *getTargetFieldForToUnionCast(QualType unionType,\n                                                       QualType opType);\n  static const FieldDecl *getTargetFieldForToUnionCast(const RecordDecl *RD,\n                                                       QualType opType);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() >= firstCastExprConstant &&\n           T->getStmtClass() <= lastCastExprConstant;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Op, &Op+1); }\n  const_child_range children() const { return const_child_range(&Op, &Op + 1); }\n};\n\n/// ImplicitCastExpr - Allows us to explicitly represent implicit type\n/// conversions, which have no direct representation in the original\n/// source code. For example: converting T[]->T*, void f()->void\n/// (*f)(), float->double, short->int, etc.\n///\n/// In C, implicit casts always produce rvalues. However, in C++, an\n/// implicit cast whose result is being bound to a reference will be\n/// an lvalue or xvalue. For example:\n///\n/// @code\n/// class Base { };\n/// class Derived : public Base { };\n/// Derived &&ref();\n/// void f(Derived d) {\n///   Base& b = d; // initializer is an ImplicitCastExpr\n///                // to an lvalue of type Base\n///   Base&& r = ref(); // initializer is an ImplicitCastExpr\n///                     // to an xvalue of type Base\n/// }\n/// @endcode\nclass ImplicitCastExpr final\n    : public CastExpr,\n      private llvm::TrailingObjects<ImplicitCastExpr, CXXBaseSpecifier *,\n                                    FPOptionsOverride> {\n\n  ImplicitCastExpr(QualType ty, CastKind kind, Expr *op,\n                   unsigned BasePathLength, FPOptionsOverride FPO,\n                   ExprValueKind VK)\n      : CastExpr(ImplicitCastExprClass, ty, VK, kind, op, BasePathLength,\n                 FPO.requiresTrailingStorage()) {\n    if (hasStoredFPFeatures())\n      *getTrailingFPFeatures() = FPO;\n  }\n\n  /// Construct an empty implicit cast.\n  explicit ImplicitCastExpr(EmptyShell Shell, unsigned PathSize,\n                            bool HasFPFeatures)\n      : CastExpr(ImplicitCastExprClass, Shell, PathSize, HasFPFeatures) {}\n\n  unsigned numTrailingObjects(OverloadToken<CXXBaseSpecifier *>) const {\n    return path_size();\n  }\n\npublic:\n  enum OnStack_t { OnStack };\n  ImplicitCastExpr(OnStack_t _, QualType ty, CastKind kind, Expr *op,\n                   ExprValueKind VK, FPOptionsOverride FPO)\n      : CastExpr(ImplicitCastExprClass, ty, VK, kind, op, 0,\n                 FPO.requiresTrailingStorage()) {\n    if (hasStoredFPFeatures())\n      *getTrailingFPFeatures() = FPO;\n  }\n\n  bool isPartOfExplicitCast() const { return CastExprBits.PartOfExplicitCast; }\n  void setIsPartOfExplicitCast(bool PartOfExplicitCast) {\n    CastExprBits.PartOfExplicitCast = PartOfExplicitCast;\n  }\n\n  static ImplicitCastExpr *Create(const ASTContext &Context, QualType T,\n                                  CastKind Kind, Expr *Operand,\n                                  const CXXCastPath *BasePath,\n                                  ExprValueKind Cat, FPOptionsOverride FPO);\n\n  static ImplicitCastExpr *CreateEmpty(const ASTContext &Context,\n                                       unsigned PathSize, bool HasFPFeatures);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getSubExpr()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getSubExpr()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ImplicitCastExprClass;\n  }\n\n  friend TrailingObjects;\n  friend class CastExpr;\n};\n\n/// ExplicitCastExpr - An explicit cast written in the source\n/// code.\n///\n/// This class is effectively an abstract class, because it provides\n/// the basic representation of an explicitly-written cast without\n/// specifying which kind of cast (C cast, functional cast, static\n/// cast, etc.) was written; specific derived classes represent the\n/// particular style of cast and its location information.\n///\n/// Unlike implicit casts, explicit cast nodes have two different\n/// types: the type that was written into the source code, and the\n/// actual type of the expression as determined by semantic\n/// analysis. These types may differ slightly. For example, in C++ one\n/// can cast to a reference type, which indicates that the resulting\n/// expression will be an lvalue or xvalue. The reference type, however,\n/// will not be used as the type of the expression.\nclass ExplicitCastExpr : public CastExpr {\n  /// TInfo - Source type info for the (written) type\n  /// this expression is casting to.\n  TypeSourceInfo *TInfo;\n\nprotected:\n  ExplicitCastExpr(StmtClass SC, QualType exprTy, ExprValueKind VK,\n                   CastKind kind, Expr *op, unsigned PathSize,\n                   bool HasFPFeatures, TypeSourceInfo *writtenTy)\n      : CastExpr(SC, exprTy, VK, kind, op, PathSize, HasFPFeatures),\n        TInfo(writtenTy) {}\n\n  /// Construct an empty explicit cast.\n  ExplicitCastExpr(StmtClass SC, EmptyShell Shell, unsigned PathSize,\n                   bool HasFPFeatures)\n      : CastExpr(SC, Shell, PathSize, HasFPFeatures) {}\n\npublic:\n  /// getTypeInfoAsWritten - Returns the type source info for the type\n  /// that this expression is casting to.\n  TypeSourceInfo *getTypeInfoAsWritten() const { return TInfo; }\n  void setTypeInfoAsWritten(TypeSourceInfo *writtenTy) { TInfo = writtenTy; }\n\n  /// getTypeAsWritten - Returns the type that this expression is\n  /// casting to, as written in the source code.\n  QualType getTypeAsWritten() const { return TInfo->getType(); }\n\n  static bool classof(const Stmt *T) {\n     return T->getStmtClass() >= firstExplicitCastExprConstant &&\n            T->getStmtClass() <= lastExplicitCastExprConstant;\n  }\n};\n\n/// CStyleCastExpr - An explicit cast in C (C99 6.5.4) or a C-style\n/// cast in C++ (C++ [expr.cast]), which uses the syntax\n/// (Type)expr. For example: @c (int)f.\nclass CStyleCastExpr final\n    : public ExplicitCastExpr,\n      private llvm::TrailingObjects<CStyleCastExpr, CXXBaseSpecifier *,\n                                    FPOptionsOverride> {\n  SourceLocation LPLoc; // the location of the left paren\n  SourceLocation RPLoc; // the location of the right paren\n\n  CStyleCastExpr(QualType exprTy, ExprValueKind vk, CastKind kind, Expr *op,\n                 unsigned PathSize, FPOptionsOverride FPO,\n                 TypeSourceInfo *writtenTy, SourceLocation l, SourceLocation r)\n      : ExplicitCastExpr(CStyleCastExprClass, exprTy, vk, kind, op, PathSize,\n                         FPO.requiresTrailingStorage(), writtenTy),\n        LPLoc(l), RPLoc(r) {\n    if (hasStoredFPFeatures())\n      *getTrailingFPFeatures() = FPO;\n  }\n\n  /// Construct an empty C-style explicit cast.\n  explicit CStyleCastExpr(EmptyShell Shell, unsigned PathSize,\n                          bool HasFPFeatures)\n      : ExplicitCastExpr(CStyleCastExprClass, Shell, PathSize, HasFPFeatures) {}\n\n  unsigned numTrailingObjects(OverloadToken<CXXBaseSpecifier *>) const {\n    return path_size();\n  }\n\npublic:\n  static CStyleCastExpr *\n  Create(const ASTContext &Context, QualType T, ExprValueKind VK, CastKind K,\n         Expr *Op, const CXXCastPath *BasePath, FPOptionsOverride FPO,\n         TypeSourceInfo *WrittenTy, SourceLocation L, SourceLocation R);\n\n  static CStyleCastExpr *CreateEmpty(const ASTContext &Context,\n                                     unsigned PathSize, bool HasFPFeatures);\n\n  SourceLocation getLParenLoc() const { return LPLoc; }\n  void setLParenLoc(SourceLocation L) { LPLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RPLoc; }\n  void setRParenLoc(SourceLocation L) { RPLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return LPLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getSubExpr()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CStyleCastExprClass;\n  }\n\n  friend TrailingObjects;\n  friend class CastExpr;\n};\n\n/// A builtin binary operation expression such as \"x + y\" or \"x <= y\".\n///\n/// This expression node kind describes a builtin binary operation,\n/// such as \"x + y\" for integer values \"x\" and \"y\". The operands will\n/// already have been converted to appropriate types (e.g., by\n/// performing promotions or conversions).\n///\n/// In C++, where operators may be overloaded, a different kind of\n/// expression node (CXXOperatorCallExpr) is used to express the\n/// invocation of an overloaded operator with operator syntax. Within\n/// a C++ template, whether BinaryOperator or CXXOperatorCallExpr is\n/// used to store an expression \"x + y\" depends on the subexpressions\n/// for x and y. If neither x or y is type-dependent, and the \"+\"\n/// operator resolves to a built-in operation, BinaryOperator will be\n/// used to express the computation (x and y may still be\n/// value-dependent). If either x or y is type-dependent, or if the\n/// \"+\" resolves to an overloaded operator, CXXOperatorCallExpr will\n/// be used to express the computation.\nclass BinaryOperator : public Expr {\n  enum { LHS, RHS, END_EXPR };\n  Stmt *SubExprs[END_EXPR];\n\npublic:\n  typedef BinaryOperatorKind Opcode;\n\nprotected:\n  size_t offsetOfTrailingStorage() const;\n\n  /// Return a pointer to the trailing FPOptions\n  FPOptionsOverride *getTrailingFPFeatures() {\n    assert(BinaryOperatorBits.HasFPFeatures);\n    return reinterpret_cast<FPOptionsOverride *>(\n        reinterpret_cast<char *>(this) + offsetOfTrailingStorage());\n  }\n  const FPOptionsOverride *getTrailingFPFeatures() const {\n    assert(BinaryOperatorBits.HasFPFeatures);\n    return reinterpret_cast<const FPOptionsOverride *>(\n        reinterpret_cast<const char *>(this) + offsetOfTrailingStorage());\n  }\n\n  /// Build a binary operator, assuming that appropriate storage has been\n  /// allocated for the trailing objects when needed.\n  BinaryOperator(const ASTContext &Ctx, Expr *lhs, Expr *rhs, Opcode opc,\n                 QualType ResTy, ExprValueKind VK, ExprObjectKind OK,\n                 SourceLocation opLoc, FPOptionsOverride FPFeatures);\n\n  /// Construct an empty binary operator.\n  explicit BinaryOperator(EmptyShell Empty) : Expr(BinaryOperatorClass, Empty) {\n    BinaryOperatorBits.Opc = BO_Comma;\n  }\n\npublic:\n  static BinaryOperator *CreateEmpty(const ASTContext &C, bool hasFPFeatures);\n\n  static BinaryOperator *Create(const ASTContext &C, Expr *lhs, Expr *rhs,\n                                Opcode opc, QualType ResTy, ExprValueKind VK,\n                                ExprObjectKind OK, SourceLocation opLoc,\n                                FPOptionsOverride FPFeatures);\n  SourceLocation getExprLoc() const { return getOperatorLoc(); }\n  SourceLocation getOperatorLoc() const { return BinaryOperatorBits.OpLoc; }\n  void setOperatorLoc(SourceLocation L) { BinaryOperatorBits.OpLoc = L; }\n\n  Opcode getOpcode() const {\n    return static_cast<Opcode>(BinaryOperatorBits.Opc);\n  }\n  void setOpcode(Opcode Opc) { BinaryOperatorBits.Opc = Opc; }\n\n  Expr *getLHS() const { return cast<Expr>(SubExprs[LHS]); }\n  void setLHS(Expr *E) { SubExprs[LHS] = E; }\n  Expr *getRHS() const { return cast<Expr>(SubExprs[RHS]); }\n  void setRHS(Expr *E) { SubExprs[RHS] = E; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getLHS()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getRHS()->getEndLoc();\n  }\n\n  /// getOpcodeStr - Turn an Opcode enum value into the punctuation char it\n  /// corresponds to, e.g. \"<<=\".\n  static StringRef getOpcodeStr(Opcode Op);\n\n  StringRef getOpcodeStr() const { return getOpcodeStr(getOpcode()); }\n\n  /// Retrieve the binary opcode that corresponds to the given\n  /// overloaded operator.\n  static Opcode getOverloadedOpcode(OverloadedOperatorKind OO);\n\n  /// Retrieve the overloaded operator kind that corresponds to\n  /// the given binary opcode.\n  static OverloadedOperatorKind getOverloadedOperator(Opcode Opc);\n\n  /// predicates to categorize the respective opcodes.\n  static bool isPtrMemOp(Opcode Opc) {\n    return Opc == BO_PtrMemD || Opc == BO_PtrMemI;\n  }\n  bool isPtrMemOp() const { return isPtrMemOp(getOpcode()); }\n\n  static bool isMultiplicativeOp(Opcode Opc) {\n    return Opc >= BO_Mul && Opc <= BO_Rem;\n  }\n  bool isMultiplicativeOp() const { return isMultiplicativeOp(getOpcode()); }\n  static bool isAdditiveOp(Opcode Opc) { return Opc == BO_Add || Opc==BO_Sub; }\n  bool isAdditiveOp() const { return isAdditiveOp(getOpcode()); }\n  static bool isShiftOp(Opcode Opc) { return Opc == BO_Shl || Opc == BO_Shr; }\n  bool isShiftOp() const { return isShiftOp(getOpcode()); }\n\n  static bool isBitwiseOp(Opcode Opc) { return Opc >= BO_And && Opc <= BO_Or; }\n  bool isBitwiseOp() const { return isBitwiseOp(getOpcode()); }\n\n  static bool isRelationalOp(Opcode Opc) { return Opc >= BO_LT && Opc<=BO_GE; }\n  bool isRelationalOp() const { return isRelationalOp(getOpcode()); }\n\n  static bool isEqualityOp(Opcode Opc) { return Opc == BO_EQ || Opc == BO_NE; }\n  bool isEqualityOp() const { return isEqualityOp(getOpcode()); }\n\n  static bool isComparisonOp(Opcode Opc) { return Opc >= BO_Cmp && Opc<=BO_NE; }\n  bool isComparisonOp() const { return isComparisonOp(getOpcode()); }\n\n  static bool isCommaOp(Opcode Opc) { return Opc == BO_Comma; }\n  bool isCommaOp() const { return isCommaOp(getOpcode()); }\n\n  static Opcode negateComparisonOp(Opcode Opc) {\n    switch (Opc) {\n    default:\n      llvm_unreachable(\"Not a comparison operator.\");\n    case BO_LT: return BO_GE;\n    case BO_GT: return BO_LE;\n    case BO_LE: return BO_GT;\n    case BO_GE: return BO_LT;\n    case BO_EQ: return BO_NE;\n    case BO_NE: return BO_EQ;\n    }\n  }\n\n  static Opcode reverseComparisonOp(Opcode Opc) {\n    switch (Opc) {\n    default:\n      llvm_unreachable(\"Not a comparison operator.\");\n    case BO_LT: return BO_GT;\n    case BO_GT: return BO_LT;\n    case BO_LE: return BO_GE;\n    case BO_GE: return BO_LE;\n    case BO_EQ:\n    case BO_NE:\n      return Opc;\n    }\n  }\n\n  static bool isLogicalOp(Opcode Opc) { return Opc == BO_LAnd || Opc==BO_LOr; }\n  bool isLogicalOp() const { return isLogicalOp(getOpcode()); }\n\n  static bool isAssignmentOp(Opcode Opc) {\n    return Opc >= BO_Assign && Opc <= BO_OrAssign;\n  }\n  bool isAssignmentOp() const { return isAssignmentOp(getOpcode()); }\n\n  static bool isCompoundAssignmentOp(Opcode Opc) {\n    return Opc > BO_Assign && Opc <= BO_OrAssign;\n  }\n  bool isCompoundAssignmentOp() const {\n    return isCompoundAssignmentOp(getOpcode());\n  }\n  static Opcode getOpForCompoundAssignment(Opcode Opc) {\n    assert(isCompoundAssignmentOp(Opc));\n    if (Opc >= BO_AndAssign)\n      return Opcode(unsigned(Opc) - BO_AndAssign + BO_And);\n    else\n      return Opcode(unsigned(Opc) - BO_MulAssign + BO_Mul);\n  }\n\n  static bool isShiftAssignOp(Opcode Opc) {\n    return Opc == BO_ShlAssign || Opc == BO_ShrAssign;\n  }\n  bool isShiftAssignOp() const {\n    return isShiftAssignOp(getOpcode());\n  }\n\n  // Return true if a binary operator using the specified opcode and operands\n  // would match the 'p = (i8*)nullptr + n' idiom for casting a pointer-sized\n  // integer to a pointer.\n  static bool isNullPointerArithmeticExtension(ASTContext &Ctx, Opcode Opc,\n                                               Expr *LHS, Expr *RHS);\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() >= firstBinaryOperatorConstant &&\n           S->getStmtClass() <= lastBinaryOperatorConstant;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0]+END_EXPR);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n\n  /// Set and fetch the bit that shows whether FPFeatures needs to be\n  /// allocated in Trailing Storage\n  void setHasStoredFPFeatures(bool B) { BinaryOperatorBits.HasFPFeatures = B; }\n  bool hasStoredFPFeatures() const { return BinaryOperatorBits.HasFPFeatures; }\n\n  /// Get FPFeatures from trailing storage\n  FPOptionsOverride getStoredFPFeatures() const {\n    assert(hasStoredFPFeatures());\n    return *getTrailingFPFeatures();\n  }\n  /// Set FPFeatures in trailing storage, used only by Serialization\n  void setStoredFPFeatures(FPOptionsOverride F) {\n    assert(BinaryOperatorBits.HasFPFeatures);\n    *getTrailingFPFeatures() = F;\n  }\n\n  // Get the FP features status of this operator. Only meaningful for\n  // operations on floating point types.\n  FPOptions getFPFeaturesInEffect(const LangOptions &LO) const {\n    if (BinaryOperatorBits.HasFPFeatures)\n      return getStoredFPFeatures().applyOverrides(LO);\n    return FPOptions::defaultWithoutTrailingStorage(LO);\n  }\n\n  // This is used in ASTImporter\n  FPOptionsOverride getFPFeatures(const LangOptions &LO) const {\n    if (BinaryOperatorBits.HasFPFeatures)\n      return getStoredFPFeatures();\n    return FPOptionsOverride();\n  }\n\n  // Get the FP contractability status of this operator. Only meaningful for\n  // operations on floating point types.\n  bool isFPContractableWithinStatement(const LangOptions &LO) const {\n    return getFPFeaturesInEffect(LO).allowFPContractWithinStatement();\n  }\n\n  // Get the FENV_ACCESS status of this operator. Only meaningful for\n  // operations on floating point types.\n  bool isFEnvAccessOn(const LangOptions &LO) const {\n    return getFPFeaturesInEffect(LO).getAllowFEnvAccess();\n  }\n\nprotected:\n  BinaryOperator(const ASTContext &Ctx, Expr *lhs, Expr *rhs, Opcode opc,\n                 QualType ResTy, ExprValueKind VK, ExprObjectKind OK,\n                 SourceLocation opLoc, FPOptionsOverride FPFeatures,\n                 bool dead2);\n\n  /// Construct an empty BinaryOperator, SC is CompoundAssignOperator.\n  BinaryOperator(StmtClass SC, EmptyShell Empty) : Expr(SC, Empty) {\n    BinaryOperatorBits.Opc = BO_MulAssign;\n  }\n\n  /// Return the size in bytes needed for the trailing objects.\n  /// Used to allocate the right amount of storage.\n  static unsigned sizeOfTrailingObjects(bool HasFPFeatures) {\n    return HasFPFeatures * sizeof(FPOptionsOverride);\n  }\n};\n\n/// CompoundAssignOperator - For compound assignments (e.g. +=), we keep\n/// track of the type the operation is performed in.  Due to the semantics of\n/// these operators, the operands are promoted, the arithmetic performed, an\n/// implicit conversion back to the result type done, then the assignment takes\n/// place.  This captures the intermediate type which the computation is done\n/// in.\nclass CompoundAssignOperator : public BinaryOperator {\n  QualType ComputationLHSType;\n  QualType ComputationResultType;\n\n  /// Construct an empty CompoundAssignOperator.\n  explicit CompoundAssignOperator(const ASTContext &C, EmptyShell Empty,\n                                  bool hasFPFeatures)\n      : BinaryOperator(CompoundAssignOperatorClass, Empty) {}\n\nprotected:\n  CompoundAssignOperator(const ASTContext &C, Expr *lhs, Expr *rhs, Opcode opc,\n                         QualType ResType, ExprValueKind VK, ExprObjectKind OK,\n                         SourceLocation OpLoc, FPOptionsOverride FPFeatures,\n                         QualType CompLHSType, QualType CompResultType)\n      : BinaryOperator(C, lhs, rhs, opc, ResType, VK, OK, OpLoc, FPFeatures,\n                       true),\n        ComputationLHSType(CompLHSType), ComputationResultType(CompResultType) {\n    assert(isCompoundAssignmentOp() &&\n           \"Only should be used for compound assignments\");\n  }\n\npublic:\n  static CompoundAssignOperator *CreateEmpty(const ASTContext &C,\n                                             bool hasFPFeatures);\n\n  static CompoundAssignOperator *\n  Create(const ASTContext &C, Expr *lhs, Expr *rhs, Opcode opc, QualType ResTy,\n         ExprValueKind VK, ExprObjectKind OK, SourceLocation opLoc,\n         FPOptionsOverride FPFeatures, QualType CompLHSType = QualType(),\n         QualType CompResultType = QualType());\n\n  // The two computation types are the type the LHS is converted\n  // to for the computation and the type of the result; the two are\n  // distinct in a few cases (specifically, int+=ptr and ptr-=ptr).\n  QualType getComputationLHSType() const { return ComputationLHSType; }\n  void setComputationLHSType(QualType T) { ComputationLHSType = T; }\n\n  QualType getComputationResultType() const { return ComputationResultType; }\n  void setComputationResultType(QualType T) { ComputationResultType = T; }\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() == CompoundAssignOperatorClass;\n  }\n};\n\ninline size_t BinaryOperator::offsetOfTrailingStorage() const {\n  assert(BinaryOperatorBits.HasFPFeatures);\n  return isa<CompoundAssignOperator>(this) ? sizeof(CompoundAssignOperator)\n                                           : sizeof(BinaryOperator);\n}\n\n/// AbstractConditionalOperator - An abstract base class for\n/// ConditionalOperator and BinaryConditionalOperator.\nclass AbstractConditionalOperator : public Expr {\n  SourceLocation QuestionLoc, ColonLoc;\n  friend class ASTStmtReader;\n\nprotected:\n  AbstractConditionalOperator(StmtClass SC, QualType T, ExprValueKind VK,\n                              ExprObjectKind OK, SourceLocation qloc,\n                              SourceLocation cloc)\n      : Expr(SC, T, VK, OK), QuestionLoc(qloc), ColonLoc(cloc) {}\n\n  AbstractConditionalOperator(StmtClass SC, EmptyShell Empty)\n    : Expr(SC, Empty) { }\n\npublic:\n  // getCond - Return the expression representing the condition for\n  //   the ?: operator.\n  Expr *getCond() const;\n\n  // getTrueExpr - Return the subexpression representing the value of\n  //   the expression if the condition evaluates to true.\n  Expr *getTrueExpr() const;\n\n  // getFalseExpr - Return the subexpression representing the value of\n  //   the expression if the condition evaluates to false.  This is\n  //   the same as getRHS.\n  Expr *getFalseExpr() const;\n\n  SourceLocation getQuestionLoc() const { return QuestionLoc; }\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ConditionalOperatorClass ||\n           T->getStmtClass() == BinaryConditionalOperatorClass;\n  }\n};\n\n/// ConditionalOperator - The ?: ternary operator.  The GNU \"missing\n/// middle\" extension is a BinaryConditionalOperator.\nclass ConditionalOperator : public AbstractConditionalOperator {\n  enum { COND, LHS, RHS, END_EXPR };\n  Stmt* SubExprs[END_EXPR]; // Left/Middle/Right hand sides.\n\n  friend class ASTStmtReader;\npublic:\n  ConditionalOperator(Expr *cond, SourceLocation QLoc, Expr *lhs,\n                      SourceLocation CLoc, Expr *rhs, QualType t,\n                      ExprValueKind VK, ExprObjectKind OK)\n      : AbstractConditionalOperator(ConditionalOperatorClass, t, VK, OK, QLoc,\n                                    CLoc) {\n    SubExprs[COND] = cond;\n    SubExprs[LHS] = lhs;\n    SubExprs[RHS] = rhs;\n    setDependence(computeDependence(this));\n  }\n\n  /// Build an empty conditional operator.\n  explicit ConditionalOperator(EmptyShell Empty)\n    : AbstractConditionalOperator(ConditionalOperatorClass, Empty) { }\n\n  // getCond - Return the expression representing the condition for\n  //   the ?: operator.\n  Expr *getCond() const { return cast<Expr>(SubExprs[COND]); }\n\n  // getTrueExpr - Return the subexpression representing the value of\n  //   the expression if the condition evaluates to true.\n  Expr *getTrueExpr() const { return cast<Expr>(SubExprs[LHS]); }\n\n  // getFalseExpr - Return the subexpression representing the value of\n  //   the expression if the condition evaluates to false.  This is\n  //   the same as getRHS.\n  Expr *getFalseExpr() const { return cast<Expr>(SubExprs[RHS]); }\n\n  Expr *getLHS() const { return cast<Expr>(SubExprs[LHS]); }\n  Expr *getRHS() const { return cast<Expr>(SubExprs[RHS]); }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getCond()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getRHS()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ConditionalOperatorClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0]+END_EXPR);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n};\n\n/// BinaryConditionalOperator - The GNU extension to the conditional\n/// operator which allows the middle operand to be omitted.\n///\n/// This is a different expression kind on the assumption that almost\n/// every client ends up needing to know that these are different.\nclass BinaryConditionalOperator : public AbstractConditionalOperator {\n  enum { COMMON, COND, LHS, RHS, NUM_SUBEXPRS };\n\n  /// - the common condition/left-hand-side expression, which will be\n  ///   evaluated as the opaque value\n  /// - the condition, expressed in terms of the opaque value\n  /// - the left-hand-side, expressed in terms of the opaque value\n  /// - the right-hand-side\n  Stmt *SubExprs[NUM_SUBEXPRS];\n  OpaqueValueExpr *OpaqueValue;\n\n  friend class ASTStmtReader;\npublic:\n  BinaryConditionalOperator(Expr *common, OpaqueValueExpr *opaqueValue,\n                            Expr *cond, Expr *lhs, Expr *rhs,\n                            SourceLocation qloc, SourceLocation cloc,\n                            QualType t, ExprValueKind VK, ExprObjectKind OK)\n      : AbstractConditionalOperator(BinaryConditionalOperatorClass, t, VK, OK,\n                                    qloc, cloc),\n        OpaqueValue(opaqueValue) {\n    SubExprs[COMMON] = common;\n    SubExprs[COND] = cond;\n    SubExprs[LHS] = lhs;\n    SubExprs[RHS] = rhs;\n    assert(OpaqueValue->getSourceExpr() == common && \"Wrong opaque value\");\n    setDependence(computeDependence(this));\n  }\n\n  /// Build an empty conditional operator.\n  explicit BinaryConditionalOperator(EmptyShell Empty)\n    : AbstractConditionalOperator(BinaryConditionalOperatorClass, Empty) { }\n\n  /// getCommon - Return the common expression, written to the\n  ///   left of the condition.  The opaque value will be bound to the\n  ///   result of this expression.\n  Expr *getCommon() const { return cast<Expr>(SubExprs[COMMON]); }\n\n  /// getOpaqueValue - Return the opaque value placeholder.\n  OpaqueValueExpr *getOpaqueValue() const { return OpaqueValue; }\n\n  /// getCond - Return the condition expression; this is defined\n  ///   in terms of the opaque value.\n  Expr *getCond() const { return cast<Expr>(SubExprs[COND]); }\n\n  /// getTrueExpr - Return the subexpression which will be\n  ///   evaluated if the condition evaluates to true;  this is defined\n  ///   in terms of the opaque value.\n  Expr *getTrueExpr() const {\n    return cast<Expr>(SubExprs[LHS]);\n  }\n\n  /// getFalseExpr - Return the subexpression which will be\n  ///   evaluated if the condnition evaluates to false; this is\n  ///   defined in terms of the opaque value.\n  Expr *getFalseExpr() const {\n    return cast<Expr>(SubExprs[RHS]);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getCommon()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getFalseExpr()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == BinaryConditionalOperatorClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(SubExprs, SubExprs + NUM_SUBEXPRS);\n  }\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + NUM_SUBEXPRS);\n  }\n};\n\ninline Expr *AbstractConditionalOperator::getCond() const {\n  if (const ConditionalOperator *co = dyn_cast<ConditionalOperator>(this))\n    return co->getCond();\n  return cast<BinaryConditionalOperator>(this)->getCond();\n}\n\ninline Expr *AbstractConditionalOperator::getTrueExpr() const {\n  if (const ConditionalOperator *co = dyn_cast<ConditionalOperator>(this))\n    return co->getTrueExpr();\n  return cast<BinaryConditionalOperator>(this)->getTrueExpr();\n}\n\ninline Expr *AbstractConditionalOperator::getFalseExpr() const {\n  if (const ConditionalOperator *co = dyn_cast<ConditionalOperator>(this))\n    return co->getFalseExpr();\n  return cast<BinaryConditionalOperator>(this)->getFalseExpr();\n}\n\n/// AddrLabelExpr - The GNU address of label extension, representing &&label.\nclass AddrLabelExpr : public Expr {\n  SourceLocation AmpAmpLoc, LabelLoc;\n  LabelDecl *Label;\npublic:\n  AddrLabelExpr(SourceLocation AALoc, SourceLocation LLoc, LabelDecl *L,\n                QualType t)\n      : Expr(AddrLabelExprClass, t, VK_RValue, OK_Ordinary), AmpAmpLoc(AALoc),\n        LabelLoc(LLoc), Label(L) {\n    setDependence(ExprDependence::None);\n  }\n\n  /// Build an empty address of a label expression.\n  explicit AddrLabelExpr(EmptyShell Empty)\n    : Expr(AddrLabelExprClass, Empty) { }\n\n  SourceLocation getAmpAmpLoc() const { return AmpAmpLoc; }\n  void setAmpAmpLoc(SourceLocation L) { AmpAmpLoc = L; }\n  SourceLocation getLabelLoc() const { return LabelLoc; }\n  void setLabelLoc(SourceLocation L) { LabelLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AmpAmpLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return LabelLoc; }\n\n  LabelDecl *getLabel() const { return Label; }\n  void setLabel(LabelDecl *L) { Label = L; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == AddrLabelExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// StmtExpr - This is the GNU Statement Expression extension: ({int X=4; X;}).\n/// The StmtExpr contains a single CompoundStmt node, which it evaluates and\n/// takes the value of the last subexpression.\n///\n/// A StmtExpr is always an r-value; values \"returned\" out of a\n/// StmtExpr will be copied.\nclass StmtExpr : public Expr {\n  Stmt *SubStmt;\n  SourceLocation LParenLoc, RParenLoc;\npublic:\n  StmtExpr(CompoundStmt *SubStmt, QualType T, SourceLocation LParenLoc,\n           SourceLocation RParenLoc, unsigned TemplateDepth)\n      : Expr(StmtExprClass, T, VK_RValue, OK_Ordinary), SubStmt(SubStmt),\n        LParenLoc(LParenLoc), RParenLoc(RParenLoc) {\n    setDependence(computeDependence(this, TemplateDepth));\n    // FIXME: A templated statement expression should have an associated\n    // DeclContext so that nested declarations always have a dependent context.\n    StmtExprBits.TemplateDepth = TemplateDepth;\n  }\n\n  /// Build an empty statement expression.\n  explicit StmtExpr(EmptyShell Empty) : Expr(StmtExprClass, Empty) { }\n\n  CompoundStmt *getSubStmt() { return cast<CompoundStmt>(SubStmt); }\n  const CompoundStmt *getSubStmt() const { return cast<CompoundStmt>(SubStmt); }\n  void setSubStmt(CompoundStmt *S) { SubStmt = S; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return LParenLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  void setLParenLoc(SourceLocation L) { LParenLoc = L; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  unsigned getTemplateDepth() const { return StmtExprBits.TemplateDepth; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == StmtExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&SubStmt, &SubStmt+1); }\n  const_child_range children() const {\n    return const_child_range(&SubStmt, &SubStmt + 1);\n  }\n};\n\n/// ShuffleVectorExpr - clang-specific builtin-in function\n/// __builtin_shufflevector.\n/// This AST node represents a operator that does a constant\n/// shuffle, similar to LLVM's shufflevector instruction. It takes\n/// two vectors and a variable number of constant indices,\n/// and returns the appropriately shuffled vector.\nclass ShuffleVectorExpr : public Expr {\n  SourceLocation BuiltinLoc, RParenLoc;\n\n  // SubExprs - the list of values passed to the __builtin_shufflevector\n  // function. The first two are vectors, and the rest are constant\n  // indices.  The number of values in this list is always\n  // 2+the number of indices in the vector type.\n  Stmt **SubExprs;\n  unsigned NumExprs;\n\npublic:\n  ShuffleVectorExpr(const ASTContext &C, ArrayRef<Expr*> args, QualType Type,\n                    SourceLocation BLoc, SourceLocation RP);\n\n  /// Build an empty vector-shuffle expression.\n  explicit ShuffleVectorExpr(EmptyShell Empty)\n    : Expr(ShuffleVectorExprClass, Empty), SubExprs(nullptr) { }\n\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n  void setBuiltinLoc(SourceLocation L) { BuiltinLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ShuffleVectorExprClass;\n  }\n\n  /// getNumSubExprs - Return the size of the SubExprs array.  This includes the\n  /// constant expression, the actual arguments passed in, and the function\n  /// pointers.\n  unsigned getNumSubExprs() const { return NumExprs; }\n\n  /// Retrieve the array of expressions.\n  Expr **getSubExprs() { return reinterpret_cast<Expr **>(SubExprs); }\n\n  /// getExpr - Return the Expr at the specified index.\n  Expr *getExpr(unsigned Index) {\n    assert((Index < NumExprs) && \"Arg access out of range!\");\n    return cast<Expr>(SubExprs[Index]);\n  }\n  const Expr *getExpr(unsigned Index) const {\n    assert((Index < NumExprs) && \"Arg access out of range!\");\n    return cast<Expr>(SubExprs[Index]);\n  }\n\n  void setExprs(const ASTContext &C, ArrayRef<Expr *> Exprs);\n\n  llvm::APSInt getShuffleMaskIdx(const ASTContext &Ctx, unsigned N) const {\n    assert((N < NumExprs - 2) && \"Shuffle idx out of range!\");\n    return getExpr(N+2)->EvaluateKnownConstInt(Ctx);\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0]+NumExprs);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + NumExprs);\n  }\n};\n\n/// ConvertVectorExpr - Clang builtin function __builtin_convertvector\n/// This AST node provides support for converting a vector type to another\n/// vector type of the same arity.\nclass ConvertVectorExpr : public Expr {\nprivate:\n  Stmt *SrcExpr;\n  TypeSourceInfo *TInfo;\n  SourceLocation BuiltinLoc, RParenLoc;\n\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  explicit ConvertVectorExpr(EmptyShell Empty) : Expr(ConvertVectorExprClass, Empty) {}\n\npublic:\n  ConvertVectorExpr(Expr *SrcExpr, TypeSourceInfo *TI, QualType DstType,\n                    ExprValueKind VK, ExprObjectKind OK,\n                    SourceLocation BuiltinLoc, SourceLocation RParenLoc)\n      : Expr(ConvertVectorExprClass, DstType, VK, OK), SrcExpr(SrcExpr),\n        TInfo(TI), BuiltinLoc(BuiltinLoc), RParenLoc(RParenLoc) {\n    setDependence(computeDependence(this));\n  }\n\n  /// getSrcExpr - Return the Expr to be converted.\n  Expr *getSrcExpr() const { return cast<Expr>(SrcExpr); }\n\n  /// getTypeSourceInfo - Return the destination type.\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return TInfo;\n  }\n  void setTypeSourceInfo(TypeSourceInfo *ti) {\n    TInfo = ti;\n  }\n\n  /// getBuiltinLoc - Return the location of the __builtin_convertvector token.\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n\n  /// getRParenLoc - Return the location of final right parenthesis.\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ConvertVectorExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&SrcExpr, &SrcExpr+1); }\n  const_child_range children() const {\n    return const_child_range(&SrcExpr, &SrcExpr + 1);\n  }\n};\n\n/// ChooseExpr - GNU builtin-in function __builtin_choose_expr.\n/// This AST node is similar to the conditional operator (?:) in C, with\n/// the following exceptions:\n/// - the test expression must be a integer constant expression.\n/// - the expression returned acts like the chosen subexpression in every\n///   visible way: the type is the same as that of the chosen subexpression,\n///   and all predicates (whether it's an l-value, whether it's an integer\n///   constant expression, etc.) return the same result as for the chosen\n///   sub-expression.\nclass ChooseExpr : public Expr {\n  enum { COND, LHS, RHS, END_EXPR };\n  Stmt* SubExprs[END_EXPR]; // Left/Middle/Right hand sides.\n  SourceLocation BuiltinLoc, RParenLoc;\n  bool CondIsTrue;\npublic:\n  ChooseExpr(SourceLocation BLoc, Expr *cond, Expr *lhs, Expr *rhs, QualType t,\n             ExprValueKind VK, ExprObjectKind OK, SourceLocation RP,\n             bool condIsTrue)\n      : Expr(ChooseExprClass, t, VK, OK), BuiltinLoc(BLoc), RParenLoc(RP),\n        CondIsTrue(condIsTrue) {\n    SubExprs[COND] = cond;\n    SubExprs[LHS] = lhs;\n    SubExprs[RHS] = rhs;\n\n    setDependence(computeDependence(this));\n  }\n\n  /// Build an empty __builtin_choose_expr.\n  explicit ChooseExpr(EmptyShell Empty) : Expr(ChooseExprClass, Empty) { }\n\n  /// isConditionTrue - Return whether the condition is true (i.e. not\n  /// equal to zero).\n  bool isConditionTrue() const {\n    assert(!isConditionDependent() &&\n           \"Dependent condition isn't true or false\");\n    return CondIsTrue;\n  }\n  void setIsConditionTrue(bool isTrue) { CondIsTrue = isTrue; }\n\n  bool isConditionDependent() const {\n    return getCond()->isTypeDependent() || getCond()->isValueDependent();\n  }\n\n  /// getChosenSubExpr - Return the subexpression chosen according to the\n  /// condition.\n  Expr *getChosenSubExpr() const {\n    return isConditionTrue() ? getLHS() : getRHS();\n  }\n\n  Expr *getCond() const { return cast<Expr>(SubExprs[COND]); }\n  void setCond(Expr *E) { SubExprs[COND] = E; }\n  Expr *getLHS() const { return cast<Expr>(SubExprs[LHS]); }\n  void setLHS(Expr *E) { SubExprs[LHS] = E; }\n  Expr *getRHS() const { return cast<Expr>(SubExprs[RHS]); }\n  void setRHS(Expr *E) { SubExprs[RHS] = E; }\n\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n  void setBuiltinLoc(SourceLocation L) { BuiltinLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ChooseExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0]+END_EXPR);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n};\n\n/// GNUNullExpr - Implements the GNU __null extension, which is a name\n/// for a null pointer constant that has integral type (e.g., int or\n/// long) and is the same size and alignment as a pointer. The __null\n/// extension is typically only used by system headers, which define\n/// NULL as __null in C++ rather than using 0 (which is an integer\n/// that may not match the size of a pointer).\nclass GNUNullExpr : public Expr {\n  /// TokenLoc - The location of the __null keyword.\n  SourceLocation TokenLoc;\n\npublic:\n  GNUNullExpr(QualType Ty, SourceLocation Loc)\n      : Expr(GNUNullExprClass, Ty, VK_RValue, OK_Ordinary), TokenLoc(Loc) {\n    setDependence(ExprDependence::None);\n  }\n\n  /// Build an empty GNU __null expression.\n  explicit GNUNullExpr(EmptyShell Empty) : Expr(GNUNullExprClass, Empty) { }\n\n  /// getTokenLocation - The location of the __null token.\n  SourceLocation getTokenLocation() const { return TokenLoc; }\n  void setTokenLocation(SourceLocation L) { TokenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return TokenLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return TokenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == GNUNullExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Represents a call to the builtin function \\c __builtin_va_arg.\nclass VAArgExpr : public Expr {\n  Stmt *Val;\n  llvm::PointerIntPair<TypeSourceInfo *, 1, bool> TInfo;\n  SourceLocation BuiltinLoc, RParenLoc;\npublic:\n  VAArgExpr(SourceLocation BLoc, Expr *e, TypeSourceInfo *TInfo,\n            SourceLocation RPLoc, QualType t, bool IsMS)\n      : Expr(VAArgExprClass, t, VK_RValue, OK_Ordinary), Val(e),\n        TInfo(TInfo, IsMS), BuiltinLoc(BLoc), RParenLoc(RPLoc) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Create an empty __builtin_va_arg expression.\n  explicit VAArgExpr(EmptyShell Empty)\n      : Expr(VAArgExprClass, Empty), Val(nullptr), TInfo(nullptr, false) {}\n\n  const Expr *getSubExpr() const { return cast<Expr>(Val); }\n  Expr *getSubExpr() { return cast<Expr>(Val); }\n  void setSubExpr(Expr *E) { Val = E; }\n\n  /// Returns whether this is really a Win64 ABI va_arg expression.\n  bool isMicrosoftABI() const { return TInfo.getInt(); }\n  void setIsMicrosoftABI(bool IsMS) { TInfo.setInt(IsMS); }\n\n  TypeSourceInfo *getWrittenTypeInfo() const { return TInfo.getPointer(); }\n  void setWrittenTypeInfo(TypeSourceInfo *TI) { TInfo.setPointer(TI); }\n\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n  void setBuiltinLoc(SourceLocation L) { BuiltinLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == VAArgExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Val, &Val+1); }\n  const_child_range children() const {\n    return const_child_range(&Val, &Val + 1);\n  }\n};\n\n/// Represents a function call to one of __builtin_LINE(), __builtin_COLUMN(),\n/// __builtin_FUNCTION(), or __builtin_FILE().\nclass SourceLocExpr final : public Expr {\n  SourceLocation BuiltinLoc, RParenLoc;\n  DeclContext *ParentContext;\n\npublic:\n  enum IdentKind { Function, File, Line, Column };\n\n  SourceLocExpr(const ASTContext &Ctx, IdentKind Type, SourceLocation BLoc,\n                SourceLocation RParenLoc, DeclContext *Context);\n\n  /// Build an empty call expression.\n  explicit SourceLocExpr(EmptyShell Empty) : Expr(SourceLocExprClass, Empty) {}\n\n  /// Return the result of evaluating this SourceLocExpr in the specified\n  /// (and possibly null) default argument or initialization context.\n  APValue EvaluateInContext(const ASTContext &Ctx,\n                            const Expr *DefaultExpr) const;\n\n  /// Return a string representing the name of the specific builtin function.\n  StringRef getBuiltinStr() const;\n\n  IdentKind getIdentKind() const {\n    return static_cast<IdentKind>(SourceLocExprBits.Kind);\n  }\n\n  bool isStringType() const {\n    switch (getIdentKind()) {\n    case File:\n    case Function:\n      return true;\n    case Line:\n    case Column:\n      return false;\n    }\n    llvm_unreachable(\"unknown source location expression kind\");\n  }\n  bool isIntType() const LLVM_READONLY { return !isStringType(); }\n\n  /// If the SourceLocExpr has been resolved return the subexpression\n  /// representing the resolved value. Otherwise return null.\n  const DeclContext *getParentContext() const { return ParentContext; }\n  DeclContext *getParentContext() { return ParentContext; }\n\n  SourceLocation getLocation() const { return BuiltinLoc; }\n  SourceLocation getBeginLoc() const { return BuiltinLoc; }\n  SourceLocation getEndLoc() const { return RParenLoc; }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(child_iterator(), child_iterator());\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == SourceLocExprClass;\n  }\n\nprivate:\n  friend class ASTStmtReader;\n};\n\n/// Describes an C or C++ initializer list.\n///\n/// InitListExpr describes an initializer list, which can be used to\n/// initialize objects of different types, including\n/// struct/class/union types, arrays, and vectors. For example:\n///\n/// @code\n/// struct foo x = { 1, { 2, 3 } };\n/// @endcode\n///\n/// Prior to semantic analysis, an initializer list will represent the\n/// initializer list as written by the user, but will have the\n/// placeholder type \"void\". This initializer list is called the\n/// syntactic form of the initializer, and may contain C99 designated\n/// initializers (represented as DesignatedInitExprs), initializations\n/// of subobject members without explicit braces, and so on. Clients\n/// interested in the original syntax of the initializer list should\n/// use the syntactic form of the initializer list.\n///\n/// After semantic analysis, the initializer list will represent the\n/// semantic form of the initializer, where the initializations of all\n/// subobjects are made explicit with nested InitListExpr nodes and\n/// C99 designators have been eliminated by placing the designated\n/// initializations into the subobject they initialize. Additionally,\n/// any \"holes\" in the initialization, where no initializer has been\n/// specified for a particular subobject, will be replaced with\n/// implicitly-generated ImplicitValueInitExpr expressions that\n/// value-initialize the subobjects. Note, however, that the\n/// initializer lists may still have fewer initializers than there are\n/// elements to initialize within the object.\n///\n/// After semantic analysis has completed, given an initializer list,\n/// method isSemanticForm() returns true if and only if this is the\n/// semantic form of the initializer list (note: the same AST node\n/// may at the same time be the syntactic form).\n/// Given the semantic form of the initializer list, one can retrieve\n/// the syntactic form of that initializer list (when different)\n/// using method getSyntacticForm(); the method returns null if applied\n/// to a initializer list which is already in syntactic form.\n/// Similarly, given the syntactic form (i.e., an initializer list such\n/// that isSemanticForm() returns false), one can retrieve the semantic\n/// form using method getSemanticForm().\n/// Since many initializer lists have the same syntactic and semantic forms,\n/// getSyntacticForm() may return NULL, indicating that the current\n/// semantic initializer list also serves as its syntactic form.\nclass InitListExpr : public Expr {\n  // FIXME: Eliminate this vector in favor of ASTContext allocation\n  typedef ASTVector<Stmt *> InitExprsTy;\n  InitExprsTy InitExprs;\n  SourceLocation LBraceLoc, RBraceLoc;\n\n  /// The alternative form of the initializer list (if it exists).\n  /// The int part of the pair stores whether this initializer list is\n  /// in semantic form. If not null, the pointer points to:\n  ///   - the syntactic form, if this is in semantic form;\n  ///   - the semantic form, if this is in syntactic form.\n  llvm::PointerIntPair<InitListExpr *, 1, bool> AltForm;\n\n  /// Either:\n  ///  If this initializer list initializes an array with more elements than\n  ///  there are initializers in the list, specifies an expression to be used\n  ///  for value initialization of the rest of the elements.\n  /// Or\n  ///  If this initializer list initializes a union, specifies which\n  ///  field within the union will be initialized.\n  llvm::PointerUnion<Expr *, FieldDecl *> ArrayFillerOrUnionFieldInit;\n\npublic:\n  InitListExpr(const ASTContext &C, SourceLocation lbraceloc,\n               ArrayRef<Expr*> initExprs, SourceLocation rbraceloc);\n\n  /// Build an empty initializer list.\n  explicit InitListExpr(EmptyShell Empty)\n    : Expr(InitListExprClass, Empty), AltForm(nullptr, true) { }\n\n  unsigned getNumInits() const { return InitExprs.size(); }\n\n  /// Retrieve the set of initializers.\n  Expr **getInits() { return reinterpret_cast<Expr **>(InitExprs.data()); }\n\n  /// Retrieve the set of initializers.\n  Expr * const *getInits() const {\n    return reinterpret_cast<Expr * const *>(InitExprs.data());\n  }\n\n  ArrayRef<Expr *> inits() {\n    return llvm::makeArrayRef(getInits(), getNumInits());\n  }\n\n  ArrayRef<Expr *> inits() const {\n    return llvm::makeArrayRef(getInits(), getNumInits());\n  }\n\n  const Expr *getInit(unsigned Init) const {\n    assert(Init < getNumInits() && \"Initializer access out of range!\");\n    return cast_or_null<Expr>(InitExprs[Init]);\n  }\n\n  Expr *getInit(unsigned Init) {\n    assert(Init < getNumInits() && \"Initializer access out of range!\");\n    return cast_or_null<Expr>(InitExprs[Init]);\n  }\n\n  void setInit(unsigned Init, Expr *expr) {\n    assert(Init < getNumInits() && \"Initializer access out of range!\");\n    InitExprs[Init] = expr;\n\n    if (expr)\n      setDependence(getDependence() | expr->getDependence());\n  }\n\n  /// Mark the semantic form of the InitListExpr as error when the semantic\n  /// analysis fails.\n  void markError() {\n    assert(isSemanticForm());\n    setDependence(getDependence() | ExprDependence::ErrorDependent);\n  }\n\n  /// Reserve space for some number of initializers.\n  void reserveInits(const ASTContext &C, unsigned NumInits);\n\n  /// Specify the number of initializers\n  ///\n  /// If there are more than @p NumInits initializers, the remaining\n  /// initializers will be destroyed. If there are fewer than @p\n  /// NumInits initializers, NULL expressions will be added for the\n  /// unknown initializers.\n  void resizeInits(const ASTContext &Context, unsigned NumInits);\n\n  /// Updates the initializer at index @p Init with the new\n  /// expression @p expr, and returns the old expression at that\n  /// location.\n  ///\n  /// When @p Init is out of range for this initializer list, the\n  /// initializer list will be extended with NULL expressions to\n  /// accommodate the new entry.\n  Expr *updateInit(const ASTContext &C, unsigned Init, Expr *expr);\n\n  /// If this initializer list initializes an array with more elements\n  /// than there are initializers in the list, specifies an expression to be\n  /// used for value initialization of the rest of the elements.\n  Expr *getArrayFiller() {\n    return ArrayFillerOrUnionFieldInit.dyn_cast<Expr *>();\n  }\n  const Expr *getArrayFiller() const {\n    return const_cast<InitListExpr *>(this)->getArrayFiller();\n  }\n  void setArrayFiller(Expr *filler);\n\n  /// Return true if this is an array initializer and its array \"filler\"\n  /// has been set.\n  bool hasArrayFiller() const { return getArrayFiller(); }\n\n  /// If this initializes a union, specifies which field in the\n  /// union to initialize.\n  ///\n  /// Typically, this field is the first named field within the\n  /// union. However, a designated initializer can specify the\n  /// initialization of a different field within the union.\n  FieldDecl *getInitializedFieldInUnion() {\n    return ArrayFillerOrUnionFieldInit.dyn_cast<FieldDecl *>();\n  }\n  const FieldDecl *getInitializedFieldInUnion() const {\n    return const_cast<InitListExpr *>(this)->getInitializedFieldInUnion();\n  }\n  void setInitializedFieldInUnion(FieldDecl *FD) {\n    assert((FD == nullptr\n            || getInitializedFieldInUnion() == nullptr\n            || getInitializedFieldInUnion() == FD)\n           && \"Only one field of a union may be initialized at a time!\");\n    ArrayFillerOrUnionFieldInit = FD;\n  }\n\n  // Explicit InitListExpr's originate from source code (and have valid source\n  // locations). Implicit InitListExpr's are created by the semantic analyzer.\n  // FIXME: This is wrong; InitListExprs created by semantic analysis have\n  // valid source locations too!\n  bool isExplicit() const {\n    return LBraceLoc.isValid() && RBraceLoc.isValid();\n  }\n\n  // Is this an initializer for an array of characters, initialized by a string\n  // literal or an @encode?\n  bool isStringLiteralInit() const;\n\n  /// Is this a transparent initializer list (that is, an InitListExpr that is\n  /// purely syntactic, and whose semantics are that of the sole contained\n  /// initializer)?\n  bool isTransparent() const;\n\n  /// Is this the zero initializer {0} in a language which considers it\n  /// idiomatic?\n  bool isIdiomaticZeroInitializer(const LangOptions &LangOpts) const;\n\n  SourceLocation getLBraceLoc() const { return LBraceLoc; }\n  void setLBraceLoc(SourceLocation Loc) { LBraceLoc = Loc; }\n  SourceLocation getRBraceLoc() const { return RBraceLoc; }\n  void setRBraceLoc(SourceLocation Loc) { RBraceLoc = Loc; }\n\n  bool isSemanticForm() const { return AltForm.getInt(); }\n  InitListExpr *getSemanticForm() const {\n    return isSemanticForm() ? nullptr : AltForm.getPointer();\n  }\n  bool isSyntacticForm() const {\n    return !AltForm.getInt() || !AltForm.getPointer();\n  }\n  InitListExpr *getSyntacticForm() const {\n    return isSemanticForm() ? AltForm.getPointer() : nullptr;\n  }\n\n  void setSyntacticForm(InitListExpr *Init) {\n    AltForm.setPointer(Init);\n    AltForm.setInt(true);\n    Init->AltForm.setPointer(this);\n    Init->AltForm.setInt(false);\n  }\n\n  bool hadArrayRangeDesignator() const {\n    return InitListExprBits.HadArrayRangeDesignator != 0;\n  }\n  void sawArrayRangeDesignator(bool ARD = true) {\n    InitListExprBits.HadArrayRangeDesignator = ARD;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == InitListExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    const_child_range CCR = const_cast<const InitListExpr *>(this)->children();\n    return child_range(cast_away_const(CCR.begin()),\n                       cast_away_const(CCR.end()));\n  }\n\n  const_child_range children() const {\n    // FIXME: This does not include the array filler expression.\n    if (InitExprs.empty())\n      return const_child_range(const_child_iterator(), const_child_iterator());\n    return const_child_range(&InitExprs[0], &InitExprs[0] + InitExprs.size());\n  }\n\n  typedef InitExprsTy::iterator iterator;\n  typedef InitExprsTy::const_iterator const_iterator;\n  typedef InitExprsTy::reverse_iterator reverse_iterator;\n  typedef InitExprsTy::const_reverse_iterator const_reverse_iterator;\n\n  iterator begin() { return InitExprs.begin(); }\n  const_iterator begin() const { return InitExprs.begin(); }\n  iterator end() { return InitExprs.end(); }\n  const_iterator end() const { return InitExprs.end(); }\n  reverse_iterator rbegin() { return InitExprs.rbegin(); }\n  const_reverse_iterator rbegin() const { return InitExprs.rbegin(); }\n  reverse_iterator rend() { return InitExprs.rend(); }\n  const_reverse_iterator rend() const { return InitExprs.rend(); }\n\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n};\n\n/// Represents a C99 designated initializer expression.\n///\n/// A designated initializer expression (C99 6.7.8) contains one or\n/// more designators (which can be field designators, array\n/// designators, or GNU array-range designators) followed by an\n/// expression that initializes the field or element(s) that the\n/// designators refer to. For example, given:\n///\n/// @code\n/// struct point {\n///   double x;\n///   double y;\n/// };\n/// struct point ptarray[10] = { [2].y = 1.0, [2].x = 2.0, [0].x = 1.0 };\n/// @endcode\n///\n/// The InitListExpr contains three DesignatedInitExprs, the first of\n/// which covers @c [2].y=1.0. This DesignatedInitExpr will have two\n/// designators, one array designator for @c [2] followed by one field\n/// designator for @c .y. The initialization expression will be 1.0.\nclass DesignatedInitExpr final\n    : public Expr,\n      private llvm::TrailingObjects<DesignatedInitExpr, Stmt *> {\npublic:\n  /// Forward declaration of the Designator class.\n  class Designator;\n\nprivate:\n  /// The location of the '=' or ':' prior to the actual initializer\n  /// expression.\n  SourceLocation EqualOrColonLoc;\n\n  /// Whether this designated initializer used the GNU deprecated\n  /// syntax rather than the C99 '=' syntax.\n  unsigned GNUSyntax : 1;\n\n  /// The number of designators in this initializer expression.\n  unsigned NumDesignators : 15;\n\n  /// The number of subexpressions of this initializer expression,\n  /// which contains both the initializer and any additional\n  /// expressions used by array and array-range designators.\n  unsigned NumSubExprs : 16;\n\n  /// The designators in this designated initialization\n  /// expression.\n  Designator *Designators;\n\n  DesignatedInitExpr(const ASTContext &C, QualType Ty,\n                     llvm::ArrayRef<Designator> Designators,\n                     SourceLocation EqualOrColonLoc, bool GNUSyntax,\n                     ArrayRef<Expr *> IndexExprs, Expr *Init);\n\n  explicit DesignatedInitExpr(unsigned NumSubExprs)\n    : Expr(DesignatedInitExprClass, EmptyShell()),\n      NumDesignators(0), NumSubExprs(NumSubExprs), Designators(nullptr) { }\n\npublic:\n  /// A field designator, e.g., \".x\".\n  struct FieldDesignator {\n    /// Refers to the field that is being initialized. The low bit\n    /// of this field determines whether this is actually a pointer\n    /// to an IdentifierInfo (if 1) or a FieldDecl (if 0). When\n    /// initially constructed, a field designator will store an\n    /// IdentifierInfo*. After semantic analysis has resolved that\n    /// name, the field designator will instead store a FieldDecl*.\n    uintptr_t NameOrField;\n\n    /// The location of the '.' in the designated initializer.\n    SourceLocation DotLoc;\n\n    /// The location of the field name in the designated initializer.\n    SourceLocation FieldLoc;\n  };\n\n  /// An array or GNU array-range designator, e.g., \"[9]\" or \"[10..15]\".\n  struct ArrayOrRangeDesignator {\n    /// Location of the first index expression within the designated\n    /// initializer expression's list of subexpressions.\n    unsigned Index;\n    /// The location of the '[' starting the array range designator.\n    SourceLocation LBracketLoc;\n    /// The location of the ellipsis separating the start and end\n    /// indices. Only valid for GNU array-range designators.\n    SourceLocation EllipsisLoc;\n    /// The location of the ']' terminating the array range designator.\n    SourceLocation RBracketLoc;\n  };\n\n  /// Represents a single C99 designator.\n  ///\n  /// @todo This class is infuriatingly similar to clang::Designator,\n  /// but minor differences (storing indices vs. storing pointers)\n  /// keep us from reusing it. Try harder, later, to rectify these\n  /// differences.\n  class Designator {\n    /// The kind of designator this describes.\n    enum {\n      FieldDesignator,\n      ArrayDesignator,\n      ArrayRangeDesignator\n    } Kind;\n\n    union {\n      /// A field designator, e.g., \".x\".\n      struct FieldDesignator Field;\n      /// An array or GNU array-range designator, e.g., \"[9]\" or \"[10..15]\".\n      struct ArrayOrRangeDesignator ArrayOrRange;\n    };\n    friend class DesignatedInitExpr;\n\n  public:\n    Designator() {}\n\n    /// Initializes a field designator.\n    Designator(const IdentifierInfo *FieldName, SourceLocation DotLoc,\n               SourceLocation FieldLoc)\n      : Kind(FieldDesignator) {\n      new (&Field) DesignatedInitExpr::FieldDesignator;\n      Field.NameOrField = reinterpret_cast<uintptr_t>(FieldName) | 0x01;\n      Field.DotLoc = DotLoc;\n      Field.FieldLoc = FieldLoc;\n    }\n\n    /// Initializes an array designator.\n    Designator(unsigned Index, SourceLocation LBracketLoc,\n               SourceLocation RBracketLoc)\n      : Kind(ArrayDesignator) {\n      new (&ArrayOrRange) DesignatedInitExpr::ArrayOrRangeDesignator;\n      ArrayOrRange.Index = Index;\n      ArrayOrRange.LBracketLoc = LBracketLoc;\n      ArrayOrRange.EllipsisLoc = SourceLocation();\n      ArrayOrRange.RBracketLoc = RBracketLoc;\n    }\n\n    /// Initializes a GNU array-range designator.\n    Designator(unsigned Index, SourceLocation LBracketLoc,\n               SourceLocation EllipsisLoc, SourceLocation RBracketLoc)\n      : Kind(ArrayRangeDesignator) {\n      new (&ArrayOrRange) DesignatedInitExpr::ArrayOrRangeDesignator;\n      ArrayOrRange.Index = Index;\n      ArrayOrRange.LBracketLoc = LBracketLoc;\n      ArrayOrRange.EllipsisLoc = EllipsisLoc;\n      ArrayOrRange.RBracketLoc = RBracketLoc;\n    }\n\n    bool isFieldDesignator() const { return Kind == FieldDesignator; }\n    bool isArrayDesignator() const { return Kind == ArrayDesignator; }\n    bool isArrayRangeDesignator() const { return Kind == ArrayRangeDesignator; }\n\n    IdentifierInfo *getFieldName() const;\n\n    FieldDecl *getField() const {\n      assert(Kind == FieldDesignator && \"Only valid on a field designator\");\n      if (Field.NameOrField & 0x01)\n        return nullptr;\n      else\n        return reinterpret_cast<FieldDecl *>(Field.NameOrField);\n    }\n\n    void setField(FieldDecl *FD) {\n      assert(Kind == FieldDesignator && \"Only valid on a field designator\");\n      Field.NameOrField = reinterpret_cast<uintptr_t>(FD);\n    }\n\n    SourceLocation getDotLoc() const {\n      assert(Kind == FieldDesignator && \"Only valid on a field designator\");\n      return Field.DotLoc;\n    }\n\n    SourceLocation getFieldLoc() const {\n      assert(Kind == FieldDesignator && \"Only valid on a field designator\");\n      return Field.FieldLoc;\n    }\n\n    SourceLocation getLBracketLoc() const {\n      assert((Kind == ArrayDesignator || Kind == ArrayRangeDesignator) &&\n             \"Only valid on an array or array-range designator\");\n      return ArrayOrRange.LBracketLoc;\n    }\n\n    SourceLocation getRBracketLoc() const {\n      assert((Kind == ArrayDesignator || Kind == ArrayRangeDesignator) &&\n             \"Only valid on an array or array-range designator\");\n      return ArrayOrRange.RBracketLoc;\n    }\n\n    SourceLocation getEllipsisLoc() const {\n      assert(Kind == ArrayRangeDesignator &&\n             \"Only valid on an array-range designator\");\n      return ArrayOrRange.EllipsisLoc;\n    }\n\n    unsigned getFirstExprIndex() const {\n      assert((Kind == ArrayDesignator || Kind == ArrayRangeDesignator) &&\n             \"Only valid on an array or array-range designator\");\n      return ArrayOrRange.Index;\n    }\n\n    SourceLocation getBeginLoc() const LLVM_READONLY {\n      if (Kind == FieldDesignator)\n        return getDotLoc().isInvalid()? getFieldLoc() : getDotLoc();\n      else\n        return getLBracketLoc();\n    }\n    SourceLocation getEndLoc() const LLVM_READONLY {\n      return Kind == FieldDesignator ? getFieldLoc() : getRBracketLoc();\n    }\n    SourceRange getSourceRange() const LLVM_READONLY {\n      return SourceRange(getBeginLoc(), getEndLoc());\n    }\n  };\n\n  static DesignatedInitExpr *Create(const ASTContext &C,\n                                    llvm::ArrayRef<Designator> Designators,\n                                    ArrayRef<Expr*> IndexExprs,\n                                    SourceLocation EqualOrColonLoc,\n                                    bool GNUSyntax, Expr *Init);\n\n  static DesignatedInitExpr *CreateEmpty(const ASTContext &C,\n                                         unsigned NumIndexExprs);\n\n  /// Returns the number of designators in this initializer.\n  unsigned size() const { return NumDesignators; }\n\n  // Iterator access to the designators.\n  llvm::MutableArrayRef<Designator> designators() {\n    return {Designators, NumDesignators};\n  }\n\n  llvm::ArrayRef<Designator> designators() const {\n    return {Designators, NumDesignators};\n  }\n\n  Designator *getDesignator(unsigned Idx) { return &designators()[Idx]; }\n  const Designator *getDesignator(unsigned Idx) const {\n    return &designators()[Idx];\n  }\n\n  void setDesignators(const ASTContext &C, const Designator *Desigs,\n                      unsigned NumDesigs);\n\n  Expr *getArrayIndex(const Designator &D) const;\n  Expr *getArrayRangeStart(const Designator &D) const;\n  Expr *getArrayRangeEnd(const Designator &D) const;\n\n  /// Retrieve the location of the '=' that precedes the\n  /// initializer value itself, if present.\n  SourceLocation getEqualOrColonLoc() const { return EqualOrColonLoc; }\n  void setEqualOrColonLoc(SourceLocation L) { EqualOrColonLoc = L; }\n\n  /// Whether this designated initializer should result in direct-initialization\n  /// of the designated subobject (eg, '{.foo{1, 2, 3}}').\n  bool isDirectInit() const { return EqualOrColonLoc.isInvalid(); }\n\n  /// Determines whether this designated initializer used the\n  /// deprecated GNU syntax for designated initializers.\n  bool usesGNUSyntax() const { return GNUSyntax; }\n  void setGNUSyntax(bool GNU) { GNUSyntax = GNU; }\n\n  /// Retrieve the initializer value.\n  Expr *getInit() const {\n    return cast<Expr>(*const_cast<DesignatedInitExpr*>(this)->child_begin());\n  }\n\n  void setInit(Expr *init) {\n    *child_begin() = init;\n  }\n\n  /// Retrieve the total number of subexpressions in this\n  /// designated initializer expression, including the actual\n  /// initialized value and any expressions that occur within array\n  /// and array-range designators.\n  unsigned getNumSubExprs() const { return NumSubExprs; }\n\n  Expr *getSubExpr(unsigned Idx) const {\n    assert(Idx < NumSubExprs && \"Subscript out of range\");\n    return cast<Expr>(getTrailingObjects<Stmt *>()[Idx]);\n  }\n\n  void setSubExpr(unsigned Idx, Expr *E) {\n    assert(Idx < NumSubExprs && \"Subscript out of range\");\n    getTrailingObjects<Stmt *>()[Idx] = E;\n  }\n\n  /// Replaces the designator at index @p Idx with the series\n  /// of designators in [First, Last).\n  void ExpandDesignator(const ASTContext &C, unsigned Idx,\n                        const Designator *First, const Designator *Last);\n\n  SourceRange getDesignatorsSourceRange() const;\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == DesignatedInitExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    Stmt **begin = getTrailingObjects<Stmt *>();\n    return child_range(begin, begin + NumSubExprs);\n  }\n  const_child_range children() const {\n    Stmt * const *begin = getTrailingObjects<Stmt *>();\n    return const_child_range(begin, begin + NumSubExprs);\n  }\n\n  friend TrailingObjects;\n};\n\n/// Represents a place-holder for an object not to be initialized by\n/// anything.\n///\n/// This only makes sense when it appears as part of an updater of a\n/// DesignatedInitUpdateExpr (see below). The base expression of a DIUE\n/// initializes a big object, and the NoInitExpr's mark the spots within the\n/// big object not to be overwritten by the updater.\n///\n/// \\see DesignatedInitUpdateExpr\nclass NoInitExpr : public Expr {\npublic:\n  explicit NoInitExpr(QualType ty)\n      : Expr(NoInitExprClass, ty, VK_RValue, OK_Ordinary) {\n    setDependence(computeDependence(this));\n  }\n\n  explicit NoInitExpr(EmptyShell Empty)\n    : Expr(NoInitExprClass, Empty) { }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == NoInitExprClass;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return SourceLocation(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return SourceLocation(); }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n// In cases like:\n//   struct Q { int a, b, c; };\n//   Q *getQ();\n//   void foo() {\n//     struct A { Q q; } a = { *getQ(), .q.b = 3 };\n//   }\n//\n// We will have an InitListExpr for a, with type A, and then a\n// DesignatedInitUpdateExpr for \"a.q\" with type Q. The \"base\" for this DIUE\n// is the call expression *getQ(); the \"updater\" for the DIUE is \".q.b = 3\"\n//\nclass DesignatedInitUpdateExpr : public Expr {\n  // BaseAndUpdaterExprs[0] is the base expression;\n  // BaseAndUpdaterExprs[1] is an InitListExpr overwriting part of the base.\n  Stmt *BaseAndUpdaterExprs[2];\n\npublic:\n  DesignatedInitUpdateExpr(const ASTContext &C, SourceLocation lBraceLoc,\n                           Expr *baseExprs, SourceLocation rBraceLoc);\n\n  explicit DesignatedInitUpdateExpr(EmptyShell Empty)\n    : Expr(DesignatedInitUpdateExprClass, Empty) { }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == DesignatedInitUpdateExprClass;\n  }\n\n  Expr *getBase() const { return cast<Expr>(BaseAndUpdaterExprs[0]); }\n  void setBase(Expr *Base) { BaseAndUpdaterExprs[0] = Base; }\n\n  InitListExpr *getUpdater() const {\n    return cast<InitListExpr>(BaseAndUpdaterExprs[1]);\n  }\n  void setUpdater(Expr *Updater) { BaseAndUpdaterExprs[1] = Updater; }\n\n  // Iterators\n  // children = the base and the updater\n  child_range children() {\n    return child_range(&BaseAndUpdaterExprs[0], &BaseAndUpdaterExprs[0] + 2);\n  }\n  const_child_range children() const {\n    return const_child_range(&BaseAndUpdaterExprs[0],\n                             &BaseAndUpdaterExprs[0] + 2);\n  }\n};\n\n/// Represents a loop initializing the elements of an array.\n///\n/// The need to initialize the elements of an array occurs in a number of\n/// contexts:\n///\n///  * in the implicit copy/move constructor for a class with an array member\n///  * when a lambda-expression captures an array by value\n///  * when a decomposition declaration decomposes an array\n///\n/// There are two subexpressions: a common expression (the source array)\n/// that is evaluated once up-front, and a per-element initializer that\n/// runs once for each array element.\n///\n/// Within the per-element initializer, the common expression may be referenced\n/// via an OpaqueValueExpr, and the current index may be obtained via an\n/// ArrayInitIndexExpr.\nclass ArrayInitLoopExpr : public Expr {\n  Stmt *SubExprs[2];\n\n  explicit ArrayInitLoopExpr(EmptyShell Empty)\n      : Expr(ArrayInitLoopExprClass, Empty), SubExprs{} {}\n\npublic:\n  explicit ArrayInitLoopExpr(QualType T, Expr *CommonInit, Expr *ElementInit)\n      : Expr(ArrayInitLoopExprClass, T, VK_RValue, OK_Ordinary),\n        SubExprs{CommonInit, ElementInit} {\n    setDependence(computeDependence(this));\n  }\n\n  /// Get the common subexpression shared by all initializations (the source\n  /// array).\n  OpaqueValueExpr *getCommonExpr() const {\n    return cast<OpaqueValueExpr>(SubExprs[0]);\n  }\n\n  /// Get the initializer to use for each array element.\n  Expr *getSubExpr() const { return cast<Expr>(SubExprs[1]); }\n\n  llvm::APInt getArraySize() const {\n    return cast<ConstantArrayType>(getType()->castAsArrayTypeUnsafe())\n        ->getSize();\n  }\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() == ArrayInitLoopExprClass;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getCommonExpr()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getCommonExpr()->getEndLoc();\n  }\n\n  child_range children() {\n    return child_range(SubExprs, SubExprs + 2);\n  }\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + 2);\n  }\n\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n};\n\n/// Represents the index of the current element of an array being\n/// initialized by an ArrayInitLoopExpr. This can only appear within the\n/// subexpression of an ArrayInitLoopExpr.\nclass ArrayInitIndexExpr : public Expr {\n  explicit ArrayInitIndexExpr(EmptyShell Empty)\n      : Expr(ArrayInitIndexExprClass, Empty) {}\n\npublic:\n  explicit ArrayInitIndexExpr(QualType T)\n      : Expr(ArrayInitIndexExprClass, T, VK_RValue, OK_Ordinary) {\n    setDependence(ExprDependence::None);\n  }\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() == ArrayInitIndexExprClass;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return SourceLocation(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return SourceLocation(); }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  friend class ASTReader;\n  friend class ASTStmtReader;\n};\n\n/// Represents an implicitly-generated value initialization of\n/// an object of a given type.\n///\n/// Implicit value initializations occur within semantic initializer\n/// list expressions (InitListExpr) as placeholders for subobject\n/// initializations not explicitly specified by the user.\n///\n/// \\see InitListExpr\nclass ImplicitValueInitExpr : public Expr {\npublic:\n  explicit ImplicitValueInitExpr(QualType ty)\n      : Expr(ImplicitValueInitExprClass, ty, VK_RValue, OK_Ordinary) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Construct an empty implicit value initialization.\n  explicit ImplicitValueInitExpr(EmptyShell Empty)\n    : Expr(ImplicitValueInitExprClass, Empty) { }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ImplicitValueInitExprClass;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return SourceLocation(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return SourceLocation(); }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\nclass ParenListExpr final\n    : public Expr,\n      private llvm::TrailingObjects<ParenListExpr, Stmt *> {\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  /// The location of the left and right parentheses.\n  SourceLocation LParenLoc, RParenLoc;\n\n  /// Build a paren list.\n  ParenListExpr(SourceLocation LParenLoc, ArrayRef<Expr *> Exprs,\n                SourceLocation RParenLoc);\n\n  /// Build an empty paren list.\n  ParenListExpr(EmptyShell Empty, unsigned NumExprs);\n\npublic:\n  /// Create a paren list.\n  static ParenListExpr *Create(const ASTContext &Ctx, SourceLocation LParenLoc,\n                               ArrayRef<Expr *> Exprs,\n                               SourceLocation RParenLoc);\n\n  /// Create an empty paren list.\n  static ParenListExpr *CreateEmpty(const ASTContext &Ctx, unsigned NumExprs);\n\n  /// Return the number of expressions in this paren list.\n  unsigned getNumExprs() const { return ParenListExprBits.NumExprs; }\n\n  Expr *getExpr(unsigned Init) {\n    assert(Init < getNumExprs() && \"Initializer access out of range!\");\n    return getExprs()[Init];\n  }\n\n  const Expr *getExpr(unsigned Init) const {\n    return const_cast<ParenListExpr *>(this)->getExpr(Init);\n  }\n\n  Expr **getExprs() {\n    return reinterpret_cast<Expr **>(getTrailingObjects<Stmt *>());\n  }\n\n  ArrayRef<Expr *> exprs() {\n    return llvm::makeArrayRef(getExprs(), getNumExprs());\n  }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  SourceLocation getBeginLoc() const { return getLParenLoc(); }\n  SourceLocation getEndLoc() const { return getRParenLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ParenListExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(getTrailingObjects<Stmt *>(),\n                       getTrailingObjects<Stmt *>() + getNumExprs());\n  }\n  const_child_range children() const {\n    return const_child_range(getTrailingObjects<Stmt *>(),\n                             getTrailingObjects<Stmt *>() + getNumExprs());\n  }\n};\n\n/// Represents a C11 generic selection.\n///\n/// A generic selection (C11 6.5.1.1) contains an unevaluated controlling\n/// expression, followed by one or more generic associations.  Each generic\n/// association specifies a type name and an expression, or \"default\" and an\n/// expression (in which case it is known as a default generic association).\n/// The type and value of the generic selection are identical to those of its\n/// result expression, which is defined as the expression in the generic\n/// association with a type name that is compatible with the type of the\n/// controlling expression, or the expression in the default generic association\n/// if no types are compatible.  For example:\n///\n/// @code\n/// _Generic(X, double: 1, float: 2, default: 3)\n/// @endcode\n///\n/// The above expression evaluates to 1 if 1.0 is substituted for X, 2 if 1.0f\n/// or 3 if \"hello\".\n///\n/// As an extension, generic selections are allowed in C++, where the following\n/// additional semantics apply:\n///\n/// Any generic selection whose controlling expression is type-dependent or\n/// which names a dependent type in its association list is result-dependent,\n/// which means that the choice of result expression is dependent.\n/// Result-dependent generic associations are both type- and value-dependent.\nclass GenericSelectionExpr final\n    : public Expr,\n      private llvm::TrailingObjects<GenericSelectionExpr, Stmt *,\n                                    TypeSourceInfo *> {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// The number of association expressions and the index of the result\n  /// expression in the case where the generic selection expression is not\n  /// result-dependent. The result index is equal to ResultDependentIndex\n  /// if and only if the generic selection expression is result-dependent.\n  unsigned NumAssocs, ResultIndex;\n  enum : unsigned {\n    ResultDependentIndex = std::numeric_limits<unsigned>::max(),\n    ControllingIndex = 0,\n    AssocExprStartIndex = 1\n  };\n\n  /// The location of the \"default\" and of the right parenthesis.\n  SourceLocation DefaultLoc, RParenLoc;\n\n  // GenericSelectionExpr is followed by several trailing objects.\n  // They are (in order):\n  //\n  // * A single Stmt * for the controlling expression.\n  // * An array of getNumAssocs() Stmt * for the association expressions.\n  // * An array of getNumAssocs() TypeSourceInfo *, one for each of the\n  //   association expressions.\n  unsigned numTrailingObjects(OverloadToken<Stmt *>) const {\n    // Add one to account for the controlling expression; the remainder\n    // are the associated expressions.\n    return 1 + getNumAssocs();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<TypeSourceInfo *>) const {\n    return getNumAssocs();\n  }\n\n  template <bool Const> class AssociationIteratorTy;\n  /// Bundle together an association expression and its TypeSourceInfo.\n  /// The Const template parameter is for the const and non-const versions\n  /// of AssociationTy.\n  template <bool Const> class AssociationTy {\n    friend class GenericSelectionExpr;\n    template <bool OtherConst> friend class AssociationIteratorTy;\n    using ExprPtrTy = std::conditional_t<Const, const Expr *, Expr *>;\n    using TSIPtrTy =\n        std::conditional_t<Const, const TypeSourceInfo *, TypeSourceInfo *>;\n    ExprPtrTy E;\n    TSIPtrTy TSI;\n    bool Selected;\n    AssociationTy(ExprPtrTy E, TSIPtrTy TSI, bool Selected)\n        : E(E), TSI(TSI), Selected(Selected) {}\n\n  public:\n    ExprPtrTy getAssociationExpr() const { return E; }\n    TSIPtrTy getTypeSourceInfo() const { return TSI; }\n    QualType getType() const { return TSI ? TSI->getType() : QualType(); }\n    bool isSelected() const { return Selected; }\n    AssociationTy *operator->() { return this; }\n    const AssociationTy *operator->() const { return this; }\n  }; // class AssociationTy\n\n  /// Iterator over const and non-const Association objects. The Association\n  /// objects are created on the fly when the iterator is dereferenced.\n  /// This abstract over how exactly the association expressions and the\n  /// corresponding TypeSourceInfo * are stored.\n  template <bool Const>\n  class AssociationIteratorTy\n      : public llvm::iterator_facade_base<\n            AssociationIteratorTy<Const>, std::input_iterator_tag,\n            AssociationTy<Const>, std::ptrdiff_t, AssociationTy<Const>,\n            AssociationTy<Const>> {\n    friend class GenericSelectionExpr;\n    // FIXME: This iterator could conceptually be a random access iterator, and\n    // it would be nice if we could strengthen the iterator category someday.\n    // However this iterator does not satisfy two requirements of forward\n    // iterators:\n    // a) reference = T& or reference = const T&\n    // b) If It1 and It2 are both dereferenceable, then It1 == It2 if and only\n    //    if *It1 and *It2 are bound to the same objects.\n    // An alternative design approach was discussed during review;\n    // store an Association object inside the iterator, and return a reference\n    // to it when dereferenced. This idea was discarded beacuse of nasty\n    // lifetime issues:\n    //    AssociationIterator It = ...;\n    //    const Association &Assoc = *It++; // Oops, Assoc is dangling.\n    using BaseTy = typename AssociationIteratorTy::iterator_facade_base;\n    using StmtPtrPtrTy =\n        std::conditional_t<Const, const Stmt *const *, Stmt **>;\n    using TSIPtrPtrTy = std::conditional_t<Const, const TypeSourceInfo *const *,\n                                           TypeSourceInfo **>;\n    StmtPtrPtrTy E; // = nullptr; FIXME: Once support for gcc 4.8 is dropped.\n    TSIPtrPtrTy TSI; // Kept in sync with E.\n    unsigned Offset = 0, SelectedOffset = 0;\n    AssociationIteratorTy(StmtPtrPtrTy E, TSIPtrPtrTy TSI, unsigned Offset,\n                          unsigned SelectedOffset)\n        : E(E), TSI(TSI), Offset(Offset), SelectedOffset(SelectedOffset) {}\n\n  public:\n    AssociationIteratorTy() : E(nullptr), TSI(nullptr) {}\n    typename BaseTy::reference operator*() const {\n      return AssociationTy<Const>(cast<Expr>(*E), *TSI,\n                                  Offset == SelectedOffset);\n    }\n    typename BaseTy::pointer operator->() const { return **this; }\n    using BaseTy::operator++;\n    AssociationIteratorTy &operator++() {\n      ++E;\n      ++TSI;\n      ++Offset;\n      return *this;\n    }\n    bool operator==(AssociationIteratorTy Other) const { return E == Other.E; }\n  }; // class AssociationIterator\n\n  /// Build a non-result-dependent generic selection expression.\n  GenericSelectionExpr(const ASTContext &Context, SourceLocation GenericLoc,\n                       Expr *ControllingExpr,\n                       ArrayRef<TypeSourceInfo *> AssocTypes,\n                       ArrayRef<Expr *> AssocExprs, SourceLocation DefaultLoc,\n                       SourceLocation RParenLoc,\n                       bool ContainsUnexpandedParameterPack,\n                       unsigned ResultIndex);\n\n  /// Build a result-dependent generic selection expression.\n  GenericSelectionExpr(const ASTContext &Context, SourceLocation GenericLoc,\n                       Expr *ControllingExpr,\n                       ArrayRef<TypeSourceInfo *> AssocTypes,\n                       ArrayRef<Expr *> AssocExprs, SourceLocation DefaultLoc,\n                       SourceLocation RParenLoc,\n                       bool ContainsUnexpandedParameterPack);\n\n  /// Build an empty generic selection expression for deserialization.\n  explicit GenericSelectionExpr(EmptyShell Empty, unsigned NumAssocs);\n\npublic:\n  /// Create a non-result-dependent generic selection expression.\n  static GenericSelectionExpr *\n  Create(const ASTContext &Context, SourceLocation GenericLoc,\n         Expr *ControllingExpr, ArrayRef<TypeSourceInfo *> AssocTypes,\n         ArrayRef<Expr *> AssocExprs, SourceLocation DefaultLoc,\n         SourceLocation RParenLoc, bool ContainsUnexpandedParameterPack,\n         unsigned ResultIndex);\n\n  /// Create a result-dependent generic selection expression.\n  static GenericSelectionExpr *\n  Create(const ASTContext &Context, SourceLocation GenericLoc,\n         Expr *ControllingExpr, ArrayRef<TypeSourceInfo *> AssocTypes,\n         ArrayRef<Expr *> AssocExprs, SourceLocation DefaultLoc,\n         SourceLocation RParenLoc, bool ContainsUnexpandedParameterPack);\n\n  /// Create an empty generic selection expression for deserialization.\n  static GenericSelectionExpr *CreateEmpty(const ASTContext &Context,\n                                           unsigned NumAssocs);\n\n  using Association = AssociationTy<false>;\n  using ConstAssociation = AssociationTy<true>;\n  using AssociationIterator = AssociationIteratorTy<false>;\n  using ConstAssociationIterator = AssociationIteratorTy<true>;\n  using association_range = llvm::iterator_range<AssociationIterator>;\n  using const_association_range =\n      llvm::iterator_range<ConstAssociationIterator>;\n\n  /// The number of association expressions.\n  unsigned getNumAssocs() const { return NumAssocs; }\n\n  /// The zero-based index of the result expression's generic association in\n  /// the generic selection's association list.  Defined only if the\n  /// generic selection is not result-dependent.\n  unsigned getResultIndex() const {\n    assert(!isResultDependent() &&\n           \"Generic selection is result-dependent but getResultIndex called!\");\n    return ResultIndex;\n  }\n\n  /// Whether this generic selection is result-dependent.\n  bool isResultDependent() const { return ResultIndex == ResultDependentIndex; }\n\n  /// Return the controlling expression of this generic selection expression.\n  Expr *getControllingExpr() {\n    return cast<Expr>(getTrailingObjects<Stmt *>()[ControllingIndex]);\n  }\n  const Expr *getControllingExpr() const {\n    return cast<Expr>(getTrailingObjects<Stmt *>()[ControllingIndex]);\n  }\n\n  /// Return the result expression of this controlling expression. Defined if\n  /// and only if the generic selection expression is not result-dependent.\n  Expr *getResultExpr() {\n    return cast<Expr>(\n        getTrailingObjects<Stmt *>()[AssocExprStartIndex + getResultIndex()]);\n  }\n  const Expr *getResultExpr() const {\n    return cast<Expr>(\n        getTrailingObjects<Stmt *>()[AssocExprStartIndex + getResultIndex()]);\n  }\n\n  ArrayRef<Expr *> getAssocExprs() const {\n    return {reinterpret_cast<Expr *const *>(getTrailingObjects<Stmt *>() +\n                                            AssocExprStartIndex),\n            NumAssocs};\n  }\n  ArrayRef<TypeSourceInfo *> getAssocTypeSourceInfos() const {\n    return {getTrailingObjects<TypeSourceInfo *>(), NumAssocs};\n  }\n\n  /// Return the Ith association expression with its TypeSourceInfo,\n  /// bundled together in GenericSelectionExpr::(Const)Association.\n  Association getAssociation(unsigned I) {\n    assert(I < getNumAssocs() &&\n           \"Out-of-range index in GenericSelectionExpr::getAssociation!\");\n    return Association(\n        cast<Expr>(getTrailingObjects<Stmt *>()[AssocExprStartIndex + I]),\n        getTrailingObjects<TypeSourceInfo *>()[I],\n        !isResultDependent() && (getResultIndex() == I));\n  }\n  ConstAssociation getAssociation(unsigned I) const {\n    assert(I < getNumAssocs() &&\n           \"Out-of-range index in GenericSelectionExpr::getAssociation!\");\n    return ConstAssociation(\n        cast<Expr>(getTrailingObjects<Stmt *>()[AssocExprStartIndex + I]),\n        getTrailingObjects<TypeSourceInfo *>()[I],\n        !isResultDependent() && (getResultIndex() == I));\n  }\n\n  association_range associations() {\n    AssociationIterator Begin(getTrailingObjects<Stmt *>() +\n                                  AssocExprStartIndex,\n                              getTrailingObjects<TypeSourceInfo *>(),\n                              /*Offset=*/0, ResultIndex);\n    AssociationIterator End(Begin.E + NumAssocs, Begin.TSI + NumAssocs,\n                            /*Offset=*/NumAssocs, ResultIndex);\n    return llvm::make_range(Begin, End);\n  }\n\n  const_association_range associations() const {\n    ConstAssociationIterator Begin(getTrailingObjects<Stmt *>() +\n                                       AssocExprStartIndex,\n                                   getTrailingObjects<TypeSourceInfo *>(),\n                                   /*Offset=*/0, ResultIndex);\n    ConstAssociationIterator End(Begin.E + NumAssocs, Begin.TSI + NumAssocs,\n                                 /*Offset=*/NumAssocs, ResultIndex);\n    return llvm::make_range(Begin, End);\n  }\n\n  SourceLocation getGenericLoc() const {\n    return GenericSelectionExprBits.GenericLoc;\n  }\n  SourceLocation getDefaultLoc() const { return DefaultLoc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  SourceLocation getBeginLoc() const { return getGenericLoc(); }\n  SourceLocation getEndLoc() const { return getRParenLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == GenericSelectionExprClass;\n  }\n\n  child_range children() {\n    return child_range(getTrailingObjects<Stmt *>(),\n                       getTrailingObjects<Stmt *>() +\n                           numTrailingObjects(OverloadToken<Stmt *>()));\n  }\n  const_child_range children() const {\n    return const_child_range(getTrailingObjects<Stmt *>(),\n                             getTrailingObjects<Stmt *>() +\n                                 numTrailingObjects(OverloadToken<Stmt *>()));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Clang Extensions\n//===----------------------------------------------------------------------===//\n\n/// ExtVectorElementExpr - This represents access to specific elements of a\n/// vector, and may occur on the left hand side or right hand side.  For example\n/// the following is legal:  \"V.xy = V.zw\" if V is a 4 element extended vector.\n///\n/// Note that the base may have either vector or pointer to vector type, just\n/// like a struct field reference.\n///\nclass ExtVectorElementExpr : public Expr {\n  Stmt *Base;\n  IdentifierInfo *Accessor;\n  SourceLocation AccessorLoc;\npublic:\n  ExtVectorElementExpr(QualType ty, ExprValueKind VK, Expr *base,\n                       IdentifierInfo &accessor, SourceLocation loc)\n      : Expr(ExtVectorElementExprClass, ty, VK,\n             (VK == VK_RValue ? OK_Ordinary : OK_VectorComponent)),\n        Base(base), Accessor(&accessor), AccessorLoc(loc) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Build an empty vector element expression.\n  explicit ExtVectorElementExpr(EmptyShell Empty)\n    : Expr(ExtVectorElementExprClass, Empty) { }\n\n  const Expr *getBase() const { return cast<Expr>(Base); }\n  Expr *getBase() { return cast<Expr>(Base); }\n  void setBase(Expr *E) { Base = E; }\n\n  IdentifierInfo &getAccessor() const { return *Accessor; }\n  void setAccessor(IdentifierInfo *II) { Accessor = II; }\n\n  SourceLocation getAccessorLoc() const { return AccessorLoc; }\n  void setAccessorLoc(SourceLocation L) { AccessorLoc = L; }\n\n  /// getNumElements - Get the number of components being selected.\n  unsigned getNumElements() const;\n\n  /// containsDuplicateElements - Return true if any element access is\n  /// repeated.\n  bool containsDuplicateElements() const;\n\n  /// getEncodedElementAccess - Encode the elements accessed into an llvm\n  /// aggregate Constant of ConstantInt(s).\n  void getEncodedElementAccess(SmallVectorImpl<uint32_t> &Elts) const;\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getBase()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY { return AccessorLoc; }\n\n  /// isArrow - Return true if the base expression is a pointer to vector,\n  /// return false if the base expression is a vector.\n  bool isArrow() const;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ExtVectorElementExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Base, &Base+1); }\n  const_child_range children() const {\n    return const_child_range(&Base, &Base + 1);\n  }\n};\n\n/// BlockExpr - Adaptor class for mixing a BlockDecl with expressions.\n/// ^{ statement-body }   or   ^(int arg1, float arg2){ statement-body }\nclass BlockExpr : public Expr {\nprotected:\n  BlockDecl *TheBlock;\npublic:\n  BlockExpr(BlockDecl *BD, QualType ty)\n      : Expr(BlockExprClass, ty, VK_RValue, OK_Ordinary), TheBlock(BD) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Build an empty block expression.\n  explicit BlockExpr(EmptyShell Empty) : Expr(BlockExprClass, Empty) { }\n\n  const BlockDecl *getBlockDecl() const { return TheBlock; }\n  BlockDecl *getBlockDecl() { return TheBlock; }\n  void setBlockDecl(BlockDecl *BD) { TheBlock = BD; }\n\n  // Convenience functions for probing the underlying BlockDecl.\n  SourceLocation getCaretLocation() const;\n  const Stmt *getBody() const;\n  Stmt *getBody();\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getCaretLocation();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getBody()->getEndLoc();\n  }\n\n  /// getFunctionType - Return the underlying function type for this block.\n  const FunctionProtoType *getFunctionType() const;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == BlockExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Copy initialization expr of a __block variable and a boolean flag that\n/// indicates whether the expression can throw.\nstruct BlockVarCopyInit {\n  BlockVarCopyInit() = default;\n  BlockVarCopyInit(Expr *CopyExpr, bool CanThrow)\n      : ExprAndFlag(CopyExpr, CanThrow) {}\n  void setExprAndFlag(Expr *CopyExpr, bool CanThrow) {\n    ExprAndFlag.setPointerAndInt(CopyExpr, CanThrow);\n  }\n  Expr *getCopyExpr() const { return ExprAndFlag.getPointer(); }\n  bool canThrow() const { return ExprAndFlag.getInt(); }\n  llvm::PointerIntPair<Expr *, 1, bool> ExprAndFlag;\n};\n\n/// AsTypeExpr - Clang builtin function __builtin_astype [OpenCL 6.2.4.2]\n/// This AST node provides support for reinterpreting a type to another\n/// type of the same size.\nclass AsTypeExpr : public Expr {\nprivate:\n  Stmt *SrcExpr;\n  SourceLocation BuiltinLoc, RParenLoc;\n\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  explicit AsTypeExpr(EmptyShell Empty) : Expr(AsTypeExprClass, Empty) {}\n\npublic:\n  AsTypeExpr(Expr *SrcExpr, QualType DstType, ExprValueKind VK,\n             ExprObjectKind OK, SourceLocation BuiltinLoc,\n             SourceLocation RParenLoc)\n      : Expr(AsTypeExprClass, DstType, VK, OK), SrcExpr(SrcExpr),\n        BuiltinLoc(BuiltinLoc), RParenLoc(RParenLoc) {\n    setDependence(computeDependence(this));\n  }\n\n  /// getSrcExpr - Return the Expr to be converted.\n  Expr *getSrcExpr() const { return cast<Expr>(SrcExpr); }\n\n  /// getBuiltinLoc - Return the location of the __builtin_astype token.\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n\n  /// getRParenLoc - Return the location of final right parenthesis.\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == AsTypeExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&SrcExpr, &SrcExpr+1); }\n  const_child_range children() const {\n    return const_child_range(&SrcExpr, &SrcExpr + 1);\n  }\n};\n\n/// PseudoObjectExpr - An expression which accesses a pseudo-object\n/// l-value.  A pseudo-object is an abstract object, accesses to which\n/// are translated to calls.  The pseudo-object expression has a\n/// syntactic form, which shows how the expression was actually\n/// written in the source code, and a semantic form, which is a series\n/// of expressions to be executed in order which detail how the\n/// operation is actually evaluated.  Optionally, one of the semantic\n/// forms may also provide a result value for the expression.\n///\n/// If any of the semantic-form expressions is an OpaqueValueExpr,\n/// that OVE is required to have a source expression, and it is bound\n/// to the result of that source expression.  Such OVEs may appear\n/// only in subsequent semantic-form expressions and as\n/// sub-expressions of the syntactic form.\n///\n/// PseudoObjectExpr should be used only when an operation can be\n/// usefully described in terms of fairly simple rewrite rules on\n/// objects and functions that are meant to be used by end-developers.\n/// For example, under the Itanium ABI, dynamic casts are implemented\n/// as a call to a runtime function called __dynamic_cast; using this\n/// class to describe that would be inappropriate because that call is\n/// not really part of the user-visible semantics, and instead the\n/// cast is properly reflected in the AST and IR-generation has been\n/// taught to generate the call as necessary.  In contrast, an\n/// Objective-C property access is semantically defined to be\n/// equivalent to a particular message send, and this is very much\n/// part of the user model.  The name of this class encourages this\n/// modelling design.\nclass PseudoObjectExpr final\n    : public Expr,\n      private llvm::TrailingObjects<PseudoObjectExpr, Expr *> {\n  // PseudoObjectExprBits.NumSubExprs - The number of sub-expressions.\n  // Always at least two, because the first sub-expression is the\n  // syntactic form.\n\n  // PseudoObjectExprBits.ResultIndex - The index of the\n  // sub-expression holding the result.  0 means the result is void,\n  // which is unambiguous because it's the index of the syntactic\n  // form.  Note that this is therefore 1 higher than the value passed\n  // in to Create, which is an index within the semantic forms.\n  // Note also that ASTStmtWriter assumes this encoding.\n\n  Expr **getSubExprsBuffer() { return getTrailingObjects<Expr *>(); }\n  const Expr * const *getSubExprsBuffer() const {\n    return getTrailingObjects<Expr *>();\n  }\n\n  PseudoObjectExpr(QualType type, ExprValueKind VK,\n                   Expr *syntactic, ArrayRef<Expr*> semantic,\n                   unsigned resultIndex);\n\n  PseudoObjectExpr(EmptyShell shell, unsigned numSemanticExprs);\n\n  unsigned getNumSubExprs() const {\n    return PseudoObjectExprBits.NumSubExprs;\n  }\n\npublic:\n  /// NoResult - A value for the result index indicating that there is\n  /// no semantic result.\n  enum : unsigned { NoResult = ~0U };\n\n  static PseudoObjectExpr *Create(const ASTContext &Context, Expr *syntactic,\n                                  ArrayRef<Expr*> semantic,\n                                  unsigned resultIndex);\n\n  static PseudoObjectExpr *Create(const ASTContext &Context, EmptyShell shell,\n                                  unsigned numSemanticExprs);\n\n  /// Return the syntactic form of this expression, i.e. the\n  /// expression it actually looks like.  Likely to be expressed in\n  /// terms of OpaqueValueExprs bound in the semantic form.\n  Expr *getSyntacticForm() { return getSubExprsBuffer()[0]; }\n  const Expr *getSyntacticForm() const { return getSubExprsBuffer()[0]; }\n\n  /// Return the index of the result-bearing expression into the semantics\n  /// expressions, or PseudoObjectExpr::NoResult if there is none.\n  unsigned getResultExprIndex() const {\n    if (PseudoObjectExprBits.ResultIndex == 0) return NoResult;\n    return PseudoObjectExprBits.ResultIndex - 1;\n  }\n\n  /// Return the result-bearing expression, or null if there is none.\n  Expr *getResultExpr() {\n    if (PseudoObjectExprBits.ResultIndex == 0)\n      return nullptr;\n    return getSubExprsBuffer()[PseudoObjectExprBits.ResultIndex];\n  }\n  const Expr *getResultExpr() const {\n    return const_cast<PseudoObjectExpr*>(this)->getResultExpr();\n  }\n\n  unsigned getNumSemanticExprs() const { return getNumSubExprs() - 1; }\n\n  typedef Expr * const *semantics_iterator;\n  typedef const Expr * const *const_semantics_iterator;\n  semantics_iterator semantics_begin() {\n    return getSubExprsBuffer() + 1;\n  }\n  const_semantics_iterator semantics_begin() const {\n    return getSubExprsBuffer() + 1;\n  }\n  semantics_iterator semantics_end() {\n    return getSubExprsBuffer() + getNumSubExprs();\n  }\n  const_semantics_iterator semantics_end() const {\n    return getSubExprsBuffer() + getNumSubExprs();\n  }\n\n  llvm::iterator_range<semantics_iterator> semantics() {\n    return llvm::make_range(semantics_begin(), semantics_end());\n  }\n  llvm::iterator_range<const_semantics_iterator> semantics() const {\n    return llvm::make_range(semantics_begin(), semantics_end());\n  }\n\n  Expr *getSemanticExpr(unsigned index) {\n    assert(index + 1 < getNumSubExprs());\n    return getSubExprsBuffer()[index + 1];\n  }\n  const Expr *getSemanticExpr(unsigned index) const {\n    return const_cast<PseudoObjectExpr*>(this)->getSemanticExpr(index);\n  }\n\n  SourceLocation getExprLoc() const LLVM_READONLY {\n    return getSyntacticForm()->getExprLoc();\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getSyntacticForm()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getSyntacticForm()->getEndLoc();\n  }\n\n  child_range children() {\n    const_child_range CCR =\n        const_cast<const PseudoObjectExpr *>(this)->children();\n    return child_range(cast_away_const(CCR.begin()),\n                       cast_away_const(CCR.end()));\n  }\n  const_child_range children() const {\n    Stmt *const *cs = const_cast<Stmt *const *>(\n        reinterpret_cast<const Stmt *const *>(getSubExprsBuffer()));\n    return const_child_range(cs, cs + getNumSubExprs());\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == PseudoObjectExprClass;\n  }\n\n  friend TrailingObjects;\n  friend class ASTStmtReader;\n};\n\n/// AtomicExpr - Variadic atomic builtins: __atomic_exchange, __atomic_fetch_*,\n/// __atomic_load, __atomic_store, and __atomic_compare_exchange_*, for the\n/// similarly-named C++11 instructions, and __c11 variants for <stdatomic.h>,\n/// and corresponding __opencl_atomic_* for OpenCL 2.0.\n/// All of these instructions take one primary pointer, at least one memory\n/// order. The instructions for which getScopeModel returns non-null value\n/// take one synch scope.\nclass AtomicExpr : public Expr {\npublic:\n  enum AtomicOp {\n#define BUILTIN(ID, TYPE, ATTRS)\n#define ATOMIC_BUILTIN(ID, TYPE, ATTRS) AO ## ID,\n#include \"clang/Basic/Builtins.def\"\n    // Avoid trailing comma\n    BI_First = 0\n  };\n\nprivate:\n  /// Location of sub-expressions.\n  /// The location of Scope sub-expression is NumSubExprs - 1, which is\n  /// not fixed, therefore is not defined in enum.\n  enum { PTR, ORDER, VAL1, ORDER_FAIL, VAL2, WEAK, END_EXPR };\n  Stmt *SubExprs[END_EXPR + 1];\n  unsigned NumSubExprs;\n  SourceLocation BuiltinLoc, RParenLoc;\n  AtomicOp Op;\n\n  friend class ASTStmtReader;\npublic:\n  AtomicExpr(SourceLocation BLoc, ArrayRef<Expr*> args, QualType t,\n             AtomicOp op, SourceLocation RP);\n\n  /// Determine the number of arguments the specified atomic builtin\n  /// should have.\n  static unsigned getNumSubExprs(AtomicOp Op);\n\n  /// Build an empty AtomicExpr.\n  explicit AtomicExpr(EmptyShell Empty) : Expr(AtomicExprClass, Empty) { }\n\n  Expr *getPtr() const {\n    return cast<Expr>(SubExprs[PTR]);\n  }\n  Expr *getOrder() const {\n    return cast<Expr>(SubExprs[ORDER]);\n  }\n  Expr *getScope() const {\n    assert(getScopeModel() && \"No scope\");\n    return cast<Expr>(SubExprs[NumSubExprs - 1]);\n  }\n  Expr *getVal1() const {\n    if (Op == AO__c11_atomic_init || Op == AO__opencl_atomic_init)\n      return cast<Expr>(SubExprs[ORDER]);\n    assert(NumSubExprs > VAL1);\n    return cast<Expr>(SubExprs[VAL1]);\n  }\n  Expr *getOrderFail() const {\n    assert(NumSubExprs > ORDER_FAIL);\n    return cast<Expr>(SubExprs[ORDER_FAIL]);\n  }\n  Expr *getVal2() const {\n    if (Op == AO__atomic_exchange)\n      return cast<Expr>(SubExprs[ORDER_FAIL]);\n    assert(NumSubExprs > VAL2);\n    return cast<Expr>(SubExprs[VAL2]);\n  }\n  Expr *getWeak() const {\n    assert(NumSubExprs > WEAK);\n    return cast<Expr>(SubExprs[WEAK]);\n  }\n  QualType getValueType() const;\n\n  AtomicOp getOp() const { return Op; }\n  unsigned getNumSubExprs() const { return NumSubExprs; }\n\n  Expr **getSubExprs() { return reinterpret_cast<Expr **>(SubExprs); }\n  const Expr * const *getSubExprs() const {\n    return reinterpret_cast<Expr * const *>(SubExprs);\n  }\n\n  bool isVolatile() const {\n    return getPtr()->getType()->getPointeeType().isVolatileQualified();\n  }\n\n  bool isCmpXChg() const {\n    return getOp() == AO__c11_atomic_compare_exchange_strong ||\n           getOp() == AO__c11_atomic_compare_exchange_weak ||\n           getOp() == AO__opencl_atomic_compare_exchange_strong ||\n           getOp() == AO__opencl_atomic_compare_exchange_weak ||\n           getOp() == AO__atomic_compare_exchange ||\n           getOp() == AO__atomic_compare_exchange_n;\n  }\n\n  bool isOpenCL() const {\n    return getOp() >= AO__opencl_atomic_init &&\n           getOp() <= AO__opencl_atomic_fetch_max;\n  }\n\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == AtomicExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(SubExprs, SubExprs+NumSubExprs);\n  }\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + NumSubExprs);\n  }\n\n  /// Get atomic scope model for the atomic op code.\n  /// \\return empty atomic scope model if the atomic op code does not have\n  ///   scope operand.\n  static std::unique_ptr<AtomicScopeModel> getScopeModel(AtomicOp Op) {\n    auto Kind =\n        (Op >= AO__opencl_atomic_load && Op <= AO__opencl_atomic_fetch_max)\n            ? AtomicScopeModelKind::OpenCL\n            : AtomicScopeModelKind::None;\n    return AtomicScopeModel::create(Kind);\n  }\n\n  /// Get atomic scope model.\n  /// \\return empty atomic scope model if this atomic expression does not have\n  ///   scope operand.\n  std::unique_ptr<AtomicScopeModel> getScopeModel() const {\n    return getScopeModel(getOp());\n  }\n};\n\n/// TypoExpr - Internal placeholder for expressions where typo correction\n/// still needs to be performed and/or an error diagnostic emitted.\nclass TypoExpr : public Expr {\n  // The location for the typo name.\n  SourceLocation TypoLoc;\n\npublic:\n  TypoExpr(QualType T, SourceLocation TypoLoc)\n      : Expr(TypoExprClass, T, VK_LValue, OK_Ordinary), TypoLoc(TypoLoc) {\n    assert(T->isDependentType() && \"TypoExpr given a non-dependent type\");\n    setDependence(ExprDependence::TypeValueInstantiation |\n                  ExprDependence::Error);\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return TypoLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return TypoLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == TypoExprClass;\n  }\n\n};\n\n/// Frontend produces RecoveryExprs on semantic errors that prevent creating\n/// other well-formed expressions. E.g. when type-checking of a binary operator\n/// fails, we cannot produce a BinaryOperator expression. Instead, we can choose\n/// to produce a recovery expression storing left and right operands.\n///\n/// RecoveryExpr does not have any semantic meaning in C++, it is only useful to\n/// preserve expressions in AST that would otherwise be dropped. It captures\n/// subexpressions of some expression that we could not construct and source\n/// range covered by the expression.\n///\n/// By default, RecoveryExpr uses dependence-bits to take advantage of existing\n/// machinery to deal with dependent code in C++, e.g. RecoveryExpr is preserved\n/// in `decltype(<broken-expr>)` as part of the `DependentDecltypeType`. In\n/// addition to that, clang does not report most errors on dependent\n/// expressions, so we get rid of bogus errors for free. However, note that\n/// unlike other dependent expressions, RecoveryExpr can be produced in\n/// non-template contexts.\n///\n/// We will preserve the type in RecoveryExpr when the type is known, e.g.\n/// preserving the return type for a broken non-overloaded function call, a\n/// overloaded call where all candidates have the same return type. In this\n/// case, the expression is not type-dependent (unless the known type is itself\n/// dependent)\n///\n/// One can also reliably suppress all bogus errors on expressions containing\n/// recovery expressions by examining results of Expr::containsErrors().\nclass RecoveryExpr final : public Expr,\n                           private llvm::TrailingObjects<RecoveryExpr, Expr *> {\npublic:\n  static RecoveryExpr *Create(ASTContext &Ctx, QualType T,\n                              SourceLocation BeginLoc, SourceLocation EndLoc,\n                              ArrayRef<Expr *> SubExprs);\n  static RecoveryExpr *CreateEmpty(ASTContext &Ctx, unsigned NumSubExprs);\n\n  ArrayRef<Expr *> subExpressions() {\n    auto *B = getTrailingObjects<Expr *>();\n    return llvm::makeArrayRef(B, B + NumExprs);\n  }\n\n  ArrayRef<const Expr *> subExpressions() const {\n    return const_cast<RecoveryExpr *>(this)->subExpressions();\n  }\n\n  child_range children() {\n    Stmt **B = reinterpret_cast<Stmt **>(getTrailingObjects<Expr *>());\n    return child_range(B, B + NumExprs);\n  }\n\n  SourceLocation getBeginLoc() const { return BeginLoc; }\n  SourceLocation getEndLoc() const { return EndLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == RecoveryExprClass;\n  }\n\nprivate:\n  RecoveryExpr(ASTContext &Ctx, QualType T, SourceLocation BeginLoc,\n               SourceLocation EndLoc, ArrayRef<Expr *> SubExprs);\n  RecoveryExpr(EmptyShell Empty, unsigned NumSubExprs)\n      : Expr(RecoveryExprClass, Empty), NumExprs(NumSubExprs) {}\n\n  size_t numTrailingObjects(OverloadToken<Stmt *>) const { return NumExprs; }\n\n  SourceLocation BeginLoc, EndLoc;\n  unsigned NumExprs;\n  friend TrailingObjects;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n};\n\n} // end namespace clang\n\n#endif // LLVM_CLANG_AST_EXPR_H\n"}, "48": {"id": 48, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/PathDiagnostic.h", "content": "//===- PathDiagnostic.h - Path-Specific Diagnostic Handling -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the PathDiagnostic-related interfaces.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_BUGREPORTER_PATHDIAGNOSTIC_H\n#define LLVM_CLANG_STATICANALYZER_CORE_BUGREPORTER_PATHDIAGNOSTIC_H\n\n#include \"clang/AST/Stmt.h\"\n#include \"clang/Analysis/AnalysisDeclContext.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <cassert>\n#include <deque>\n#include <iterator>\n#include <list>\n#include <map>\n#include <memory>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace clang {\n\nclass AnalysisDeclContext;\nclass BinaryOperator;\nclass CallEnter;\nclass CallExitEnd;\nclass CallExpr;\nclass ConditionalOperator;\nclass Decl;\nclass Expr;\nclass LocationContext;\nclass MemberExpr;\nclass ProgramPoint;\nclass SourceManager;\n\nnamespace ento {\n\n//===----------------------------------------------------------------------===//\n// High-level interface for handlers of path-sensitive diagnostics.\n//===----------------------------------------------------------------------===//\n\nclass PathDiagnostic;\n\n/// These options tweak the behavior of path diangostic consumers.\n/// Most of these options are currently supported by very few consumers.\nstruct PathDiagnosticConsumerOptions {\n  /// Run-line of the tool that produced the diagnostic.\n  /// It can be included with the diagnostic for debugging purposes.\n  std::string ToolInvocation;\n\n  /// Whether to include additional information about macro expansions\n  /// with the diagnostics, because otherwise they can be hard to obtain\n  /// without re-compiling the program under analysis.\n  bool ShouldDisplayMacroExpansions = false;\n\n  /// Whether to include LLVM statistics of the process in the diagnostic.\n  /// Useful for profiling the tool on large real-world codebases.\n  bool ShouldSerializeStats = false;\n\n  /// If the consumer intends to produce multiple output files, should it\n  /// use randomly generated file names for these files (with the tiny risk of\n  /// having random collisions) or deterministic human-readable file names\n  /// (with a larger risk of deterministic collisions or invalid characters\n  /// in the file name). We should not really give this choice to the users\n  /// because deterministic mode is always superior when done right, but\n  /// for some consumers this mode is experimental and needs to be\n  /// off by default.\n  bool ShouldWriteStableReportFilename = false;\n\n  /// Whether the consumer should treat consumed diagnostics as hard errors.\n  /// Useful for breaking your build when issues are found.\n  bool ShouldDisplayWarningsAsErrors = false;\n\n  /// Whether the consumer should attempt to rewrite the source file\n  /// with fix-it hints attached to the diagnostics it consumes.\n  bool ShouldApplyFixIts = false;\n\n  /// Whether the consumer should present the name of the entity that emitted\n  /// the diagnostic (eg., a checker) so that the user knew how to disable it.\n  bool ShouldDisplayDiagnosticName = false;\n};\n\nclass PathDiagnosticConsumer {\npublic:\n  class PDFileEntry : public llvm::FoldingSetNode {\n  public:\n    PDFileEntry(llvm::FoldingSetNodeID &NodeID) : NodeID(NodeID) {}\n\n    using ConsumerFiles = std::vector<std::pair<StringRef, StringRef>>;\n\n    /// A vector of <consumer,file> pairs.\n    ConsumerFiles files;\n\n    /// A precomputed hash tag used for uniquing PDFileEntry objects.\n    const llvm::FoldingSetNodeID NodeID;\n\n    /// Used for profiling in the FoldingSet.\n    void Profile(llvm::FoldingSetNodeID &ID) { ID = NodeID; }\n  };\n\n  class FilesMade {\n    llvm::BumpPtrAllocator Alloc;\n    llvm::FoldingSet<PDFileEntry> Set;\n\n  public:\n    ~FilesMade();\n\n    bool empty() const { return Set.empty(); }\n\n    void addDiagnostic(const PathDiagnostic &PD,\n                       StringRef ConsumerName,\n                       StringRef fileName);\n\n    PDFileEntry::ConsumerFiles *getFiles(const PathDiagnostic &PD);\n  };\n\nprivate:\n  virtual void anchor();\n\npublic:\n  PathDiagnosticConsumer() = default;\n  virtual ~PathDiagnosticConsumer();\n\n  void FlushDiagnostics(FilesMade *FilesMade);\n\n  virtual void FlushDiagnosticsImpl(std::vector<const PathDiagnostic *> &Diags,\n                                    FilesMade *filesMade) = 0;\n\n  virtual StringRef getName() const = 0;\n\n  void HandlePathDiagnostic(std::unique_ptr<PathDiagnostic> D);\n\n  enum PathGenerationScheme {\n    /// Only runs visitors, no output generated.\n    None,\n\n    /// Used for HTML, SARIF, and text output.\n    Minimal,\n\n    /// Used for plist output, used for \"arrows\" generation.\n    Extensive,\n  };\n\n  virtual PathGenerationScheme getGenerationScheme() const { return Minimal; }\n\n  bool shouldGenerateDiagnostics() const {\n    return getGenerationScheme() != None;\n  }\n\n  bool shouldAddPathEdges() const { return getGenerationScheme() == Extensive; }\n\n  virtual bool supportsLogicalOpControlFlow() const { return false; }\n\n  /// Return true if the PathDiagnosticConsumer supports individual\n  /// PathDiagnostics that span multiple files.\n  virtual bool supportsCrossFileDiagnostics() const { return false; }\n\nprotected:\n  bool flushed = false;\n  llvm::FoldingSet<PathDiagnostic> Diags;\n};\n\n//===----------------------------------------------------------------------===//\n// Path-sensitive diagnostics.\n//===----------------------------------------------------------------------===//\n\nclass PathDiagnosticRange : public SourceRange {\npublic:\n  bool isPoint = false;\n\n  PathDiagnosticRange(SourceRange R, bool isP = false)\n      : SourceRange(R), isPoint(isP) {}\n  PathDiagnosticRange() = default;\n};\n\nusing LocationOrAnalysisDeclContext =\n    llvm::PointerUnion<const LocationContext *, AnalysisDeclContext *>;\n\nclass PathDiagnosticLocation {\nprivate:\n  enum Kind { RangeK, SingleLocK, StmtK, DeclK } K = SingleLocK;\n\n  const Stmt *S = nullptr;\n  const Decl *D = nullptr;\n  const SourceManager *SM = nullptr;\n  FullSourceLoc Loc;\n  PathDiagnosticRange Range;\n\n  PathDiagnosticLocation(SourceLocation L, const SourceManager &sm, Kind kind)\n      : K(kind), SM(&sm), Loc(genLocation(L)), Range(genRange()) {}\n\n  FullSourceLoc genLocation(\n      SourceLocation L = SourceLocation(),\n      LocationOrAnalysisDeclContext LAC = (AnalysisDeclContext *)nullptr) const;\n\n  PathDiagnosticRange genRange(\n      LocationOrAnalysisDeclContext LAC = (AnalysisDeclContext *)nullptr) const;\n\npublic:\n  /// Create an invalid location.\n  PathDiagnosticLocation() = default;\n\n  /// Create a location corresponding to the given statement.\n  PathDiagnosticLocation(const Stmt *s, const SourceManager &sm,\n                         LocationOrAnalysisDeclContext lac)\n      : K(s->getBeginLoc().isValid() ? StmtK : SingleLocK),\n        S(K == StmtK ? s : nullptr), SM(&sm),\n        Loc(genLocation(SourceLocation(), lac)), Range(genRange(lac)) {\n    assert(K == SingleLocK || S);\n    assert(K == SingleLocK || Loc.isValid());\n    assert(K == SingleLocK || Range.isValid());\n  }\n\n  /// Create a location corresponding to the given declaration.\n  PathDiagnosticLocation(const Decl *d, const SourceManager &sm)\n      : K(DeclK), D(d), SM(&sm), Loc(genLocation()), Range(genRange()) {\n    assert(D);\n    assert(Loc.isValid());\n    assert(Range.isValid());\n  }\n\n  /// Create a location at an explicit offset in the source.\n  ///\n  /// This should only be used if there are no more appropriate constructors.\n  PathDiagnosticLocation(SourceLocation loc, const SourceManager &sm)\n      : SM(&sm), Loc(loc, sm), Range(genRange()) {\n    assert(Loc.isValid());\n    assert(Range.isValid());\n  }\n\n  /// Create a location corresponding to the given declaration.\n  static PathDiagnosticLocation create(const Decl *D,\n                                       const SourceManager &SM) {\n    return PathDiagnosticLocation(D, SM);\n  }\n\n  /// Create a location for the beginning of the declaration.\n  static PathDiagnosticLocation createBegin(const Decl *D,\n                                            const SourceManager &SM);\n\n  /// Create a location for the beginning of the declaration.\n  /// The third argument is ignored, useful for generic treatment\n  /// of statements and declarations.\n  static PathDiagnosticLocation\n  createBegin(const Decl *D, const SourceManager &SM,\n              const LocationOrAnalysisDeclContext LAC) {\n    return createBegin(D, SM);\n  }\n\n  /// Create a location for the beginning of the statement.\n  static PathDiagnosticLocation createBegin(const Stmt *S,\n                                            const SourceManager &SM,\n                                            const LocationOrAnalysisDeclContext LAC);\n\n  /// Create a location for the end of the statement.\n  ///\n  /// If the statement is a CompoundStatement, the location will point to the\n  /// closing brace instead of following it.\n  static PathDiagnosticLocation createEnd(const Stmt *S,\n                                          const SourceManager &SM,\n                                       const LocationOrAnalysisDeclContext LAC);\n\n  /// Create the location for the operator of the binary expression.\n  /// Assumes the statement has a valid location.\n  static PathDiagnosticLocation createOperatorLoc(const BinaryOperator *BO,\n                                                  const SourceManager &SM);\n  static PathDiagnosticLocation createConditionalColonLoc(\n                                                  const ConditionalOperator *CO,\n                                                  const SourceManager &SM);\n\n  /// For member expressions, return the location of the '.' or '->'.\n  /// Assumes the statement has a valid location.\n  static PathDiagnosticLocation createMemberLoc(const MemberExpr *ME,\n                                                const SourceManager &SM);\n\n  /// Create a location for the beginning of the compound statement.\n  /// Assumes the statement has a valid location.\n  static PathDiagnosticLocation createBeginBrace(const CompoundStmt *CS,\n                                                 const SourceManager &SM);\n\n  /// Create a location for the end of the compound statement.\n  /// Assumes the statement has a valid location.\n  static PathDiagnosticLocation createEndBrace(const CompoundStmt *CS,\n                                               const SourceManager &SM);\n\n  /// Create a location for the beginning of the enclosing declaration body.\n  /// Defaults to the beginning of the first statement in the declaration body.\n  static PathDiagnosticLocation createDeclBegin(const LocationContext *LC,\n                                                const SourceManager &SM);\n\n  /// Constructs a location for the end of the enclosing declaration body.\n  /// Defaults to the end of brace.\n  static PathDiagnosticLocation createDeclEnd(const LocationContext *LC,\n                                                   const SourceManager &SM);\n\n  /// Create a location corresponding to the given valid ProgramPoint.\n  static PathDiagnosticLocation create(const ProgramPoint &P,\n                                       const SourceManager &SMng);\n\n  /// Convert the given location into a single kind location.\n  static PathDiagnosticLocation createSingleLocation(\n                                             const PathDiagnosticLocation &PDL);\n\n  /// Construct a source location that corresponds to either the beginning\n  /// or the end of the given statement, or a nearby valid source location\n  /// if the statement does not have a valid source location of its own.\n  static SourceLocation\n  getValidSourceLocation(const Stmt *S, LocationOrAnalysisDeclContext LAC,\n                         bool UseEndOfStatement = false);\n\n  bool operator==(const PathDiagnosticLocation &X) const {\n    return K == X.K && Loc == X.Loc && Range == X.Range;\n  }\n\n  bool operator!=(const PathDiagnosticLocation &X) const {\n    return !(*this == X);\n  }\n\n  bool isValid() const {\n    return SM != nullptr;\n  }\n\n  FullSourceLoc asLocation() const {\n    return Loc;\n  }\n\n  PathDiagnosticRange asRange() const {\n    return Range;\n  }\n\n  const Stmt *asStmt() const { assert(isValid()); return S; }\n  const Stmt *getStmtOrNull() const {\n    if (!isValid())\n      return nullptr;\n    return asStmt();\n  }\n\n  const Decl *asDecl() const { assert(isValid()); return D; }\n\n  bool hasRange() const { return K == StmtK || K == RangeK || K == DeclK; }\n\n  bool hasValidLocation() const { return asLocation().isValid(); }\n\n  void invalidate() {\n    *this = PathDiagnosticLocation();\n  }\n\n  void flatten();\n\n  const SourceManager& getManager() const { assert(isValid()); return *SM; }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const;\n\n  void dump() const;\n};\n\nclass PathDiagnosticLocationPair {\nprivate:\n  PathDiagnosticLocation Start, End;\n\npublic:\n  PathDiagnosticLocationPair(const PathDiagnosticLocation &start,\n                             const PathDiagnosticLocation &end)\n      : Start(start), End(end) {}\n\n  const PathDiagnosticLocation &getStart() const { return Start; }\n  const PathDiagnosticLocation &getEnd() const { return End; }\n\n  void setStart(const PathDiagnosticLocation &L) { Start = L; }\n  void setEnd(const PathDiagnosticLocation &L) { End = L; }\n\n  void flatten() {\n    Start.flatten();\n    End.flatten();\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    Start.Profile(ID);\n    End.Profile(ID);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Path \"pieces\" for path-sensitive diagnostics.\n//===----------------------------------------------------------------------===//\n\nclass PathDiagnosticPiece: public llvm::FoldingSetNode {\npublic:\n  enum Kind { ControlFlow, Event, Macro, Call, Note, PopUp };\n  enum DisplayHint { Above, Below };\n\nprivate:\n  const std::string str;\n  const Kind kind;\n  const DisplayHint Hint;\n\n  /// In the containing bug report, this piece is the last piece from\n  /// the main source file.\n  bool LastInMainSourceFile = false;\n\n  /// A constant string that can be used to tag the PathDiagnosticPiece,\n  /// typically with the identification of the creator.  The actual pointer\n  /// value is meant to be an identifier; the string itself is useful for\n  /// debugging.\n  StringRef Tag;\n\n  std::vector<SourceRange> ranges;\n  std::vector<FixItHint> fixits;\n\nprotected:\n  PathDiagnosticPiece(StringRef s, Kind k, DisplayHint hint = Below);\n  PathDiagnosticPiece(Kind k, DisplayHint hint = Below);\n\npublic:\n  PathDiagnosticPiece() = delete;\n  PathDiagnosticPiece(const PathDiagnosticPiece &) = delete;\n  PathDiagnosticPiece &operator=(const PathDiagnosticPiece &) = delete;\n  virtual ~PathDiagnosticPiece();\n\n  StringRef getString() const { return str; }\n\n  /// Tag this PathDiagnosticPiece with the given C-string.\n  void setTag(const char *tag) { Tag = tag; }\n\n  /// Return the opaque tag (if any) on the PathDiagnosticPiece.\n  const void *getTag() const { return Tag.data(); }\n\n  /// Return the string representation of the tag.  This is useful\n  /// for debugging.\n  StringRef getTagStr() const { return Tag; }\n\n  /// getDisplayHint - Return a hint indicating where the diagnostic should\n  ///  be displayed by the PathDiagnosticConsumer.\n  DisplayHint getDisplayHint() const { return Hint; }\n\n  virtual PathDiagnosticLocation getLocation() const = 0;\n  virtual void flattenLocations() = 0;\n\n  Kind getKind() const { return kind; }\n\n  void addRange(SourceRange R) {\n    if (!R.isValid())\n      return;\n    ranges.push_back(R);\n  }\n\n  void addRange(SourceLocation B, SourceLocation E) {\n    if (!B.isValid() || !E.isValid())\n      return;\n    ranges.push_back(SourceRange(B,E));\n  }\n\n  void addFixit(FixItHint F) {\n    fixits.push_back(F);\n  }\n\n  /// Return the SourceRanges associated with this PathDiagnosticPiece.\n  ArrayRef<SourceRange> getRanges() const { return ranges; }\n\n  /// Return the fix-it hints associated with this PathDiagnosticPiece.\n  ArrayRef<FixItHint> getFixits() const { return fixits; }\n\n  virtual void Profile(llvm::FoldingSetNodeID &ID) const;\n\n  void setAsLastInMainSourceFile() {\n    LastInMainSourceFile = true;\n  }\n\n  bool isLastInMainSourceFile() const {\n    return LastInMainSourceFile;\n  }\n\n  virtual void dump() const = 0;\n};\n\nusing PathDiagnosticPieceRef = std::shared_ptr<PathDiagnosticPiece>;\n\nclass PathPieces : public std::list<PathDiagnosticPieceRef> {\n  void flattenTo(PathPieces &Primary, PathPieces &Current,\n                 bool ShouldFlattenMacros) const;\n\npublic:\n  PathPieces flatten(bool ShouldFlattenMacros) const {\n    PathPieces Result;\n    flattenTo(Result, Result, ShouldFlattenMacros);\n    return Result;\n  }\n\n  void dump() const;\n};\n\nclass PathDiagnosticSpotPiece : public PathDiagnosticPiece {\nprivate:\n  PathDiagnosticLocation Pos;\n\npublic:\n  PathDiagnosticSpotPiece(const PathDiagnosticLocation &pos,\n                          StringRef s,\n                          PathDiagnosticPiece::Kind k,\n                          bool addPosRange = true)\n      : PathDiagnosticPiece(s, k), Pos(pos) {\n    assert(Pos.isValid() && Pos.hasValidLocation() &&\n           \"PathDiagnosticSpotPiece's must have a valid location.\");\n    if (addPosRange && Pos.hasRange()) addRange(Pos.asRange());\n  }\n\n  PathDiagnosticLocation getLocation() const override { return Pos; }\n  void flattenLocations() override { Pos.flatten(); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == Event || P->getKind() == Macro ||\n           P->getKind() == Note || P->getKind() == PopUp;\n  }\n};\n\nclass PathDiagnosticEventPiece : public PathDiagnosticSpotPiece {\n  Optional<bool> IsPrunable;\n\npublic:\n  PathDiagnosticEventPiece(const PathDiagnosticLocation &pos,\n                           StringRef s, bool addPosRange = true)\n      : PathDiagnosticSpotPiece(pos, s, Event, addPosRange) {}\n  ~PathDiagnosticEventPiece() override;\n\n  /// Mark the diagnostic piece as being potentially prunable.  This\n  /// flag may have been previously set, at which point it will not\n  /// be reset unless one specifies to do so.\n  void setPrunable(bool isPrunable, bool override = false) {\n    if (IsPrunable.hasValue() && !override)\n     return;\n    IsPrunable = isPrunable;\n  }\n\n  /// Return true if the diagnostic piece is prunable.\n  bool isPrunable() const {\n    return IsPrunable.hasValue() ? IsPrunable.getValue() : false;\n  }\n\n  void dump() const override;\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == Event;\n  }\n};\n\nclass PathDiagnosticCallPiece : public PathDiagnosticPiece {\n  const Decl *Caller;\n  const Decl *Callee = nullptr;\n\n  // Flag signifying that this diagnostic has only call enter and no matching\n  // call exit.\n  bool NoExit;\n\n  // Flag signifying that the callee function is an Objective-C autosynthesized\n  // property getter or setter.\n  bool IsCalleeAnAutosynthesizedPropertyAccessor = false;\n\n  // The custom string, which should appear after the call Return Diagnostic.\n  // TODO: Should we allow multiple diagnostics?\n  std::string CallStackMessage;\n\n  PathDiagnosticCallPiece(const Decl *callerD,\n                          const PathDiagnosticLocation &callReturnPos)\n      : PathDiagnosticPiece(Call), Caller(callerD), NoExit(false),\n        callReturn(callReturnPos) {}\n  PathDiagnosticCallPiece(PathPieces &oldPath, const Decl *caller)\n      : PathDiagnosticPiece(Call), Caller(caller), NoExit(true),\n        path(oldPath) {}\n\npublic:\n  PathDiagnosticLocation callEnter;\n  PathDiagnosticLocation callEnterWithin;\n  PathDiagnosticLocation callReturn;\n  PathPieces path;\n\n  ~PathDiagnosticCallPiece() override;\n\n  const Decl *getCaller() const { return Caller; }\n\n  const Decl *getCallee() const { return Callee; }\n  void setCallee(const CallEnter &CE, const SourceManager &SM);\n\n  bool hasCallStackMessage() { return !CallStackMessage.empty(); }\n  void setCallStackMessage(StringRef st) { CallStackMessage = std::string(st); }\n\n  PathDiagnosticLocation getLocation() const override { return callEnter; }\n\n  std::shared_ptr<PathDiagnosticEventPiece> getCallEnterEvent() const;\n  std::shared_ptr<PathDiagnosticEventPiece>\n  getCallEnterWithinCallerEvent() const;\n  std::shared_ptr<PathDiagnosticEventPiece> getCallExitEvent() const;\n\n  void flattenLocations() override {\n    callEnter.flatten();\n    callReturn.flatten();\n    for (const auto &I : path)\n      I->flattenLocations();\n  }\n\n  static std::shared_ptr<PathDiagnosticCallPiece>\n  construct(const CallExitEnd &CE,\n            const SourceManager &SM);\n\n  static PathDiagnosticCallPiece *construct(PathPieces &pieces,\n                                            const Decl *caller);\n\n  void dump() const override;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == Call;\n  }\n};\n\nclass PathDiagnosticControlFlowPiece : public PathDiagnosticPiece {\n  std::vector<PathDiagnosticLocationPair> LPairs;\n\npublic:\n  PathDiagnosticControlFlowPiece(const PathDiagnosticLocation &startPos,\n                                 const PathDiagnosticLocation &endPos,\n                                 StringRef s)\n      : PathDiagnosticPiece(s, ControlFlow) {\n    LPairs.push_back(PathDiagnosticLocationPair(startPos, endPos));\n  }\n\n  PathDiagnosticControlFlowPiece(const PathDiagnosticLocation &startPos,\n                                 const PathDiagnosticLocation &endPos)\n      : PathDiagnosticPiece(ControlFlow) {\n    LPairs.push_back(PathDiagnosticLocationPair(startPos, endPos));\n  }\n\n  ~PathDiagnosticControlFlowPiece() override;\n\n  PathDiagnosticLocation getStartLocation() const {\n    assert(!LPairs.empty() &&\n           \"PathDiagnosticControlFlowPiece needs at least one location.\");\n    return LPairs[0].getStart();\n  }\n\n  PathDiagnosticLocation getEndLocation() const {\n    assert(!LPairs.empty() &&\n           \"PathDiagnosticControlFlowPiece needs at least one location.\");\n    return LPairs[0].getEnd();\n  }\n\n  void setStartLocation(const PathDiagnosticLocation &L) {\n    LPairs[0].setStart(L);\n  }\n\n  void setEndLocation(const PathDiagnosticLocation &L) {\n    LPairs[0].setEnd(L);\n  }\n\n  void push_back(const PathDiagnosticLocationPair &X) { LPairs.push_back(X); }\n\n  PathDiagnosticLocation getLocation() const override {\n    return getStartLocation();\n  }\n\n  using iterator = std::vector<PathDiagnosticLocationPair>::iterator;\n\n  iterator begin() { return LPairs.begin(); }\n  iterator end() { return LPairs.end(); }\n\n  void flattenLocations() override {\n    for (auto &I : *this)\n      I.flatten();\n  }\n\n  using const_iterator =\n      std::vector<PathDiagnosticLocationPair>::const_iterator;\n\n  const_iterator begin() const { return LPairs.begin(); }\n  const_iterator end() const { return LPairs.end(); }\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == ControlFlow;\n  }\n\n  void dump() const override;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n};\n\nclass PathDiagnosticMacroPiece : public PathDiagnosticSpotPiece {\npublic:\n  PathDiagnosticMacroPiece(const PathDiagnosticLocation &pos)\n      : PathDiagnosticSpotPiece(pos, \"\", Macro) {}\n  ~PathDiagnosticMacroPiece() override;\n\n  PathPieces subPieces;\n\n  void flattenLocations() override {\n    PathDiagnosticSpotPiece::flattenLocations();\n    for (const auto &I : subPieces)\n      I->flattenLocations();\n  }\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == Macro;\n  }\n\n  void dump() const override;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n};\n\nclass PathDiagnosticNotePiece: public PathDiagnosticSpotPiece {\npublic:\n  PathDiagnosticNotePiece(const PathDiagnosticLocation &Pos, StringRef S,\n                          bool AddPosRange = true)\n      : PathDiagnosticSpotPiece(Pos, S, Note, AddPosRange) {}\n  ~PathDiagnosticNotePiece() override;\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == Note;\n  }\n\n  void dump() const override;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n};\n\nclass PathDiagnosticPopUpPiece: public PathDiagnosticSpotPiece {\npublic:\n  PathDiagnosticPopUpPiece(const PathDiagnosticLocation &Pos, StringRef S,\n                           bool AddPosRange = true)\n      : PathDiagnosticSpotPiece(Pos, S, PopUp, AddPosRange) {}\n  ~PathDiagnosticPopUpPiece() override;\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == PopUp;\n  }\n\n  void dump() const override;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n};\n\n/// File IDs mapped to sets of line numbers.\nusing FilesToLineNumsMap = std::map<FileID, std::set<unsigned>>;\n\n/// PathDiagnostic - PathDiagnostic objects represent a single path-sensitive\n///  diagnostic.  It represents an ordered-collection of PathDiagnosticPieces,\n///  each which represent the pieces of the path.\nclass PathDiagnostic : public llvm::FoldingSetNode {\n  std::string CheckerName;\n  const Decl *DeclWithIssue;\n  std::string BugType;\n  std::string VerboseDesc;\n  std::string ShortDesc;\n  std::string Category;\n  std::deque<std::string> OtherDesc;\n\n  /// Loc The location of the path diagnostic report.\n  PathDiagnosticLocation Loc;\n\n  PathPieces pathImpl;\n  SmallVector<PathPieces *, 3> pathStack;\n\n  /// Important bug uniqueing location.\n  /// The location info is useful to differentiate between bugs.\n  PathDiagnosticLocation UniqueingLoc;\n  const Decl *UniqueingDecl;\n\n  /// Lines executed in the path.\n  std::unique_ptr<FilesToLineNumsMap> ExecutedLines;\n\npublic:\n  PathDiagnostic() = delete;\n  PathDiagnostic(StringRef CheckerName, const Decl *DeclWithIssue,\n                 StringRef bugtype, StringRef verboseDesc, StringRef shortDesc,\n                 StringRef category, PathDiagnosticLocation LocationToUnique,\n                 const Decl *DeclToUnique,\n                 std::unique_ptr<FilesToLineNumsMap> ExecutedLines);\n  ~PathDiagnostic();\n\n  const PathPieces &path;\n\n  /// Return the path currently used by builders for constructing the\n  /// PathDiagnostic.\n  PathPieces &getActivePath() {\n    if (pathStack.empty())\n      return pathImpl;\n    return *pathStack.back();\n  }\n\n  /// Return a mutable version of 'path'.\n  PathPieces &getMutablePieces() {\n    return pathImpl;\n  }\n\n  /// Return the unrolled size of the path.\n  unsigned full_size();\n\n  void pushActivePath(PathPieces *p) { pathStack.push_back(p); }\n  void popActivePath() { if (!pathStack.empty()) pathStack.pop_back(); }\n\n  bool isWithinCall() const { return !pathStack.empty(); }\n\n  void setEndOfPath(PathDiagnosticPieceRef EndPiece) {\n    assert(!Loc.isValid() && \"End location already set!\");\n    Loc = EndPiece->getLocation();\n    assert(Loc.isValid() && \"Invalid location for end-of-path piece\");\n    getActivePath().push_back(std::move(EndPiece));\n  }\n\n  void appendToDesc(StringRef S) {\n    if (!ShortDesc.empty())\n      ShortDesc += S;\n    VerboseDesc += S;\n  }\n\n  StringRef getVerboseDescription() const { return VerboseDesc; }\n\n  StringRef getShortDescription() const {\n    return ShortDesc.empty() ? VerboseDesc : ShortDesc;\n  }\n\n  StringRef getCheckerName() const { return CheckerName; }\n  StringRef getBugType() const { return BugType; }\n  StringRef getCategory() const { return Category; }\n\n  using meta_iterator = std::deque<std::string>::const_iterator;\n\n  meta_iterator meta_begin() const { return OtherDesc.begin(); }\n  meta_iterator meta_end() const { return OtherDesc.end(); }\n  void addMeta(StringRef s) { OtherDesc.push_back(std::string(s)); }\n\n  const FilesToLineNumsMap &getExecutedLines() const {\n    return *ExecutedLines;\n  }\n\n  FilesToLineNumsMap &getExecutedLines() {\n    return *ExecutedLines;\n  }\n\n  /// Return the semantic context where an issue occurred.  If the\n  /// issue occurs along a path, this represents the \"central\" area\n  /// where the bug manifests.\n  const Decl *getDeclWithIssue() const { return DeclWithIssue; }\n\n  void setDeclWithIssue(const Decl *D) {\n    DeclWithIssue = D;\n  }\n\n  PathDiagnosticLocation getLocation() const {\n    return Loc;\n  }\n\n  void setLocation(PathDiagnosticLocation NewLoc) {\n    Loc = NewLoc;\n  }\n\n  /// Get the location on which the report should be uniqued.\n  PathDiagnosticLocation getUniqueingLoc() const {\n    return UniqueingLoc;\n  }\n\n  /// Get the declaration containing the uniqueing location.\n  const Decl *getUniqueingDecl() const {\n    return UniqueingDecl;\n  }\n\n  void flattenLocations() {\n    Loc.flatten();\n    for (const auto &I : pathImpl)\n      I->flattenLocations();\n  }\n\n  /// Profiles the diagnostic, independent of the path it references.\n  ///\n  /// This can be used to merge diagnostics that refer to the same issue\n  /// along different paths.\n  void Profile(llvm::FoldingSetNodeID &ID) const;\n\n  /// Profiles the diagnostic, including its path.\n  ///\n  /// Two diagnostics with the same issue along different paths will generate\n  /// different profiles.\n  void FullProfile(llvm::FoldingSetNodeID &ID) const;\n};\n\n} // namespace ento\n} // namespace clang\n\n#endif // LLVM_CLANG_STATICANALYZER_CORE_BUGREPORTER_PATHDIAGNOSTIC_H\n"}, "50": {"id": 50, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/AttributeCommonInfo.h", "content": "//======- AttributeCommonInfo.h - Base info about Attributes-----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the AttributeCommonInfo type, which is the base for a\n// ParsedAttr and is used by Attr as a way to share info between the two.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_ATTRIBUTECOMMONINFO_H\n#define LLVM_CLANG_BASIC_ATTRIBUTECOMMONINFO_H\n#include \"clang/Basic/SourceLocation.h\"\n\nnamespace clang {\nclass IdentifierInfo;\nclass ASTRecordWriter;\n\nclass AttributeCommonInfo {\npublic:\n  /// The style used to specify an attribute.\n  enum Syntax {\n    /// __attribute__((...))\n    AS_GNU,\n\n    /// [[...]]\n    AS_CXX11,\n\n    /// [[...]]\n    AS_C2x,\n\n    /// __declspec(...)\n    AS_Declspec,\n\n    /// [uuid(\"...\")] class Foo\n    AS_Microsoft,\n\n    /// __ptr16, alignas(...), etc.\n    AS_Keyword,\n\n    /// #pragma ...\n    AS_Pragma,\n\n    // Note TableGen depends on the order above.  Do not add or change the order\n    // without adding related code to TableGen/ClangAttrEmitter.cpp.\n    /// Context-sensitive version of a keyword attribute.\n    AS_ContextSensitiveKeyword,\n  };\n  enum Kind {\n#define PARSED_ATTR(NAME) AT_##NAME,\n#include \"clang/Sema/AttrParsedAttrList.inc\"\n#undef PARSED_ATTR\n    NoSemaHandlerAttribute,\n    IgnoredAttribute,\n    UnknownAttribute,\n  };\n\nprivate:\n  const IdentifierInfo *AttrName = nullptr;\n  const IdentifierInfo *ScopeName = nullptr;\n  SourceRange AttrRange;\n  const SourceLocation ScopeLoc;\n  // Corresponds to the Kind enum.\n  unsigned AttrKind : 16;\n  /// Corresponds to the Syntax enum.\n  unsigned SyntaxUsed : 3;\n  unsigned SpellingIndex : 4;\n\nprotected:\n  static constexpr unsigned SpellingNotCalculated = 0xf;\n\npublic:\n  AttributeCommonInfo(SourceRange AttrRange)\n      : AttrRange(AttrRange), ScopeLoc(), AttrKind(0), SyntaxUsed(0),\n        SpellingIndex(SpellingNotCalculated) {}\n\n  AttributeCommonInfo(SourceLocation AttrLoc)\n      : AttrRange(AttrLoc), ScopeLoc(), AttrKind(0), SyntaxUsed(0),\n        SpellingIndex(SpellingNotCalculated) {}\n\n  AttributeCommonInfo(const IdentifierInfo *AttrName,\n                      const IdentifierInfo *ScopeName, SourceRange AttrRange,\n                      SourceLocation ScopeLoc, Syntax SyntaxUsed)\n      : AttrName(AttrName), ScopeName(ScopeName), AttrRange(AttrRange),\n        ScopeLoc(ScopeLoc),\n        AttrKind(getParsedKind(AttrName, ScopeName, SyntaxUsed)),\n        SyntaxUsed(SyntaxUsed), SpellingIndex(SpellingNotCalculated) {}\n\n  AttributeCommonInfo(const IdentifierInfo *AttrName,\n                      const IdentifierInfo *ScopeName, SourceRange AttrRange,\n                      SourceLocation ScopeLoc, Kind AttrKind, Syntax SyntaxUsed)\n      : AttrName(AttrName), ScopeName(ScopeName), AttrRange(AttrRange),\n        ScopeLoc(ScopeLoc), AttrKind(AttrKind), SyntaxUsed(SyntaxUsed),\n        SpellingIndex(SpellingNotCalculated) {}\n\n  AttributeCommonInfo(const IdentifierInfo *AttrName,\n                      const IdentifierInfo *ScopeName, SourceRange AttrRange,\n                      SourceLocation ScopeLoc, Kind AttrKind, Syntax SyntaxUsed,\n                      unsigned Spelling)\n      : AttrName(AttrName), ScopeName(ScopeName), AttrRange(AttrRange),\n        ScopeLoc(ScopeLoc), AttrKind(AttrKind), SyntaxUsed(SyntaxUsed),\n        SpellingIndex(Spelling) {}\n\n  AttributeCommonInfo(const IdentifierInfo *AttrName, SourceRange AttrRange,\n                      Syntax SyntaxUsed)\n      : AttrName(AttrName), ScopeName(nullptr), AttrRange(AttrRange),\n        ScopeLoc(), AttrKind(getParsedKind(AttrName, ScopeName, SyntaxUsed)),\n        SyntaxUsed(SyntaxUsed), SpellingIndex(SpellingNotCalculated) {}\n\n  AttributeCommonInfo(SourceRange AttrRange, Kind K, Syntax SyntaxUsed)\n      : AttrName(nullptr), ScopeName(nullptr), AttrRange(AttrRange), ScopeLoc(),\n        AttrKind(K), SyntaxUsed(SyntaxUsed),\n        SpellingIndex(SpellingNotCalculated) {}\n\n  AttributeCommonInfo(SourceRange AttrRange, Kind K, Syntax SyntaxUsed,\n                      unsigned Spelling)\n      : AttrName(nullptr), ScopeName(nullptr), AttrRange(AttrRange), ScopeLoc(),\n        AttrKind(K), SyntaxUsed(SyntaxUsed), SpellingIndex(Spelling) {}\n\n  AttributeCommonInfo(AttributeCommonInfo &&) = default;\n  AttributeCommonInfo(const AttributeCommonInfo &) = default;\n\n  Kind getParsedKind() const { return Kind(AttrKind); }\n  Syntax getSyntax() const { return Syntax(SyntaxUsed); }\n  const IdentifierInfo *getAttrName() const { return AttrName; }\n  SourceLocation getLoc() const { return AttrRange.getBegin(); }\n  SourceRange getRange() const { return AttrRange; }\n  void setRange(SourceRange R) { AttrRange = R; }\n\n  bool hasScope() const { return ScopeName; }\n  const IdentifierInfo *getScopeName() const { return ScopeName; }\n  SourceLocation getScopeLoc() const { return ScopeLoc; }\n\n  /// Gets the normalized full name, which consists of both scope and name and\n  /// with surrounding underscores removed as appropriate (e.g.\n  /// __gnu__::__attr__ will be normalized to gnu::attr).\n  std::string getNormalizedFullName() const;\n\n  bool isDeclspecAttribute() const { return SyntaxUsed == AS_Declspec; }\n  bool isMicrosoftAttribute() const { return SyntaxUsed == AS_Microsoft; }\n\n  bool isGNUScope() const;\n\n  bool isAlignasAttribute() const {\n    // FIXME: Use a better mechanism to determine this.\n    return getParsedKind() == AT_Aligned && isKeywordAttribute();\n  }\n\n  bool isCXX11Attribute() const {\n    return SyntaxUsed == AS_CXX11 || isAlignasAttribute();\n  }\n\n  bool isC2xAttribute() const { return SyntaxUsed == AS_C2x; }\n\n  bool isKeywordAttribute() const {\n    return SyntaxUsed == AS_Keyword || SyntaxUsed == AS_ContextSensitiveKeyword;\n  }\n\n  bool isContextSensitiveKeywordAttribute() const {\n    return SyntaxUsed == AS_ContextSensitiveKeyword;\n  }\n\n  unsigned getAttributeSpellingListIndex() const {\n    assert((isAttributeSpellingListCalculated() || AttrName) &&\n           \"Spelling cannot be found\");\n    return isAttributeSpellingListCalculated()\n               ? SpellingIndex\n               : calculateAttributeSpellingListIndex();\n  }\n  void setAttributeSpellingListIndex(unsigned V) { SpellingIndex = V; }\n\n  static Kind getParsedKind(const IdentifierInfo *Name,\n                            const IdentifierInfo *Scope, Syntax SyntaxUsed);\n\nprivate:\n  /// Get an index into the attribute spelling list\n  /// defined in Attr.td. This index is used by an attribute\n  /// to pretty print itself.\n  unsigned calculateAttributeSpellingListIndex() const;\n\n  friend class clang::ASTRecordWriter;\n  // Used exclusively by ASTDeclWriter to get the raw spelling list state.\n  unsigned getAttributeSpellingListIndexRaw() const { return SpellingIndex; }\n\nprotected:\n  bool isAttributeSpellingListCalculated() const {\n    return SpellingIndex != SpellingNotCalculated;\n  }\n};\n} // namespace clang\n\n#endif // LLVM_CLANG_BASIC_ATTRIBUTECOMMONINFO_H\n"}, "55": {"id": 55, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/DirectoryEntry.h", "content": "//===- clang/Basic/DirectoryEntry.h - Directory references ------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Defines interfaces for clang::DirectoryEntry and clang::DirectoryEntryRef.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_DIRECTORYENTRY_H\n#define LLVM_CLANG_BASIC_DIRECTORYENTRY_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/Hashing.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/ErrorOr.h\"\n\nnamespace clang {\nnamespace FileMgr {\n\ntemplate <class RefTy> class MapEntryOptionalStorage;\n\n} // end namespace FileMgr\n\n/// Cached information about one directory (either on disk or in\n/// the virtual file system).\nclass DirectoryEntry {\n  friend class FileManager;\n\n  // FIXME: We should not be storing a directory entry name here.\n  StringRef Name; // Name of the directory.\n\npublic:\n  StringRef getName() const { return Name; }\n};\n\n/// A reference to a \\c DirectoryEntry  that includes the name of the directory\n/// as it was accessed by the FileManager's client.\nclass DirectoryEntryRef {\npublic:\n  const DirectoryEntry &getDirEntry() const { return *ME->getValue(); }\n\n  StringRef getName() const { return ME->getKey(); }\n\n  /// Hash code is based on the DirectoryEntry, not the specific named\n  /// reference.\n  friend llvm::hash_code hash_value(DirectoryEntryRef Ref) {\n    return llvm::hash_value(&Ref.getDirEntry());\n  }\n\n  using MapEntry = llvm::StringMapEntry<llvm::ErrorOr<DirectoryEntry &>>;\n\n  const MapEntry &getMapEntry() const { return *ME; }\n\n  /// Check if RHS referenced the file in exactly the same way.\n  bool isSameRef(DirectoryEntryRef RHS) const { return ME == RHS.ME; }\n\n  DirectoryEntryRef() = delete;\n  DirectoryEntryRef(const MapEntry &ME) : ME(&ME) {}\n\n  /// Allow DirectoryEntryRef to degrade into 'const DirectoryEntry*' to\n  /// facilitate incremental adoption.\n  ///\n  /// The goal is to avoid code churn due to dances like the following:\n  /// \\code\n  /// // Old code.\n  /// lvalue = rvalue;\n  ///\n  /// // Temporary code from an incremental patch.\n  /// lvalue = &rvalue.getDirectoryEntry();\n  ///\n  /// // Final code.\n  /// lvalue = rvalue;\n  /// \\endcode\n  ///\n  /// FIXME: Once DirectoryEntryRef is \"everywhere\" and DirectoryEntry::getName\n  /// has been deleted, delete this implicit conversion.\n  operator const DirectoryEntry *() const { return &getDirEntry(); }\n\nprivate:\n  friend class FileMgr::MapEntryOptionalStorage<DirectoryEntryRef>;\n  struct optional_none_tag {};\n\n  // Private constructor for use by OptionalStorage.\n  DirectoryEntryRef(optional_none_tag) : ME(nullptr) {}\n  bool hasOptionalValue() const { return ME; }\n\n  friend struct llvm::DenseMapInfo<DirectoryEntryRef>;\n  struct dense_map_empty_tag {};\n  struct dense_map_tombstone_tag {};\n\n  // Private constructors for use by DenseMapInfo.\n  DirectoryEntryRef(dense_map_empty_tag)\n      : ME(llvm::DenseMapInfo<const MapEntry *>::getEmptyKey()) {}\n  DirectoryEntryRef(dense_map_tombstone_tag)\n      : ME(llvm::DenseMapInfo<const MapEntry *>::getTombstoneKey()) {}\n  bool isSpecialDenseMapKey() const {\n    return isSameRef(DirectoryEntryRef(dense_map_empty_tag())) ||\n           isSameRef(DirectoryEntryRef(dense_map_tombstone_tag()));\n  }\n\n  const MapEntry *ME;\n};\n\nnamespace FileMgr {\n\n/// Customized storage for refs derived from map entires in FileManager, using\n/// the private optional_none_tag to keep it to the size of a single pointer.\ntemplate <class RefTy> class MapEntryOptionalStorage {\n  using optional_none_tag = typename RefTy::optional_none_tag;\n  RefTy MaybeRef;\n\npublic:\n  MapEntryOptionalStorage() : MaybeRef(optional_none_tag()) {}\n\n  template <class... ArgTypes>\n  explicit MapEntryOptionalStorage(llvm::optional_detail::in_place_t,\n                                   ArgTypes &&...Args)\n      : MaybeRef(std::forward<ArgTypes>(Args)...) {}\n\n  void reset() { MaybeRef = optional_none_tag(); }\n\n  bool hasValue() const { return MaybeRef.hasOptionalValue(); }\n\n  RefTy &getValue() LLVM_LVALUE_FUNCTION {\n    assert(hasValue());\n    return MaybeRef;\n  }\n  RefTy const &getValue() const LLVM_LVALUE_FUNCTION {\n    assert(hasValue());\n    return MaybeRef;\n  }\n#if LLVM_HAS_RVALUE_REFERENCE_THIS\n  RefTy &&getValue() && {\n    assert(hasValue());\n    return std::move(MaybeRef);\n  }\n#endif\n\n  template <class... Args> void emplace(Args &&...args) {\n    MaybeRef = RefTy(std::forward<Args>(args)...);\n  }\n\n  MapEntryOptionalStorage &operator=(RefTy Ref) {\n    MaybeRef = Ref;\n    return *this;\n  }\n};\n\n} // end namespace FileMgr\n} // end namespace clang\n\nnamespace llvm {\nnamespace optional_detail {\n\n/// Customize OptionalStorage<DirectoryEntryRef> to use DirectoryEntryRef and\n/// its optional_none_tag to keep it the size of a single pointer.\ntemplate <>\nclass OptionalStorage<clang::DirectoryEntryRef>\n    : public clang::FileMgr::MapEntryOptionalStorage<clang::DirectoryEntryRef> {\n  using StorageImpl =\n      clang::FileMgr::MapEntryOptionalStorage<clang::DirectoryEntryRef>;\n\npublic:\n  OptionalStorage() = default;\n\n  template <class... ArgTypes>\n  explicit OptionalStorage(in_place_t, ArgTypes &&...Args)\n      : StorageImpl(in_place_t{}, std::forward<ArgTypes>(Args)...) {}\n\n  OptionalStorage &operator=(clang::DirectoryEntryRef Ref) {\n    StorageImpl::operator=(Ref);\n    return *this;\n  }\n};\n\nstatic_assert(sizeof(Optional<clang::DirectoryEntryRef>) ==\n                  sizeof(clang::DirectoryEntryRef),\n              \"Optional<DirectoryEntryRef> must avoid size overhead\");\n\nstatic_assert(\n    std::is_trivially_copyable<Optional<clang::DirectoryEntryRef>>::value,\n    \"Optional<DirectoryEntryRef> should be trivially copyable\");\n\n} // end namespace optional_detail\n\n/// Specialisation of DenseMapInfo for DirectoryEntryRef.\ntemplate <> struct DenseMapInfo<clang::DirectoryEntryRef> {\n  static inline clang::DirectoryEntryRef getEmptyKey() {\n    return clang::DirectoryEntryRef(\n        clang::DirectoryEntryRef::dense_map_empty_tag());\n  }\n\n  static inline clang::DirectoryEntryRef getTombstoneKey() {\n    return clang::DirectoryEntryRef(\n        clang::DirectoryEntryRef::dense_map_tombstone_tag());\n  }\n\n  static unsigned getHashValue(clang::DirectoryEntryRef Val) {\n    return hash_value(Val);\n  }\n\n  static bool isEqual(clang::DirectoryEntryRef LHS,\n                      clang::DirectoryEntryRef RHS) {\n    // Catch the easy cases: both empty, both tombstone, or the same ref.\n    if (LHS.isSameRef(RHS))\n      return true;\n\n    // Confirm LHS and RHS are valid.\n    if (LHS.isSpecialDenseMapKey() || RHS.isSpecialDenseMapKey())\n      return false;\n\n    // It's safe to use operator==.\n    return LHS == RHS;\n  }\n};\n\n} // end namespace llvm\n\nnamespace clang {\n\n/// Wrapper around Optional<DirectoryEntryRef> that degrades to 'const\n/// DirectoryEntry*', facilitating incremental patches to propagate\n/// DirectoryEntryRef.\n///\n/// This class can be used as return value or field where it's convenient for\n/// an Optional<DirectoryEntryRef> to degrade to a 'const DirectoryEntry*'. The\n/// purpose is to avoid code churn due to dances like the following:\n/// \\code\n/// // Old code.\n/// lvalue = rvalue;\n///\n/// // Temporary code from an incremental patch.\n/// Optional<DirectoryEntryRef> MaybeF = rvalue;\n/// lvalue = MaybeF ? &MaybeF.getDirectoryEntry() : nullptr;\n///\n/// // Final code.\n/// lvalue = rvalue;\n/// \\endcode\n///\n/// FIXME: Once DirectoryEntryRef is \"everywhere\" and DirectoryEntry::LastRef\n/// and DirectoryEntry::getName have been deleted, delete this class and\n/// replace instances with Optional<DirectoryEntryRef>.\nclass OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr\n    : public Optional<DirectoryEntryRef> {\npublic:\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr() = default;\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr(\n      OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr &&) = default;\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr(\n      const OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr &) = default;\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr &\n  operator=(OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr &&) = default;\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr &\n  operator=(const OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr &) = default;\n\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr(llvm::NoneType) {}\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr(DirectoryEntryRef Ref)\n      : Optional<DirectoryEntryRef>(Ref) {}\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr(Optional<DirectoryEntryRef> MaybeRef)\n      : Optional<DirectoryEntryRef>(MaybeRef) {}\n\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr &operator=(llvm::NoneType) {\n    Optional<DirectoryEntryRef>::operator=(None);\n    return *this;\n  }\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr &operator=(DirectoryEntryRef Ref) {\n    Optional<DirectoryEntryRef>::operator=(Ref);\n    return *this;\n  }\n  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr &\n  operator=(Optional<DirectoryEntryRef> MaybeRef) {\n    Optional<DirectoryEntryRef>::operator=(MaybeRef);\n    return *this;\n  }\n\n  /// Degrade to 'const DirectoryEntry *' to allow  DirectoryEntry::LastRef and\n  /// DirectoryEntry::getName have been deleted, delete this class and replace\n  /// instances with Optional<DirectoryEntryRef>\n  operator const DirectoryEntry *() const {\n    return hasValue() ? &getValue().getDirEntry() : nullptr;\n  }\n};\n\nstatic_assert(std::is_trivially_copyable<\n                  OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr>::value,\n              \"OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr should be \"\n              \"trivially copyable\");\n\n} // end namespace clang\n\n#endif // LLVM_CLANG_BASIC_DIRECTORYENTRY_H\n"}, "56": {"id": 56, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "content": "//===- clang/Basic/FileEntry.h - File references ----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Defines interfaces for clang::FileEntry and clang::FileEntryRef.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_FILEENTRY_H\n#define LLVM_CLANG_BASIC_FILEENTRY_H\n\n#include \"clang/Basic/DirectoryEntry.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/Hashing.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/ErrorOr.h\"\n#include \"llvm/Support/FileSystem/UniqueID.h\"\n\nnamespace llvm {\n\nclass MemoryBuffer;\n\nnamespace vfs {\n\nclass File;\n\n} // namespace vfs\n} // namespace llvm\n\nnamespace clang {\n\nclass FileEntryRef;\n\n} // namespace clang\n\nnamespace llvm {\nnamespace optional_detail {\n\n/// Forward declare a template specialization for OptionalStorage.\ntemplate <>\nclass OptionalStorage<clang::FileEntryRef, /*is_trivially_copyable*/ true>;\n\n} // namespace optional_detail\n} // namespace llvm\n\nnamespace clang {\n\nclass FileEntry;\n\n/// A reference to a \\c FileEntry that includes the name of the file as it was\n/// accessed by the FileManager's client.\nclass FileEntryRef {\npublic:\n  StringRef getName() const { return ME->first(); }\n  const FileEntry &getFileEntry() const {\n    return *ME->second->V.get<FileEntry *>();\n  }\n  DirectoryEntryRef getDir() const { return *ME->second->Dir; }\n\n  inline bool isValid() const;\n  inline off_t getSize() const;\n  inline unsigned getUID() const;\n  inline const llvm::sys::fs::UniqueID &getUniqueID() const;\n  inline time_t getModificationTime() const;\n  inline bool isNamedPipe() const;\n  inline void closeFile() const;\n\n  /// Check if the underlying FileEntry is the same, intentially ignoring\n  /// whether the file was referenced with the same spelling of the filename.\n  friend bool operator==(const FileEntryRef &LHS, const FileEntryRef &RHS) {\n    return &LHS.getFileEntry() == &RHS.getFileEntry();\n  }\n  friend bool operator==(const FileEntry *LHS, const FileEntryRef &RHS) {\n    return LHS == &RHS.getFileEntry();\n  }\n  friend bool operator==(const FileEntryRef &LHS, const FileEntry *RHS) {\n    return &LHS.getFileEntry() == RHS;\n  }\n  friend bool operator!=(const FileEntryRef &LHS, const FileEntryRef &RHS) {\n    return !(LHS == RHS);\n  }\n  friend bool operator!=(const FileEntry *LHS, const FileEntryRef &RHS) {\n    return !(LHS == RHS);\n  }\n  friend bool operator!=(const FileEntryRef &LHS, const FileEntry *RHS) {\n    return !(LHS == RHS);\n  }\n\n  /// Hash code is based on the FileEntry, not the specific named reference,\n  /// just like operator==.\n  friend llvm::hash_code hash_value(FileEntryRef Ref) {\n    return llvm::hash_value(&Ref.getFileEntry());\n  }\n\n  struct MapValue;\n\n  /// Type used in the StringMap.\n  using MapEntry = llvm::StringMapEntry<llvm::ErrorOr<MapValue>>;\n\n  /// Type stored in the StringMap.\n  struct MapValue {\n    /// The pointer at another MapEntry is used when the FileManager should\n    /// silently forward from one name to another, which occurs in Redirecting\n    /// VFSs that use external names. In that case, the \\c FileEntryRef\n    /// returned by the \\c FileManager will have the external name, and not the\n    /// name that was used to lookup the file.\n    ///\n    /// The second type is really a `const MapEntry *`, but that confuses\n    /// gcc5.3.  Once that's no longer supported, change this back.\n    llvm::PointerUnion<FileEntry *, const void *> V;\n\n    /// Directory the file was found in. Set if and only if V is a FileEntry.\n    Optional<DirectoryEntryRef> Dir;\n\n    MapValue() = delete;\n    MapValue(FileEntry &FE, DirectoryEntryRef Dir) : V(&FE), Dir(Dir) {}\n    MapValue(MapEntry &ME) : V(&ME) {}\n  };\n\n  /// Check if RHS referenced the file in exactly the same way.\n  bool isSameRef(const FileEntryRef &RHS) const { return ME == RHS.ME; }\n\n  /// Allow FileEntryRef to degrade into 'const FileEntry*' to facilitate\n  /// incremental adoption.\n  ///\n  /// The goal is to avoid code churn due to dances like the following:\n  /// \\code\n  /// // Old code.\n  /// lvalue = rvalue;\n  ///\n  /// // Temporary code from an incremental patch.\n  /// lvalue = &rvalue.getFileEntry();\n  ///\n  /// // Final code.\n  /// lvalue = rvalue;\n  /// \\endcode\n  ///\n  /// FIXME: Once FileEntryRef is \"everywhere\" and FileEntry::LastRef and\n  /// FileEntry::getName have been deleted, delete this implicit conversion.\n  operator const FileEntry *() const { return &getFileEntry(); }\n\n  FileEntryRef() = delete;\n  explicit FileEntryRef(const MapEntry &ME) : ME(&ME) {\n    assert(ME.second && \"Expected payload\");\n    assert(ME.second->V && \"Expected non-null\");\n    assert(ME.second->V.is<FileEntry *>() && \"Expected FileEntry\");\n  }\n\n  /// Expose the underlying MapEntry to simplify packing in a PointerIntPair or\n  /// PointerUnion and allow construction in Optional.\n  const clang::FileEntryRef::MapEntry &getMapEntry() const { return *ME; }\n\nprivate:\n  friend class FileMgr::MapEntryOptionalStorage<FileEntryRef>;\n  struct optional_none_tag {};\n\n  // Private constructor for use by OptionalStorage.\n  FileEntryRef(optional_none_tag) : ME(nullptr) {}\n  bool hasOptionalValue() const { return ME; }\n\n  friend struct llvm::DenseMapInfo<FileEntryRef>;\n  struct dense_map_empty_tag {};\n  struct dense_map_tombstone_tag {};\n\n  // Private constructors for use by DenseMapInfo.\n  FileEntryRef(dense_map_empty_tag)\n      : ME(llvm::DenseMapInfo<const MapEntry *>::getEmptyKey()) {}\n  FileEntryRef(dense_map_tombstone_tag)\n      : ME(llvm::DenseMapInfo<const MapEntry *>::getTombstoneKey()) {}\n  bool isSpecialDenseMapKey() const {\n    return isSameRef(FileEntryRef(dense_map_empty_tag())) ||\n           isSameRef(FileEntryRef(dense_map_tombstone_tag()));\n  }\n\n  const MapEntry *ME;\n};\n\nstatic_assert(sizeof(FileEntryRef) == sizeof(const FileEntry *),\n              \"FileEntryRef must avoid size overhead\");\n\nstatic_assert(std::is_trivially_copyable<FileEntryRef>::value,\n              \"FileEntryRef must be trivially copyable\");\n\n} // end namespace clang\n\nnamespace llvm {\nnamespace optional_detail {\n\n/// Customize OptionalStorage<FileEntryRef> to use FileEntryRef and its\n/// optional_none_tag to keep it the size of a single pointer.\ntemplate <>\nclass OptionalStorage<clang::FileEntryRef>\n    : public clang::FileMgr::MapEntryOptionalStorage<clang::FileEntryRef> {\n  using StorageImpl =\n      clang::FileMgr::MapEntryOptionalStorage<clang::FileEntryRef>;\n\npublic:\n  OptionalStorage() = default;\n\n  template <class... ArgTypes>\n  explicit OptionalStorage(in_place_t, ArgTypes &&...Args)\n      : StorageImpl(in_place_t{}, std::forward<ArgTypes>(Args)...) {}\n\n  OptionalStorage &operator=(clang::FileEntryRef Ref) {\n    StorageImpl::operator=(Ref);\n    return *this;\n  }\n};\n\nstatic_assert(sizeof(Optional<clang::FileEntryRef>) ==\n                  sizeof(clang::FileEntryRef),\n              \"Optional<FileEntryRef> must avoid size overhead\");\n\nstatic_assert(std::is_trivially_copyable<Optional<clang::FileEntryRef>>::value,\n              \"Optional<FileEntryRef> should be trivially copyable\");\n\n} // end namespace optional_detail\n\n/// Specialisation of DenseMapInfo for FileEntryRef.\ntemplate <> struct DenseMapInfo<clang::FileEntryRef> {\n  static inline clang::FileEntryRef getEmptyKey() {\n    return clang::FileEntryRef(clang::FileEntryRef::dense_map_empty_tag());\n  }\n\n  static inline clang::FileEntryRef getTombstoneKey() {\n    return clang::FileEntryRef(clang::FileEntryRef::dense_map_tombstone_tag());\n  }\n\n  static unsigned getHashValue(clang::FileEntryRef Val) {\n    return hash_value(Val);\n  }\n\n  static bool isEqual(clang::FileEntryRef LHS, clang::FileEntryRef RHS) {\n    // Catch the easy cases: both empty, both tombstone, or the same ref.\n    if (LHS.isSameRef(RHS))\n      return true;\n\n    // Confirm LHS and RHS are valid.\n    if (LHS.isSpecialDenseMapKey() || RHS.isSpecialDenseMapKey())\n      return false;\n\n    // It's safe to use operator==.\n    return LHS == RHS;\n  }\n};\n\n} // end namespace llvm\n\nnamespace clang {\n\n/// Wrapper around Optional<FileEntryRef> that degrades to 'const FileEntry*',\n/// facilitating incremental patches to propagate FileEntryRef.\n///\n/// This class can be used as return value or field where it's convenient for\n/// an Optional<FileEntryRef> to degrade to a 'const FileEntry*'. The purpose\n/// is to avoid code churn due to dances like the following:\n/// \\code\n/// // Old code.\n/// lvalue = rvalue;\n///\n/// // Temporary code from an incremental patch.\n/// Optional<FileEntryRef> MaybeF = rvalue;\n/// lvalue = MaybeF ? &MaybeF.getFileEntry() : nullptr;\n///\n/// // Final code.\n/// lvalue = rvalue;\n/// \\endcode\n///\n/// FIXME: Once FileEntryRef is \"everywhere\" and FileEntry::LastRef and\n/// FileEntry::getName have been deleted, delete this class and replace\n/// instances with Optional<FileEntryRef>.\nclass OptionalFileEntryRefDegradesToFileEntryPtr\n    : public Optional<FileEntryRef> {\npublic:\n  OptionalFileEntryRefDegradesToFileEntryPtr() = default;\n  OptionalFileEntryRefDegradesToFileEntryPtr(\n      OptionalFileEntryRefDegradesToFileEntryPtr &&) = default;\n  OptionalFileEntryRefDegradesToFileEntryPtr(\n      const OptionalFileEntryRefDegradesToFileEntryPtr &) = default;\n  OptionalFileEntryRefDegradesToFileEntryPtr &\n  operator=(OptionalFileEntryRefDegradesToFileEntryPtr &&) = default;\n  OptionalFileEntryRefDegradesToFileEntryPtr &\n  operator=(const OptionalFileEntryRefDegradesToFileEntryPtr &) = default;\n\n  OptionalFileEntryRefDegradesToFileEntryPtr(llvm::NoneType) {}\n  OptionalFileEntryRefDegradesToFileEntryPtr(FileEntryRef Ref)\n      : Optional<FileEntryRef>(Ref) {}\n  OptionalFileEntryRefDegradesToFileEntryPtr(Optional<FileEntryRef> MaybeRef)\n      : Optional<FileEntryRef>(MaybeRef) {}\n\n  OptionalFileEntryRefDegradesToFileEntryPtr &operator=(llvm::NoneType) {\n    Optional<FileEntryRef>::operator=(None);\n    return *this;\n  }\n  OptionalFileEntryRefDegradesToFileEntryPtr &operator=(FileEntryRef Ref) {\n    Optional<FileEntryRef>::operator=(Ref);\n    return *this;\n  }\n  OptionalFileEntryRefDegradesToFileEntryPtr &\n  operator=(Optional<FileEntryRef> MaybeRef) {\n    Optional<FileEntryRef>::operator=(MaybeRef);\n    return *this;\n  }\n\n  /// Degrade to 'const FileEntry *' to allow  FileEntry::LastRef and\n  /// FileEntry::getName have been deleted, delete this class and replace\n  /// instances with Optional<FileEntryRef>\n  operator const FileEntry *() const {\n    return hasValue() ? &getValue().getFileEntry() : nullptr;\n  }\n};\n\nstatic_assert(\n    std::is_trivially_copyable<\n        OptionalFileEntryRefDegradesToFileEntryPtr>::value,\n    \"OptionalFileEntryRefDegradesToFileEntryPtr should be trivially copyable\");\n\n/// Cached information about one file (either on disk\n/// or in the virtual file system).\n///\n/// If the 'File' member is valid, then this FileEntry has an open file\n/// descriptor for the file.\nclass FileEntry {\n  friend class FileManager;\n\n  std::string RealPathName;   // Real path to the file; could be empty.\n  off_t Size = 0;             // File size in bytes.\n  time_t ModTime = 0;         // Modification time of file.\n  const DirectoryEntry *Dir = nullptr; // Directory file lives in.\n  llvm::sys::fs::UniqueID UniqueID;\n  unsigned UID = 0; // A unique (small) ID for the file.\n  bool IsNamedPipe = false;\n  bool IsValid = false; // Is this \\c FileEntry initialized and valid?\n\n  /// The open file, if it is owned by the \\p FileEntry.\n  mutable std::unique_ptr<llvm::vfs::File> File;\n\n  /// The file content, if it is owned by the \\p FileEntry.\n  std::unique_ptr<llvm::MemoryBuffer> Content;\n\n  // First access name for this FileEntry.\n  //\n  // This is Optional only to allow delayed construction (FileEntryRef has no\n  // default constructor). It should always have a value in practice.\n  //\n  // TODO: remove this once everyone that needs a name uses FileEntryRef.\n  Optional<FileEntryRef> LastRef;\n\npublic:\n  FileEntry();\n  ~FileEntry();\n\n  FileEntry(const FileEntry &) = delete;\n  FileEntry &operator=(const FileEntry &) = delete;\n\n  StringRef getName() const { return LastRef->getName(); }\n  FileEntryRef getLastRef() const { return *LastRef; }\n\n  StringRef tryGetRealPathName() const { return RealPathName; }\n  bool isValid() const { return IsValid; }\n  off_t getSize() const { return Size; }\n  unsigned getUID() const { return UID; }\n  const llvm::sys::fs::UniqueID &getUniqueID() const { return UniqueID; }\n  time_t getModificationTime() const { return ModTime; }\n\n  /// Return the directory the file lives in.\n  const DirectoryEntry *getDir() const { return Dir; }\n\n  bool operator<(const FileEntry &RHS) const { return UniqueID < RHS.UniqueID; }\n\n  /// Check whether the file is a named pipe (and thus can't be opened by\n  /// the native FileManager methods).\n  bool isNamedPipe() const { return IsNamedPipe; }\n\n  void closeFile() const;\n};\n\nbool FileEntryRef::isValid() const { return getFileEntry().isValid(); }\n\noff_t FileEntryRef::getSize() const { return getFileEntry().getSize(); }\n\nunsigned FileEntryRef::getUID() const { return getFileEntry().getUID(); }\n\nconst llvm::sys::fs::UniqueID &FileEntryRef::getUniqueID() const {\n  return getFileEntry().getUniqueID();\n}\n\ntime_t FileEntryRef::getModificationTime() const {\n  return getFileEntry().getModificationTime();\n}\n\nbool FileEntryRef::isNamedPipe() const { return getFileEntry().isNamedPipe(); }\n\nvoid FileEntryRef::closeFile() const { getFileEntry().closeFile(); }\n\n} // end namespace clang\n\n#endif // LLVM_CLANG_BASIC_FILEENTRY_H\n"}, "57": {"id": 57, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileSystemOptions.h", "content": "//===--- FileSystemOptions.h - File System Options --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Defines the clang::FileSystemOptions interface.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_FILESYSTEMOPTIONS_H\n#define LLVM_CLANG_BASIC_FILESYSTEMOPTIONS_H\n\n#include <string>\n\nnamespace clang {\n\n/// Keeps track of options that affect how file operations are performed.\nclass FileSystemOptions {\npublic:\n  /// If set, paths are resolved as if the working directory was\n  /// set to the value of WorkingDir.\n  std::string WorkingDir;\n};\n\n} // end namespace clang\n\n#endif\n"}, "59": {"id": 59, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/LLVM.h", "content": "//===--- LLVM.h - Import various common LLVM datatypes ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Forward-declares and imports various common LLVM datatypes that\n/// clang wants to use unqualified.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_LLVM_H\n#define LLVM_CLANG_BASIC_LLVM_H\n\n// Do not proliferate #includes here, require clients to #include their\n// dependencies.\n// Casting.h has complex templates that cannot be easily forward declared.\n#include \"llvm/Support/Casting.h\"\n// None.h includes an enumerator that is desired & cannot be forward declared\n// without a definition of NoneType.\n#include \"llvm/ADT/None.h\"\n\nnamespace llvm {\n  // ADT's.\n  class StringRef;\n  class Twine;\n  class VersionTuple;\n  template<typename T> class ArrayRef;\n  template<typename T> class MutableArrayRef;\n  template<typename T> class OwningArrayRef;\n  template<unsigned InternalLen> class SmallString;\n  template<typename T, unsigned N> class SmallVector;\n  template<typename T> class SmallVectorImpl;\n  template<typename T> class Optional;\n  template <class T> class Expected;\n\n  template<typename T>\n  struct SaveAndRestore;\n\n  // Reference counting.\n  template <typename T> class IntrusiveRefCntPtr;\n  template <typename T> struct IntrusiveRefCntPtrInfo;\n  template <class Derived> class RefCountedBase;\n\n  class raw_ostream;\n  class raw_pwrite_stream;\n  // TODO: DenseMap, ...\n}\n\n\nnamespace clang {\n  // Casting operators.\n  using llvm::isa;\n  using llvm::isa_and_nonnull;\n  using llvm::cast;\n  using llvm::dyn_cast;\n  using llvm::dyn_cast_or_null;\n  using llvm::cast_or_null;\n\n  // ADT's.\n  using llvm::ArrayRef;\n  using llvm::MutableArrayRef;\n  using llvm::None;\n  using llvm::Optional;\n  using llvm::OwningArrayRef;\n  using llvm::SaveAndRestore;\n  using llvm::SmallString;\n  using llvm::SmallVector;\n  using llvm::SmallVectorImpl;\n  using llvm::StringRef;\n  using llvm::Twine;\n  using llvm::VersionTuple;\n\n  // Error handling.\n  using llvm::Expected;\n\n  // Reference counting.\n  using llvm::IntrusiveRefCntPtr;\n  using llvm::IntrusiveRefCntPtrInfo;\n  using llvm::RefCountedBase;\n\n  using llvm::raw_ostream;\n  using llvm::raw_pwrite_stream;\n} // end namespace clang.\n\n#endif\n"}, "61": {"id": 61, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Module.h", "content": "//===- Module.h - Describe a module -----------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the clang::Module class, which describes a module in the\n/// source code.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_MODULE_H\n#define LLVM_CLANG_BASIC_MODULE_H\n\n#include \"clang/Basic/DirectoryEntry.h\"\n#include \"clang/Basic/FileEntry.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <ctime>\n#include <iterator>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass raw_ostream;\n\n} // namespace llvm\n\nnamespace clang {\n\nclass FileManager;\nclass LangOptions;\nclass TargetInfo;\n\n/// Describes the name of a module.\nusing ModuleId = SmallVector<std::pair<std::string, SourceLocation>, 2>;\n\n/// The signature of a module, which is a hash of the AST content.\nstruct ASTFileSignature : std::array<uint8_t, 20> {\n  using BaseT = std::array<uint8_t, 20>;\n\n  static constexpr size_t size = std::tuple_size<BaseT>::value;\n\n  ASTFileSignature(BaseT S = {{0}}) : BaseT(std::move(S)) {}\n\n  explicit operator bool() const { return *this != BaseT({{0}}); }\n\n  /// Returns the value truncated to the size of an uint64_t.\n  uint64_t truncatedValue() const {\n    uint64_t Value = 0;\n    static_assert(sizeof(*this) >= sizeof(uint64_t), \"No need to truncate.\");\n    for (unsigned I = 0; I < sizeof(uint64_t); ++I)\n      Value |= static_cast<uint64_t>((*this)[I]) << (I * 8);\n    return Value;\n  }\n\n  static ASTFileSignature create(StringRef Bytes) {\n    return create(Bytes.bytes_begin(), Bytes.bytes_end());\n  }\n\n  static ASTFileSignature createDISentinel() {\n    ASTFileSignature Sentinel;\n    Sentinel.fill(0xFF);\n    return Sentinel;\n  }\n\n  template <typename InputIt>\n  static ASTFileSignature create(InputIt First, InputIt Last) {\n    assert(std::distance(First, Last) == size &&\n           \"Wrong amount of bytes to create an ASTFileSignature\");\n\n    ASTFileSignature Signature;\n    std::copy(First, Last, Signature.begin());\n    return Signature;\n  }\n};\n\n/// Describes a module or submodule.\nclass Module {\npublic:\n  /// The name of this module.\n  std::string Name;\n\n  /// The location of the module definition.\n  SourceLocation DefinitionLoc;\n\n  enum ModuleKind {\n    /// This is a module that was defined by a module map and built out\n    /// of header files.\n    ModuleMapModule,\n\n    /// This is a C++ Modules TS module interface unit.\n    ModuleInterfaceUnit,\n\n    /// This is a fragment of the global module within some C++ module.\n    GlobalModuleFragment,\n\n    /// This is the private module fragment within some C++ module.\n    PrivateModuleFragment,\n  };\n\n  /// The kind of this module.\n  ModuleKind Kind = ModuleMapModule;\n\n  /// The parent of this module. This will be NULL for the top-level\n  /// module.\n  Module *Parent;\n\n  /// The build directory of this module. This is the directory in\n  /// which the module is notionally built, and relative to which its headers\n  /// are found.\n  const DirectoryEntry *Directory = nullptr;\n\n  /// The presumed file name for the module map defining this module.\n  /// Only non-empty when building from preprocessed source.\n  std::string PresumedModuleMapFile;\n\n  /// The umbrella header or directory.\n  llvm::PointerUnion<const FileEntry *, const DirectoryEntry *> Umbrella;\n\n  /// The module signature.\n  ASTFileSignature Signature;\n\n  /// The name of the umbrella entry, as written in the module map.\n  std::string UmbrellaAsWritten;\n\n  /// The module through which entities defined in this module will\n  /// eventually be exposed, for use in \"private\" modules.\n  std::string ExportAsModule;\n\n  /// Does this Module scope describe part of the purview of a named C++ module?\n  bool isModulePurview() const {\n    return Kind == ModuleInterfaceUnit || Kind == PrivateModuleFragment;\n  }\n\nprivate:\n  /// The submodules of this module, indexed by name.\n  std::vector<Module *> SubModules;\n\n  /// A mapping from the submodule name to the index into the\n  /// \\c SubModules vector at which that submodule resides.\n  llvm::StringMap<unsigned> SubModuleIndex;\n\n  /// The AST file if this is a top-level module which has a\n  /// corresponding serialized AST file, or null otherwise.\n  Optional<FileEntryRef> ASTFile;\n\n  /// The top-level headers associated with this module.\n  llvm::SmallSetVector<const FileEntry *, 2> TopHeaders;\n\n  /// top-level header filenames that aren't resolved to FileEntries yet.\n  std::vector<std::string> TopHeaderNames;\n\n  /// Cache of modules visible to lookup in this module.\n  mutable llvm::DenseSet<const Module*> VisibleModulesCache;\n\n  /// The ID used when referencing this module within a VisibleModuleSet.\n  unsigned VisibilityID;\n\npublic:\n  enum HeaderKind {\n    HK_Normal,\n    HK_Textual,\n    HK_Private,\n    HK_PrivateTextual,\n    HK_Excluded\n  };\n  static const int NumHeaderKinds = HK_Excluded + 1;\n\n  /// Information about a header directive as found in the module map\n  /// file.\n  struct Header {\n    std::string NameAsWritten;\n    const FileEntry *Entry;\n\n    explicit operator bool() { return Entry; }\n  };\n\n  /// Information about a directory name as found in the module map\n  /// file.\n  struct DirectoryName {\n    std::string NameAsWritten;\n    const DirectoryEntry *Entry;\n\n    explicit operator bool() { return Entry; }\n  };\n\n  /// The headers that are part of this module.\n  SmallVector<Header, 2> Headers[5];\n\n  /// Stored information about a header directive that was found in the\n  /// module map file but has not been resolved to a file.\n  struct UnresolvedHeaderDirective {\n    HeaderKind Kind = HK_Normal;\n    SourceLocation FileNameLoc;\n    std::string FileName;\n    bool IsUmbrella = false;\n    bool HasBuiltinHeader = false;\n    Optional<off_t> Size;\n    Optional<time_t> ModTime;\n  };\n\n  /// Headers that are mentioned in the module map file but that we have not\n  /// yet attempted to resolve to a file on the file system.\n  SmallVector<UnresolvedHeaderDirective, 1> UnresolvedHeaders;\n\n  /// Headers that are mentioned in the module map file but could not be\n  /// found on the file system.\n  SmallVector<UnresolvedHeaderDirective, 1> MissingHeaders;\n\n  /// An individual requirement: a feature name and a flag indicating\n  /// the required state of that feature.\n  using Requirement = std::pair<std::string, bool>;\n\n  /// The set of language features required to use this module.\n  ///\n  /// If any of these requirements are not available, the \\c IsAvailable bit\n  /// will be false to indicate that this (sub)module is not available.\n  SmallVector<Requirement, 2> Requirements;\n\n  /// A module with the same name that shadows this module.\n  Module *ShadowingModule = nullptr;\n\n  /// Whether this module has declared itself unimportable, either because\n  /// it's missing a requirement from \\p Requirements or because it's been\n  /// shadowed by another module.\n  unsigned IsUnimportable : 1;\n\n  /// Whether we tried and failed to load a module file for this module.\n  unsigned HasIncompatibleModuleFile : 1;\n\n  /// Whether this module is available in the current translation unit.\n  ///\n  /// If the module is missing headers or does not meet all requirements then\n  /// this bit will be 0.\n  unsigned IsAvailable : 1;\n\n  /// Whether this module was loaded from a module file.\n  unsigned IsFromModuleFile : 1;\n\n  /// Whether this is a framework module.\n  unsigned IsFramework : 1;\n\n  /// Whether this is an explicit submodule.\n  unsigned IsExplicit : 1;\n\n  /// Whether this is a \"system\" module (which assumes that all\n  /// headers in it are system headers).\n  unsigned IsSystem : 1;\n\n  /// Whether this is an 'extern \"C\"' module (which implicitly puts all\n  /// headers in it within an 'extern \"C\"' block, and allows the module to be\n  /// imported within such a block).\n  unsigned IsExternC : 1;\n\n  /// Whether this is an inferred submodule (module * { ... }).\n  unsigned IsInferred : 1;\n\n  /// Whether we should infer submodules for this module based on\n  /// the headers.\n  ///\n  /// Submodules can only be inferred for modules with an umbrella header.\n  unsigned InferSubmodules : 1;\n\n  /// Whether, when inferring submodules, the inferred submodules\n  /// should be explicit.\n  unsigned InferExplicitSubmodules : 1;\n\n  /// Whether, when inferring submodules, the inferr submodules should\n  /// export all modules they import (e.g., the equivalent of \"export *\").\n  unsigned InferExportWildcard : 1;\n\n  /// Whether the set of configuration macros is exhaustive.\n  ///\n  /// When the set of configuration macros is exhaustive, meaning\n  /// that no identifier not in this list should affect how the module is\n  /// built.\n  unsigned ConfigMacrosExhaustive : 1;\n\n  /// Whether files in this module can only include non-modular headers\n  /// and headers from used modules.\n  unsigned NoUndeclaredIncludes : 1;\n\n  /// Whether this module came from a \"private\" module map, found next\n  /// to a regular (public) module map.\n  unsigned ModuleMapIsPrivate : 1;\n\n  /// Describes the visibility of the various names within a\n  /// particular module.\n  enum NameVisibilityKind {\n    /// All of the names in this module are hidden.\n    Hidden,\n    /// All of the names in this module are visible.\n    AllVisible\n  };\n\n  /// The visibility of names within this particular module.\n  NameVisibilityKind NameVisibility;\n\n  /// The location of the inferred submodule.\n  SourceLocation InferredSubmoduleLoc;\n\n  /// The set of modules imported by this module, and on which this\n  /// module depends.\n  llvm::SmallSetVector<Module *, 2> Imports;\n\n  /// Describes an exported module.\n  ///\n  /// The pointer is the module being re-exported, while the bit will be true\n  /// to indicate that this is a wildcard export.\n  using ExportDecl = llvm::PointerIntPair<Module *, 1, bool>;\n\n  /// The set of export declarations.\n  SmallVector<ExportDecl, 2> Exports;\n\n  /// Describes an exported module that has not yet been resolved\n  /// (perhaps because the module it refers to has not yet been loaded).\n  struct UnresolvedExportDecl {\n    /// The location of the 'export' keyword in the module map file.\n    SourceLocation ExportLoc;\n\n    /// The name of the module.\n    ModuleId Id;\n\n    /// Whether this export declaration ends in a wildcard, indicating\n    /// that all of its submodules should be exported (rather than the named\n    /// module itself).\n    bool Wildcard;\n  };\n\n  /// The set of export declarations that have yet to be resolved.\n  SmallVector<UnresolvedExportDecl, 2> UnresolvedExports;\n\n  /// The directly used modules.\n  SmallVector<Module *, 2> DirectUses;\n\n  /// The set of use declarations that have yet to be resolved.\n  SmallVector<ModuleId, 2> UnresolvedDirectUses;\n\n  /// A library or framework to link against when an entity from this\n  /// module is used.\n  struct LinkLibrary {\n    LinkLibrary() = default;\n    LinkLibrary(const std::string &Library, bool IsFramework)\n        : Library(Library), IsFramework(IsFramework) {}\n\n    /// The library to link against.\n    ///\n    /// This will typically be a library or framework name, but can also\n    /// be an absolute path to the library or framework.\n    std::string Library;\n\n    /// Whether this is a framework rather than a library.\n    bool IsFramework = false;\n  };\n\n  /// The set of libraries or frameworks to link against when\n  /// an entity from this module is used.\n  llvm::SmallVector<LinkLibrary, 2> LinkLibraries;\n\n  /// Autolinking uses the framework name for linking purposes\n  /// when this is false and the export_as name otherwise.\n  bool UseExportAsModuleLinkName = false;\n\n  /// The set of \"configuration macros\", which are macros that\n  /// (intentionally) change how this module is built.\n  std::vector<std::string> ConfigMacros;\n\n  /// An unresolved conflict with another module.\n  struct UnresolvedConflict {\n    /// The (unresolved) module id.\n    ModuleId Id;\n\n    /// The message provided to the user when there is a conflict.\n    std::string Message;\n  };\n\n  /// The list of conflicts for which the module-id has not yet been\n  /// resolved.\n  std::vector<UnresolvedConflict> UnresolvedConflicts;\n\n  /// A conflict between two modules.\n  struct Conflict {\n    /// The module that this module conflicts with.\n    Module *Other;\n\n    /// The message provided to the user when there is a conflict.\n    std::string Message;\n  };\n\n  /// The list of conflicts.\n  std::vector<Conflict> Conflicts;\n\n  /// Construct a new module or submodule.\n  Module(StringRef Name, SourceLocation DefinitionLoc, Module *Parent,\n         bool IsFramework, bool IsExplicit, unsigned VisibilityID);\n\n  ~Module();\n\n  /// Determine whether this module has been declared unimportable.\n  bool isUnimportable() const { return IsUnimportable; }\n\n  /// Determine whether this module has been declared unimportable.\n  ///\n  /// \\param LangOpts The language options used for the current\n  /// translation unit.\n  ///\n  /// \\param Target The target options used for the current translation unit.\n  ///\n  /// \\param Req If this module is unimportable because of a missing\n  /// requirement, this parameter will be set to one of the requirements that\n  /// is not met for use of this module.\n  ///\n  /// \\param ShadowingModule If this module is unimportable because it is\n  /// shadowed, this parameter will be set to the shadowing module.\n  bool isUnimportable(const LangOptions &LangOpts, const TargetInfo &Target,\n                      Requirement &Req, Module *&ShadowingModule) const;\n\n  /// Determine whether this module is available for use within the\n  /// current translation unit.\n  bool isAvailable() const { return IsAvailable; }\n\n  /// Determine whether this module is available for use within the\n  /// current translation unit.\n  ///\n  /// \\param LangOpts The language options used for the current\n  /// translation unit.\n  ///\n  /// \\param Target The target options used for the current translation unit.\n  ///\n  /// \\param Req If this module is unavailable because of a missing requirement,\n  /// this parameter will be set to one of the requirements that is not met for\n  /// use of this module.\n  ///\n  /// \\param MissingHeader If this module is unavailable because of a missing\n  /// header, this parameter will be set to one of the missing headers.\n  ///\n  /// \\param ShadowingModule If this module is unavailable because it is\n  /// shadowed, this parameter will be set to the shadowing module.\n  bool isAvailable(const LangOptions &LangOpts,\n                   const TargetInfo &Target,\n                   Requirement &Req,\n                   UnresolvedHeaderDirective &MissingHeader,\n                   Module *&ShadowingModule) const;\n\n  /// Determine whether this module is a submodule.\n  bool isSubModule() const { return Parent != nullptr; }\n\n  /// Check if this module is a (possibly transitive) submodule of \\p Other.\n  ///\n  /// The 'A is a submodule of B' relation is a partial order based on the\n  /// the parent-child relationship between individual modules.\n  ///\n  /// Returns \\c false if \\p Other is \\c nullptr.\n  bool isSubModuleOf(const Module *Other) const;\n\n  /// Determine whether this module is a part of a framework,\n  /// either because it is a framework module or because it is a submodule\n  /// of a framework module.\n  bool isPartOfFramework() const {\n    for (const Module *Mod = this; Mod; Mod = Mod->Parent)\n      if (Mod->IsFramework)\n        return true;\n\n    return false;\n  }\n\n  /// Determine whether this module is a subframework of another\n  /// framework.\n  bool isSubFramework() const {\n    return IsFramework && Parent && Parent->isPartOfFramework();\n  }\n\n  /// Set the parent of this module. This should only be used if the parent\n  /// could not be set during module creation.\n  void setParent(Module *M) {\n    assert(!Parent);\n    Parent = M;\n    Parent->SubModuleIndex[Name] = Parent->SubModules.size();\n    Parent->SubModules.push_back(this);\n  }\n\n  /// Retrieve the full name of this module, including the path from\n  /// its top-level module.\n  /// \\param AllowStringLiterals If \\c true, components that might not be\n  ///        lexically valid as identifiers will be emitted as string literals.\n  std::string getFullModuleName(bool AllowStringLiterals = false) const;\n\n  /// Whether the full name of this module is equal to joining\n  /// \\p nameParts with \".\"s.\n  ///\n  /// This is more efficient than getFullModuleName().\n  bool fullModuleNameIs(ArrayRef<StringRef> nameParts) const;\n\n  /// Retrieve the top-level module for this (sub)module, which may\n  /// be this module.\n  Module *getTopLevelModule() {\n    return const_cast<Module *>(\n             const_cast<const Module *>(this)->getTopLevelModule());\n  }\n\n  /// Retrieve the top-level module for this (sub)module, which may\n  /// be this module.\n  const Module *getTopLevelModule() const;\n\n  /// Retrieve the name of the top-level module.\n  StringRef getTopLevelModuleName() const {\n    return getTopLevelModule()->Name;\n  }\n\n  /// The serialized AST file for this module, if one was created.\n  OptionalFileEntryRefDegradesToFileEntryPtr getASTFile() const {\n    return getTopLevelModule()->ASTFile;\n  }\n\n  /// Set the serialized AST file for the top-level module of this module.\n  void setASTFile(Optional<FileEntryRef> File) {\n    assert((!File || !getASTFile() || getASTFile() == File) &&\n           \"file path changed\");\n    getTopLevelModule()->ASTFile = File;\n  }\n\n  /// Retrieve the directory for which this module serves as the\n  /// umbrella.\n  DirectoryName getUmbrellaDir() const;\n\n  /// Retrieve the header that serves as the umbrella header for this\n  /// module.\n  Header getUmbrellaHeader() const {\n    if (auto *FE = Umbrella.dyn_cast<const FileEntry *>())\n      return Header{UmbrellaAsWritten, FE};\n    return Header{};\n  }\n\n  /// Determine whether this module has an umbrella directory that is\n  /// not based on an umbrella header.\n  bool hasUmbrellaDir() const {\n    return Umbrella && Umbrella.is<const DirectoryEntry *>();\n  }\n\n  /// Add a top-level header associated with this module.\n  void addTopHeader(const FileEntry *File);\n\n  /// Add a top-level header filename associated with this module.\n  void addTopHeaderFilename(StringRef Filename) {\n    TopHeaderNames.push_back(std::string(Filename));\n  }\n\n  /// The top-level headers associated with this module.\n  ArrayRef<const FileEntry *> getTopHeaders(FileManager &FileMgr);\n\n  /// Determine whether this module has declared its intention to\n  /// directly use another module.\n  bool directlyUses(const Module *Requested) const;\n\n  /// Add the given feature requirement to the list of features\n  /// required by this module.\n  ///\n  /// \\param Feature The feature that is required by this module (and\n  /// its submodules).\n  ///\n  /// \\param RequiredState The required state of this feature: \\c true\n  /// if it must be present, \\c false if it must be absent.\n  ///\n  /// \\param LangOpts The set of language options that will be used to\n  /// evaluate the availability of this feature.\n  ///\n  /// \\param Target The target options that will be used to evaluate the\n  /// availability of this feature.\n  void addRequirement(StringRef Feature, bool RequiredState,\n                      const LangOptions &LangOpts,\n                      const TargetInfo &Target);\n\n  /// Mark this module and all of its submodules as unavailable.\n  void markUnavailable(bool Unimportable);\n\n  /// Find the submodule with the given name.\n  ///\n  /// \\returns The submodule if found, or NULL otherwise.\n  Module *findSubmodule(StringRef Name) const;\n  Module *findOrInferSubmodule(StringRef Name);\n\n  /// Determine whether the specified module would be visible to\n  /// a lookup at the end of this module.\n  ///\n  /// FIXME: This may return incorrect results for (submodules of) the\n  /// module currently being built, if it's queried before we see all\n  /// of its imports.\n  bool isModuleVisible(const Module *M) const {\n    if (VisibleModulesCache.empty())\n      buildVisibleModulesCache();\n    return VisibleModulesCache.count(M);\n  }\n\n  unsigned getVisibilityID() const { return VisibilityID; }\n\n  using submodule_iterator = std::vector<Module *>::iterator;\n  using submodule_const_iterator = std::vector<Module *>::const_iterator;\n\n  submodule_iterator submodule_begin() { return SubModules.begin(); }\n  submodule_const_iterator submodule_begin() const {return SubModules.begin();}\n  submodule_iterator submodule_end()   { return SubModules.end(); }\n  submodule_const_iterator submodule_end() const { return SubModules.end(); }\n\n  llvm::iterator_range<submodule_iterator> submodules() {\n    return llvm::make_range(submodule_begin(), submodule_end());\n  }\n  llvm::iterator_range<submodule_const_iterator> submodules() const {\n    return llvm::make_range(submodule_begin(), submodule_end());\n  }\n\n  /// Appends this module's list of exported modules to \\p Exported.\n  ///\n  /// This provides a subset of immediately imported modules (the ones that are\n  /// directly exported), not the complete set of exported modules.\n  void getExportedModules(SmallVectorImpl<Module *> &Exported) const;\n\n  static StringRef getModuleInputBufferName() {\n    return \"<module-includes>\";\n  }\n\n  /// Print the module map for this module to the given stream.\n  void print(raw_ostream &OS, unsigned Indent = 0) const;\n\n  /// Dump the contents of this module to the given output stream.\n  void dump() const;\n\nprivate:\n  void buildVisibleModulesCache() const;\n};\n\n/// A set of visible modules.\nclass VisibleModuleSet {\npublic:\n  VisibleModuleSet() = default;\n  VisibleModuleSet(VisibleModuleSet &&O)\n      : ImportLocs(std::move(O.ImportLocs)), Generation(O.Generation ? 1 : 0) {\n    O.ImportLocs.clear();\n    ++O.Generation;\n  }\n\n  /// Move from another visible modules set. Guaranteed to leave the source\n  /// empty and bump the generation on both.\n  VisibleModuleSet &operator=(VisibleModuleSet &&O) {\n    ImportLocs = std::move(O.ImportLocs);\n    O.ImportLocs.clear();\n    ++O.Generation;\n    ++Generation;\n    return *this;\n  }\n\n  /// Get the current visibility generation. Incremented each time the\n  /// set of visible modules changes in any way.\n  unsigned getGeneration() const { return Generation; }\n\n  /// Determine whether a module is visible.\n  bool isVisible(const Module *M) const {\n    return getImportLoc(M).isValid();\n  }\n\n  /// Get the location at which the import of a module was triggered.\n  SourceLocation getImportLoc(const Module *M) const {\n    return M->getVisibilityID() < ImportLocs.size()\n               ? ImportLocs[M->getVisibilityID()]\n               : SourceLocation();\n  }\n\n  /// A callback to call when a module is made visible (directly or\n  /// indirectly) by a call to \\ref setVisible.\n  using VisibleCallback = llvm::function_ref<void(Module *M)>;\n\n  /// A callback to call when a module conflict is found. \\p Path\n  /// consists of a sequence of modules from the conflicting module to the one\n  /// made visible, where each was exported by the next.\n  using ConflictCallback =\n      llvm::function_ref<void(ArrayRef<Module *> Path, Module *Conflict,\n                         StringRef Message)>;\n\n  /// Make a specific module visible.\n  void setVisible(Module *M, SourceLocation Loc,\n                  VisibleCallback Vis = [](Module *) {},\n                  ConflictCallback Cb = [](ArrayRef<Module *>, Module *,\n                                           StringRef) {});\n\nprivate:\n  /// Import locations for each visible module. Indexed by the module's\n  /// VisibilityID.\n  std::vector<SourceLocation> ImportLocs;\n\n  /// Visibility generation, bumped every time the visibility state changes.\n  unsigned Generation = 0;\n};\n\n/// Abstracts clang modules and precompiled header files and holds\n/// everything needed to generate debug info for an imported module\n/// or PCH.\nclass ASTSourceDescriptor {\n  StringRef PCHModuleName;\n  StringRef Path;\n  StringRef ASTFile;\n  ASTFileSignature Signature;\n  Module *ClangModule = nullptr;\n\npublic:\n  ASTSourceDescriptor() = default;\n  ASTSourceDescriptor(StringRef Name, StringRef Path, StringRef ASTFile,\n                      ASTFileSignature Signature)\n      : PCHModuleName(std::move(Name)), Path(std::move(Path)),\n        ASTFile(std::move(ASTFile)), Signature(Signature) {}\n  ASTSourceDescriptor(Module &M);\n\n  std::string getModuleName() const;\n  StringRef getPath() const { return Path; }\n  StringRef getASTFile() const { return ASTFile; }\n  ASTFileSignature getSignature() const { return Signature; }\n  Module *getModuleOrNull() const { return ClangModule; }\n};\n\n\n} // namespace clang\n\n#endif // LLVM_CLANG_BASIC_MODULE_H\n"}, "65": {"id": 65, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceManager.h", "content": "//===- SourceManager.h - Track and cache source files -----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the SourceManager interface.\n///\n/// There are three different types of locations in a %file: a spelling\n/// location, an expansion location, and a presumed location.\n///\n/// Given an example of:\n/// \\code\n/// #define min(x, y) x < y ? x : y\n/// \\endcode\n///\n/// and then later on a use of min:\n/// \\code\n/// #line 17\n/// return min(a, b);\n/// \\endcode\n///\n/// The expansion location is the line in the source code where the macro\n/// was expanded (the return statement), the spelling location is the\n/// location in the source where the macro was originally defined,\n/// and the presumed location is where the line directive states that\n/// the line is 17, or any other line.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_SOURCEMANAGER_H\n#define LLVM_CLANG_BASIC_SOURCEMANAGER_H\n\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/FileEntry.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/BitVector.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include <cassert>\n#include <cstddef>\n#include <map>\n#include <memory>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace clang {\n\nclass ASTReader;\nclass ASTWriter;\nclass FileManager;\nclass LineTableInfo;\nclass SourceManager;\n\n/// Public enums and private classes that are part of the\n/// SourceManager implementation.\nnamespace SrcMgr {\n\n/// Indicates whether a file or directory holds normal user code,\n/// system code, or system code which is implicitly 'extern \"C\"' in C++ mode.\n///\n/// Entire directories can be tagged with this (this is maintained by\n/// DirectoryLookup and friends) as can specific FileInfos when a \\#pragma\n/// system_header is seen or in various other cases.\n///\nenum CharacteristicKind {\n  C_User,\n  C_System,\n  C_ExternCSystem,\n  C_User_ModuleMap,\n  C_System_ModuleMap\n};\n\n/// Determine whether a file / directory characteristic is for system code.\ninline bool isSystem(CharacteristicKind CK) {\n  return CK != C_User && CK != C_User_ModuleMap;\n}\n\n/// Determine whether a file characteristic is for a module map.\ninline bool isModuleMap(CharacteristicKind CK) {\n  return CK == C_User_ModuleMap || CK == C_System_ModuleMap;\n}\n\n/// Mapping of line offsets into a source file. This does not own the storage\n/// for the line numbers.\nclass LineOffsetMapping {\npublic:\n  explicit operator bool() const { return Storage; }\n  unsigned size() const {\n    assert(Storage);\n    return Storage[0];\n  }\n  ArrayRef<unsigned> getLines() const {\n    assert(Storage);\n    return ArrayRef<unsigned>(Storage + 1, Storage + 1 + size());\n  }\n  const unsigned *begin() const { return getLines().begin(); }\n  const unsigned *end() const { return getLines().end(); }\n  const unsigned &operator[](int I) const { return getLines()[I]; }\n\n  static LineOffsetMapping get(llvm::MemoryBufferRef Buffer,\n                               llvm::BumpPtrAllocator &Alloc);\n\n  LineOffsetMapping() = default;\n  LineOffsetMapping(ArrayRef<unsigned> LineOffsets,\n                    llvm::BumpPtrAllocator &Alloc);\n\nprivate:\n  /// First element is the size, followed by elements at off-by-one indexes.\n  unsigned *Storage = nullptr;\n};\n\n/// One instance of this struct is kept for every file loaded or used.\n///\n/// This object owns the MemoryBuffer object.\nclass alignas(8) ContentCache {\n  /// The actual buffer containing the characters from the input\n  /// file.\n  mutable std::unique_ptr<llvm::MemoryBuffer> Buffer;\n\npublic:\n  /// Reference to the file entry representing this ContentCache.\n  ///\n  /// This reference does not own the FileEntry object.\n  ///\n  /// It is possible for this to be NULL if the ContentCache encapsulates\n  /// an imaginary text buffer.\n  ///\n  /// FIXME: Turn this into a FileEntryRef and remove Filename.\n  const FileEntry *OrigEntry;\n\n  /// References the file which the contents were actually loaded from.\n  ///\n  /// Can be different from 'Entry' if we overridden the contents of one file\n  /// with the contents of another file.\n  const FileEntry *ContentsEntry;\n\n  /// The filename that is used to access OrigEntry.\n  ///\n  /// FIXME: Remove this once OrigEntry is a FileEntryRef with a stable name.\n  StringRef Filename;\n\n  /// A bump pointer allocated array of offsets for each source line.\n  ///\n  /// This is lazily computed.  The lines are owned by the SourceManager\n  /// BumpPointerAllocator object.\n  mutable LineOffsetMapping SourceLineCache;\n\n  /// Indicates whether the buffer itself was provided to override\n  /// the actual file contents.\n  ///\n  /// When true, the original entry may be a virtual file that does not\n  /// exist.\n  unsigned BufferOverridden : 1;\n\n  /// True if this content cache was initially created for a source file\n  /// considered to be volatile (likely to change between stat and open).\n  unsigned IsFileVolatile : 1;\n\n  /// True if this file may be transient, that is, if it might not\n  /// exist at some later point in time when this content entry is used,\n  /// after serialization and deserialization.\n  unsigned IsTransient : 1;\n\n  mutable unsigned IsBufferInvalid : 1;\n\n  ContentCache(const FileEntry *Ent = nullptr) : ContentCache(Ent, Ent) {}\n\n  ContentCache(const FileEntry *Ent, const FileEntry *contentEnt)\n      : OrigEntry(Ent), ContentsEntry(contentEnt), BufferOverridden(false),\n        IsFileVolatile(false), IsTransient(false), IsBufferInvalid(false) {}\n\n  /// The copy ctor does not allow copies where source object has either\n  /// a non-NULL Buffer or SourceLineCache.  Ownership of allocated memory\n  /// is not transferred, so this is a logical error.\n  ContentCache(const ContentCache &RHS)\n      : BufferOverridden(false), IsFileVolatile(false), IsTransient(false),\n        IsBufferInvalid(false) {\n    OrigEntry = RHS.OrigEntry;\n    ContentsEntry = RHS.ContentsEntry;\n\n    assert(!RHS.Buffer && !RHS.SourceLineCache &&\n           \"Passed ContentCache object cannot own a buffer.\");\n  }\n\n  ContentCache &operator=(const ContentCache &RHS) = delete;\n\n  /// Returns the memory buffer for the associated content.\n  ///\n  /// \\param Diag Object through which diagnostics will be emitted if the\n  ///   buffer cannot be retrieved.\n  ///\n  /// \\param Loc If specified, is the location that invalid file diagnostics\n  ///   will be emitted at.\n  llvm::Optional<llvm::MemoryBufferRef>\n  getBufferOrNone(DiagnosticsEngine &Diag, FileManager &FM,\n                  SourceLocation Loc = SourceLocation()) const;\n\n  /// Returns the size of the content encapsulated by this\n  /// ContentCache.\n  ///\n  /// This can be the size of the source file or the size of an\n  /// arbitrary scratch buffer.  If the ContentCache encapsulates a source\n  /// file this size is retrieved from the file's FileEntry.\n  unsigned getSize() const;\n\n  /// Returns the number of bytes actually mapped for this\n  /// ContentCache.\n  ///\n  /// This can be 0 if the MemBuffer was not actually expanded.\n  unsigned getSizeBytesMapped() const;\n\n  /// Returns the kind of memory used to back the memory buffer for\n  /// this content cache.  This is used for performance analysis.\n  llvm::MemoryBuffer::BufferKind getMemoryBufferKind() const;\n\n  /// Return the buffer, only if it has been loaded.\n  llvm::Optional<llvm::MemoryBufferRef> getBufferIfLoaded() const {\n    if (Buffer)\n      return Buffer->getMemBufferRef();\n    return None;\n  }\n\n  /// Return a StringRef to the source buffer data, only if it has already\n  /// been loaded.\n  llvm::Optional<StringRef> getBufferDataIfLoaded() const {\n    if (Buffer)\n      return Buffer->getBuffer();\n    return None;\n  }\n\n  /// Set the buffer.\n  void setBuffer(std::unique_ptr<llvm::MemoryBuffer> B) {\n    IsBufferInvalid = false;\n    Buffer = std::move(B);\n  }\n\n  /// Set the buffer to one that's not owned (or to nullptr).\n  ///\n  /// \\pre Buffer cannot already be set.\n  void setUnownedBuffer(llvm::Optional<llvm::MemoryBufferRef> B) {\n    assert(!Buffer && \"Expected to be called right after construction\");\n    if (B)\n      setBuffer(llvm::MemoryBuffer::getMemBuffer(*B));\n  }\n\n  // If BufStr has an invalid BOM, returns the BOM name; otherwise, returns\n  // nullptr\n  static const char *getInvalidBOM(StringRef BufStr);\n};\n\n// Assert that the \\c ContentCache objects will always be 8-byte aligned so\n// that we can pack 3 bits of integer into pointers to such objects.\nstatic_assert(alignof(ContentCache) >= 8,\n              \"ContentCache must be 8-byte aligned.\");\n\n/// Information about a FileID, basically just the logical file\n/// that it represents and include stack information.\n///\n/// Each FileInfo has include stack information, indicating where it came\n/// from. This information encodes the \\#include chain that a token was\n/// expanded from. The main include file has an invalid IncludeLoc.\n///\n/// FileInfo should not grow larger than ExpansionInfo. Doing so will\n/// cause memory to bloat in compilations with many unloaded macro\n/// expansions, since the two data structurs are stored in a union in\n/// SLocEntry. Extra fields should instead go in \"ContentCache *\", which\n/// stores file contents and other bits on the side.\n///\nclass FileInfo {\n  friend class clang::SourceManager;\n  friend class clang::ASTWriter;\n  friend class clang::ASTReader;\n\n  /// The location of the \\#include that brought in this file.\n  ///\n  /// This is an invalid SLOC for the main file (top of the \\#include chain).\n  SourceLocation IncludeLoc;\n\n  /// Number of FileIDs (files and macros) that were created during\n  /// preprocessing of this \\#include, including this SLocEntry.\n  ///\n  /// Zero means the preprocessor didn't provide such info for this SLocEntry.\n  unsigned NumCreatedFIDs : 31;\n\n  /// Whether this FileInfo has any \\#line directives.\n  unsigned HasLineDirectives : 1;\n\n  /// The content cache and the characteristic of the file.\n  llvm::PointerIntPair<const ContentCache *, 3, CharacteristicKind>\n      ContentAndKind;\n\npublic:\n  /// Return a FileInfo object.\n  static FileInfo get(SourceLocation IL, ContentCache &Con,\n                      CharacteristicKind FileCharacter, StringRef Filename) {\n    FileInfo X;\n    X.IncludeLoc = IL;\n    X.NumCreatedFIDs = 0;\n    X.HasLineDirectives = false;\n    X.ContentAndKind.setPointer(&Con);\n    X.ContentAndKind.setInt(FileCharacter);\n    Con.Filename = Filename;\n    return X;\n  }\n\n  SourceLocation getIncludeLoc() const {\n    return IncludeLoc;\n  }\n\n  const ContentCache &getContentCache() const {\n    return *ContentAndKind.getPointer();\n  }\n\n  /// Return whether this is a system header or not.\n  CharacteristicKind getFileCharacteristic() const {\n    return ContentAndKind.getInt();\n  }\n\n  /// Return true if this FileID has \\#line directives in it.\n  bool hasLineDirectives() const { return HasLineDirectives; }\n\n  /// Set the flag that indicates that this FileID has\n  /// line table entries associated with it.\n  void setHasLineDirectives() { HasLineDirectives = true; }\n\n  /// Returns the name of the file that was used when the file was loaded from\n  /// the underlying file system.\n  StringRef getName() const { return getContentCache().Filename; }\n};\n\n/// Each ExpansionInfo encodes the expansion location - where\n/// the token was ultimately expanded, and the SpellingLoc - where the actual\n/// character data for the token came from.\nclass ExpansionInfo {\n  // Really these are all SourceLocations.\n\n  /// Where the spelling for the token can be found.\n  SourceLocation SpellingLoc;\n\n  /// In a macro expansion, ExpansionLocStart and ExpansionLocEnd\n  /// indicate the start and end of the expansion. In object-like macros,\n  /// they will be the same. In a function-like macro expansion, the start\n  /// will be the identifier and the end will be the ')'. Finally, in\n  /// macro-argument instantiations, the end will be 'SourceLocation()', an\n  /// invalid location.\n  SourceLocation ExpansionLocStart, ExpansionLocEnd;\n\n  /// Whether the expansion range is a token range.\n  bool ExpansionIsTokenRange;\n\npublic:\n  SourceLocation getSpellingLoc() const {\n    return SpellingLoc.isInvalid() ? getExpansionLocStart() : SpellingLoc;\n  }\n\n  SourceLocation getExpansionLocStart() const {\n    return ExpansionLocStart;\n  }\n\n  SourceLocation getExpansionLocEnd() const {\n    return ExpansionLocEnd.isInvalid() ? getExpansionLocStart()\n                                       : ExpansionLocEnd;\n  }\n\n  bool isExpansionTokenRange() const { return ExpansionIsTokenRange; }\n\n  CharSourceRange getExpansionLocRange() const {\n    return CharSourceRange(\n        SourceRange(getExpansionLocStart(), getExpansionLocEnd()),\n        isExpansionTokenRange());\n  }\n\n  bool isMacroArgExpansion() const {\n    // Note that this needs to return false for default constructed objects.\n    return getExpansionLocStart().isValid() && ExpansionLocEnd.isInvalid();\n  }\n\n  bool isMacroBodyExpansion() const {\n    return getExpansionLocStart().isValid() && ExpansionLocEnd.isValid();\n  }\n\n  bool isFunctionMacroExpansion() const {\n    return getExpansionLocStart().isValid() &&\n           getExpansionLocStart() != getExpansionLocEnd();\n  }\n\n  /// Return a ExpansionInfo for an expansion.\n  ///\n  /// Start and End specify the expansion range (where the macro is\n  /// expanded), and SpellingLoc specifies the spelling location (where\n  /// the characters from the token come from). All three can refer to\n  /// normal File SLocs or expansion locations.\n  static ExpansionInfo create(SourceLocation SpellingLoc, SourceLocation Start,\n                              SourceLocation End,\n                              bool ExpansionIsTokenRange = true) {\n    ExpansionInfo X;\n    X.SpellingLoc = SpellingLoc;\n    X.ExpansionLocStart = Start;\n    X.ExpansionLocEnd = End;\n    X.ExpansionIsTokenRange = ExpansionIsTokenRange;\n    return X;\n  }\n\n  /// Return a special ExpansionInfo for the expansion of\n  /// a macro argument into a function-like macro's body.\n  ///\n  /// ExpansionLoc specifies the expansion location (where the macro is\n  /// expanded). This doesn't need to be a range because a macro is always\n  /// expanded at a macro parameter reference, and macro parameters are\n  /// always exactly one token. SpellingLoc specifies the spelling location\n  /// (where the characters from the token come from). ExpansionLoc and\n  /// SpellingLoc can both refer to normal File SLocs or expansion locations.\n  ///\n  /// Given the code:\n  /// \\code\n  ///   #define F(x) f(x)\n  ///   F(42);\n  /// \\endcode\n  ///\n  /// When expanding '\\c F(42)', the '\\c x' would call this with an\n  /// SpellingLoc pointing at '\\c 42' and an ExpansionLoc pointing at its\n  /// location in the definition of '\\c F'.\n  static ExpansionInfo createForMacroArg(SourceLocation SpellingLoc,\n                                         SourceLocation ExpansionLoc) {\n    // We store an intentionally invalid source location for the end of the\n    // expansion range to mark that this is a macro argument location rather\n    // than a normal one.\n    return create(SpellingLoc, ExpansionLoc, SourceLocation());\n  }\n\n  /// Return a special ExpansionInfo representing a token that ends\n  /// prematurely. This is used to model a '>>' token that has been split\n  /// into '>' tokens and similar cases. Unlike for the other forms of\n  /// expansion, the expansion range in this case is a character range, not\n  /// a token range.\n  static ExpansionInfo createForTokenSplit(SourceLocation SpellingLoc,\n                                           SourceLocation Start,\n                                           SourceLocation End) {\n    return create(SpellingLoc, Start, End, false);\n  }\n};\n\n// Assert that the \\c FileInfo objects are no bigger than \\c ExpansionInfo\n// objects. This controls the size of \\c SLocEntry, of which we have one for\n// each macro expansion. The number of (unloaded) macro expansions can be\n// very large. Any other fields needed in FileInfo should go in ContentCache.\nstatic_assert(sizeof(FileInfo) <= sizeof(ExpansionInfo),\n              \"FileInfo must be no larger than ExpansionInfo.\");\n\n/// This is a discriminated union of FileInfo and ExpansionInfo.\n///\n/// SourceManager keeps an array of these objects, and they are uniquely\n/// identified by the FileID datatype.\nclass SLocEntry {\n  unsigned Offset : 31;\n  unsigned IsExpansion : 1;\n  union {\n    FileInfo File;\n    ExpansionInfo Expansion;\n  };\n\npublic:\n  SLocEntry() : Offset(), IsExpansion(), File() {}\n\n  unsigned getOffset() const { return Offset; }\n\n  bool isExpansion() const { return IsExpansion; }\n  bool isFile() const { return !isExpansion(); }\n\n  const FileInfo &getFile() const {\n    assert(isFile() && \"Not a file SLocEntry!\");\n    return File;\n  }\n\n  const ExpansionInfo &getExpansion() const {\n    assert(isExpansion() && \"Not a macro expansion SLocEntry!\");\n    return Expansion;\n  }\n\n  static SLocEntry get(unsigned Offset, const FileInfo &FI) {\n    assert(!(Offset & (1u << 31)) && \"Offset is too large\");\n    SLocEntry E;\n    E.Offset = Offset;\n    E.IsExpansion = false;\n    E.File = FI;\n    return E;\n  }\n\n  static SLocEntry get(unsigned Offset, const ExpansionInfo &Expansion) {\n    assert(!(Offset & (1u << 31)) && \"Offset is too large\");\n    SLocEntry E;\n    E.Offset = Offset;\n    E.IsExpansion = true;\n    new (&E.Expansion) ExpansionInfo(Expansion);\n    return E;\n  }\n};\n\n} // namespace SrcMgr\n\n/// External source of source location entries.\nclass ExternalSLocEntrySource {\npublic:\n  virtual ~ExternalSLocEntrySource();\n\n  /// Read the source location entry with index ID, which will always be\n  /// less than -1.\n  ///\n  /// \\returns true if an error occurred that prevented the source-location\n  /// entry from being loaded.\n  virtual bool ReadSLocEntry(int ID) = 0;\n\n  /// Retrieve the module import location and name for the given ID, if\n  /// in fact it was loaded from a module (rather than, say, a precompiled\n  /// header).\n  virtual std::pair<SourceLocation, StringRef> getModuleImportLoc(int ID) = 0;\n};\n\n/// Holds the cache used by isBeforeInTranslationUnit.\n///\n/// The cache structure is complex enough to be worth breaking out of\n/// SourceManager.\nclass InBeforeInTUCacheEntry {\n  /// The FileID's of the cached query.\n  ///\n  /// If these match up with a subsequent query, the result can be reused.\n  FileID LQueryFID, RQueryFID;\n\n  /// True if LQueryFID was created before RQueryFID.\n  ///\n  /// This is used to compare macro expansion locations.\n  bool IsLQFIDBeforeRQFID;\n\n  /// The file found in common between the two \\#include traces, i.e.,\n  /// the nearest common ancestor of the \\#include tree.\n  FileID CommonFID;\n\n  /// The offset of the previous query in CommonFID.\n  ///\n  /// Usually, this represents the location of the \\#include for QueryFID, but\n  /// if LQueryFID is a parent of RQueryFID (or vice versa) then these can be a\n  /// random token in the parent.\n  unsigned LCommonOffset, RCommonOffset;\n\npublic:\n  /// Return true if the currently cached values match up with\n  /// the specified LHS/RHS query.\n  ///\n  /// If not, we can't use the cache.\n  bool isCacheValid(FileID LHS, FileID RHS) const {\n    return LQueryFID == LHS && RQueryFID == RHS;\n  }\n\n  /// If the cache is valid, compute the result given the\n  /// specified offsets in the LHS/RHS FileID's.\n  bool getCachedResult(unsigned LOffset, unsigned ROffset) const {\n    // If one of the query files is the common file, use the offset.  Otherwise,\n    // use the #include loc in the common file.\n    if (LQueryFID != CommonFID) LOffset = LCommonOffset;\n    if (RQueryFID != CommonFID) ROffset = RCommonOffset;\n\n    // It is common for multiple macro expansions to be \"included\" from the same\n    // location (expansion location), in which case use the order of the FileIDs\n    // to determine which came first. This will also take care the case where\n    // one of the locations points at the inclusion/expansion point of the other\n    // in which case its FileID will come before the other.\n    if (LOffset == ROffset)\n      return IsLQFIDBeforeRQFID;\n\n    return LOffset < ROffset;\n  }\n\n  /// Set up a new query.\n  void setQueryFIDs(FileID LHS, FileID RHS, bool isLFIDBeforeRFID) {\n    assert(LHS != RHS);\n    LQueryFID = LHS;\n    RQueryFID = RHS;\n    IsLQFIDBeforeRQFID = isLFIDBeforeRFID;\n  }\n\n  void clear() {\n    LQueryFID = RQueryFID = FileID();\n    IsLQFIDBeforeRQFID = false;\n  }\n\n  void setCommonLoc(FileID commonFID, unsigned lCommonOffset,\n                    unsigned rCommonOffset) {\n    CommonFID = commonFID;\n    LCommonOffset = lCommonOffset;\n    RCommonOffset = rCommonOffset;\n  }\n};\n\n/// The stack used when building modules on demand, which is used\n/// to provide a link between the source managers of the different compiler\n/// instances.\nusing ModuleBuildStack = ArrayRef<std::pair<std::string, FullSourceLoc>>;\n\n/// This class handles loading and caching of source files into memory.\n///\n/// This object owns the MemoryBuffer objects for all of the loaded\n/// files and assigns unique FileID's for each unique \\#include chain.\n///\n/// The SourceManager can be queried for information about SourceLocation\n/// objects, turning them into either spelling or expansion locations. Spelling\n/// locations represent where the bytes corresponding to a token came from and\n/// expansion locations represent where the location is in the user's view. In\n/// the case of a macro expansion, for example, the spelling location indicates\n/// where the expanded token came from and the expansion location specifies\n/// where it was expanded.\nclass SourceManager : public RefCountedBase<SourceManager> {\n  /// DiagnosticsEngine object.\n  DiagnosticsEngine &Diag;\n\n  FileManager &FileMgr;\n\n  mutable llvm::BumpPtrAllocator ContentCacheAlloc;\n\n  /// Memoized information about all of the files tracked by this\n  /// SourceManager.\n  ///\n  /// This map allows us to merge ContentCache entries based\n  /// on their FileEntry*.  All ContentCache objects will thus have unique,\n  /// non-null, FileEntry pointers.\n  llvm::DenseMap<const FileEntry*, SrcMgr::ContentCache*> FileInfos;\n\n  /// True if the ContentCache for files that are overridden by other\n  /// files, should report the original file name. Defaults to true.\n  bool OverridenFilesKeepOriginalName = true;\n\n  /// True if non-system source files should be treated as volatile\n  /// (likely to change while trying to use them). Defaults to false.\n  bool UserFilesAreVolatile;\n\n  /// True if all files read during this compilation should be treated\n  /// as transient (may not be present in later compilations using a module\n  /// file created from this compilation). Defaults to false.\n  bool FilesAreTransient = false;\n\n  struct OverriddenFilesInfoTy {\n    /// Files that have been overridden with the contents from another\n    /// file.\n    llvm::DenseMap<const FileEntry *, const FileEntry *> OverriddenFiles;\n\n    /// Files that were overridden with a memory buffer.\n    llvm::DenseSet<const FileEntry *> OverriddenFilesWithBuffer;\n  };\n\n  /// Lazily create the object keeping overridden files info, since\n  /// it is uncommonly used.\n  std::unique_ptr<OverriddenFilesInfoTy> OverriddenFilesInfo;\n\n  OverriddenFilesInfoTy &getOverriddenFilesInfo() {\n    if (!OverriddenFilesInfo)\n      OverriddenFilesInfo.reset(new OverriddenFilesInfoTy);\n    return *OverriddenFilesInfo;\n  }\n\n  /// Information about various memory buffers that we have read in.\n  ///\n  /// All FileEntry* within the stored ContentCache objects are NULL,\n  /// as they do not refer to a file.\n  std::vector<SrcMgr::ContentCache*> MemBufferInfos;\n\n  /// The table of SLocEntries that are local to this module.\n  ///\n  /// Positive FileIDs are indexes into this table. Entry 0 indicates an invalid\n  /// expansion.\n  SmallVector<SrcMgr::SLocEntry, 0> LocalSLocEntryTable;\n\n  /// The table of SLocEntries that are loaded from other modules.\n  ///\n  /// Negative FileIDs are indexes into this table. To get from ID to an index,\n  /// use (-ID - 2).\n  SmallVector<SrcMgr::SLocEntry, 0> LoadedSLocEntryTable;\n\n  /// The starting offset of the next local SLocEntry.\n  ///\n  /// This is LocalSLocEntryTable.back().Offset + the size of that entry.\n  unsigned NextLocalOffset;\n\n  /// The starting offset of the latest batch of loaded SLocEntries.\n  ///\n  /// This is LoadedSLocEntryTable.back().Offset, except that that entry might\n  /// not have been loaded, so that value would be unknown.\n  unsigned CurrentLoadedOffset;\n\n  /// The highest possible offset is 2^31-1, so CurrentLoadedOffset\n  /// starts at 2^31.\n  static const unsigned MaxLoadedOffset = 1U << 31U;\n\n  /// A bitmap that indicates whether the entries of LoadedSLocEntryTable\n  /// have already been loaded from the external source.\n  ///\n  /// Same indexing as LoadedSLocEntryTable.\n  llvm::BitVector SLocEntryLoaded;\n\n  /// An external source for source location entries.\n  ExternalSLocEntrySource *ExternalSLocEntries = nullptr;\n\n  /// A one-entry cache to speed up getFileID.\n  ///\n  /// LastFileIDLookup records the last FileID looked up or created, because it\n  /// is very common to look up many tokens from the same file.\n  mutable FileID LastFileIDLookup;\n\n  /// Holds information for \\#line directives.\n  ///\n  /// This is referenced by indices from SLocEntryTable.\n  std::unique_ptr<LineTableInfo> LineTable;\n\n  /// These ivars serve as a cache used in the getLineNumber\n  /// method which is used to speedup getLineNumber calls to nearby locations.\n  mutable FileID LastLineNoFileIDQuery;\n  mutable const SrcMgr::ContentCache *LastLineNoContentCache;\n  mutable unsigned LastLineNoFilePos;\n  mutable unsigned LastLineNoResult;\n\n  /// The file ID for the main source file of the translation unit.\n  FileID MainFileID;\n\n  /// The file ID for the precompiled preamble there is one.\n  FileID PreambleFileID;\n\n  // Statistics for -print-stats.\n  mutable unsigned NumLinearScans = 0;\n  mutable unsigned NumBinaryProbes = 0;\n\n  /// Associates a FileID with its \"included/expanded in\" decomposed\n  /// location.\n  ///\n  /// Used to cache results from and speed-up \\c getDecomposedIncludedLoc\n  /// function.\n  mutable llvm::DenseMap<FileID, std::pair<FileID, unsigned>> IncludedLocMap;\n\n  /// The key value into the IsBeforeInTUCache table.\n  using IsBeforeInTUCacheKey = std::pair<FileID, FileID>;\n\n  /// The IsBeforeInTranslationUnitCache is a mapping from FileID pairs\n  /// to cache results.\n  using InBeforeInTUCache =\n      llvm::DenseMap<IsBeforeInTUCacheKey, InBeforeInTUCacheEntry>;\n\n  /// Cache results for the isBeforeInTranslationUnit method.\n  mutable InBeforeInTUCache IBTUCache;\n  mutable InBeforeInTUCacheEntry IBTUCacheOverflow;\n\n  /// Return the cache entry for comparing the given file IDs\n  /// for isBeforeInTranslationUnit.\n  InBeforeInTUCacheEntry &getInBeforeInTUCache(FileID LFID, FileID RFID) const;\n\n  // Cache for the \"fake\" buffer used for error-recovery purposes.\n  mutable std::unique_ptr<llvm::MemoryBuffer> FakeBufferForRecovery;\n\n  mutable std::unique_ptr<SrcMgr::ContentCache> FakeContentCacheForRecovery;\n\n  mutable std::unique_ptr<SrcMgr::SLocEntry> FakeSLocEntryForRecovery;\n\n  /// Lazily computed map of macro argument chunks to their expanded\n  /// source location.\n  using MacroArgsMap = std::map<unsigned, SourceLocation>;\n\n  mutable llvm::DenseMap<FileID, std::unique_ptr<MacroArgsMap>>\n      MacroArgsCacheMap;\n\n  /// The stack of modules being built, which is used to detect\n  /// cycles in the module dependency graph as modules are being built, as\n  /// well as to describe why we're rebuilding a particular module.\n  ///\n  /// There is no way to set this value from the command line. If we ever need\n  /// to do so (e.g., if on-demand module construction moves out-of-process),\n  /// we can add a cc1-level option to do so.\n  SmallVector<std::pair<std::string, FullSourceLoc>, 2> StoredModuleBuildStack;\n\npublic:\n  SourceManager(DiagnosticsEngine &Diag, FileManager &FileMgr,\n                bool UserFilesAreVolatile = false);\n  explicit SourceManager(const SourceManager &) = delete;\n  SourceManager &operator=(const SourceManager &) = delete;\n  ~SourceManager();\n\n  void clearIDTables();\n\n  /// Initialize this source manager suitably to replay the compilation\n  /// described by \\p Old. Requires that \\p Old outlive \\p *this.\n  void initializeForReplay(const SourceManager &Old);\n\n  DiagnosticsEngine &getDiagnostics() const { return Diag; }\n\n  FileManager &getFileManager() const { return FileMgr; }\n\n  /// Set true if the SourceManager should report the original file name\n  /// for contents of files that were overridden by other files. Defaults to\n  /// true.\n  void setOverridenFilesKeepOriginalName(bool value) {\n    OverridenFilesKeepOriginalName = value;\n  }\n\n  /// True if non-system source files should be treated as volatile\n  /// (likely to change while trying to use them).\n  bool userFilesAreVolatile() const { return UserFilesAreVolatile; }\n\n  /// Retrieve the module build stack.\n  ModuleBuildStack getModuleBuildStack() const {\n    return StoredModuleBuildStack;\n  }\n\n  /// Set the module build stack.\n  void setModuleBuildStack(ModuleBuildStack stack) {\n    StoredModuleBuildStack.clear();\n    StoredModuleBuildStack.append(stack.begin(), stack.end());\n  }\n\n  /// Push an entry to the module build stack.\n  void pushModuleBuildStack(StringRef moduleName, FullSourceLoc importLoc) {\n    StoredModuleBuildStack.push_back(std::make_pair(moduleName.str(),importLoc));\n  }\n\n  //===--------------------------------------------------------------------===//\n  // MainFileID creation and querying methods.\n  //===--------------------------------------------------------------------===//\n\n  /// Returns the FileID of the main source file.\n  FileID getMainFileID() const { return MainFileID; }\n\n  /// Set the file ID for the main source file.\n  void setMainFileID(FileID FID) {\n    MainFileID = FID;\n  }\n\n  /// Returns true when the given FileEntry corresponds to the main file.\n  ///\n  /// The main file should be set prior to calling this function.\n  bool isMainFile(const FileEntry &SourceFile);\n\n  /// Set the file ID for the precompiled preamble.\n  void setPreambleFileID(FileID Preamble) {\n    assert(PreambleFileID.isInvalid() && \"PreambleFileID already set!\");\n    PreambleFileID = Preamble;\n  }\n\n  /// Get the file ID for the precompiled preamble if there is one.\n  FileID getPreambleFileID() const { return PreambleFileID; }\n\n  //===--------------------------------------------------------------------===//\n  // Methods to create new FileID's and macro expansions.\n  //===--------------------------------------------------------------------===//\n\n  /// Create a new FileID that represents the specified file\n  /// being \\#included from the specified IncludePosition.\n  ///\n  /// This translates NULL into standard input.\n  FileID createFileID(const FileEntry *SourceFile, SourceLocation IncludePos,\n                      SrcMgr::CharacteristicKind FileCharacter,\n                      int LoadedID = 0, unsigned LoadedOffset = 0);\n\n  FileID createFileID(FileEntryRef SourceFile, SourceLocation IncludePos,\n                      SrcMgr::CharacteristicKind FileCharacter,\n                      int LoadedID = 0, unsigned LoadedOffset = 0);\n\n  /// Create a new FileID that represents the specified memory buffer.\n  ///\n  /// This does no caching of the buffer and takes ownership of the\n  /// MemoryBuffer, so only pass a MemoryBuffer to this once.\n  FileID createFileID(std::unique_ptr<llvm::MemoryBuffer> Buffer,\n                      SrcMgr::CharacteristicKind FileCharacter = SrcMgr::C_User,\n                      int LoadedID = 0, unsigned LoadedOffset = 0,\n                      SourceLocation IncludeLoc = SourceLocation());\n\n  /// Create a new FileID that represents the specified memory buffer.\n  ///\n  /// This does not take ownership of the MemoryBuffer. The memory buffer must\n  /// outlive the SourceManager.\n  FileID createFileID(const llvm::MemoryBufferRef &Buffer,\n                      SrcMgr::CharacteristicKind FileCharacter = SrcMgr::C_User,\n                      int LoadedID = 0, unsigned LoadedOffset = 0,\n                      SourceLocation IncludeLoc = SourceLocation());\n\n  /// Get the FileID for \\p SourceFile if it exists. Otherwise, create a\n  /// new FileID for the \\p SourceFile.\n  FileID getOrCreateFileID(const FileEntry *SourceFile,\n                           SrcMgr::CharacteristicKind FileCharacter);\n\n  /// Return a new SourceLocation that encodes the\n  /// fact that a token from SpellingLoc should actually be referenced from\n  /// ExpansionLoc, and that it represents the expansion of a macro argument\n  /// into the function-like macro body.\n  SourceLocation createMacroArgExpansionLoc(SourceLocation Loc,\n                                            SourceLocation ExpansionLoc,\n                                            unsigned TokLength);\n\n  /// Return a new SourceLocation that encodes the fact\n  /// that a token from SpellingLoc should actually be referenced from\n  /// ExpansionLoc.\n  SourceLocation createExpansionLoc(SourceLocation Loc,\n                                    SourceLocation ExpansionLocStart,\n                                    SourceLocation ExpansionLocEnd,\n                                    unsigned TokLength,\n                                    bool ExpansionIsTokenRange = true,\n                                    int LoadedID = 0,\n                                    unsigned LoadedOffset = 0);\n\n  /// Return a new SourceLocation that encodes that the token starting\n  /// at \\p TokenStart ends prematurely at \\p TokenEnd.\n  SourceLocation createTokenSplitLoc(SourceLocation SpellingLoc,\n                                     SourceLocation TokenStart,\n                                     SourceLocation TokenEnd);\n\n  /// Retrieve the memory buffer associated with the given file.\n  ///\n  /// Returns None if the buffer is not valid.\n  llvm::Optional<llvm::MemoryBufferRef>\n  getMemoryBufferForFileOrNone(const FileEntry *File);\n\n  /// Retrieve the memory buffer associated with the given file.\n  ///\n  /// Returns a fake buffer if there isn't a real one.\n  llvm::MemoryBufferRef getMemoryBufferForFileOrFake(const FileEntry *File) {\n    if (auto B = getMemoryBufferForFileOrNone(File))\n      return *B;\n    return getFakeBufferForRecovery();\n  }\n\n  /// Override the contents of the given source file by providing an\n  /// already-allocated buffer.\n  ///\n  /// \\param SourceFile the source file whose contents will be overridden.\n  ///\n  /// \\param Buffer the memory buffer whose contents will be used as the\n  /// data in the given source file.\n  void overrideFileContents(const FileEntry *SourceFile,\n                            const llvm::MemoryBufferRef &Buffer) {\n    overrideFileContents(SourceFile, llvm::MemoryBuffer::getMemBuffer(Buffer));\n  }\n\n  /// Override the contents of the given source file by providing an\n  /// already-allocated buffer.\n  ///\n  /// \\param SourceFile the source file whose contents will be overridden.\n  ///\n  /// \\param Buffer the memory buffer whose contents will be used as the\n  /// data in the given source file.\n  void overrideFileContents(const FileEntry *SourceFile,\n                            std::unique_ptr<llvm::MemoryBuffer> Buffer);\n  void overrideFileContents(FileEntryRef SourceFile,\n                            std::unique_ptr<llvm::MemoryBuffer> Buffer) {\n    overrideFileContents(&SourceFile.getFileEntry(), std::move(Buffer));\n  }\n\n  /// Override the given source file with another one.\n  ///\n  /// \\param SourceFile the source file which will be overridden.\n  ///\n  /// \\param NewFile the file whose contents will be used as the\n  /// data instead of the contents of the given source file.\n  void overrideFileContents(const FileEntry *SourceFile,\n                            const FileEntry *NewFile);\n\n  /// Returns true if the file contents have been overridden.\n  bool isFileOverridden(const FileEntry *File) const {\n    if (OverriddenFilesInfo) {\n      if (OverriddenFilesInfo->OverriddenFilesWithBuffer.count(File))\n        return true;\n      if (OverriddenFilesInfo->OverriddenFiles.find(File) !=\n          OverriddenFilesInfo->OverriddenFiles.end())\n        return true;\n    }\n    return false;\n  }\n\n  /// Bypass the overridden contents of a file.  This creates a new FileEntry\n  /// and initializes the content cache for it.  Returns None if there is no\n  /// such file in the filesystem.\n  ///\n  /// This should be called before parsing has begun.\n  Optional<FileEntryRef> bypassFileContentsOverride(FileEntryRef File);\n\n  /// Specify that a file is transient.\n  void setFileIsTransient(const FileEntry *SourceFile);\n\n  /// Specify that all files that are read during this compilation are\n  /// transient.\n  void setAllFilesAreTransient(bool Transient) {\n    FilesAreTransient = Transient;\n  }\n\n  //===--------------------------------------------------------------------===//\n  // FileID manipulation methods.\n  //===--------------------------------------------------------------------===//\n\n  /// Return the buffer for the specified FileID.\n  ///\n  /// If there is an error opening this buffer the first time, return None.\n  llvm::Optional<llvm::MemoryBufferRef>\n  getBufferOrNone(FileID FID, SourceLocation Loc = SourceLocation()) const {\n    if (auto *Entry = getSLocEntryForFile(FID))\n      return Entry->getFile().getContentCache().getBufferOrNone(\n          Diag, getFileManager(), Loc);\n    return None;\n  }\n\n  /// Return the buffer for the specified FileID.\n  ///\n  /// If there is an error opening this buffer the first time, this\n  /// manufactures a temporary buffer and returns it.\n  llvm::MemoryBufferRef\n  getBufferOrFake(FileID FID, SourceLocation Loc = SourceLocation()) const {\n    if (auto B = getBufferOrNone(FID, Loc))\n      return *B;\n    return getFakeBufferForRecovery();\n  }\n\n  /// Returns the FileEntry record for the provided FileID.\n  const FileEntry *getFileEntryForID(FileID FID) const {\n    if (auto *Entry = getSLocEntryForFile(FID))\n      return Entry->getFile().getContentCache().OrigEntry;\n    return nullptr;\n  }\n\n  /// Returns the FileEntryRef for the provided FileID.\n  Optional<FileEntryRef> getFileEntryRefForID(FileID FID) const {\n    if (auto *Entry = getFileEntryForID(FID))\n      return Entry->getLastRef();\n    return None;\n  }\n\n  /// Returns the filename for the provided FileID, unless it's a built-in\n  /// buffer that's not represented by a filename.\n  ///\n  /// Returns None for non-files and built-in files.\n  Optional<StringRef> getNonBuiltinFilenameForID(FileID FID) const;\n\n  /// Returns the FileEntry record for the provided SLocEntry.\n  const FileEntry *getFileEntryForSLocEntry(const SrcMgr::SLocEntry &sloc) const\n  {\n    return sloc.getFile().getContentCache().OrigEntry;\n  }\n\n  /// Return a StringRef to the source buffer data for the\n  /// specified FileID.\n  ///\n  /// \\param FID The file ID whose contents will be returned.\n  /// \\param Invalid If non-NULL, will be set true if an error occurred.\n  StringRef getBufferData(FileID FID, bool *Invalid = nullptr) const;\n\n  /// Return a StringRef to the source buffer data for the\n  /// specified FileID, returning None if invalid.\n  ///\n  /// \\param FID The file ID whose contents will be returned.\n  llvm::Optional<StringRef> getBufferDataOrNone(FileID FID) const;\n\n  /// Return a StringRef to the source buffer data for the\n  /// specified FileID, returning None if it's not yet loaded.\n  ///\n  /// \\param FID The file ID whose contents will be returned.\n  llvm::Optional<StringRef> getBufferDataIfLoaded(FileID FID) const;\n\n  /// Get the number of FileIDs (files and macros) that were created\n  /// during preprocessing of \\p FID, including it.\n  unsigned getNumCreatedFIDsForFileID(FileID FID) const {\n    if (auto *Entry = getSLocEntryForFile(FID))\n      return Entry->getFile().NumCreatedFIDs;\n    return 0;\n  }\n\n  /// Set the number of FileIDs (files and macros) that were created\n  /// during preprocessing of \\p FID, including it.\n  void setNumCreatedFIDsForFileID(FileID FID, unsigned NumFIDs,\n                                  bool Force = false) const {\n    auto *Entry = getSLocEntryForFile(FID);\n    if (!Entry)\n      return;\n    assert((Force || Entry->getFile().NumCreatedFIDs == 0) && \"Already set!\");\n    const_cast<SrcMgr::FileInfo &>(Entry->getFile()).NumCreatedFIDs = NumFIDs;\n  }\n\n  //===--------------------------------------------------------------------===//\n  // SourceLocation manipulation methods.\n  //===--------------------------------------------------------------------===//\n\n  /// Return the FileID for a SourceLocation.\n  ///\n  /// This is a very hot method that is used for all SourceManager queries\n  /// that start with a SourceLocation object.  It is responsible for finding\n  /// the entry in SLocEntryTable which contains the specified location.\n  ///\n  FileID getFileID(SourceLocation SpellingLoc) const {\n    unsigned SLocOffset = SpellingLoc.getOffset();\n\n    // If our one-entry cache covers this offset, just return it.\n    if (isOffsetInFileID(LastFileIDLookup, SLocOffset))\n      return LastFileIDLookup;\n\n    return getFileIDSlow(SLocOffset);\n  }\n\n  /// Return the filename of the file containing a SourceLocation.\n  StringRef getFilename(SourceLocation SpellingLoc) const;\n\n  /// Return the source location corresponding to the first byte of\n  /// the specified file.\n  SourceLocation getLocForStartOfFile(FileID FID) const {\n    if (auto *Entry = getSLocEntryForFile(FID))\n      return SourceLocation::getFileLoc(Entry->getOffset());\n    return SourceLocation();\n  }\n\n  /// Return the source location corresponding to the last byte of the\n  /// specified file.\n  SourceLocation getLocForEndOfFile(FileID FID) const {\n    if (auto *Entry = getSLocEntryForFile(FID))\n      return SourceLocation::getFileLoc(Entry->getOffset() +\n                                        getFileIDSize(FID));\n    return SourceLocation();\n  }\n\n  /// Returns the include location if \\p FID is a \\#include'd file\n  /// otherwise it returns an invalid location.\n  SourceLocation getIncludeLoc(FileID FID) const {\n    if (auto *Entry = getSLocEntryForFile(FID))\n      return Entry->getFile().getIncludeLoc();\n    return SourceLocation();\n  }\n\n  // Returns the import location if the given source location is\n  // located within a module, or an invalid location if the source location\n  // is within the current translation unit.\n  std::pair<SourceLocation, StringRef>\n  getModuleImportLoc(SourceLocation Loc) const {\n    FileID FID = getFileID(Loc);\n\n    // Positive file IDs are in the current translation unit, and -1 is a\n    // placeholder.\n    if (FID.ID >= -1)\n      return std::make_pair(SourceLocation(), \"\");\n\n    return ExternalSLocEntries->getModuleImportLoc(FID.ID);\n  }\n\n  /// Given a SourceLocation object \\p Loc, return the expansion\n  /// location referenced by the ID.\n  SourceLocation getExpansionLoc(SourceLocation Loc) const {\n    // Handle the non-mapped case inline, defer to out of line code to handle\n    // expansions.\n    if (Loc.isFileID()) return Loc;\n    return getExpansionLocSlowCase(Loc);\n  }\n\n  /// Given \\p Loc, if it is a macro location return the expansion\n  /// location or the spelling location, depending on if it comes from a\n  /// macro argument or not.\n  SourceLocation getFileLoc(SourceLocation Loc) const {\n    if (Loc.isFileID()) return Loc;\n    return getFileLocSlowCase(Loc);\n  }\n\n  /// Return the start/end of the expansion information for an\n  /// expansion location.\n  ///\n  /// \\pre \\p Loc is required to be an expansion location.\n  CharSourceRange getImmediateExpansionRange(SourceLocation Loc) const;\n\n  /// Given a SourceLocation object, return the range of\n  /// tokens covered by the expansion in the ultimate file.\n  CharSourceRange getExpansionRange(SourceLocation Loc) const;\n\n  /// Given a SourceRange object, return the range of\n  /// tokens or characters covered by the expansion in the ultimate file.\n  CharSourceRange getExpansionRange(SourceRange Range) const {\n    SourceLocation Begin = getExpansionRange(Range.getBegin()).getBegin();\n    CharSourceRange End = getExpansionRange(Range.getEnd());\n    return CharSourceRange(SourceRange(Begin, End.getEnd()),\n                           End.isTokenRange());\n  }\n\n  /// Given a CharSourceRange object, return the range of\n  /// tokens or characters covered by the expansion in the ultimate file.\n  CharSourceRange getExpansionRange(CharSourceRange Range) const {\n    CharSourceRange Expansion = getExpansionRange(Range.getAsRange());\n    if (Expansion.getEnd() == Range.getEnd())\n      Expansion.setTokenRange(Range.isTokenRange());\n    return Expansion;\n  }\n\n  /// Given a SourceLocation object, return the spelling\n  /// location referenced by the ID.\n  ///\n  /// This is the place where the characters that make up the lexed token\n  /// can be found.\n  SourceLocation getSpellingLoc(SourceLocation Loc) const {\n    // Handle the non-mapped case inline, defer to out of line code to handle\n    // expansions.\n    if (Loc.isFileID()) return Loc;\n    return getSpellingLocSlowCase(Loc);\n  }\n\n  /// Given a SourceLocation object, return the spelling location\n  /// referenced by the ID.\n  ///\n  /// This is the first level down towards the place where the characters\n  /// that make up the lexed token can be found.  This should not generally\n  /// be used by clients.\n  SourceLocation getImmediateSpellingLoc(SourceLocation Loc) const;\n\n  /// Form a SourceLocation from a FileID and Offset pair.\n  SourceLocation getComposedLoc(FileID FID, unsigned Offset) const {\n    auto *Entry = getSLocEntryOrNull(FID);\n    if (!Entry)\n      return SourceLocation();\n\n    unsigned GlobalOffset = Entry->getOffset() + Offset;\n    return Entry->isFile() ? SourceLocation::getFileLoc(GlobalOffset)\n                           : SourceLocation::getMacroLoc(GlobalOffset);\n  }\n\n  /// Decompose the specified location into a raw FileID + Offset pair.\n  ///\n  /// The first element is the FileID, the second is the offset from the\n  /// start of the buffer of the location.\n  std::pair<FileID, unsigned> getDecomposedLoc(SourceLocation Loc) const {\n    FileID FID = getFileID(Loc);\n    auto *Entry = getSLocEntryOrNull(FID);\n    if (!Entry)\n      return std::make_pair(FileID(), 0);\n    return std::make_pair(FID, Loc.getOffset() - Entry->getOffset());\n  }\n\n  /// Decompose the specified location into a raw FileID + Offset pair.\n  ///\n  /// If the location is an expansion record, walk through it until we find\n  /// the final location expanded.\n  std::pair<FileID, unsigned>\n  getDecomposedExpansionLoc(SourceLocation Loc) const {\n    FileID FID = getFileID(Loc);\n    auto *E = getSLocEntryOrNull(FID);\n    if (!E)\n      return std::make_pair(FileID(), 0);\n\n    unsigned Offset = Loc.getOffset()-E->getOffset();\n    if (Loc.isFileID())\n      return std::make_pair(FID, Offset);\n\n    return getDecomposedExpansionLocSlowCase(E);\n  }\n\n  /// Decompose the specified location into a raw FileID + Offset pair.\n  ///\n  /// If the location is an expansion record, walk through it until we find\n  /// its spelling record.\n  std::pair<FileID, unsigned>\n  getDecomposedSpellingLoc(SourceLocation Loc) const {\n    FileID FID = getFileID(Loc);\n    auto *E = getSLocEntryOrNull(FID);\n    if (!E)\n      return std::make_pair(FileID(), 0);\n\n    unsigned Offset = Loc.getOffset()-E->getOffset();\n    if (Loc.isFileID())\n      return std::make_pair(FID, Offset);\n    return getDecomposedSpellingLocSlowCase(E, Offset);\n  }\n\n  /// Returns the \"included/expanded in\" decomposed location of the given\n  /// FileID.\n  std::pair<FileID, unsigned> getDecomposedIncludedLoc(FileID FID) const;\n\n  /// Returns the offset from the start of the file that the\n  /// specified SourceLocation represents.\n  ///\n  /// This is not very meaningful for a macro ID.\n  unsigned getFileOffset(SourceLocation SpellingLoc) const {\n    return getDecomposedLoc(SpellingLoc).second;\n  }\n\n  /// Tests whether the given source location represents a macro\n  /// argument's expansion into the function-like macro definition.\n  ///\n  /// \\param StartLoc If non-null and function returns true, it is set to the\n  /// start location of the macro argument expansion.\n  ///\n  /// Such source locations only appear inside of the expansion\n  /// locations representing where a particular function-like macro was\n  /// expanded.\n  bool isMacroArgExpansion(SourceLocation Loc,\n                           SourceLocation *StartLoc = nullptr) const;\n\n  /// Tests whether the given source location represents the expansion of\n  /// a macro body.\n  ///\n  /// This is equivalent to testing whether the location is part of a macro\n  /// expansion but not the expansion of an argument to a function-like macro.\n  bool isMacroBodyExpansion(SourceLocation Loc) const;\n\n  /// Returns true if the given MacroID location points at the beginning\n  /// of the immediate macro expansion.\n  ///\n  /// \\param MacroBegin If non-null and function returns true, it is set to the\n  /// begin location of the immediate macro expansion.\n  bool isAtStartOfImmediateMacroExpansion(SourceLocation Loc,\n                                    SourceLocation *MacroBegin = nullptr) const;\n\n  /// Returns true if the given MacroID location points at the character\n  /// end of the immediate macro expansion.\n  ///\n  /// \\param MacroEnd If non-null and function returns true, it is set to the\n  /// character end location of the immediate macro expansion.\n  bool\n  isAtEndOfImmediateMacroExpansion(SourceLocation Loc,\n                                   SourceLocation *MacroEnd = nullptr) const;\n\n  /// Returns true if \\p Loc is inside the [\\p Start, +\\p Length)\n  /// chunk of the source location address space.\n  ///\n  /// If it's true and \\p RelativeOffset is non-null, it will be set to the\n  /// relative offset of \\p Loc inside the chunk.\n  bool isInSLocAddrSpace(SourceLocation Loc,\n                         SourceLocation Start, unsigned Length,\n                         unsigned *RelativeOffset = nullptr) const {\n    assert(((Start.getOffset() < NextLocalOffset &&\n               Start.getOffset()+Length <= NextLocalOffset) ||\n            (Start.getOffset() >= CurrentLoadedOffset &&\n                Start.getOffset()+Length < MaxLoadedOffset)) &&\n           \"Chunk is not valid SLoc address space\");\n    unsigned LocOffs = Loc.getOffset();\n    unsigned BeginOffs = Start.getOffset();\n    unsigned EndOffs = BeginOffs + Length;\n    if (LocOffs >= BeginOffs && LocOffs < EndOffs) {\n      if (RelativeOffset)\n        *RelativeOffset = LocOffs - BeginOffs;\n      return true;\n    }\n\n    return false;\n  }\n\n  /// Return true if both \\p LHS and \\p RHS are in the local source\n  /// location address space or the loaded one.\n  ///\n  /// If it's true and \\p RelativeOffset is non-null, it will be set to the\n  /// offset of \\p RHS relative to \\p LHS.\n  bool isInSameSLocAddrSpace(SourceLocation LHS, SourceLocation RHS,\n                             int *RelativeOffset) const {\n    unsigned LHSOffs = LHS.getOffset(), RHSOffs = RHS.getOffset();\n    bool LHSLoaded = LHSOffs >= CurrentLoadedOffset;\n    bool RHSLoaded = RHSOffs >= CurrentLoadedOffset;\n\n    if (LHSLoaded == RHSLoaded) {\n      if (RelativeOffset)\n        *RelativeOffset = RHSOffs - LHSOffs;\n      return true;\n    }\n\n    return false;\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Queries about the code at a SourceLocation.\n  //===--------------------------------------------------------------------===//\n\n  /// Return a pointer to the start of the specified location\n  /// in the appropriate spelling MemoryBuffer.\n  ///\n  /// \\param Invalid If non-NULL, will be set \\c true if an error occurs.\n  const char *getCharacterData(SourceLocation SL,\n                               bool *Invalid = nullptr) const;\n\n  /// Return the column # for the specified file position.\n  ///\n  /// This is significantly cheaper to compute than the line number.  This\n  /// returns zero if the column number isn't known.  This may only be called\n  /// on a file sloc, so you must choose a spelling or expansion location\n  /// before calling this method.\n  unsigned getColumnNumber(FileID FID, unsigned FilePos,\n                           bool *Invalid = nullptr) const;\n  unsigned getSpellingColumnNumber(SourceLocation Loc,\n                                   bool *Invalid = nullptr) const;\n  unsigned getExpansionColumnNumber(SourceLocation Loc,\n                                    bool *Invalid = nullptr) const;\n  unsigned getPresumedColumnNumber(SourceLocation Loc,\n                                   bool *Invalid = nullptr) const;\n\n  /// Given a SourceLocation, return the spelling line number\n  /// for the position indicated.\n  ///\n  /// This requires building and caching a table of line offsets for the\n  /// MemoryBuffer, so this is not cheap: use only when about to emit a\n  /// diagnostic.\n  unsigned getLineNumber(FileID FID, unsigned FilePos, bool *Invalid = nullptr) const;\n  unsigned getSpellingLineNumber(SourceLocation Loc, bool *Invalid = nullptr) const;\n  unsigned getExpansionLineNumber(SourceLocation Loc, bool *Invalid = nullptr) const;\n  unsigned getPresumedLineNumber(SourceLocation Loc, bool *Invalid = nullptr) const;\n\n  /// Return the filename or buffer identifier of the buffer the\n  /// location is in.\n  ///\n  /// Note that this name does not respect \\#line directives.  Use\n  /// getPresumedLoc for normal clients.\n  StringRef getBufferName(SourceLocation Loc, bool *Invalid = nullptr) const;\n\n  /// Return the file characteristic of the specified source\n  /// location, indicating whether this is a normal file, a system\n  /// header, or an \"implicit extern C\" system header.\n  ///\n  /// This state can be modified with flags on GNU linemarker directives like:\n  /// \\code\n  ///   # 4 \"foo.h\" 3\n  /// \\endcode\n  /// which changes all source locations in the current file after that to be\n  /// considered to be from a system header.\n  SrcMgr::CharacteristicKind getFileCharacteristic(SourceLocation Loc) const;\n\n  /// Returns the \"presumed\" location of a SourceLocation specifies.\n  ///\n  /// A \"presumed location\" can be modified by \\#line or GNU line marker\n  /// directives.  This provides a view on the data that a user should see\n  /// in diagnostics, for example.\n  ///\n  /// Note that a presumed location is always given as the expansion point of\n  /// an expansion location, not at the spelling location.\n  ///\n  /// \\returns The presumed location of the specified SourceLocation. If the\n  /// presumed location cannot be calculated (e.g., because \\p Loc is invalid\n  /// or the file containing \\p Loc has changed on disk), returns an invalid\n  /// presumed location.\n  PresumedLoc getPresumedLoc(SourceLocation Loc,\n                             bool UseLineDirectives = true) const;\n\n  /// Returns whether the PresumedLoc for a given SourceLocation is\n  /// in the main file.\n  ///\n  /// This computes the \"presumed\" location for a SourceLocation, then checks\n  /// whether it came from a file other than the main file. This is different\n  /// from isWrittenInMainFile() because it takes line marker directives into\n  /// account.\n  bool isInMainFile(SourceLocation Loc) const;\n\n  /// Returns true if the spelling locations for both SourceLocations\n  /// are part of the same file buffer.\n  ///\n  /// This check ignores line marker directives.\n  bool isWrittenInSameFile(SourceLocation Loc1, SourceLocation Loc2) const {\n    return getFileID(Loc1) == getFileID(Loc2);\n  }\n\n  /// Returns true if the spelling location for the given location\n  /// is in the main file buffer.\n  ///\n  /// This check ignores line marker directives.\n  bool isWrittenInMainFile(SourceLocation Loc) const {\n    return getFileID(Loc) == getMainFileID();\n  }\n\n  /// Returns whether \\p Loc is located in a <built-in> file.\n  bool isWrittenInBuiltinFile(SourceLocation Loc) const {\n    StringRef Filename(getPresumedLoc(Loc).getFilename());\n    return Filename.equals(\"<built-in>\");\n  }\n\n  /// Returns whether \\p Loc is located in a <command line> file.\n  bool isWrittenInCommandLineFile(SourceLocation Loc) const {\n    StringRef Filename(getPresumedLoc(Loc).getFilename());\n    return Filename.equals(\"<command line>\");\n  }\n\n  /// Returns whether \\p Loc is located in a <scratch space> file.\n  bool isWrittenInScratchSpace(SourceLocation Loc) const {\n    StringRef Filename(getPresumedLoc(Loc).getFilename());\n    return Filename.equals(\"<scratch space>\");\n  }\n\n  /// Returns if a SourceLocation is in a system header.\n  bool isInSystemHeader(SourceLocation Loc) const {\n    return isSystem(getFileCharacteristic(Loc));\n  }\n\n  /// Returns if a SourceLocation is in an \"extern C\" system header.\n  bool isInExternCSystemHeader(SourceLocation Loc) const {\n    return getFileCharacteristic(Loc) == SrcMgr::C_ExternCSystem;\n  }\n\n  /// Returns whether \\p Loc is expanded from a macro in a system header.\n  bool isInSystemMacro(SourceLocation loc) const {\n    if (!loc.isMacroID())\n      return false;\n\n    // This happens when the macro is the result of a paste, in that case\n    // its spelling is the scratch memory, so we take the parent context.\n    // There can be several level of token pasting.\n    if (isWrittenInScratchSpace(getSpellingLoc(loc))) {\n      do {\n        loc = getImmediateMacroCallerLoc(loc);\n      } while (isWrittenInScratchSpace(getSpellingLoc(loc)));\n      return isInSystemMacro(loc);\n    }\n\n    return isInSystemHeader(getSpellingLoc(loc));\n  }\n\n  /// The size of the SLocEntry that \\p FID represents.\n  unsigned getFileIDSize(FileID FID) const;\n\n  /// Given a specific FileID, returns true if \\p Loc is inside that\n  /// FileID chunk and sets relative offset (offset of \\p Loc from beginning\n  /// of FileID) to \\p relativeOffset.\n  bool isInFileID(SourceLocation Loc, FileID FID,\n                  unsigned *RelativeOffset = nullptr) const {\n    unsigned Offs = Loc.getOffset();\n    if (isOffsetInFileID(FID, Offs)) {\n      if (RelativeOffset)\n        *RelativeOffset = Offs - getSLocEntry(FID).getOffset();\n      return true;\n    }\n\n    return false;\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Line Table Manipulation Routines\n  //===--------------------------------------------------------------------===//\n\n  /// Return the uniqued ID for the specified filename.\n  unsigned getLineTableFilenameID(StringRef Str);\n\n  /// Add a line note to the line table for the FileID and offset\n  /// specified by Loc.\n  ///\n  /// If FilenameID is -1, it is considered to be unspecified.\n  void AddLineNote(SourceLocation Loc, unsigned LineNo, int FilenameID,\n                   bool IsFileEntry, bool IsFileExit,\n                   SrcMgr::CharacteristicKind FileKind);\n\n  /// Determine if the source manager has a line table.\n  bool hasLineTable() const { return LineTable != nullptr; }\n\n  /// Retrieve the stored line table.\n  LineTableInfo &getLineTable();\n\n  //===--------------------------------------------------------------------===//\n  // Queries for performance analysis.\n  //===--------------------------------------------------------------------===//\n\n  /// Return the total amount of physical memory allocated by the\n  /// ContentCache allocator.\n  size_t getContentCacheSize() const {\n    return ContentCacheAlloc.getTotalMemory();\n  }\n\n  struct MemoryBufferSizes {\n    const size_t malloc_bytes;\n    const size_t mmap_bytes;\n\n    MemoryBufferSizes(size_t malloc_bytes, size_t mmap_bytes)\n      : malloc_bytes(malloc_bytes), mmap_bytes(mmap_bytes) {}\n  };\n\n  /// Return the amount of memory used by memory buffers, breaking down\n  /// by heap-backed versus mmap'ed memory.\n  MemoryBufferSizes getMemoryBufferSizes() const;\n\n  /// Return the amount of memory used for various side tables and\n  /// data structures in the SourceManager.\n  size_t getDataStructureSizes() const;\n\n  //===--------------------------------------------------------------------===//\n  // Other miscellaneous methods.\n  //===--------------------------------------------------------------------===//\n\n  /// Get the source location for the given file:line:col triplet.\n  ///\n  /// If the source file is included multiple times, the source location will\n  /// be based upon the first inclusion.\n  SourceLocation translateFileLineCol(const FileEntry *SourceFile,\n                                      unsigned Line, unsigned Col) const;\n\n  /// Get the FileID for the given file.\n  ///\n  /// If the source file is included multiple times, the FileID will be the\n  /// first inclusion.\n  FileID translateFile(const FileEntry *SourceFile) const;\n  FileID translateFile(FileEntryRef SourceFile) const {\n    return translateFile(&SourceFile.getFileEntry());\n  }\n\n  /// Get the source location in \\p FID for the given line:col.\n  /// Returns null location if \\p FID is not a file SLocEntry.\n  SourceLocation translateLineCol(FileID FID,\n                                  unsigned Line, unsigned Col) const;\n\n  /// If \\p Loc points inside a function macro argument, the returned\n  /// location will be the macro location in which the argument was expanded.\n  /// If a macro argument is used multiple times, the expanded location will\n  /// be at the first expansion of the argument.\n  /// e.g.\n  ///   MY_MACRO(foo);\n  ///             ^\n  /// Passing a file location pointing at 'foo', will yield a macro location\n  /// where 'foo' was expanded into.\n  SourceLocation getMacroArgExpandedLocation(SourceLocation Loc) const;\n\n  /// Determines the order of 2 source locations in the translation unit.\n  ///\n  /// \\returns true if LHS source location comes before RHS, false otherwise.\n  bool isBeforeInTranslationUnit(SourceLocation LHS, SourceLocation RHS) const;\n\n  /// Determines whether the two decomposed source location is in the\n  ///        same translation unit. As a byproduct, it also calculates the order\n  ///        of the source locations in case they are in the same TU.\n  ///\n  /// \\returns Pair of bools the first component is true if the two locations\n  ///          are in the same TU. The second bool is true if the first is true\n  ///          and \\p LOffs is before \\p ROffs.\n  std::pair<bool, bool>\n  isInTheSameTranslationUnit(std::pair<FileID, unsigned> &LOffs,\n                             std::pair<FileID, unsigned> &ROffs) const;\n\n  /// Determines the order of 2 source locations in the \"source location\n  /// address space\".\n  bool isBeforeInSLocAddrSpace(SourceLocation LHS, SourceLocation RHS) const {\n    return isBeforeInSLocAddrSpace(LHS, RHS.getOffset());\n  }\n\n  /// Determines the order of a source location and a source location\n  /// offset in the \"source location address space\".\n  ///\n  /// Note that we always consider source locations loaded from\n  bool isBeforeInSLocAddrSpace(SourceLocation LHS, unsigned RHS) const {\n    unsigned LHSOffset = LHS.getOffset();\n    bool LHSLoaded = LHSOffset >= CurrentLoadedOffset;\n    bool RHSLoaded = RHS >= CurrentLoadedOffset;\n    if (LHSLoaded == RHSLoaded)\n      return LHSOffset < RHS;\n\n    return LHSLoaded;\n  }\n\n  /// Return true if the Point is within Start and End.\n  bool isPointWithin(SourceLocation Location, SourceLocation Start,\n                     SourceLocation End) const {\n    return Location == Start || Location == End ||\n           (isBeforeInTranslationUnit(Start, Location) &&\n            isBeforeInTranslationUnit(Location, End));\n  }\n\n  // Iterators over FileInfos.\n  using fileinfo_iterator =\n      llvm::DenseMap<const FileEntry*, SrcMgr::ContentCache*>::const_iterator;\n\n  fileinfo_iterator fileinfo_begin() const { return FileInfos.begin(); }\n  fileinfo_iterator fileinfo_end() const { return FileInfos.end(); }\n  bool hasFileInfo(const FileEntry *File) const {\n    return FileInfos.find(File) != FileInfos.end();\n  }\n\n  /// Print statistics to stderr.\n  void PrintStats() const;\n\n  void dump() const;\n\n  /// Get the number of local SLocEntries we have.\n  unsigned local_sloc_entry_size() const { return LocalSLocEntryTable.size(); }\n\n  /// Get a local SLocEntry. This is exposed for indexing.\n  const SrcMgr::SLocEntry &getLocalSLocEntry(unsigned Index) const {\n    assert(Index < LocalSLocEntryTable.size() && \"Invalid index\");\n    return LocalSLocEntryTable[Index];\n  }\n\n  /// Get the number of loaded SLocEntries we have.\n  unsigned loaded_sloc_entry_size() const { return LoadedSLocEntryTable.size();}\n\n  /// Get a loaded SLocEntry. This is exposed for indexing.\n  const SrcMgr::SLocEntry &getLoadedSLocEntry(unsigned Index,\n                                              bool *Invalid = nullptr) const {\n    assert(Index < LoadedSLocEntryTable.size() && \"Invalid index\");\n    if (SLocEntryLoaded[Index])\n      return LoadedSLocEntryTable[Index];\n    return loadSLocEntry(Index, Invalid);\n  }\n\n  const SrcMgr::SLocEntry &getSLocEntry(FileID FID,\n                                        bool *Invalid = nullptr) const {\n    if (FID.ID == 0 || FID.ID == -1) {\n      if (Invalid) *Invalid = true;\n      return LocalSLocEntryTable[0];\n    }\n    return getSLocEntryByID(FID.ID, Invalid);\n  }\n\n  unsigned getNextLocalOffset() const { return NextLocalOffset; }\n\n  void setExternalSLocEntrySource(ExternalSLocEntrySource *Source) {\n    assert(LoadedSLocEntryTable.empty() &&\n           \"Invalidating existing loaded entries\");\n    ExternalSLocEntries = Source;\n  }\n\n  /// Allocate a number of loaded SLocEntries, which will be actually\n  /// loaded on demand from the external source.\n  ///\n  /// NumSLocEntries will be allocated, which occupy a total of TotalSize space\n  /// in the global source view. The lowest ID and the base offset of the\n  /// entries will be returned.\n  std::pair<int, unsigned>\n  AllocateLoadedSLocEntries(unsigned NumSLocEntries, unsigned TotalSize);\n\n  /// Returns true if \\p Loc came from a PCH/Module.\n  bool isLoadedSourceLocation(SourceLocation Loc) const {\n    return Loc.getOffset() >= CurrentLoadedOffset;\n  }\n\n  /// Returns true if \\p Loc did not come from a PCH/Module.\n  bool isLocalSourceLocation(SourceLocation Loc) const {\n    return Loc.getOffset() < NextLocalOffset;\n  }\n\n  /// Returns true if \\p FID came from a PCH/Module.\n  bool isLoadedFileID(FileID FID) const {\n    assert(FID.ID != -1 && \"Using FileID sentinel value\");\n    return FID.ID < 0;\n  }\n\n  /// Returns true if \\p FID did not come from a PCH/Module.\n  bool isLocalFileID(FileID FID) const {\n    return !isLoadedFileID(FID);\n  }\n\n  /// Gets the location of the immediate macro caller, one level up the stack\n  /// toward the initial macro typed into the source.\n  SourceLocation getImmediateMacroCallerLoc(SourceLocation Loc) const {\n    if (!Loc.isMacroID()) return Loc;\n\n    // When we have the location of (part of) an expanded parameter, its\n    // spelling location points to the argument as expanded in the macro call,\n    // and therefore is used to locate the macro caller.\n    if (isMacroArgExpansion(Loc))\n      return getImmediateSpellingLoc(Loc);\n\n    // Otherwise, the caller of the macro is located where this macro is\n    // expanded (while the spelling is part of the macro definition).\n    return getImmediateExpansionRange(Loc).getBegin();\n  }\n\n  /// \\return Location of the top-level macro caller.\n  SourceLocation getTopMacroCallerLoc(SourceLocation Loc) const;\n\nprivate:\n  friend class ASTReader;\n  friend class ASTWriter;\n\n  llvm::MemoryBufferRef getFakeBufferForRecovery() const;\n  SrcMgr::ContentCache &getFakeContentCacheForRecovery() const;\n\n  const SrcMgr::SLocEntry &loadSLocEntry(unsigned Index, bool *Invalid) const;\n\n  const SrcMgr::SLocEntry *getSLocEntryOrNull(FileID FID) const {\n    bool Invalid = false;\n    const SrcMgr::SLocEntry &Entry = getSLocEntry(FID, &Invalid);\n    return Invalid ? nullptr : &Entry;\n  }\n\n  const SrcMgr::SLocEntry *getSLocEntryForFile(FileID FID) const {\n    if (auto *Entry = getSLocEntryOrNull(FID))\n      if (Entry->isFile())\n        return Entry;\n    return nullptr;\n  }\n\n  /// Get the entry with the given unwrapped FileID.\n  /// Invalid will not be modified for Local IDs.\n  const SrcMgr::SLocEntry &getSLocEntryByID(int ID,\n                                            bool *Invalid = nullptr) const {\n    assert(ID != -1 && \"Using FileID sentinel value\");\n    if (ID < 0)\n      return getLoadedSLocEntryByID(ID, Invalid);\n    return getLocalSLocEntry(static_cast<unsigned>(ID));\n  }\n\n  const SrcMgr::SLocEntry &\n  getLoadedSLocEntryByID(int ID, bool *Invalid = nullptr) const {\n    return getLoadedSLocEntry(static_cast<unsigned>(-ID - 2), Invalid);\n  }\n\n  /// Implements the common elements of storing an expansion info struct into\n  /// the SLocEntry table and producing a source location that refers to it.\n  SourceLocation createExpansionLocImpl(const SrcMgr::ExpansionInfo &Expansion,\n                                        unsigned TokLength,\n                                        int LoadedID = 0,\n                                        unsigned LoadedOffset = 0);\n\n  /// Return true if the specified FileID contains the\n  /// specified SourceLocation offset.  This is a very hot method.\n  inline bool isOffsetInFileID(FileID FID, unsigned SLocOffset) const {\n    const SrcMgr::SLocEntry &Entry = getSLocEntry(FID);\n    // If the entry is after the offset, it can't contain it.\n    if (SLocOffset < Entry.getOffset()) return false;\n\n    // If this is the very last entry then it does.\n    if (FID.ID == -2)\n      return true;\n\n    // If it is the last local entry, then it does if the location is local.\n    if (FID.ID+1 == static_cast<int>(LocalSLocEntryTable.size()))\n      return SLocOffset < NextLocalOffset;\n\n    // Otherwise, the entry after it has to not include it. This works for both\n    // local and loaded entries.\n    return SLocOffset < getSLocEntryByID(FID.ID+1).getOffset();\n  }\n\n  /// Returns the previous in-order FileID or an invalid FileID if there\n  /// is no previous one.\n  FileID getPreviousFileID(FileID FID) const;\n\n  /// Returns the next in-order FileID or an invalid FileID if there is\n  /// no next one.\n  FileID getNextFileID(FileID FID) const;\n\n  /// Create a new fileID for the specified ContentCache and\n  /// include position.\n  ///\n  /// This works regardless of whether the ContentCache corresponds to a\n  /// file or some other input source.\n  FileID createFileIDImpl(SrcMgr::ContentCache &File, StringRef Filename,\n                          SourceLocation IncludePos,\n                          SrcMgr::CharacteristicKind DirCharacter, int LoadedID,\n                          unsigned LoadedOffset);\n\n  SrcMgr::ContentCache &getOrCreateContentCache(FileEntryRef SourceFile,\n                                                bool isSystemFile = false);\n\n  /// Create a new ContentCache for the specified  memory buffer.\n  SrcMgr::ContentCache &\n  createMemBufferContentCache(std::unique_ptr<llvm::MemoryBuffer> Buf);\n\n  FileID getFileIDSlow(unsigned SLocOffset) const;\n  FileID getFileIDLocal(unsigned SLocOffset) const;\n  FileID getFileIDLoaded(unsigned SLocOffset) const;\n\n  SourceLocation getExpansionLocSlowCase(SourceLocation Loc) const;\n  SourceLocation getSpellingLocSlowCase(SourceLocation Loc) const;\n  SourceLocation getFileLocSlowCase(SourceLocation Loc) const;\n\n  std::pair<FileID, unsigned>\n  getDecomposedExpansionLocSlowCase(const SrcMgr::SLocEntry *E) const;\n  std::pair<FileID, unsigned>\n  getDecomposedSpellingLocSlowCase(const SrcMgr::SLocEntry *E,\n                                   unsigned Offset) const;\n  void computeMacroArgsCache(MacroArgsMap &MacroArgsCache, FileID FID) const;\n  void associateFileChunkWithMacroArgExp(MacroArgsMap &MacroArgsCache,\n                                         FileID FID,\n                                         SourceLocation SpellLoc,\n                                         SourceLocation ExpansionLoc,\n                                         unsigned ExpansionLength) const;\n};\n\n/// Comparison function object.\ntemplate<typename T>\nclass BeforeThanCompare;\n\n/// Compare two source locations.\ntemplate<>\nclass BeforeThanCompare<SourceLocation> {\n  SourceManager &SM;\n\npublic:\n  explicit BeforeThanCompare(SourceManager &SM) : SM(SM) {}\n\n  bool operator()(SourceLocation LHS, SourceLocation RHS) const {\n    return SM.isBeforeInTranslationUnit(LHS, RHS);\n  }\n};\n\n/// Compare two non-overlapping source ranges.\ntemplate<>\nclass BeforeThanCompare<SourceRange> {\n  SourceManager &SM;\n\npublic:\n  explicit BeforeThanCompare(SourceManager &SM) : SM(SM) {}\n\n  bool operator()(SourceRange LHS, SourceRange RHS) const {\n    return SM.isBeforeInTranslationUnit(LHS.getBegin(), RHS.getBegin());\n  }\n};\n\n/// SourceManager and necessary depdencies (e.g. VFS, FileManager) for a single\n/// in-memorty file.\nclass SourceManagerForFile {\npublic:\n  /// Creates SourceManager and necessary depdencies (e.g. VFS, FileManager).\n  /// The main file in the SourceManager will be \\p FileName with \\p Content.\n  SourceManagerForFile(StringRef FileName, StringRef Content);\n\n  SourceManager &get() {\n    assert(SourceMgr);\n    return *SourceMgr;\n  }\n\nprivate:\n  // The order of these fields are important - they should be in the same order\n  // as they are created in `createSourceManagerForFile` so that they can be\n  // deleted in the reverse order as they are created.\n  std::unique_ptr<FileManager> FileMgr;\n  std::unique_ptr<DiagnosticsEngine> Diagnostics;\n  std::unique_ptr<SourceManager> SourceMgr;\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_BASIC_SOURCEMANAGER_H\n"}, "66": {"id": 66, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Specifiers.h", "content": "//===--- Specifiers.h - Declaration and Type Specifiers ---------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Defines various enumerations that describe declaration and\n/// type specifiers.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_SPECIFIERS_H\n#define LLVM_CLANG_BASIC_SPECIFIERS_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/DataTypes.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n\nnamespace clang {\n\n  /// Define the meaning of possible values of the kind in ExplicitSpecifier.\n  enum class ExplicitSpecKind : unsigned {\n    ResolvedFalse,\n    ResolvedTrue,\n    Unresolved,\n  };\n\n  /// Define the kind of constexpr specifier.\n  enum class ConstexprSpecKind { Unspecified, Constexpr, Consteval, Constinit };\n\n  /// Specifies the width of a type, e.g., short, long, or long long.\n  enum class TypeSpecifierWidth { Unspecified, Short, Long, LongLong };\n\n  /// Specifies the signedness of a type, e.g., signed or unsigned.\n  enum class TypeSpecifierSign { Unspecified, Signed, Unsigned };\n\n  enum class TypeSpecifiersPipe { Unspecified, Pipe };\n\n  /// Specifies the kind of type.\n  enum TypeSpecifierType {\n    TST_unspecified,\n    TST_void,\n    TST_char,\n    TST_wchar,        // C++ wchar_t\n    TST_char8,        // C++20 char8_t (proposed)\n    TST_char16,       // C++11 char16_t\n    TST_char32,       // C++11 char32_t\n    TST_int,\n    TST_int128,\n    TST_extint,       // Extended Int types.\n    TST_half,         // OpenCL half, ARM NEON __fp16\n    TST_Float16,      // C11 extension ISO/IEC TS 18661-3\n    TST_Accum,        // ISO/IEC JTC1 SC22 WG14 N1169 Extension\n    TST_Fract,\n    TST_BFloat16,\n    TST_float,\n    TST_double,\n    TST_float128,\n    TST_bool,         // _Bool\n    TST_decimal32,    // _Decimal32\n    TST_decimal64,    // _Decimal64\n    TST_decimal128,   // _Decimal128\n    TST_enum,\n    TST_union,\n    TST_struct,\n    TST_class,        // C++ class type\n    TST_interface,    // C++ (Microsoft-specific) __interface type\n    TST_typename,     // Typedef, C++ class-name or enum name, etc.\n    TST_typeofType,\n    TST_typeofExpr,\n    TST_decltype,         // C++11 decltype\n    TST_underlyingType,   // __underlying_type for C++11\n    TST_auto,             // C++11 auto\n    TST_decltype_auto,    // C++1y decltype(auto)\n    TST_auto_type,        // __auto_type extension\n    TST_unknown_anytype,  // __unknown_anytype extension\n    TST_atomic,           // C11 _Atomic\n#define GENERIC_IMAGE_TYPE(ImgType, Id) TST_##ImgType##_t, // OpenCL image types\n#include \"clang/Basic/OpenCLImageTypes.def\"\n    TST_error // erroneous type\n  };\n\n  /// Structure that packs information about the type specifiers that\n  /// were written in a particular type specifier sequence.\n  struct WrittenBuiltinSpecs {\n    static_assert(TST_error < 1 << 6, \"Type bitfield not wide enough for TST\");\n    /*DeclSpec::TST*/ unsigned Type  : 6;\n    /*DeclSpec::TSS*/ unsigned Sign  : 2;\n    /*TypeSpecifierWidth*/ unsigned Width : 2;\n    unsigned ModeAttr : 1;\n  };\n\n  /// A C++ access specifier (public, private, protected), plus the\n  /// special value \"none\" which means different things in different contexts.\n  enum AccessSpecifier {\n    AS_public,\n    AS_protected,\n    AS_private,\n    AS_none\n  };\n\n  /// The categorization of expression values, currently following the\n  /// C++11 scheme.\n  enum ExprValueKind {\n    /// An r-value expression (a pr-value in the C++11 taxonomy)\n    /// produces a temporary value.\n    VK_RValue,\n\n    /// An l-value expression is a reference to an object with\n    /// independent storage.\n    VK_LValue,\n\n    /// An x-value expression is a reference to an object with\n    /// independent storage but which can be \"moved\", i.e.\n    /// efficiently cannibalized for its resources.\n    VK_XValue\n  };\n\n  /// A further classification of the kind of object referenced by an\n  /// l-value or x-value.\n  enum ExprObjectKind {\n    /// An ordinary object is located at an address in memory.\n    OK_Ordinary,\n\n    /// A bitfield object is a bitfield on a C or C++ record.\n    OK_BitField,\n\n    /// A vector component is an element or range of elements on a vector.\n    OK_VectorComponent,\n\n    /// An Objective-C property is a logical field of an Objective-C\n    /// object which is read and written via Objective-C method calls.\n    OK_ObjCProperty,\n\n    /// An Objective-C array/dictionary subscripting which reads an\n    /// object or writes at the subscripted array/dictionary element via\n    /// Objective-C method calls.\n    OK_ObjCSubscript,\n\n    /// A matrix component is a single element of a matrix.\n    OK_MatrixComponent\n  };\n\n  /// The reason why a DeclRefExpr does not constitute an odr-use.\n  enum NonOdrUseReason {\n    /// This is an odr-use.\n    NOUR_None = 0,\n    /// This name appears in an unevaluated operand.\n    NOUR_Unevaluated,\n    /// This name appears as a potential result of an lvalue-to-rvalue\n    /// conversion that is a constant expression.\n    NOUR_Constant,\n    /// This name appears as a potential result of a discarded value\n    /// expression.\n    NOUR_Discarded,\n  };\n\n  /// Describes the kind of template specialization that a\n  /// particular template specialization declaration represents.\n  enum TemplateSpecializationKind {\n    /// This template specialization was formed from a template-id but\n    /// has not yet been declared, defined, or instantiated.\n    TSK_Undeclared = 0,\n    /// This template specialization was implicitly instantiated from a\n    /// template. (C++ [temp.inst]).\n    TSK_ImplicitInstantiation,\n    /// This template specialization was declared or defined by an\n    /// explicit specialization (C++ [temp.expl.spec]) or partial\n    /// specialization (C++ [temp.class.spec]).\n    TSK_ExplicitSpecialization,\n    /// This template specialization was instantiated from a template\n    /// due to an explicit instantiation declaration request\n    /// (C++11 [temp.explicit]).\n    TSK_ExplicitInstantiationDeclaration,\n    /// This template specialization was instantiated from a template\n    /// due to an explicit instantiation definition request\n    /// (C++ [temp.explicit]).\n    TSK_ExplicitInstantiationDefinition\n  };\n\n  /// Determine whether this template specialization kind refers\n  /// to an instantiation of an entity (as opposed to a non-template or\n  /// an explicit specialization).\n  inline bool isTemplateInstantiation(TemplateSpecializationKind Kind) {\n    return Kind != TSK_Undeclared && Kind != TSK_ExplicitSpecialization;\n  }\n\n  /// True if this template specialization kind is an explicit\n  /// specialization, explicit instantiation declaration, or explicit\n  /// instantiation definition.\n  inline bool isTemplateExplicitInstantiationOrSpecialization(\n      TemplateSpecializationKind Kind) {\n    switch (Kind) {\n    case TSK_ExplicitSpecialization:\n    case TSK_ExplicitInstantiationDeclaration:\n    case TSK_ExplicitInstantiationDefinition:\n      return true;\n\n    case TSK_Undeclared:\n    case TSK_ImplicitInstantiation:\n      return false;\n    }\n    llvm_unreachable(\"bad template specialization kind\");\n  }\n\n  /// Thread storage-class-specifier.\n  enum ThreadStorageClassSpecifier {\n    TSCS_unspecified,\n    /// GNU __thread.\n    TSCS___thread,\n    /// C++11 thread_local. Implies 'static' at block scope, but not at\n    /// class scope.\n    TSCS_thread_local,\n    /// C11 _Thread_local. Must be combined with either 'static' or 'extern'\n    /// if used at block scope.\n    TSCS__Thread_local\n  };\n\n  /// Storage classes.\n  enum StorageClass {\n    // These are legal on both functions and variables.\n    SC_None,\n    SC_Extern,\n    SC_Static,\n    SC_PrivateExtern,\n\n    // These are only legal on variables.\n    SC_Auto,\n    SC_Register\n  };\n\n  /// Checks whether the given storage class is legal for functions.\n  inline bool isLegalForFunction(StorageClass SC) {\n    return SC <= SC_PrivateExtern;\n  }\n\n  /// Checks whether the given storage class is legal for variables.\n  inline bool isLegalForVariable(StorageClass SC) {\n    return true;\n  }\n\n  /// In-class initialization styles for non-static data members.\n  enum InClassInitStyle {\n    ICIS_NoInit,   ///< No in-class initializer.\n    ICIS_CopyInit, ///< Copy initialization.\n    ICIS_ListInit  ///< Direct list-initialization.\n  };\n\n  /// CallingConv - Specifies the calling convention that a function uses.\n  enum CallingConv {\n    CC_C,           // __attribute__((cdecl))\n    CC_X86StdCall,  // __attribute__((stdcall))\n    CC_X86FastCall, // __attribute__((fastcall))\n    CC_X86ThisCall, // __attribute__((thiscall))\n    CC_X86VectorCall, // __attribute__((vectorcall))\n    CC_X86Pascal,   // __attribute__((pascal))\n    CC_Win64,       // __attribute__((ms_abi))\n    CC_X86_64SysV,  // __attribute__((sysv_abi))\n    CC_X86RegCall, // __attribute__((regcall))\n    CC_AAPCS,       // __attribute__((pcs(\"aapcs\")))\n    CC_AAPCS_VFP,   // __attribute__((pcs(\"aapcs-vfp\")))\n    CC_IntelOclBicc, // __attribute__((intel_ocl_bicc))\n    CC_SpirFunction, // default for OpenCL functions on SPIR target\n    CC_OpenCLKernel, // inferred for OpenCL kernels\n    CC_Swift,        // __attribute__((swiftcall))\n    CC_PreserveMost, // __attribute__((preserve_most))\n    CC_PreserveAll,  // __attribute__((preserve_all))\n    CC_AArch64VectorCall, // __attribute__((aarch64_vector_pcs))\n  };\n\n  /// Checks whether the given calling convention supports variadic\n  /// calls. Unprototyped calls also use the variadic call rules.\n  inline bool supportsVariadicCall(CallingConv CC) {\n    switch (CC) {\n    case CC_X86StdCall:\n    case CC_X86FastCall:\n    case CC_X86ThisCall:\n    case CC_X86RegCall:\n    case CC_X86Pascal:\n    case CC_X86VectorCall:\n    case CC_SpirFunction:\n    case CC_OpenCLKernel:\n    case CC_Swift:\n      return false;\n    default:\n      return true;\n    }\n  }\n\n  /// The storage duration for an object (per C++ [basic.stc]).\n  enum StorageDuration {\n    SD_FullExpression, ///< Full-expression storage duration (for temporaries).\n    SD_Automatic,      ///< Automatic storage duration (most local variables).\n    SD_Thread,         ///< Thread storage duration.\n    SD_Static,         ///< Static storage duration.\n    SD_Dynamic         ///< Dynamic storage duration.\n  };\n\n  /// Describes the nullability of a particular type.\n  enum class NullabilityKind : uint8_t {\n    /// Values of this type can never be null.\n    NonNull = 0,\n    /// Values of this type can be null.\n    Nullable,\n    /// Whether values of this type can be null is (explicitly)\n    /// unspecified. This captures a (fairly rare) case where we\n    /// can't conclude anything about the nullability of the type even\n    /// though it has been considered.\n    Unspecified,\n    // Generally behaves like Nullable, except when used in a block parameter\n    // that was imported into a swift async method. There, swift will assume\n    // that the parameter can get null even if no error occured. _Nullable\n    // parameters are assumed to only get null on error.\n    NullableResult,\n  };\n\n  /// Return true if \\p L has a weaker nullability annotation than \\p R. The\n  /// ordering is: Unspecified < Nullable < NonNull.\n  inline bool hasWeakerNullability(NullabilityKind L, NullabilityKind R) {\n    return uint8_t(L) > uint8_t(R);\n  }\n\n  /// Retrieve the spelling of the given nullability kind.\n  llvm::StringRef getNullabilitySpelling(NullabilityKind kind,\n                                         bool isContextSensitive = false);\n\n  /// Kinds of parameter ABI.\n  enum class ParameterABI {\n    /// This parameter uses ordinary ABI rules for its type.\n    Ordinary,\n\n    /// This parameter (which must have pointer type) is a Swift\n    /// indirect result parameter.\n    SwiftIndirectResult,\n\n    /// This parameter (which must have pointer-to-pointer type) uses\n    /// the special Swift error-result ABI treatment.  There can be at\n    /// most one parameter on a given function that uses this treatment.\n    SwiftErrorResult,\n\n    /// This parameter (which must have pointer type) uses the special\n    /// Swift context-pointer ABI treatment.  There can be at\n    /// most one parameter on a given function that uses this treatment.\n    SwiftContext\n  };\n\n  /// Assigned inheritance model for a class in the MS C++ ABI. Must match order\n  /// of spellings in MSInheritanceAttr.\n  enum class MSInheritanceModel {\n    Single = 0,\n    Multiple = 1,\n    Virtual = 2,\n    Unspecified = 3,\n  };\n\n  llvm::StringRef getParameterABISpelling(ParameterABI kind);\n\n  inline llvm::StringRef getAccessSpelling(AccessSpecifier AS) {\n    switch (AS) {\n    case AccessSpecifier::AS_public:\n      return \"public\";\n    case AccessSpecifier::AS_protected:\n      return \"protected\";\n    case AccessSpecifier::AS_private:\n      return \"private\";\n    case AccessSpecifier::AS_none:\n      return {};\n    }\n    llvm_unreachable(\"Unknown AccessSpecifier\");\n  }\n} // end namespace clang\n\n#endif // LLVM_CLANG_BASIC_SPECIFIERS_H\n"}, "68": {"id": 68, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Format/Format.h", "content": "//===--- Format.h - Format C++ code -----------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Various functions to configurably format source code.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_FORMAT_FORMAT_H\n#define LLVM_CLANG_FORMAT_FORMAT_H\n\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Tooling/Core/Replacement.h\"\n#include \"clang/Tooling/Inclusions/IncludeStyle.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/Support/Regex.h\"\n#include \"llvm/Support/SourceMgr.h\"\n#include <system_error>\n\nnamespace llvm {\nnamespace vfs {\nclass FileSystem;\n}\n} // namespace llvm\n\nnamespace clang {\n\nclass Lexer;\nclass SourceManager;\nclass DiagnosticConsumer;\n\nnamespace format {\n\nenum class ParseError {\n  Success = 0,\n  Error,\n  Unsuitable,\n  BinPackTrailingCommaConflict\n};\nclass ParseErrorCategory final : public std::error_category {\npublic:\n  const char *name() const noexcept override;\n  std::string message(int EV) const override;\n};\nconst std::error_category &getParseCategory();\nstd::error_code make_error_code(ParseError e);\n\n/// The ``FormatStyle`` is used to configure the formatting to follow\n/// specific guidelines.\nstruct FormatStyle {\n  // If the BasedOn: was InheritParentConfig and this style needs the file from\n  // the parent directories. It is not part of the actual style for formatting.\n  // Thus the // instead of ///.\n  bool InheritsParentConfig;\n\n  /// The extra indent or outdent of access modifiers, e.g. ``public:``.\n  int AccessModifierOffset;\n\n  /// Different styles for aligning after open brackets.\n  enum BracketAlignmentStyle : unsigned char {\n    /// Align parameters on the open bracket, e.g.:\n    /// \\code\n    ///   someLongFunction(argument1,\n    ///                    argument2);\n    /// \\endcode\n    BAS_Align,\n    /// Don't align, instead use ``ContinuationIndentWidth``, e.g.:\n    /// \\code\n    ///   someLongFunction(argument1,\n    ///       argument2);\n    /// \\endcode\n    BAS_DontAlign,\n    /// Always break after an open bracket, if the parameters don't fit\n    /// on a single line, e.g.:\n    /// \\code\n    ///   someLongFunction(\n    ///       argument1, argument2);\n    /// \\endcode\n    BAS_AlwaysBreak,\n  };\n\n  /// If ``true``, horizontally aligns arguments after an open bracket.\n  ///\n  /// This applies to round brackets (parentheses), angle brackets and square\n  /// brackets.\n  BracketAlignmentStyle AlignAfterOpenBracket;\n\n  /// Styles for alignment of consecutive tokens. Tokens can be assignment signs\n  /// (see\n  /// ``AlignConsecutiveAssignments``), bitfield member separators (see\n  /// ``AlignConsecutiveBitFields``), names in declarations (see\n  /// ``AlignConsecutiveDeclarations``) or macro definitions (see\n  /// ``AlignConsecutiveMacros``).\n  enum AlignConsecutiveStyle {\n    ACS_None,\n    ACS_Consecutive,\n    ACS_AcrossEmptyLines,\n    ACS_AcrossComments,\n    ACS_AcrossEmptyLinesAndComments\n  };\n\n  /// Style of aligning consecutive macro definitions.\n  ///\n  /// ``Consecutive`` will result in formattings like:\n  /// \\code\n  ///   #define SHORT_NAME       42\n  ///   #define LONGER_NAME      0x007f\n  ///   #define EVEN_LONGER_NAME (2)\n  ///   #define foo(x)           (x * x)\n  ///   #define bar(y, z)        (y + z)\n  /// \\endcode\n  ///\n  /// Possible values:\n  ///\n  /// * ``ACS_None`` (in configuration: ``None``)\n  ///    Do not align macro definitions on consecutive lines.\n  ///\n  /// * ``ACS_Consecutive`` (in configuration: ``Consecutive``)\n  ///    Align macro definitions on consecutive lines. This will result in\n  ///    formattings like:\n  ///    \\code\n  ///      #define SHORT_NAME       42\n  ///      #define LONGER_NAME      0x007f\n  ///      #define EVEN_LONGER_NAME (2)\n  ///\n  ///      #define foo(x) (x * x)\n  ///      /* some comment */\n  ///      #define bar(y, z) (y + z)\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossEmptyLines`` (in configuration: ``AcrossEmptyLines``)\n  ///    Same as ACS_Consecutive, but also spans over empty lines, e.g.\n  ///    \\code\n  ///      #define SHORT_NAME       42\n  ///      #define LONGER_NAME      0x007f\n  ///      #define EVEN_LONGER_NAME (2)\n  ///\n  ///      #define foo(x)           (x * x)\n  ///      /* some comment */\n  ///      #define bar(y, z) (y + z)\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossComments`` (in configuration: ``AcrossComments``)\n  ///    Same as ACS_Consecutive, but also spans over lines only containing\n  ///    comments, e.g.\n  ///    \\code\n  ///      #define SHORT_NAME       42\n  ///      #define LONGER_NAME      0x007f\n  ///      #define EVEN_LONGER_NAME (2)\n  ///\n  ///      #define foo(x)    (x * x)\n  ///      /* some comment */\n  ///      #define bar(y, z) (y + z)\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossEmptyLinesAndComments``\n  ///   (in configuration: ``AcrossEmptyLinesAndComments``)\n  ///\n  ///    Same as ACS_Consecutive, but also spans over lines only containing\n  ///    comments and empty lines, e.g.\n  ///    \\code\n  ///      #define SHORT_NAME       42\n  ///      #define LONGER_NAME      0x007f\n  ///      #define EVEN_LONGER_NAME (2)\n  ///\n  ///      #define foo(x)           (x * x)\n  ///      /* some comment */\n  ///      #define bar(y, z)        (y + z)\n  ///    \\endcode\n  AlignConsecutiveStyle AlignConsecutiveMacros;\n\n  /// Style of aligning consecutive assignments.\n  ///\n  /// ``Consecutive`` will result in formattings like:\n  /// \\code\n  ///   int a            = 1;\n  ///   int somelongname = 2;\n  ///   double c         = 3;\n  /// \\endcode\n  ///\n  /// Possible values:\n  ///\n  /// * ``ACS_None`` (in configuration: ``None``)\n  ///    Do not align assignments on consecutive lines.\n  ///\n  /// * ``ACS_Consecutive`` (in configuration: ``Consecutive``)\n  ///    Align assignments on consecutive lines. This will result in\n  ///    formattings like:\n  ///    \\code\n  ///      int a            = 1;\n  ///      int somelongname = 2;\n  ///      double c         = 3;\n  ///\n  ///      int d = 3;\n  ///      /* A comment. */\n  ///      double e = 4;\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossEmptyLines`` (in configuration: ``AcrossEmptyLines``)\n  ///    Same as ACS_Consecutive, but also spans over empty lines, e.g.\n  ///    \\code\n  ///      int a            = 1;\n  ///      int somelongname = 2;\n  ///      double c         = 3;\n  ///\n  ///      int d            = 3;\n  ///      /* A comment. */\n  ///      double e = 4;\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossComments`` (in configuration: ``AcrossComments``)\n  ///    Same as ACS_Consecutive, but also spans over lines only containing\n  ///    comments, e.g.\n  ///    \\code\n  ///      int a            = 1;\n  ///      int somelongname = 2;\n  ///      double c         = 3;\n  ///\n  ///      int d    = 3;\n  ///      /* A comment. */\n  ///      double e = 4;\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossEmptyLinesAndComments``\n  ///   (in configuration: ``AcrossEmptyLinesAndComments``)\n  ///\n  ///    Same as ACS_Consecutive, but also spans over lines only containing\n  ///    comments and empty lines, e.g.\n  ///    \\code\n  ///      int a            = 1;\n  ///      int somelongname = 2;\n  ///      double c         = 3;\n  ///\n  ///      int d            = 3;\n  ///      /* A comment. */\n  ///      double e         = 4;\n  ///    \\endcode\n  AlignConsecutiveStyle AlignConsecutiveAssignments;\n\n  /// Style of aligning consecutive bit field.\n  ///\n  /// ``Consecutive`` will align the bitfield separators of consecutive lines.\n  /// This will result in formattings like:\n  /// \\code\n  ///   int aaaa : 1;\n  ///   int b    : 12;\n  ///   int ccc  : 8;\n  /// \\endcode\n  ///\n  /// Possible values:\n  ///\n  /// * ``ACS_None`` (in configuration: ``None``)\n  ///    Do not align bit fields on consecutive lines.\n  ///\n  /// * ``ACS_Consecutive`` (in configuration: ``Consecutive``)\n  ///    Align bit fields on consecutive lines. This will result in\n  ///    formattings like:\n  ///    \\code\n  ///      int aaaa : 1;\n  ///      int b    : 12;\n  ///      int ccc  : 8;\n  ///\n  ///      int d : 2;\n  ///      /* A comment. */\n  ///      int ee : 3;\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossEmptyLines`` (in configuration: ``AcrossEmptyLines``)\n  ///    Same as ACS_Consecutive, but also spans over empty lines, e.g.\n  ///    \\code\n  ///      int aaaa : 1;\n  ///      int b    : 12;\n  ///      int ccc  : 8;\n  ///\n  ///      int d    : 2;\n  ///      /* A comment. */\n  ///      int ee : 3;\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossComments`` (in configuration: ``AcrossComments``)\n  ///    Same as ACS_Consecutive, but also spans over lines only containing\n  ///    comments, e.g.\n  ///    \\code\n  ///      int aaaa : 1;\n  ///      int b    : 12;\n  ///      int ccc  : 8;\n  ///\n  ///      int d  : 2;\n  ///      /* A comment. */\n  ///      int ee : 3;\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossEmptyLinesAndComments``\n  ///   (in configuration: ``AcrossEmptyLinesAndComments``)\n  ///\n  ///    Same as ACS_Consecutive, but also spans over lines only containing\n  ///    comments and empty lines, e.g.\n  ///    \\code\n  ///      int aaaa : 1;\n  ///      int b    : 12;\n  ///      int ccc  : 8;\n  ///\n  ///      int d    : 2;\n  ///      /* A comment. */\n  ///      int ee   : 3;\n  ///    \\endcode\n  AlignConsecutiveStyle AlignConsecutiveBitFields;\n\n  /// Style of aligning consecutive declarations.\n  ///\n  /// ``Consecutive`` will align the declaration names of consecutive lines.\n  /// This will result in formattings like:\n  /// \\code\n  ///   int         aaaa = 12;\n  ///   float       b = 23;\n  ///   std::string ccc;\n  /// \\endcode\n  ///\n  /// Possible values:\n  ///\n  /// * ``ACS_None`` (in configuration: ``None``)\n  ///    Do not align bit declarations on consecutive lines.\n  ///\n  /// * ``ACS_Consecutive`` (in configuration: ``Consecutive``)\n  ///    Align declarations on consecutive lines. This will result in\n  ///    formattings like:\n  ///    \\code\n  ///      int         aaaa = 12;\n  ///      float       b = 23;\n  ///      std::string ccc;\n  ///\n  ///      int a = 42;\n  ///      /* A comment. */\n  ///      bool c = false;\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossEmptyLines`` (in configuration: ``AcrossEmptyLines``)\n  ///    Same as ACS_Consecutive, but also spans over empty lines, e.g.\n  ///    \\code\n  ///      int         aaaa = 12;\n  ///      float       b = 23;\n  ///      std::string ccc;\n  ///\n  ///      int         a = 42;\n  ///      /* A comment. */\n  ///      bool c = false;\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossComments`` (in configuration: ``AcrossComments``)\n  ///    Same as ACS_Consecutive, but also spans over lines only containing\n  ///    comments, e.g.\n  ///    \\code\n  ///      int         aaaa = 12;\n  ///      float       b = 23;\n  ///      std::string ccc;\n  ///\n  ///      int  a = 42;\n  ///      /* A comment. */\n  ///      bool c = false;\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossEmptyLinesAndComments``\n  ///   (in configuration: ``AcrossEmptyLinesAndComments``)\n  ///\n  ///    Same as ACS_Consecutive, but also spans over lines only containing\n  ///    comments and empty lines, e.g.\n  ///    \\code\n  ///      int         aaaa = 12;\n  ///      float       b = 23;\n  ///      std::string ccc;\n  ///\n  ///      int         a = 42;\n  ///      /* A comment. */\n  ///      bool        c = false;\n  ///    \\endcode\n  AlignConsecutiveStyle AlignConsecutiveDeclarations;\n\n  /// Different styles for aligning escaped newlines.\n  enum EscapedNewlineAlignmentStyle : unsigned char {\n    /// Don't align escaped newlines.\n    /// \\code\n    ///   #define A \\\n    ///     int aaaa; \\\n    ///     int b; \\\n    ///     int dddddddddd;\n    /// \\endcode\n    ENAS_DontAlign,\n    /// Align escaped newlines as far left as possible.\n    /// \\code\n    ///   true:\n    ///   #define A   \\\n    ///     int aaaa; \\\n    ///     int b;    \\\n    ///     int dddddddddd;\n    ///\n    ///   false:\n    /// \\endcode\n    ENAS_Left,\n    /// Align escaped newlines in the right-most column.\n    /// \\code\n    ///   #define A                                                                      \\\n    ///     int aaaa;                                                                    \\\n    ///     int b;                                                                       \\\n    ///     int dddddddddd;\n    /// \\endcode\n    ENAS_Right,\n  };\n\n  /// Options for aligning backslashes in escaped newlines.\n  EscapedNewlineAlignmentStyle AlignEscapedNewlines;\n\n  /// Different styles for aligning operands.\n  enum OperandAlignmentStyle : unsigned char {\n    /// Do not align operands of binary and ternary expressions.\n    /// The wrapped lines are indented ``ContinuationIndentWidth`` spaces from\n    /// the start of the line.\n    OAS_DontAlign,\n    /// Horizontally align operands of binary and ternary expressions.\n    ///\n    /// Specifically, this aligns operands of a single expression that needs\n    /// to be split over multiple lines, e.g.:\n    /// \\code\n    ///   int aaa = bbbbbbbbbbbbbbb +\n    ///             ccccccccccccccc;\n    /// \\endcode\n    ///\n    /// When ``BreakBeforeBinaryOperators`` is set, the wrapped operator is\n    /// aligned with the operand on the first line.\n    /// \\code\n    ///   int aaa = bbbbbbbbbbbbbbb\n    ///             + ccccccccccccccc;\n    /// \\endcode\n    OAS_Align,\n    /// Horizontally align operands of binary and ternary expressions.\n    ///\n    /// This is similar to ``AO_Align``, except when\n    /// ``BreakBeforeBinaryOperators`` is set, the operator is un-indented so\n    /// that the wrapped operand is aligned with the operand on the first line.\n    /// \\code\n    ///   int aaa = bbbbbbbbbbbbbbb\n    ///           + ccccccccccccccc;\n    /// \\endcode\n    OAS_AlignAfterOperator,\n  };\n\n  /// If ``true``, horizontally align operands of binary and ternary\n  /// expressions.\n  OperandAlignmentStyle AlignOperands;\n\n  /// If ``true``, aligns trailing comments.\n  /// \\code\n  ///   true:                                   false:\n  ///   int a;     // My comment a      vs.     int a; // My comment a\n  ///   int b = 2; // comment  b                int b = 2; // comment about b\n  /// \\endcode\n  bool AlignTrailingComments;\n\n  /// \\brief If a function call or braced initializer list doesn't fit on a\n  /// line, allow putting all arguments onto the next line, even if\n  /// ``BinPackArguments`` is ``false``.\n  /// \\code\n  ///   true:\n  ///   callFunction(\n  ///       a, b, c, d);\n  ///\n  ///   false:\n  ///   callFunction(a,\n  ///                b,\n  ///                c,\n  ///                d);\n  /// \\endcode\n  bool AllowAllArgumentsOnNextLine;\n\n  /// \\brief If a constructor definition with a member initializer list doesn't\n  /// fit on a single line, allow putting all member initializers onto the next\n  /// line, if ```ConstructorInitializerAllOnOneLineOrOnePerLine``` is true.\n  /// Note that this parameter has no effect if\n  /// ```ConstructorInitializerAllOnOneLineOrOnePerLine``` is false.\n  /// \\code\n  ///   true:\n  ///   MyClass::MyClass() :\n  ///       member0(0), member1(2) {}\n  ///\n  ///   false:\n  ///   MyClass::MyClass() :\n  ///       member0(0),\n  ///       member1(2) {}\n  bool AllowAllConstructorInitializersOnNextLine;\n\n  /// If the function declaration doesn't fit on a line,\n  /// allow putting all parameters of a function declaration onto\n  /// the next line even if ``BinPackParameters`` is ``false``.\n  /// \\code\n  ///   true:\n  ///   void myFunction(\n  ///       int a, int b, int c, int d, int e);\n  ///\n  ///   false:\n  ///   void myFunction(int a,\n  ///                   int b,\n  ///                   int c,\n  ///                   int d,\n  ///                   int e);\n  /// \\endcode\n  bool AllowAllParametersOfDeclarationOnNextLine;\n\n  /// Allow short enums on a single line.\n  /// \\code\n  ///   true:\n  ///   enum { A, B } myEnum;\n  ///\n  ///   false:\n  ///   enum\n  ///   {\n  ///     A,\n  ///     B\n  ///   } myEnum;\n  /// \\endcode\n  bool AllowShortEnumsOnASingleLine;\n\n  /// Different styles for merging short blocks containing at most one\n  /// statement.\n  enum ShortBlockStyle : unsigned char {\n    /// Never merge blocks into a single line.\n    /// \\code\n    ///   while (true) {\n    ///   }\n    ///   while (true) {\n    ///     continue;\n    ///   }\n    /// \\endcode\n    SBS_Never,\n    /// Only merge empty blocks.\n    /// \\code\n    ///   while (true) {}\n    ///   while (true) {\n    ///     continue;\n    ///   }\n    /// \\endcode\n    SBS_Empty,\n    /// Always merge short blocks into a single line.\n    /// \\code\n    ///   while (true) {}\n    ///   while (true) { continue; }\n    /// \\endcode\n    SBS_Always,\n  };\n\n  /// Dependent on the value, ``while (true) { continue; }`` can be put on a\n  /// single line.\n  ShortBlockStyle AllowShortBlocksOnASingleLine;\n\n  /// If ``true``, short case labels will be contracted to a single line.\n  /// \\code\n  ///   true:                                   false:\n  ///   switch (a) {                    vs.     switch (a) {\n  ///   case 1: x = 1; break;                   case 1:\n  ///   case 2: return;                           x = 1;\n  ///   }                                         break;\n  ///                                           case 2:\n  ///                                             return;\n  ///                                           }\n  /// \\endcode\n  bool AllowShortCaseLabelsOnASingleLine;\n\n  /// Different styles for merging short functions containing at most one\n  /// statement.\n  enum ShortFunctionStyle : unsigned char {\n    /// Never merge functions into a single line.\n    SFS_None,\n    /// Only merge functions defined inside a class. Same as \"inline\",\n    /// except it does not implies \"empty\": i.e. top level empty functions\n    /// are not merged either.\n    /// \\code\n    ///   class Foo {\n    ///     void f() { foo(); }\n    ///   };\n    ///   void f() {\n    ///     foo();\n    ///   }\n    ///   void f() {\n    ///   }\n    /// \\endcode\n    SFS_InlineOnly,\n    /// Only merge empty functions.\n    /// \\code\n    ///   void f() {}\n    ///   void f2() {\n    ///     bar2();\n    ///   }\n    /// \\endcode\n    SFS_Empty,\n    /// Only merge functions defined inside a class. Implies \"empty\".\n    /// \\code\n    ///   class Foo {\n    ///     void f() { foo(); }\n    ///   };\n    ///   void f() {\n    ///     foo();\n    ///   }\n    ///   void f() {}\n    /// \\endcode\n    SFS_Inline,\n    /// Merge all functions fitting on a single line.\n    /// \\code\n    ///   class Foo {\n    ///     void f() { foo(); }\n    ///   };\n    ///   void f() { bar(); }\n    /// \\endcode\n    SFS_All,\n  };\n\n  /// Dependent on the value, ``int f() { return 0; }`` can be put on a\n  /// single line.\n  ShortFunctionStyle AllowShortFunctionsOnASingleLine;\n\n  /// Different styles for handling short if lines\n  enum ShortIfStyle : unsigned char {\n    /// Never put short ifs on the same line.\n    /// \\code\n    ///   if (a)\n    ///     return ;\n    ///   else {\n    ///     return;\n    ///   }\n    /// \\endcode\n    SIS_Never,\n    /// Without else put short ifs on the same line only if\n    /// the else is not a compound statement.\n    /// \\code\n    ///   if (a) return;\n    ///   else\n    ///     return;\n    /// \\endcode\n    SIS_WithoutElse,\n    /// Always put short ifs on the same line if\n    /// the else is not a compound statement or not.\n    /// \\code\n    ///   if (a) return;\n    ///   else {\n    ///     return;\n    ///   }\n    /// \\endcode\n    SIS_Always,\n  };\n\n  /// If ``true``, ``if (a) return;`` can be put on a single line.\n  ShortIfStyle AllowShortIfStatementsOnASingleLine;\n\n  /// Different styles for merging short lambdas containing at most one\n  /// statement.\n  enum ShortLambdaStyle : unsigned char {\n    /// Never merge lambdas into a single line.\n    SLS_None,\n    /// Only merge empty lambdas.\n    /// \\code\n    ///   auto lambda = [](int a) {}\n    ///   auto lambda2 = [](int a) {\n    ///       return a;\n    ///   };\n    /// \\endcode\n    SLS_Empty,\n    /// Merge lambda into a single line if argument of a function.\n    /// \\code\n    ///   auto lambda = [](int a) {\n    ///       return a;\n    ///   };\n    ///   sort(a.begin(), a.end(), ()[] { return x < y; })\n    /// \\endcode\n    SLS_Inline,\n    /// Merge all lambdas fitting on a single line.\n    /// \\code\n    ///   auto lambda = [](int a) {}\n    ///   auto lambda2 = [](int a) { return a; };\n    /// \\endcode\n    SLS_All,\n  };\n\n  /// Dependent on the value, ``auto lambda []() { return 0; }`` can be put on a\n  /// single line.\n  ShortLambdaStyle AllowShortLambdasOnASingleLine;\n\n  /// If ``true``, ``while (true) continue;`` can be put on a single\n  /// line.\n  bool AllowShortLoopsOnASingleLine;\n\n  /// Different ways to break after the function definition return type.\n  /// This option is **deprecated** and is retained for backwards compatibility.\n  enum DefinitionReturnTypeBreakingStyle : unsigned char {\n    /// Break after return type automatically.\n    /// ``PenaltyReturnTypeOnItsOwnLine`` is taken into account.\n    DRTBS_None,\n    /// Always break after the return type.\n    DRTBS_All,\n    /// Always break after the return types of top-level functions.\n    DRTBS_TopLevel,\n  };\n\n  /// Different ways to break after the function definition or\n  /// declaration return type.\n  enum ReturnTypeBreakingStyle : unsigned char {\n    /// Break after return type automatically.\n    /// ``PenaltyReturnTypeOnItsOwnLine`` is taken into account.\n    /// \\code\n    ///   class A {\n    ///     int f() { return 0; };\n    ///   };\n    ///   int f();\n    ///   int f() { return 1; }\n    /// \\endcode\n    RTBS_None,\n    /// Always break after the return type.\n    /// \\code\n    ///   class A {\n    ///     int\n    ///     f() {\n    ///       return 0;\n    ///     };\n    ///   };\n    ///   int\n    ///   f();\n    ///   int\n    ///   f() {\n    ///     return 1;\n    ///   }\n    /// \\endcode\n    RTBS_All,\n    /// Always break after the return types of top-level functions.\n    /// \\code\n    ///   class A {\n    ///     int f() { return 0; };\n    ///   };\n    ///   int\n    ///   f();\n    ///   int\n    ///   f() {\n    ///     return 1;\n    ///   }\n    /// \\endcode\n    RTBS_TopLevel,\n    /// Always break after the return type of function definitions.\n    /// \\code\n    ///   class A {\n    ///     int\n    ///     f() {\n    ///       return 0;\n    ///     };\n    ///   };\n    ///   int f();\n    ///   int\n    ///   f() {\n    ///     return 1;\n    ///   }\n    /// \\endcode\n    RTBS_AllDefinitions,\n    /// Always break after the return type of top-level definitions.\n    /// \\code\n    ///   class A {\n    ///     int f() { return 0; };\n    ///   };\n    ///   int f();\n    ///   int\n    ///   f() {\n    ///     return 1;\n    ///   }\n    /// \\endcode\n    RTBS_TopLevelDefinitions,\n  };\n\n  /// The function definition return type breaking style to use.  This\n  /// option is **deprecated** and is retained for backwards compatibility.\n  DefinitionReturnTypeBreakingStyle AlwaysBreakAfterDefinitionReturnType;\n\n  /// The function declaration return type breaking style to use.\n  ReturnTypeBreakingStyle AlwaysBreakAfterReturnType;\n\n  /// If ``true``, always break before multiline string literals.\n  ///\n  /// This flag is mean to make cases where there are multiple multiline strings\n  /// in a file look more consistent. Thus, it will only take effect if wrapping\n  /// the string at that point leads to it being indented\n  /// ``ContinuationIndentWidth`` spaces from the start of the line.\n  /// \\code\n  ///    true:                                  false:\n  ///    aaaa =                         vs.     aaaa = \"bbbb\"\n  ///        \"bbbb\"                                    \"cccc\";\n  ///        \"cccc\";\n  /// \\endcode\n  bool AlwaysBreakBeforeMultilineStrings;\n\n  /// Different ways to break after the template declaration.\n  enum BreakTemplateDeclarationsStyle : unsigned char {\n    /// Do not force break before declaration.\n    /// ``PenaltyBreakTemplateDeclaration`` is taken into account.\n    /// \\code\n    ///    template <typename T> T foo() {\n    ///    }\n    ///    template <typename T> T foo(int aaaaaaaaaaaaaaaaaaaaa,\n    ///                                int bbbbbbbbbbbbbbbbbbbbb) {\n    ///    }\n    /// \\endcode\n    BTDS_No,\n    /// Force break after template declaration only when the following\n    /// declaration spans multiple lines.\n    /// \\code\n    ///    template <typename T> T foo() {\n    ///    }\n    ///    template <typename T>\n    ///    T foo(int aaaaaaaaaaaaaaaaaaaaa,\n    ///          int bbbbbbbbbbbbbbbbbbbbb) {\n    ///    }\n    /// \\endcode\n    BTDS_MultiLine,\n    /// Always break after template declaration.\n    /// \\code\n    ///    template <typename T>\n    ///    T foo() {\n    ///    }\n    ///    template <typename T>\n    ///    T foo(int aaaaaaaaaaaaaaaaaaaaa,\n    ///          int bbbbbbbbbbbbbbbbbbbbb) {\n    ///    }\n    /// \\endcode\n    BTDS_Yes\n  };\n\n  /// The template declaration breaking style to use.\n  BreakTemplateDeclarationsStyle AlwaysBreakTemplateDeclarations;\n\n  /// A vector of strings that should be interpreted as attributes/qualifiers\n  /// instead of identifiers. This can be useful for language extensions or\n  /// static analyzer annotations.\n  ///\n  /// For example:\n  /// \\code\n  ///   x = (char *__capability)&y;\n  ///   int function(void) __ununsed;\n  ///   void only_writes_to_buffer(char *__output buffer);\n  /// \\endcode\n  ///\n  /// In the .clang-format configuration file, this can be configured like:\n  /// \\code{.yaml}\n  ///   AttributeMacros: ['__capability', '__output', '__ununsed']\n  /// \\endcode\n  ///\n  std::vector<std::string> AttributeMacros;\n\n  /// If ``false``, a function call's arguments will either be all on the\n  /// same line or will have one line each.\n  /// \\code\n  ///   true:\n  ///   void f() {\n  ///     f(aaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaa,\n  ///       aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\n  ///   }\n  ///\n  ///   false:\n  ///   void f() {\n  ///     f(aaaaaaaaaaaaaaaaaaaa,\n  ///       aaaaaaaaaaaaaaaaaaaa,\n  ///       aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\n  ///   }\n  /// \\endcode\n  bool BinPackArguments;\n\n  /// The style of inserting trailing commas into container literals.\n  enum TrailingCommaStyle : unsigned char {\n    /// Do not insert trailing commas.\n    TCS_None,\n    /// Insert trailing commas in container literals that were wrapped over\n    /// multiple lines. Note that this is conceptually incompatible with\n    /// bin-packing, because the trailing comma is used as an indicator\n    /// that a container should be formatted one-per-line (i.e. not bin-packed).\n    /// So inserting a trailing comma counteracts bin-packing.\n    TCS_Wrapped,\n  };\n\n  /// If set to ``TCS_Wrapped`` will insert trailing commas in container\n  /// literals (arrays and objects) that wrap across multiple lines.\n  /// It is currently only available for JavaScript\n  /// and disabled by default ``TCS_None``.\n  /// ``InsertTrailingCommas`` cannot be used together with ``BinPackArguments``\n  /// as inserting the comma disables bin-packing.\n  /// \\code\n  ///   TSC_Wrapped:\n  ///   const someArray = [\n  ///   aaaaaaaaaaaaaaaaaaaaaaaaaa,\n  ///   aaaaaaaaaaaaaaaaaaaaaaaaaa,\n  ///   aaaaaaaaaaaaaaaaaaaaaaaaaa,\n  ///   //                        ^ inserted\n  ///   ]\n  /// \\endcode\n  TrailingCommaStyle InsertTrailingCommas;\n\n  /// If ``false``, a function declaration's or function definition's\n  /// parameters will either all be on the same line or will have one line each.\n  /// \\code\n  ///   true:\n  ///   void f(int aaaaaaaaaaaaaaaaaaaa, int aaaaaaaaaaaaaaaaaaaa,\n  ///          int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}\n  ///\n  ///   false:\n  ///   void f(int aaaaaaaaaaaaaaaaaaaa,\n  ///          int aaaaaaaaaaaaaaaaaaaa,\n  ///          int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}\n  /// \\endcode\n  bool BinPackParameters;\n\n  /// The style of wrapping parameters on the same line (bin-packed) or\n  /// on one line each.\n  enum BinPackStyle : unsigned char {\n    /// Automatically determine parameter bin-packing behavior.\n    BPS_Auto,\n    /// Always bin-pack parameters.\n    BPS_Always,\n    /// Never bin-pack parameters.\n    BPS_Never,\n  };\n\n  /// The style of breaking before or after binary operators.\n  enum BinaryOperatorStyle : unsigned char {\n    /// Break after operators.\n    /// \\code\n    ///    LooooooooooongType loooooooooooooooooooooongVariable =\n    ///        someLooooooooooooooooongFunction();\n    ///\n    ///    bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +\n    ///                         aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==\n    ///                     aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &&\n    ///                 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa >\n    ///                     ccccccccccccccccccccccccccccccccccccccccc;\n    /// \\endcode\n    BOS_None,\n    /// Break before operators that aren't assignments.\n    /// \\code\n    ///    LooooooooooongType loooooooooooooooooooooongVariable =\n    ///        someLooooooooooooooooongFunction();\n    ///\n    ///    bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n    ///                         + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n    ///                     == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n    ///                 && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n    ///                        > ccccccccccccccccccccccccccccccccccccccccc;\n    /// \\endcode\n    BOS_NonAssignment,\n    /// Break before operators.\n    /// \\code\n    ///    LooooooooooongType loooooooooooooooooooooongVariable\n    ///        = someLooooooooooooooooongFunction();\n    ///\n    ///    bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n    ///                         + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n    ///                     == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n    ///                 && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n    ///                        > ccccccccccccccccccccccccccccccccccccccccc;\n    /// \\endcode\n    BOS_All,\n  };\n\n  /// The way to wrap binary operators.\n  BinaryOperatorStyle BreakBeforeBinaryOperators;\n\n  /// Different ways to attach braces to their surrounding context.\n  enum BraceBreakingStyle : unsigned char {\n    /// Always attach braces to surrounding context.\n    /// \\code\n    ///   namespace N {\n    ///   enum E {\n    ///     E1,\n    ///     E2,\n    ///   };\n    ///\n    ///   class C {\n    ///   public:\n    ///     C();\n    ///   };\n    ///\n    ///   bool baz(int i) {\n    ///     try {\n    ///       do {\n    ///         switch (i) {\n    ///         case 1: {\n    ///           foobar();\n    ///           break;\n    ///         }\n    ///         default: {\n    ///           break;\n    ///         }\n    ///         }\n    ///       } while (--i);\n    ///       return true;\n    ///     } catch (...) {\n    ///       handleError();\n    ///       return false;\n    ///     }\n    ///   }\n    ///\n    ///   void foo(bool b) {\n    ///     if (b) {\n    ///       baz(2);\n    ///     } else {\n    ///       baz(5);\n    ///     }\n    ///   }\n    ///\n    ///   void bar() { foo(true); }\n    ///   } // namespace N\n    /// \\endcode\n    BS_Attach,\n    /// Like ``Attach``, but break before braces on function, namespace and\n    /// class definitions.\n    /// \\code\n    ///   namespace N\n    ///   {\n    ///   enum E {\n    ///     E1,\n    ///     E2,\n    ///   };\n    ///\n    ///   class C\n    ///   {\n    ///   public:\n    ///     C();\n    ///   };\n    ///\n    ///   bool baz(int i)\n    ///   {\n    ///     try {\n    ///       do {\n    ///         switch (i) {\n    ///         case 1: {\n    ///           foobar();\n    ///           break;\n    ///         }\n    ///         default: {\n    ///           break;\n    ///         }\n    ///         }\n    ///       } while (--i);\n    ///       return true;\n    ///     } catch (...) {\n    ///       handleError();\n    ///       return false;\n    ///     }\n    ///   }\n    ///\n    ///   void foo(bool b)\n    ///   {\n    ///     if (b) {\n    ///       baz(2);\n    ///     } else {\n    ///       baz(5);\n    ///     }\n    ///   }\n    ///\n    ///   void bar() { foo(true); }\n    ///   } // namespace N\n    /// \\endcode\n    BS_Linux,\n    /// Like ``Attach``, but break before braces on enum, function, and record\n    /// definitions.\n    /// \\code\n    ///   namespace N {\n    ///   enum E\n    ///   {\n    ///     E1,\n    ///     E2,\n    ///   };\n    ///\n    ///   class C\n    ///   {\n    ///   public:\n    ///     C();\n    ///   };\n    ///\n    ///   bool baz(int i)\n    ///   {\n    ///     try {\n    ///       do {\n    ///         switch (i) {\n    ///         case 1: {\n    ///           foobar();\n    ///           break;\n    ///         }\n    ///         default: {\n    ///           break;\n    ///         }\n    ///         }\n    ///       } while (--i);\n    ///       return true;\n    ///     } catch (...) {\n    ///       handleError();\n    ///       return false;\n    ///     }\n    ///   }\n    ///\n    ///   void foo(bool b)\n    ///   {\n    ///     if (b) {\n    ///       baz(2);\n    ///     } else {\n    ///       baz(5);\n    ///     }\n    ///   }\n    ///\n    ///   void bar() { foo(true); }\n    ///   } // namespace N\n    /// \\endcode\n    BS_Mozilla,\n    /// Like ``Attach``, but break before function definitions, ``catch``, and\n    /// ``else``.\n    /// \\code\n    ///   namespace N {\n    ///   enum E {\n    ///     E1,\n    ///     E2,\n    ///   };\n    ///\n    ///   class C {\n    ///   public:\n    ///     C();\n    ///   };\n    ///\n    ///   bool baz(int i)\n    ///   {\n    ///     try {\n    ///       do {\n    ///         switch (i) {\n    ///         case 1: {\n    ///           foobar();\n    ///           break;\n    ///         }\n    ///         default: {\n    ///           break;\n    ///         }\n    ///         }\n    ///       } while (--i);\n    ///       return true;\n    ///     }\n    ///     catch (...) {\n    ///       handleError();\n    ///       return false;\n    ///     }\n    ///   }\n    ///\n    ///   void foo(bool b)\n    ///   {\n    ///     if (b) {\n    ///       baz(2);\n    ///     }\n    ///     else {\n    ///       baz(5);\n    ///     }\n    ///   }\n    ///\n    ///   void bar() { foo(true); }\n    ///   } // namespace N\n    /// \\endcode\n    BS_Stroustrup,\n    /// Always break before braces.\n    /// \\code\n    ///   namespace N\n    ///   {\n    ///   enum E\n    ///   {\n    ///     E1,\n    ///     E2,\n    ///   };\n    ///\n    ///   class C\n    ///   {\n    ///   public:\n    ///     C();\n    ///   };\n    ///\n    ///   bool baz(int i)\n    ///   {\n    ///     try\n    ///     {\n    ///       do\n    ///       {\n    ///         switch (i)\n    ///         {\n    ///         case 1:\n    ///         {\n    ///           foobar();\n    ///           break;\n    ///         }\n    ///         default:\n    ///         {\n    ///           break;\n    ///         }\n    ///         }\n    ///       } while (--i);\n    ///       return true;\n    ///     }\n    ///     catch (...)\n    ///     {\n    ///       handleError();\n    ///       return false;\n    ///     }\n    ///   }\n    ///\n    ///   void foo(bool b)\n    ///   {\n    ///     if (b)\n    ///     {\n    ///       baz(2);\n    ///     }\n    ///     else\n    ///     {\n    ///       baz(5);\n    ///     }\n    ///   }\n    ///\n    ///   void bar() { foo(true); }\n    ///   } // namespace N\n    /// \\endcode\n    BS_Allman,\n    /// Like ``Allman`` but always indent braces and line up code with braces.\n    /// \\code\n    ///   namespace N\n    ///     {\n    ///   enum E\n    ///     {\n    ///     E1,\n    ///     E2,\n    ///     };\n    ///\n    ///   class C\n    ///     {\n    ///   public:\n    ///     C();\n    ///     };\n    ///\n    ///   bool baz(int i)\n    ///     {\n    ///     try\n    ///       {\n    ///       do\n    ///         {\n    ///         switch (i)\n    ///           {\n    ///           case 1:\n    ///           {\n    ///           foobar();\n    ///           break;\n    ///           }\n    ///           default:\n    ///           {\n    ///           break;\n    ///           }\n    ///           }\n    ///         } while (--i);\n    ///       return true;\n    ///       }\n    ///     catch (...)\n    ///       {\n    ///       handleError();\n    ///       return false;\n    ///       }\n    ///     }\n    ///\n    ///   void foo(bool b)\n    ///     {\n    ///     if (b)\n    ///       {\n    ///       baz(2);\n    ///       }\n    ///     else\n    ///       {\n    ///       baz(5);\n    ///       }\n    ///     }\n    ///\n    ///   void bar() { foo(true); }\n    ///     } // namespace N\n    /// \\endcode\n    BS_Whitesmiths,\n    /// Always break before braces and add an extra level of indentation to\n    /// braces of control statements, not to those of class, function\n    /// or other definitions.\n    /// \\code\n    ///   namespace N\n    ///   {\n    ///   enum E\n    ///   {\n    ///     E1,\n    ///     E2,\n    ///   };\n    ///\n    ///   class C\n    ///   {\n    ///   public:\n    ///     C();\n    ///   };\n    ///\n    ///   bool baz(int i)\n    ///   {\n    ///     try\n    ///       {\n    ///         do\n    ///           {\n    ///             switch (i)\n    ///               {\n    ///               case 1:\n    ///                 {\n    ///                   foobar();\n    ///                   break;\n    ///                 }\n    ///               default:\n    ///                 {\n    ///                   break;\n    ///                 }\n    ///               }\n    ///           }\n    ///         while (--i);\n    ///         return true;\n    ///       }\n    ///     catch (...)\n    ///       {\n    ///         handleError();\n    ///         return false;\n    ///       }\n    ///   }\n    ///\n    ///   void foo(bool b)\n    ///   {\n    ///     if (b)\n    ///       {\n    ///         baz(2);\n    ///       }\n    ///     else\n    ///       {\n    ///         baz(5);\n    ///       }\n    ///   }\n    ///\n    ///   void bar() { foo(true); }\n    ///   } // namespace N\n    /// \\endcode\n    BS_GNU,\n    /// Like ``Attach``, but break before functions.\n    /// \\code\n    ///   namespace N {\n    ///   enum E {\n    ///     E1,\n    ///     E2,\n    ///   };\n    ///\n    ///   class C {\n    ///   public:\n    ///     C();\n    ///   };\n    ///\n    ///   bool baz(int i)\n    ///   {\n    ///     try {\n    ///       do {\n    ///         switch (i) {\n    ///         case 1: {\n    ///           foobar();\n    ///           break;\n    ///         }\n    ///         default: {\n    ///           break;\n    ///         }\n    ///         }\n    ///       } while (--i);\n    ///       return true;\n    ///     } catch (...) {\n    ///       handleError();\n    ///       return false;\n    ///     }\n    ///   }\n    ///\n    ///   void foo(bool b)\n    ///   {\n    ///     if (b) {\n    ///       baz(2);\n    ///     } else {\n    ///       baz(5);\n    ///     }\n    ///   }\n    ///\n    ///   void bar() { foo(true); }\n    ///   } // namespace N\n    /// \\endcode\n    BS_WebKit,\n    /// Configure each individual brace in `BraceWrapping`.\n    BS_Custom\n  };\n\n  /// The brace breaking style to use.\n  BraceBreakingStyle BreakBeforeBraces;\n\n  /// Different ways to wrap braces after control statements.\n  enum BraceWrappingAfterControlStatementStyle : unsigned char {\n    /// Never wrap braces after a control statement.\n    /// \\code\n    ///   if (foo()) {\n    ///   } else {\n    ///   }\n    ///   for (int i = 0; i < 10; ++i) {\n    ///   }\n    /// \\endcode\n    BWACS_Never,\n    /// Only wrap braces after a multi-line control statement.\n    /// \\code\n    ///   if (foo && bar &&\n    ///       baz)\n    ///   {\n    ///     quux();\n    ///   }\n    ///   while (foo || bar) {\n    ///   }\n    /// \\endcode\n    BWACS_MultiLine,\n    /// Always wrap braces after a control statement.\n    /// \\code\n    ///   if (foo())\n    ///   {\n    ///   } else\n    ///   {}\n    ///   for (int i = 0; i < 10; ++i)\n    ///   {}\n    /// \\endcode\n    BWACS_Always\n  };\n\n  /// Precise control over the wrapping of braces.\n  /// \\code\n  ///   # Should be declared this way:\n  ///   BreakBeforeBraces: Custom\n  ///   BraceWrapping:\n  ///       AfterClass: true\n  /// \\endcode\n  struct BraceWrappingFlags {\n    /// Wrap case labels.\n    /// \\code\n    ///   false:                                true:\n    ///   switch (foo) {                vs.     switch (foo) {\n    ///     case 1: {                             case 1:\n    ///       bar();                              {\n    ///       break;                                bar();\n    ///     }                                       break;\n    ///     default: {                            }\n    ///       plop();                             default:\n    ///     }                                     {\n    ///   }                                         plop();\n    ///                                           }\n    ///                                         }\n    /// \\endcode\n    bool AfterCaseLabel;\n    /// Wrap class definitions.\n    /// \\code\n    ///   true:\n    ///   class foo {};\n    ///\n    ///   false:\n    ///   class foo\n    ///   {};\n    /// \\endcode\n    bool AfterClass;\n\n    /// Wrap control statements (``if``/``for``/``while``/``switch``/..).\n    BraceWrappingAfterControlStatementStyle AfterControlStatement;\n    /// Wrap enum definitions.\n    /// \\code\n    ///   true:\n    ///   enum X : int\n    ///   {\n    ///     B\n    ///   };\n    ///\n    ///   false:\n    ///   enum X : int { B };\n    /// \\endcode\n    bool AfterEnum;\n    /// Wrap function definitions.\n    /// \\code\n    ///   true:\n    ///   void foo()\n    ///   {\n    ///     bar();\n    ///     bar2();\n    ///   }\n    ///\n    ///   false:\n    ///   void foo() {\n    ///     bar();\n    ///     bar2();\n    ///   }\n    /// \\endcode\n    bool AfterFunction;\n    /// Wrap namespace definitions.\n    /// \\code\n    ///   true:\n    ///   namespace\n    ///   {\n    ///   int foo();\n    ///   int bar();\n    ///   }\n    ///\n    ///   false:\n    ///   namespace {\n    ///   int foo();\n    ///   int bar();\n    ///   }\n    /// \\endcode\n    bool AfterNamespace;\n    /// Wrap ObjC definitions (interfaces, implementations...).\n    /// \\note @autoreleasepool and @synchronized blocks are wrapped\n    /// according to `AfterControlStatement` flag.\n    bool AfterObjCDeclaration;\n    /// Wrap struct definitions.\n    /// \\code\n    ///   true:\n    ///   struct foo\n    ///   {\n    ///     int x;\n    ///   };\n    ///\n    ///   false:\n    ///   struct foo {\n    ///     int x;\n    ///   };\n    /// \\endcode\n    bool AfterStruct;\n    /// Wrap union definitions.\n    /// \\code\n    ///   true:\n    ///   union foo\n    ///   {\n    ///     int x;\n    ///   }\n    ///\n    ///   false:\n    ///   union foo {\n    ///     int x;\n    ///   }\n    /// \\endcode\n    bool AfterUnion;\n    /// Wrap extern blocks.\n    /// \\code\n    ///   true:\n    ///   extern \"C\"\n    ///   {\n    ///     int foo();\n    ///   }\n    ///\n    ///   false:\n    ///   extern \"C\" {\n    ///   int foo();\n    ///   }\n    /// \\endcode\n    bool AfterExternBlock; // Partially superseded by IndentExternBlock\n    /// Wrap before ``catch``.\n    /// \\code\n    ///   true:\n    ///   try {\n    ///     foo();\n    ///   }\n    ///   catch () {\n    ///   }\n    ///\n    ///   false:\n    ///   try {\n    ///     foo();\n    ///   } catch () {\n    ///   }\n    /// \\endcode\n    bool BeforeCatch;\n    /// Wrap before ``else``.\n    /// \\code\n    ///   true:\n    ///   if (foo()) {\n    ///   }\n    ///   else {\n    ///   }\n    ///\n    ///   false:\n    ///   if (foo()) {\n    ///   } else {\n    ///   }\n    /// \\endcode\n    bool BeforeElse;\n    /// Wrap lambda block.\n    /// \\code\n    ///   true:\n    ///   connect(\n    ///     []()\n    ///     {\n    ///       foo();\n    ///       bar();\n    ///     });\n    ///\n    ///   false:\n    ///   connect([]() {\n    ///     foo();\n    ///     bar();\n    ///   });\n    /// \\endcode\n    bool BeforeLambdaBody;\n    /// Wrap before ``while``.\n    /// \\code\n    ///   true:\n    ///   do {\n    ///     foo();\n    ///   }\n    ///   while (1);\n    ///\n    ///   false:\n    ///   do {\n    ///     foo();\n    ///   } while (1);\n    /// \\endcode\n    bool BeforeWhile;\n    /// Indent the wrapped braces themselves.\n    bool IndentBraces;\n    /// If ``false``, empty function body can be put on a single line.\n    /// This option is used only if the opening brace of the function has\n    /// already been wrapped, i.e. the `AfterFunction` brace wrapping mode is\n    /// set, and the function could/should not be put on a single line (as per\n    /// `AllowShortFunctionsOnASingleLine` and constructor formatting options).\n    /// \\code\n    ///   int f()   vs.   int f()\n    ///   {}              {\n    ///                   }\n    /// \\endcode\n    ///\n    bool SplitEmptyFunction;\n    /// If ``false``, empty record (e.g. class, struct or union) body\n    /// can be put on a single line. This option is used only if the opening\n    /// brace of the record has already been wrapped, i.e. the `AfterClass`\n    /// (for classes) brace wrapping mode is set.\n    /// \\code\n    ///   class Foo   vs.  class Foo\n    ///   {}               {\n    ///                    }\n    /// \\endcode\n    ///\n    bool SplitEmptyRecord;\n    /// If ``false``, empty namespace body can be put on a single line.\n    /// This option is used only if the opening brace of the namespace has\n    /// already been wrapped, i.e. the `AfterNamespace` brace wrapping mode is\n    /// set.\n    /// \\code\n    ///   namespace Foo   vs.  namespace Foo\n    ///   {}                   {\n    ///                        }\n    /// \\endcode\n    ///\n    bool SplitEmptyNamespace;\n  };\n\n  /// Control of individual brace wrapping cases.\n  ///\n  /// If ``BreakBeforeBraces`` is set to ``BS_Custom``, use this to specify how\n  /// each individual brace case should be handled. Otherwise, this is ignored.\n  /// \\code{.yaml}\n  ///   # Example of usage:\n  ///   BreakBeforeBraces: Custom\n  ///   BraceWrapping:\n  ///     AfterEnum: true\n  ///     AfterStruct: false\n  ///     SplitEmptyFunction: false\n  /// \\endcode\n  BraceWrappingFlags BraceWrapping;\n\n  /// If ``true``, concept will be placed on a new line.\n  /// \\code\n  ///   true:\n  ///    template<typename T>\n  ///    concept ...\n  ///\n  ///   false:\n  ///    template<typename T> concept ...\n  /// \\endcode\n  bool BreakBeforeConceptDeclarations;\n\n  /// If ``true``, ternary operators will be placed after line breaks.\n  /// \\code\n  ///    true:\n  ///    veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription\n  ///        ? firstValue\n  ///        : SecondValueVeryVeryVeryVeryLong;\n  ///\n  ///    false:\n  ///    veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ?\n  ///        firstValue :\n  ///        SecondValueVeryVeryVeryVeryLong;\n  /// \\endcode\n  bool BreakBeforeTernaryOperators;\n\n  /// Different ways to break initializers.\n  enum BreakConstructorInitializersStyle : unsigned char {\n    /// Break constructor initializers before the colon and after the commas.\n    /// \\code\n    ///    Constructor()\n    ///        : initializer1(),\n    ///          initializer2()\n    /// \\endcode\n    BCIS_BeforeColon,\n    /// Break constructor initializers before the colon and commas, and align\n    /// the commas with the colon.\n    /// \\code\n    ///    Constructor()\n    ///        : initializer1()\n    ///        , initializer2()\n    /// \\endcode\n    BCIS_BeforeComma,\n    /// Break constructor initializers after the colon and commas.\n    /// \\code\n    ///    Constructor() :\n    ///        initializer1(),\n    ///        initializer2()\n    /// \\endcode\n    BCIS_AfterColon\n  };\n\n  /// The constructor initializers style to use.\n  BreakConstructorInitializersStyle BreakConstructorInitializers;\n\n  /// Break after each annotation on a field in Java files.\n  /// \\code{.java}\n  ///    true:                                  false:\n  ///    @Partial                       vs.     @Partial @Mock DataLoad loader;\n  ///    @Mock\n  ///    DataLoad loader;\n  /// \\endcode\n  bool BreakAfterJavaFieldAnnotations;\n\n  /// Allow breaking string literals when formatting.\n  /// \\code\n  ///    true:\n  ///    const char* x = \"veryVeryVeryVeryVeryVe\"\n  ///                    \"ryVeryVeryVeryVeryVery\"\n  ///                    \"VeryLongString\";\n  ///\n  ///    false:\n  ///    const char* x =\n  ///      \"veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString\";\n  /// \\endcode\n  bool BreakStringLiterals;\n\n  /// The column limit.\n  ///\n  /// A column limit of ``0`` means that there is no column limit. In this case,\n  /// clang-format will respect the input's line breaking decisions within\n  /// statements unless they contradict other rules.\n  unsigned ColumnLimit;\n\n  /// A regular expression that describes comments with special meaning,\n  /// which should not be split into lines or otherwise changed.\n  /// \\code\n  ///    // CommentPragmas: '^ FOOBAR pragma:'\n  ///    // Will leave the following line unaffected\n  ///    #include <vector> // FOOBAR pragma: keep\n  /// \\endcode\n  std::string CommentPragmas;\n\n  /// Different ways to break inheritance list.\n  enum BreakInheritanceListStyle : unsigned char {\n    /// Break inheritance list before the colon and after the commas.\n    /// \\code\n    ///    class Foo\n    ///        : Base1,\n    ///          Base2\n    ///    {};\n    /// \\endcode\n    BILS_BeforeColon,\n    /// Break inheritance list before the colon and commas, and align\n    /// the commas with the colon.\n    /// \\code\n    ///    class Foo\n    ///        : Base1\n    ///        , Base2\n    ///    {};\n    /// \\endcode\n    BILS_BeforeComma,\n    /// Break inheritance list after the colon and commas.\n    /// \\code\n    ///    class Foo :\n    ///        Base1,\n    ///        Base2\n    ///    {};\n    /// \\endcode\n    BILS_AfterColon\n  };\n\n  /// The inheritance list style to use.\n  BreakInheritanceListStyle BreakInheritanceList;\n\n  /// If ``true``, consecutive namespace declarations will be on the same\n  /// line. If ``false``, each namespace is declared on a new line.\n  /// \\code\n  ///   true:\n  ///   namespace Foo { namespace Bar {\n  ///   }}\n  ///\n  ///   false:\n  ///   namespace Foo {\n  ///   namespace Bar {\n  ///   }\n  ///   }\n  /// \\endcode\n  ///\n  /// If it does not fit on a single line, the overflowing namespaces get\n  /// wrapped:\n  /// \\code\n  ///   namespace Foo { namespace Bar {\n  ///   namespace Extra {\n  ///   }}}\n  /// \\endcode\n  bool CompactNamespaces;\n\n  // clang-format off\n  /// If the constructor initializers don't fit on a line, put each\n  /// initializer on its own line.\n  /// \\code\n  ///   true:\n  ///   SomeClass::Constructor()\n  ///       : aaaaaaaa(aaaaaaaa), aaaaaaaa(aaaaaaaa), aaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaa) {\n  ///     return 0;\n  ///   }\n  ///\n  ///   false:\n  ///   SomeClass::Constructor()\n  ///       : aaaaaaaa(aaaaaaaa), aaaaaaaa(aaaaaaaa),\n  ///         aaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaa) {\n  ///     return 0;\n  ///   }\n  /// \\endcode\n  bool ConstructorInitializerAllOnOneLineOrOnePerLine;\n  // clang-format on\n\n  /// The number of characters to use for indentation of constructor\n  /// initializer lists as well as inheritance lists.\n  unsigned ConstructorInitializerIndentWidth;\n\n  /// Indent width for line continuations.\n  /// \\code\n  ///    ContinuationIndentWidth: 2\n  ///\n  ///    int i =         //  VeryVeryVeryVeryVeryLongComment\n  ///      longFunction( // Again a long comment\n  ///        arg);\n  /// \\endcode\n  unsigned ContinuationIndentWidth;\n\n  /// If ``true``, format braced lists as best suited for C++11 braced\n  /// lists.\n  ///\n  /// Important differences:\n  /// - No spaces inside the braced list.\n  /// - No line break before the closing brace.\n  /// - Indentation with the continuation indent, not with the block indent.\n  ///\n  /// Fundamentally, C++11 braced lists are formatted exactly like function\n  /// calls would be formatted in their place. If the braced list follows a name\n  /// (e.g. a type or variable name), clang-format formats as if the ``{}`` were\n  /// the parentheses of a function call with that name. If there is no name,\n  /// a zero-length name is assumed.\n  /// \\code\n  ///    true:                                  false:\n  ///    vector<int> x{1, 2, 3, 4};     vs.     vector<int> x{ 1, 2, 3, 4 };\n  ///    vector<T> x{{}, {}, {}, {}};           vector<T> x{ {}, {}, {}, {} };\n  ///    f(MyMap[{composite, key}]);            f(MyMap[{ composite, key }]);\n  ///    new int[3]{1, 2, 3};                   new int[3]{ 1, 2, 3 };\n  /// \\endcode\n  bool Cpp11BracedListStyle;\n\n  /// \\brief Analyze the formatted file for the most used line ending (``\\r\\n``\n  /// or ``\\n``). ``UseCRLF`` is only used as a fallback if none can be derived.\n  bool DeriveLineEnding;\n\n  /// If ``true``, analyze the formatted file for the most common\n  /// alignment of ``&`` and ``*``.\n  /// Pointer and reference alignment styles are going to be updated according\n  /// to the preferences found in the file.\n  /// ``PointerAlignment`` is then used only as fallback.\n  bool DerivePointerAlignment;\n\n  /// Disables formatting completely.\n  bool DisableFormat;\n\n  /// Different styles for empty line before access modifiers.\n  enum EmptyLineBeforeAccessModifierStyle : unsigned char {\n    /// Remove all empty lines before access modifiers.\n    /// \\code\n    ///   struct foo {\n    ///   private:\n    ///     int i;\n    ///   protected:\n    ///     int j;\n    ///     /* comment */\n    ///   public:\n    ///     foo() {}\n    ///   private:\n    ///   protected:\n    ///   };\n    /// \\endcode\n    ELBAMS_Never,\n    /// Keep existing empty lines before access modifiers.\n    ELBAMS_Leave,\n    /// Add empty line only when access modifier starts a new logical block.\n    /// Logical block is a group of one or more member fields or functions.\n    /// \\code\n    ///   struct foo {\n    ///   private:\n    ///     int i;\n    ///\n    ///   protected:\n    ///     int j;\n    ///     /* comment */\n    ///   public:\n    ///     foo() {}\n    ///\n    ///   private:\n    ///   protected:\n    ///   };\n    /// \\endcode\n    ELBAMS_LogicalBlock,\n    /// Always add empty line before access modifiers unless access modifier\n    /// is at the start of struct or class definition.\n    /// \\code\n    ///   struct foo {\n    ///   private:\n    ///     int i;\n    ///\n    ///   protected:\n    ///     int j;\n    ///     /* comment */\n    ///\n    ///   public:\n    ///     foo() {}\n    ///\n    ///   private:\n    ///\n    ///   protected:\n    ///   };\n    /// \\endcode\n    ELBAMS_Always,\n  };\n\n  /// Defines in which cases to put empty line before access modifiers.\n  EmptyLineBeforeAccessModifierStyle EmptyLineBeforeAccessModifier;\n\n  /// If ``true``, clang-format detects whether function calls and\n  /// definitions are formatted with one parameter per line.\n  ///\n  /// Each call can be bin-packed, one-per-line or inconclusive. If it is\n  /// inconclusive, e.g. completely on one line, but a decision needs to be\n  /// made, clang-format analyzes whether there are other bin-packed cases in\n  /// the input file and act accordingly.\n  ///\n  /// NOTE: This is an experimental flag, that might go away or be renamed. Do\n  /// not use this in config files, etc. Use at your own risk.\n  bool ExperimentalAutoDetectBinPacking;\n\n  /// If ``true``, clang-format adds missing namespace end comments for\n  /// short namespaces and fixes invalid existing ones. Short ones are\n  /// controlled by \"ShortNamespaceLines\".\n  /// \\code\n  ///    true:                                  false:\n  ///    namespace a {                  vs.     namespace a {\n  ///    foo();                                 foo();\n  ///    bar();                                 bar();\n  ///    } // namespace a                       }\n  /// \\endcode\n  bool FixNamespaceComments;\n\n  /// A vector of macros that should be interpreted as foreach loops\n  /// instead of as function calls.\n  ///\n  /// These are expected to be macros of the form:\n  /// \\code\n  ///   FOREACH(<variable-declaration>, ...)\n  ///     <loop-body>\n  /// \\endcode\n  ///\n  /// In the .clang-format configuration file, this can be configured like:\n  /// \\code{.yaml}\n  ///   ForEachMacros: ['RANGES_FOR', 'FOREACH']\n  /// \\endcode\n  ///\n  /// For example: BOOST_FOREACH.\n  std::vector<std::string> ForEachMacros;\n\n  /// \\brief A vector of macros that should be interpreted as type declarations\n  /// instead of as function calls.\n  ///\n  /// These are expected to be macros of the form:\n  /// \\code\n  ///   STACK_OF(...)\n  /// \\endcode\n  ///\n  /// In the .clang-format configuration file, this can be configured like:\n  /// \\code{.yaml}\n  ///   TypenameMacros: ['STACK_OF', 'LIST']\n  /// \\endcode\n  ///\n  /// For example: OpenSSL STACK_OF, BSD LIST_ENTRY.\n  std::vector<std::string> TypenameMacros;\n\n  /// A vector of macros that should be interpreted as complete\n  /// statements.\n  ///\n  /// Typical macros are expressions, and require a semi-colon to be\n  /// added; sometimes this is not the case, and this allows to make\n  /// clang-format aware of such cases.\n  ///\n  /// For example: Q_UNUSED\n  std::vector<std::string> StatementMacros;\n\n  /// A vector of macros which are used to open namespace blocks.\n  ///\n  /// These are expected to be macros of the form:\n  /// \\code\n  ///   NAMESPACE(<namespace-name>, ...) {\n  ///     <namespace-content>\n  ///   }\n  /// \\endcode\n  ///\n  /// For example: TESTSUITE\n  std::vector<std::string> NamespaceMacros;\n\n  /// A vector of macros which are whitespace-sensitive and should not\n  /// be touched.\n  ///\n  /// These are expected to be macros of the form:\n  /// \\code\n  ///   STRINGIZE(...)\n  /// \\endcode\n  ///\n  /// In the .clang-format configuration file, this can be configured like:\n  /// \\code{.yaml}\n  ///   WhitespaceSensitiveMacros: ['STRINGIZE', 'PP_STRINGIZE']\n  /// \\endcode\n  ///\n  /// For example: BOOST_PP_STRINGIZE\n  std::vector<std::string> WhitespaceSensitiveMacros;\n\n  tooling::IncludeStyle IncludeStyle;\n\n  /// Specify whether access modifiers should have their own indentation level.\n  ///\n  /// When ``false``, access modifiers are indented (or outdented) relative to\n  /// the record members, respecting the ``AccessModifierOffset``. Record\n  /// members are indented one level below the record.\n  /// When ``true``, access modifiers get their own indentation level. As a\n  /// consequence, record members are always indented 2 levels below the record,\n  /// regardless of the access modifier presence. Value of the\n  /// ``AccessModifierOffset`` is ignored.\n  /// \\code\n  ///    false:                                 true:\n  ///    class C {                      vs.     class C {\n  ///      class D {                                class D {\n  ///        void bar();                                void bar();\n  ///      protected:                                 protected:\n  ///        D();                                       D();\n  ///      };                                       };\n  ///    public:                                  public:\n  ///      C();                                     C();\n  ///    };                                     };\n  ///    void foo() {                           void foo() {\n  ///      return 1;                              return 1;\n  ///    }                                      }\n  /// \\endcode\n  bool IndentAccessModifiers;\n\n  /// Indent case labels one level from the switch statement.\n  ///\n  /// When ``false``, use the same indentation level as for the switch\n  /// statement. Switch statement body is always indented one level more than\n  /// case labels (except the first block following the case label, which\n  /// itself indents the code - unless IndentCaseBlocks is enabled).\n  /// \\code\n  ///    false:                                 true:\n  ///    switch (fool) {                vs.     switch (fool) {\n  ///    case 1:                                  case 1:\n  ///      bar();                                   bar();\n  ///      break;                                   break;\n  ///    default:                                 default:\n  ///      plop();                                  plop();\n  ///    }                                      }\n  /// \\endcode\n  bool IndentCaseLabels;\n\n  /// Indent case label blocks one level from the case label.\n  ///\n  /// When ``false``, the block following the case label uses the same\n  /// indentation level as for the case label, treating the case label the same\n  /// as an if-statement.\n  /// When ``true``, the block gets indented as a scope block.\n  /// \\code\n  ///    false:                                 true:\n  ///    switch (fool) {                vs.     switch (fool) {\n  ///    case 1: {                              case 1:\n  ///      bar();                                 {\n  ///    } break;                                   bar();\n  ///    default: {                               }\n  ///      plop();                                break;\n  ///    }                                      default:\n  ///    }                                        {\n  ///                                               plop();\n  ///                                             }\n  ///                                           }\n  /// \\endcode\n  bool IndentCaseBlocks;\n\n  /// Indent goto labels.\n  ///\n  /// When ``false``, goto labels are flushed left.\n  /// \\code\n  ///    true:                                  false:\n  ///    int f() {                      vs.     int f() {\n  ///      if (foo()) {                           if (foo()) {\n  ///      label1:                              label1:\n  ///        bar();                                 bar();\n  ///      }                                      }\n  ///    label2:                                label2:\n  ///      return 1;                              return 1;\n  ///    }                                      }\n  /// \\endcode\n  bool IndentGotoLabels;\n\n  /// Options for indenting preprocessor directives.\n  enum PPDirectiveIndentStyle : unsigned char {\n    /// Does not indent any directives.\n    /// \\code\n    ///    #if FOO\n    ///    #if BAR\n    ///    #include <foo>\n    ///    #endif\n    ///    #endif\n    /// \\endcode\n    PPDIS_None,\n    /// Indents directives after the hash.\n    /// \\code\n    ///    #if FOO\n    ///    #  if BAR\n    ///    #    include <foo>\n    ///    #  endif\n    ///    #endif\n    /// \\endcode\n    PPDIS_AfterHash,\n    /// Indents directives before the hash.\n    /// \\code\n    ///    #if FOO\n    ///      #if BAR\n    ///        #include <foo>\n    ///      #endif\n    ///    #endif\n    /// \\endcode\n    PPDIS_BeforeHash\n  };\n\n  /// The preprocessor directive indenting style to use.\n  PPDirectiveIndentStyle IndentPPDirectives;\n\n  /// Indents extern blocks\n  enum IndentExternBlockStyle : unsigned char {\n    /// Backwards compatible with AfterExternBlock's indenting.\n    /// \\code\n    ///    IndentExternBlock: AfterExternBlock\n    ///    BraceWrapping.AfterExternBlock: true\n    ///    extern \"C\"\n    ///    {\n    ///        void foo();\n    ///    }\n    /// \\endcode\n    ///\n    /// \\code\n    ///    IndentExternBlock: AfterExternBlock\n    ///    BraceWrapping.AfterExternBlock: false\n    ///    extern \"C\" {\n    ///    void foo();\n    ///    }\n    /// \\endcode\n    IEBS_AfterExternBlock,\n    /// Does not indent extern blocks.\n    /// \\code\n    ///     extern \"C\" {\n    ///     void foo();\n    ///     }\n    /// \\endcode\n    IEBS_NoIndent,\n    /// Indents extern blocks.\n    /// \\code\n    ///     extern \"C\" {\n    ///       void foo();\n    ///     }\n    /// \\endcode\n    IEBS_Indent,\n  };\n\n  /// IndentExternBlockStyle is the type of indenting of extern blocks.\n  IndentExternBlockStyle IndentExternBlock;\n\n  /// Indent the requires clause in a template\n  /// \\code\n  ///    true:\n  ///    template <typename It>\n  ///      requires Iterator<It>\n  ///    void sort(It begin, It end) {\n  ///      //....\n  ///    }\n  ///\n  ///    false:\n  ///    template <typename It>\n  ///    requires Iterator<It>\n  ///    void sort(It begin, It end) {\n  ///      //....\n  ///    }\n  /// \\endcode\n  bool IndentRequires;\n\n  /// The number of columns to use for indentation.\n  /// \\code\n  ///    IndentWidth: 3\n  ///\n  ///    void f() {\n  ///       someFunction();\n  ///       if (true, false) {\n  ///          f();\n  ///       }\n  ///    }\n  /// \\endcode\n  unsigned IndentWidth;\n\n  /// Indent if a function definition or declaration is wrapped after the\n  /// type.\n  /// \\code\n  ///    true:\n  ///    LoooooooooooooooooooooooooooooooooooooooongReturnType\n  ///        LoooooooooooooooooooooooooooooooongFunctionDeclaration();\n  ///\n  ///    false:\n  ///    LoooooooooooooooooooooooooooooooooooooooongReturnType\n  ///    LoooooooooooooooooooooooooooooooongFunctionDeclaration();\n  /// \\endcode\n  bool IndentWrappedFunctionNames;\n\n  /// A vector of prefixes ordered by the desired groups for Java imports.\n  ///\n  /// One group's prefix can be a subset of another - the longest prefix is\n  /// always matched. Within a group, the imports are ordered lexicographically.\n  /// Static imports are grouped separately and follow the same group rules.\n  /// By default, static imports are placed before non-static imports,\n  /// but this behavior is changed by another option,\n  /// ``SortJavaStaticImport``.\n  ///\n  /// In the .clang-format configuration file, this can be configured like\n  /// in the following yaml example. This will result in imports being\n  /// formatted as in the Java example below.\n  /// \\code{.yaml}\n  ///   JavaImportGroups: ['com.example', 'com', 'org']\n  /// \\endcode\n  ///\n  /// \\code{.java}\n  ///    import static com.example.function1;\n  ///\n  ///    import static com.test.function2;\n  ///\n  ///    import static org.example.function3;\n  ///\n  ///    import com.example.ClassA;\n  ///    import com.example.Test;\n  ///    import com.example.a.ClassB;\n  ///\n  ///    import com.test.ClassC;\n  ///\n  ///    import org.example.ClassD;\n  /// \\endcode\n  std::vector<std::string> JavaImportGroups;\n\n  /// Quotation styles for JavaScript strings. Does not affect template\n  /// strings.\n  enum JavaScriptQuoteStyle : unsigned char {\n    /// Leave string quotes as they are.\n    /// \\code{.js}\n    ///    string1 = \"foo\";\n    ///    string2 = 'bar';\n    /// \\endcode\n    JSQS_Leave,\n    /// Always use single quotes.\n    /// \\code{.js}\n    ///    string1 = 'foo';\n    ///    string2 = 'bar';\n    /// \\endcode\n    JSQS_Single,\n    /// Always use double quotes.\n    /// \\code{.js}\n    ///    string1 = \"foo\";\n    ///    string2 = \"bar\";\n    /// \\endcode\n    JSQS_Double\n  };\n\n  /// The JavaScriptQuoteStyle to use for JavaScript strings.\n  JavaScriptQuoteStyle JavaScriptQuotes;\n\n  // clang-format off\n  /// Whether to wrap JavaScript import/export statements.\n  /// \\code{.js}\n  ///    true:\n  ///    import {\n  ///        VeryLongImportsAreAnnoying,\n  ///        VeryLongImportsAreAnnoying,\n  ///        VeryLongImportsAreAnnoying,\n  ///    } from 'some/module.js'\n  ///\n  ///    false:\n  ///    import {VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying,} from \"some/module.js\"\n  /// \\endcode\n  bool JavaScriptWrapImports;\n  // clang-format on\n\n  /// If true, the empty line at the start of blocks is kept.\n  /// \\code\n  ///    true:                                  false:\n  ///    if (foo) {                     vs.     if (foo) {\n  ///                                             bar();\n  ///      bar();                               }\n  ///    }\n  /// \\endcode\n  bool KeepEmptyLinesAtTheStartOfBlocks;\n\n  /// Supported languages.\n  ///\n  /// When stored in a configuration file, specifies the language, that the\n  /// configuration targets. When passed to the ``reformat()`` function, enables\n  /// syntax features specific to the language.\n  enum LanguageKind : unsigned char {\n    /// Do not use.\n    LK_None,\n    /// Should be used for C, C++.\n    LK_Cpp,\n    /// Should be used for C#.\n    LK_CSharp,\n    /// Should be used for Java.\n    LK_Java,\n    /// Should be used for JavaScript.\n    LK_JavaScript,\n    /// Should be used for Objective-C, Objective-C++.\n    LK_ObjC,\n    /// Should be used for Protocol Buffers\n    /// (https://developers.google.com/protocol-buffers/).\n    LK_Proto,\n    /// Should be used for TableGen code.\n    LK_TableGen,\n    /// Should be used for Protocol Buffer messages in text format\n    /// (https://developers.google.com/protocol-buffers/).\n    LK_TextProto\n  };\n  bool isCpp() const { return Language == LK_Cpp || Language == LK_ObjC; }\n  bool isCSharp() const { return Language == LK_CSharp; }\n\n  /// Language, this format style is targeted at.\n  LanguageKind Language;\n\n  /// A regular expression matching macros that start a block.\n  /// \\code\n  ///    # With:\n  ///    MacroBlockBegin: \"^NS_MAP_BEGIN|\\\n  ///    NS_TABLE_HEAD$\"\n  ///    MacroBlockEnd: \"^\\\n  ///    NS_MAP_END|\\\n  ///    NS_TABLE_.*_END$\"\n  ///\n  ///    NS_MAP_BEGIN\n  ///      foo();\n  ///    NS_MAP_END\n  ///\n  ///    NS_TABLE_HEAD\n  ///      bar();\n  ///    NS_TABLE_FOO_END\n  ///\n  ///    # Without:\n  ///    NS_MAP_BEGIN\n  ///    foo();\n  ///    NS_MAP_END\n  ///\n  ///    NS_TABLE_HEAD\n  ///    bar();\n  ///    NS_TABLE_FOO_END\n  /// \\endcode\n  std::string MacroBlockBegin;\n\n  /// A regular expression matching macros that end a block.\n  std::string MacroBlockEnd;\n\n  /// The maximum number of consecutive empty lines to keep.\n  /// \\code\n  ///    MaxEmptyLinesToKeep: 1         vs.     MaxEmptyLinesToKeep: 0\n  ///    int f() {                              int f() {\n  ///      int = 1;                                 int i = 1;\n  ///                                               i = foo();\n  ///      i = foo();                               return i;\n  ///                                           }\n  ///      return i;\n  ///    }\n  /// \\endcode\n  unsigned MaxEmptyLinesToKeep;\n\n  /// Different ways to indent namespace contents.\n  enum NamespaceIndentationKind : unsigned char {\n    /// Don't indent in namespaces.\n    /// \\code\n    ///    namespace out {\n    ///    int i;\n    ///    namespace in {\n    ///    int i;\n    ///    }\n    ///    }\n    /// \\endcode\n    NI_None,\n    /// Indent only in inner namespaces (nested in other namespaces).\n    /// \\code\n    ///    namespace out {\n    ///    int i;\n    ///    namespace in {\n    ///      int i;\n    ///    }\n    ///    }\n    /// \\endcode\n    NI_Inner,\n    /// Indent in all namespaces.\n    /// \\code\n    ///    namespace out {\n    ///      int i;\n    ///      namespace in {\n    ///        int i;\n    ///      }\n    ///    }\n    /// \\endcode\n    NI_All\n  };\n\n  /// The indentation used for namespaces.\n  NamespaceIndentationKind NamespaceIndentation;\n\n  /// Controls bin-packing Objective-C protocol conformance list\n  /// items into as few lines as possible when they go over ``ColumnLimit``.\n  ///\n  /// If ``Auto`` (the default), delegates to the value in\n  /// ``BinPackParameters``. If that is ``true``, bin-packs Objective-C\n  /// protocol conformance list items into as few lines as possible\n  /// whenever they go over ``ColumnLimit``.\n  ///\n  /// If ``Always``, always bin-packs Objective-C protocol conformance\n  /// list items into as few lines as possible whenever they go over\n  /// ``ColumnLimit``.\n  ///\n  /// If ``Never``, lays out Objective-C protocol conformance list items\n  /// onto individual lines whenever they go over ``ColumnLimit``.\n  ///\n  /// \\code{.objc}\n  ///    Always (or Auto, if BinPackParameters=true):\n  ///    @interface ccccccccccccc () <\n  ///        ccccccccccccc, ccccccccccccc,\n  ///        ccccccccccccc, ccccccccccccc> {\n  ///    }\n  ///\n  ///    Never (or Auto, if BinPackParameters=false):\n  ///    @interface ddddddddddddd () <\n  ///        ddddddddddddd,\n  ///        ddddddddddddd,\n  ///        ddddddddddddd,\n  ///        ddddddddddddd> {\n  ///    }\n  /// \\endcode\n  BinPackStyle ObjCBinPackProtocolList;\n\n  /// The number of characters to use for indentation of ObjC blocks.\n  /// \\code{.objc}\n  ///    ObjCBlockIndentWidth: 4\n  ///\n  ///    [operation setCompletionBlock:^{\n  ///        [self onOperationDone];\n  ///    }];\n  /// \\endcode\n  unsigned ObjCBlockIndentWidth;\n\n  /// Add a space after ``@property`` in Objective-C, i.e. use\n  /// ``@property (readonly)`` instead of ``@property(readonly)``.\n  bool ObjCSpaceAfterProperty;\n\n  /// Break parameters list into lines when there is nested block\n  /// parameters in a function call.\n  /// \\code\n  ///   false:\n  ///    - (void)_aMethod\n  ///    {\n  ///        [self.test1 t:self w:self callback:^(typeof(self) self, NSNumber\n  ///        *u, NSNumber *v) {\n  ///            u = c;\n  ///        }]\n  ///    }\n  ///    true:\n  ///    - (void)_aMethod\n  ///    {\n  ///       [self.test1 t:self\n  ///                    w:self\n  ///           callback:^(typeof(self) self, NSNumber *u, NSNumber *v) {\n  ///                u = c;\n  ///            }]\n  ///    }\n  /// \\endcode\n  bool ObjCBreakBeforeNestedBlockParam;\n\n  /// Add a space in front of an Objective-C protocol list, i.e. use\n  /// ``Foo <Protocol>`` instead of ``Foo<Protocol>``.\n  bool ObjCSpaceBeforeProtocolList;\n\n  /// The penalty for breaking around an assignment operator.\n  unsigned PenaltyBreakAssignment;\n\n  /// The penalty for breaking a function call after ``call(``.\n  unsigned PenaltyBreakBeforeFirstCallParameter;\n\n  /// The penalty for each line break introduced inside a comment.\n  unsigned PenaltyBreakComment;\n\n  /// The penalty for breaking before the first ``<<``.\n  unsigned PenaltyBreakFirstLessLess;\n\n  /// The penalty for each line break introduced inside a string literal.\n  unsigned PenaltyBreakString;\n\n  /// The penalty for breaking after template declaration.\n  unsigned PenaltyBreakTemplateDeclaration;\n\n  /// The penalty for each character outside of the column limit.\n  unsigned PenaltyExcessCharacter;\n\n  /// Penalty for putting the return type of a function onto its own\n  /// line.\n  unsigned PenaltyReturnTypeOnItsOwnLine;\n\n  /// Penalty for each character of whitespace indentation\n  /// (counted relative to leading non-whitespace column).\n  unsigned PenaltyIndentedWhitespace;\n\n  /// The ``&`` and ``*`` alignment style.\n  enum PointerAlignmentStyle : unsigned char {\n    /// Align pointer to the left.\n    /// \\code\n    ///   int* a;\n    /// \\endcode\n    PAS_Left,\n    /// Align pointer to the right.\n    /// \\code\n    ///   int *a;\n    /// \\endcode\n    PAS_Right,\n    /// Align pointer in the middle.\n    /// \\code\n    ///   int * a;\n    /// \\endcode\n    PAS_Middle\n  };\n\n  /// Pointer and reference alignment style.\n  PointerAlignmentStyle PointerAlignment;\n\n  /// See documentation of ``RawStringFormats``.\n  struct RawStringFormat {\n    /// The language of this raw string.\n    LanguageKind Language;\n    /// A list of raw string delimiters that match this language.\n    std::vector<std::string> Delimiters;\n    /// A list of enclosing function names that match this language.\n    std::vector<std::string> EnclosingFunctions;\n    /// The canonical delimiter for this language.\n    std::string CanonicalDelimiter;\n    /// The style name on which this raw string format is based on.\n    /// If not specified, the raw string format is based on the style that this\n    /// format is based on.\n    std::string BasedOnStyle;\n    bool operator==(const RawStringFormat &Other) const {\n      return Language == Other.Language && Delimiters == Other.Delimiters &&\n             EnclosingFunctions == Other.EnclosingFunctions &&\n             CanonicalDelimiter == Other.CanonicalDelimiter &&\n             BasedOnStyle == Other.BasedOnStyle;\n    }\n  };\n\n  /// Defines hints for detecting supported languages code blocks in raw\n  /// strings.\n  ///\n  /// A raw string with a matching delimiter or a matching enclosing function\n  /// name will be reformatted assuming the specified language based on the\n  /// style for that language defined in the .clang-format file. If no style has\n  /// been defined in the .clang-format file for the specific language, a\n  /// predefined style given by 'BasedOnStyle' is used. If 'BasedOnStyle' is not\n  /// found, the formatting is based on llvm style. A matching delimiter takes\n  /// precedence over a matching enclosing function name for determining the\n  /// language of the raw string contents.\n  ///\n  /// If a canonical delimiter is specified, occurrences of other delimiters for\n  /// the same language will be updated to the canonical if possible.\n  ///\n  /// There should be at most one specification per language and each delimiter\n  /// and enclosing function should not occur in multiple specifications.\n  ///\n  /// To configure this in the .clang-format file, use:\n  /// \\code{.yaml}\n  ///   RawStringFormats:\n  ///     - Language: TextProto\n  ///         Delimiters:\n  ///           - 'pb'\n  ///           - 'proto'\n  ///         EnclosingFunctions:\n  ///           - 'PARSE_TEXT_PROTO'\n  ///         BasedOnStyle: google\n  ///     - Language: Cpp\n  ///         Delimiters:\n  ///           - 'cc'\n  ///           - 'cpp'\n  ///         BasedOnStyle: llvm\n  ///         CanonicalDelimiter: 'cc'\n  /// \\endcode\n  std::vector<RawStringFormat> RawStringFormats;\n\n  // clang-format off\n  /// If ``true``, clang-format will attempt to re-flow comments.\n  /// \\code\n  ///    false:\n  ///    // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information\n  ///    /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */\n  ///\n  ///    true:\n  ///    // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of\n  ///    // information\n  ///    /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of\n  ///     * information */\n  /// \\endcode\n  bool ReflowComments;\n  // clang-format on\n\n  /// The maximal number of unwrapped lines that a short namespace spans.\n  /// Defaults to 1.\n  ///\n  /// This determines the maximum length of short namespaces by counting\n  /// unwrapped lines (i.e. containing neither opening nor closing\n  /// namespace brace) and makes \"FixNamespaceComments\" omit adding\n  /// end comments for those.\n  /// \\code\n  ///    ShortNamespaceLines: 1     vs.     ShortNamespaceLines: 0\n  ///    namespace a {                      namespace a {\n  ///      int foo;                           int foo;\n  ///    }                                  } // namespace a\n  ///\n  ///    ShortNamespaceLines: 1     vs.     ShortNamespaceLines: 0\n  ///    namespace b {                      namespace b {\n  ///      int foo;                           int foo;\n  ///      int bar;                           int bar;\n  ///    } // namespace b                   } // namespace b\n  /// \\endcode\n  unsigned ShortNamespaceLines;\n\n  /// Include sorting options.\n  enum SortIncludesOptions : unsigned char {\n    /// Includes are never sorted.\n    /// \\code\n    ///    #include \"B/A.h\"\n    ///    #include \"A/B.h\"\n    ///    #include \"a/b.h\"\n    ///    #include \"A/b.h\"\n    ///    #include \"B/a.h\"\n    /// \\endcode\n    SI_Never,\n    /// Includes are sorted in an ASCIIbetical or case sensitive fashion.\n    /// \\code\n    ///    #include \"A/B.h\"\n    ///    #include \"A/b.h\"\n    ///    #include \"B/A.h\"\n    ///    #include \"B/a.h\"\n    ///    #include \"a/b.h\"\n    /// \\endcode\n    SI_CaseSensitive,\n    /// Includes are sorted in an alphabetical or case insensitive fashion.\n    /// \\code\n    ///    #include \"A/B.h\"\n    ///    #include \"A/b.h\"\n    ///    #include \"a/b.h\"\n    ///    #include \"B/A.h\"\n    ///    #include \"B/a.h\"\n    /// \\endcode\n    SI_CaseInsensitive,\n  };\n\n  /// Controls if and how clang-format will sort ``#includes``.\n  /// If ``Never``, includes are never sorted.\n  /// If ``CaseInsensitive``, includes are sorted in an ASCIIbetical or case\n  /// insensitive fashion.\n  /// If ``CaseSensitive``, includes are sorted in an alphabetical or case\n  /// sensitive fashion.\n  SortIncludesOptions SortIncludes;\n\n  /// Position for Java Static imports.\n  enum SortJavaStaticImportOptions : unsigned char {\n    /// Static imports are placed before non-static imports.\n    /// \\code{.java}\n    ///   import static org.example.function1;\n    ///\n    ///   import org.example.ClassA;\n    /// \\endcode\n    SJSIO_Before,\n    /// Static imports are placed after non-static imports.\n    /// \\code{.java}\n    ///   import org.example.ClassA;\n    ///\n    ///   import static org.example.function1;\n    /// \\endcode\n    SJSIO_After,\n  };\n\n  /// When sorting Java imports, by default static imports are placed before\n  /// non-static imports. If ``JavaStaticImportAfterImport`` is ``After``,\n  /// static imports are placed after non-static imports.\n  SortJavaStaticImportOptions SortJavaStaticImport;\n\n  /// If ``true``, clang-format will sort using declarations.\n  ///\n  /// The order of using declarations is defined as follows:\n  /// Split the strings by \"::\" and discard any initial empty strings. The last\n  /// element of each list is a non-namespace name; all others are namespace\n  /// names. Sort the lists of names lexicographically, where the sort order of\n  /// individual names is that all non-namespace names come before all namespace\n  /// names, and within those groups, names are in case-insensitive\n  /// lexicographic order.\n  /// \\code\n  ///    false:                                 true:\n  ///    using std::cout;               vs.     using std::cin;\n  ///    using std::cin;                        using std::cout;\n  /// \\endcode\n  bool SortUsingDeclarations;\n\n  /// If ``true``, a space is inserted after C style casts.\n  /// \\code\n  ///    true:                                  false:\n  ///    (int) i;                       vs.     (int)i;\n  /// \\endcode\n  bool SpaceAfterCStyleCast;\n\n  /// If ``true``, a space is inserted after the logical not operator (``!``).\n  /// \\code\n  ///    true:                                  false:\n  ///    ! someExpression();            vs.     !someExpression();\n  /// \\endcode\n  bool SpaceAfterLogicalNot;\n\n  /// If \\c true, a space will be inserted after the 'template' keyword.\n  /// \\code\n  ///    true:                                  false:\n  ///    template <int> void foo();     vs.     template<int> void foo();\n  /// \\endcode\n  bool SpaceAfterTemplateKeyword;\n\n  /// Different ways to put a space before opening parentheses.\n  enum SpaceAroundPointerQualifiersStyle : unsigned char {\n    /// Don't ensure spaces around pointer qualifiers and use PointerAlignment\n    /// instead.\n    /// \\code\n    ///    PointerAlignment: Left                 PointerAlignment: Right\n    ///    void* const* x = NULL;         vs.     void *const *x = NULL;\n    /// \\endcode\n    SAPQ_Default,\n    /// Ensure that there is a space before pointer qualifiers.\n    /// \\code\n    ///    PointerAlignment: Left                 PointerAlignment: Right\n    ///    void* const* x = NULL;         vs.     void * const *x = NULL;\n    /// \\endcode\n    SAPQ_Before,\n    /// Ensure that there is a space after pointer qualifiers.\n    /// \\code\n    ///    PointerAlignment: Left                 PointerAlignment: Right\n    ///    void* const * x = NULL;         vs.     void *const *x = NULL;\n    /// \\endcode\n    SAPQ_After,\n    /// Ensure that there is a space both before and after pointer qualifiers.\n    /// \\code\n    ///    PointerAlignment: Left                 PointerAlignment: Right\n    ///    void* const * x = NULL;         vs.     void * const *x = NULL;\n    /// \\endcode\n    SAPQ_Both,\n  };\n\n  ///  Defines in which cases to put a space before or after pointer qualifiers\n  SpaceAroundPointerQualifiersStyle SpaceAroundPointerQualifiers;\n\n  /// If ``false``, spaces will be removed before assignment operators.\n  /// \\code\n  ///    true:                                  false:\n  ///    int a = 5;                     vs.     int a= 5;\n  ///    a += 42;                               a+= 42;\n  /// \\endcode\n  bool SpaceBeforeAssignmentOperators;\n\n  /// If ``false``, spaces will be removed before case colon.\n  /// \\code\n  ///   true:                                   false\n  ///   switch (x) {                    vs.     switch (x) {\n  ///     case 1 : break;                         case 1: break;\n  ///   }                                       }\n  /// \\endcode\n  bool SpaceBeforeCaseColon;\n\n  /// If ``true``, a space will be inserted before a C++11 braced list\n  /// used to initialize an object (after the preceding identifier or type).\n  /// \\code\n  ///    true:                                  false:\n  ///    Foo foo { bar };               vs.     Foo foo{ bar };\n  ///    Foo {};                                Foo{};\n  ///    vector<int> { 1, 2, 3 };               vector<int>{ 1, 2, 3 };\n  ///    new int[3] { 1, 2, 3 };                new int[3]{ 1, 2, 3 };\n  /// \\endcode\n  bool SpaceBeforeCpp11BracedList;\n\n  /// If ``false``, spaces will be removed before constructor initializer\n  /// colon.\n  /// \\code\n  ///    true:                                  false:\n  ///    Foo::Foo() : a(a) {}                   Foo::Foo(): a(a) {}\n  /// \\endcode\n  bool SpaceBeforeCtorInitializerColon;\n\n  /// If ``false``, spaces will be removed before inheritance colon.\n  /// \\code\n  ///    true:                                  false:\n  ///    class Foo : Bar {}             vs.     class Foo: Bar {}\n  /// \\endcode\n  bool SpaceBeforeInheritanceColon;\n\n  /// Different ways to put a space before opening parentheses.\n  enum SpaceBeforeParensOptions : unsigned char {\n    /// Never put a space before opening parentheses.\n    /// \\code\n    ///    void f() {\n    ///      if(true) {\n    ///        f();\n    ///      }\n    ///    }\n    /// \\endcode\n    SBPO_Never,\n    /// Put a space before opening parentheses only after control statement\n    /// keywords (``for/if/while...``).\n    /// \\code\n    ///    void f() {\n    ///      if (true) {\n    ///        f();\n    ///      }\n    ///    }\n    /// \\endcode\n    SBPO_ControlStatements,\n    /// Same as ``SBPO_ControlStatements`` except this option doesn't apply to\n    /// ForEach macros. This is useful in projects where ForEach macros are\n    /// treated as function calls instead of control statements.\n    /// \\code\n    ///    void f() {\n    ///      Q_FOREACH(...) {\n    ///        f();\n    ///      }\n    ///    }\n    /// \\endcode\n    SBPO_ControlStatementsExceptForEachMacros,\n    /// Put a space before opening parentheses only if the parentheses are not\n    /// empty i.e. '()'\n    /// \\code\n    ///   void() {\n    ///     if (true) {\n    ///       f();\n    ///       g (x, y, z);\n    ///     }\n    ///   }\n    /// \\endcode\n    SBPO_NonEmptyParentheses,\n    /// Always put a space before opening parentheses, except when it's\n    /// prohibited by the syntax rules (in function-like macro definitions) or\n    /// when determined by other style rules (after unary operators, opening\n    /// parentheses, etc.)\n    /// \\code\n    ///    void f () {\n    ///      if (true) {\n    ///        f ();\n    ///      }\n    ///    }\n    /// \\endcode\n    SBPO_Always\n  };\n\n  /// Defines in which cases to put a space before opening parentheses.\n  SpaceBeforeParensOptions SpaceBeforeParens;\n\n  /// If ``false``, spaces will be removed before range-based for loop\n  /// colon.\n  /// \\code\n  ///    true:                                  false:\n  ///    for (auto v : values) {}       vs.     for(auto v: values) {}\n  /// \\endcode\n  bool SpaceBeforeRangeBasedForLoopColon;\n\n  /// If ``true``, spaces will be inserted into ``{}``.\n  /// \\code\n  ///    true:                                false:\n  ///    void f() { }                   vs.   void f() {}\n  ///    while (true) { }                     while (true) {}\n  /// \\endcode\n  bool SpaceInEmptyBlock;\n\n  /// If ``true``, spaces may be inserted into ``()``.\n  /// \\code\n  ///    true:                                false:\n  ///    void f( ) {                    vs.   void f() {\n  ///      int x[] = {foo( ), bar( )};          int x[] = {foo(), bar()};\n  ///      if (true) {                          if (true) {\n  ///        f( );                                f();\n  ///      }                                    }\n  ///    }                                    }\n  /// \\endcode\n  bool SpaceInEmptyParentheses;\n\n  /// The number of spaces before trailing line comments\n  /// (``//`` - comments).\n  ///\n  /// This does not affect trailing block comments (``/*`` - comments) as\n  /// those commonly have different usage patterns and a number of special\n  /// cases.\n  /// \\code\n  ///    SpacesBeforeTrailingComments: 3\n  ///    void f() {\n  ///      if (true) {   // foo1\n  ///        f();        // bar\n  ///      }             // foo\n  ///    }\n  /// \\endcode\n  unsigned SpacesBeforeTrailingComments;\n\n  /// If ``true``, spaces will be inserted after ``<`` and before ``>``\n  /// in template argument lists.\n  /// \\code\n  ///    true:                                  false:\n  ///    static_cast< int >(arg);       vs.     static_cast<int>(arg);\n  ///    std::function< void(int) > fct;        std::function<void(int)> fct;\n  /// \\endcode\n  bool SpacesInAngles;\n\n  /// If ``true``, spaces will be inserted around if/for/switch/while\n  /// conditions.\n  /// \\code\n  ///    true:                                  false:\n  ///    if ( a )  { ... }              vs.     if (a) { ... }\n  ///    while ( i < 5 )  { ... }               while (i < 5) { ... }\n  /// \\endcode\n  bool SpacesInConditionalStatement;\n\n  /// If ``true``, spaces are inserted inside container literals (e.g.\n  /// ObjC and Javascript array and dict literals).\n  /// \\code{.js}\n  ///    true:                                  false:\n  ///    var arr = [ 1, 2, 3 ];         vs.     var arr = [1, 2, 3];\n  ///    f({a : 1, b : 2, c : 3});              f({a: 1, b: 2, c: 3});\n  /// \\endcode\n  bool SpacesInContainerLiterals;\n\n  /// If ``true``, spaces may be inserted into C style casts.\n  /// \\code\n  ///    true:                                  false:\n  ///    x = ( int32 )y                 vs.     x = (int32)y\n  /// \\endcode\n  bool SpacesInCStyleCastParentheses;\n\n  /// Control of spaces within a single line comment\n  struct SpacesInLineComment {\n    /// The minimum number of spaces at the start of the comment.\n    unsigned Minimum;\n    /// The maximum number of spaces at the start of the comment.\n    unsigned Maximum;\n  };\n\n  /// How many spaces are allowed at the start of a line comment. To disable the\n  /// maximum set it to ``-1``, apart from that the maximum takes precedence\n  /// over the minimum.\n  /// \\code Minimum = 1 Maximum = -1\n  /// // One space is forced\n  ///\n  /// //  but more spaces are possible\n  ///\n  /// Minimum = 0\n  /// Maximum = 0\n  /// //Forces to start every comment directly after the slashes\n  /// \\endcode\n  ///\n  /// Note that in line comment sections the relative indent of the subsequent\n  /// lines is kept, that means the following:\n  /// \\code\n  /// before:                                   after:\n  /// Minimum: 1\n  /// //if (b) {                                // if (b) {\n  /// //  return true;                          //   return true;\n  /// //}                                       // }\n  ///\n  /// Maximum: 0\n  /// /// List:                                 ///List:\n  /// ///  - Foo                                /// - Foo\n  /// ///    - Bar                              ///   - Bar\n  /// \\endcode\n  SpacesInLineComment SpacesInLineCommentPrefix;\n\n  /// If ``true``, spaces will be inserted after ``(`` and before ``)``.\n  /// \\code\n  ///    true:                                  false:\n  ///    t f( Deleted & ) & = delete;   vs.     t f(Deleted &) & = delete;\n  /// \\endcode\n  bool SpacesInParentheses;\n\n  /// If ``true``, spaces will be inserted after ``[`` and before ``]``.\n  /// Lambdas without arguments or unspecified size array declarations will not\n  /// be affected.\n  /// \\code\n  ///    true:                                  false:\n  ///    int a[ 5 ];                    vs.     int a[5];\n  ///    std::unique_ptr<int[]> foo() {} // Won't be affected\n  /// \\endcode\n  bool SpacesInSquareBrackets;\n\n  /// If ``true``, spaces will be before  ``[``.\n  /// Lambdas will not be affected. Only the first ``[`` will get a space added.\n  /// \\code\n  ///    true:                                  false:\n  ///    int a [5];                    vs.      int a[5];\n  ///    int a [5][5];                 vs.      int a[5][5];\n  /// \\endcode\n  bool SpaceBeforeSquareBrackets;\n\n  /// Styles for adding spacing around ``:`` in bitfield definitions.\n  enum BitFieldColonSpacingStyle : unsigned char {\n    /// Add one space on each side of the ``:``\n    /// \\code\n    ///   unsigned bf : 2;\n    /// \\endcode\n    BFCS_Both,\n    /// Add no space around the ``:`` (except when needed for\n    /// ``AlignConsecutiveBitFields``).\n    /// \\code\n    ///   unsigned bf:2;\n    /// \\endcode\n    BFCS_None,\n    /// Add space before the ``:`` only\n    /// \\code\n    ///   unsigned bf :2;\n    /// \\endcode\n    BFCS_Before,\n    /// Add space after the ``:`` only (space may be added before if\n    /// needed for ``AlignConsecutiveBitFields``).\n    /// \\code\n    ///   unsigned bf: 2;\n    /// \\endcode\n    BFCS_After\n  };\n  /// The BitFieldColonSpacingStyle to use for bitfields.\n  BitFieldColonSpacingStyle BitFieldColonSpacing;\n\n  /// Supported language standards for parsing and formatting C++ constructs.\n  /// \\code\n  ///    Latest:                                vector<set<int>>\n  ///    c++03                          vs.     vector<set<int> >\n  /// \\endcode\n  ///\n  /// The correct way to spell a specific language version is e.g. ``c++11``.\n  /// The historical aliases ``Cpp03`` and ``Cpp11`` are deprecated.\n  enum LanguageStandard : unsigned char {\n    /// Parse and format as C++03.\n    /// ``Cpp03`` is a deprecated alias for ``c++03``\n    LS_Cpp03, // c++03\n    /// Parse and format as C++11.\n    LS_Cpp11, // c++11\n    /// Parse and format as C++14.\n    LS_Cpp14, // c++14\n    /// Parse and format as C++17.\n    LS_Cpp17, // c++17\n    /// Parse and format as C++20.\n    LS_Cpp20, // c++20\n    /// Parse and format using the latest supported language version.\n    /// ``Cpp11`` is a deprecated alias for ``Latest``\n    LS_Latest,\n    /// Automatic detection based on the input.\n    LS_Auto,\n  };\n\n  /// Parse and format C++ constructs compatible with this standard.\n  /// \\code\n  ///    c++03:                                 latest:\n  ///    vector<set<int> > x;           vs.     vector<set<int>> x;\n  /// \\endcode\n  LanguageStandard Standard;\n\n  /// Macros which are ignored in front of a statement, as if they were an\n  /// attribute. So that they are not parsed as identifier, for example for Qts\n  /// emit.\n  /// \\code\n  ///   AlignConsecutiveDeclarations: true\n  ///   StatementAttributeLikeMacros: []\n  ///   unsigned char data = 'x';\n  ///   emit          signal(data); // This is parsed as variable declaration.\n  ///\n  ///   AlignConsecutiveDeclarations: true\n  ///   StatementAttributeLikeMacros: [emit]\n  ///   unsigned char data = 'x';\n  ///   emit signal(data); // Now it's fine again.\n  /// \\endcode\n  std::vector<std::string> StatementAttributeLikeMacros;\n\n  /// The number of columns used for tab stops.\n  unsigned TabWidth;\n\n  /// Different ways to use tab in formatting.\n  enum UseTabStyle : unsigned char {\n    /// Never use tab.\n    UT_Never,\n    /// Use tabs only for indentation.\n    UT_ForIndentation,\n    /// Fill all leading whitespace with tabs, and use spaces for alignment that\n    /// appears within a line (e.g. consecutive assignments and declarations).\n    UT_ForContinuationAndIndentation,\n    /// Use tabs for line continuation and indentation, and spaces for\n    /// alignment.\n    UT_AlignWithSpaces,\n    /// Use tabs whenever we need to fill whitespace that spans at least from\n    /// one tab stop to the next one.\n    UT_Always\n  };\n\n  /// \\brief Use ``\\r\\n`` instead of ``\\n`` for line breaks.\n  /// Also used as fallback if ``DeriveLineEnding`` is true.\n  bool UseCRLF;\n\n  /// The way to use tab characters in the resulting file.\n  UseTabStyle UseTab;\n\n  bool operator==(const FormatStyle &R) const {\n    return AccessModifierOffset == R.AccessModifierOffset &&\n           AlignAfterOpenBracket == R.AlignAfterOpenBracket &&\n           AlignConsecutiveAssignments == R.AlignConsecutiveAssignments &&\n           AlignConsecutiveBitFields == R.AlignConsecutiveBitFields &&\n           AlignConsecutiveDeclarations == R.AlignConsecutiveDeclarations &&\n           AlignConsecutiveMacros == R.AlignConsecutiveMacros &&\n           AlignEscapedNewlines == R.AlignEscapedNewlines &&\n           AlignOperands == R.AlignOperands &&\n           AlignTrailingComments == R.AlignTrailingComments &&\n           AllowAllArgumentsOnNextLine == R.AllowAllArgumentsOnNextLine &&\n           AllowAllConstructorInitializersOnNextLine ==\n               R.AllowAllConstructorInitializersOnNextLine &&\n           AllowAllParametersOfDeclarationOnNextLine ==\n               R.AllowAllParametersOfDeclarationOnNextLine &&\n           AllowShortEnumsOnASingleLine == R.AllowShortEnumsOnASingleLine &&\n           AllowShortBlocksOnASingleLine == R.AllowShortBlocksOnASingleLine &&\n           AllowShortCaseLabelsOnASingleLine ==\n               R.AllowShortCaseLabelsOnASingleLine &&\n           AllowShortFunctionsOnASingleLine ==\n               R.AllowShortFunctionsOnASingleLine &&\n           AllowShortIfStatementsOnASingleLine ==\n               R.AllowShortIfStatementsOnASingleLine &&\n           AllowShortLambdasOnASingleLine == R.AllowShortLambdasOnASingleLine &&\n           AllowShortLoopsOnASingleLine == R.AllowShortLoopsOnASingleLine &&\n           AlwaysBreakAfterReturnType == R.AlwaysBreakAfterReturnType &&\n           AlwaysBreakBeforeMultilineStrings ==\n               R.AlwaysBreakBeforeMultilineStrings &&\n           AlwaysBreakTemplateDeclarations ==\n               R.AlwaysBreakTemplateDeclarations &&\n           AttributeMacros == R.AttributeMacros &&\n           BinPackArguments == R.BinPackArguments &&\n           BinPackParameters == R.BinPackParameters &&\n           BreakBeforeBinaryOperators == R.BreakBeforeBinaryOperators &&\n           BreakBeforeBraces == R.BreakBeforeBraces &&\n           BreakBeforeConceptDeclarations == R.BreakBeforeConceptDeclarations &&\n           BreakBeforeTernaryOperators == R.BreakBeforeTernaryOperators &&\n           BreakConstructorInitializers == R.BreakConstructorInitializers &&\n           CompactNamespaces == R.CompactNamespaces &&\n           BreakAfterJavaFieldAnnotations == R.BreakAfterJavaFieldAnnotations &&\n           BreakStringLiterals == R.BreakStringLiterals &&\n           ColumnLimit == R.ColumnLimit && CommentPragmas == R.CommentPragmas &&\n           BreakInheritanceList == R.BreakInheritanceList &&\n           ConstructorInitializerAllOnOneLineOrOnePerLine ==\n               R.ConstructorInitializerAllOnOneLineOrOnePerLine &&\n           ConstructorInitializerIndentWidth ==\n               R.ConstructorInitializerIndentWidth &&\n           ContinuationIndentWidth == R.ContinuationIndentWidth &&\n           Cpp11BracedListStyle == R.Cpp11BracedListStyle &&\n           DeriveLineEnding == R.DeriveLineEnding &&\n           DerivePointerAlignment == R.DerivePointerAlignment &&\n           DisableFormat == R.DisableFormat &&\n           EmptyLineBeforeAccessModifier == R.EmptyLineBeforeAccessModifier &&\n           ExperimentalAutoDetectBinPacking ==\n               R.ExperimentalAutoDetectBinPacking &&\n           FixNamespaceComments == R.FixNamespaceComments &&\n           ForEachMacros == R.ForEachMacros &&\n           IncludeStyle.IncludeBlocks == R.IncludeStyle.IncludeBlocks &&\n           IncludeStyle.IncludeCategories == R.IncludeStyle.IncludeCategories &&\n           IncludeStyle.IncludeIsMainRegex ==\n               R.IncludeStyle.IncludeIsMainRegex &&\n           IncludeStyle.IncludeIsMainSourceRegex ==\n               R.IncludeStyle.IncludeIsMainSourceRegex &&\n           IndentAccessModifiers == R.IndentAccessModifiers &&\n           IndentCaseLabels == R.IndentCaseLabels &&\n           IndentCaseBlocks == R.IndentCaseBlocks &&\n           IndentGotoLabels == R.IndentGotoLabels &&\n           IndentPPDirectives == R.IndentPPDirectives &&\n           IndentExternBlock == R.IndentExternBlock &&\n           IndentRequires == R.IndentRequires && IndentWidth == R.IndentWidth &&\n           Language == R.Language &&\n           IndentWrappedFunctionNames == R.IndentWrappedFunctionNames &&\n           JavaImportGroups == R.JavaImportGroups &&\n           JavaScriptQuotes == R.JavaScriptQuotes &&\n           JavaScriptWrapImports == R.JavaScriptWrapImports &&\n           KeepEmptyLinesAtTheStartOfBlocks ==\n               R.KeepEmptyLinesAtTheStartOfBlocks &&\n           MacroBlockBegin == R.MacroBlockBegin &&\n           MacroBlockEnd == R.MacroBlockEnd &&\n           MaxEmptyLinesToKeep == R.MaxEmptyLinesToKeep &&\n           NamespaceIndentation == R.NamespaceIndentation &&\n           NamespaceMacros == R.NamespaceMacros &&\n           ObjCBinPackProtocolList == R.ObjCBinPackProtocolList &&\n           ObjCBlockIndentWidth == R.ObjCBlockIndentWidth &&\n           ObjCBreakBeforeNestedBlockParam ==\n               R.ObjCBreakBeforeNestedBlockParam &&\n           ObjCSpaceAfterProperty == R.ObjCSpaceAfterProperty &&\n           ObjCSpaceBeforeProtocolList == R.ObjCSpaceBeforeProtocolList &&\n           PenaltyBreakAssignment == R.PenaltyBreakAssignment &&\n           PenaltyBreakBeforeFirstCallParameter ==\n               R.PenaltyBreakBeforeFirstCallParameter &&\n           PenaltyBreakComment == R.PenaltyBreakComment &&\n           PenaltyBreakFirstLessLess == R.PenaltyBreakFirstLessLess &&\n           PenaltyBreakString == R.PenaltyBreakString &&\n           PenaltyExcessCharacter == R.PenaltyExcessCharacter &&\n           PenaltyReturnTypeOnItsOwnLine == R.PenaltyReturnTypeOnItsOwnLine &&\n           PenaltyBreakTemplateDeclaration ==\n               R.PenaltyBreakTemplateDeclaration &&\n           PointerAlignment == R.PointerAlignment &&\n           RawStringFormats == R.RawStringFormats &&\n           ShortNamespaceLines == R.ShortNamespaceLines &&\n           SortIncludes == R.SortIncludes &&\n           SortJavaStaticImport == R.SortJavaStaticImport &&\n           SpaceAfterCStyleCast == R.SpaceAfterCStyleCast &&\n           SpaceAfterLogicalNot == R.SpaceAfterLogicalNot &&\n           SpaceAfterTemplateKeyword == R.SpaceAfterTemplateKeyword &&\n           SpaceBeforeAssignmentOperators == R.SpaceBeforeAssignmentOperators &&\n           SpaceBeforeCaseColon == R.SpaceBeforeCaseColon &&\n           SpaceBeforeCpp11BracedList == R.SpaceBeforeCpp11BracedList &&\n           SpaceBeforeCtorInitializerColon ==\n               R.SpaceBeforeCtorInitializerColon &&\n           SpaceBeforeInheritanceColon == R.SpaceBeforeInheritanceColon &&\n           SpaceBeforeParens == R.SpaceBeforeParens &&\n           SpaceAroundPointerQualifiers == R.SpaceAroundPointerQualifiers &&\n           SpaceBeforeRangeBasedForLoopColon ==\n               R.SpaceBeforeRangeBasedForLoopColon &&\n           SpaceInEmptyBlock == R.SpaceInEmptyBlock &&\n           SpaceInEmptyParentheses == R.SpaceInEmptyParentheses &&\n           SpacesBeforeTrailingComments == R.SpacesBeforeTrailingComments &&\n           SpacesInAngles == R.SpacesInAngles &&\n           SpacesInConditionalStatement == R.SpacesInConditionalStatement &&\n           SpacesInContainerLiterals == R.SpacesInContainerLiterals &&\n           SpacesInCStyleCastParentheses == R.SpacesInCStyleCastParentheses &&\n           SpacesInLineCommentPrefix.Minimum ==\n               R.SpacesInLineCommentPrefix.Minimum &&\n           SpacesInLineCommentPrefix.Maximum ==\n               R.SpacesInLineCommentPrefix.Maximum &&\n           SpacesInParentheses == R.SpacesInParentheses &&\n           SpacesInSquareBrackets == R.SpacesInSquareBrackets &&\n           SpaceBeforeSquareBrackets == R.SpaceBeforeSquareBrackets &&\n           BitFieldColonSpacing == R.BitFieldColonSpacing &&\n           Standard == R.Standard &&\n           StatementAttributeLikeMacros == R.StatementAttributeLikeMacros &&\n           StatementMacros == R.StatementMacros && TabWidth == R.TabWidth &&\n           UseTab == R.UseTab && UseCRLF == R.UseCRLF &&\n           TypenameMacros == R.TypenameMacros;\n  }\n\n  llvm::Optional<FormatStyle> GetLanguageStyle(LanguageKind Language) const;\n\n  // Stores per-language styles. A FormatStyle instance inside has an empty\n  // StyleSet. A FormatStyle instance returned by the Get method has its\n  // StyleSet set to a copy of the originating StyleSet, effectively keeping the\n  // internal representation of that StyleSet alive.\n  //\n  // The memory management and ownership reminds of a birds nest: chicks\n  // leaving the nest take photos of the nest with them.\n  struct FormatStyleSet {\n    typedef std::map<FormatStyle::LanguageKind, FormatStyle> MapType;\n\n    llvm::Optional<FormatStyle> Get(FormatStyle::LanguageKind Language) const;\n\n    // Adds \\p Style to this FormatStyleSet. Style must not have an associated\n    // FormatStyleSet.\n    // Style.Language should be different than LK_None. If this FormatStyleSet\n    // already contains an entry for Style.Language, that gets replaced with the\n    // passed Style.\n    void Add(FormatStyle Style);\n\n    // Clears this FormatStyleSet.\n    void Clear();\n\n  private:\n    std::shared_ptr<MapType> Styles;\n  };\n\n  static FormatStyleSet BuildStyleSetFromConfiguration(\n      const FormatStyle &MainStyle,\n      const std::vector<FormatStyle> &ConfigurationStyles);\n\nprivate:\n  FormatStyleSet StyleSet;\n\n  friend std::error_code\n  parseConfiguration(llvm::MemoryBufferRef Config, FormatStyle *Style,\n                     bool AllowUnknownOptions,\n                     llvm::SourceMgr::DiagHandlerTy DiagHandler,\n                     void *DiagHandlerCtxt);\n};\n\n/// Returns a format style complying with the LLVM coding standards:\n/// http://llvm.org/docs/CodingStandards.html.\nFormatStyle getLLVMStyle(\n    FormatStyle::LanguageKind Language = FormatStyle::LanguageKind::LK_Cpp);\n\n/// Returns a format style complying with one of Google's style guides:\n/// http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml.\n/// http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml.\n/// https://developers.google.com/protocol-buffers/docs/style.\nFormatStyle getGoogleStyle(FormatStyle::LanguageKind Language);\n\n/// Returns a format style complying with Chromium's style guide:\n/// http://www.chromium.org/developers/coding-style.\nFormatStyle getChromiumStyle(FormatStyle::LanguageKind Language);\n\n/// Returns a format style complying with Mozilla's style guide:\n/// https://developer.mozilla.org/en-US/docs/Developer_Guide/Coding_Style.\nFormatStyle getMozillaStyle();\n\n/// Returns a format style complying with Webkit's style guide:\n/// http://www.webkit.org/coding/coding-style.html\nFormatStyle getWebKitStyle();\n\n/// Returns a format style complying with GNU Coding Standards:\n/// http://www.gnu.org/prep/standards/standards.html\nFormatStyle getGNUStyle();\n\n/// Returns a format style complying with Microsoft style guide:\n/// https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference?view=vs-2017\nFormatStyle getMicrosoftStyle(FormatStyle::LanguageKind Language);\n\n/// Returns style indicating formatting should be not applied at all.\nFormatStyle getNoStyle();\n\n/// Gets a predefined style for the specified language by name.\n///\n/// Currently supported names: LLVM, Google, Chromium, Mozilla. Names are\n/// compared case-insensitively.\n///\n/// Returns ``true`` if the Style has been set.\nbool getPredefinedStyle(StringRef Name, FormatStyle::LanguageKind Language,\n                        FormatStyle *Style);\n\n/// Parse configuration from YAML-formatted text.\n///\n/// Style->Language is used to get the base style, if the ``BasedOnStyle``\n/// option is present.\n///\n/// The FormatStyleSet of Style is reset.\n///\n/// When ``BasedOnStyle`` is not present, options not present in the YAML\n/// document, are retained in \\p Style.\n///\n/// If AllowUnknownOptions is true, no errors are emitted if unknown\n/// format options are occured.\n///\n/// If set all diagnostics are emitted through the DiagHandler.\nstd::error_code\nparseConfiguration(llvm::MemoryBufferRef Config, FormatStyle *Style,\n                   bool AllowUnknownOptions = false,\n                   llvm::SourceMgr::DiagHandlerTy DiagHandler = nullptr,\n                   void *DiagHandlerCtx = nullptr);\n\n/// Like above but accepts an unnamed buffer.\ninline std::error_code parseConfiguration(StringRef Config, FormatStyle *Style,\n                                          bool AllowUnknownOptions = false) {\n  return parseConfiguration(llvm::MemoryBufferRef(Config, \"YAML\"), Style,\n                            AllowUnknownOptions);\n}\n\n/// Gets configuration in a YAML string.\nstd::string configurationAsText(const FormatStyle &Style);\n\n/// Returns the replacements necessary to sort all ``#include`` blocks\n/// that are affected by ``Ranges``.\ntooling::Replacements sortIncludes(const FormatStyle &Style, StringRef Code,\n                                   ArrayRef<tooling::Range> Ranges,\n                                   StringRef FileName,\n                                   unsigned *Cursor = nullptr);\n\n/// Returns the replacements corresponding to applying and formatting\n/// \\p Replaces on success; otheriwse, return an llvm::Error carrying\n/// llvm::StringError.\nllvm::Expected<tooling::Replacements>\nformatReplacements(StringRef Code, const tooling::Replacements &Replaces,\n                   const FormatStyle &Style);\n\n/// Returns the replacements corresponding to applying \\p Replaces and\n/// cleaning up the code after that on success; otherwise, return an llvm::Error\n/// carrying llvm::StringError.\n/// This also supports inserting/deleting C++ #include directives:\n/// - If a replacement has offset UINT_MAX, length 0, and a replacement text\n///   that is an #include directive, this will insert the #include into the\n///   correct block in the \\p Code.\n/// - If a replacement has offset UINT_MAX, length 1, and a replacement text\n///   that is the name of the header to be removed, the header will be removed\n///   from \\p Code if it exists.\n/// The include manipulation is done via `tooling::HeaderInclude`, see its\n/// documentation for more details on how include insertion points are found and\n/// what edits are produced.\nllvm::Expected<tooling::Replacements>\ncleanupAroundReplacements(StringRef Code, const tooling::Replacements &Replaces,\n                          const FormatStyle &Style);\n\n/// Represents the status of a formatting attempt.\nstruct FormattingAttemptStatus {\n  /// A value of ``false`` means that any of the affected ranges were not\n  /// formatted due to a non-recoverable syntax error.\n  bool FormatComplete = true;\n\n  /// If ``FormatComplete`` is false, ``Line`` records a one-based\n  /// original line number at which a syntax error might have occurred. This is\n  /// based on a best-effort analysis and could be imprecise.\n  unsigned Line = 0;\n};\n\n/// Reformats the given \\p Ranges in \\p Code.\n///\n/// Each range is extended on either end to its next bigger logic unit, i.e.\n/// everything that might influence its formatting or might be influenced by its\n/// formatting.\n///\n/// Returns the ``Replacements`` necessary to make all \\p Ranges comply with\n/// \\p Style.\n///\n/// If ``Status`` is non-null, its value will be populated with the status of\n/// this formatting attempt. See \\c FormattingAttemptStatus.\ntooling::Replacements reformat(const FormatStyle &Style, StringRef Code,\n                               ArrayRef<tooling::Range> Ranges,\n                               StringRef FileName = \"<stdin>\",\n                               FormattingAttemptStatus *Status = nullptr);\n\n/// Same as above, except if ``IncompleteFormat`` is non-null, its value\n/// will be set to true if any of the affected ranges were not formatted due to\n/// a non-recoverable syntax error.\ntooling::Replacements reformat(const FormatStyle &Style, StringRef Code,\n                               ArrayRef<tooling::Range> Ranges,\n                               StringRef FileName, bool *IncompleteFormat);\n\n/// Clean up any erroneous/redundant code in the given \\p Ranges in \\p\n/// Code.\n///\n/// Returns the ``Replacements`` that clean up all \\p Ranges in \\p Code.\ntooling::Replacements cleanup(const FormatStyle &Style, StringRef Code,\n                              ArrayRef<tooling::Range> Ranges,\n                              StringRef FileName = \"<stdin>\");\n\n/// Fix namespace end comments in the given \\p Ranges in \\p Code.\n///\n/// Returns the ``Replacements`` that fix the namespace comments in all\n/// \\p Ranges in \\p Code.\ntooling::Replacements fixNamespaceEndComments(const FormatStyle &Style,\n                                              StringRef Code,\n                                              ArrayRef<tooling::Range> Ranges,\n                                              StringRef FileName = \"<stdin>\");\n\n/// Sort consecutive using declarations in the given \\p Ranges in\n/// \\p Code.\n///\n/// Returns the ``Replacements`` that sort the using declarations in all\n/// \\p Ranges in \\p Code.\ntooling::Replacements sortUsingDeclarations(const FormatStyle &Style,\n                                            StringRef Code,\n                                            ArrayRef<tooling::Range> Ranges,\n                                            StringRef FileName = \"<stdin>\");\n\n/// Returns the ``LangOpts`` that the formatter expects you to set.\n///\n/// \\param Style determines specific settings for lexing mode.\nLangOptions getFormattingLangOpts(const FormatStyle &Style = getLLVMStyle());\n\n/// Description to be used for help text for a ``llvm::cl`` option for\n/// specifying format style. The description is closely related to the operation\n/// of ``getStyle()``.\nextern const char *StyleOptionHelpDescription;\n\n/// The suggested format style to use by default. This allows tools using\n/// `getStyle` to have a consistent default style.\n/// Different builds can modify the value to the preferred styles.\nextern const char *DefaultFormatStyle;\n\n/// The suggested predefined style to use as the fallback style in `getStyle`.\n/// Different builds can modify the value to the preferred styles.\nextern const char *DefaultFallbackStyle;\n\n/// Construct a FormatStyle based on ``StyleName``.\n///\n/// ``StyleName`` can take several forms:\n/// * \"{<key>: <value>, ...}\" - Set specic style parameters.\n/// * \"<style name>\" - One of the style names supported by\n/// getPredefinedStyle().\n/// * \"file\" - Load style configuration from a file called ``.clang-format``\n/// located in one of the parent directories of ``FileName`` or the current\n/// directory if ``FileName`` is empty.\n///\n/// \\param[in] StyleName Style name to interpret according to the description\n/// above.\n/// \\param[in] FileName Path to start search for .clang-format if ``StyleName``\n/// == \"file\".\n/// \\param[in] FallbackStyle The name of a predefined style used to fallback to\n/// in case \\p StyleName is \"file\" and no file can be found.\n/// \\param[in] Code The actual code to be formatted. Used to determine the\n/// language if the filename isn't sufficient.\n/// \\param[in] FS The underlying file system, in which the file resides. By\n/// default, the file system is the real file system.\n/// \\param[in] AllowUnknownOptions If true, unknown format options only\n///             emit a warning. If false, errors are emitted on unknown format\n///             options.\n///\n/// \\returns FormatStyle as specified by ``StyleName``. If ``StyleName`` is\n/// \"file\" and no file is found, returns ``FallbackStyle``. If no style could be\n/// determined, returns an Error.\nllvm::Expected<FormatStyle> getStyle(StringRef StyleName, StringRef FileName,\n                                     StringRef FallbackStyle,\n                                     StringRef Code = \"\",\n                                     llvm::vfs::FileSystem *FS = nullptr,\n                                     bool AllowUnknownOptions = false);\n\n// Guesses the language from the ``FileName`` and ``Code`` to be formatted.\n// Defaults to FormatStyle::LK_Cpp.\nFormatStyle::LanguageKind guessLanguage(StringRef FileName, StringRef Code);\n\n// Returns a string representation of ``Language``.\ninline StringRef getLanguageName(FormatStyle::LanguageKind Language) {\n  switch (Language) {\n  case FormatStyle::LK_Cpp:\n    return \"C++\";\n  case FormatStyle::LK_CSharp:\n    return \"CSharp\";\n  case FormatStyle::LK_ObjC:\n    return \"Objective-C\";\n  case FormatStyle::LK_Java:\n    return \"Java\";\n  case FormatStyle::LK_JavaScript:\n    return \"JavaScript\";\n  case FormatStyle::LK_Proto:\n    return \"Proto\";\n  case FormatStyle::LK_TableGen:\n    return \"TableGen\";\n  case FormatStyle::LK_TextProto:\n    return \"TextProto\";\n  default:\n    return \"Unknown\";\n  }\n}\n\n} // end namespace format\n} // end namespace clang\n\nnamespace std {\ntemplate <>\nstruct is_error_code_enum<clang::format::ParseError> : std::true_type {};\n} // namespace std\n\n#endif // LLVM_CLANG_FORMAT_FORMAT_H\n"}, "69": {"id": 69, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/ASTUnit.h", "content": "//===- ASTUnit.h - ASTUnit utility ------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// ASTUnit utility class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_FRONTEND_ASTUNIT_H\n#define LLVM_CLANG_FRONTEND_ASTUNIT_H\n\n#include \"clang-c/Index.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/FileSystemOptions.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Basic/TargetOptions.h\"\n#include \"clang/Lex/HeaderSearchOptions.h\"\n#include \"clang/Lex/ModuleLoader.h\"\n#include \"clang/Lex/PreprocessingRecord.h\"\n#include \"clang/Sema/CodeCompleteConsumer.h\"\n#include \"clang/Serialization/ASTBitCodes.h\"\n#include \"clang/Frontend/PrecompiledPreamble.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <memory>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass MemoryBuffer;\n\nnamespace vfs {\n\nclass FileSystem;\n\n} // namespace vfs\n} // namespace llvm\n\nnamespace clang {\n\nclass ASTContext;\nclass ASTDeserializationListener;\nclass ASTMutationListener;\nclass ASTReader;\nclass CompilerInstance;\nclass CompilerInvocation;\nclass Decl;\nclass FileEntry;\nclass FileManager;\nclass FrontendAction;\nclass HeaderSearch;\nclass InputKind;\nclass InMemoryModuleCache;\nclass PCHContainerOperations;\nclass PCHContainerReader;\nclass Preprocessor;\nclass PreprocessorOptions;\nclass Sema;\nclass TargetInfo;\n\n/// \\brief Enumerates the available scopes for skipping function bodies.\nenum class SkipFunctionBodiesScope { None, Preamble, PreambleAndMainFile };\n\n/// \\brief Enumerates the available kinds for capturing diagnostics.\nenum class CaptureDiagsKind { None, All, AllWithoutNonErrorsFromIncludes };\n\n/// Utility class for loading a ASTContext from an AST file.\nclass ASTUnit {\npublic:\n  struct StandaloneFixIt {\n    std::pair<unsigned, unsigned> RemoveRange;\n    std::pair<unsigned, unsigned> InsertFromRange;\n    std::string CodeToInsert;\n    bool BeforePreviousInsertions;\n  };\n\n  struct StandaloneDiagnostic {\n    unsigned ID;\n    DiagnosticsEngine::Level Level;\n    std::string Message;\n    std::string Filename;\n    unsigned LocOffset;\n    std::vector<std::pair<unsigned, unsigned>> Ranges;\n    std::vector<StandaloneFixIt> FixIts;\n  };\n\nprivate:\n  std::shared_ptr<LangOptions>            LangOpts;\n  IntrusiveRefCntPtr<DiagnosticsEngine>   Diagnostics;\n  IntrusiveRefCntPtr<FileManager>         FileMgr;\n  IntrusiveRefCntPtr<SourceManager>       SourceMgr;\n  IntrusiveRefCntPtr<InMemoryModuleCache> ModuleCache;\n  std::unique_ptr<HeaderSearch>           HeaderInfo;\n  IntrusiveRefCntPtr<TargetInfo>          Target;\n  std::shared_ptr<Preprocessor>           PP;\n  IntrusiveRefCntPtr<ASTContext>          Ctx;\n  std::shared_ptr<TargetOptions>          TargetOpts;\n  std::shared_ptr<HeaderSearchOptions>    HSOpts;\n  std::shared_ptr<PreprocessorOptions>    PPOpts;\n  IntrusiveRefCntPtr<ASTReader> Reader;\n  bool HadModuleLoaderFatalFailure = false;\n\n  struct ASTWriterData;\n  std::unique_ptr<ASTWriterData> WriterData;\n\n  FileSystemOptions FileSystemOpts;\n\n  /// The AST consumer that received information about the translation\n  /// unit as it was parsed or loaded.\n  std::unique_ptr<ASTConsumer> Consumer;\n\n  /// The semantic analysis object used to type-check the translation\n  /// unit.\n  std::unique_ptr<Sema> TheSema;\n\n  /// Optional owned invocation, just used to make the invocation used in\n  /// LoadFromCommandLine available.\n  std::shared_ptr<CompilerInvocation> Invocation;\n\n  /// Fake module loader: the AST unit doesn't need to load any modules.\n  TrivialModuleLoader ModuleLoader;\n\n  // OnlyLocalDecls - when true, walking this AST should only visit declarations\n  // that come from the AST itself, not from included precompiled headers.\n  // FIXME: This is temporary; eventually, CIndex will always do this.\n  bool OnlyLocalDecls = false;\n\n  /// Whether to capture any diagnostics produced.\n  CaptureDiagsKind CaptureDiagnostics = CaptureDiagsKind::None;\n\n  /// Track whether the main file was loaded from an AST or not.\n  bool MainFileIsAST;\n\n  /// What kind of translation unit this AST represents.\n  TranslationUnitKind TUKind = TU_Complete;\n\n  /// Whether we should time each operation.\n  bool WantTiming;\n\n  /// Whether the ASTUnit should delete the remapped buffers.\n  bool OwnsRemappedFileBuffers = true;\n\n  /// Track the top-level decls which appeared in an ASTUnit which was loaded\n  /// from a source file.\n  //\n  // FIXME: This is just an optimization hack to avoid deserializing large parts\n  // of a PCH file when using the Index library on an ASTUnit loaded from\n  // source. In the long term we should make the Index library use efficient and\n  // more scalable search mechanisms.\n  std::vector<Decl*> TopLevelDecls;\n\n  /// Sorted (by file offset) vector of pairs of file offset/Decl.\n  using LocDeclsTy = SmallVector<std::pair<unsigned, Decl *>, 64>;\n  using FileDeclsTy = llvm::DenseMap<FileID, std::unique_ptr<LocDeclsTy>>;\n\n  /// Map from FileID to the file-level declarations that it contains.\n  /// The files and decls are only local (and non-preamble) ones.\n  FileDeclsTy FileDecls;\n\n  /// The name of the original source file used to generate this ASTUnit.\n  std::string OriginalSourceFile;\n\n  /// The set of diagnostics produced when creating the preamble.\n  SmallVector<StandaloneDiagnostic, 4> PreambleDiagnostics;\n\n  /// The set of diagnostics produced when creating this\n  /// translation unit.\n  SmallVector<StoredDiagnostic, 4> StoredDiagnostics;\n\n  /// The set of diagnostics produced when failing to parse, e.g. due\n  /// to failure to load the PCH.\n  SmallVector<StoredDiagnostic, 4> FailedParseDiagnostics;\n\n  /// The number of stored diagnostics that come from the driver\n  /// itself.\n  ///\n  /// Diagnostics that come from the driver are retained from one parse to\n  /// the next.\n  unsigned NumStoredDiagnosticsFromDriver = 0;\n\n  /// Counter that determines when we want to try building a\n  /// precompiled preamble.\n  ///\n  /// If zero, we will never build a precompiled preamble. Otherwise,\n  /// it's treated as a counter that decrements each time we reparse\n  /// without the benefit of a precompiled preamble. When it hits 1,\n  /// we'll attempt to rebuild the precompiled header. This way, if\n  /// building the precompiled preamble fails, we won't try again for\n  /// some number of calls.\n  unsigned PreambleRebuildCountdown = 0;\n\n  /// Counter indicating how often the preamble was build in total.\n  unsigned PreambleCounter = 0;\n\n  /// Cache pairs \"filename - source location\"\n  ///\n  /// Cache contains only source locations from preamble so it is\n  /// guaranteed that they stay valid when the SourceManager is recreated.\n  /// This cache is used when loading preamble to increase performance\n  /// of that loading. It must be cleared when preamble is recreated.\n  llvm::StringMap<SourceLocation> PreambleSrcLocCache;\n\n  /// The contents of the preamble.\n  llvm::Optional<PrecompiledPreamble> Preamble;\n\n  /// When non-NULL, this is the buffer used to store the contents of\n  /// the main file when it has been padded for use with the precompiled\n  /// preamble.\n  std::unique_ptr<llvm::MemoryBuffer> SavedMainFileBuffer;\n\n  /// The number of warnings that occurred while parsing the preamble.\n  ///\n  /// This value will be used to restore the state of the \\c DiagnosticsEngine\n  /// object when re-using the precompiled preamble. Note that only the\n  /// number of warnings matters, since we will not save the preamble\n  /// when any errors are present.\n  unsigned NumWarningsInPreamble = 0;\n\n  /// A list of the serialization ID numbers for each of the top-level\n  /// declarations parsed within the precompiled preamble.\n  std::vector<serialization::DeclID> TopLevelDeclsInPreamble;\n\n  /// Whether we should be caching code-completion results.\n  bool ShouldCacheCodeCompletionResults : 1;\n\n  /// Whether to include brief documentation within the set of code\n  /// completions cached.\n  bool IncludeBriefCommentsInCodeCompletion : 1;\n\n  /// True if non-system source files should be treated as volatile\n  /// (likely to change while trying to use them).\n  bool UserFilesAreVolatile : 1;\n\n  static void ConfigureDiags(IntrusiveRefCntPtr<DiagnosticsEngine> Diags,\n                             ASTUnit &AST, CaptureDiagsKind CaptureDiagnostics);\n\n  void TranslateStoredDiagnostics(FileManager &FileMgr,\n                                  SourceManager &SrcMan,\n                      const SmallVectorImpl<StandaloneDiagnostic> &Diags,\n                            SmallVectorImpl<StoredDiagnostic> &Out);\n\n  void clearFileLevelDecls();\n\npublic:\n  /// A cached code-completion result, which may be introduced in one of\n  /// many different contexts.\n  struct CachedCodeCompletionResult {\n    /// The code-completion string corresponding to this completion\n    /// result.\n    CodeCompletionString *Completion;\n\n    /// A bitmask that indicates which code-completion contexts should\n    /// contain this completion result.\n    ///\n    /// The bits in the bitmask correspond to the values of\n    /// CodeCompleteContext::Kind. To map from a completion context kind to a\n    /// bit, shift 1 by that number of bits. Many completions can occur in\n    /// several different contexts.\n    uint64_t ShowInContexts;\n\n    /// The priority given to this code-completion result.\n    unsigned Priority;\n\n    /// The libclang cursor kind corresponding to this code-completion\n    /// result.\n    CXCursorKind Kind;\n\n    /// The availability of this code-completion result.\n    CXAvailabilityKind Availability;\n\n    /// The simplified type class for a non-macro completion result.\n    SimplifiedTypeClass TypeClass;\n\n    /// The type of a non-macro completion result, stored as a unique\n    /// integer used by the string map of cached completion types.\n    ///\n    /// This value will be zero if the type is not known, or a unique value\n    /// determined by the formatted type string. Se \\c CachedCompletionTypes\n    /// for more information.\n    unsigned Type;\n  };\n\n  /// Retrieve the mapping from formatted type names to unique type\n  /// identifiers.\n  llvm::StringMap<unsigned> &getCachedCompletionTypes() {\n    return CachedCompletionTypes;\n  }\n\n  /// Retrieve the allocator used to cache global code completions.\n  std::shared_ptr<GlobalCodeCompletionAllocator>\n  getCachedCompletionAllocator() {\n    return CachedCompletionAllocator;\n  }\n\n  CodeCompletionTUInfo &getCodeCompletionTUInfo() {\n    if (!CCTUInfo)\n      CCTUInfo = std::make_unique<CodeCompletionTUInfo>(\n          std::make_shared<GlobalCodeCompletionAllocator>());\n    return *CCTUInfo;\n  }\n\nprivate:\n  /// Allocator used to store cached code completions.\n  std::shared_ptr<GlobalCodeCompletionAllocator> CachedCompletionAllocator;\n\n  std::unique_ptr<CodeCompletionTUInfo> CCTUInfo;\n\n  /// The set of cached code-completion results.\n  std::vector<CachedCodeCompletionResult> CachedCompletionResults;\n\n  /// A mapping from the formatted type name to a unique number for that\n  /// type, which is used for type equality comparisons.\n  llvm::StringMap<unsigned> CachedCompletionTypes;\n\n  /// A string hash of the top-level declaration and macro definition\n  /// names processed the last time that we reparsed the file.\n  ///\n  /// This hash value is used to determine when we need to refresh the\n  /// global code-completion cache.\n  unsigned CompletionCacheTopLevelHashValue = 0;\n\n  /// A string hash of the top-level declaration and macro definition\n  /// names processed the last time that we reparsed the precompiled preamble.\n  ///\n  /// This hash value is used to determine when we need to refresh the\n  /// global code-completion cache after a rebuild of the precompiled preamble.\n  unsigned PreambleTopLevelHashValue = 0;\n\n  /// The current hash value for the top-level declaration and macro\n  /// definition names\n  unsigned CurrentTopLevelHashValue = 0;\n\n  /// Bit used by CIndex to mark when a translation unit may be in an\n  /// inconsistent state, and is not safe to free.\n  unsigned UnsafeToFree : 1;\n\n  /// \\brief Enumerator specifying the scope for skipping function bodies.\n  SkipFunctionBodiesScope SkipFunctionBodies = SkipFunctionBodiesScope::None;\n\n  /// Cache any \"global\" code-completion results, so that we can avoid\n  /// recomputing them with each completion.\n  void CacheCodeCompletionResults();\n\n  /// Clear out and deallocate\n  void ClearCachedCompletionResults();\n\n  explicit ASTUnit(bool MainFileIsAST);\n\n  bool Parse(std::shared_ptr<PCHContainerOperations> PCHContainerOps,\n             std::unique_ptr<llvm::MemoryBuffer> OverrideMainBuffer,\n             IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS);\n\n  std::unique_ptr<llvm::MemoryBuffer> getMainBufferWithPrecompiledPreamble(\n      std::shared_ptr<PCHContainerOperations> PCHContainerOps,\n      CompilerInvocation &PreambleInvocationIn,\n      IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS, bool AllowRebuild = true,\n      unsigned MaxLines = 0);\n  void RealizeTopLevelDeclsFromPreamble();\n\n  /// Transfers ownership of the objects (like SourceManager) from\n  /// \\param CI to this ASTUnit.\n  void transferASTDataFromCompilerInstance(CompilerInstance &CI);\n\n  /// Allows us to assert that ASTUnit is not being used concurrently,\n  /// which is not supported.\n  ///\n  /// Clients should create instances of the ConcurrencyCheck class whenever\n  /// using the ASTUnit in a way that isn't intended to be concurrent, which is\n  /// just about any usage.\n  /// Becomes a noop in release mode; only useful for debug mode checking.\n  class ConcurrencyState {\n    void *Mutex; // a std::recursive_mutex in debug;\n\n  public:\n    ConcurrencyState();\n    ~ConcurrencyState();\n\n    void start();\n    void finish();\n  };\n  ConcurrencyState ConcurrencyCheckValue;\n\npublic:\n  friend class ConcurrencyCheck;\n\n  class ConcurrencyCheck {\n    ASTUnit &Self;\n\n  public:\n    explicit ConcurrencyCheck(ASTUnit &Self) : Self(Self) {\n      Self.ConcurrencyCheckValue.start();\n    }\n\n    ~ConcurrencyCheck() {\n      Self.ConcurrencyCheckValue.finish();\n    }\n  };\n\n  ASTUnit(const ASTUnit &) = delete;\n  ASTUnit &operator=(const ASTUnit &) = delete;\n  ~ASTUnit();\n\n  bool isMainFileAST() const { return MainFileIsAST; }\n\n  bool isUnsafeToFree() const { return UnsafeToFree; }\n  void setUnsafeToFree(bool Value) { UnsafeToFree = Value; }\n\n  const DiagnosticsEngine &getDiagnostics() const { return *Diagnostics; }\n  DiagnosticsEngine &getDiagnostics() { return *Diagnostics; }\n\n  const SourceManager &getSourceManager() const { return *SourceMgr; }\n  SourceManager &getSourceManager() { return *SourceMgr; }\n\n  const Preprocessor &getPreprocessor() const { return *PP; }\n  Preprocessor &getPreprocessor() { return *PP; }\n  std::shared_ptr<Preprocessor> getPreprocessorPtr() const { return PP; }\n\n  const ASTContext &getASTContext() const { return *Ctx; }\n  ASTContext &getASTContext() { return *Ctx; }\n\n  void setASTContext(ASTContext *ctx) { Ctx = ctx; }\n  void setPreprocessor(std::shared_ptr<Preprocessor> pp);\n\n  /// Enable source-range based diagnostic messages.\n  ///\n  /// If diagnostic messages with source-range information are to be expected\n  /// and AST comes not from file (e.g. after LoadFromCompilerInvocation) this\n  /// function has to be called.\n  /// The function is to be called only once and the AST should be associated\n  /// with the same source file afterwards.\n  void enableSourceFileDiagnostics();\n\n  bool hasSema() const { return (bool)TheSema; }\n\n  Sema &getSema() const {\n    assert(TheSema && \"ASTUnit does not have a Sema object!\");\n    return *TheSema;\n  }\n\n  const LangOptions &getLangOpts() const {\n    assert(LangOpts && \"ASTUnit does not have language options\");\n    return *LangOpts;\n  }\n\n  const HeaderSearchOptions &getHeaderSearchOpts() const {\n    assert(HSOpts && \"ASTUnit does not have header search options\");\n    return *HSOpts;\n  }\n\n  const PreprocessorOptions &getPreprocessorOpts() const {\n    assert(PPOpts && \"ASTUnit does not have preprocessor options\");\n    return *PPOpts;\n  }\n\n  const FileManager &getFileManager() const { return *FileMgr; }\n  FileManager &getFileManager() { return *FileMgr; }\n\n  const FileSystemOptions &getFileSystemOpts() const { return FileSystemOpts; }\n\n  IntrusiveRefCntPtr<ASTReader> getASTReader() const;\n\n  StringRef getOriginalSourceFileName() const {\n    return OriginalSourceFile;\n  }\n\n  ASTMutationListener *getASTMutationListener();\n  ASTDeserializationListener *getDeserializationListener();\n\n  bool getOnlyLocalDecls() const { return OnlyLocalDecls; }\n\n  bool getOwnsRemappedFileBuffers() const { return OwnsRemappedFileBuffers; }\n  void setOwnsRemappedFileBuffers(bool val) { OwnsRemappedFileBuffers = val; }\n\n  StringRef getMainFileName() const;\n\n  /// If this ASTUnit came from an AST file, returns the filename for it.\n  StringRef getASTFileName() const;\n\n  using top_level_iterator = std::vector<Decl *>::iterator;\n\n  top_level_iterator top_level_begin() {\n    assert(!isMainFileAST() && \"Invalid call for AST based ASTUnit!\");\n    if (!TopLevelDeclsInPreamble.empty())\n      RealizeTopLevelDeclsFromPreamble();\n    return TopLevelDecls.begin();\n  }\n\n  top_level_iterator top_level_end() {\n    assert(!isMainFileAST() && \"Invalid call for AST based ASTUnit!\");\n    if (!TopLevelDeclsInPreamble.empty())\n      RealizeTopLevelDeclsFromPreamble();\n    return TopLevelDecls.end();\n  }\n\n  std::size_t top_level_size() const {\n    assert(!isMainFileAST() && \"Invalid call for AST based ASTUnit!\");\n    return TopLevelDeclsInPreamble.size() + TopLevelDecls.size();\n  }\n\n  bool top_level_empty() const {\n    assert(!isMainFileAST() && \"Invalid call for AST based ASTUnit!\");\n    return TopLevelDeclsInPreamble.empty() && TopLevelDecls.empty();\n  }\n\n  /// Add a new top-level declaration.\n  void addTopLevelDecl(Decl *D) {\n    TopLevelDecls.push_back(D);\n  }\n\n  /// Add a new local file-level declaration.\n  void addFileLevelDecl(Decl *D);\n\n  /// Get the decls that are contained in a file in the Offset/Length\n  /// range. \\p Length can be 0 to indicate a point at \\p Offset instead of\n  /// a range.\n  void findFileRegionDecls(FileID File, unsigned Offset, unsigned Length,\n                           SmallVectorImpl<Decl *> &Decls);\n\n  /// Retrieve a reference to the current top-level name hash value.\n  ///\n  /// Note: This is used internally by the top-level tracking action\n  unsigned &getCurrentTopLevelHashValue() { return CurrentTopLevelHashValue; }\n\n  /// Get the source location for the given file:line:col triplet.\n  ///\n  /// The difference with SourceManager::getLocation is that this method checks\n  /// whether the requested location points inside the precompiled preamble\n  /// in which case the returned source location will be a \"loaded\" one.\n  SourceLocation getLocation(const FileEntry *File,\n                             unsigned Line, unsigned Col) const;\n\n  /// Get the source location for the given file:offset pair.\n  SourceLocation getLocation(const FileEntry *File, unsigned Offset) const;\n\n  /// If \\p Loc is a loaded location from the preamble, returns\n  /// the corresponding local location of the main file, otherwise it returns\n  /// \\p Loc.\n  SourceLocation mapLocationFromPreamble(SourceLocation Loc) const;\n\n  /// If \\p Loc is a local location of the main file but inside the\n  /// preamble chunk, returns the corresponding loaded location from the\n  /// preamble, otherwise it returns \\p Loc.\n  SourceLocation mapLocationToPreamble(SourceLocation Loc) const;\n\n  bool isInPreambleFileID(SourceLocation Loc) const;\n  bool isInMainFileID(SourceLocation Loc) const;\n  SourceLocation getStartOfMainFileID() const;\n  SourceLocation getEndOfPreambleFileID() const;\n\n  /// \\see mapLocationFromPreamble.\n  SourceRange mapRangeFromPreamble(SourceRange R) const {\n    return SourceRange(mapLocationFromPreamble(R.getBegin()),\n                       mapLocationFromPreamble(R.getEnd()));\n  }\n\n  /// \\see mapLocationToPreamble.\n  SourceRange mapRangeToPreamble(SourceRange R) const {\n    return SourceRange(mapLocationToPreamble(R.getBegin()),\n                       mapLocationToPreamble(R.getEnd()));\n  }\n\n  unsigned getPreambleCounterForTests() const { return PreambleCounter; }\n\n  // Retrieve the diagnostics associated with this AST\n  using stored_diag_iterator = StoredDiagnostic *;\n  using stored_diag_const_iterator = const StoredDiagnostic *;\n\n  stored_diag_const_iterator stored_diag_begin() const {\n    return StoredDiagnostics.begin();\n  }\n\n  stored_diag_iterator stored_diag_begin() {\n    return StoredDiagnostics.begin();\n  }\n\n  stored_diag_const_iterator stored_diag_end() const {\n    return StoredDiagnostics.end();\n  }\n\n  stored_diag_iterator stored_diag_end() {\n    return StoredDiagnostics.end();\n  }\n\n  unsigned stored_diag_size() const { return StoredDiagnostics.size(); }\n\n  stored_diag_iterator stored_diag_afterDriver_begin() {\n    if (NumStoredDiagnosticsFromDriver > StoredDiagnostics.size())\n      NumStoredDiagnosticsFromDriver = 0;\n    return StoredDiagnostics.begin() + NumStoredDiagnosticsFromDriver;\n  }\n\n  using cached_completion_iterator =\n      std::vector<CachedCodeCompletionResult>::iterator;\n\n  cached_completion_iterator cached_completion_begin() {\n    return CachedCompletionResults.begin();\n  }\n\n  cached_completion_iterator cached_completion_end() {\n    return CachedCompletionResults.end();\n  }\n\n  unsigned cached_completion_size() const {\n    return CachedCompletionResults.size();\n  }\n\n  /// Returns an iterator range for the local preprocessing entities\n  /// of the local Preprocessor, if this is a parsed source file, or the loaded\n  /// preprocessing entities of the primary module if this is an AST file.\n  llvm::iterator_range<PreprocessingRecord::iterator>\n  getLocalPreprocessingEntities() const;\n\n  /// Type for a function iterating over a number of declarations.\n  /// \\returns true to continue iteration and false to abort.\n  using DeclVisitorFn = bool (*)(void *context, const Decl *D);\n\n  /// Iterate over local declarations (locally parsed if this is a parsed\n  /// source file or the loaded declarations of the primary module if this is an\n  /// AST file).\n  /// \\returns true if the iteration was complete or false if it was aborted.\n  bool visitLocalTopLevelDecls(void *context, DeclVisitorFn Fn);\n\n  /// Get the PCH file if one was included.\n  const FileEntry *getPCHFile();\n\n  /// Returns true if the ASTUnit was constructed from a serialized\n  /// module file.\n  bool isModuleFile() const;\n\n  std::unique_ptr<llvm::MemoryBuffer>\n  getBufferForFile(StringRef Filename, std::string *ErrorStr = nullptr);\n\n  /// Determine what kind of translation unit this AST represents.\n  TranslationUnitKind getTranslationUnitKind() const { return TUKind; }\n\n  /// Determine the input kind this AST unit represents.\n  InputKind getInputKind() const;\n\n  /// A mapping from a file name to the memory buffer that stores the\n  /// remapped contents of that file.\n  using RemappedFile = std::pair<std::string, llvm::MemoryBuffer *>;\n\n  /// Create a ASTUnit. Gets ownership of the passed CompilerInvocation.\n  static std::unique_ptr<ASTUnit>\n  create(std::shared_ptr<CompilerInvocation> CI,\n         IntrusiveRefCntPtr<DiagnosticsEngine> Diags,\n         CaptureDiagsKind CaptureDiagnostics, bool UserFilesAreVolatile);\n\n  enum WhatToLoad {\n    /// Load options and the preprocessor state.\n    LoadPreprocessorOnly,\n\n    /// Load the AST, but do not restore Sema state.\n    LoadASTOnly,\n\n    /// Load everything, including Sema.\n    LoadEverything\n  };\n\n  /// Create a ASTUnit from an AST file.\n  ///\n  /// \\param Filename - The AST file to load.\n  ///\n  /// \\param PCHContainerRdr - The PCHContainerOperations to use for loading and\n  /// creating modules.\n  /// \\param Diags - The diagnostics engine to use for reporting errors; its\n  /// lifetime is expected to extend past that of the returned ASTUnit.\n  ///\n  /// \\returns - The initialized ASTUnit or null if the AST failed to load.\n  static std::unique_ptr<ASTUnit>\n  LoadFromASTFile(const std::string &Filename,\n                  const PCHContainerReader &PCHContainerRdr, WhatToLoad ToLoad,\n                  IntrusiveRefCntPtr<DiagnosticsEngine> Diags,\n                  const FileSystemOptions &FileSystemOpts,\n                  bool UseDebugInfo = false, bool OnlyLocalDecls = false,\n                  CaptureDiagsKind CaptureDiagnostics = CaptureDiagsKind::None,\n                  bool AllowASTWithCompilerErrors = false,\n                  bool UserFilesAreVolatile = false);\n\nprivate:\n  /// Helper function for \\c LoadFromCompilerInvocation() and\n  /// \\c LoadFromCommandLine(), which loads an AST from a compiler invocation.\n  ///\n  /// \\param PrecompilePreambleAfterNParses After how many parses the preamble\n  /// of this translation unit should be precompiled, to improve the performance\n  /// of reparsing. Set to zero to disable preambles.\n  ///\n  /// \\param VFS - A llvm::vfs::FileSystem to be used for all file accesses.\n  /// Note that preamble is saved to a temporary directory on a RealFileSystem,\n  /// so in order for it to be loaded correctly, VFS should have access to\n  /// it(i.e., be an overlay over RealFileSystem).\n  ///\n  /// \\returns \\c true if a catastrophic failure occurred (which means that the\n  /// \\c ASTUnit itself is invalid), or \\c false otherwise.\n  bool LoadFromCompilerInvocation(\n      std::shared_ptr<PCHContainerOperations> PCHContainerOps,\n      unsigned PrecompilePreambleAfterNParses,\n      IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS);\n\npublic:\n  /// Create an ASTUnit from a source file, via a CompilerInvocation\n  /// object, by invoking the optionally provided ASTFrontendAction.\n  ///\n  /// \\param CI - The compiler invocation to use; it must have exactly one input\n  /// source file. The ASTUnit takes ownership of the CompilerInvocation object.\n  ///\n  /// \\param PCHContainerOps - The PCHContainerOperations to use for loading and\n  /// creating modules.\n  ///\n  /// \\param Diags - The diagnostics engine to use for reporting errors; its\n  /// lifetime is expected to extend past that of the returned ASTUnit.\n  ///\n  /// \\param Action - The ASTFrontendAction to invoke. Its ownership is not\n  /// transferred.\n  ///\n  /// \\param Unit - optionally an already created ASTUnit. Its ownership is not\n  /// transferred.\n  ///\n  /// \\param Persistent - if true the returned ASTUnit will be complete.\n  /// false means the caller is only interested in getting info through the\n  /// provided \\see Action.\n  ///\n  /// \\param ErrAST - If non-null and parsing failed without any AST to return\n  /// (e.g. because the PCH could not be loaded), this accepts the ASTUnit\n  /// mainly to allow the caller to see the diagnostics.\n  /// This will only receive an ASTUnit if a new one was created. If an already\n  /// created ASTUnit was passed in \\p Unit then the caller can check that.\n  ///\n  static ASTUnit *LoadFromCompilerInvocationAction(\n      std::shared_ptr<CompilerInvocation> CI,\n      std::shared_ptr<PCHContainerOperations> PCHContainerOps,\n      IntrusiveRefCntPtr<DiagnosticsEngine> Diags,\n      FrontendAction *Action = nullptr, ASTUnit *Unit = nullptr,\n      bool Persistent = true, StringRef ResourceFilesPath = StringRef(),\n      bool OnlyLocalDecls = false,\n      CaptureDiagsKind CaptureDiagnostics = CaptureDiagsKind::None,\n      unsigned PrecompilePreambleAfterNParses = 0,\n      bool CacheCodeCompletionResults = false,\n      bool UserFilesAreVolatile = false,\n      std::unique_ptr<ASTUnit> *ErrAST = nullptr);\n\n  /// LoadFromCompilerInvocation - Create an ASTUnit from a source file, via a\n  /// CompilerInvocation object.\n  ///\n  /// \\param CI - The compiler invocation to use; it must have exactly one input\n  /// source file. The ASTUnit takes ownership of the CompilerInvocation object.\n  ///\n  /// \\param PCHContainerOps - The PCHContainerOperations to use for loading and\n  /// creating modules.\n  ///\n  /// \\param Diags - The diagnostics engine to use for reporting errors; its\n  /// lifetime is expected to extend past that of the returned ASTUnit.\n  //\n  // FIXME: Move OnlyLocalDecls, UseBumpAllocator to setters on the ASTUnit, we\n  // shouldn't need to specify them at construction time.\n  static std::unique_ptr<ASTUnit> LoadFromCompilerInvocation(\n      std::shared_ptr<CompilerInvocation> CI,\n      std::shared_ptr<PCHContainerOperations> PCHContainerOps,\n      IntrusiveRefCntPtr<DiagnosticsEngine> Diags, FileManager *FileMgr,\n      bool OnlyLocalDecls = false,\n      CaptureDiagsKind CaptureDiagnostics = CaptureDiagsKind::None,\n      unsigned PrecompilePreambleAfterNParses = 0,\n      TranslationUnitKind TUKind = TU_Complete,\n      bool CacheCodeCompletionResults = false,\n      bool IncludeBriefCommentsInCodeCompletion = false,\n      bool UserFilesAreVolatile = false);\n\n  /// LoadFromCommandLine - Create an ASTUnit from a vector of command line\n  /// arguments, which must specify exactly one source file.\n  ///\n  /// \\param ArgBegin - The beginning of the argument vector.\n  ///\n  /// \\param ArgEnd - The end of the argument vector.\n  ///\n  /// \\param PCHContainerOps - The PCHContainerOperations to use for loading and\n  /// creating modules.\n  ///\n  /// \\param Diags - The diagnostics engine to use for reporting errors; its\n  /// lifetime is expected to extend past that of the returned ASTUnit.\n  ///\n  /// \\param ResourceFilesPath - The path to the compiler resource files.\n  ///\n  /// \\param ModuleFormat - If provided, uses the specific module format.\n  ///\n  /// \\param ErrAST - If non-null and parsing failed without any AST to return\n  /// (e.g. because the PCH could not be loaded), this accepts the ASTUnit\n  /// mainly to allow the caller to see the diagnostics.\n  ///\n  /// \\param VFS - A llvm::vfs::FileSystem to be used for all file accesses.\n  /// Note that preamble is saved to a temporary directory on a RealFileSystem,\n  /// so in order for it to be loaded correctly, VFS should have access to\n  /// it(i.e., be an overlay over RealFileSystem). RealFileSystem will be used\n  /// if \\p VFS is nullptr.\n  ///\n  // FIXME: Move OnlyLocalDecls, UseBumpAllocator to setters on the ASTUnit, we\n  // shouldn't need to specify them at construction time.\n  static ASTUnit *LoadFromCommandLine(\n      const char **ArgBegin, const char **ArgEnd,\n      std::shared_ptr<PCHContainerOperations> PCHContainerOps,\n      IntrusiveRefCntPtr<DiagnosticsEngine> Diags, StringRef ResourceFilesPath,\n      bool OnlyLocalDecls = false,\n      CaptureDiagsKind CaptureDiagnostics = CaptureDiagsKind::None,\n      ArrayRef<RemappedFile> RemappedFiles = None,\n      bool RemappedFilesKeepOriginalName = true,\n      unsigned PrecompilePreambleAfterNParses = 0,\n      TranslationUnitKind TUKind = TU_Complete,\n      bool CacheCodeCompletionResults = false,\n      bool IncludeBriefCommentsInCodeCompletion = false,\n      bool AllowPCHWithCompilerErrors = false,\n      SkipFunctionBodiesScope SkipFunctionBodies =\n          SkipFunctionBodiesScope::None,\n      bool SingleFileParse = false, bool UserFilesAreVolatile = false,\n      bool ForSerialization = false,\n      bool RetainExcludedConditionalBlocks = false,\n      llvm::Optional<StringRef> ModuleFormat = llvm::None,\n      std::unique_ptr<ASTUnit> *ErrAST = nullptr,\n      IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS = nullptr);\n\n  /// Reparse the source files using the same command-line options that\n  /// were originally used to produce this translation unit.\n  ///\n  /// \\param VFS - A llvm::vfs::FileSystem to be used for all file accesses.\n  /// Note that preamble is saved to a temporary directory on a RealFileSystem,\n  /// so in order for it to be loaded correctly, VFS should give an access to\n  /// this(i.e. be an overlay over RealFileSystem).\n  /// FileMgr->getVirtualFileSystem() will be used if \\p VFS is nullptr.\n  ///\n  /// \\returns True if a failure occurred that causes the ASTUnit not to\n  /// contain any translation-unit information, false otherwise.\n  bool Reparse(std::shared_ptr<PCHContainerOperations> PCHContainerOps,\n               ArrayRef<RemappedFile> RemappedFiles = None,\n               IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS = nullptr);\n\n  /// Free data that will be re-generated on the next parse.\n  ///\n  /// Preamble-related data is not affected.\n  void ResetForParse();\n\n  /// Perform code completion at the given file, line, and\n  /// column within this translation unit.\n  ///\n  /// \\param File The file in which code completion will occur.\n  ///\n  /// \\param Line The line at which code completion will occur.\n  ///\n  /// \\param Column The column at which code completion will occur.\n  ///\n  /// \\param IncludeMacros Whether to include macros in the code-completion\n  /// results.\n  ///\n  /// \\param IncludeCodePatterns Whether to include code patterns (such as a\n  /// for loop) in the code-completion results.\n  ///\n  /// \\param IncludeBriefComments Whether to include brief documentation within\n  /// the set of code completions returned.\n  ///\n  /// FIXME: The Diag, LangOpts, SourceMgr, FileMgr, StoredDiagnostics, and\n  /// OwnedBuffers parameters are all disgusting hacks. They will go away.\n  void CodeComplete(StringRef File, unsigned Line, unsigned Column,\n                    ArrayRef<RemappedFile> RemappedFiles, bool IncludeMacros,\n                    bool IncludeCodePatterns, bool IncludeBriefComments,\n                    CodeCompleteConsumer &Consumer,\n                    std::shared_ptr<PCHContainerOperations> PCHContainerOps,\n                    DiagnosticsEngine &Diag, LangOptions &LangOpts,\n                    SourceManager &SourceMgr, FileManager &FileMgr,\n                    SmallVectorImpl<StoredDiagnostic> &StoredDiagnostics,\n                    SmallVectorImpl<const llvm::MemoryBuffer *> &OwnedBuffers);\n\n  /// Save this translation unit to a file with the given name.\n  ///\n  /// \\returns true if there was a file error or false if the save was\n  /// successful.\n  bool Save(StringRef File);\n\n  /// Serialize this translation unit with the given output stream.\n  ///\n  /// \\returns True if an error occurred, false otherwise.\n  bool serialize(raw_ostream &OS);\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_FRONTEND_ASTUNIT_H\n"}, "70": {"id": 70, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/CommandLineSourceLoc.h", "content": "\n//===--- CommandLineSourceLoc.h - Parsing for source locations-*- C++ -*---===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Command line parsing for source locations.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_FRONTEND_COMMANDLINESOURCELOC_H\n#define LLVM_CLANG_FRONTEND_COMMANDLINESOURCELOC_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\nnamespace clang {\n\n/// A source location that has been parsed on the command line.\nstruct ParsedSourceLocation {\n  std::string FileName;\n  unsigned Line;\n  unsigned Column;\n\npublic:\n  /// Construct a parsed source location from a string; the Filename is empty on\n  /// error.\n  static ParsedSourceLocation FromString(StringRef Str) {\n    ParsedSourceLocation PSL;\n    std::pair<StringRef, StringRef> ColSplit = Str.rsplit(':');\n    std::pair<StringRef, StringRef> LineSplit =\n      ColSplit.first.rsplit(':');\n\n    // If both tail splits were valid integers, return success.\n    if (!ColSplit.second.getAsInteger(10, PSL.Column) &&\n        !LineSplit.second.getAsInteger(10, PSL.Line)) {\n      PSL.FileName = std::string(LineSplit.first);\n\n      // On the command-line, stdin may be specified via \"-\". Inside the\n      // compiler, stdin is called \"<stdin>\".\n      if (PSL.FileName == \"-\")\n        PSL.FileName = \"<stdin>\";\n    }\n\n    return PSL;\n  }\n\n  /// Serialize ParsedSourceLocation back to a string.\n  std::string ToString() const {\n    return (llvm::Twine(FileName == \"<stdin>\" ? \"-\" : FileName) + \":\" +\n            Twine(Line) + \":\" + Twine(Column))\n        .str();\n  }\n};\n\n/// A source range that has been parsed on the command line.\nstruct ParsedSourceRange {\n  std::string FileName;\n  /// The starting location of the range. The first element is the line and\n  /// the second element is the column.\n  std::pair<unsigned, unsigned> Begin;\n  /// The ending location of the range. The first element is the line and the\n  /// second element is the column.\n  std::pair<unsigned, unsigned> End;\n\n  /// Returns a parsed source range from a string or None if the string is\n  /// invalid.\n  ///\n  /// These source string has the following format:\n  ///\n  /// file:start_line:start_column[-end_line:end_column]\n  ///\n  /// If the end line and column are omitted, the starting line and columns\n  /// are used as the end values.\n  static Optional<ParsedSourceRange> fromString(StringRef Str) {\n    std::pair<StringRef, StringRef> RangeSplit = Str.rsplit('-');\n    unsigned EndLine, EndColumn;\n    bool HasEndLoc = false;\n    if (!RangeSplit.second.empty()) {\n      std::pair<StringRef, StringRef> Split = RangeSplit.second.rsplit(':');\n      if (Split.first.getAsInteger(10, EndLine) ||\n          Split.second.getAsInteger(10, EndColumn)) {\n        // The string does not end in end_line:end_column, so the '-'\n        // probably belongs to the filename which menas the whole\n        // string should be parsed.\n        RangeSplit.first = Str;\n      } else\n        HasEndLoc = true;\n    }\n    auto Begin = ParsedSourceLocation::FromString(RangeSplit.first);\n    if (Begin.FileName.empty())\n      return None;\n    if (!HasEndLoc) {\n      EndLine = Begin.Line;\n      EndColumn = Begin.Column;\n    }\n    return ParsedSourceRange{std::move(Begin.FileName),\n                             {Begin.Line, Begin.Column},\n                             {EndLine, EndColumn}};\n  }\n};\n}\n\nnamespace llvm {\n  namespace cl {\n    /// Command-line option parser that parses source locations.\n    ///\n    /// Source locations are of the form filename:line:column.\n    template<>\n    class parser<clang::ParsedSourceLocation> final\n      : public basic_parser<clang::ParsedSourceLocation> {\n    public:\n      inline bool parse(Option &O, StringRef ArgName, StringRef ArgValue,\n                 clang::ParsedSourceLocation &Val);\n    };\n\n    bool\n    parser<clang::ParsedSourceLocation>::\n    parse(Option &O, StringRef ArgName, StringRef ArgValue,\n          clang::ParsedSourceLocation &Val) {\n      using namespace clang;\n\n      Val = ParsedSourceLocation::FromString(ArgValue);\n      if (Val.FileName.empty()) {\n        errs() << \"error: \"\n               << \"source location must be of the form filename:line:column\\n\";\n        return true;\n      }\n\n      return false;\n    }\n  }\n}\n\n#endif\n"}, "71": {"id": 71, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/CompilerInstance.h", "content": "//===-- CompilerInstance.h - Clang Compiler Instance ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_FRONTEND_COMPILERINSTANCE_H_\n#define LLVM_CLANG_FRONTEND_COMPILERINSTANCE_H_\n\n#include \"clang/AST/ASTConsumer.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Frontend/CompilerInvocation.h\"\n#include \"clang/Frontend/PCHContainerOperations.h\"\n#include \"clang/Frontend/Utils.h\"\n#include \"clang/Lex/HeaderSearchOptions.h\"\n#include \"clang/Lex/ModuleLoader.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/BuryPointer.h\"\n#include <cassert>\n#include <list>\n#include <memory>\n#include <string>\n#include <utility>\n\nnamespace llvm {\nclass raw_fd_ostream;\nclass Timer;\nclass TimerGroup;\n}\n\nnamespace clang {\nclass ASTContext;\nclass ASTReader;\nclass CodeCompleteConsumer;\nclass DiagnosticsEngine;\nclass DiagnosticConsumer;\nclass ExternalASTSource;\nclass FileEntry;\nclass FileManager;\nclass FrontendAction;\nclass InMemoryModuleCache;\nclass Module;\nclass Preprocessor;\nclass Sema;\nclass SourceManager;\nclass TargetInfo;\nenum class DisableValidationForModuleKind;\n\n/// CompilerInstance - Helper class for managing a single instance of the Clang\n/// compiler.\n///\n/// The CompilerInstance serves two purposes:\n///  (1) It manages the various objects which are necessary to run the compiler,\n///      for example the preprocessor, the target information, and the AST\n///      context.\n///  (2) It provides utility routines for constructing and manipulating the\n///      common Clang objects.\n///\n/// The compiler instance generally owns the instance of all the objects that it\n/// manages. However, clients can still share objects by manually setting the\n/// object and retaking ownership prior to destroying the CompilerInstance.\n///\n/// The compiler instance is intended to simplify clients, but not to lock them\n/// in to the compiler instance for everything. When possible, utility functions\n/// come in two forms; a short form that reuses the CompilerInstance objects,\n/// and a long form that takes explicit instances of any required objects.\nclass CompilerInstance : public ModuleLoader {\n  /// The options used in this compiler instance.\n  std::shared_ptr<CompilerInvocation> Invocation;\n\n  /// The diagnostics engine instance.\n  IntrusiveRefCntPtr<DiagnosticsEngine> Diagnostics;\n\n  /// The target being compiled for.\n  IntrusiveRefCntPtr<TargetInfo> Target;\n\n  /// Auxiliary Target info.\n  IntrusiveRefCntPtr<TargetInfo> AuxTarget;\n\n  /// The file manager.\n  IntrusiveRefCntPtr<FileManager> FileMgr;\n\n  /// The source manager.\n  IntrusiveRefCntPtr<SourceManager> SourceMgr;\n\n  /// The cache of PCM files.\n  IntrusiveRefCntPtr<InMemoryModuleCache> ModuleCache;\n\n  /// The preprocessor.\n  std::shared_ptr<Preprocessor> PP;\n\n  /// The AST context.\n  IntrusiveRefCntPtr<ASTContext> Context;\n\n  /// An optional sema source that will be attached to sema.\n  IntrusiveRefCntPtr<ExternalSemaSource> ExternalSemaSrc;\n\n  /// The AST consumer.\n  std::unique_ptr<ASTConsumer> Consumer;\n\n  /// The code completion consumer.\n  std::unique_ptr<CodeCompleteConsumer> CompletionConsumer;\n\n  /// The semantic analysis object.\n  std::unique_ptr<Sema> TheSema;\n\n  /// The frontend timer group.\n  std::unique_ptr<llvm::TimerGroup> FrontendTimerGroup;\n\n  /// The frontend timer.\n  std::unique_ptr<llvm::Timer> FrontendTimer;\n\n  /// The ASTReader, if one exists.\n  IntrusiveRefCntPtr<ASTReader> TheASTReader;\n\n  /// The module dependency collector for crashdumps\n  std::shared_ptr<ModuleDependencyCollector> ModuleDepCollector;\n\n  /// The module provider.\n  std::shared_ptr<PCHContainerOperations> ThePCHContainerOperations;\n\n  std::vector<std::shared_ptr<DependencyCollector>> DependencyCollectors;\n\n  /// The set of top-level modules that has already been built on the\n  /// fly as part of this overall compilation action.\n  std::map<std::string, std::string, std::less<>> BuiltModules;\n\n  /// Should we delete the BuiltModules when we're done?\n  bool DeleteBuiltModules = true;\n\n  /// The location of the module-import keyword for the last module\n  /// import.\n  SourceLocation LastModuleImportLoc;\n\n  /// The result of the last module import.\n  ///\n  ModuleLoadResult LastModuleImportResult;\n\n  /// Whether we should (re)build the global module index once we\n  /// have finished with this translation unit.\n  bool BuildGlobalModuleIndex = false;\n\n  /// We have a full global module index, with all modules.\n  bool HaveFullGlobalModuleIndex = false;\n\n  /// One or more modules failed to build.\n  bool ModuleBuildFailed = false;\n\n  /// The stream for verbose output if owned, otherwise nullptr.\n  std::unique_ptr<raw_ostream> OwnedVerboseOutputStream;\n\n  /// The stream for verbose output.\n  raw_ostream *VerboseOutputStream = &llvm::errs();\n\n  /// Holds information about the output file.\n  ///\n  /// If TempFilename is not empty we must rename it to Filename at the end.\n  /// TempFilename may be empty and Filename non-empty if creating the temporary\n  /// failed.\n  struct OutputFile {\n    std::string Filename;\n    std::string TempFilename;\n\n    OutputFile(std::string filename, std::string tempFilename)\n        : Filename(std::move(filename)), TempFilename(std::move(tempFilename)) {\n    }\n  };\n\n  /// The list of active output files.\n  std::list<OutputFile> OutputFiles;\n\n  /// Force an output buffer.\n  std::unique_ptr<llvm::raw_pwrite_stream> OutputStream;\n\n  CompilerInstance(const CompilerInstance &) = delete;\n  void operator=(const CompilerInstance &) = delete;\npublic:\n  explicit CompilerInstance(\n      std::shared_ptr<PCHContainerOperations> PCHContainerOps =\n          std::make_shared<PCHContainerOperations>(),\n      InMemoryModuleCache *SharedModuleCache = nullptr);\n  ~CompilerInstance() override;\n\n  /// @name High-Level Operations\n  /// {\n\n  /// ExecuteAction - Execute the provided action against the compiler's\n  /// CompilerInvocation object.\n  ///\n  /// This function makes the following assumptions:\n  ///\n  ///  - The invocation options should be initialized. This function does not\n  ///    handle the '-help' or '-version' options, clients should handle those\n  ///    directly.\n  ///\n  ///  - The diagnostics engine should have already been created by the client.\n  ///\n  ///  - No other CompilerInstance state should have been initialized (this is\n  ///    an unchecked error).\n  ///\n  ///  - Clients should have initialized any LLVM target features that may be\n  ///    required.\n  ///\n  ///  - Clients should eventually call llvm_shutdown() upon the completion of\n  ///    this routine to ensure that any managed objects are properly destroyed.\n  ///\n  /// Note that this routine may write output to 'stderr'.\n  ///\n  /// \\param Act - The action to execute.\n  /// \\return - True on success.\n  //\n  // FIXME: Eliminate the llvm_shutdown requirement, that should either be part\n  // of the context or else not CompilerInstance specific.\n  bool ExecuteAction(FrontendAction &Act);\n\n  /// }\n  /// @name Compiler Invocation and Options\n  /// {\n\n  bool hasInvocation() const { return Invocation != nullptr; }\n\n  CompilerInvocation &getInvocation() {\n    assert(Invocation && \"Compiler instance has no invocation!\");\n    return *Invocation;\n  }\n\n  /// setInvocation - Replace the current invocation.\n  void setInvocation(std::shared_ptr<CompilerInvocation> Value);\n\n  /// Indicates whether we should (re)build the global module index.\n  bool shouldBuildGlobalModuleIndex() const;\n\n  /// Set the flag indicating whether we should (re)build the global\n  /// module index.\n  void setBuildGlobalModuleIndex(bool Build) {\n    BuildGlobalModuleIndex = Build;\n  }\n\n  /// }\n  /// @name Forwarding Methods\n  /// {\n\n  AnalyzerOptionsRef getAnalyzerOpts() {\n    return Invocation->getAnalyzerOpts();\n  }\n\n  CodeGenOptions &getCodeGenOpts() {\n    return Invocation->getCodeGenOpts();\n  }\n  const CodeGenOptions &getCodeGenOpts() const {\n    return Invocation->getCodeGenOpts();\n  }\n\n  DependencyOutputOptions &getDependencyOutputOpts() {\n    return Invocation->getDependencyOutputOpts();\n  }\n  const DependencyOutputOptions &getDependencyOutputOpts() const {\n    return Invocation->getDependencyOutputOpts();\n  }\n\n  DiagnosticOptions &getDiagnosticOpts() {\n    return Invocation->getDiagnosticOpts();\n  }\n  const DiagnosticOptions &getDiagnosticOpts() const {\n    return Invocation->getDiagnosticOpts();\n  }\n\n  FileSystemOptions &getFileSystemOpts() {\n    return Invocation->getFileSystemOpts();\n  }\n  const FileSystemOptions &getFileSystemOpts() const {\n    return Invocation->getFileSystemOpts();\n  }\n\n  FrontendOptions &getFrontendOpts() {\n    return Invocation->getFrontendOpts();\n  }\n  const FrontendOptions &getFrontendOpts() const {\n    return Invocation->getFrontendOpts();\n  }\n\n  HeaderSearchOptions &getHeaderSearchOpts() {\n    return Invocation->getHeaderSearchOpts();\n  }\n  const HeaderSearchOptions &getHeaderSearchOpts() const {\n    return Invocation->getHeaderSearchOpts();\n  }\n  std::shared_ptr<HeaderSearchOptions> getHeaderSearchOptsPtr() const {\n    return Invocation->getHeaderSearchOptsPtr();\n  }\n\n  LangOptions &getLangOpts() {\n    return *Invocation->getLangOpts();\n  }\n  const LangOptions &getLangOpts() const {\n    return *Invocation->getLangOpts();\n  }\n\n  PreprocessorOptions &getPreprocessorOpts() {\n    return Invocation->getPreprocessorOpts();\n  }\n  const PreprocessorOptions &getPreprocessorOpts() const {\n    return Invocation->getPreprocessorOpts();\n  }\n\n  PreprocessorOutputOptions &getPreprocessorOutputOpts() {\n    return Invocation->getPreprocessorOutputOpts();\n  }\n  const PreprocessorOutputOptions &getPreprocessorOutputOpts() const {\n    return Invocation->getPreprocessorOutputOpts();\n  }\n\n  TargetOptions &getTargetOpts() {\n    return Invocation->getTargetOpts();\n  }\n  const TargetOptions &getTargetOpts() const {\n    return Invocation->getTargetOpts();\n  }\n\n  /// }\n  /// @name Diagnostics Engine\n  /// {\n\n  bool hasDiagnostics() const { return Diagnostics != nullptr; }\n\n  /// Get the current diagnostics engine.\n  DiagnosticsEngine &getDiagnostics() const {\n    assert(Diagnostics && \"Compiler instance has no diagnostics!\");\n    return *Diagnostics;\n  }\n\n  /// setDiagnostics - Replace the current diagnostics engine.\n  void setDiagnostics(DiagnosticsEngine *Value);\n\n  DiagnosticConsumer &getDiagnosticClient() const {\n    assert(Diagnostics && Diagnostics->getClient() &&\n           \"Compiler instance has no diagnostic client!\");\n    return *Diagnostics->getClient();\n  }\n\n  /// }\n  /// @name VerboseOutputStream\n  /// }\n\n  /// Replace the current stream for verbose output.\n  void setVerboseOutputStream(raw_ostream &Value);\n\n  /// Replace the current stream for verbose output.\n  void setVerboseOutputStream(std::unique_ptr<raw_ostream> Value);\n\n  /// Get the current stream for verbose output.\n  raw_ostream &getVerboseOutputStream() {\n    return *VerboseOutputStream;\n  }\n\n  /// }\n  /// @name Target Info\n  /// {\n\n  bool hasTarget() const { return Target != nullptr; }\n\n  TargetInfo &getTarget() const {\n    assert(Target && \"Compiler instance has no target!\");\n    return *Target;\n  }\n\n  /// Replace the current Target.\n  void setTarget(TargetInfo *Value);\n\n  /// }\n  /// @name AuxTarget Info\n  /// {\n\n  TargetInfo *getAuxTarget() const { return AuxTarget.get(); }\n\n  /// Replace the current AuxTarget.\n  void setAuxTarget(TargetInfo *Value);\n\n  // Create Target and AuxTarget based on current options\n  bool createTarget();\n\n  /// }\n  /// @name Virtual File System\n  /// {\n\n  llvm::vfs::FileSystem &getVirtualFileSystem() const;\n\n  /// }\n  /// @name File Manager\n  /// {\n\n  bool hasFileManager() const { return FileMgr != nullptr; }\n\n  /// Return the current file manager to the caller.\n  FileManager &getFileManager() const {\n    assert(FileMgr && \"Compiler instance has no file manager!\");\n    return *FileMgr;\n  }\n\n  void resetAndLeakFileManager() {\n    llvm::BuryPointer(FileMgr.get());\n    FileMgr.resetWithoutRelease();\n  }\n\n  /// Replace the current file manager and virtual file system.\n  void setFileManager(FileManager *Value);\n\n  /// }\n  /// @name Source Manager\n  /// {\n\n  bool hasSourceManager() const { return SourceMgr != nullptr; }\n\n  /// Return the current source manager.\n  SourceManager &getSourceManager() const {\n    assert(SourceMgr && \"Compiler instance has no source manager!\");\n    return *SourceMgr;\n  }\n\n  void resetAndLeakSourceManager() {\n    llvm::BuryPointer(SourceMgr.get());\n    SourceMgr.resetWithoutRelease();\n  }\n\n  /// setSourceManager - Replace the current source manager.\n  void setSourceManager(SourceManager *Value);\n\n  /// }\n  /// @name Preprocessor\n  /// {\n\n  bool hasPreprocessor() const { return PP != nullptr; }\n\n  /// Return the current preprocessor.\n  Preprocessor &getPreprocessor() const {\n    assert(PP && \"Compiler instance has no preprocessor!\");\n    return *PP;\n  }\n\n  std::shared_ptr<Preprocessor> getPreprocessorPtr() { return PP; }\n\n  void resetAndLeakPreprocessor() {\n    llvm::BuryPointer(new std::shared_ptr<Preprocessor>(PP));\n  }\n\n  /// Replace the current preprocessor.\n  void setPreprocessor(std::shared_ptr<Preprocessor> Value);\n\n  /// }\n  /// @name ASTContext\n  /// {\n\n  bool hasASTContext() const { return Context != nullptr; }\n\n  ASTContext &getASTContext() const {\n    assert(Context && \"Compiler instance has no AST context!\");\n    return *Context;\n  }\n\n  void resetAndLeakASTContext() {\n    llvm::BuryPointer(Context.get());\n    Context.resetWithoutRelease();\n  }\n\n  /// setASTContext - Replace the current AST context.\n  void setASTContext(ASTContext *Value);\n\n  /// Replace the current Sema; the compiler instance takes ownership\n  /// of S.\n  void setSema(Sema *S);\n\n  /// }\n  /// @name ASTConsumer\n  /// {\n\n  bool hasASTConsumer() const { return (bool)Consumer; }\n\n  ASTConsumer &getASTConsumer() const {\n    assert(Consumer && \"Compiler instance has no AST consumer!\");\n    return *Consumer;\n  }\n\n  /// takeASTConsumer - Remove the current AST consumer and give ownership to\n  /// the caller.\n  std::unique_ptr<ASTConsumer> takeASTConsumer() { return std::move(Consumer); }\n\n  /// setASTConsumer - Replace the current AST consumer; the compiler instance\n  /// takes ownership of \\p Value.\n  void setASTConsumer(std::unique_ptr<ASTConsumer> Value);\n\n  /// }\n  /// @name Semantic analysis\n  /// {\n  bool hasSema() const { return (bool)TheSema; }\n\n  Sema &getSema() const {\n    assert(TheSema && \"Compiler instance has no Sema object!\");\n    return *TheSema;\n  }\n\n  std::unique_ptr<Sema> takeSema();\n  void resetAndLeakSema();\n\n  /// }\n  /// @name Module Management\n  /// {\n\n  IntrusiveRefCntPtr<ASTReader> getASTReader() const;\n  void setASTReader(IntrusiveRefCntPtr<ASTReader> Reader);\n\n  std::shared_ptr<ModuleDependencyCollector> getModuleDepCollector() const;\n  void setModuleDepCollector(\n      std::shared_ptr<ModuleDependencyCollector> Collector);\n\n  std::shared_ptr<PCHContainerOperations> getPCHContainerOperations() const {\n    return ThePCHContainerOperations;\n  }\n\n  /// Return the appropriate PCHContainerWriter depending on the\n  /// current CodeGenOptions.\n  const PCHContainerWriter &getPCHContainerWriter() const {\n    assert(Invocation && \"cannot determine module format without invocation\");\n    StringRef Format = getHeaderSearchOpts().ModuleFormat;\n    auto *Writer = ThePCHContainerOperations->getWriterOrNull(Format);\n    if (!Writer) {\n      if (Diagnostics)\n        Diagnostics->Report(diag::err_module_format_unhandled) << Format;\n      llvm::report_fatal_error(\"unknown module format\");\n    }\n    return *Writer;\n  }\n\n  /// Return the appropriate PCHContainerReader depending on the\n  /// current CodeGenOptions.\n  const PCHContainerReader &getPCHContainerReader() const {\n    assert(Invocation && \"cannot determine module format without invocation\");\n    StringRef Format = getHeaderSearchOpts().ModuleFormat;\n    auto *Reader = ThePCHContainerOperations->getReaderOrNull(Format);\n    if (!Reader) {\n      if (Diagnostics)\n        Diagnostics->Report(diag::err_module_format_unhandled) << Format;\n      llvm::report_fatal_error(\"unknown module format\");\n    }\n    return *Reader;\n  }\n\n  /// }\n  /// @name Code Completion\n  /// {\n\n  bool hasCodeCompletionConsumer() const { return (bool)CompletionConsumer; }\n\n  CodeCompleteConsumer &getCodeCompletionConsumer() const {\n    assert(CompletionConsumer &&\n           \"Compiler instance has no code completion consumer!\");\n    return *CompletionConsumer;\n  }\n\n  /// setCodeCompletionConsumer - Replace the current code completion consumer;\n  /// the compiler instance takes ownership of \\p Value.\n  void setCodeCompletionConsumer(CodeCompleteConsumer *Value);\n\n  /// }\n  /// @name Frontend timer\n  /// {\n\n  bool hasFrontendTimer() const { return (bool)FrontendTimer; }\n\n  llvm::Timer &getFrontendTimer() const {\n    assert(FrontendTimer && \"Compiler instance has no frontend timer!\");\n    return *FrontendTimer;\n  }\n\n  /// }\n  /// @name Output Files\n  /// {\n\n  /// clearOutputFiles - Clear the output file list. The underlying output\n  /// streams must have been closed beforehand.\n  ///\n  /// \\param EraseFiles - If true, attempt to erase the files from disk.\n  void clearOutputFiles(bool EraseFiles);\n\n  /// }\n  /// @name Construction Utility Methods\n  /// {\n\n  /// Create the diagnostics engine using the invocation's diagnostic options\n  /// and replace any existing one with it.\n  ///\n  /// Note that this routine also replaces the diagnostic client,\n  /// allocating one if one is not provided.\n  ///\n  /// \\param Client If non-NULL, a diagnostic client that will be\n  /// attached to (and, then, owned by) the DiagnosticsEngine inside this AST\n  /// unit.\n  ///\n  /// \\param ShouldOwnClient If Client is non-NULL, specifies whether\n  /// the diagnostic object should take ownership of the client.\n  void createDiagnostics(DiagnosticConsumer *Client = nullptr,\n                         bool ShouldOwnClient = true);\n\n  /// Create a DiagnosticsEngine object with a the TextDiagnosticPrinter.\n  ///\n  /// If no diagnostic client is provided, this creates a\n  /// DiagnosticConsumer that is owned by the returned diagnostic\n  /// object, if using directly the caller is responsible for\n  /// releasing the returned DiagnosticsEngine's client eventually.\n  ///\n  /// \\param Opts - The diagnostic options; note that the created text\n  /// diagnostic object contains a reference to these options.\n  ///\n  /// \\param Client If non-NULL, a diagnostic client that will be\n  /// attached to (and, then, owned by) the returned DiagnosticsEngine\n  /// object.\n  ///\n  /// \\param CodeGenOpts If non-NULL, the code gen options in use, which may be\n  /// used by some diagnostics printers (for logging purposes only).\n  ///\n  /// \\return The new object on success, or null on failure.\n  static IntrusiveRefCntPtr<DiagnosticsEngine>\n  createDiagnostics(DiagnosticOptions *Opts,\n                    DiagnosticConsumer *Client = nullptr,\n                    bool ShouldOwnClient = true,\n                    const CodeGenOptions *CodeGenOpts = nullptr);\n\n  /// Create the file manager and replace any existing one with it.\n  ///\n  /// \\return The new file manager on success, or null on failure.\n  FileManager *\n  createFileManager(IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS = nullptr);\n\n  /// Create the source manager and replace any existing one with it.\n  void createSourceManager(FileManager &FileMgr);\n\n  /// Create the preprocessor, using the invocation, file, and source managers,\n  /// and replace any existing one with it.\n  void createPreprocessor(TranslationUnitKind TUKind);\n\n  std::string getSpecificModuleCachePath(StringRef ModuleHash);\n  std::string getSpecificModuleCachePath() {\n    return getSpecificModuleCachePath(getInvocation().getModuleHash());\n  }\n\n  /// Create the AST context.\n  void createASTContext();\n\n  /// Create an external AST source to read a PCH file and attach it to the AST\n  /// context.\n  void createPCHExternalASTSource(\n      StringRef Path, DisableValidationForModuleKind DisableValidation,\n      bool AllowPCHWithCompilerErrors, void *DeserializationListener,\n      bool OwnDeserializationListener);\n\n  /// Create an external AST source to read a PCH file.\n  ///\n  /// \\return - The new object on success, or null on failure.\n  static IntrusiveRefCntPtr<ASTReader> createPCHExternalASTSource(\n      StringRef Path, StringRef Sysroot,\n      DisableValidationForModuleKind DisableValidation,\n      bool AllowPCHWithCompilerErrors, Preprocessor &PP,\n      InMemoryModuleCache &ModuleCache, ASTContext &Context,\n      const PCHContainerReader &PCHContainerRdr,\n      ArrayRef<std::shared_ptr<ModuleFileExtension>> Extensions,\n      ArrayRef<std::shared_ptr<DependencyCollector>> DependencyCollectors,\n      void *DeserializationListener, bool OwnDeserializationListener,\n      bool Preamble, bool UseGlobalModuleIndex);\n\n  /// Create a code completion consumer using the invocation; note that this\n  /// will cause the source manager to truncate the input source file at the\n  /// completion point.\n  void createCodeCompletionConsumer();\n\n  /// Create a code completion consumer to print code completion results, at\n  /// \\p Filename, \\p Line, and \\p Column, to the given output stream \\p OS.\n  static CodeCompleteConsumer *createCodeCompletionConsumer(\n      Preprocessor &PP, StringRef Filename, unsigned Line, unsigned Column,\n      const CodeCompleteOptions &Opts, raw_ostream &OS);\n\n  /// Create the Sema object to be used for parsing.\n  void createSema(TranslationUnitKind TUKind,\n                  CodeCompleteConsumer *CompletionConsumer);\n\n  /// Create the frontend timer and replace any existing one with it.\n  void createFrontendTimer();\n\n  /// Create the default output file (from the invocation's options) and add it\n  /// to the list of tracked output files.\n  ///\n  /// The files created by this are usually removed on signal, and, depending\n  /// on FrontendOptions, may also use a temporary file (that is, the data is\n  /// written to a temporary file which will atomically replace the target\n  /// output on success). If a client (like libclang) needs to disable\n  /// RemoveFileOnSignal, temporary files will be forced on.\n  ///\n  /// \\return - Null on error.\n  std::unique_ptr<raw_pwrite_stream>\n  createDefaultOutputFile(bool Binary = true, StringRef BaseInput = \"\",\n                          StringRef Extension = \"\",\n                          bool RemoveFileOnSignal = true,\n                          bool CreateMissingDirectories = false);\n\n  /// Create a new output file, optionally deriving the output path name, and\n  /// add it to the list of tracked output files.\n  ///\n  /// \\return - Null on error.\n  std::unique_ptr<raw_pwrite_stream>\n  createOutputFile(StringRef OutputPath, bool Binary, bool RemoveFileOnSignal,\n                   bool UseTemporary, bool CreateMissingDirectories = false);\n\nprivate:\n  /// Create a new output file and add it to the list of tracked output files.\n  ///\n  /// If \\p OutputPath is empty, then createOutputFile will derive an output\n  /// path location as \\p BaseInput, with any suffix removed, and \\p Extension\n  /// appended. If \\p OutputPath is not stdout and \\p UseTemporary\n  /// is true, createOutputFile will create a new temporary file that must be\n  /// renamed to \\p OutputPath in the end.\n  ///\n  /// \\param OutputPath - If given, the path to the output file.\n  /// \\param Binary - The mode to open the file in.\n  /// \\param RemoveFileOnSignal - Whether the file should be registered with\n  /// llvm::sys::RemoveFileOnSignal. Note that this is not safe for\n  /// multithreaded use, as the underlying signal mechanism is not reentrant\n  /// \\param UseTemporary - Create a new temporary file that must be renamed to\n  /// OutputPath in the end.\n  /// \\param CreateMissingDirectories - When \\p UseTemporary is true, create\n  /// missing directories in the output path.\n  Expected<std::unique_ptr<raw_pwrite_stream>>\n  createOutputFileImpl(StringRef OutputPath, bool Binary,\n                       bool RemoveFileOnSignal, bool UseTemporary,\n                       bool CreateMissingDirectories);\n\npublic:\n  std::unique_ptr<raw_pwrite_stream> createNullOutputFile();\n\n  /// }\n  /// @name Initialization Utility Methods\n  /// {\n\n  /// InitializeSourceManager - Initialize the source manager to set InputFile\n  /// as the main file.\n  ///\n  /// \\return True on success.\n  bool InitializeSourceManager(const FrontendInputFile &Input);\n\n  /// InitializeSourceManager - Initialize the source manager to set InputFile\n  /// as the main file.\n  ///\n  /// \\return True on success.\n  static bool InitializeSourceManager(const FrontendInputFile &Input,\n                                      DiagnosticsEngine &Diags,\n                                      FileManager &FileMgr,\n                                      SourceManager &SourceMgr);\n\n  /// }\n\n  void setOutputStream(std::unique_ptr<llvm::raw_pwrite_stream> OutStream) {\n    OutputStream = std::move(OutStream);\n  }\n\n  std::unique_ptr<llvm::raw_pwrite_stream> takeOutputStream() {\n    return std::move(OutputStream);\n  }\n\n  void createASTReader();\n\n  bool loadModuleFile(StringRef FileName);\n\nprivate:\n  /// Find a module, potentially compiling it, before reading its AST.  This is\n  /// the guts of loadModule.\n  ///\n  /// For prebuilt modules, the Module is not expected to exist in\n  /// HeaderSearch's ModuleMap.  If a ModuleFile by that name is in the\n  /// ModuleManager, then it will be loaded and looked up.\n  ///\n  /// For implicit modules, the Module is expected to already be in the\n  /// ModuleMap.  First attempt to load it from the given path on disk.  If that\n  /// fails, defer to compileModuleAndReadAST, which will first build and then\n  /// load it.\n  ModuleLoadResult findOrCompileModuleAndReadAST(StringRef ModuleName,\n                                                 SourceLocation ImportLoc,\n                                                 SourceLocation ModuleNameLoc,\n                                                 bool IsInclusionDirective);\n\npublic:\n  ModuleLoadResult loadModule(SourceLocation ImportLoc, ModuleIdPath Path,\n                              Module::NameVisibilityKind Visibility,\n                              bool IsInclusionDirective) override;\n\n  void createModuleFromSource(SourceLocation ImportLoc, StringRef ModuleName,\n                              StringRef Source) override;\n\n  void makeModuleVisible(Module *Mod, Module::NameVisibilityKind Visibility,\n                         SourceLocation ImportLoc) override;\n\n  bool hadModuleLoaderFatalFailure() const {\n    return ModuleLoader::HadFatalFailure;\n  }\n\n  GlobalModuleIndex *loadGlobalModuleIndex(SourceLocation TriggerLoc) override;\n\n  bool lookupMissingImports(StringRef Name, SourceLocation TriggerLoc) override;\n\n  void addDependencyCollector(std::shared_ptr<DependencyCollector> Listener) {\n    DependencyCollectors.push_back(std::move(Listener));\n  }\n\n  void setExternalSemaSource(IntrusiveRefCntPtr<ExternalSemaSource> ESS);\n\n  InMemoryModuleCache &getModuleCache() const { return *ModuleCache; }\n};\n\n} // end namespace clang\n\n#endif\n"}, "72": {"id": 72, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/CompilerInvocation.h", "content": "//===- CompilerInvocation.h - Compiler Invocation Helper Data ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_FRONTEND_COMPILERINVOCATION_H\n#define LLVM_CLANG_FRONTEND_COMPILERINVOCATION_H\n\n#include \"clang/Basic/CodeGenOptions.h\"\n#include \"clang/Basic/DiagnosticOptions.h\"\n#include \"clang/Basic/FileSystemOptions.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/LangStandard.h\"\n#include \"clang/Frontend/DependencyOutputOptions.h\"\n#include \"clang/Frontend/FrontendOptions.h\"\n#include \"clang/Frontend/MigratorOptions.h\"\n#include \"clang/Frontend/PreprocessorOutputOptions.h\"\n#include \"clang/StaticAnalyzer/Core/AnalyzerOptions.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include <memory>\n#include <string>\n\nnamespace llvm {\n\nclass Triple;\n\nnamespace opt {\n\nclass ArgList;\n\n} // namespace opt\n\nnamespace vfs {\n\nclass FileSystem;\n\n} // namespace vfs\n\n} // namespace llvm\n\nnamespace clang {\n\nclass DiagnosticsEngine;\nclass HeaderSearchOptions;\nclass PreprocessorOptions;\nclass TargetOptions;\n\n/// Fill out Opts based on the options given in Args.\n///\n/// Args must have been created from the OptTable returned by\n/// createCC1OptTable().\n///\n/// When errors are encountered, return false and, if Diags is non-null,\n/// report the error(s).\nbool ParseDiagnosticArgs(DiagnosticOptions &Opts, llvm::opt::ArgList &Args,\n                         DiagnosticsEngine *Diags = nullptr,\n                         bool DefaultDiagColor = true);\n\nclass CompilerInvocationBase {\npublic:\n  /// Options controlling the language variant.\n  std::shared_ptr<LangOptions> LangOpts;\n\n  /// Options controlling the target.\n  std::shared_ptr<TargetOptions> TargetOpts;\n\n  /// Options controlling the diagnostic engine.\n  IntrusiveRefCntPtr<DiagnosticOptions> DiagnosticOpts;\n\n  /// Options controlling the \\#include directive.\n  std::shared_ptr<HeaderSearchOptions> HeaderSearchOpts;\n\n  /// Options controlling the preprocessor (aside from \\#include handling).\n  std::shared_ptr<PreprocessorOptions> PreprocessorOpts;\n\n  CompilerInvocationBase();\n  CompilerInvocationBase(const CompilerInvocationBase &X);\n  CompilerInvocationBase &operator=(const CompilerInvocationBase &) = delete;\n  ~CompilerInvocationBase();\n\n  LangOptions *getLangOpts() { return LangOpts.get(); }\n  const LangOptions *getLangOpts() const { return LangOpts.get(); }\n\n  TargetOptions &getTargetOpts() { return *TargetOpts.get(); }\n  const TargetOptions &getTargetOpts() const { return *TargetOpts.get(); }\n\n  DiagnosticOptions &getDiagnosticOpts() const { return *DiagnosticOpts; }\n\n  HeaderSearchOptions &getHeaderSearchOpts() { return *HeaderSearchOpts; }\n\n  const HeaderSearchOptions &getHeaderSearchOpts() const {\n    return *HeaderSearchOpts;\n  }\n\n  std::shared_ptr<HeaderSearchOptions> getHeaderSearchOptsPtr() const {\n    return HeaderSearchOpts;\n  }\n\n  std::shared_ptr<PreprocessorOptions> getPreprocessorOptsPtr() {\n    return PreprocessorOpts;\n  }\n\n  PreprocessorOptions &getPreprocessorOpts() { return *PreprocessorOpts; }\n\n  const PreprocessorOptions &getPreprocessorOpts() const {\n    return *PreprocessorOpts;\n  }\n};\n\n/// Helper class for holding the data necessary to invoke the compiler.\n///\n/// This class is designed to represent an abstract \"invocation\" of the\n/// compiler, including data such as the include paths, the code generation\n/// options, the warning flags, and so on.\nclass CompilerInvocation : public CompilerInvocationBase {\n  /// Options controlling the static analyzer.\n  AnalyzerOptionsRef AnalyzerOpts;\n\n  MigratorOptions MigratorOpts;\n\n  /// Options controlling IRgen and the backend.\n  CodeGenOptions CodeGenOpts;\n\n  /// Options controlling dependency output.\n  DependencyOutputOptions DependencyOutputOpts;\n\n  /// Options controlling file system operations.\n  FileSystemOptions FileSystemOpts;\n\n  /// Options controlling the frontend itself.\n  FrontendOptions FrontendOpts;\n\n  /// Options controlling preprocessed output.\n  PreprocessorOutputOptions PreprocessorOutputOpts;\n\npublic:\n  CompilerInvocation() : AnalyzerOpts(new AnalyzerOptions()) {}\n\n  /// @name Utility Methods\n  /// @{\n\n  /// Create a compiler invocation from a list of input options.\n  /// \\returns true on success.\n  ///\n  /// \\returns false if an error was encountered while parsing the arguments\n  /// and attempts to recover and continue parsing the rest of the arguments.\n  /// The recovery is best-effort and only guarantees that \\p Res will end up in\n  /// one of the vaild-to-access (albeit arbitrary) states.\n  ///\n  /// \\param [out] Res - The resulting invocation.\n  /// \\param [in] CommandLineArgs - Array of argument strings, this must not\n  /// contain \"-cc1\".\n  static bool CreateFromArgs(CompilerInvocation &Res,\n                             ArrayRef<const char *> CommandLineArgs,\n                             DiagnosticsEngine &Diags,\n                             const char *Argv0 = nullptr);\n\n  /// Get the directory where the compiler headers\n  /// reside, relative to the compiler binary (found by the passed in\n  /// arguments).\n  ///\n  /// \\param Argv0 - The program path (from argv[0]), for finding the builtin\n  /// compiler path.\n  /// \\param MainAddr - The address of main (or some other function in the main\n  /// executable), for finding the builtin compiler path.\n  static std::string GetResourcesPath(const char *Argv0, void *MainAddr);\n\n  /// Set language defaults for the given input language and\n  /// language standard in the given LangOptions object.\n  ///\n  /// \\param Opts - The LangOptions object to set up.\n  /// \\param IK - The input language.\n  /// \\param T - The target triple.\n  /// \\param Includes - The affected list of included files.\n  /// \\param LangStd - The input language standard.\n  static void\n  setLangDefaults(LangOptions &Opts, InputKind IK, const llvm::Triple &T,\n                  std::vector<std::string> &Includes,\n                  LangStandard::Kind LangStd = LangStandard::lang_unspecified);\n\n  /// Retrieve a module hash string that is suitable for uniquely\n  /// identifying the conditions under which the module was built.\n  std::string getModuleHash() const;\n\n  using StringAllocator = llvm::function_ref<const char *(const llvm::Twine &)>;\n  /// Generate a cc1-compatible command line arguments from this instance.\n  ///\n  /// \\param [out] Args - The generated arguments. Note that the caller is\n  /// responsible for inserting the path to the clang executable and \"-cc1\" if\n  /// desired.\n  /// \\param SA - A function that given a Twine can allocate storage for a given\n  /// command line argument and return a pointer to the newly allocated string.\n  /// The returned pointer is what gets appended to Args.\n  void generateCC1CommandLine(llvm::SmallVectorImpl<const char *> &Args,\n                              StringAllocator SA) const;\n\n  /// @}\n  /// @name Option Subgroups\n  /// @{\n\n  AnalyzerOptionsRef getAnalyzerOpts() const { return AnalyzerOpts; }\n\n  MigratorOptions &getMigratorOpts() { return MigratorOpts; }\n  const MigratorOptions &getMigratorOpts() const { return MigratorOpts; }\n\n  CodeGenOptions &getCodeGenOpts() { return CodeGenOpts; }\n  const CodeGenOptions &getCodeGenOpts() const { return CodeGenOpts; }\n\n  DependencyOutputOptions &getDependencyOutputOpts() {\n    return DependencyOutputOpts;\n  }\n\n  const DependencyOutputOptions &getDependencyOutputOpts() const {\n    return DependencyOutputOpts;\n  }\n\n  FileSystemOptions &getFileSystemOpts() { return FileSystemOpts; }\n\n  const FileSystemOptions &getFileSystemOpts() const {\n    return FileSystemOpts;\n  }\n\n  FrontendOptions &getFrontendOpts() { return FrontendOpts; }\n  const FrontendOptions &getFrontendOpts() const { return FrontendOpts; }\n\n  PreprocessorOutputOptions &getPreprocessorOutputOpts() {\n    return PreprocessorOutputOpts;\n  }\n\n  const PreprocessorOutputOptions &getPreprocessorOutputOpts() const {\n    return PreprocessorOutputOpts;\n  }\n\n  /// @}\n\nprivate:\n  static bool CreateFromArgsImpl(CompilerInvocation &Res,\n                                 ArrayRef<const char *> CommandLineArgs,\n                                 DiagnosticsEngine &Diags, const char *Argv0);\n\n  /// Generate command line options from DiagnosticOptions.\n  static void GenerateDiagnosticArgs(const DiagnosticOptions &Opts,\n                                     SmallVectorImpl<const char *> &Args,\n                                     StringAllocator SA, bool DefaultDiagColor);\n\n  /// Parse command line options that map to LangOptions.\n  static bool ParseLangArgs(LangOptions &Opts, llvm::opt::ArgList &Args,\n                            InputKind IK, const llvm::Triple &T,\n                            std::vector<std::string> &Includes,\n                            DiagnosticsEngine &Diags);\n\n  /// Generate command line options from LangOptions.\n  static void GenerateLangArgs(const LangOptions &Opts,\n                               SmallVectorImpl<const char *> &Args,\n                               StringAllocator SA, const llvm::Triple &T);\n\n  /// Parse command line options that map to CodeGenOptions.\n  static bool ParseCodeGenArgs(CodeGenOptions &Opts, llvm::opt::ArgList &Args,\n                               InputKind IK, DiagnosticsEngine &Diags,\n                               const llvm::Triple &T,\n                               const std::string &OutputFile,\n                               const LangOptions &LangOptsRef);\n\n  // Generate command line options from CodeGenOptions.\n  static void GenerateCodeGenArgs(const CodeGenOptions &Opts,\n                                  SmallVectorImpl<const char *> &Args,\n                                  StringAllocator SA, const llvm::Triple &T,\n                                  const std::string &OutputFile,\n                                  const LangOptions *LangOpts);\n};\n\nIntrusiveRefCntPtr<llvm::vfs::FileSystem>\ncreateVFSFromCompilerInvocation(const CompilerInvocation &CI,\n                                DiagnosticsEngine &Diags);\n\nIntrusiveRefCntPtr<llvm::vfs::FileSystem> createVFSFromCompilerInvocation(\n    const CompilerInvocation &CI, DiagnosticsEngine &Diags,\n    IntrusiveRefCntPtr<llvm::vfs::FileSystem> BaseFS);\n\n} // namespace clang\n\n#endif // LLVM_CLANG_FRONTEND_COMPILERINVOCATION_H\n"}, "73": {"id": 73, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/DependencyOutputOptions.h", "content": "//===--- DependencyOutputOptions.h ------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_FRONTEND_DEPENDENCYOUTPUTOPTIONS_H\n#define LLVM_CLANG_FRONTEND_DEPENDENCYOUTPUTOPTIONS_H\n\n#include <string>\n#include <vector>\n\nnamespace clang {\n\n/// ShowIncludesDestination - Destination for /showIncludes output.\nenum class ShowIncludesDestination { None, Stdout, Stderr };\n\n/// DependencyOutputFormat - Format for the compiler dependency file.\nenum class DependencyOutputFormat { Make, NMake };\n\n/// ExtraDepKind - The kind of extra dependency file.\nenum ExtraDepKind {\n  EDK_SanitizeBlacklist,\n  EDK_ProfileList,\n  EDK_ModuleFile,\n  EDK_DepFileEntry,\n};\n\n/// DependencyOutputOptions - Options for controlling the compiler dependency\n/// file generation.\nclass DependencyOutputOptions {\npublic:\n  unsigned IncludeSystemHeaders : 1; ///< Include system header dependencies.\n  unsigned ShowHeaderIncludes : 1;   ///< Show header inclusions (-H).\n  unsigned UsePhonyTargets : 1;      ///< Include phony targets for each\n                                     /// dependency, which can avoid some 'make'\n                                     /// problems.\n  unsigned AddMissingHeaderDeps : 1; ///< Add missing headers to dependency list\n  unsigned IncludeModuleFiles : 1; ///< Include module file dependencies.\n\n  /// Destination of cl.exe style /showIncludes info.\n  ShowIncludesDestination ShowIncludesDest = ShowIncludesDestination::None;\n\n  /// The format for the dependency file.\n  DependencyOutputFormat OutputFormat = DependencyOutputFormat::Make;\n\n  /// The file to write dependency output to.\n  std::string OutputFile;\n\n  /// The file to write header include output to. This is orthogonal to\n  /// ShowHeaderIncludes (-H) and will include headers mentioned in the\n  /// predefines buffer. If the output file is \"-\", output will be sent to\n  /// stderr.\n  std::string HeaderIncludeOutputFile;\n\n  /// A list of names to use as the targets in the dependency file; this list\n  /// must contain at least one entry.\n  std::vector<std::string> Targets;\n\n  /// A list of extra dependencies (filename and kind) to be used for every\n  /// target.\n  std::vector<std::pair<std::string, ExtraDepKind>> ExtraDeps;\n\n  /// In /showIncludes mode, pretend the main TU is a header with this name.\n  std::string ShowIncludesPretendHeader;\n\n  /// The file to write GraphViz-formatted header dependencies to.\n  std::string DOTOutputFile;\n\n  /// The directory to copy module dependencies to when collecting them.\n  std::string ModuleDependencyOutputDir;\n\npublic:\n  DependencyOutputOptions()\n      : IncludeSystemHeaders(0), ShowHeaderIncludes(0), UsePhonyTargets(0),\n        AddMissingHeaderDeps(0), IncludeModuleFiles(0) {}\n};\n\n}  // end namespace clang\n\n#endif\n"}, "74": {"id": 74, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/FrontendAction.h", "content": "//===-- FrontendAction.h - Generic Frontend Action Interface ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Defines the clang::FrontendAction interface and various convenience\n/// abstract classes (clang::ASTFrontendAction, clang::PluginASTAction,\n/// clang::PreprocessorFrontendAction, and clang::WrapperFrontendAction)\n/// derived from it.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_FRONTEND_FRONTENDACTION_H\n#define LLVM_CLANG_FRONTEND_FRONTENDACTION_H\n\n#include \"clang/AST/ASTConsumer.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Frontend/ASTUnit.h\"\n#include \"clang/Frontend/FrontendOptions.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Error.h\"\n#include <memory>\n#include <string>\n#include <vector>\n\nnamespace clang {\nclass ASTMergeAction;\nclass CompilerInstance;\n\n/// Abstract base class for actions which can be performed by the frontend.\nclass FrontendAction {\n  FrontendInputFile CurrentInput;\n  std::unique_ptr<ASTUnit> CurrentASTUnit;\n  CompilerInstance *Instance;\n  friend class ASTMergeAction;\n  friend class WrapperFrontendAction;\n\nprivate:\n  std::unique_ptr<ASTConsumer> CreateWrappedASTConsumer(CompilerInstance &CI,\n                                                        StringRef InFile);\n\nprotected:\n  /// @name Implementation Action Interface\n  /// @{\n\n  /// Prepare to execute the action on the given CompilerInstance.\n  ///\n  /// This is called before executing the action on any inputs, and can modify\n  /// the configuration as needed (including adjusting the input list).\n  virtual bool PrepareToExecuteAction(CompilerInstance &CI) { return true; }\n\n  /// Create the AST consumer object for this action, if supported.\n  ///\n  /// This routine is called as part of BeginSourceFile(), which will\n  /// fail if the AST consumer cannot be created. This will not be called if the\n  /// action has indicated that it only uses the preprocessor.\n  ///\n  /// \\param CI - The current compiler instance, provided as a convenience, see\n  /// getCompilerInstance().\n  ///\n  /// \\param InFile - The current input file, provided as a convenience, see\n  /// getCurrentFile().\n  ///\n  /// \\return The new AST consumer, or null on failure.\n  virtual std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                         StringRef InFile) = 0;\n\n  /// Callback before starting processing a single input, giving the\n  /// opportunity to modify the CompilerInvocation or do some other action\n  /// before BeginSourceFileAction is called.\n  ///\n  /// \\return True on success; on failure BeginSourceFileAction(),\n  /// ExecuteAction() and EndSourceFileAction() will not be called.\n  virtual bool BeginInvocation(CompilerInstance &CI) { return true; }\n\n  /// Callback at the start of processing a single input.\n  ///\n  /// \\return True on success; on failure ExecutionAction() and\n  /// EndSourceFileAction() will not be called.\n  virtual bool BeginSourceFileAction(CompilerInstance &CI) {\n    return true;\n  }\n\n  /// Callback to run the program action, using the initialized\n  /// compiler instance.\n  ///\n  /// This is guaranteed to only be called between BeginSourceFileAction()\n  /// and EndSourceFileAction().\n  virtual void ExecuteAction() = 0;\n\n  /// Callback at the end of processing a single input.\n  ///\n  /// This is guaranteed to only be called following a successful call to\n  /// BeginSourceFileAction (and BeginSourceFile).\n  virtual void EndSourceFileAction() {}\n\n  /// Callback at the end of processing a single input, to determine\n  /// if the output files should be erased or not.\n  ///\n  /// By default it returns true if a compiler error occurred.\n  /// This is guaranteed to only be called following a successful call to\n  /// BeginSourceFileAction (and BeginSourceFile).\n  virtual bool shouldEraseOutputFiles();\n\n  /// @}\n\npublic:\n  FrontendAction();\n  virtual ~FrontendAction();\n\n  /// @name Compiler Instance Access\n  /// @{\n\n  CompilerInstance &getCompilerInstance() const {\n    assert(Instance && \"Compiler instance not registered!\");\n    return *Instance;\n  }\n\n  void setCompilerInstance(CompilerInstance *Value) { Instance = Value; }\n\n  /// @}\n  /// @name Current File Information\n  /// @{\n\n  bool isCurrentFileAST() const {\n    assert(!CurrentInput.isEmpty() && \"No current file!\");\n    return (bool)CurrentASTUnit;\n  }\n\n  const FrontendInputFile &getCurrentInput() const {\n    return CurrentInput;\n  }\n\n  StringRef getCurrentFile() const {\n    assert(!CurrentInput.isEmpty() && \"No current file!\");\n    return CurrentInput.getFile();\n  }\n\n  StringRef getCurrentFileOrBufferName() const {\n    assert(!CurrentInput.isEmpty() && \"No current file!\");\n    return CurrentInput.isFile()\n               ? CurrentInput.getFile()\n               : CurrentInput.getBuffer().getBufferIdentifier();\n  }\n\n  InputKind getCurrentFileKind() const {\n    assert(!CurrentInput.isEmpty() && \"No current file!\");\n    return CurrentInput.getKind();\n  }\n\n  ASTUnit &getCurrentASTUnit() const {\n    assert(CurrentASTUnit && \"No current AST unit!\");\n    return *CurrentASTUnit;\n  }\n\n  Module *getCurrentModule() const;\n\n  std::unique_ptr<ASTUnit> takeCurrentASTUnit() {\n    return std::move(CurrentASTUnit);\n  }\n\n  void setCurrentInput(const FrontendInputFile &CurrentInput,\n                       std::unique_ptr<ASTUnit> AST = nullptr);\n\n  /// @}\n  /// @name Supported Modes\n  /// @{\n\n  /// Is this action invoked on a model file?\n  ///\n  /// Model files are incomplete translation units that relies on type\n  /// information from another translation unit. Check ParseModelFileAction for\n  /// details.\n  virtual bool isModelParsingAction() const { return false; }\n\n  /// Does this action only use the preprocessor?\n  ///\n  /// If so no AST context will be created and this action will be invalid\n  /// with AST file inputs.\n  virtual bool usesPreprocessorOnly() const = 0;\n\n  /// For AST-based actions, the kind of translation unit we're handling.\n  virtual TranslationUnitKind getTranslationUnitKind() { return TU_Complete; }\n\n  /// Does this action support use with PCH?\n  virtual bool hasPCHSupport() const { return true; }\n\n  /// Does this action support use with AST files?\n  virtual bool hasASTFileSupport() const { return true; }\n\n  /// Does this action support use with IR files?\n  virtual bool hasIRSupport() const { return false; }\n\n  /// Does this action support use with code completion?\n  virtual bool hasCodeCompletionSupport() const { return false; }\n\n  /// @}\n  /// @name Public Action Interface\n  /// @{\n\n  /// Prepare the action to execute on the given compiler instance.\n  bool PrepareToExecute(CompilerInstance &CI) {\n    return PrepareToExecuteAction(CI);\n  }\n\n  /// Prepare the action for processing the input file \\p Input.\n  ///\n  /// This is run after the options and frontend have been initialized,\n  /// but prior to executing any per-file processing.\n  ///\n  /// \\param CI - The compiler instance this action is being run from. The\n  /// action may store and use this object up until the matching EndSourceFile\n  /// action.\n  ///\n  /// \\param Input - The input filename and kind. Some input kinds are handled\n  /// specially, for example AST inputs, since the AST file itself contains\n  /// several objects which would normally be owned by the\n  /// CompilerInstance. When processing AST input files, these objects should\n  /// generally not be initialized in the CompilerInstance -- they will\n  /// automatically be shared with the AST file in between\n  /// BeginSourceFile() and EndSourceFile().\n  ///\n  /// \\return True on success; on failure the compilation of this file should\n  /// be aborted and neither Execute() nor EndSourceFile() should be called.\n  bool BeginSourceFile(CompilerInstance &CI, const FrontendInputFile &Input);\n\n  /// Set the source manager's main input file, and run the action.\n  llvm::Error Execute();\n\n  /// Perform any per-file post processing, deallocate per-file\n  /// objects, and run statistics and output file cleanup code.\n  void EndSourceFile();\n\n  /// @}\n};\n\n/// Abstract base class to use for AST consumer-based frontend actions.\nclass ASTFrontendAction : public FrontendAction {\nprotected:\n  /// Implement the ExecuteAction interface by running Sema on\n  /// the already-initialized AST consumer.\n  ///\n  /// This will also take care of instantiating a code completion consumer if\n  /// the user requested it and the action supports it.\n  void ExecuteAction() override;\n\npublic:\n  ASTFrontendAction() {}\n  bool usesPreprocessorOnly() const override { return false; }\n};\n\nclass PluginASTAction : public ASTFrontendAction {\n  virtual void anchor();\npublic:\n  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                 StringRef InFile) override = 0;\n\n  /// Parse the given plugin command line arguments.\n  ///\n  /// \\param CI - The compiler instance, for use in reporting diagnostics.\n  /// \\return True if the parsing succeeded; otherwise the plugin will be\n  /// destroyed and no action run. The plugin is responsible for using the\n  /// CompilerInstance's Diagnostic object to report errors.\n  virtual bool ParseArgs(const CompilerInstance &CI,\n                         const std::vector<std::string> &arg) = 0;\n\n  enum ActionType {\n    Cmdline,             ///< Action is determined by the cc1 command-line\n    ReplaceAction,       ///< Replace the main action\n    AddBeforeMainAction, ///< Execute the action before the main action\n    AddAfterMainAction   ///< Execute the action after the main action\n  };\n  /// Get the action type for this plugin\n  ///\n  /// \\return The action type. If the type is Cmdline then by default the\n  /// plugin does nothing and what it does is determined by the cc1\n  /// command-line.\n  virtual ActionType getActionType() { return Cmdline; }\n};\n\n/// Abstract base class to use for preprocessor-based frontend actions.\nclass PreprocessorFrontendAction : public FrontendAction {\nprotected:\n  /// Provide a default implementation which returns aborts;\n  /// this method should never be called by FrontendAction clients.\n  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                 StringRef InFile) override;\n\npublic:\n  bool usesPreprocessorOnly() const override { return true; }\n};\n\n/// A frontend action which simply wraps some other runtime-specified\n/// frontend action.\n///\n/// Deriving from this class allows an action to inject custom logic around\n/// some existing action's behavior. It implements every virtual method in\n/// the FrontendAction interface by forwarding to the wrapped action.\nclass WrapperFrontendAction : public FrontendAction {\n  std::unique_ptr<FrontendAction> WrappedAction;\n\nprotected:\n  bool PrepareToExecuteAction(CompilerInstance &CI) override;\n  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                 StringRef InFile) override;\n  bool BeginInvocation(CompilerInstance &CI) override;\n  bool BeginSourceFileAction(CompilerInstance &CI) override;\n  void ExecuteAction() override;\n  void EndSourceFileAction() override;\n  bool shouldEraseOutputFiles() override;\n\npublic:\n  /// Construct a WrapperFrontendAction from an existing action, taking\n  /// ownership of it.\n  WrapperFrontendAction(std::unique_ptr<FrontendAction> WrappedAction);\n\n  bool usesPreprocessorOnly() const override;\n  TranslationUnitKind getTranslationUnitKind() override;\n  bool hasPCHSupport() const override;\n  bool hasASTFileSupport() const override;\n  bool hasIRSupport() const override;\n  bool hasCodeCompletionSupport() const override;\n};\n\n}  // end namespace clang\n\n#endif\n"}, "75": {"id": 75, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/FrontendOptions.h", "content": "//===- FrontendOptions.h ----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_FRONTEND_FRONTENDOPTIONS_H\n#define LLVM_CLANG_FRONTEND_FRONTENDOPTIONS_H\n\n#include \"clang/AST/ASTDumperUtils.h\"\n#include \"clang/Basic/LangStandard.h\"\n#include \"clang/Frontend/CommandLineSourceLoc.h\"\n#include \"clang/Sema/CodeCompleteOptions.h\"\n#include \"clang/Serialization/ModuleFileExtension.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <cassert>\n#include <memory>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nnamespace llvm {\n\nclass MemoryBuffer;\n\n} // namespace llvm\n\nnamespace clang {\n\nnamespace frontend {\n\nenum ActionKind {\n  /// Parse ASTs and list Decl nodes.\n  ASTDeclList,\n\n  /// Parse ASTs and dump them.\n  ASTDump,\n\n  /// Parse ASTs and print them.\n  ASTPrint,\n\n  /// Parse ASTs and view them in Graphviz.\n  ASTView,\n\n  /// Dump the compiler configuration.\n  DumpCompilerOptions,\n\n  /// Dump out raw tokens.\n  DumpRawTokens,\n\n  /// Dump out preprocessed tokens.\n  DumpTokens,\n\n  /// Emit a .s file.\n  EmitAssembly,\n\n  /// Emit a .bc file.\n  EmitBC,\n\n  /// Translate input source into HTML.\n  EmitHTML,\n\n  /// Emit a .ll file.\n  EmitLLVM,\n\n  /// Generate LLVM IR, but do not emit anything.\n  EmitLLVMOnly,\n\n  /// Generate machine code, but don't emit anything.\n  EmitCodeGenOnly,\n\n  /// Emit a .o file.\n  EmitObj,\n\n  /// Parse and apply any fixits to the source.\n  FixIt,\n\n  /// Generate pre-compiled module from a module map.\n  GenerateModule,\n\n  /// Generate pre-compiled module from a C++ module interface file.\n  GenerateModuleInterface,\n\n  /// Generate pre-compiled module from a set of header files.\n  GenerateHeaderModule,\n\n  /// Generate pre-compiled header.\n  GeneratePCH,\n\n  /// Generate Interface Stub Files.\n  GenerateInterfaceStubs,\n\n  /// Only execute frontend initialization.\n  InitOnly,\n\n  /// Dump information about a module file.\n  ModuleFileInfo,\n\n  /// Load and verify that a PCH file is usable.\n  VerifyPCH,\n\n  /// Parse and perform semantic analysis.\n  ParseSyntaxOnly,\n\n  /// Run a plugin action, \\see ActionName.\n  PluginAction,\n\n  /// Print the \"preamble\" of the input file\n  PrintPreamble,\n\n  /// -E mode.\n  PrintPreprocessedInput,\n\n  /// Expand macros but not \\#includes.\n  RewriteMacros,\n\n  /// ObjC->C Rewriter.\n  RewriteObjC,\n\n  /// Rewriter playground\n  RewriteTest,\n\n  /// Run one or more source code analyses.\n  RunAnalysis,\n\n  /// Dump template instantiations\n  TemplightDump,\n\n  /// Run migrator.\n  MigrateSource,\n\n  /// Just lex, no output.\n  RunPreprocessorOnly,\n\n  /// Print the output of the dependency directives source minimizer.\n  PrintDependencyDirectivesSourceMinimizerOutput\n};\n\n} // namespace frontend\n\n/// The kind of a file that we've been handed as an input.\nclass InputKind {\nprivate:\n  Language Lang;\n  unsigned Fmt : 3;\n  unsigned Preprocessed : 1;\n\npublic:\n  /// The input file format.\n  enum Format {\n    Source,\n    ModuleMap,\n    Precompiled\n  };\n\n  constexpr InputKind(Language L = Language::Unknown, Format F = Source,\n                      bool PP = false)\n      : Lang(L), Fmt(F), Preprocessed(PP) {}\n\n  Language getLanguage() const { return static_cast<Language>(Lang); }\n  Format getFormat() const { return static_cast<Format>(Fmt); }\n  bool isPreprocessed() const { return Preprocessed; }\n\n  /// Is the input kind fully-unknown?\n  bool isUnknown() const { return Lang == Language::Unknown && Fmt == Source; }\n\n  /// Is the language of the input some dialect of Objective-C?\n  bool isObjectiveC() const {\n    return Lang == Language::ObjC || Lang == Language::ObjCXX;\n  }\n\n  InputKind getPreprocessed() const {\n    return InputKind(getLanguage(), getFormat(), true);\n  }\n\n  InputKind withFormat(Format F) const {\n    return InputKind(getLanguage(), F, isPreprocessed());\n  }\n};\n\n/// An input file for the front end.\nclass FrontendInputFile {\n  /// The file name, or \"-\" to read from standard input.\n  std::string File;\n\n  /// The input, if it comes from a buffer rather than a file. This object\n  /// does not own the buffer, and the caller is responsible for ensuring\n  /// that it outlives any users.\n  llvm::Optional<llvm::MemoryBufferRef> Buffer;\n\n  /// The kind of input, e.g., C source, AST file, LLVM IR.\n  InputKind Kind;\n\n  /// Whether we're dealing with a 'system' input (vs. a 'user' input).\n  bool IsSystem = false;\n\npublic:\n  FrontendInputFile() = default;\n  FrontendInputFile(StringRef File, InputKind Kind, bool IsSystem = false)\n      : File(File.str()), Kind(Kind), IsSystem(IsSystem) {}\n  FrontendInputFile(llvm::MemoryBufferRef Buffer, InputKind Kind,\n                    bool IsSystem = false)\n      : Buffer(Buffer), Kind(Kind), IsSystem(IsSystem) {}\n\n  InputKind getKind() const { return Kind; }\n  bool isSystem() const { return IsSystem; }\n\n  bool isEmpty() const { return File.empty() && Buffer == None; }\n  bool isFile() const { return !isBuffer(); }\n  bool isBuffer() const { return Buffer != None; }\n  bool isPreprocessed() const { return Kind.isPreprocessed(); }\n\n  StringRef getFile() const {\n    assert(isFile());\n    return File;\n  }\n\n  llvm::MemoryBufferRef getBuffer() const {\n    assert(isBuffer());\n    return *Buffer;\n  }\n};\n\n/// FrontendOptions - Options for controlling the behavior of the frontend.\nclass FrontendOptions {\npublic:\n  /// Disable memory freeing on exit.\n  unsigned DisableFree : 1;\n\n  /// When generating PCH files, instruct the AST writer to create relocatable\n  /// PCH files.\n  unsigned RelocatablePCH : 1;\n\n  /// Show the -help text.\n  unsigned ShowHelp : 1;\n\n  /// Show frontend performance metrics and statistics.\n  unsigned ShowStats : 1;\n\n  /// print the supported cpus for the current target\n  unsigned PrintSupportedCPUs : 1;\n\n  /// Output time trace profile.\n  unsigned TimeTrace : 1;\n\n  /// Show the -version text.\n  unsigned ShowVersion : 1;\n\n  /// Apply fixes even if there are unfixable errors.\n  unsigned FixWhatYouCan : 1;\n\n  /// Apply fixes only for warnings.\n  unsigned FixOnlyWarnings : 1;\n\n  /// Apply fixes and recompile.\n  unsigned FixAndRecompile : 1;\n\n  /// Apply fixes to temporary files.\n  unsigned FixToTemporaries : 1;\n\n  /// Emit ARC errors even if the migrator can fix them.\n  unsigned ARCMTMigrateEmitARCErrors : 1;\n\n  /// Skip over function bodies to speed up parsing in cases you do not need\n  /// them (e.g. with code completion).\n  unsigned SkipFunctionBodies : 1;\n\n  /// Whether we can use the global module index if available.\n  unsigned UseGlobalModuleIndex : 1;\n\n  /// Whether we can generate the global module index if needed.\n  unsigned GenerateGlobalModuleIndex : 1;\n\n  /// Whether we include declaration dumps in AST dumps.\n  unsigned ASTDumpDecls : 1;\n\n  /// Whether we deserialize all decls when forming AST dumps.\n  unsigned ASTDumpAll : 1;\n\n  /// Whether we include lookup table dumps in AST dumps.\n  unsigned ASTDumpLookups : 1;\n\n  /// Whether we include declaration type dumps in AST dumps.\n  unsigned ASTDumpDeclTypes : 1;\n\n  /// Whether we are performing an implicit module build.\n  unsigned BuildingImplicitModule : 1;\n\n  /// Whether we should embed all used files into the PCM file.\n  unsigned ModulesEmbedAllFiles : 1;\n\n  /// Whether timestamps should be written to the produced PCH file.\n  unsigned IncludeTimestamps : 1;\n\n  /// Should a temporary file be used during compilation.\n  unsigned UseTemporary : 1;\n\n  /// When using -emit-module, treat the modulemap as a system module.\n  unsigned IsSystemModule : 1;\n\n  /// Output (and read) PCM files regardless of compiler errors.\n  unsigned AllowPCMWithCompilerErrors : 1;\n\n  CodeCompleteOptions CodeCompleteOpts;\n\n  /// Specifies the output format of the AST.\n  ASTDumpOutputFormat ASTDumpFormat = ADOF_Default;\n\n  enum {\n    ARCMT_None,\n    ARCMT_Check,\n    ARCMT_Modify,\n    ARCMT_Migrate\n  } ARCMTAction = ARCMT_None;\n\n  enum {\n    ObjCMT_None = 0,\n\n    /// Enable migration to modern ObjC literals.\n    ObjCMT_Literals = 0x1,\n\n    /// Enable migration to modern ObjC subscripting.\n    ObjCMT_Subscripting = 0x2,\n\n    /// Enable migration to modern ObjC readonly property.\n    ObjCMT_ReadonlyProperty = 0x4,\n\n    /// Enable migration to modern ObjC readwrite property.\n    ObjCMT_ReadwriteProperty = 0x8,\n\n    /// Enable migration to modern ObjC property.\n    ObjCMT_Property = (ObjCMT_ReadonlyProperty | ObjCMT_ReadwriteProperty),\n\n    /// Enable annotation of ObjCMethods of all kinds.\n    ObjCMT_Annotation = 0x10,\n\n    /// Enable migration of ObjC methods to 'instancetype'.\n    ObjCMT_Instancetype = 0x20,\n\n    /// Enable migration to NS_ENUM/NS_OPTIONS macros.\n    ObjCMT_NsMacros = 0x40,\n\n    /// Enable migration to add conforming protocols.\n    ObjCMT_ProtocolConformance = 0x80,\n\n    /// prefer 'atomic' property over 'nonatomic'.\n    ObjCMT_AtomicProperty = 0x100,\n\n    /// annotate property with NS_RETURNS_INNER_POINTER\n    ObjCMT_ReturnsInnerPointerProperty = 0x200,\n\n    /// use NS_NONATOMIC_IOSONLY for property 'atomic' attribute\n    ObjCMT_NsAtomicIOSOnlyProperty = 0x400,\n\n    /// Enable inferring NS_DESIGNATED_INITIALIZER for ObjC methods.\n    ObjCMT_DesignatedInitializer = 0x800,\n\n    /// Enable converting setter/getter expressions to property-dot syntx.\n    ObjCMT_PropertyDotSyntax = 0x1000,\n\n    ObjCMT_MigrateDecls = (ObjCMT_ReadonlyProperty | ObjCMT_ReadwriteProperty |\n                           ObjCMT_Annotation | ObjCMT_Instancetype |\n                           ObjCMT_NsMacros | ObjCMT_ProtocolConformance |\n                           ObjCMT_NsAtomicIOSOnlyProperty |\n                           ObjCMT_DesignatedInitializer),\n    ObjCMT_MigrateAll = (ObjCMT_Literals | ObjCMT_Subscripting |\n                         ObjCMT_MigrateDecls | ObjCMT_PropertyDotSyntax)\n  };\n  unsigned ObjCMTAction = ObjCMT_None;\n  std::string ObjCMTWhiteListPath;\n\n  std::string MTMigrateDir;\n  std::string ARCMTMigrateReportOut;\n\n  /// The input kind, either specified via -x argument or deduced from the input\n  /// file name.\n  InputKind DashX;\n\n  /// The input files and their types.\n  SmallVector<FrontendInputFile, 0> Inputs;\n\n  /// When the input is a module map, the original module map file from which\n  /// that map was inferred, if any (for umbrella modules).\n  std::string OriginalModuleMap;\n\n  /// The output file, if any.\n  std::string OutputFile;\n\n  /// If given, the new suffix for fix-it rewritten files.\n  std::string FixItSuffix;\n\n  /// If given, filter dumped AST Decl nodes by this substring.\n  std::string ASTDumpFilter;\n\n  /// If given, enable code completion at the provided location.\n  ParsedSourceLocation CodeCompletionAt;\n\n  /// The frontend action to perform.\n  frontend::ActionKind ProgramAction = frontend::ParseSyntaxOnly;\n\n  /// The name of the action to run when using a plugin action.\n  std::string ActionName;\n\n  /// Args to pass to the plugins\n  std::unordered_map<std::string,std::vector<std::string>> PluginArgs;\n\n  /// The list of plugin actions to run in addition to the normal action.\n  std::vector<std::string> AddPluginActions;\n\n  /// The list of plugins to load.\n  std::vector<std::string> Plugins;\n\n  /// The list of module file extensions.\n  std::vector<std::shared_ptr<ModuleFileExtension>> ModuleFileExtensions;\n\n  /// The list of module map files to load before processing the input.\n  std::vector<std::string> ModuleMapFiles;\n\n  /// The list of additional prebuilt module files to load before\n  /// processing the input.\n  std::vector<std::string> ModuleFiles;\n\n  /// The list of files to embed into the compiled module file.\n  std::vector<std::string> ModulesEmbedFiles;\n\n  /// The list of AST files to merge.\n  std::vector<std::string> ASTMergeFiles;\n\n  /// A list of arguments to forward to LLVM's option processing; this\n  /// should only be used for debugging and experimental features.\n  std::vector<std::string> LLVMArgs;\n\n  /// File name of the file that will provide record layouts\n  /// (in the format produced by -fdump-record-layouts).\n  std::string OverrideRecordLayoutsFile;\n\n  /// Auxiliary triple for CUDA/HIP compilation.\n  std::string AuxTriple;\n\n  /// Auxiliary target CPU for CUDA/HIP compilation.\n  Optional<std::string> AuxTargetCPU;\n\n  /// Auxiliary target features for CUDA/HIP compilation.\n  Optional<std::vector<std::string>> AuxTargetFeatures;\n\n  /// Filename to write statistics to.\n  std::string StatsFile;\n\n  /// Minimum time granularity (in microseconds) traced by time profiler.\n  unsigned TimeTraceGranularity;\n\npublic:\n  FrontendOptions()\n      : DisableFree(false), RelocatablePCH(false), ShowHelp(false),\n        ShowStats(false), TimeTrace(false), ShowVersion(false),\n        FixWhatYouCan(false), FixOnlyWarnings(false), FixAndRecompile(false),\n        FixToTemporaries(false), ARCMTMigrateEmitARCErrors(false),\n        SkipFunctionBodies(false), UseGlobalModuleIndex(true),\n        GenerateGlobalModuleIndex(true), ASTDumpDecls(false),\n        ASTDumpLookups(false), BuildingImplicitModule(false),\n        ModulesEmbedAllFiles(false), IncludeTimestamps(true),\n        UseTemporary(true), AllowPCMWithCompilerErrors(false),\n        TimeTraceGranularity(500) {}\n\n  /// getInputKindForExtension - Return the appropriate input kind for a file\n  /// extension. For example, \"c\" would return Language::C.\n  ///\n  /// \\return The input kind for the extension, or Language::Unknown if the\n  /// extension is not recognized.\n  static InputKind getInputKindForExtension(StringRef Extension);\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_FRONTEND_FRONTENDOPTIONS_H\n"}, "76": {"id": 76, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/PrecompiledPreamble.h", "content": "//===--- PrecompiledPreamble.h - Build precompiled preambles ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Helper class to build precompiled preamble.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_FRONTEND_PRECOMPILED_PREAMBLE_H\n#define LLVM_CLANG_FRONTEND_PRECOMPILED_PREAMBLE_H\n\n#include \"clang/Lex/Lexer.h\"\n#include \"clang/Lex/Preprocessor.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/MD5.h\"\n#include <cstddef>\n#include <memory>\n#include <system_error>\n#include <type_traits>\n\nnamespace llvm {\nclass MemoryBuffer;\nclass MemoryBufferRef;\nnamespace vfs {\nclass FileSystem;\n}\n} // namespace llvm\n\nnamespace clang {\nclass CompilerInstance;\nclass CompilerInvocation;\nclass Decl;\nclass DeclGroupRef;\nclass PCHContainerOperations;\n\n/// Runs lexer to compute suggested preamble bounds.\nPreambleBounds ComputePreambleBounds(const LangOptions &LangOpts,\n                                     const llvm::MemoryBufferRef &Buffer,\n                                     unsigned MaxLines);\n\nclass PreambleCallbacks;\n\n/// A class holding a PCH and all information to check whether it is valid to\n/// reuse the PCH for the subsequent runs. Use BuildPreamble to create PCH and\n/// CanReusePreamble + AddImplicitPreamble to make use of it.\nclass PrecompiledPreamble {\n  class PCHStorage;\n  struct PreambleFileHash;\n\npublic:\n  /// Try to build PrecompiledPreamble for \\p Invocation. See\n  /// BuildPreambleError for possible error codes.\n  ///\n  /// \\param Invocation Original CompilerInvocation with options to compile the\n  /// file.\n  ///\n  /// \\param MainFileBuffer Buffer with the contents of the main file.\n  ///\n  /// \\param Bounds Bounds of the preamble, result of calling\n  /// ComputePreambleBounds.\n  ///\n  /// \\param Diagnostics Diagnostics engine to be used while building the\n  /// preamble.\n  ///\n  /// \\param VFS An instance of vfs::FileSystem to be used for file\n  /// accesses.\n  ///\n  /// \\param PCHContainerOps An instance of PCHContainerOperations.\n  ///\n  /// \\param StoreInMemory Store PCH in memory. If false, PCH will be stored in\n  /// a temporary file.\n  ///\n  /// \\param Callbacks A set of callbacks to be executed when building\n  /// the preamble.\n  static llvm::ErrorOr<PrecompiledPreamble>\n  Build(const CompilerInvocation &Invocation,\n        const llvm::MemoryBuffer *MainFileBuffer, PreambleBounds Bounds,\n        DiagnosticsEngine &Diagnostics,\n        IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS,\n        std::shared_ptr<PCHContainerOperations> PCHContainerOps,\n        bool StoreInMemory, PreambleCallbacks &Callbacks);\n\n  PrecompiledPreamble(PrecompiledPreamble &&) = default;\n  PrecompiledPreamble &operator=(PrecompiledPreamble &&) = default;\n\n  /// PreambleBounds used to build the preamble.\n  PreambleBounds getBounds() const;\n\n  /// Returns the size, in bytes, that preamble takes on disk or in memory.\n  /// For on-disk preambles returns 0 if filesystem operations fail. Intended to\n  /// be used for logging and debugging purposes only.\n  std::size_t getSize() const;\n\n  /// Returned string is not null-terminated.\n  llvm::StringRef getContents() const {\n    return {PreambleBytes.data(), PreambleBytes.size()};\n  }\n\n  /// Check whether PrecompiledPreamble can be reused for the new contents(\\p\n  /// MainFileBuffer) of the main file.\n  bool CanReuse(const CompilerInvocation &Invocation,\n                const llvm::MemoryBufferRef &MainFileBuffer,\n                PreambleBounds Bounds, llvm::vfs::FileSystem &VFS) const;\n\n  /// Changes options inside \\p CI to use PCH from this preamble. Also remaps\n  /// main file to \\p MainFileBuffer and updates \\p VFS to ensure the preamble\n  /// is accessible.\n  /// Requires that CanReuse() is true.\n  /// For in-memory preambles, PrecompiledPreamble instance continues to own the\n  /// MemoryBuffer with the Preamble after this method returns. The caller is\n  /// responsible for making sure the PrecompiledPreamble instance outlives the\n  /// compiler run and the AST that will be using the PCH.\n  void AddImplicitPreamble(CompilerInvocation &CI,\n                           IntrusiveRefCntPtr<llvm::vfs::FileSystem> &VFS,\n                           llvm::MemoryBuffer *MainFileBuffer) const;\n\n  /// Configure \\p CI to use this preamble.\n  /// Like AddImplicitPreamble, but doesn't assume CanReuse() is true.\n  /// If this preamble does not match the file, it may parse differently.\n  void OverridePreamble(CompilerInvocation &CI,\n                        IntrusiveRefCntPtr<llvm::vfs::FileSystem> &VFS,\n                        llvm::MemoryBuffer *MainFileBuffer) const;\n\nprivate:\n  PrecompiledPreamble(PCHStorage Storage, std::vector<char> PreambleBytes,\n                      bool PreambleEndsAtStartOfLine,\n                      llvm::StringMap<PreambleFileHash> FilesInPreamble,\n                      llvm::StringSet<> MissingFiles);\n\n  /// A temp file that would be deleted on destructor call. If destructor is not\n  /// called for any reason, the file will be deleted at static objects'\n  /// destruction.\n  /// An assertion will fire if two TempPCHFiles are created with the same name,\n  /// so it's not intended to be used outside preamble-handling.\n  class TempPCHFile {\n  public:\n    // A main method used to construct TempPCHFile.\n    static llvm::ErrorOr<TempPCHFile> CreateNewPreamblePCHFile();\n\n  private:\n    TempPCHFile(std::string FilePath);\n\n  public:\n    TempPCHFile(TempPCHFile &&Other);\n    TempPCHFile &operator=(TempPCHFile &&Other);\n\n    TempPCHFile(const TempPCHFile &) = delete;\n    ~TempPCHFile();\n\n    /// A path where temporary file is stored.\n    llvm::StringRef getFilePath() const;\n\n  private:\n    void RemoveFileIfPresent();\n\n  private:\n    llvm::Optional<std::string> FilePath;\n  };\n\n  class InMemoryPreamble {\n  public:\n    std::string Data;\n  };\n\n  class PCHStorage {\n  public:\n    enum class Kind { Empty, InMemory, TempFile };\n\n    PCHStorage() = default;\n    PCHStorage(TempPCHFile File);\n    PCHStorage(InMemoryPreamble Memory);\n\n    PCHStorage(const PCHStorage &) = delete;\n    PCHStorage &operator=(const PCHStorage &) = delete;\n\n    PCHStorage(PCHStorage &&Other);\n    PCHStorage &operator=(PCHStorage &&Other);\n\n    ~PCHStorage();\n\n    Kind getKind() const;\n\n    TempPCHFile &asFile();\n    const TempPCHFile &asFile() const;\n\n    InMemoryPreamble &asMemory();\n    const InMemoryPreamble &asMemory() const;\n\n  private:\n    void destroy();\n    void setEmpty();\n\n  private:\n    Kind StorageKind = Kind::Empty;\n    llvm::AlignedCharArrayUnion<TempPCHFile, InMemoryPreamble> Storage = {};\n  };\n\n  /// Data used to determine if a file used in the preamble has been changed.\n  struct PreambleFileHash {\n    /// All files have size set.\n    off_t Size = 0;\n\n    /// Modification time is set for files that are on disk.  For memory\n    /// buffers it is zero.\n    time_t ModTime = 0;\n\n    /// Memory buffers have MD5 instead of modification time.  We don't\n    /// compute MD5 for on-disk files because we hope that modification time is\n    /// enough to tell if the file was changed.\n    llvm::MD5::MD5Result MD5 = {};\n\n    static PreambleFileHash createForFile(off_t Size, time_t ModTime);\n    static PreambleFileHash\n    createForMemoryBuffer(const llvm::MemoryBufferRef &Buffer);\n\n    friend bool operator==(const PreambleFileHash &LHS,\n                           const PreambleFileHash &RHS) {\n      return LHS.Size == RHS.Size && LHS.ModTime == RHS.ModTime &&\n             LHS.MD5 == RHS.MD5;\n    }\n    friend bool operator!=(const PreambleFileHash &LHS,\n                           const PreambleFileHash &RHS) {\n      return !(LHS == RHS);\n    }\n  };\n\n  /// Helper function to set up PCH for the preamble into \\p CI and \\p VFS to\n  /// with the specified \\p Bounds.\n  void configurePreamble(PreambleBounds Bounds, CompilerInvocation &CI,\n                         IntrusiveRefCntPtr<llvm::vfs::FileSystem> &VFS,\n                         llvm::MemoryBuffer *MainFileBuffer) const;\n\n  /// Sets up the PreprocessorOptions and changes VFS, so that PCH stored in \\p\n  /// Storage is accessible to clang. This method is an implementation detail of\n  /// AddImplicitPreamble.\n  static void\n  setupPreambleStorage(const PCHStorage &Storage,\n                       PreprocessorOptions &PreprocessorOpts,\n                       IntrusiveRefCntPtr<llvm::vfs::FileSystem> &VFS);\n\n  /// Manages the memory buffer or temporary file that stores the PCH.\n  PCHStorage Storage;\n  /// Keeps track of the files that were used when computing the\n  /// preamble, with both their buffer size and their modification time.\n  ///\n  /// If any of the files have changed from one compile to the next,\n  /// the preamble must be thrown away.\n  llvm::StringMap<PreambleFileHash> FilesInPreamble;\n  /// Files that were not found during preamble building. If any of these now\n  /// exist then the preamble should not be reused.\n  ///\n  /// Storing *all* the missing files that could invalidate the preamble would\n  /// make it too expensive to revalidate (when the include path has many\n  /// entries, each #include will miss half of them on average).\n  /// Instead, we track only files that could have satisfied an #include that\n  /// was ultimately not found.\n  llvm::StringSet<> MissingFiles;\n  /// The contents of the file that was used to precompile the preamble. Only\n  /// contains first PreambleBounds::Size bytes. Used to compare if the relevant\n  /// part of the file has not changed, so that preamble can be reused.\n  std::vector<char> PreambleBytes;\n  /// See PreambleBounds::PreambleEndsAtStartOfLine\n  bool PreambleEndsAtStartOfLine;\n};\n\n/// A set of callbacks to gather useful information while building a preamble.\nclass PreambleCallbacks {\npublic:\n  virtual ~PreambleCallbacks() = default;\n\n  /// Called before FrontendAction::BeginSourceFile.\n  /// Can be used to store references to various CompilerInstance fields\n  /// (e.g. SourceManager) that may be interesting to the consumers of other\n  /// callbacks.\n  virtual void BeforeExecute(CompilerInstance &CI);\n  /// Called after FrontendAction::Execute(), but before\n  /// FrontendAction::EndSourceFile(). Can be used to transfer ownership of\n  /// various CompilerInstance fields before they are destroyed.\n  virtual void AfterExecute(CompilerInstance &CI);\n  /// Called after PCH has been emitted. \\p Writer may be used to retrieve\n  /// information about AST, serialized in PCH.\n  virtual void AfterPCHEmitted(ASTWriter &Writer);\n  /// Called for each TopLevelDecl.\n  /// NOTE: To allow more flexibility a custom ASTConsumer could probably be\n  /// used instead, but having only this method allows a simpler API.\n  virtual void HandleTopLevelDecl(DeclGroupRef DG);\n  /// Creates wrapper class for PPCallbacks so we can also process information\n  /// about includes that are inside of a preamble\n  virtual std::unique_ptr<PPCallbacks> createPPCallbacks();\n  /// The returned CommentHandler will be added to the preprocessor if not null.\n  virtual CommentHandler *getCommentHandler();\n  /// Determines which function bodies are parsed, by default skips everything.\n  /// Only used if FrontendOpts::SkipFunctionBodies is true.\n  /// See ASTConsumer::shouldSkipFunctionBody.\n  virtual bool shouldSkipFunctionBody(Decl *D) { return true; }\n};\n\nenum class BuildPreambleError {\n  CouldntCreateTempFile = 1,\n  CouldntCreateTargetInfo,\n  BeginSourceFileFailed,\n  CouldntEmitPCH,\n  BadInputs\n};\n\nclass BuildPreambleErrorCategory final : public std::error_category {\npublic:\n  const char *name() const noexcept override;\n  std::string message(int condition) const override;\n};\n\nstd::error_code make_error_code(BuildPreambleError Error);\n} // namespace clang\n\nnamespace std {\ntemplate <>\nstruct is_error_code_enum<clang::BuildPreambleError> : std::true_type {};\n} // namespace std\n\n#endif\n"}, "77": {"id": 77, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/Utils.h", "content": "//===- Utils.h - Misc utilities for the front-end ---------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This header contains miscellaneous utilities for various front-end actions.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_FRONTEND_UTILS_H\n#define LLVM_CLANG_FRONTEND_UTILS_H\n\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Driver/OptionUtils.h\"\n#include \"clang/Frontend/DependencyOutputOptions.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/StringSet.h\"\n#include \"llvm/Option/OptSpecifier.h\"\n#include \"llvm/Support/FileCollector.h\"\n#include \"llvm/Support/VirtualFileSystem.h\"\n#include <cstdint>\n#include <memory>\n#include <string>\n#include <system_error>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass Triple;\n\n} // namespace llvm\n\nnamespace clang {\n\nclass ASTReader;\nclass CompilerInstance;\nclass CompilerInvocation;\nclass DiagnosticsEngine;\nclass ExternalSemaSource;\nclass FrontendOptions;\nclass HeaderSearch;\nclass HeaderSearchOptions;\nclass LangOptions;\nclass PCHContainerReader;\nclass Preprocessor;\nclass PreprocessorOptions;\nclass PreprocessorOutputOptions;\n\n/// Apply the header search options to get given HeaderSearch object.\nvoid ApplyHeaderSearchOptions(HeaderSearch &HS,\n                              const HeaderSearchOptions &HSOpts,\n                              const LangOptions &Lang,\n                              const llvm::Triple &triple);\n\n/// InitializePreprocessor - Initialize the preprocessor getting it and the\n/// environment ready to process a single file.\nvoid InitializePreprocessor(Preprocessor &PP, const PreprocessorOptions &PPOpts,\n                            const PCHContainerReader &PCHContainerRdr,\n                            const FrontendOptions &FEOpts);\n\n/// DoPrintPreprocessedInput - Implement -E mode.\nvoid DoPrintPreprocessedInput(Preprocessor &PP, raw_ostream *OS,\n                              const PreprocessorOutputOptions &Opts);\n\n/// An interface for collecting the dependencies of a compilation. Users should\n/// use \\c attachToPreprocessor and \\c attachToASTReader to get all of the\n/// dependencies.\n/// FIXME: Migrate DependencyGraphGen to use this interface.\nclass DependencyCollector {\npublic:\n  virtual ~DependencyCollector();\n\n  virtual void attachToPreprocessor(Preprocessor &PP);\n  virtual void attachToASTReader(ASTReader &R);\n  ArrayRef<std::string> getDependencies() const { return Dependencies; }\n\n  /// Called when a new file is seen. Return true if \\p Filename should be added\n  /// to the list of dependencies.\n  ///\n  /// The default implementation ignores <built-in> and system files.\n  virtual bool sawDependency(StringRef Filename, bool FromModule,\n                             bool IsSystem, bool IsModuleFile, bool IsMissing);\n\n  /// Called when the end of the main file is reached.\n  virtual void finishedMainFile(DiagnosticsEngine &Diags) {}\n\n  /// Return true if system files should be passed to sawDependency().\n  virtual bool needSystemDependencies() { return false; }\n\n  /// Add a dependency \\p Filename if it has not been seen before and\n  /// sawDependency() returns true.\n  virtual void maybeAddDependency(StringRef Filename, bool FromModule,\n                                  bool IsSystem, bool IsModuleFile,\n                                  bool IsMissing);\n\nprotected:\n  /// Return true if the filename was added to the list of dependencies, false\n  /// otherwise.\n  bool addDependency(StringRef Filename);\n\nprivate:\n  llvm::StringSet<> Seen;\n  std::vector<std::string> Dependencies;\n};\n\n/// Builds a dependency file when attached to a Preprocessor (for includes) and\n/// ASTReader (for module imports), and writes it out at the end of processing\n/// a source file.  Users should attach to the ast reader whenever a module is\n/// loaded.\nclass DependencyFileGenerator : public DependencyCollector {\npublic:\n  DependencyFileGenerator(const DependencyOutputOptions &Opts);\n\n  void attachToPreprocessor(Preprocessor &PP) override;\n\n  void finishedMainFile(DiagnosticsEngine &Diags) override;\n\n  bool needSystemDependencies() final override { return IncludeSystemHeaders; }\n\n  bool sawDependency(StringRef Filename, bool FromModule, bool IsSystem,\n                     bool IsModuleFile, bool IsMissing) final override;\n\nprotected:\n  void outputDependencyFile(llvm::raw_ostream &OS);\n\nprivate:\n  void outputDependencyFile(DiagnosticsEngine &Diags);\n\n  std::string OutputFile;\n  std::vector<std::string> Targets;\n  bool IncludeSystemHeaders;\n  bool PhonyTarget;\n  bool AddMissingHeaderDeps;\n  bool SeenMissingHeader;\n  bool IncludeModuleFiles;\n  DependencyOutputFormat OutputFormat;\n  unsigned InputFileIndex;\n};\n\n/// Collects the dependencies for imported modules into a directory.  Users\n/// should attach to the AST reader whenever a module is loaded.\nclass ModuleDependencyCollector : public DependencyCollector {\n  std::string DestDir;\n  bool HasErrors = false;\n  llvm::StringSet<> Seen;\n  llvm::vfs::YAMLVFSWriter VFSWriter;\n  llvm::FileCollector::PathCanonicalizer Canonicalizer;\n\n  std::error_code copyToRoot(StringRef Src, StringRef Dst = {});\n\npublic:\n  ModuleDependencyCollector(std::string DestDir)\n      : DestDir(std::move(DestDir)) {}\n  ~ModuleDependencyCollector() override { writeFileMap(); }\n\n  StringRef getDest() { return DestDir; }\n  virtual bool insertSeen(StringRef Filename) { return Seen.insert(Filename).second; }\n  virtual void addFile(StringRef Filename, StringRef FileDst = {});\n\n  virtual void addFileMapping(StringRef VPath, StringRef RPath) {\n    VFSWriter.addFileMapping(VPath, RPath);\n  }\n\n  void attachToPreprocessor(Preprocessor &PP) override;\n  void attachToASTReader(ASTReader &R) override;\n\n  virtual void writeFileMap();\n  virtual bool hasErrors() { return HasErrors; }\n};\n\n/// AttachDependencyGraphGen - Create a dependency graph generator, and attach\n/// it to the given preprocessor.\nvoid AttachDependencyGraphGen(Preprocessor &PP, StringRef OutputFile,\n                              StringRef SysRoot);\n\n/// AttachHeaderIncludeGen - Create a header include list generator, and attach\n/// it to the given preprocessor.\n///\n/// \\param DepOpts - Options controlling the output.\n/// \\param ShowAllHeaders - If true, show all header information instead of just\n/// headers following the predefines buffer. This is useful for making sure\n/// includes mentioned on the command line are also reported, but differs from\n/// the default behavior used by -H.\n/// \\param OutputPath - If non-empty, a path to write the header include\n/// information to, instead of writing to stderr.\n/// \\param ShowDepth - Whether to indent to show the nesting of the includes.\n/// \\param MSStyle - Whether to print in cl.exe /showIncludes style.\nvoid AttachHeaderIncludeGen(Preprocessor &PP,\n                            const DependencyOutputOptions &DepOpts,\n                            bool ShowAllHeaders = false,\n                            StringRef OutputPath = {},\n                            bool ShowDepth = true, bool MSStyle = false);\n\n/// The ChainedIncludesSource class converts headers to chained PCHs in\n/// memory, mainly for testing.\nIntrusiveRefCntPtr<ExternalSemaSource>\ncreateChainedIncludesSource(CompilerInstance &CI,\n                            IntrusiveRefCntPtr<ExternalSemaSource> &Reader);\n\n/// createInvocationFromCommandLine - Construct a compiler invocation object for\n/// a command line argument vector.\n///\n/// \\param ShouldRecoverOnErrors - whether we should attempt to return a\n/// non-null (and possibly incorrect) CompilerInvocation if any errors were\n/// encountered. When this flag is false, always return null on errors.\n///\n/// \\param CC1Args - if non-null, will be populated with the args to cc1\n/// expanded from \\p Args. May be set even if nullptr is returned.\n///\n/// \\return A CompilerInvocation, or nullptr if none was built for the given\n/// argument vector.\nstd::unique_ptr<CompilerInvocation> createInvocationFromCommandLine(\n    ArrayRef<const char *> Args,\n    IntrusiveRefCntPtr<DiagnosticsEngine> Diags =\n        IntrusiveRefCntPtr<DiagnosticsEngine>(),\n    IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS = nullptr,\n    bool ShouldRecoverOnErrors = false,\n    std::vector<std::string> *CC1Args = nullptr);\n\n// Frontend timing utils\n\n} // namespace clang\n\n#endif // LLVM_CLANG_FRONTEND_UTILS_H\n"}, "78": {"id": 78, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/DirectoryLookup.h", "content": "//===--- DirectoryLookup.h - Info for searching for headers -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the DirectoryLookup interface.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LEX_DIRECTORYLOOKUP_H\n#define LLVM_CLANG_LEX_DIRECTORYLOOKUP_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/FileManager.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Lex/ModuleMap.h\"\n\nnamespace clang {\nclass HeaderMap;\nclass HeaderSearch;\nclass Module;\n\n/// DirectoryLookup - This class represents one entry in the search list that\n/// specifies the search order for directories in \\#include directives.  It\n/// represents either a directory, a framework, or a headermap.\n///\nclass DirectoryLookup {\npublic:\n  enum LookupType_t {\n    LT_NormalDir,\n    LT_Framework,\n    LT_HeaderMap\n  };\nprivate:\n  union DLU { // This union is discriminated by isHeaderMap.\n    /// Dir - This is the actual directory that we're referring to for a normal\n    /// directory or a framework.\n    DirectoryEntryRef Dir;\n\n    /// Map - This is the HeaderMap if this is a headermap lookup.\n    ///\n    const HeaderMap *Map;\n\n    DLU(DirectoryEntryRef Dir) : Dir(Dir) {}\n    DLU(const HeaderMap *Map) : Map(Map) {}\n  } u;\n\n  /// DirCharacteristic - The type of directory this is: this is an instance of\n  /// SrcMgr::CharacteristicKind.\n  unsigned DirCharacteristic : 2;\n\n  /// LookupType - This indicates whether this DirectoryLookup object is a\n  /// normal directory, a framework, or a headermap.\n  unsigned LookupType : 2;\n\n  /// Whether this is a header map used when building a framework.\n  unsigned IsIndexHeaderMap : 1;\n\n  /// Whether we've performed an exhaustive search for module maps\n  /// within the subdirectories of this directory.\n  unsigned SearchedAllModuleMaps : 1;\n\npublic:\n  /// This ctor *does not take ownership* of 'Dir'.\n  DirectoryLookup(DirectoryEntryRef Dir, SrcMgr::CharacteristicKind DT,\n                  bool isFramework)\n      : u(Dir), DirCharacteristic(DT),\n        LookupType(isFramework ? LT_Framework : LT_NormalDir),\n        IsIndexHeaderMap(false), SearchedAllModuleMaps(false) {}\n\n  /// This ctor *does not take ownership* of 'Map'.\n  DirectoryLookup(const HeaderMap *Map, SrcMgr::CharacteristicKind DT,\n                  bool isIndexHeaderMap)\n      : u(Map), DirCharacteristic(DT), LookupType(LT_HeaderMap),\n        IsIndexHeaderMap(isIndexHeaderMap), SearchedAllModuleMaps(false) {}\n\n  /// getLookupType - Return the kind of directory lookup that this is: either a\n  /// normal directory, a framework path, or a HeaderMap.\n  LookupType_t getLookupType() const { return (LookupType_t)LookupType; }\n\n  /// getName - Return the directory or filename corresponding to this lookup\n  /// object.\n  StringRef getName() const;\n\n  /// getDir - Return the directory that this entry refers to.\n  ///\n  const DirectoryEntry *getDir() const {\n    return isNormalDir() ? &u.Dir.getDirEntry() : nullptr;\n  }\n\n  /// getFrameworkDir - Return the directory that this framework refers to.\n  ///\n  const DirectoryEntry *getFrameworkDir() const {\n    return isFramework() ? &u.Dir.getDirEntry() : nullptr;\n  }\n\n  Optional<DirectoryEntryRef> getFrameworkDirRef() const {\n    return isFramework() ? Optional<DirectoryEntryRef>(u.Dir) : None;\n  }\n\n  /// getHeaderMap - Return the directory that this entry refers to.\n  ///\n  const HeaderMap *getHeaderMap() const {\n    return isHeaderMap() ? u.Map : nullptr;\n  }\n\n  /// isNormalDir - Return true if this is a normal directory, not a header map.\n  bool isNormalDir() const { return getLookupType() == LT_NormalDir; }\n\n  /// isFramework - True if this is a framework directory.\n  ///\n  bool isFramework() const { return getLookupType() == LT_Framework; }\n\n  /// isHeaderMap - Return true if this is a header map, not a normal directory.\n  bool isHeaderMap() const { return getLookupType() == LT_HeaderMap; }\n\n  /// Determine whether we have already searched this entire\n  /// directory for module maps.\n  bool haveSearchedAllModuleMaps() const { return SearchedAllModuleMaps; }\n\n  /// Specify whether we have already searched all of the subdirectories\n  /// for module maps.\n  void setSearchedAllModuleMaps(bool SAMM) {\n    SearchedAllModuleMaps = SAMM;\n  }\n\n  /// DirCharacteristic - The type of directory this is, one of the DirType enum\n  /// values.\n  SrcMgr::CharacteristicKind getDirCharacteristic() const {\n    return (SrcMgr::CharacteristicKind)DirCharacteristic;\n  }\n\n  /// Whether this describes a system header directory.\n  bool isSystemHeaderDirectory() const {\n    return getDirCharacteristic() != SrcMgr::C_User;\n  }\n\n  /// Whether this header map is building a framework or not.\n  bool isIndexHeaderMap() const {\n    return isHeaderMap() && IsIndexHeaderMap;\n  }\n\n  /// LookupFile - Lookup the specified file in this search path, returning it\n  /// if it exists or returning null if not.\n  ///\n  /// \\param Filename The file to look up relative to the search paths.\n  ///\n  /// \\param HS The header search instance to search with.\n  ///\n  /// \\param IncludeLoc the source location of the #include or #import\n  /// directive.\n  ///\n  /// \\param SearchPath If not NULL, will be set to the search path relative\n  /// to which the file was found.\n  ///\n  /// \\param RelativePath If not NULL, will be set to the path relative to\n  /// SearchPath at which the file was found. This only differs from the\n  /// Filename for framework includes.\n  ///\n  /// \\param RequestingModule The module in which the lookup was performed.\n  ///\n  /// \\param SuggestedModule If non-null, and the file found is semantically\n  /// part of a known module, this will be set to the module that should\n  /// be imported instead of preprocessing/parsing the file found.\n  ///\n  /// \\param [out] InUserSpecifiedSystemFramework If the file is found,\n  /// set to true if the file is located in a framework that has been\n  /// user-specified to be treated as a system framework.\n  ///\n  /// \\param [out] IsFrameworkFound For a framework directory set to true if\n  /// specified '.framework' directory is found.\n  ///\n  /// \\param [out] MappedName if this is a headermap which maps the filename to\n  /// a framework include (\"Foo.h\" -> \"Foo/Foo.h\"), set the new name to this\n  /// vector and point Filename to it.\n  Optional<FileEntryRef>\n  LookupFile(StringRef &Filename, HeaderSearch &HS, SourceLocation IncludeLoc,\n             SmallVectorImpl<char> *SearchPath,\n             SmallVectorImpl<char> *RelativePath, Module *RequestingModule,\n             ModuleMap::KnownHeader *SuggestedModule,\n             bool &InUserSpecifiedSystemFramework, bool &IsFrameworkFound,\n             bool &IsInHeaderMap, SmallVectorImpl<char> &MappedName) const;\n\nprivate:\n  Optional<FileEntryRef> DoFrameworkLookup(\n      StringRef Filename, HeaderSearch &HS, SmallVectorImpl<char> *SearchPath,\n      SmallVectorImpl<char> *RelativePath, Module *RequestingModule,\n      ModuleMap::KnownHeader *SuggestedModule,\n      bool &InUserSpecifiedSystemFramework, bool &IsFrameworkFound) const;\n};\n\n}  // end namespace clang\n\n#endif\n"}, "79": {"id": 79, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h", "content": "//===- HeaderSearchOptions.h ------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LEX_HEADERSEARCHOPTIONS_H\n#define LLVM_CLANG_LEX_HEADERSEARCHOPTIONS_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/CachedHashString.h\"\n#include \"llvm/ADT/Hashing.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <cstdint>\n#include <string>\n#include <vector>\n#include <map>\n\nnamespace clang {\n\nnamespace frontend {\n\n/// IncludeDirGroup - Identifies the group an include Entry belongs to,\n/// representing its relative positive in the search list.\n/// \\#include directives whose paths are enclosed by string quotes (\"\")\n/// start searching at the Quoted group (specified by '-iquote'),\n/// then search the Angled group, then the System group, etc.\nenum IncludeDirGroup {\n  /// '\\#include \"\"' paths, added by 'gcc -iquote'.\n  Quoted = 0,\n\n  /// Paths for '\\#include <>' added by '-I'.\n  Angled,\n\n  /// Like Angled, but marks header maps used when building frameworks.\n  IndexHeaderMap,\n\n  /// Like Angled, but marks system directories.\n  System,\n\n  /// Like System, but headers are implicitly wrapped in extern \"C\".\n  ExternCSystem,\n\n  /// Like System, but only used for C.\n  CSystem,\n\n  /// Like System, but only used for C++.\n  CXXSystem,\n\n  /// Like System, but only used for ObjC.\n  ObjCSystem,\n\n  /// Like System, but only used for ObjC++.\n  ObjCXXSystem,\n\n  /// Like System, but searched after the system directories.\n  After\n};\n\n} // namespace frontend\n\n/// HeaderSearchOptions - Helper class for storing options related to the\n/// initialization of the HeaderSearch object.\nclass HeaderSearchOptions {\npublic:\n  struct Entry {\n    std::string Path;\n    frontend::IncludeDirGroup Group;\n    unsigned IsFramework : 1;\n\n    /// IgnoreSysRoot - This is false if an absolute path should be treated\n    /// relative to the sysroot, or true if it should always be the absolute\n    /// path.\n    unsigned IgnoreSysRoot : 1;\n\n    Entry(StringRef path, frontend::IncludeDirGroup group, bool isFramework,\n          bool ignoreSysRoot)\n        : Path(path), Group(group), IsFramework(isFramework),\n          IgnoreSysRoot(ignoreSysRoot) {}\n  };\n\n  struct SystemHeaderPrefix {\n    /// A prefix to be matched against paths in \\#include directives.\n    std::string Prefix;\n\n    /// True if paths beginning with this prefix should be treated as system\n    /// headers.\n    bool IsSystemHeader;\n\n    SystemHeaderPrefix(StringRef Prefix, bool IsSystemHeader)\n        : Prefix(Prefix), IsSystemHeader(IsSystemHeader) {}\n  };\n\n  /// If non-empty, the directory to use as a \"virtual system root\" for include\n  /// paths.\n  std::string Sysroot;\n\n  /// User specified include entries.\n  std::vector<Entry> UserEntries;\n\n  /// User-specified system header prefixes.\n  std::vector<SystemHeaderPrefix> SystemHeaderPrefixes;\n\n  /// The directory which holds the compiler resource files (builtin includes,\n  /// etc.).\n  std::string ResourceDir;\n\n  /// The directory used for the module cache.\n  std::string ModuleCachePath;\n\n  /// The directory used for a user build.\n  std::string ModuleUserBuildPath;\n\n  /// The mapping of module names to prebuilt module files.\n  std::map<std::string, std::string, std::less<>> PrebuiltModuleFiles;\n\n  /// The directories used to load prebuilt module files.\n  std::vector<std::string> PrebuiltModulePaths;\n\n  /// The module/pch container format.\n  std::string ModuleFormat;\n\n  /// Whether we should disable the use of the hash string within the\n  /// module cache.\n  ///\n  /// Note: Only used for testing!\n  unsigned DisableModuleHash : 1;\n\n  /// Implicit module maps.  This option is enabld by default when\n  /// modules is enabled.\n  unsigned ImplicitModuleMaps : 1;\n\n  /// Set the 'home directory' of a module map file to the current\n  /// working directory (or the home directory of the module map file that\n  /// contained the 'extern module' directive importing this module map file\n  /// if any) rather than the directory containing the module map file.\n  //\n  /// The home directory is where we look for files named in the module map\n  /// file.\n  unsigned ModuleMapFileHomeIsCwd : 1;\n\n  /// Also search for prebuilt implicit modules in the prebuilt module cache\n  /// path.\n  unsigned EnablePrebuiltImplicitModules : 1;\n\n  /// The interval (in seconds) between pruning operations.\n  ///\n  /// This operation is expensive, because it requires Clang to walk through\n  /// the directory structure of the module cache, stat()'ing and removing\n  /// files.\n  ///\n  /// The default value is large, e.g., the operation runs once a week.\n  unsigned ModuleCachePruneInterval = 7 * 24 * 60 * 60;\n\n  /// The time (in seconds) after which an unused module file will be\n  /// considered unused and will, therefore, be pruned.\n  ///\n  /// When the module cache is pruned, any module file that has not been\n  /// accessed in this many seconds will be removed. The default value is\n  /// large, e.g., a month, to avoid forcing infrequently-used modules to be\n  /// regenerated often.\n  unsigned ModuleCachePruneAfter = 31 * 24 * 60 * 60;\n\n  /// The time in seconds when the build session started.\n  ///\n  /// This time is used by other optimizations in header search and module\n  /// loading.\n  uint64_t BuildSessionTimestamp = 0;\n\n  /// The set of macro names that should be ignored for the purposes\n  /// of computing the module hash.\n  llvm::SmallSetVector<llvm::CachedHashString, 16> ModulesIgnoreMacros;\n\n  /// The set of user-provided virtual filesystem overlay files.\n  std::vector<std::string> VFSOverlayFiles;\n\n  /// Include the compiler builtin includes.\n  unsigned UseBuiltinIncludes : 1;\n\n  /// Include the system standard include search directories.\n  unsigned UseStandardSystemIncludes : 1;\n\n  /// Include the system standard C++ library include search directories.\n  unsigned UseStandardCXXIncludes : 1;\n\n  /// Use libc++ instead of the default libstdc++.\n  unsigned UseLibcxx : 1;\n\n  /// Whether header search information should be output as for -v.\n  unsigned Verbose : 1;\n\n  /// If true, skip verifying input files used by modules if the\n  /// module was already verified during this build session (see\n  /// \\c BuildSessionTimestamp).\n  unsigned ModulesValidateOncePerBuildSession : 1;\n\n  /// Whether to validate system input files when a module is loaded.\n  unsigned ModulesValidateSystemHeaders : 1;\n\n  // Whether the content of input files should be hashed and used to\n  // validate consistency.\n  unsigned ValidateASTInputFilesContent : 1;\n\n  /// Whether the module includes debug information (-gmodules).\n  unsigned UseDebugInfo : 1;\n\n  unsigned ModulesValidateDiagnosticOptions : 1;\n\n  unsigned ModulesHashContent : 1;\n\n  /// Whether we should include all things that could impact the module in the\n  /// hash.\n  ///\n  /// This includes things like the full header search path, and enabled\n  /// diagnostics.\n  unsigned ModulesStrictContextHash : 1;\n\n  HeaderSearchOptions(StringRef _Sysroot = \"/\")\n      : Sysroot(_Sysroot), ModuleFormat(\"raw\"), DisableModuleHash(false),\n        ImplicitModuleMaps(false), ModuleMapFileHomeIsCwd(false),\n        EnablePrebuiltImplicitModules(false), UseBuiltinIncludes(true),\n        UseStandardSystemIncludes(true), UseStandardCXXIncludes(true),\n        UseLibcxx(false), Verbose(false),\n        ModulesValidateOncePerBuildSession(false),\n        ModulesValidateSystemHeaders(false),\n        ValidateASTInputFilesContent(false), UseDebugInfo(false),\n        ModulesValidateDiagnosticOptions(true), ModulesHashContent(false),\n        ModulesStrictContextHash(false) {}\n\n  /// AddPath - Add the \\p Path path to the specified \\p Group list.\n  void AddPath(StringRef Path, frontend::IncludeDirGroup Group,\n               bool IsFramework, bool IgnoreSysRoot) {\n    UserEntries.emplace_back(Path, Group, IsFramework, IgnoreSysRoot);\n  }\n\n  /// AddSystemHeaderPrefix - Override whether \\#include directives naming a\n  /// path starting with \\p Prefix should be considered as naming a system\n  /// header.\n  void AddSystemHeaderPrefix(StringRef Prefix, bool IsSystemHeader) {\n    SystemHeaderPrefixes.emplace_back(Prefix, IsSystemHeader);\n  }\n\n  void AddVFSOverlayFile(StringRef Name) {\n    VFSOverlayFiles.push_back(std::string(Name));\n  }\n\n  void AddPrebuiltModulePath(StringRef Name) {\n    PrebuiltModulePaths.push_back(std::string(Name));\n  }\n};\n\ninline llvm::hash_code hash_value(const HeaderSearchOptions::Entry &E) {\n  return llvm::hash_combine(E.Path, E.Group, E.IsFramework, E.IgnoreSysRoot);\n}\n\ninline llvm::hash_code\nhash_value(const HeaderSearchOptions::SystemHeaderPrefix &SHP) {\n  return llvm::hash_combine(SHP.Prefix, SHP.IsSystemHeader);\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_LEX_HEADERSEARCHOPTIONS_H\n"}, "80": {"id": 80, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/Lexer.h", "content": "//===- Lexer.h - C Language Family Lexer ------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the Lexer interface.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LEX_LEXER_H\n#define LLVM_CLANG_LEX_LEXER_H\n\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/TokenKinds.h\"\n#include \"clang/Lex/PreprocessorLexer.h\"\n#include \"clang/Lex/Token.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <cassert>\n#include <cstdint>\n#include <string>\n\nnamespace llvm {\n\nclass MemoryBufferRef;\n\n} // namespace llvm\n\nnamespace clang {\n\nclass DiagnosticBuilder;\nclass Preprocessor;\nclass SourceManager;\n\n/// ConflictMarkerKind - Kinds of conflict marker which the lexer might be\n/// recovering from.\nenum ConflictMarkerKind {\n  /// Not within a conflict marker.\n  CMK_None,\n\n  /// A normal or diff3 conflict marker, initiated by at least 7 \"<\"s,\n  /// separated by at least 7 \"=\"s or \"|\"s, and terminated by at least 7 \">\"s.\n  CMK_Normal,\n\n  /// A Perforce-style conflict marker, initiated by 4 \">\"s,\n  /// separated by 4 \"=\"s, and terminated by 4 \"<\"s.\n  CMK_Perforce\n};\n\n/// Describes the bounds (start, size) of the preamble and a flag required by\n/// PreprocessorOptions::PrecompiledPreambleBytes.\n/// The preamble includes the BOM, if any.\nstruct PreambleBounds {\n  /// Size of the preamble in bytes.\n  unsigned Size;\n\n  /// Whether the preamble ends at the start of a new line.\n  ///\n  /// Used to inform the lexer as to whether it's starting at the beginning of\n  /// a line after skipping the preamble.\n  bool PreambleEndsAtStartOfLine;\n\n  PreambleBounds(unsigned Size, bool PreambleEndsAtStartOfLine)\n      : Size(Size), PreambleEndsAtStartOfLine(PreambleEndsAtStartOfLine) {}\n};\n\n/// Lexer - This provides a simple interface that turns a text buffer into a\n/// stream of tokens.  This provides no support for file reading or buffering,\n/// or buffering/seeking of tokens, only forward lexing is supported.  It relies\n/// on the specified Preprocessor object to handle preprocessor directives, etc.\nclass Lexer : public PreprocessorLexer {\n  friend class Preprocessor;\n\n  void anchor() override;\n\n  //===--------------------------------------------------------------------===//\n  // Constant configuration values for this lexer.\n\n  // Start of the buffer.\n  const char *BufferStart;\n\n  // End of the buffer.\n  const char *BufferEnd;\n\n  // Location for start of file.\n  SourceLocation FileLoc;\n\n  // LangOpts enabled by this language (cache).\n  LangOptions LangOpts;\n\n  // True if lexer for _Pragma handling.\n  bool Is_PragmaLexer;\n\n  //===--------------------------------------------------------------------===//\n  // Context-specific lexing flags set by the preprocessor.\n  //\n\n  /// ExtendedTokenMode - The lexer can optionally keep comments and whitespace\n  /// and return them as tokens.  This is used for -C and -CC modes, and\n  /// whitespace preservation can be useful for some clients that want to lex\n  /// the file in raw mode and get every character from the file.\n  ///\n  /// When this is set to 2 it returns comments and whitespace.  When set to 1\n  /// it returns comments, when it is set to 0 it returns normal tokens only.\n  unsigned char ExtendedTokenMode;\n\n  //===--------------------------------------------------------------------===//\n  // Context that changes as the file is lexed.\n  // NOTE: any state that mutates when in raw mode must have save/restore code\n  // in Lexer::isNextPPTokenLParen.\n\n  // BufferPtr - Current pointer into the buffer.  This is the next character\n  // to be lexed.\n  const char *BufferPtr;\n\n  // IsAtStartOfLine - True if the next lexed token should get the \"start of\n  // line\" flag set on it.\n  bool IsAtStartOfLine;\n\n  bool IsAtPhysicalStartOfLine;\n\n  bool HasLeadingSpace;\n\n  bool HasLeadingEmptyMacro;\n\n  // NewLinePtr - A pointer to new line character '\\n' being lexed. For '\\r\\n',\n  // it also points to '\\n.'\n  const char *NewLinePtr;\n\n  // CurrentConflictMarkerState - The kind of conflict marker we are handling.\n  ConflictMarkerKind CurrentConflictMarkerState;\n\n  void InitLexer(const char *BufStart, const char *BufPtr, const char *BufEnd);\n\npublic:\n  /// Lexer constructor - Create a new lexer object for the specified buffer\n  /// with the specified preprocessor managing the lexing process.  This lexer\n  /// assumes that the associated file buffer and Preprocessor objects will\n  /// outlive it, so it doesn't take ownership of either of them.\n  Lexer(FileID FID, const llvm::MemoryBufferRef &InputFile, Preprocessor &PP);\n\n  /// Lexer constructor - Create a new raw lexer object.  This object is only\n  /// suitable for calls to 'LexFromRawLexer'.  This lexer assumes that the\n  /// text range will outlive it, so it doesn't take ownership of it.\n  Lexer(SourceLocation FileLoc, const LangOptions &LangOpts,\n        const char *BufStart, const char *BufPtr, const char *BufEnd);\n\n  /// Lexer constructor - Create a new raw lexer object.  This object is only\n  /// suitable for calls to 'LexFromRawLexer'.  This lexer assumes that the\n  /// text range will outlive it, so it doesn't take ownership of it.\n  Lexer(FileID FID, const llvm::MemoryBufferRef &FromFile,\n        const SourceManager &SM, const LangOptions &LangOpts);\n\n  Lexer(const Lexer &) = delete;\n  Lexer &operator=(const Lexer &) = delete;\n\n  /// Create_PragmaLexer: Lexer constructor - Create a new lexer object for\n  /// _Pragma expansion.  This has a variety of magic semantics that this method\n  /// sets up.  It returns a new'd Lexer that must be delete'd when done.\n  static Lexer *Create_PragmaLexer(SourceLocation SpellingLoc,\n                                   SourceLocation ExpansionLocStart,\n                                   SourceLocation ExpansionLocEnd,\n                                   unsigned TokLen, Preprocessor &PP);\n\n  /// getLangOpts - Return the language features currently enabled.\n  /// NOTE: this lexer modifies features as a file is parsed!\n  const LangOptions &getLangOpts() const { return LangOpts; }\n\n  /// getFileLoc - Return the File Location for the file we are lexing out of.\n  /// The physical location encodes the location where the characters come from,\n  /// the virtual location encodes where we should *claim* the characters came\n  /// from.  Currently this is only used by _Pragma handling.\n  SourceLocation getFileLoc() const { return FileLoc; }\n\nprivate:\n  /// Lex - Return the next token in the file.  If this is the end of file, it\n  /// return the tok::eof token.  This implicitly involves the preprocessor.\n  bool Lex(Token &Result);\n\npublic:\n  /// isPragmaLexer - Returns true if this Lexer is being used to lex a pragma.\n  bool isPragmaLexer() const { return Is_PragmaLexer; }\n\nprivate:\n  /// IndirectLex - An indirect call to 'Lex' that can be invoked via\n  ///  the PreprocessorLexer interface.\n  void IndirectLex(Token &Result) override { Lex(Result); }\n\npublic:\n  /// LexFromRawLexer - Lex a token from a designated raw lexer (one with no\n  /// associated preprocessor object.  Return true if the 'next character to\n  /// read' pointer points at the end of the lexer buffer, false otherwise.\n  bool LexFromRawLexer(Token &Result) {\n    assert(LexingRawMode && \"Not already in raw mode!\");\n    Lex(Result);\n    // Note that lexing to the end of the buffer doesn't implicitly delete the\n    // lexer when in raw mode.\n    return BufferPtr == BufferEnd;\n  }\n\n  /// isKeepWhitespaceMode - Return true if the lexer should return tokens for\n  /// every character in the file, including whitespace and comments.  This\n  /// should only be used in raw mode, as the preprocessor is not prepared to\n  /// deal with the excess tokens.\n  bool isKeepWhitespaceMode() const {\n    return ExtendedTokenMode > 1;\n  }\n\n  /// SetKeepWhitespaceMode - This method lets clients enable or disable\n  /// whitespace retention mode.\n  void SetKeepWhitespaceMode(bool Val) {\n    assert((!Val || LexingRawMode || LangOpts.TraditionalCPP) &&\n           \"Can only retain whitespace in raw mode or -traditional-cpp\");\n    ExtendedTokenMode = Val ? 2 : 0;\n  }\n\n  /// inKeepCommentMode - Return true if the lexer should return comments as\n  /// tokens.\n  bool inKeepCommentMode() const {\n    return ExtendedTokenMode > 0;\n  }\n\n  /// SetCommentRetentionMode - Change the comment retention mode of the lexer\n  /// to the specified mode.  This is really only useful when lexing in raw\n  /// mode, because otherwise the lexer needs to manage this.\n  void SetCommentRetentionState(bool Mode) {\n    assert(!isKeepWhitespaceMode() &&\n           \"Can't play with comment retention state when retaining whitespace\");\n    ExtendedTokenMode = Mode ? 1 : 0;\n  }\n\n  /// Sets the extended token mode back to its initial value, according to the\n  /// language options and preprocessor. This controls whether the lexer\n  /// produces comment and whitespace tokens.\n  ///\n  /// This requires the lexer to have an associated preprocessor. A standalone\n  /// lexer has nothing to reset to.\n  void resetExtendedTokenMode();\n\n  /// Gets source code buffer.\n  StringRef getBuffer() const {\n    return StringRef(BufferStart, BufferEnd - BufferStart);\n  }\n\n  /// ReadToEndOfLine - Read the rest of the current preprocessor line as an\n  /// uninterpreted string.  This switches the lexer out of directive mode.\n  void ReadToEndOfLine(SmallVectorImpl<char> *Result = nullptr);\n\n\n  /// Diag - Forwarding function for diagnostics.  This translate a source\n  /// position in the current buffer into a SourceLocation object for rendering.\n  DiagnosticBuilder Diag(const char *Loc, unsigned DiagID) const;\n\n  /// getSourceLocation - Return a source location identifier for the specified\n  /// offset in the current file.\n  SourceLocation getSourceLocation(const char *Loc, unsigned TokLen = 1) const;\n\n  /// getSourceLocation - Return a source location for the next character in\n  /// the current file.\n  SourceLocation getSourceLocation() override {\n    return getSourceLocation(BufferPtr);\n  }\n\n  /// Return the current location in the buffer.\n  const char *getBufferLocation() const { return BufferPtr; }\n\n  /// Returns the current lexing offset.\n  unsigned getCurrentBufferOffset() {\n    assert(BufferPtr >= BufferStart && \"Invalid buffer state\");\n    return BufferPtr - BufferStart;\n  }\n\n  /// Skip over \\p NumBytes bytes.\n  ///\n  /// If the skip is successful, the next token will be lexed from the new\n  /// offset. The lexer also assumes that we skipped to the start of the line.\n  ///\n  /// \\returns true if the skip failed (new offset would have been past the\n  /// end of the buffer), false otherwise.\n  bool skipOver(unsigned NumBytes);\n\n  /// Stringify - Convert the specified string into a C string by i) escaping\n  /// '\\\\' and \" characters and ii) replacing newline character(s) with \"\\\\n\".\n  /// If Charify is true, this escapes the ' character instead of \".\n  static std::string Stringify(StringRef Str, bool Charify = false);\n\n  /// Stringify - Convert the specified string into a C string by i) escaping\n  /// '\\\\' and \" characters and ii) replacing newline character(s) with \"\\\\n\".\n  static void Stringify(SmallVectorImpl<char> &Str);\n\n  /// getSpelling - This method is used to get the spelling of a token into a\n  /// preallocated buffer, instead of as an std::string.  The caller is required\n  /// to allocate enough space for the token, which is guaranteed to be at least\n  /// Tok.getLength() bytes long.  The length of the actual result is returned.\n  ///\n  /// Note that this method may do two possible things: it may either fill in\n  /// the buffer specified with characters, or it may *change the input pointer*\n  /// to point to a constant buffer with the data already in it (avoiding a\n  /// copy).  The caller is not allowed to modify the returned buffer pointer\n  /// if an internal buffer is returned.\n  static unsigned getSpelling(const Token &Tok, const char *&Buffer,\n                              const SourceManager &SourceMgr,\n                              const LangOptions &LangOpts,\n                              bool *Invalid = nullptr);\n\n  /// getSpelling() - Return the 'spelling' of the Tok token.  The spelling of a\n  /// token is the characters used to represent the token in the source file\n  /// after trigraph expansion and escaped-newline folding.  In particular, this\n  /// wants to get the true, uncanonicalized, spelling of things like digraphs\n  /// UCNs, etc.\n  static std::string getSpelling(const Token &Tok,\n                                 const SourceManager &SourceMgr,\n                                 const LangOptions &LangOpts,\n                                 bool *Invalid = nullptr);\n\n  /// getSpelling - This method is used to get the spelling of the\n  /// token at the given source location.  If, as is usually true, it\n  /// is not necessary to copy any data, then the returned string may\n  /// not point into the provided buffer.\n  ///\n  /// This method lexes at the expansion depth of the given\n  /// location and does not jump to the expansion or spelling\n  /// location.\n  static StringRef getSpelling(SourceLocation loc,\n                               SmallVectorImpl<char> &buffer,\n                               const SourceManager &SM,\n                               const LangOptions &options,\n                               bool *invalid = nullptr);\n\n  /// MeasureTokenLength - Relex the token at the specified location and return\n  /// its length in bytes in the input file.  If the token needs cleaning (e.g.\n  /// includes a trigraph or an escaped newline) then this count includes bytes\n  /// that are part of that.\n  static unsigned MeasureTokenLength(SourceLocation Loc,\n                                     const SourceManager &SM,\n                                     const LangOptions &LangOpts);\n\n  /// Relex the token at the specified location.\n  /// \\returns true if there was a failure, false on success.\n  static bool getRawToken(SourceLocation Loc, Token &Result,\n                          const SourceManager &SM,\n                          const LangOptions &LangOpts,\n                          bool IgnoreWhiteSpace = false);\n\n  /// Given a location any where in a source buffer, find the location\n  /// that corresponds to the beginning of the token in which the original\n  /// source location lands.\n  static SourceLocation GetBeginningOfToken(SourceLocation Loc,\n                                            const SourceManager &SM,\n                                            const LangOptions &LangOpts);\n\n  /// Get the physical length (including trigraphs and escaped newlines) of the\n  /// first \\p Characters characters of the token starting at TokStart.\n  static unsigned getTokenPrefixLength(SourceLocation TokStart,\n                                       unsigned CharNo,\n                                       const SourceManager &SM,\n                                       const LangOptions &LangOpts);\n\n  /// AdvanceToTokenCharacter - If the current SourceLocation specifies a\n  /// location at the start of a token, return a new location that specifies a\n  /// character within the token.  This handles trigraphs and escaped newlines.\n  static SourceLocation AdvanceToTokenCharacter(SourceLocation TokStart,\n                                                unsigned Characters,\n                                                const SourceManager &SM,\n                                                const LangOptions &LangOpts) {\n    return TokStart.getLocWithOffset(\n        getTokenPrefixLength(TokStart, Characters, SM, LangOpts));\n  }\n\n  /// Computes the source location just past the end of the\n  /// token at this source location.\n  ///\n  /// This routine can be used to produce a source location that\n  /// points just past the end of the token referenced by \\p Loc, and\n  /// is generally used when a diagnostic needs to point just after a\n  /// token where it expected something different that it received. If\n  /// the returned source location would not be meaningful (e.g., if\n  /// it points into a macro), this routine returns an invalid\n  /// source location.\n  ///\n  /// \\param Offset an offset from the end of the token, where the source\n  /// location should refer to. The default offset (0) produces a source\n  /// location pointing just past the end of the token; an offset of 1 produces\n  /// a source location pointing to the last character in the token, etc.\n  static SourceLocation getLocForEndOfToken(SourceLocation Loc, unsigned Offset,\n                                            const SourceManager &SM,\n                                            const LangOptions &LangOpts);\n\n  /// Given a token range, produce a corresponding CharSourceRange that\n  /// is not a token range. This allows the source range to be used by\n  /// components that don't have access to the lexer and thus can't find the\n  /// end of the range for themselves.\n  static CharSourceRange getAsCharRange(SourceRange Range,\n                                        const SourceManager &SM,\n                                        const LangOptions &LangOpts) {\n    SourceLocation End = getLocForEndOfToken(Range.getEnd(), 0, SM, LangOpts);\n    return End.isInvalid() ? CharSourceRange()\n                           : CharSourceRange::getCharRange(\n                                 Range.getBegin(), End);\n  }\n  static CharSourceRange getAsCharRange(CharSourceRange Range,\n                                        const SourceManager &SM,\n                                        const LangOptions &LangOpts) {\n    return Range.isTokenRange()\n               ? getAsCharRange(Range.getAsRange(), SM, LangOpts)\n               : Range;\n  }\n\n  /// Returns true if the given MacroID location points at the first\n  /// token of the macro expansion.\n  ///\n  /// \\param MacroBegin If non-null and function returns true, it is set to\n  /// begin location of the macro.\n  static bool isAtStartOfMacroExpansion(SourceLocation loc,\n                                        const SourceManager &SM,\n                                        const LangOptions &LangOpts,\n                                        SourceLocation *MacroBegin = nullptr);\n\n  /// Returns true if the given MacroID location points at the last\n  /// token of the macro expansion.\n  ///\n  /// \\param MacroEnd If non-null and function returns true, it is set to\n  /// end location of the macro.\n  static bool isAtEndOfMacroExpansion(SourceLocation loc,\n                                      const SourceManager &SM,\n                                      const LangOptions &LangOpts,\n                                      SourceLocation *MacroEnd = nullptr);\n\n  /// Accepts a range and returns a character range with file locations.\n  ///\n  /// Returns a null range if a part of the range resides inside a macro\n  /// expansion or the range does not reside on the same FileID.\n  ///\n  /// This function is trying to deal with macros and return a range based on\n  /// file locations. The cases where it can successfully handle macros are:\n  ///\n  /// -begin or end range lies at the start or end of a macro expansion, in\n  ///  which case the location will be set to the expansion point, e.g:\n  ///    \\#define M 1 2\n  ///    a M\n  /// If you have a range [a, 2] (where 2 came from the macro), the function\n  /// will return a range for \"a M\"\n  /// if you have range [a, 1], the function will fail because the range\n  /// overlaps with only a part of the macro\n  ///\n  /// -The macro is a function macro and the range can be mapped to the macro\n  ///  arguments, e.g:\n  ///    \\#define M 1 2\n  ///    \\#define FM(x) x\n  ///    FM(a b M)\n  /// if you have range [b, 2], the function will return the file range \"b M\"\n  /// inside the macro arguments.\n  /// if you have range [a, 2], the function will return the file range\n  /// \"FM(a b M)\" since the range includes all of the macro expansion.\n  static CharSourceRange makeFileCharRange(CharSourceRange Range,\n                                           const SourceManager &SM,\n                                           const LangOptions &LangOpts);\n\n  /// Returns a string for the source that the range encompasses.\n  static StringRef getSourceText(CharSourceRange Range,\n                                 const SourceManager &SM,\n                                 const LangOptions &LangOpts,\n                                 bool *Invalid = nullptr);\n\n  /// Retrieve the name of the immediate macro expansion.\n  ///\n  /// This routine starts from a source location, and finds the name of the macro\n  /// responsible for its immediate expansion. It looks through any intervening\n  /// macro argument expansions to compute this. It returns a StringRef which\n  /// refers to the SourceManager-owned buffer of the source where that macro\n  /// name is spelled. Thus, the result shouldn't out-live that SourceManager.\n  static StringRef getImmediateMacroName(SourceLocation Loc,\n                                         const SourceManager &SM,\n                                         const LangOptions &LangOpts);\n\n  /// Retrieve the name of the immediate macro expansion.\n  ///\n  /// This routine starts from a source location, and finds the name of the\n  /// macro responsible for its immediate expansion. It looks through any\n  /// intervening macro argument expansions to compute this. It returns a\n  /// StringRef which refers to the SourceManager-owned buffer of the source\n  /// where that macro name is spelled. Thus, the result shouldn't out-live\n  /// that SourceManager.\n  ///\n  /// This differs from Lexer::getImmediateMacroName in that any macro argument\n  /// location will result in the topmost function macro that accepted it.\n  /// e.g.\n  /// \\code\n  ///   MAC1( MAC2(foo) )\n  /// \\endcode\n  /// for location of 'foo' token, this function will return \"MAC1\" while\n  /// Lexer::getImmediateMacroName will return \"MAC2\".\n  static StringRef getImmediateMacroNameForDiagnostics(\n      SourceLocation Loc, const SourceManager &SM, const LangOptions &LangOpts);\n\n  /// Compute the preamble of the given file.\n  ///\n  /// The preamble of a file contains the initial comments, include directives,\n  /// and other preprocessor directives that occur before the code in this\n  /// particular file actually begins. The preamble of the main source file is\n  /// a potential prefix header.\n  ///\n  /// \\param Buffer The memory buffer containing the file's contents.\n  ///\n  /// \\param MaxLines If non-zero, restrict the length of the preamble\n  /// to fewer than this number of lines.\n  ///\n  /// \\returns The offset into the file where the preamble ends and the rest\n  /// of the file begins along with a boolean value indicating whether\n  /// the preamble ends at the beginning of a new line.\n  static PreambleBounds ComputePreamble(StringRef Buffer,\n                                        const LangOptions &LangOpts,\n                                        unsigned MaxLines = 0);\n\n  /// Finds the token that comes right after the given location.\n  ///\n  /// Returns the next token, or none if the location is inside a macro.\n  static Optional<Token> findNextToken(SourceLocation Loc,\n                                       const SourceManager &SM,\n                                       const LangOptions &LangOpts);\n\n  /// Checks that the given token is the first token that occurs after\n  /// the given location (this excludes comments and whitespace). Returns the\n  /// location immediately after the specified token. If the token is not found\n  /// or the location is inside a macro, the returned source location will be\n  /// invalid.\n  static SourceLocation findLocationAfterToken(SourceLocation loc,\n                                         tok::TokenKind TKind,\n                                         const SourceManager &SM,\n                                         const LangOptions &LangOpts,\n                                         bool SkipTrailingWhitespaceAndNewLine);\n\n  /// Returns true if the given character could appear in an identifier.\n  static bool isIdentifierBodyChar(char c, const LangOptions &LangOpts);\n\n  /// Checks whether new line pointed by Str is preceded by escape\n  /// sequence.\n  static bool isNewLineEscaped(const char *BufferStart, const char *Str);\n\n  /// getCharAndSizeNoWarn - Like the getCharAndSize method, but does not ever\n  /// emit a warning.\n  static inline char getCharAndSizeNoWarn(const char *Ptr, unsigned &Size,\n                                          const LangOptions &LangOpts) {\n    // If this is not a trigraph and not a UCN or escaped newline, return\n    // quickly.\n    if (isObviouslySimpleCharacter(Ptr[0])) {\n      Size = 1;\n      return *Ptr;\n    }\n\n    Size = 0;\n    return getCharAndSizeSlowNoWarn(Ptr, Size, LangOpts);\n  }\n\n  /// Returns the leading whitespace for line that corresponds to the given\n  /// location \\p Loc.\n  static StringRef getIndentationForLine(SourceLocation Loc,\n                                         const SourceManager &SM);\n\nprivate:\n  //===--------------------------------------------------------------------===//\n  // Internal implementation interfaces.\n\n  /// LexTokenInternal - Internal interface to lex a preprocessing token. Called\n  /// by Lex.\n  ///\n  bool LexTokenInternal(Token &Result, bool TokAtPhysicalStartOfLine);\n\n  bool CheckUnicodeWhitespace(Token &Result, uint32_t C, const char *CurPtr);\n\n  /// Given that a token begins with the Unicode character \\p C, figure out\n  /// what kind of token it is and dispatch to the appropriate lexing helper\n  /// function.\n  bool LexUnicode(Token &Result, uint32_t C, const char *CurPtr);\n\n  /// FormTokenWithChars - When we lex a token, we have identified a span\n  /// starting at BufferPtr, going to TokEnd that forms the token.  This method\n  /// takes that range and assigns it to the token as its location and size.  In\n  /// addition, since tokens cannot overlap, this also updates BufferPtr to be\n  /// TokEnd.\n  void FormTokenWithChars(Token &Result, const char *TokEnd,\n                          tok::TokenKind Kind) {\n    unsigned TokLen = TokEnd-BufferPtr;\n    Result.setLength(TokLen);\n    Result.setLocation(getSourceLocation(BufferPtr, TokLen));\n    Result.setKind(Kind);\n    BufferPtr = TokEnd;\n  }\n\n  /// isNextPPTokenLParen - Return 1 if the next unexpanded token will return a\n  /// tok::l_paren token, 0 if it is something else and 2 if there are no more\n  /// tokens in the buffer controlled by this lexer.\n  unsigned isNextPPTokenLParen();\n\n  //===--------------------------------------------------------------------===//\n  // Lexer character reading interfaces.\n\n  // This lexer is built on two interfaces for reading characters, both of which\n  // automatically provide phase 1/2 translation.  getAndAdvanceChar is used\n  // when we know that we will be reading a character from the input buffer and\n  // that this character will be part of the result token. This occurs in (f.e.)\n  // string processing, because we know we need to read until we find the\n  // closing '\"' character.\n  //\n  // The second interface is the combination of getCharAndSize with\n  // ConsumeChar.  getCharAndSize reads a phase 1/2 translated character,\n  // returning it and its size.  If the lexer decides that this character is\n  // part of the current token, it calls ConsumeChar on it.  This two stage\n  // approach allows us to emit diagnostics for characters (e.g. warnings about\n  // trigraphs), knowing that they only are emitted if the character is\n  // consumed.\n\n  /// isObviouslySimpleCharacter - Return true if the specified character is\n  /// obviously the same in translation phase 1 and translation phase 3.  This\n  /// can return false for characters that end up being the same, but it will\n  /// never return true for something that needs to be mapped.\n  static bool isObviouslySimpleCharacter(char C) {\n    return C != '?' && C != '\\\\';\n  }\n\n  /// getAndAdvanceChar - Read a single 'character' from the specified buffer,\n  /// advance over it, and return it.  This is tricky in several cases.  Here we\n  /// just handle the trivial case and fall-back to the non-inlined\n  /// getCharAndSizeSlow method to handle the hard case.\n  inline char getAndAdvanceChar(const char *&Ptr, Token &Tok) {\n    // If this is not a trigraph and not a UCN or escaped newline, return\n    // quickly.\n    if (isObviouslySimpleCharacter(Ptr[0])) return *Ptr++;\n\n    unsigned Size = 0;\n    char C = getCharAndSizeSlow(Ptr, Size, &Tok);\n    Ptr += Size;\n    return C;\n  }\n\n  /// ConsumeChar - When a character (identified by getCharAndSize) is consumed\n  /// and added to a given token, check to see if there are diagnostics that\n  /// need to be emitted or flags that need to be set on the token.  If so, do\n  /// it.\n  const char *ConsumeChar(const char *Ptr, unsigned Size, Token &Tok) {\n    // Normal case, we consumed exactly one token.  Just return it.\n    if (Size == 1)\n      return Ptr+Size;\n\n    // Otherwise, re-lex the character with a current token, allowing\n    // diagnostics to be emitted and flags to be set.\n    Size = 0;\n    getCharAndSizeSlow(Ptr, Size, &Tok);\n    return Ptr+Size;\n  }\n\n  /// getCharAndSize - Peek a single 'character' from the specified buffer,\n  /// get its size, and return it.  This is tricky in several cases.  Here we\n  /// just handle the trivial case and fall-back to the non-inlined\n  /// getCharAndSizeSlow method to handle the hard case.\n  inline char getCharAndSize(const char *Ptr, unsigned &Size) {\n    // If this is not a trigraph and not a UCN or escaped newline, return\n    // quickly.\n    if (isObviouslySimpleCharacter(Ptr[0])) {\n      Size = 1;\n      return *Ptr;\n    }\n\n    Size = 0;\n    return getCharAndSizeSlow(Ptr, Size);\n  }\n\n  /// getCharAndSizeSlow - Handle the slow/uncommon case of the getCharAndSize\n  /// method.\n  char getCharAndSizeSlow(const char *Ptr, unsigned &Size,\n                          Token *Tok = nullptr);\n\n  /// getEscapedNewLineSize - Return the size of the specified escaped newline,\n  /// or 0 if it is not an escaped newline. P[-1] is known to be a \"\\\" on entry\n  /// to this function.\n  static unsigned getEscapedNewLineSize(const char *P);\n\n  /// SkipEscapedNewLines - If P points to an escaped newline (or a series of\n  /// them), skip over them and return the first non-escaped-newline found,\n  /// otherwise return P.\n  static const char *SkipEscapedNewLines(const char *P);\n\n  /// getCharAndSizeSlowNoWarn - Same as getCharAndSizeSlow, but never emits a\n  /// diagnostic.\n  static char getCharAndSizeSlowNoWarn(const char *Ptr, unsigned &Size,\n                                       const LangOptions &LangOpts);\n\n  //===--------------------------------------------------------------------===//\n  // Other lexer functions.\n\n  void SetByteOffset(unsigned Offset, bool StartOfLine);\n\n  void PropagateLineStartLeadingSpaceInfo(Token &Result);\n\n  const char *LexUDSuffix(Token &Result, const char *CurPtr,\n                          bool IsStringLiteral);\n\n  // Helper functions to lex the remainder of a token of the specific type.\n  bool LexIdentifier         (Token &Result, const char *CurPtr);\n  bool LexNumericConstant    (Token &Result, const char *CurPtr);\n  bool LexStringLiteral      (Token &Result, const char *CurPtr,\n                              tok::TokenKind Kind);\n  bool LexRawStringLiteral   (Token &Result, const char *CurPtr,\n                              tok::TokenKind Kind);\n  bool LexAngledStringLiteral(Token &Result, const char *CurPtr);\n  bool LexCharConstant       (Token &Result, const char *CurPtr,\n                              tok::TokenKind Kind);\n  bool LexEndOfFile          (Token &Result, const char *CurPtr);\n  bool SkipWhitespace        (Token &Result, const char *CurPtr,\n                              bool &TokAtPhysicalStartOfLine);\n  bool SkipLineComment       (Token &Result, const char *CurPtr,\n                              bool &TokAtPhysicalStartOfLine);\n  bool SkipBlockComment      (Token &Result, const char *CurPtr,\n                              bool &TokAtPhysicalStartOfLine);\n  bool SaveLineComment       (Token &Result, const char *CurPtr);\n\n  bool IsStartOfConflictMarker(const char *CurPtr);\n  bool HandleEndOfConflictMarker(const char *CurPtr);\n\n  bool lexEditorPlaceholder(Token &Result, const char *CurPtr);\n\n  bool isCodeCompletionPoint(const char *CurPtr) const;\n  void cutOffLexing() { BufferPtr = BufferEnd; }\n\n  bool isHexaLiteral(const char *Start, const LangOptions &LangOpts);\n\n  void codeCompleteIncludedFile(const char *PathStart,\n                                const char *CompletionPoint, bool IsAngled);\n\n  /// Read a universal character name.\n  ///\n  /// \\param StartPtr The position in the source buffer after the initial '\\'.\n  ///                 If the UCN is syntactically well-formed (but not \n  ///                 necessarily valid), this parameter will be updated to\n  ///                 point to the character after the UCN.\n  /// \\param SlashLoc The position in the source buffer of the '\\'.\n  /// \\param Result   The token being formed. Pass \\c nullptr to suppress\n  ///                 diagnostics and handle token formation in the caller.\n  ///\n  /// \\return The Unicode codepoint specified by the UCN, or 0 if the UCN is\n  ///         invalid.\n  uint32_t tryReadUCN(const char *&StartPtr, const char *SlashLoc, Token *Result);\n\n  /// Try to consume a UCN as part of an identifier at the current\n  /// location.\n  /// \\param CurPtr Initially points to the range of characters in the source\n  ///               buffer containing the '\\'. Updated to point past the end of\n  ///               the UCN on success.\n  /// \\param Size The number of characters occupied by the '\\' (including\n  ///             trigraphs and escaped newlines).\n  /// \\param Result The token being produced. Marked as containing a UCN on\n  ///               success.\n  /// \\return \\c true if a UCN was lexed and it produced an acceptable\n  ///         identifier character, \\c false otherwise.\n  bool tryConsumeIdentifierUCN(const char *&CurPtr, unsigned Size,\n                               Token &Result);\n\n  /// Try to consume an identifier character encoded in UTF-8.\n  /// \\param CurPtr Points to the start of the (potential) UTF-8 code unit\n  ///        sequence. On success, updated to point past the end of it.\n  /// \\return \\c true if a UTF-8 sequence mapping to an acceptable identifier\n  ///         character was lexed, \\c false otherwise.\n  bool tryConsumeIdentifierUTF8Char(const char *&CurPtr);\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_LEX_LEXER_H\n"}, "81": {"id": 81, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/MacroInfo.h", "content": "//===- MacroInfo.h - Information about #defined identifiers -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the clang::MacroInfo and clang::MacroDirective classes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LEX_MACROINFO_H\n#define LLVM_CLANG_LEX_MACROINFO_H\n\n#include \"clang/Lex/Token.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <algorithm>\n#include <cassert>\n\nnamespace clang {\n\nclass DefMacroDirective;\nclass IdentifierInfo;\nclass Module;\nclass Preprocessor;\nclass SourceManager;\n\n/// Encapsulates the data about a macro definition (e.g. its tokens).\n///\n/// There's an instance of this class for every #define.\nclass MacroInfo {\n  //===--------------------------------------------------------------------===//\n  // State set when the macro is defined.\n\n  /// The location the macro is defined.\n  SourceLocation Location;\n\n  /// The location of the last token in the macro.\n  SourceLocation EndLocation;\n\n  /// The list of arguments for a function-like macro.\n  ///\n  /// ParameterList points to the first of NumParameters pointers.\n  ///\n  /// This can be empty, for, e.g. \"#define X()\".  In a C99-style variadic\n  /// macro, this includes the \\c __VA_ARGS__ identifier on the list.\n  IdentifierInfo **ParameterList = nullptr;\n\n  /// \\see ParameterList\n  unsigned NumParameters = 0;\n\n  /// This is the list of tokens that the macro is defined to.\n  SmallVector<Token, 8> ReplacementTokens;\n\n  /// Length in characters of the macro definition.\n  mutable unsigned DefinitionLength;\n  mutable bool IsDefinitionLengthCached : 1;\n\n  /// True if this macro is function-like, false if it is object-like.\n  bool IsFunctionLike : 1;\n\n  /// True if this macro is of the form \"#define X(...)\" or\n  /// \"#define X(Y,Z,...)\".\n  ///\n  /// The __VA_ARGS__ token should be replaced with the contents of \"...\" in an\n  /// invocation.\n  bool IsC99Varargs : 1;\n\n  /// True if this macro is of the form \"#define X(a...)\".\n  ///\n  /// The \"a\" identifier in the replacement list will be replaced with all\n  /// arguments of the macro starting with the specified one.\n  bool IsGNUVarargs : 1;\n\n  /// True if this macro requires processing before expansion.\n  ///\n  /// This is the case for builtin macros such as __LINE__, so long as they have\n  /// not been redefined, but not for regular predefined macros from the\n  /// \"<built-in>\" memory buffer (see Preprocessing::getPredefinesFileID).\n  bool IsBuiltinMacro : 1;\n\n  /// Whether this macro contains the sequence \", ## __VA_ARGS__\"\n  bool HasCommaPasting : 1;\n\n  //===--------------------------------------------------------------------===//\n  // State that changes as the macro is used.\n\n  /// True if we have started an expansion of this macro already.\n  ///\n  /// This disables recursive expansion, which would be quite bad for things\n  /// like \\#define A A.\n  bool IsDisabled : 1;\n\n  /// True if this macro is either defined in the main file and has\n  /// been used, or if it is not defined in the main file.\n  ///\n  /// This is used to emit -Wunused-macros diagnostics.\n  bool IsUsed : 1;\n\n  /// True if this macro can be redefined without emitting a warning.\n  bool IsAllowRedefinitionsWithoutWarning : 1;\n\n  /// Must warn if the macro is unused at the end of translation unit.\n  bool IsWarnIfUnused : 1;\n\n  /// Whether this macro was used as header guard.\n  bool UsedForHeaderGuard : 1;\n\n  // Only the Preprocessor gets to create and destroy these.\n  MacroInfo(SourceLocation DefLoc);\n  ~MacroInfo() = default;\n\npublic:\n  /// Return the location that the macro was defined at.\n  SourceLocation getDefinitionLoc() const { return Location; }\n\n  /// Set the location of the last token in the macro.\n  void setDefinitionEndLoc(SourceLocation EndLoc) { EndLocation = EndLoc; }\n\n  /// Return the location of the last token in the macro.\n  SourceLocation getDefinitionEndLoc() const { return EndLocation; }\n\n  /// Get length in characters of the macro definition.\n  unsigned getDefinitionLength(const SourceManager &SM) const {\n    if (IsDefinitionLengthCached)\n      return DefinitionLength;\n    return getDefinitionLengthSlow(SM);\n  }\n\n  /// Return true if the specified macro definition is equal to\n  /// this macro in spelling, arguments, and whitespace.\n  ///\n  /// \\param Syntactically if true, the macro definitions can be identical even\n  /// if they use different identifiers for the function macro parameters.\n  /// Otherwise the comparison is lexical and this implements the rules in\n  /// C99 6.10.3.\n  bool isIdenticalTo(const MacroInfo &Other, Preprocessor &PP,\n                     bool Syntactically) const;\n\n  /// Set or clear the isBuiltinMacro flag.\n  void setIsBuiltinMacro(bool Val = true) { IsBuiltinMacro = Val; }\n\n  /// Set the value of the IsUsed flag.\n  void setIsUsed(bool Val) { IsUsed = Val; }\n\n  /// Set the value of the IsAllowRedefinitionsWithoutWarning flag.\n  void setIsAllowRedefinitionsWithoutWarning(bool Val) {\n    IsAllowRedefinitionsWithoutWarning = Val;\n  }\n\n  /// Set the value of the IsWarnIfUnused flag.\n  void setIsWarnIfUnused(bool val) { IsWarnIfUnused = val; }\n\n  /// Set the specified list of identifiers as the parameter list for\n  /// this macro.\n  void setParameterList(ArrayRef<IdentifierInfo *> List,\n                       llvm::BumpPtrAllocator &PPAllocator) {\n    assert(ParameterList == nullptr && NumParameters == 0 &&\n           \"Parameter list already set!\");\n    if (List.empty())\n      return;\n\n    NumParameters = List.size();\n    ParameterList = PPAllocator.Allocate<IdentifierInfo *>(List.size());\n    std::copy(List.begin(), List.end(), ParameterList);\n  }\n\n  /// Parameters - The list of parameters for a function-like macro.  This can\n  /// be empty, for, e.g. \"#define X()\".\n  using param_iterator = IdentifierInfo *const *;\n  bool param_empty() const { return NumParameters == 0; }\n  param_iterator param_begin() const { return ParameterList; }\n  param_iterator param_end() const { return ParameterList + NumParameters; }\n  unsigned getNumParams() const { return NumParameters; }\n  ArrayRef<const IdentifierInfo *> params() const {\n    return ArrayRef<const IdentifierInfo *>(ParameterList, NumParameters);\n  }\n\n  /// Return the parameter number of the specified identifier,\n  /// or -1 if the identifier is not a formal parameter identifier.\n  int getParameterNum(const IdentifierInfo *Arg) const {\n    for (param_iterator I = param_begin(), E = param_end(); I != E; ++I)\n      if (*I == Arg)\n        return I - param_begin();\n    return -1;\n  }\n\n  /// Function/Object-likeness.  Keep track of whether this macro has formal\n  /// parameters.\n  void setIsFunctionLike() { IsFunctionLike = true; }\n  bool isFunctionLike() const { return IsFunctionLike; }\n  bool isObjectLike() const { return !IsFunctionLike; }\n\n  /// Varargs querying methods.  This can only be set for function-like macros.\n  void setIsC99Varargs() { IsC99Varargs = true; }\n  void setIsGNUVarargs() { IsGNUVarargs = true; }\n  bool isC99Varargs() const { return IsC99Varargs; }\n  bool isGNUVarargs() const { return IsGNUVarargs; }\n  bool isVariadic() const { return IsC99Varargs | IsGNUVarargs; }\n\n  /// Return true if this macro requires processing before expansion.\n  ///\n  /// This is true only for builtin macro, such as \\__LINE__, whose values\n  /// are not given by fixed textual expansions.  Regular predefined macros\n  /// from the \"<built-in>\" buffer are not reported as builtins by this\n  /// function.\n  bool isBuiltinMacro() const { return IsBuiltinMacro; }\n\n  bool hasCommaPasting() const { return HasCommaPasting; }\n  void setHasCommaPasting() { HasCommaPasting = true; }\n\n  /// Return false if this macro is defined in the main file and has\n  /// not yet been used.\n  bool isUsed() const { return IsUsed; }\n\n  /// Return true if this macro can be redefined without warning.\n  bool isAllowRedefinitionsWithoutWarning() const {\n    return IsAllowRedefinitionsWithoutWarning;\n  }\n\n  /// Return true if we should emit a warning if the macro is unused.\n  bool isWarnIfUnused() const { return IsWarnIfUnused; }\n\n  /// Return the number of tokens that this macro expands to.\n  unsigned getNumTokens() const { return ReplacementTokens.size(); }\n\n  const Token &getReplacementToken(unsigned Tok) const {\n    assert(Tok < ReplacementTokens.size() && \"Invalid token #\");\n    return ReplacementTokens[Tok];\n  }\n\n  using tokens_iterator = SmallVectorImpl<Token>::const_iterator;\n\n  tokens_iterator tokens_begin() const { return ReplacementTokens.begin(); }\n  tokens_iterator tokens_end() const { return ReplacementTokens.end(); }\n  bool tokens_empty() const { return ReplacementTokens.empty(); }\n  ArrayRef<Token> tokens() const { return ReplacementTokens; }\n\n  /// Add the specified token to the replacement text for the macro.\n  void AddTokenToBody(const Token &Tok) {\n    assert(\n        !IsDefinitionLengthCached &&\n        \"Changing replacement tokens after definition length got calculated\");\n    ReplacementTokens.push_back(Tok);\n  }\n\n  /// Return true if this macro is enabled.\n  ///\n  /// In other words, that we are not currently in an expansion of this macro.\n  bool isEnabled() const { return !IsDisabled; }\n\n  void EnableMacro() {\n    assert(IsDisabled && \"Cannot enable an already-enabled macro!\");\n    IsDisabled = false;\n  }\n\n  void DisableMacro() {\n    assert(!IsDisabled && \"Cannot disable an already-disabled macro!\");\n    IsDisabled = true;\n  }\n\n  /// Determine whether this macro was used for a header guard.\n  bool isUsedForHeaderGuard() const { return UsedForHeaderGuard; }\n\n  void setUsedForHeaderGuard(bool Val) { UsedForHeaderGuard = Val; }\n\n  void dump() const;\n\nprivate:\n  friend class Preprocessor;\n\n  unsigned getDefinitionLengthSlow(const SourceManager &SM) const;\n};\n\n/// Encapsulates changes to the \"macros namespace\" (the location where\n/// the macro name became active, the location where it was undefined, etc.).\n///\n/// MacroDirectives, associated with an identifier, are used to model the macro\n/// history. Usually a macro definition (MacroInfo) is where a macro name\n/// becomes active (MacroDirective) but #pragma push_macro / pop_macro can\n/// create additional DefMacroDirectives for the same MacroInfo.\nclass MacroDirective {\npublic:\n  enum Kind {\n    MD_Define,\n    MD_Undefine,\n    MD_Visibility\n  };\n\nprotected:\n  /// Previous macro directive for the same identifier, or nullptr.\n  MacroDirective *Previous = nullptr;\n\n  SourceLocation Loc;\n\n  /// MacroDirective kind.\n  unsigned MDKind : 2;\n\n  /// True if the macro directive was loaded from a PCH file.\n  unsigned IsFromPCH : 1;\n\n  // Used by VisibilityMacroDirective ----------------------------------------//\n\n  /// Whether the macro has public visibility (when described in a\n  /// module).\n  unsigned IsPublic : 1;\n\n  MacroDirective(Kind K, SourceLocation Loc)\n      : Loc(Loc), MDKind(K), IsFromPCH(false), IsPublic(true) {}\n\npublic:\n  Kind getKind() const { return Kind(MDKind); }\n\n  SourceLocation getLocation() const { return Loc; }\n\n  /// Set previous definition of the macro with the same name.\n  void setPrevious(MacroDirective *Prev) { Previous = Prev; }\n\n  /// Get previous definition of the macro with the same name.\n  const MacroDirective *getPrevious() const { return Previous; }\n\n  /// Get previous definition of the macro with the same name.\n  MacroDirective *getPrevious() { return Previous; }\n\n  /// Return true if the macro directive was loaded from a PCH file.\n  bool isFromPCH() const { return IsFromPCH; }\n\n  void setIsFromPCH() { IsFromPCH = true; }\n\n  class DefInfo {\n    DefMacroDirective *DefDirective = nullptr;\n    SourceLocation UndefLoc;\n    bool IsPublic = true;\n\n  public:\n    DefInfo() = default;\n    DefInfo(DefMacroDirective *DefDirective, SourceLocation UndefLoc,\n            bool isPublic)\n        : DefDirective(DefDirective), UndefLoc(UndefLoc), IsPublic(isPublic) {}\n\n    const DefMacroDirective *getDirective() const { return DefDirective; }\n    DefMacroDirective *getDirective() { return DefDirective; }\n\n    inline SourceLocation getLocation() const;\n    inline MacroInfo *getMacroInfo();\n\n    const MacroInfo *getMacroInfo() const {\n      return const_cast<DefInfo *>(this)->getMacroInfo();\n    }\n\n    SourceLocation getUndefLocation() const { return UndefLoc; }\n    bool isUndefined() const { return UndefLoc.isValid(); }\n\n    bool isPublic() const { return IsPublic; }\n\n    bool isValid() const { return DefDirective != nullptr; }\n    bool isInvalid() const { return !isValid(); }\n\n    explicit operator bool() const { return isValid(); }\n\n    inline DefInfo getPreviousDefinition();\n\n    const DefInfo getPreviousDefinition() const {\n      return const_cast<DefInfo *>(this)->getPreviousDefinition();\n    }\n  };\n\n  /// Traverses the macro directives history and returns the next\n  /// macro definition directive along with info about its undefined location\n  /// (if there is one) and if it is public or private.\n  DefInfo getDefinition();\n  const DefInfo getDefinition() const {\n    return const_cast<MacroDirective *>(this)->getDefinition();\n  }\n\n  bool isDefined() const {\n    if (const DefInfo Def = getDefinition())\n      return !Def.isUndefined();\n    return false;\n  }\n\n  const MacroInfo *getMacroInfo() const {\n    return getDefinition().getMacroInfo();\n  }\n  MacroInfo *getMacroInfo() { return getDefinition().getMacroInfo(); }\n\n  /// Find macro definition active in the specified source location. If\n  /// this macro was not defined there, return NULL.\n  const DefInfo findDirectiveAtLoc(SourceLocation L,\n                                   const SourceManager &SM) const;\n\n  void dump() const;\n\n  static bool classof(const MacroDirective *) { return true; }\n};\n\n/// A directive for a defined macro or a macro imported from a module.\nclass DefMacroDirective : public MacroDirective {\n  MacroInfo *Info;\n\npublic:\n  DefMacroDirective(MacroInfo *MI, SourceLocation Loc)\n      : MacroDirective(MD_Define, Loc), Info(MI) {\n    assert(MI && \"MacroInfo is null\");\n  }\n  explicit DefMacroDirective(MacroInfo *MI)\n      : DefMacroDirective(MI, MI->getDefinitionLoc()) {}\n\n  /// The data for the macro definition.\n  const MacroInfo *getInfo() const { return Info; }\n  MacroInfo *getInfo() { return Info; }\n\n  static bool classof(const MacroDirective *MD) {\n    return MD->getKind() == MD_Define;\n  }\n\n  static bool classof(const DefMacroDirective *) { return true; }\n};\n\n/// A directive for an undefined macro.\nclass UndefMacroDirective : public MacroDirective {\npublic:\n  explicit UndefMacroDirective(SourceLocation UndefLoc)\n      : MacroDirective(MD_Undefine, UndefLoc) {\n    assert(UndefLoc.isValid() && \"Invalid UndefLoc!\");\n  }\n\n  static bool classof(const MacroDirective *MD) {\n    return MD->getKind() == MD_Undefine;\n  }\n\n  static bool classof(const UndefMacroDirective *) { return true; }\n};\n\n/// A directive for setting the module visibility of a macro.\nclass VisibilityMacroDirective : public MacroDirective {\npublic:\n  explicit VisibilityMacroDirective(SourceLocation Loc, bool Public)\n      : MacroDirective(MD_Visibility, Loc) {\n    IsPublic = Public;\n  }\n\n  /// Determine whether this macro is part of the public API of its\n  /// module.\n  bool isPublic() const { return IsPublic; }\n\n  static bool classof(const MacroDirective *MD) {\n    return MD->getKind() == MD_Visibility;\n  }\n\n  static bool classof(const VisibilityMacroDirective *) { return true; }\n};\n\ninline SourceLocation MacroDirective::DefInfo::getLocation() const {\n  if (isInvalid())\n    return {};\n  return DefDirective->getLocation();\n}\n\ninline MacroInfo *MacroDirective::DefInfo::getMacroInfo() {\n  if (isInvalid())\n    return nullptr;\n  return DefDirective->getInfo();\n}\n\ninline MacroDirective::DefInfo\nMacroDirective::DefInfo::getPreviousDefinition() {\n  if (isInvalid() || DefDirective->getPrevious() == nullptr)\n    return {};\n  return DefDirective->getPrevious()->getDefinition();\n}\n\n/// Represents a macro directive exported by a module.\n///\n/// There's an instance of this class for every macro #define or #undef that is\n/// the final directive for a macro name within a module. These entities also\n/// represent the macro override graph.\n///\n/// These are stored in a FoldingSet in the preprocessor.\nclass ModuleMacro : public llvm::FoldingSetNode {\n  friend class Preprocessor;\n\n  /// The name defined by the macro.\n  IdentifierInfo *II;\n\n  /// The body of the #define, or nullptr if this is a #undef.\n  MacroInfo *Macro;\n\n  /// The module that exports this macro.\n  Module *OwningModule;\n\n  /// The number of module macros that override this one.\n  unsigned NumOverriddenBy = 0;\n\n  /// The number of modules whose macros are directly overridden by this one.\n  unsigned NumOverrides;\n\n  ModuleMacro(Module *OwningModule, IdentifierInfo *II, MacroInfo *Macro,\n              ArrayRef<ModuleMacro *> Overrides)\n      : II(II), Macro(Macro), OwningModule(OwningModule),\n        NumOverrides(Overrides.size()) {\n    std::copy(Overrides.begin(), Overrides.end(),\n              reinterpret_cast<ModuleMacro **>(this + 1));\n  }\n\npublic:\n  static ModuleMacro *create(Preprocessor &PP, Module *OwningModule,\n                             IdentifierInfo *II, MacroInfo *Macro,\n                             ArrayRef<ModuleMacro *> Overrides);\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    return Profile(ID, OwningModule, II);\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, Module *OwningModule,\n                      IdentifierInfo *II) {\n    ID.AddPointer(OwningModule);\n    ID.AddPointer(II);\n  }\n\n  /// Get the name of the macro.\n  IdentifierInfo *getName() const { return II; }\n\n  /// Get the ID of the module that exports this macro.\n  Module *getOwningModule() const { return OwningModule; }\n\n  /// Get definition for this exported #define, or nullptr if this\n  /// represents a #undef.\n  MacroInfo *getMacroInfo() const { return Macro; }\n\n  /// Iterators over the overridden module IDs.\n  /// \\{\n  using overrides_iterator = ModuleMacro *const *;\n\n  overrides_iterator overrides_begin() const {\n    return reinterpret_cast<overrides_iterator>(this + 1);\n  }\n\n  overrides_iterator overrides_end() const {\n    return overrides_begin() + NumOverrides;\n  }\n\n  ArrayRef<ModuleMacro *> overrides() const {\n    return llvm::makeArrayRef(overrides_begin(), overrides_end());\n  }\n  /// \\}\n\n  /// Get the number of macros that override this one.\n  unsigned getNumOverridingMacros() const { return NumOverriddenBy; }\n};\n\n/// A description of the current definition of a macro.\n///\n/// The definition of a macro comprises a set of (at least one) defining\n/// entities, which are either local MacroDirectives or imported ModuleMacros.\nclass MacroDefinition {\n  llvm::PointerIntPair<DefMacroDirective *, 1, bool> LatestLocalAndAmbiguous;\n  ArrayRef<ModuleMacro *> ModuleMacros;\n\npublic:\n  MacroDefinition() = default;\n  MacroDefinition(DefMacroDirective *MD, ArrayRef<ModuleMacro *> MMs,\n                  bool IsAmbiguous)\n      : LatestLocalAndAmbiguous(MD, IsAmbiguous), ModuleMacros(MMs) {}\n\n  /// Determine whether there is a definition of this macro.\n  explicit operator bool() const {\n    return getLocalDirective() || !ModuleMacros.empty();\n  }\n\n  /// Get the MacroInfo that should be used for this definition.\n  MacroInfo *getMacroInfo() const {\n    if (!ModuleMacros.empty())\n      return ModuleMacros.back()->getMacroInfo();\n    if (auto *MD = getLocalDirective())\n      return MD->getMacroInfo();\n    return nullptr;\n  }\n\n  /// \\c true if the definition is ambiguous, \\c false otherwise.\n  bool isAmbiguous() const { return LatestLocalAndAmbiguous.getInt(); }\n\n  /// Get the latest non-imported, non-\\#undef'd macro definition\n  /// for this macro.\n  DefMacroDirective *getLocalDirective() const {\n    return LatestLocalAndAmbiguous.getPointer();\n  }\n\n  /// Get the active module macros for this macro.\n  ArrayRef<ModuleMacro *> getModuleMacros() const { return ModuleMacros; }\n\n  template <typename Fn> void forAllDefinitions(Fn F) const {\n    if (auto *MD = getLocalDirective())\n      F(MD->getMacroInfo());\n    for (auto *MM : getModuleMacros())\n      F(MM->getMacroInfo());\n  }\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_LEX_MACROINFO_H\n"}, "82": {"id": 82, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/ModuleLoader.h", "content": "//===- ModuleLoader.h - Module Loader Interface -----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the ModuleLoader interface, which is responsible for\n//  loading named modules.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LEX_MODULELOADER_H\n#define LLVM_CLANG_LEX_MODULELOADER_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/Module.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <utility>\n\nnamespace clang {\n\nclass GlobalModuleIndex;\nclass IdentifierInfo;\n\n/// A sequence of identifier/location pairs used to describe a particular\n/// module or submodule, e.g., std.vector.\nusing ModuleIdPath = ArrayRef<std::pair<IdentifierInfo *, SourceLocation>>;\n\n/// Describes the result of attempting to load a module.\nclass ModuleLoadResult {\npublic:\n  enum LoadResultKind {\n    // We either succeeded or failed to load the named module.\n    Normal,\n\n    // The module exists, but does not actually contain the named submodule.\n    // This should only happen if the named submodule was inferred from an\n    // umbrella directory, but not actually part of the umbrella header.\n    MissingExpected,\n\n    // The module exists but cannot be imported due to a configuration mismatch.\n    ConfigMismatch,\n\n    // We failed to load the module, but we shouldn't cache the failure.\n    OtherUncachedFailure,\n  };\n  llvm::PointerIntPair<Module *, 2, LoadResultKind> Storage;\n\n  ModuleLoadResult() = default;\n  ModuleLoadResult(Module *M) : Storage(M, Normal) {}\n  ModuleLoadResult(LoadResultKind Kind) : Storage(nullptr, Kind) {}\n\n  operator Module *() const { return Storage.getPointer(); }\n\n  /// Determines whether this is a normal return, whether or not loading the\n  /// module was successful.\n  bool isNormal() const { return Storage.getInt() == Normal; }\n\n  /// Determines whether the module, which failed to load, was\n  /// actually a submodule that we expected to see (based on implying the\n  /// submodule from header structure), but didn't materialize in the actual\n  /// module.\n  bool isMissingExpected() const { return Storage.getInt() == MissingExpected; }\n\n  /// Determines whether the module failed to load due to a configuration\n  /// mismatch with an explicitly-named .pcm file from the command line.\n  bool isConfigMismatch() const { return Storage.getInt() == ConfigMismatch; }\n};\n\n/// Abstract interface for a module loader.\n///\n/// This abstract interface describes a module loader, which is responsible\n/// for resolving a module name (e.g., \"std\") to an actual module file, and\n/// then loading that module.\nclass ModuleLoader {\n  // Building a module if true.\n  bool BuildingModule;\n\npublic:\n  explicit ModuleLoader(bool BuildingModule = false)\n      : BuildingModule(BuildingModule) {}\n\n  virtual ~ModuleLoader();\n\n  /// Returns true if this instance is building a module.\n  bool buildingModule() const {\n    return BuildingModule;\n  }\n\n  /// Flag indicating whether this instance is building a module.\n  void setBuildingModule(bool BuildingModuleFlag) {\n    BuildingModule = BuildingModuleFlag;\n  }\n\n  /// Attempt to load the given module.\n  ///\n  /// This routine attempts to load the module described by the given\n  /// parameters.  If there is a module cache, this may implicitly compile the\n  /// module before loading it.\n  ///\n  /// \\param ImportLoc The location of the 'import' keyword.\n  ///\n  /// \\param Path The identifiers (and their locations) of the module\n  /// \"path\", e.g., \"std.vector\" would be split into \"std\" and \"vector\".\n  ///\n  /// \\param Visibility The visibility provided for the names in the loaded\n  /// module.\n  ///\n  /// \\param IsInclusionDirective Indicates that this module is being loaded\n  /// implicitly, due to the presence of an inclusion directive. Otherwise,\n  /// it is being loaded due to an import declaration.\n  ///\n  /// \\returns If successful, returns the loaded module. Otherwise, returns\n  /// NULL to indicate that the module could not be loaded.\n  virtual ModuleLoadResult loadModule(SourceLocation ImportLoc,\n                                      ModuleIdPath Path,\n                                      Module::NameVisibilityKind Visibility,\n                                      bool IsInclusionDirective) = 0;\n\n  /// Attempt to create the given module from the specified source buffer.\n  /// Does not load the module or make any submodule visible; for that, use\n  /// loadModule and makeModuleVisible.\n  ///\n  /// \\param Loc The location at which to create the module.\n  /// \\param ModuleName The name of the module to create.\n  /// \\param Source The source of the module: a (preprocessed) module map.\n  virtual void createModuleFromSource(SourceLocation Loc, StringRef ModuleName,\n                                      StringRef Source) = 0;\n\n  /// Make the given module visible.\n  virtual void makeModuleVisible(Module *Mod,\n                                 Module::NameVisibilityKind Visibility,\n                                 SourceLocation ImportLoc) = 0;\n\n  /// Load, create, or return global module.\n  /// This function returns an existing global module index, if one\n  /// had already been loaded or created, or loads one if it\n  /// exists, or creates one if it doesn't exist.\n  /// Also, importantly, if the index doesn't cover all the modules\n  /// in the module map, it will be update to do so here, because\n  /// of its use in searching for needed module imports and\n  /// associated fixit messages.\n  /// \\param TriggerLoc The location for what triggered the load.\n  /// \\returns Returns null if load failed.\n  virtual GlobalModuleIndex *loadGlobalModuleIndex(\n                                                SourceLocation TriggerLoc) = 0;\n\n  /// Check global module index for missing imports.\n  /// \\param Name The symbol name to look for.\n  /// \\param TriggerLoc The location for what triggered the load.\n  /// \\returns Returns true if any modules with that symbol found.\n  virtual bool lookupMissingImports(StringRef Name,\n                                    SourceLocation TriggerLoc) = 0;\n\n  bool HadFatalFailure = false;\n};\n\n/// A module loader that doesn't know how to create or load modules.\nclass TrivialModuleLoader : public ModuleLoader {\npublic:\n  ModuleLoadResult loadModule(SourceLocation ImportLoc, ModuleIdPath Path,\n                              Module::NameVisibilityKind Visibility,\n                              bool IsInclusionDirective) override {\n    return {};\n  }\n\n  void createModuleFromSource(SourceLocation ImportLoc, StringRef ModuleName,\n                              StringRef Source) override {}\n\n  void makeModuleVisible(Module *Mod, Module::NameVisibilityKind Visibility,\n                         SourceLocation ImportLoc) override {}\n\n  GlobalModuleIndex *loadGlobalModuleIndex(SourceLocation TriggerLoc) override {\n    return nullptr;\n  }\n\n  bool lookupMissingImports(StringRef Name,\n                            SourceLocation TriggerLoc) override {\n    return false;\n  }\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_LEX_MODULELOADER_H\n"}, "83": {"id": 83, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/ModuleMap.h", "content": "//===- ModuleMap.h - Describe the layout of modules -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the ModuleMap interface, which describes the layout of a\n// module as it relates to headers.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LEX_MODULEMAP_H\n#define LLVM_CLANG_LEX_MODULEMAP_H\n\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/Module.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/StringSet.h\"\n#include \"llvm/ADT/TinyPtrVector.h\"\n#include \"llvm/ADT/Twine.h\"\n#include <ctime>\n#include <memory>\n#include <string>\n#include <utility>\n\nnamespace clang {\n\nclass DiagnosticsEngine;\nclass DirectoryEntry;\nclass FileEntry;\nclass FileManager;\nclass HeaderSearch;\nclass SourceManager;\n\n/// A mechanism to observe the actions of the module map parser as it\n/// reads module map files.\nclass ModuleMapCallbacks {\n  virtual void anchor();\n\npublic:\n  virtual ~ModuleMapCallbacks() = default;\n\n  /// Called when a module map file has been read.\n  ///\n  /// \\param FileStart A SourceLocation referring to the start of the file's\n  /// contents.\n  /// \\param File The file itself.\n  /// \\param IsSystem Whether this is a module map from a system include path.\n  virtual void moduleMapFileRead(SourceLocation FileStart,\n                                 const FileEntry &File, bool IsSystem) {}\n\n  /// Called when a header is added during module map parsing.\n  ///\n  /// \\param Filename The header file itself.\n  virtual void moduleMapAddHeader(StringRef Filename) {}\n\n  /// Called when an umbrella header is added during module map parsing.\n  ///\n  /// \\param FileMgr FileManager instance\n  /// \\param Header The umbrella header to collect.\n  virtual void moduleMapAddUmbrellaHeader(FileManager *FileMgr,\n                                          const FileEntry *Header) {}\n};\n\nclass ModuleMap {\n  SourceManager &SourceMgr;\n  DiagnosticsEngine &Diags;\n  const LangOptions &LangOpts;\n  const TargetInfo *Target;\n  HeaderSearch &HeaderInfo;\n\n  llvm::SmallVector<std::unique_ptr<ModuleMapCallbacks>, 1> Callbacks;\n\n  /// The directory used for Clang-supplied, builtin include headers,\n  /// such as \"stdint.h\".\n  const DirectoryEntry *BuiltinIncludeDir = nullptr;\n\n  /// Language options used to parse the module map itself.\n  ///\n  /// These are always simple C language options.\n  LangOptions MMapLangOpts;\n\n  /// The module that the main source file is associated with (the module\n  /// named LangOpts::CurrentModule, if we've loaded it).\n  Module *SourceModule = nullptr;\n\n  /// Submodules of the current module that have not yet been attached to it.\n  /// (Ownership is transferred if/when we create an enclosing module.)\n  llvm::SmallVector<std::unique_ptr<Module>, 8> PendingSubmodules;\n\n  /// The top-level modules that are known.\n  llvm::StringMap<Module *> Modules;\n\n  /// Module loading cache that includes submodules, indexed by IdentifierInfo.\n  /// nullptr is stored for modules that are known to fail to load.\n  llvm::DenseMap<const IdentifierInfo *, Module *> CachedModuleLoads;\n\n  /// Shadow modules created while building this module map.\n  llvm::SmallVector<Module*, 2> ShadowModules;\n\n  /// The number of modules we have created in total.\n  unsigned NumCreatedModules = 0;\n\n  /// In case a module has a export_as entry, it might have a pending link\n  /// name to be determined if that module is imported.\n  llvm::StringMap<llvm::StringSet<>> PendingLinkAsModule;\n\npublic:\n  /// Use PendingLinkAsModule information to mark top level link names that\n  /// are going to be replaced by export_as aliases.\n  void resolveLinkAsDependencies(Module *Mod);\n\n  /// Make module to use export_as as the link dependency name if enough\n  /// information is available or add it to a pending list otherwise.\n  void addLinkAsDependency(Module *Mod);\n\n  /// Flags describing the role of a module header.\n  enum ModuleHeaderRole {\n    /// This header is normally included in the module.\n    NormalHeader  = 0x0,\n\n    /// This header is included but private.\n    PrivateHeader = 0x1,\n\n    /// This header is part of the module (for layering purposes) but\n    /// should be textually included.\n    TextualHeader = 0x2,\n\n    // Caution: Adding an enumerator needs other changes.\n    // Adjust the number of bits for KnownHeader::Storage.\n    // Adjust the bitfield HeaderFileInfo::HeaderRole size.\n    // Adjust the HeaderFileInfoTrait::ReadData streaming.\n    // Adjust the HeaderFileInfoTrait::EmitData streaming.\n    // Adjust ModuleMap::addHeader.\n  };\n\n  /// Convert a header kind to a role. Requires Kind to not be HK_Excluded.\n  static ModuleHeaderRole headerKindToRole(Module::HeaderKind Kind);\n\n  /// Convert a header role to a kind.\n  static Module::HeaderKind headerRoleToKind(ModuleHeaderRole Role);\n\n  /// A header that is known to reside within a given module,\n  /// whether it was included or excluded.\n  class KnownHeader {\n    llvm::PointerIntPair<Module *, 2, ModuleHeaderRole> Storage;\n\n  public:\n    KnownHeader() : Storage(nullptr, NormalHeader) {}\n    KnownHeader(Module *M, ModuleHeaderRole Role) : Storage(M, Role) {}\n\n    friend bool operator==(const KnownHeader &A, const KnownHeader &B) {\n      return A.Storage == B.Storage;\n    }\n    friend bool operator!=(const KnownHeader &A, const KnownHeader &B) {\n      return A.Storage != B.Storage;\n    }\n\n    /// Retrieve the module the header is stored in.\n    Module *getModule() const { return Storage.getPointer(); }\n\n    /// The role of this header within the module.\n    ModuleHeaderRole getRole() const { return Storage.getInt(); }\n\n    /// Whether this header is available in the module.\n    bool isAvailable() const {\n      return getModule()->isAvailable();\n    }\n\n    /// Whether this header is accessible from the specified module.\n    bool isAccessibleFrom(Module *M) const {\n      return !(getRole() & PrivateHeader) ||\n             (M && M->getTopLevelModule() == getModule()->getTopLevelModule());\n    }\n\n    // Whether this known header is valid (i.e., it has an\n    // associated module).\n    explicit operator bool() const {\n      return Storage.getPointer() != nullptr;\n    }\n  };\n\n  using AdditionalModMapsSet = llvm::SmallPtrSet<const FileEntry *, 1>;\n\nprivate:\n  friend class ModuleMapParser;\n\n  using HeadersMap =\n      llvm::DenseMap<const FileEntry *, SmallVector<KnownHeader, 1>>;\n\n  /// Mapping from each header to the module that owns the contents of\n  /// that header.\n  HeadersMap Headers;\n\n  /// Map from file sizes to modules with lazy header directives of that size.\n  mutable llvm::DenseMap<off_t, llvm::TinyPtrVector<Module*>> LazyHeadersBySize;\n\n  /// Map from mtimes to modules with lazy header directives with those mtimes.\n  mutable llvm::DenseMap<time_t, llvm::TinyPtrVector<Module*>>\n              LazyHeadersByModTime;\n\n  /// Mapping from directories with umbrella headers to the module\n  /// that is generated from the umbrella header.\n  ///\n  /// This mapping is used to map headers that haven't explicitly been named\n  /// in the module map over to the module that includes them via its umbrella\n  /// header.\n  llvm::DenseMap<const DirectoryEntry *, Module *> UmbrellaDirs;\n\n  /// A generation counter that is used to test whether modules of the\n  /// same name may shadow or are illegal redefinitions.\n  ///\n  /// Modules from earlier scopes may shadow modules from later ones.\n  /// Modules from the same scope may not have the same name.\n  unsigned CurrentModuleScopeID = 0;\n\n  llvm::DenseMap<Module *, unsigned> ModuleScopeIDs;\n\n  /// The set of attributes that can be attached to a module.\n  struct Attributes {\n    /// Whether this is a system module.\n    unsigned IsSystem : 1;\n\n    /// Whether this is an extern \"C\" module.\n    unsigned IsExternC : 1;\n\n    /// Whether this is an exhaustive set of configuration macros.\n    unsigned IsExhaustive : 1;\n\n    /// Whether files in this module can only include non-modular headers\n    /// and headers from used modules.\n    unsigned NoUndeclaredIncludes : 1;\n\n    Attributes()\n        : IsSystem(false), IsExternC(false), IsExhaustive(false),\n          NoUndeclaredIncludes(false) {}\n  };\n\n  /// A directory for which framework modules can be inferred.\n  struct InferredDirectory {\n    /// Whether to infer modules from this directory.\n    unsigned InferModules : 1;\n\n    /// The attributes to use for inferred modules.\n    Attributes Attrs;\n\n    /// If \\c InferModules is non-zero, the module map file that allowed\n    /// inferred modules.  Otherwise, nullptr.\n    const FileEntry *ModuleMapFile;\n\n    /// The names of modules that cannot be inferred within this\n    /// directory.\n    SmallVector<std::string, 2> ExcludedModules;\n\n    InferredDirectory() : InferModules(false) {}\n  };\n\n  /// A mapping from directories to information about inferring\n  /// framework modules from within those directories.\n  llvm::DenseMap<const DirectoryEntry *, InferredDirectory> InferredDirectories;\n\n  /// A mapping from an inferred module to the module map that allowed the\n  /// inference.\n  llvm::DenseMap<const Module *, const FileEntry *> InferredModuleAllowedBy;\n\n  llvm::DenseMap<const Module *, AdditionalModMapsSet> AdditionalModMaps;\n\n  /// Describes whether we haved parsed a particular file as a module\n  /// map.\n  llvm::DenseMap<const FileEntry *, bool> ParsedModuleMap;\n\n  /// Resolve the given export declaration into an actual export\n  /// declaration.\n  ///\n  /// \\param Mod The module in which we're resolving the export declaration.\n  ///\n  /// \\param Unresolved The export declaration to resolve.\n  ///\n  /// \\param Complain Whether this routine should complain about unresolvable\n  /// exports.\n  ///\n  /// \\returns The resolved export declaration, which will have a NULL pointer\n  /// if the export could not be resolved.\n  Module::ExportDecl\n  resolveExport(Module *Mod, const Module::UnresolvedExportDecl &Unresolved,\n                bool Complain) const;\n\n  /// Resolve the given module id to an actual module.\n  ///\n  /// \\param Id The module-id to resolve.\n  ///\n  /// \\param Mod The module in which we're resolving the module-id.\n  ///\n  /// \\param Complain Whether this routine should complain about unresolvable\n  /// module-ids.\n  ///\n  /// \\returns The resolved module, or null if the module-id could not be\n  /// resolved.\n  Module *resolveModuleId(const ModuleId &Id, Module *Mod, bool Complain) const;\n\n  /// Add an unresolved header to a module.\n  ///\n  /// \\param Mod The module in which we're adding the unresolved header\n  ///        directive.\n  /// \\param Header The unresolved header directive.\n  /// \\param NeedsFramework If Mod is not a framework but a missing header would\n  ///        be found in case Mod was, set it to true. False otherwise.\n  void addUnresolvedHeader(Module *Mod,\n                           Module::UnresolvedHeaderDirective Header,\n                           bool &NeedsFramework);\n\n  /// Look up the given header directive to find an actual header file.\n  ///\n  /// \\param M The module in which we're resolving the header directive.\n  /// \\param Header The header directive to resolve.\n  /// \\param RelativePathName Filled in with the relative path name from the\n  ///        module to the resolved header.\n  /// \\param NeedsFramework If M is not a framework but a missing header would\n  ///        be found in case M was, set it to true. False otherwise.\n  /// \\return The resolved file, if any.\n  Optional<FileEntryRef>\n  findHeader(Module *M, const Module::UnresolvedHeaderDirective &Header,\n             SmallVectorImpl<char> &RelativePathName, bool &NeedsFramework);\n\n  /// Resolve the given header directive.\n  ///\n  /// \\param M The module in which we're resolving the header directive.\n  /// \\param Header The header directive to resolve.\n  /// \\param NeedsFramework If M is not a framework but a missing header would\n  ///        be found in case M was, set it to true. False otherwise.\n  void resolveHeader(Module *M, const Module::UnresolvedHeaderDirective &Header,\n                     bool &NeedsFramework);\n\n  /// Attempt to resolve the specified header directive as naming a builtin\n  /// header.\n  /// \\return \\c true if a corresponding builtin header was found.\n  bool resolveAsBuiltinHeader(Module *M,\n                              const Module::UnresolvedHeaderDirective &Header);\n\n  /// Looks up the modules that \\p File corresponds to.\n  ///\n  /// If \\p File represents a builtin header within Clang's builtin include\n  /// directory, this also loads all of the module maps to see if it will get\n  /// associated with a specific module (e.g. in /usr/include).\n  HeadersMap::iterator findKnownHeader(const FileEntry *File);\n\n  /// Searches for a module whose umbrella directory contains \\p File.\n  ///\n  /// \\param File The header to search for.\n  ///\n  /// \\param IntermediateDirs On success, contains the set of directories\n  /// searched before finding \\p File.\n  KnownHeader findHeaderInUmbrellaDirs(const FileEntry *File,\n                    SmallVectorImpl<const DirectoryEntry *> &IntermediateDirs);\n\n  /// Given that \\p File is not in the Headers map, look it up within\n  /// umbrella directories and find or create a module for it.\n  KnownHeader findOrCreateModuleForHeaderInUmbrellaDir(const FileEntry *File);\n\n  /// A convenience method to determine if \\p File is (possibly nested)\n  /// in an umbrella directory.\n  bool isHeaderInUmbrellaDirs(const FileEntry *File) {\n    SmallVector<const DirectoryEntry *, 2> IntermediateDirs;\n    return static_cast<bool>(findHeaderInUmbrellaDirs(File, IntermediateDirs));\n  }\n\n  Module *inferFrameworkModule(const DirectoryEntry *FrameworkDir,\n                               Attributes Attrs, Module *Parent);\n\npublic:\n  /// Construct a new module map.\n  ///\n  /// \\param SourceMgr The source manager used to find module files and headers.\n  /// This source manager should be shared with the header-search mechanism,\n  /// since they will refer to the same headers.\n  ///\n  /// \\param Diags A diagnostic engine used for diagnostics.\n  ///\n  /// \\param LangOpts Language options for this translation unit.\n  ///\n  /// \\param Target The target for this translation unit.\n  ModuleMap(SourceManager &SourceMgr, DiagnosticsEngine &Diags,\n            const LangOptions &LangOpts, const TargetInfo *Target,\n            HeaderSearch &HeaderInfo);\n\n  /// Destroy the module map.\n  ~ModuleMap();\n\n  /// Set the target information.\n  void setTarget(const TargetInfo &Target);\n\n  /// Set the directory that contains Clang-supplied include\n  /// files, such as our stdarg.h or tgmath.h.\n  void setBuiltinIncludeDir(const DirectoryEntry *Dir) {\n    BuiltinIncludeDir = Dir;\n  }\n\n  /// Get the directory that contains Clang-supplied include files.\n  const DirectoryEntry *getBuiltinDir() const {\n    return BuiltinIncludeDir;\n  }\n\n  /// Is this a compiler builtin header?\n  static bool isBuiltinHeader(StringRef FileName);\n  bool isBuiltinHeader(const FileEntry *File);\n\n  /// Add a module map callback.\n  void addModuleMapCallbacks(std::unique_ptr<ModuleMapCallbacks> Callback) {\n    Callbacks.push_back(std::move(Callback));\n  }\n\n  /// Retrieve the module that owns the given header file, if any. Note that\n  /// this does not implicitly load module maps, except for builtin headers,\n  /// and does not consult the external source. (Those checks are the\n  /// responsibility of \\ref HeaderSearch.)\n  ///\n  /// \\param File The header file that is likely to be included.\n  ///\n  /// \\param AllowTextual If \\c true and \\p File is a textual header, return\n  /// its owning module. Otherwise, no KnownHeader will be returned if the\n  /// file is only known as a textual header.\n  ///\n  /// \\returns The module KnownHeader, which provides the module that owns the\n  /// given header file.  The KnownHeader is default constructed to indicate\n  /// that no module owns this header file.\n  KnownHeader findModuleForHeader(const FileEntry *File,\n                                  bool AllowTextual = false);\n\n  /// Retrieve all the modules that contain the given header file. Note that\n  /// this does not implicitly load module maps, except for builtin headers,\n  /// and does not consult the external source. (Those checks are the\n  /// responsibility of \\ref HeaderSearch.)\n  ///\n  /// Typically, \\ref findModuleForHeader should be used instead, as it picks\n  /// the preferred module for the header.\n  ArrayRef<KnownHeader> findAllModulesForHeader(const FileEntry *File);\n\n  /// Like \\ref findAllModulesForHeader, but do not attempt to infer module\n  /// ownership from umbrella headers if we've not already done so.\n  ArrayRef<KnownHeader>\n  findResolvedModulesForHeader(const FileEntry *File) const;\n\n  /// Resolve all lazy header directives for the specified file.\n  ///\n  /// This ensures that the HeaderFileInfo on HeaderSearch is up to date. This\n  /// is effectively internal, but is exposed so HeaderSearch can call it.\n  void resolveHeaderDirectives(const FileEntry *File) const;\n\n  /// Resolve all lazy header directives for the specified module.\n  void resolveHeaderDirectives(Module *Mod) const;\n\n  /// Reports errors if a module must not include a specific file.\n  ///\n  /// \\param RequestingModule The module including a file.\n  ///\n  /// \\param RequestingModuleIsModuleInterface \\c true if the inclusion is in\n  ///        the interface of RequestingModule, \\c false if it's in the\n  ///        implementation of RequestingModule. Value is ignored and\n  ///        meaningless if RequestingModule is nullptr.\n  ///\n  /// \\param FilenameLoc The location of the inclusion's filename.\n  ///\n  /// \\param Filename The included filename as written.\n  ///\n  /// \\param File The included file.\n  void diagnoseHeaderInclusion(Module *RequestingModule,\n                               bool RequestingModuleIsModuleInterface,\n                               SourceLocation FilenameLoc, StringRef Filename,\n                               const FileEntry *File);\n\n  /// Determine whether the given header is part of a module\n  /// marked 'unavailable'.\n  bool isHeaderInUnavailableModule(const FileEntry *Header) const;\n\n  /// Determine whether the given header is unavailable as part\n  /// of the specified module.\n  bool isHeaderUnavailableInModule(const FileEntry *Header,\n                                   const Module *RequestingModule) const;\n\n  /// Retrieve a module with the given name.\n  ///\n  /// \\param Name The name of the module to look up.\n  ///\n  /// \\returns The named module, if known; otherwise, returns null.\n  Module *findModule(StringRef Name) const;\n\n  /// Retrieve a module with the given name using lexical name lookup,\n  /// starting at the given context.\n  ///\n  /// \\param Name The name of the module to look up.\n  ///\n  /// \\param Context The module context, from which we will perform lexical\n  /// name lookup.\n  ///\n  /// \\returns The named module, if known; otherwise, returns null.\n  Module *lookupModuleUnqualified(StringRef Name, Module *Context) const;\n\n  /// Retrieve a module with the given name within the given context,\n  /// using direct (qualified) name lookup.\n  ///\n  /// \\param Name The name of the module to look up.\n  ///\n  /// \\param Context The module for which we will look for a submodule. If\n  /// null, we will look for a top-level module.\n  ///\n  /// \\returns The named submodule, if known; otherwose, returns null.\n  Module *lookupModuleQualified(StringRef Name, Module *Context) const;\n\n  /// Find a new module or submodule, or create it if it does not already\n  /// exist.\n  ///\n  /// \\param Name The name of the module to find or create.\n  ///\n  /// \\param Parent The module that will act as the parent of this submodule,\n  /// or nullptr to indicate that this is a top-level module.\n  ///\n  /// \\param IsFramework Whether this is a framework module.\n  ///\n  /// \\param IsExplicit Whether this is an explicit submodule.\n  ///\n  /// \\returns The found or newly-created module, along with a boolean value\n  /// that will be true if the module is newly-created.\n  std::pair<Module *, bool> findOrCreateModule(StringRef Name, Module *Parent,\n                                               bool IsFramework,\n                                               bool IsExplicit);\n\n  /// Create a global module fragment for a C++ module unit.\n  ///\n  /// We model the global module fragment as a submodule of the module\n  /// interface unit. Unfortunately, we can't create the module interface\n  /// unit's Module until later, because we don't know what it will be called.\n  Module *createGlobalModuleFragmentForModuleUnit(SourceLocation Loc);\n\n  /// Create a global module fragment for a C++ module interface unit.\n  Module *createPrivateModuleFragmentForInterfaceUnit(Module *Parent,\n                                                      SourceLocation Loc);\n\n  /// Create a new module for a C++ module interface unit.\n  /// The module must not already exist, and will be configured for the current\n  /// compilation.\n  ///\n  /// Note that this also sets the current module to the newly-created module.\n  ///\n  /// \\returns The newly-created module.\n  Module *createModuleForInterfaceUnit(SourceLocation Loc, StringRef Name,\n                                       Module *GlobalModule);\n\n  /// Create a header module from the specified list of headers.\n  Module *createHeaderModule(StringRef Name, ArrayRef<Module::Header> Headers);\n\n  /// Infer the contents of a framework module map from the given\n  /// framework directory.\n  Module *inferFrameworkModule(const DirectoryEntry *FrameworkDir,\n                               bool IsSystem, Module *Parent);\n\n  /// Create a new top-level module that is shadowed by\n  /// \\p ShadowingModule.\n  Module *createShadowedModule(StringRef Name, bool IsFramework,\n                               Module *ShadowingModule);\n\n  /// Creates a new declaration scope for module names, allowing\n  /// previously defined modules to shadow definitions from the new scope.\n  ///\n  /// \\note Module names from earlier scopes will shadow names from the new\n  /// scope, which is the opposite of how shadowing works for variables.\n  void finishModuleDeclarationScope() { CurrentModuleScopeID += 1; }\n\n  bool mayShadowNewModule(Module *ExistingModule) {\n    assert(!ExistingModule->Parent && \"expected top-level module\");\n    assert(ModuleScopeIDs.count(ExistingModule) && \"unknown module\");\n    return ModuleScopeIDs[ExistingModule] < CurrentModuleScopeID;\n  }\n\n  /// Retrieve the module map file containing the definition of the given\n  /// module.\n  ///\n  /// \\param Module The module whose module map file will be returned, if known.\n  ///\n  /// \\returns The file entry for the module map file containing the given\n  /// module, or nullptr if the module definition was inferred.\n  const FileEntry *getContainingModuleMapFile(const Module *Module) const;\n\n  /// Get the module map file that (along with the module name) uniquely\n  /// identifies this module.\n  ///\n  /// The particular module that \\c Name refers to may depend on how the module\n  /// was found in header search. However, the combination of \\c Name and\n  /// this module map will be globally unique for top-level modules. In the case\n  /// of inferred modules, returns the module map that allowed the inference\n  /// (e.g. contained 'module *'). Otherwise, returns\n  /// getContainingModuleMapFile().\n  const FileEntry *getModuleMapFileForUniquing(const Module *M) const;\n\n  void setInferredModuleAllowedBy(Module *M, const FileEntry *ModMap);\n\n  /// Get any module map files other than getModuleMapFileForUniquing(M)\n  /// that define submodules of a top-level module \\p M. This is cheaper than\n  /// getting the module map file for each submodule individually, since the\n  /// expected number of results is very small.\n  AdditionalModMapsSet *getAdditionalModuleMapFiles(const Module *M) {\n    auto I = AdditionalModMaps.find(M);\n    if (I == AdditionalModMaps.end())\n      return nullptr;\n    return &I->second;\n  }\n\n  void addAdditionalModuleMapFile(const Module *M, const FileEntry *ModuleMap);\n\n  /// Resolve all of the unresolved exports in the given module.\n  ///\n  /// \\param Mod The module whose exports should be resolved.\n  ///\n  /// \\param Complain Whether to emit diagnostics for failures.\n  ///\n  /// \\returns true if any errors were encountered while resolving exports,\n  /// false otherwise.\n  bool resolveExports(Module *Mod, bool Complain);\n\n  /// Resolve all of the unresolved uses in the given module.\n  ///\n  /// \\param Mod The module whose uses should be resolved.\n  ///\n  /// \\param Complain Whether to emit diagnostics for failures.\n  ///\n  /// \\returns true if any errors were encountered while resolving uses,\n  /// false otherwise.\n  bool resolveUses(Module *Mod, bool Complain);\n\n  /// Resolve all of the unresolved conflicts in the given module.\n  ///\n  /// \\param Mod The module whose conflicts should be resolved.\n  ///\n  /// \\param Complain Whether to emit diagnostics for failures.\n  ///\n  /// \\returns true if any errors were encountered while resolving conflicts,\n  /// false otherwise.\n  bool resolveConflicts(Module *Mod, bool Complain);\n\n  /// Sets the umbrella header of the given module to the given\n  /// header.\n  void setUmbrellaHeader(Module *Mod, const FileEntry *UmbrellaHeader,\n                         Twine NameAsWritten);\n\n  /// Sets the umbrella directory of the given module to the given\n  /// directory.\n  void setUmbrellaDir(Module *Mod, const DirectoryEntry *UmbrellaDir,\n                      Twine NameAsWritten);\n\n  /// Adds this header to the given module.\n  /// \\param Role The role of the header wrt the module.\n  void addHeader(Module *Mod, Module::Header Header,\n                 ModuleHeaderRole Role, bool Imported = false);\n\n  /// Marks this header as being excluded from the given module.\n  void excludeHeader(Module *Mod, Module::Header Header);\n\n  /// Parse the given module map file, and record any modules we\n  /// encounter.\n  ///\n  /// \\param File The file to be parsed.\n  ///\n  /// \\param IsSystem Whether this module map file is in a system header\n  /// directory, and therefore should be considered a system module.\n  ///\n  /// \\param HomeDir The directory in which relative paths within this module\n  ///        map file will be resolved.\n  ///\n  /// \\param ID The FileID of the file to process, if we've already entered it.\n  ///\n  /// \\param Offset [inout] On input the offset at which to start parsing. On\n  ///        output, the offset at which the module map terminated.\n  ///\n  /// \\param ExternModuleLoc The location of the \"extern module\" declaration\n  ///        that caused us to load this module map file, if any.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool parseModuleMapFile(const FileEntry *File, bool IsSystem,\n                          const DirectoryEntry *HomeDir,\n                          FileID ID = FileID(), unsigned *Offset = nullptr,\n                          SourceLocation ExternModuleLoc = SourceLocation());\n\n  /// Dump the contents of the module map, for debugging purposes.\n  void dump();\n\n  using module_iterator = llvm::StringMap<Module *>::const_iterator;\n\n  module_iterator module_begin() const { return Modules.begin(); }\n  module_iterator module_end()   const { return Modules.end(); }\n\n  /// Cache a module load.  M might be nullptr.\n  void cacheModuleLoad(const IdentifierInfo &II, Module *M) {\n    CachedModuleLoads[&II] = M;\n  }\n\n  /// Return a cached module load.\n  llvm::Optional<Module *> getCachedModuleLoad(const IdentifierInfo &II) {\n    auto I = CachedModuleLoads.find(&II);\n    if (I == CachedModuleLoads.end())\n      return None;\n    return I->second;\n  }\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_LEX_MODULEMAP_H\n"}, "84": {"id": 84, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/MultipleIncludeOpt.h", "content": "//===--- MultipleIncludeOpt.h - Header Multiple-Include Optzn ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Defines the MultipleIncludeOpt interface.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LEX_MULTIPLEINCLUDEOPT_H\n#define LLVM_CLANG_LEX_MULTIPLEINCLUDEOPT_H\n\n#include \"clang/Basic/SourceLocation.h\"\n\nnamespace clang {\nclass IdentifierInfo;\n\n/// Implements the simple state machine that the Lexer class uses to\n/// detect files subject to the 'multiple-include' optimization.\n///\n/// The public methods in this class are triggered by various\n/// events that occur when a file is lexed, and after the entire file is lexed,\n/// information about which macro (if any) controls the header is returned.\nclass MultipleIncludeOpt {\n  /// ReadAnyTokens - This is set to false when a file is first opened and true\n  /// any time a token is returned to the client or a (non-multiple-include)\n  /// directive is parsed.  When the final \\#endif is parsed this is reset back\n  /// to false, that way any tokens before the first \\#ifdef or after the last\n  /// \\#endif can be easily detected.\n  bool ReadAnyTokens;\n\n  /// ImmediatelyAfterTopLevelIfndef - This is true when the only tokens\n  /// processed in the file so far is an #ifndef and an identifier.  Used in\n  /// the detection of header guards in a file.\n  bool ImmediatelyAfterTopLevelIfndef;\n\n  /// ReadAnyTokens - This is set to false when a file is first opened and true\n  /// any time a token is returned to the client or a (non-multiple-include)\n  /// directive is parsed.  When the final #endif is parsed this is reset back\n  /// to false, that way any tokens before the first #ifdef or after the last\n  /// #endif can be easily detected.\n  bool DidMacroExpansion;\n\n  /// TheMacro - The controlling macro for a file, if valid.\n  ///\n  const IdentifierInfo *TheMacro;\n\n  /// DefinedMacro - The macro defined right after TheMacro, if any.\n  const IdentifierInfo *DefinedMacro;\n\n  SourceLocation MacroLoc;\n  SourceLocation DefinedLoc;\npublic:\n  MultipleIncludeOpt() {\n    ReadAnyTokens = false;\n    ImmediatelyAfterTopLevelIfndef = false;\n    DidMacroExpansion = false;\n    TheMacro = nullptr;\n    DefinedMacro = nullptr;\n  }\n\n  SourceLocation GetMacroLocation() const {\n    return MacroLoc;\n  }\n\n  SourceLocation GetDefinedLocation() const {\n    return DefinedLoc;\n  }\n\n  void resetImmediatelyAfterTopLevelIfndef() {\n    ImmediatelyAfterTopLevelIfndef = false;\n  }\n\n  void SetDefinedMacro(IdentifierInfo *M, SourceLocation Loc) {\n    DefinedMacro = M;\n    DefinedLoc = Loc;\n  }\n\n  /// Invalidate - Permanently mark this file as not being suitable for the\n  /// include-file optimization.\n  void Invalidate() {\n    // If we have read tokens but have no controlling macro, the state-machine\n    // below can never \"accept\".\n    ReadAnyTokens = true;\n    ImmediatelyAfterTopLevelIfndef = false;\n    DefinedMacro = nullptr;\n    TheMacro = nullptr;\n  }\n\n  /// getHasReadAnyTokensVal - This is used for the \\#ifndef handshake at the\n  /// top of the file when reading preprocessor directives.  Otherwise, reading\n  /// the \"ifndef x\" would count as reading tokens.\n  bool getHasReadAnyTokensVal() const { return ReadAnyTokens; }\n\n  /// getImmediatelyAfterTopLevelIfndef - returns true if the last directive\n  /// was an #ifndef at the beginning of the file.\n  bool getImmediatelyAfterTopLevelIfndef() const {\n    return ImmediatelyAfterTopLevelIfndef;\n  }\n\n  // If a token is read, remember that we have seen a side-effect in this file.\n  void ReadToken() {\n    ReadAnyTokens = true;\n    ImmediatelyAfterTopLevelIfndef = false;\n  }\n\n  /// ExpandedMacro - When a macro is expanded with this lexer as the current\n  /// buffer, this method is called to disable the MIOpt if needed.\n  void ExpandedMacro() { DidMacroExpansion = true; }\n\n  /// Called when entering a top-level \\#ifndef directive (or the\n  /// \"\\#if !defined\" equivalent) without any preceding tokens.\n  ///\n  /// Note, we don't care about the input value of 'ReadAnyTokens'.  The caller\n  /// ensures that this is only called if there are no tokens read before the\n  /// \\#ifndef.  The caller is required to do this, because reading the \\#if\n  /// line obviously reads in tokens.\n  void EnterTopLevelIfndef(const IdentifierInfo *M, SourceLocation Loc) {\n    // If the macro is already set, this is after the top-level #endif.\n    if (TheMacro)\n      return Invalidate();\n\n    // If we have already expanded a macro by the end of the #ifndef line, then\n    // there is a macro expansion *in* the #ifndef line.  This means that the\n    // condition could evaluate differently when subsequently #included.  Reject\n    // this.\n    if (DidMacroExpansion)\n      return Invalidate();\n\n    // Remember that we're in the #if and that we have the macro.\n    ReadAnyTokens = true;\n    ImmediatelyAfterTopLevelIfndef = true;\n    TheMacro = M;\n    MacroLoc = Loc;\n  }\n\n  /// Invoked when a top level conditional (except \\#ifndef) is found.\n  void EnterTopLevelConditional() {\n    // If a conditional directive (except #ifndef) is found at the top level,\n    // there is a chunk of the file not guarded by the controlling macro.\n    Invalidate();\n  }\n\n  /// Called when the lexer exits the top-level conditional.\n  void ExitTopLevelConditional() {\n    // If we have a macro, that means the top of the file was ok.  Set our state\n    // back to \"not having read any tokens\" so we can detect anything after the\n    // #endif.\n    if (!TheMacro) return Invalidate();\n\n    // At this point, we haven't \"read any tokens\" but we do have a controlling\n    // macro.\n    ReadAnyTokens = false;\n    ImmediatelyAfterTopLevelIfndef = false;\n  }\n\n  /// Once the entire file has been lexed, if there is a controlling\n  /// macro, return it.\n  const IdentifierInfo *GetControllingMacroAtEndOfFile() const {\n    // If we haven't read any tokens after the #endif, return the controlling\n    // macro if it's valid (if it isn't, it will be null).\n    if (!ReadAnyTokens)\n      return TheMacro;\n    return nullptr;\n  }\n\n  /// If the ControllingMacro is followed by a macro definition, return\n  /// the macro that was defined.\n  const IdentifierInfo *GetDefinedMacro() const {\n    return DefinedMacro;\n  }\n};\n\n}  // end namespace clang\n\n#endif\n"}, "85": {"id": 85, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/Pragma.h", "content": "//===- Pragma.h - Pragma registration and handling --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the PragmaHandler and PragmaTable interfaces.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LEX_PRAGMA_H\n#define LLVM_CLANG_LEX_PRAGMA_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <string>\n\nnamespace clang {\n\nclass PragmaNamespace;\nclass Preprocessor;\nclass Token;\n\n  /**\n   * Describes how the pragma was introduced, e.g., with \\#pragma,\n   * _Pragma, or __pragma.\n   */\n  enum PragmaIntroducerKind {\n    /**\n     * The pragma was introduced via \\#pragma.\n     */\n    PIK_HashPragma,\n\n    /**\n     * The pragma was introduced via the C99 _Pragma(string-literal).\n     */\n    PIK__Pragma,\n\n    /**\n     * The pragma was introduced via the Microsoft\n     * __pragma(token-string).\n     */\n    PIK___pragma\n  };\n\n  /// Describes how and where the pragma was introduced.\n  struct PragmaIntroducer {\n    PragmaIntroducerKind Kind;\n    SourceLocation Loc;\n  };\n\n/// PragmaHandler - Instances of this interface defined to handle the various\n/// pragmas that the language front-end uses.  Each handler optionally has a\n/// name (e.g. \"pack\") and the HandlePragma method is invoked when a pragma with\n/// that identifier is found.  If a handler does not match any of the declared\n/// pragmas the handler with a null identifier is invoked, if it exists.\n///\n/// Note that the PragmaNamespace class can be used to subdivide pragmas, e.g.\n/// we treat \"\\#pragma STDC\" and \"\\#pragma GCC\" as namespaces that contain other\n/// pragmas.\nclass PragmaHandler {\n  std::string Name;\n\npublic:\n  PragmaHandler() = default;\n  explicit PragmaHandler(StringRef name) : Name(name) {}\n  virtual ~PragmaHandler();\n\n  StringRef getName() const { return Name; }\n  virtual void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,\n                            Token &FirstToken) = 0;\n\n  /// getIfNamespace - If this is a namespace, return it.  This is equivalent to\n  /// using a dynamic_cast, but doesn't require RTTI.\n  virtual PragmaNamespace *getIfNamespace() { return nullptr; }\n};\n\n/// EmptyPragmaHandler - A pragma handler which takes no action, which can be\n/// used to ignore particular pragmas.\nclass EmptyPragmaHandler : public PragmaHandler {\npublic:\n  explicit EmptyPragmaHandler(StringRef Name = StringRef());\n\n  void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,\n                    Token &FirstToken) override;\n};\n\n/// PragmaNamespace - This PragmaHandler subdivides the namespace of pragmas,\n/// allowing hierarchical pragmas to be defined.  Common examples of namespaces\n/// are \"\\#pragma GCC\", \"\\#pragma STDC\", and \"\\#pragma omp\", but any namespaces\n/// may be (potentially recursively) defined.\nclass PragmaNamespace : public PragmaHandler {\n  /// Handlers - This is a map of the handlers in this namespace with their name\n  /// as key.\n  llvm::StringMap<std::unique_ptr<PragmaHandler>> Handlers;\n\npublic:\n  explicit PragmaNamespace(StringRef Name) : PragmaHandler(Name) {}\n\n  /// FindHandler - Check to see if there is already a handler for the\n  /// specified name.  If not, return the handler for the null name if it\n  /// exists, otherwise return null.  If IgnoreNull is true (the default) then\n  /// the null handler isn't returned on failure to match.\n  PragmaHandler *FindHandler(StringRef Name,\n                             bool IgnoreNull = true) const;\n\n  /// AddPragma - Add a pragma to this namespace.\n  void AddPragma(PragmaHandler *Handler);\n\n  /// RemovePragmaHandler - Remove the given handler from the\n  /// namespace.\n  void RemovePragmaHandler(PragmaHandler *Handler);\n\n  bool IsEmpty() const { return Handlers.empty(); }\n\n  void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,\n                    Token &Tok) override;\n\n  PragmaNamespace *getIfNamespace() override { return this; }\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_LEX_PRAGMA_H\n"}, "86": {"id": 86, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h", "content": "//===- PreprocessingRecord.h - Record of Preprocessing ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the PreprocessingRecord class, which maintains a record\n//  of what occurred during preprocessing.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LEX_PREPROCESSINGRECORD_H\n#define LLVM_CLANG_LEX_PREPROCESSINGRECORD_H\n\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Lex/PPCallbacks.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Compiler.h\"\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <utility>\n#include <vector>\n\nnamespace clang {\n\nclass PreprocessingRecord;\n\n} // namespace clang\n\n/// Allocates memory within a Clang preprocessing record.\nvoid *operator new(size_t bytes, clang::PreprocessingRecord &PR,\n                   unsigned alignment = 8) noexcept;\n\n/// Frees memory allocated in a Clang preprocessing record.\nvoid operator delete(void *ptr, clang::PreprocessingRecord &PR,\n                     unsigned) noexcept;\n\nnamespace clang {\n\nclass FileEntry;\nclass IdentifierInfo;\nclass MacroInfo;\nclass SourceManager;\nclass Token;\n\n  /// Base class that describes a preprocessed entity, which may be a\n  /// preprocessor directive or macro expansion.\n  class PreprocessedEntity {\n  public:\n    /// The kind of preprocessed entity an object describes.\n    enum EntityKind {\n      /// Indicates a problem trying to load the preprocessed entity.\n      InvalidKind,\n\n      /// A macro expansion.\n      MacroExpansionKind,\n\n      /// \\defgroup Preprocessing directives\n      /// @{\n\n      /// A macro definition.\n      MacroDefinitionKind,\n\n      /// An inclusion directive, such as \\c \\#include, \\c\n      /// \\#import, or \\c \\#include_next.\n      InclusionDirectiveKind,\n\n      /// @}\n\n      FirstPreprocessingDirective = MacroDefinitionKind,\n      LastPreprocessingDirective = InclusionDirectiveKind\n    };\n\n  private:\n    /// The kind of preprocessed entity that this object describes.\n    EntityKind Kind;\n\n    /// The source range that covers this preprocessed entity.\n    SourceRange Range;\n\n  protected:\n    friend class PreprocessingRecord;\n\n    PreprocessedEntity(EntityKind Kind, SourceRange Range)\n        : Kind(Kind), Range(Range) {}\n\n  public:\n    /// Retrieve the kind of preprocessed entity stored in this object.\n    EntityKind getKind() const { return Kind; }\n\n    /// Retrieve the source range that covers this entire preprocessed\n    /// entity.\n    SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n\n    /// Returns true if there was a problem loading the preprocessed\n    /// entity.\n    bool isInvalid() const { return Kind == InvalidKind; }\n\n    // Only allow allocation of preprocessed entities using the allocator\n    // in PreprocessingRecord or by doing a placement new.\n    void *operator new(size_t bytes, PreprocessingRecord &PR,\n                       unsigned alignment = 8) noexcept {\n      return ::operator new(bytes, PR, alignment);\n    }\n\n    void *operator new(size_t bytes, void *mem) noexcept { return mem; }\n\n    void operator delete(void *ptr, PreprocessingRecord &PR,\n                         unsigned alignment) noexcept {\n      return ::operator delete(ptr, PR, alignment);\n    }\n\n    void operator delete(void *, std::size_t) noexcept {}\n    void operator delete(void *, void *) noexcept {}\n\n  private:\n    // Make vanilla 'new' and 'delete' illegal for preprocessed entities.\n    void *operator new(size_t bytes) noexcept;\n    void operator delete(void *data) noexcept;\n  };\n\n  /// Records the presence of a preprocessor directive.\n  class PreprocessingDirective : public PreprocessedEntity {\n  public:\n    PreprocessingDirective(EntityKind Kind, SourceRange Range)\n        : PreprocessedEntity(Kind, Range) {}\n\n    // Implement isa/cast/dyncast/etc.\n    static bool classof(const PreprocessedEntity *PD) {\n      return PD->getKind() >= FirstPreprocessingDirective &&\n             PD->getKind() <= LastPreprocessingDirective;\n    }\n  };\n\n  /// Record the location of a macro definition.\n  class MacroDefinitionRecord : public PreprocessingDirective {\n    /// The name of the macro being defined.\n    const IdentifierInfo *Name;\n\n  public:\n    explicit MacroDefinitionRecord(const IdentifierInfo *Name,\n                                   SourceRange Range)\n        : PreprocessingDirective(MacroDefinitionKind, Range), Name(Name) {}\n\n    /// Retrieve the name of the macro being defined.\n    const IdentifierInfo *getName() const { return Name; }\n\n    /// Retrieve the location of the macro name in the definition.\n    SourceLocation getLocation() const { return getSourceRange().getBegin(); }\n\n    // Implement isa/cast/dyncast/etc.\n    static bool classof(const PreprocessedEntity *PE) {\n      return PE->getKind() == MacroDefinitionKind;\n    }\n  };\n\n  /// Records the location of a macro expansion.\n  class MacroExpansion : public PreprocessedEntity {\n    /// The definition of this macro or the name of the macro if it is\n    /// a builtin macro.\n    llvm::PointerUnion<IdentifierInfo *, MacroDefinitionRecord *> NameOrDef;\n\n  public:\n    MacroExpansion(IdentifierInfo *BuiltinName, SourceRange Range)\n        : PreprocessedEntity(MacroExpansionKind, Range),\n          NameOrDef(BuiltinName) {}\n\n    MacroExpansion(MacroDefinitionRecord *Definition, SourceRange Range)\n        : PreprocessedEntity(MacroExpansionKind, Range), NameOrDef(Definition) {\n    }\n\n    /// True if it is a builtin macro.\n    bool isBuiltinMacro() const { return NameOrDef.is<IdentifierInfo *>(); }\n\n    /// The name of the macro being expanded.\n    const IdentifierInfo *getName() const {\n      if (MacroDefinitionRecord *Def = getDefinition())\n        return Def->getName();\n      return NameOrDef.get<IdentifierInfo *>();\n    }\n\n    /// The definition of the macro being expanded. May return null if\n    /// this is a builtin macro.\n    MacroDefinitionRecord *getDefinition() const {\n      return NameOrDef.dyn_cast<MacroDefinitionRecord *>();\n    }\n\n    // Implement isa/cast/dyncast/etc.\n    static bool classof(const PreprocessedEntity *PE) {\n      return PE->getKind() == MacroExpansionKind;\n    }\n  };\n\n  /// Record the location of an inclusion directive, such as an\n  /// \\c \\#include or \\c \\#import statement.\n  class InclusionDirective : public PreprocessingDirective {\n  public:\n    /// The kind of inclusion directives known to the\n    /// preprocessor.\n    enum InclusionKind {\n      /// An \\c \\#include directive.\n      Include,\n\n      /// An Objective-C \\c \\#import directive.\n      Import,\n\n      /// A GNU \\c \\#include_next directive.\n      IncludeNext,\n\n      /// A Clang \\c \\#__include_macros directive.\n      IncludeMacros\n    };\n\n  private:\n    /// The name of the file that was included, as written in\n    /// the source.\n    StringRef FileName;\n\n    /// Whether the file name was in quotation marks; otherwise, it was\n    /// in angle brackets.\n    unsigned InQuotes : 1;\n\n    /// The kind of inclusion directive we have.\n    ///\n    /// This is a value of type InclusionKind.\n    unsigned Kind : 2;\n\n    /// Whether the inclusion directive was automatically turned into\n    /// a module import.\n    unsigned ImportedModule : 1;\n\n    /// The file that was included.\n    const FileEntry *File;\n\n  public:\n    InclusionDirective(PreprocessingRecord &PPRec,\n                       InclusionKind Kind, StringRef FileName,\n                       bool InQuotes, bool ImportedModule,\n                       const FileEntry *File, SourceRange Range);\n\n    /// Determine what kind of inclusion directive this is.\n    InclusionKind getKind() const { return static_cast<InclusionKind>(Kind); }\n\n    /// Retrieve the included file name as it was written in the source.\n    StringRef getFileName() const { return FileName; }\n\n    /// Determine whether the included file name was written in quotes;\n    /// otherwise, it was written in angle brackets.\n    bool wasInQuotes() const { return InQuotes; }\n\n    /// Determine whether the inclusion directive was automatically\n    /// turned into a module import.\n    bool importedModule() const { return ImportedModule; }\n\n    /// Retrieve the file entry for the actual file that was included\n    /// by this directive.\n    const FileEntry *getFile() const { return File; }\n\n    // Implement isa/cast/dyncast/etc.\n    static bool classof(const PreprocessedEntity *PE) {\n      return PE->getKind() == InclusionDirectiveKind;\n    }\n  };\n\n  /// An abstract class that should be subclassed by any external source\n  /// of preprocessing record entries.\n  class ExternalPreprocessingRecordSource {\n  public:\n    virtual ~ExternalPreprocessingRecordSource();\n\n    /// Read a preallocated preprocessed entity from the external source.\n    ///\n    /// \\returns null if an error occurred that prevented the preprocessed\n    /// entity from being loaded.\n    virtual PreprocessedEntity *ReadPreprocessedEntity(unsigned Index) = 0;\n\n    /// Returns a pair of [Begin, End) indices of preallocated\n    /// preprocessed entities that \\p Range encompasses.\n    virtual std::pair<unsigned, unsigned>\n        findPreprocessedEntitiesInRange(SourceRange Range) = 0;\n\n    /// Optionally returns true or false if the preallocated preprocessed\n    /// entity with index \\p Index came from file \\p FID.\n    virtual Optional<bool> isPreprocessedEntityInFileID(unsigned Index,\n                                                        FileID FID) {\n      return None;\n    }\n\n    /// Read a preallocated skipped range from the external source.\n    virtual SourceRange ReadSkippedRange(unsigned Index) = 0;\n  };\n\n  /// A record of the steps taken while preprocessing a source file,\n  /// including the various preprocessing directives processed, macros\n  /// expanded, etc.\n  class PreprocessingRecord : public PPCallbacks {\n    SourceManager &SourceMgr;\n\n    /// Allocator used to store preprocessing objects.\n    llvm::BumpPtrAllocator BumpAlloc;\n\n    /// The set of preprocessed entities in this record, in order they\n    /// were seen.\n    std::vector<PreprocessedEntity *> PreprocessedEntities;\n\n    /// The set of preprocessed entities in this record that have been\n    /// loaded from external sources.\n    ///\n    /// The entries in this vector are loaded lazily from the external source,\n    /// and are referenced by the iterator using negative indices.\n    std::vector<PreprocessedEntity *> LoadedPreprocessedEntities;\n\n    /// The set of ranges that were skipped by the preprocessor,\n    std::vector<SourceRange> SkippedRanges;\n\n    bool SkippedRangesAllLoaded = true;\n\n    /// Global (loaded or local) ID for a preprocessed entity.\n    /// Negative values are used to indicate preprocessed entities\n    /// loaded from the external source while non-negative values are used to\n    /// indicate preprocessed entities introduced by the current preprocessor.\n    /// Value -1 corresponds to element 0 in the loaded entities vector,\n    /// value -2 corresponds to element 1 in the loaded entities vector, etc.\n    /// Value 0 is an invalid value, the index to local entities is 1-based,\n    /// value 1 corresponds to element 0 in the local entities vector,\n    /// value 2 corresponds to element 1 in the local entities vector, etc.\n    class PPEntityID {\n      friend class PreprocessingRecord;\n\n      int ID = 0;\n\n      explicit PPEntityID(int ID) : ID(ID) {}\n\n    public:\n      PPEntityID() = default;\n    };\n\n    static PPEntityID getPPEntityID(unsigned Index, bool isLoaded) {\n      return isLoaded ? PPEntityID(-int(Index)-1) : PPEntityID(Index+1);\n    }\n\n    /// Mapping from MacroInfo structures to their definitions.\n    llvm::DenseMap<const MacroInfo *, MacroDefinitionRecord *> MacroDefinitions;\n\n    /// External source of preprocessed entities.\n    ExternalPreprocessingRecordSource *ExternalSource = nullptr;\n\n    /// Retrieve the preprocessed entity at the given ID.\n    PreprocessedEntity *getPreprocessedEntity(PPEntityID PPID);\n\n    /// Retrieve the loaded preprocessed entity at the given index.\n    PreprocessedEntity *getLoadedPreprocessedEntity(unsigned Index);\n\n    /// Determine the number of preprocessed entities that were\n    /// loaded (or can be loaded) from an external source.\n    unsigned getNumLoadedPreprocessedEntities() const {\n      return LoadedPreprocessedEntities.size();\n    }\n\n    /// Returns a pair of [Begin, End) indices of local preprocessed\n    /// entities that \\p Range encompasses.\n    std::pair<unsigned, unsigned>\n      findLocalPreprocessedEntitiesInRange(SourceRange Range) const;\n    unsigned findBeginLocalPreprocessedEntity(SourceLocation Loc) const;\n    unsigned findEndLocalPreprocessedEntity(SourceLocation Loc) const;\n\n    /// Allocate space for a new set of loaded preprocessed entities.\n    ///\n    /// \\returns The index into the set of loaded preprocessed entities, which\n    /// corresponds to the first newly-allocated entity.\n    unsigned allocateLoadedEntities(unsigned NumEntities);\n\n    /// Allocate space for a new set of loaded preprocessed skipped\n    /// ranges.\n    ///\n    /// \\returns The index into the set of loaded preprocessed ranges, which\n    /// corresponds to the first newly-allocated range.\n    unsigned allocateSkippedRanges(unsigned NumRanges);\n\n    /// Ensures that all external skipped ranges have been loaded.\n    void ensureSkippedRangesLoaded();\n\n    /// Register a new macro definition.\n    void RegisterMacroDefinition(MacroInfo *Macro, MacroDefinitionRecord *Def);\n\n  public:\n    /// Construct a new preprocessing record.\n    explicit PreprocessingRecord(SourceManager &SM);\n\n    /// Allocate memory in the preprocessing record.\n    void *Allocate(unsigned Size, unsigned Align = 8) {\n      return BumpAlloc.Allocate(Size, Align);\n    }\n\n    /// Deallocate memory in the preprocessing record.\n    void Deallocate(void *Ptr) {}\n\n    size_t getTotalMemory() const;\n\n    SourceManager &getSourceManager() const { return SourceMgr; }\n\n    /// Iteration over the preprocessed entities.\n    ///\n    /// In a complete iteration, the iterator walks the range [-M, N),\n    /// where negative values are used to indicate preprocessed entities\n    /// loaded from the external source while non-negative values are used to\n    /// indicate preprocessed entities introduced by the current preprocessor.\n    /// However, to provide iteration in source order (for, e.g., chained\n    /// precompiled headers), dereferencing the iterator flips the negative\n    /// values (corresponding to loaded entities), so that position -M\n    /// corresponds to element 0 in the loaded entities vector, position -M+1\n    /// corresponds to element 1 in the loaded entities vector, etc. This\n    /// gives us a reasonably efficient, source-order walk.\n    ///\n    /// We define this as a wrapping iterator around an int. The\n    /// iterator_adaptor_base class forwards the iterator methods to basic\n    /// integer arithmetic.\n    class iterator : public llvm::iterator_adaptor_base<\n                         iterator, int, std::random_access_iterator_tag,\n                         PreprocessedEntity *, int, PreprocessedEntity *,\n                         PreprocessedEntity *> {\n      friend class PreprocessingRecord;\n\n      PreprocessingRecord *Self;\n\n      iterator(PreprocessingRecord *Self, int Position)\n          : iterator::iterator_adaptor_base(Position), Self(Self) {}\n\n    public:\n      iterator() : iterator(nullptr, 0) {}\n\n      PreprocessedEntity *operator*() const {\n        bool isLoaded = this->I < 0;\n        unsigned Index = isLoaded ?\n            Self->LoadedPreprocessedEntities.size() + this->I : this->I;\n        PPEntityID ID = Self->getPPEntityID(Index, isLoaded);\n        return Self->getPreprocessedEntity(ID);\n      }\n      PreprocessedEntity *operator->() const { return **this; }\n    };\n\n    /// Begin iterator for all preprocessed entities.\n    iterator begin() {\n      return iterator(this, -(int)LoadedPreprocessedEntities.size());\n    }\n\n    /// End iterator for all preprocessed entities.\n    iterator end() {\n      return iterator(this, PreprocessedEntities.size());\n    }\n\n    /// Begin iterator for local, non-loaded, preprocessed entities.\n    iterator local_begin() {\n      return iterator(this, 0);\n    }\n\n    /// End iterator for local, non-loaded, preprocessed entities.\n    iterator local_end() {\n      return iterator(this, PreprocessedEntities.size());\n    }\n\n    /// iterator range for the given range of loaded\n    /// preprocessed entities.\n    llvm::iterator_range<iterator> getIteratorsForLoadedRange(unsigned start,\n                                                              unsigned count) {\n      unsigned end = start + count;\n      assert(end <= LoadedPreprocessedEntities.size());\n      return llvm::make_range(\n          iterator(this, int(start) - LoadedPreprocessedEntities.size()),\n          iterator(this, int(end) - LoadedPreprocessedEntities.size()));\n    }\n\n    /// Returns a range of preprocessed entities that source range \\p R\n    /// encompasses.\n    ///\n    /// \\param R the range to look for preprocessed entities.\n    llvm::iterator_range<iterator>\n    getPreprocessedEntitiesInRange(SourceRange R);\n\n    /// Returns true if the preprocessed entity that \\p PPEI iterator\n    /// points to is coming from the file \\p FID.\n    ///\n    /// Can be used to avoid implicit deserializations of preallocated\n    /// preprocessed entities if we only care about entities of a specific file\n    /// and not from files \\#included in the range given at\n    /// \\see getPreprocessedEntitiesInRange.\n    bool isEntityInFileID(iterator PPEI, FileID FID);\n\n    /// Add a new preprocessed entity to this record.\n    PPEntityID addPreprocessedEntity(PreprocessedEntity *Entity);\n\n    /// Set the external source for preprocessed entities.\n    void SetExternalSource(ExternalPreprocessingRecordSource &Source);\n\n    /// Retrieve the external source for preprocessed entities.\n    ExternalPreprocessingRecordSource *getExternalSource() const {\n      return ExternalSource;\n    }\n\n    /// Retrieve the macro definition that corresponds to the given\n    /// \\c MacroInfo.\n    MacroDefinitionRecord *findMacroDefinition(const MacroInfo *MI);\n\n    /// Retrieve all ranges that got skipped while preprocessing.\n    const std::vector<SourceRange> &getSkippedRanges() {\n      ensureSkippedRangesLoaded();\n      return SkippedRanges;\n    }\n\n  private:\n    friend class ASTReader;\n    friend class ASTWriter;\n\n    void MacroExpands(const Token &Id, const MacroDefinition &MD,\n                      SourceRange Range, const MacroArgs *Args) override;\n    void MacroDefined(const Token &Id, const MacroDirective *MD) override;\n    void MacroUndefined(const Token &Id, const MacroDefinition &MD,\n                        const MacroDirective *Undef) override;\n    void InclusionDirective(SourceLocation HashLoc, const Token &IncludeTok,\n                            StringRef FileName, bool IsAngled,\n                            CharSourceRange FilenameRange,\n                            const FileEntry *File, StringRef SearchPath,\n                            StringRef RelativePath, const Module *Imported,\n                            SrcMgr::CharacteristicKind FileType) override;\n    void Ifdef(SourceLocation Loc, const Token &MacroNameTok,\n               const MacroDefinition &MD) override;\n    void Ifndef(SourceLocation Loc, const Token &MacroNameTok,\n                const MacroDefinition &MD) override;\n\n    /// Hook called whenever the 'defined' operator is seen.\n    void Defined(const Token &MacroNameTok, const MacroDefinition &MD,\n                 SourceRange Range) override;\n\n    void SourceRangeSkipped(SourceRange Range,\n                            SourceLocation EndifLoc) override;\n\n    void addMacroExpansion(const Token &Id, const MacroInfo *MI,\n                           SourceRange Range);\n\n    /// Cached result of the last \\see getPreprocessedEntitiesInRange\n    /// query.\n    struct {\n      SourceRange Range;\n      std::pair<int, int> Result;\n    } CachedRangeQuery;\n\n    std::pair<int, int> getPreprocessedEntitiesInRangeSlow(SourceRange R);\n  };\n\n} // namespace clang\n\ninline void *operator new(size_t bytes, clang::PreprocessingRecord &PR,\n                          unsigned alignment) noexcept {\n  return PR.Allocate(bytes, alignment);\n}\n\ninline void operator delete(void *ptr, clang::PreprocessingRecord &PR,\n                            unsigned) noexcept {\n  PR.Deallocate(ptr);\n}\n\n#endif // LLVM_CLANG_LEX_PREPROCESSINGRECORD_H\n"}, "87": {"id": 87, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/Token.h", "content": "//===--- Token.h - Token interface ------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the Token interface.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LEX_TOKEN_H\n#define LLVM_CLANG_LEX_TOKEN_H\n\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/TokenKinds.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <cassert>\n\nnamespace clang {\n\nclass IdentifierInfo;\n\n/// Token - This structure provides full information about a lexed token.\n/// It is not intended to be space efficient, it is intended to return as much\n/// information as possible about each returned token.  This is expected to be\n/// compressed into a smaller form if memory footprint is important.\n///\n/// The parser can create a special \"annotation token\" representing a stream of\n/// tokens that were parsed and semantically resolved, e.g.: \"foo::MyClass<int>\"\n/// can be represented by a single typename annotation token that carries\n/// information about the SourceRange of the tokens and the type object.\nclass Token {\n  /// The location of the token. This is actually a SourceLocation.\n  unsigned Loc;\n\n  // Conceptually these next two fields could be in a union.  However, this\n  // causes gcc 4.2 to pessimize LexTokenInternal, a very performance critical\n  // routine. Keeping as separate members with casts until a more beautiful fix\n  // presents itself.\n\n  /// UintData - This holds either the length of the token text, when\n  /// a normal token, or the end of the SourceRange when an annotation\n  /// token.\n  unsigned UintData;\n\n  /// PtrData - This is a union of four different pointer types, which depends\n  /// on what type of token this is:\n  ///  Identifiers, keywords, etc:\n  ///    This is an IdentifierInfo*, which contains the uniqued identifier\n  ///    spelling.\n  ///  Literals:  isLiteral() returns true.\n  ///    This is a pointer to the start of the token in a text buffer, which\n  ///    may be dirty (have trigraphs / escaped newlines).\n  ///  Annotations (resolved type names, C++ scopes, etc): isAnnotation().\n  ///    This is a pointer to sema-specific data for the annotation token.\n  ///  Eof:\n  //     This is a pointer to a Decl.\n  ///  Other:\n  ///    This is null.\n  void *PtrData;\n\n  /// Kind - The actual flavor of token this is.\n  tok::TokenKind Kind;\n\n  /// Flags - Bits we track about this token, members of the TokenFlags enum.\n  unsigned short Flags;\n\npublic:\n  // Various flags set per token:\n  enum TokenFlags {\n    StartOfLine = 0x01,   // At start of line or only after whitespace\n                          // (considering the line after macro expansion).\n    LeadingSpace = 0x02,  // Whitespace exists before this token (considering\n                          // whitespace after macro expansion).\n    DisableExpand = 0x04, // This identifier may never be macro expanded.\n    NeedsCleaning = 0x08, // Contained an escaped newline or trigraph.\n    LeadingEmptyMacro = 0x10, // Empty macro exists before this token.\n    HasUDSuffix = 0x20,  // This string or character literal has a ud-suffix.\n    HasUCN = 0x40,       // This identifier contains a UCN.\n    IgnoredComma = 0x80, // This comma is not a macro argument separator (MS).\n    StringifiedInMacro = 0x100, // This string or character literal is formed by\n                                // macro stringizing or charizing operator.\n    CommaAfterElided = 0x200, // The comma following this token was elided (MS).\n    IsEditorPlaceholder = 0x400, // This identifier is a placeholder.\n    IsReinjected = 0x800, // A phase 4 token that was produced before and\n                          // re-added, e.g. via EnterTokenStream. Annotation\n                          // tokens are *not* reinjected.\n  };\n\n  tok::TokenKind getKind() const { return Kind; }\n  void setKind(tok::TokenKind K) { Kind = K; }\n\n  /// is/isNot - Predicates to check if this token is a specific kind, as in\n  /// \"if (Tok.is(tok::l_brace)) {...}\".\n  bool is(tok::TokenKind K) const { return Kind == K; }\n  bool isNot(tok::TokenKind K) const { return Kind != K; }\n  bool isOneOf(tok::TokenKind K1, tok::TokenKind K2) const {\n    return is(K1) || is(K2);\n  }\n  template <typename... Ts>\n  bool isOneOf(tok::TokenKind K1, tok::TokenKind K2, Ts... Ks) const {\n    return is(K1) || isOneOf(K2, Ks...);\n  }\n\n  /// Return true if this is a raw identifier (when lexing\n  /// in raw mode) or a non-keyword identifier (when lexing in non-raw mode).\n  bool isAnyIdentifier() const {\n    return tok::isAnyIdentifier(getKind());\n  }\n\n  /// Return true if this is a \"literal\", like a numeric\n  /// constant, string, etc.\n  bool isLiteral() const {\n    return tok::isLiteral(getKind());\n  }\n\n  /// Return true if this is any of tok::annot_* kind tokens.\n  bool isAnnotation() const {\n    return tok::isAnnotation(getKind());\n  }\n\n  /// Return a source location identifier for the specified\n  /// offset in the current file.\n  SourceLocation getLocation() const {\n    return SourceLocation::getFromRawEncoding(Loc);\n  }\n  unsigned getLength() const {\n    assert(!isAnnotation() && \"Annotation tokens have no length field\");\n    return UintData;\n  }\n\n  void setLocation(SourceLocation L) { Loc = L.getRawEncoding(); }\n  void setLength(unsigned Len) {\n    assert(!isAnnotation() && \"Annotation tokens have no length field\");\n    UintData = Len;\n  }\n\n  SourceLocation getAnnotationEndLoc() const {\n    assert(isAnnotation() && \"Used AnnotEndLocID on non-annotation token\");\n    return SourceLocation::getFromRawEncoding(UintData ? UintData : Loc);\n  }\n  void setAnnotationEndLoc(SourceLocation L) {\n    assert(isAnnotation() && \"Used AnnotEndLocID on non-annotation token\");\n    UintData = L.getRawEncoding();\n  }\n\n  SourceLocation getLastLoc() const {\n    return isAnnotation() ? getAnnotationEndLoc() : getLocation();\n  }\n\n  SourceLocation getEndLoc() const {\n    return isAnnotation() ? getAnnotationEndLoc()\n                          : getLocation().getLocWithOffset(getLength());\n  }\n\n  /// SourceRange of the group of tokens that this annotation token\n  /// represents.\n  SourceRange getAnnotationRange() const {\n    return SourceRange(getLocation(), getAnnotationEndLoc());\n  }\n  void setAnnotationRange(SourceRange R) {\n    setLocation(R.getBegin());\n    setAnnotationEndLoc(R.getEnd());\n  }\n\n  const char *getName() const { return tok::getTokenName(Kind); }\n\n  /// Reset all flags to cleared.\n  void startToken() {\n    Kind = tok::unknown;\n    Flags = 0;\n    PtrData = nullptr;\n    UintData = 0;\n    Loc = SourceLocation().getRawEncoding();\n  }\n\n  IdentifierInfo *getIdentifierInfo() const {\n    assert(isNot(tok::raw_identifier) &&\n           \"getIdentifierInfo() on a tok::raw_identifier token!\");\n    assert(!isAnnotation() &&\n           \"getIdentifierInfo() on an annotation token!\");\n    if (isLiteral()) return nullptr;\n    if (is(tok::eof)) return nullptr;\n    return (IdentifierInfo*) PtrData;\n  }\n  void setIdentifierInfo(IdentifierInfo *II) {\n    PtrData = (void*) II;\n  }\n\n  const void *getEofData() const {\n    assert(is(tok::eof));\n    return reinterpret_cast<const void *>(PtrData);\n  }\n  void setEofData(const void *D) {\n    assert(is(tok::eof));\n    assert(!PtrData);\n    PtrData = const_cast<void *>(D);\n  }\n\n  /// getRawIdentifier - For a raw identifier token (i.e., an identifier\n  /// lexed in raw mode), returns a reference to the text substring in the\n  /// buffer if known.\n  StringRef getRawIdentifier() const {\n    assert(is(tok::raw_identifier));\n    return StringRef(reinterpret_cast<const char *>(PtrData), getLength());\n  }\n  void setRawIdentifierData(const char *Ptr) {\n    assert(is(tok::raw_identifier));\n    PtrData = const_cast<char*>(Ptr);\n  }\n\n  /// getLiteralData - For a literal token (numeric constant, string, etc), this\n  /// returns a pointer to the start of it in the text buffer if known, null\n  /// otherwise.\n  const char *getLiteralData() const {\n    assert(isLiteral() && \"Cannot get literal data of non-literal\");\n    return reinterpret_cast<const char*>(PtrData);\n  }\n  void setLiteralData(const char *Ptr) {\n    assert(isLiteral() && \"Cannot set literal data of non-literal\");\n    PtrData = const_cast<char*>(Ptr);\n  }\n\n  void *getAnnotationValue() const {\n    assert(isAnnotation() && \"Used AnnotVal on non-annotation token\");\n    return PtrData;\n  }\n  void setAnnotationValue(void *val) {\n    assert(isAnnotation() && \"Used AnnotVal on non-annotation token\");\n    PtrData = val;\n  }\n\n  /// Set the specified flag.\n  void setFlag(TokenFlags Flag) {\n    Flags |= Flag;\n  }\n\n  /// Get the specified flag.\n  bool getFlag(TokenFlags Flag) const {\n    return (Flags & Flag) != 0;\n  }\n\n  /// Unset the specified flag.\n  void clearFlag(TokenFlags Flag) {\n    Flags &= ~Flag;\n  }\n\n  /// Return the internal represtation of the flags.\n  ///\n  /// This is only intended for low-level operations such as writing tokens to\n  /// disk.\n  unsigned getFlags() const {\n    return Flags;\n  }\n\n  /// Set a flag to either true or false.\n  void setFlagValue(TokenFlags Flag, bool Val) {\n    if (Val)\n      setFlag(Flag);\n    else\n      clearFlag(Flag);\n  }\n\n  /// isAtStartOfLine - Return true if this token is at the start of a line.\n  ///\n  bool isAtStartOfLine() const { return getFlag(StartOfLine); }\n\n  /// Return true if this token has whitespace before it.\n  ///\n  bool hasLeadingSpace() const { return getFlag(LeadingSpace); }\n\n  /// Return true if this identifier token should never\n  /// be expanded in the future, due to C99 6.10.3.4p2.\n  bool isExpandDisabled() const { return getFlag(DisableExpand); }\n\n  /// Return true if we have an ObjC keyword identifier.\n  bool isObjCAtKeyword(tok::ObjCKeywordKind objcKey) const;\n\n  /// Return the ObjC keyword kind.\n  tok::ObjCKeywordKind getObjCKeywordID() const;\n\n  /// Return true if this token has trigraphs or escaped newlines in it.\n  bool needsCleaning() const { return getFlag(NeedsCleaning); }\n\n  /// Return true if this token has an empty macro before it.\n  ///\n  bool hasLeadingEmptyMacro() const { return getFlag(LeadingEmptyMacro); }\n\n  /// Return true if this token is a string or character literal which\n  /// has a ud-suffix.\n  bool hasUDSuffix() const { return getFlag(HasUDSuffix); }\n\n  /// Returns true if this token contains a universal character name.\n  bool hasUCN() const { return getFlag(HasUCN); }\n\n  /// Returns true if this token is formed by macro by stringizing or charizing\n  /// operator.\n  bool stringifiedInMacro() const { return getFlag(StringifiedInMacro); }\n\n  /// Returns true if the comma after this token was elided.\n  bool commaAfterElided() const { return getFlag(CommaAfterElided); }\n\n  /// Returns true if this token is an editor placeholder.\n  ///\n  /// Editor placeholders are produced by the code-completion engine and are\n  /// represented as characters between '<#' and '#>' in the source code. The\n  /// lexer uses identifier tokens to represent placeholders.\n  bool isEditorPlaceholder() const { return getFlag(IsEditorPlaceholder); }\n};\n\n/// Information about the conditional stack (\\#if directives)\n/// currently active.\nstruct PPConditionalInfo {\n  /// Location where the conditional started.\n  SourceLocation IfLoc;\n\n  /// True if this was contained in a skipping directive, e.g.,\n  /// in a \"\\#if 0\" block.\n  bool WasSkipping;\n\n  /// True if we have emitted tokens already, and now we're in\n  /// an \\#else block or something.  Only useful in Skipping blocks.\n  bool FoundNonSkip;\n\n  /// True if we've seen a \\#else in this block.  If so,\n  /// \\#elif/\\#else directives are not allowed.\n  bool FoundElse;\n};\n\n} // end namespace clang\n\n#endif // LLVM_CLANG_LEX_TOKEN_H\n"}, "88": {"id": 88, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h", "content": "//===- CodeCompleteConsumer.h - Code Completion Interface -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the CodeCompleteConsumer class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SEMA_CODECOMPLETECONSUMER_H\n#define LLVM_CLANG_SEMA_CODECOMPLETECONSUMER_H\n\n#include \"clang-c/Index.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Lex/MacroInfo.h\"\n#include \"clang/Sema/CodeCompleteOptions.h\"\n#include \"clang/Sema/DeclSpec.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <cassert>\n#include <memory>\n#include <string>\n#include <utility>\n\nnamespace clang {\n\nclass ASTContext;\nclass Decl;\nclass DeclContext;\nclass FunctionDecl;\nclass FunctionTemplateDecl;\nclass IdentifierInfo;\nclass LangOptions;\nclass NamedDecl;\nclass NestedNameSpecifier;\nclass Preprocessor;\nclass RawComment;\nclass Sema;\nclass UsingShadowDecl;\n\n/// Default priority values for code-completion results based\n/// on their kind.\nenum {\n  /// Priority for the next initialization in a constructor initializer\n  /// list.\n  CCP_NextInitializer = 7,\n\n  /// Priority for an enumeration constant inside a switch whose\n  /// condition is of the enumeration type.\n  CCP_EnumInCase = 7,\n\n  /// Priority for a send-to-super completion.\n  CCP_SuperCompletion = 20,\n\n  /// Priority for a declaration that is in the local scope.\n  CCP_LocalDeclaration = 34,\n\n  /// Priority for a member declaration found from the current\n  /// method or member function.\n  CCP_MemberDeclaration = 35,\n\n  /// Priority for a language keyword (that isn't any of the other\n  /// categories).\n  CCP_Keyword = 40,\n\n  /// Priority for a code pattern.\n  CCP_CodePattern = 40,\n\n  /// Priority for a non-type declaration.\n  CCP_Declaration = 50,\n\n  /// Priority for a type.\n  CCP_Type = CCP_Declaration,\n\n  /// Priority for a constant value (e.g., enumerator).\n  CCP_Constant = 65,\n\n  /// Priority for a preprocessor macro.\n  CCP_Macro = 70,\n\n  /// Priority for a nested-name-specifier.\n  CCP_NestedNameSpecifier = 75,\n\n  /// Priority for a result that isn't likely to be what the user wants,\n  /// but is included for completeness.\n  CCP_Unlikely = 80,\n\n  /// Priority for the Objective-C \"_cmd\" implicit parameter.\n  CCP_ObjC_cmd = CCP_Unlikely\n};\n\n/// Priority value deltas that are added to code-completion results\n/// based on the context of the result.\nenum {\n  /// The result is in a base class.\n  CCD_InBaseClass = 2,\n\n  /// The result is a C++ non-static member function whose qualifiers\n  /// exactly match the object type on which the member function can be called.\n  CCD_ObjectQualifierMatch = -1,\n\n  /// The selector of the given message exactly matches the selector\n  /// of the current method, which might imply that some kind of delegation\n  /// is occurring.\n  CCD_SelectorMatch = -3,\n\n  /// Adjustment to the \"bool\" type in Objective-C, where the typedef\n  /// \"BOOL\" is preferred.\n  CCD_bool_in_ObjC = 1,\n\n  /// Adjustment for KVC code pattern priorities when it doesn't look\n  /// like the\n  CCD_ProbablyNotObjCCollection = 15,\n\n  /// An Objective-C method being used as a property.\n  CCD_MethodAsProperty = 2,\n\n  /// An Objective-C block property completed as a setter with a\n  /// block placeholder.\n  CCD_BlockPropertySetter = 3\n};\n\n/// Priority value factors by which we will divide or multiply the\n/// priority of a code-completion result.\nenum {\n  /// Divide by this factor when a code-completion result's type exactly\n  /// matches the type we expect.\n  CCF_ExactTypeMatch = 4,\n\n  /// Divide by this factor when a code-completion result's type is\n  /// similar to the type we expect (e.g., both arithmetic types, both\n  /// Objective-C object pointer types).\n  CCF_SimilarTypeMatch = 2\n};\n\n/// A simplified classification of types used when determining\n/// \"similar\" types for code completion.\nenum SimplifiedTypeClass {\n  STC_Arithmetic,\n  STC_Array,\n  STC_Block,\n  STC_Function,\n  STC_ObjectiveC,\n  STC_Other,\n  STC_Pointer,\n  STC_Record,\n  STC_Void\n};\n\n/// Determine the simplified type class of the given canonical type.\nSimplifiedTypeClass getSimplifiedTypeClass(CanQualType T);\n\n/// Determine the type that this declaration will have if it is used\n/// as a type or in an expression.\nQualType getDeclUsageType(ASTContext &C, const NamedDecl *ND);\n\n/// Determine the priority to be given to a macro code completion result\n/// with the given name.\n///\n/// \\param MacroName The name of the macro.\n///\n/// \\param LangOpts Options describing the current language dialect.\n///\n/// \\param PreferredTypeIsPointer Whether the preferred type for the context\n/// of this macro is a pointer type.\nunsigned getMacroUsagePriority(StringRef MacroName,\n                               const LangOptions &LangOpts,\n                               bool PreferredTypeIsPointer = false);\n\n/// Determine the libclang cursor kind associated with the given\n/// declaration.\nCXCursorKind getCursorKindForDecl(const Decl *D);\n\n/// The context in which code completion occurred, so that the\n/// code-completion consumer can process the results accordingly.\nclass CodeCompletionContext {\npublic:\n  enum Kind {\n    /// An unspecified code-completion context.\n    CCC_Other,\n\n    /// An unspecified code-completion context where we should also add\n    /// macro completions.\n    CCC_OtherWithMacros,\n\n    /// Code completion occurred within a \"top-level\" completion context,\n    /// e.g., at namespace or global scope.\n    CCC_TopLevel,\n\n    /// Code completion occurred within an Objective-C interface,\n    /// protocol, or category interface.\n    CCC_ObjCInterface,\n\n    /// Code completion occurred within an Objective-C implementation\n    /// or category implementation.\n    CCC_ObjCImplementation,\n\n    /// Code completion occurred within the instance variable list of\n    /// an Objective-C interface, implementation, or category implementation.\n    CCC_ObjCIvarList,\n\n    /// Code completion occurred within a class, struct, or union.\n    CCC_ClassStructUnion,\n\n    /// Code completion occurred where a statement (or declaration) is\n    /// expected in a function, method, or block.\n    CCC_Statement,\n\n    /// Code completion occurred where an expression is expected.\n    CCC_Expression,\n\n    /// Code completion occurred where an Objective-C message receiver\n    /// is expected.\n    CCC_ObjCMessageReceiver,\n\n    /// Code completion occurred on the right-hand side of a member\n    /// access expression using the dot operator.\n    ///\n    /// The results of this completion are the members of the type being\n    /// accessed. The type itself is available via\n    /// \\c CodeCompletionContext::getType().\n    CCC_DotMemberAccess,\n\n    /// Code completion occurred on the right-hand side of a member\n    /// access expression using the arrow operator.\n    ///\n    /// The results of this completion are the members of the type being\n    /// accessed. The type itself is available via\n    /// \\c CodeCompletionContext::getType().\n    CCC_ArrowMemberAccess,\n\n    /// Code completion occurred on the right-hand side of an Objective-C\n    /// property access expression.\n    ///\n    /// The results of this completion are the members of the type being\n    /// accessed. The type itself is available via\n    /// \\c CodeCompletionContext::getType().\n    CCC_ObjCPropertyAccess,\n\n    /// Code completion occurred after the \"enum\" keyword, to indicate\n    /// an enumeration name.\n    CCC_EnumTag,\n\n    /// Code completion occurred after the \"union\" keyword, to indicate\n    /// a union name.\n    CCC_UnionTag,\n\n    /// Code completion occurred after the \"struct\" or \"class\" keyword,\n    /// to indicate a struct or class name.\n    CCC_ClassOrStructTag,\n\n    /// Code completion occurred where a protocol name is expected.\n    CCC_ObjCProtocolName,\n\n    /// Code completion occurred where a namespace or namespace alias\n    /// is expected.\n    CCC_Namespace,\n\n    /// Code completion occurred where a type name is expected.\n    CCC_Type,\n\n    /// Code completion occurred where a new name is expected.\n    CCC_NewName,\n\n    /// Code completion occurred where both a new name and an existing symbol is\n    /// permissible.\n    CCC_SymbolOrNewName,\n\n    /// Code completion occurred where an existing name(such as type, function\n    /// or variable) is expected.\n    CCC_Symbol,\n\n    /// Code completion occurred where an macro is being defined.\n    CCC_MacroName,\n\n    /// Code completion occurred where a macro name is expected\n    /// (without any arguments, in the case of a function-like macro).\n    CCC_MacroNameUse,\n\n    /// Code completion occurred within a preprocessor expression.\n    CCC_PreprocessorExpression,\n\n    /// Code completion occurred where a preprocessor directive is\n    /// expected.\n    CCC_PreprocessorDirective,\n\n    /// Code completion occurred in a context where natural language is\n    /// expected, e.g., a comment or string literal.\n    ///\n    /// This context usually implies that no completions should be added,\n    /// unless they come from an appropriate natural-language dictionary.\n    CCC_NaturalLanguage,\n\n    /// Code completion for a selector, as in an \\@selector expression.\n    CCC_SelectorName,\n\n    /// Code completion within a type-qualifier list.\n    CCC_TypeQualifiers,\n\n    /// Code completion in a parenthesized expression, which means that\n    /// we may also have types here in C and Objective-C (as well as in C++).\n    CCC_ParenthesizedExpression,\n\n    /// Code completion where an Objective-C instance message is\n    /// expected.\n    CCC_ObjCInstanceMessage,\n\n    /// Code completion where an Objective-C class message is expected.\n    CCC_ObjCClassMessage,\n\n    /// Code completion where the name of an Objective-C class is\n    /// expected.\n    CCC_ObjCInterfaceName,\n\n    /// Code completion where an Objective-C category name is expected.\n    CCC_ObjCCategoryName,\n\n    /// Code completion inside the filename part of a #include directive.\n    CCC_IncludedFile,\n\n    /// An unknown context, in which we are recovering from a parsing\n    /// error and don't know which completions we should give.\n    CCC_Recovery\n  };\n\n  using VisitedContextSet = llvm::SmallPtrSet<DeclContext *, 8>;\n\nprivate:\n  Kind CCKind;\n\n  /// Indicates whether we are completing a name of a using declaration, e.g.\n  ///     using ^;\n  ///     using a::^;\n  bool IsUsingDeclaration;\n\n  /// The type that would prefer to see at this point (e.g., the type\n  /// of an initializer or function parameter).\n  QualType PreferredType;\n\n  /// The type of the base object in a member access expression.\n  QualType BaseType;\n\n  /// The identifiers for Objective-C selector parts.\n  ArrayRef<IdentifierInfo *> SelIdents;\n\n  /// The scope specifier that comes before the completion token e.g.\n  /// \"a::b::\"\n  llvm::Optional<CXXScopeSpec> ScopeSpecifier;\n\n  /// A set of declaration contexts visited by Sema when doing lookup for\n  /// code completion.\n  VisitedContextSet VisitedContexts;\n\npublic:\n  /// Construct a new code-completion context of the given kind.\n  CodeCompletionContext(Kind CCKind)\n      : CCKind(CCKind), IsUsingDeclaration(false), SelIdents(None) {}\n\n  /// Construct a new code-completion context of the given kind.\n  CodeCompletionContext(Kind CCKind, QualType T,\n                        ArrayRef<IdentifierInfo *> SelIdents = None)\n      : CCKind(CCKind), IsUsingDeclaration(false), SelIdents(SelIdents) {\n    if (CCKind == CCC_DotMemberAccess || CCKind == CCC_ArrowMemberAccess ||\n        CCKind == CCC_ObjCPropertyAccess || CCKind == CCC_ObjCClassMessage ||\n        CCKind == CCC_ObjCInstanceMessage)\n      BaseType = T;\n    else\n      PreferredType = T;\n  }\n\n  bool isUsingDeclaration() const { return IsUsingDeclaration; }\n  void setIsUsingDeclaration(bool V) { IsUsingDeclaration = V; }\n\n  /// Retrieve the kind of code-completion context.\n  Kind getKind() const { return CCKind; }\n\n  /// Retrieve the type that this expression would prefer to have, e.g.,\n  /// if the expression is a variable initializer or a function argument, the\n  /// type of the corresponding variable or function parameter.\n  QualType getPreferredType() const { return PreferredType; }\n  void setPreferredType(QualType T) { PreferredType = T; }\n\n  /// Retrieve the type of the base object in a member-access\n  /// expression.\n  QualType getBaseType() const { return BaseType; }\n\n  /// Retrieve the Objective-C selector identifiers.\n  ArrayRef<IdentifierInfo *> getSelIdents() const { return SelIdents; }\n\n  /// Determines whether we want C++ constructors as results within this\n  /// context.\n  bool wantConstructorResults() const;\n\n  /// Sets the scope specifier that comes before the completion token.\n  /// This is expected to be set in code completions on qualfied specifiers\n  /// (e.g. \"a::b::\").\n  void setCXXScopeSpecifier(CXXScopeSpec SS) {\n    this->ScopeSpecifier = std::move(SS);\n  }\n\n  /// Adds a visited context.\n  void addVisitedContext(DeclContext *Ctx) {\n    VisitedContexts.insert(Ctx);\n  }\n\n  /// Retrieves all visited contexts.\n  const VisitedContextSet &getVisitedContexts() const {\n    return VisitedContexts;\n  }\n\n  llvm::Optional<const CXXScopeSpec *> getCXXScopeSpecifier() {\n    if (ScopeSpecifier)\n      return ScopeSpecifier.getPointer();\n    return llvm::None;\n  }\n};\n\n/// Get string representation of \\p Kind, useful for for debugging.\nllvm::StringRef getCompletionKindString(CodeCompletionContext::Kind Kind);\n\n/// A \"string\" used to describe how code completion can\n/// be performed for an entity.\n///\n/// A code completion string typically shows how a particular entity can be\n/// used. For example, the code completion string for a function would show\n/// the syntax to call it, including the parentheses, placeholders for the\n/// arguments, etc.\nclass CodeCompletionString {\npublic:\n  /// The different kinds of \"chunks\" that can occur within a code\n  /// completion string.\n  enum ChunkKind {\n    /// The piece of text that the user is expected to type to\n    /// match the code-completion string, typically a keyword or the name of a\n    /// declarator or macro.\n    CK_TypedText,\n\n    /// A piece of text that should be placed in the buffer, e.g.,\n    /// parentheses or a comma in a function call.\n    CK_Text,\n\n    /// A code completion string that is entirely optional. For example,\n    /// an optional code completion string that describes the default arguments\n    /// in a function call.\n    CK_Optional,\n\n    /// A string that acts as a placeholder for, e.g., a function\n    /// call argument.\n    CK_Placeholder,\n\n    /// A piece of text that describes something about the result but\n    /// should not be inserted into the buffer.\n    CK_Informative,\n    /// A piece of text that describes the type of an entity or, for\n    /// functions and methods, the return type.\n    CK_ResultType,\n\n    /// A piece of text that describes the parameter that corresponds\n    /// to the code-completion location within a function call, message send,\n    /// macro invocation, etc.\n    CK_CurrentParameter,\n\n    /// A left parenthesis ('(').\n    CK_LeftParen,\n\n    /// A right parenthesis (')').\n    CK_RightParen,\n\n    /// A left bracket ('[').\n    CK_LeftBracket,\n\n    /// A right bracket (']').\n    CK_RightBracket,\n\n    /// A left brace ('{').\n    CK_LeftBrace,\n\n    /// A right brace ('}').\n    CK_RightBrace,\n\n    /// A left angle bracket ('<').\n    CK_LeftAngle,\n\n    /// A right angle bracket ('>').\n    CK_RightAngle,\n\n    /// A comma separator (',').\n    CK_Comma,\n\n    /// A colon (':').\n    CK_Colon,\n\n    /// A semicolon (';').\n    CK_SemiColon,\n\n    /// An '=' sign.\n    CK_Equal,\n\n    /// Horizontal whitespace (' ').\n    CK_HorizontalSpace,\n\n    /// Vertical whitespace ('\\\\n' or '\\\\r\\\\n', depending on the\n    /// platform).\n    CK_VerticalSpace\n  };\n\n  /// One piece of the code completion string.\n  struct Chunk {\n    /// The kind of data stored in this piece of the code completion\n    /// string.\n    ChunkKind Kind = CK_Text;\n\n    union {\n      /// The text string associated with a CK_Text, CK_Placeholder,\n      /// CK_Informative, or CK_Comma chunk.\n      /// The string is owned by the chunk and will be deallocated\n      /// (with delete[]) when the chunk is destroyed.\n      const char *Text;\n\n      /// The code completion string associated with a CK_Optional chunk.\n      /// The optional code completion string is owned by the chunk, and will\n      /// be deallocated (with delete) when the chunk is destroyed.\n      CodeCompletionString *Optional;\n    };\n\n    Chunk() : Text(nullptr) {}\n\n    explicit Chunk(ChunkKind Kind, const char *Text = \"\");\n\n    /// Create a new text chunk.\n    static Chunk CreateText(const char *Text);\n\n    /// Create a new optional chunk.\n    static Chunk CreateOptional(CodeCompletionString *Optional);\n\n    /// Create a new placeholder chunk.\n    static Chunk CreatePlaceholder(const char *Placeholder);\n\n    /// Create a new informative chunk.\n    static Chunk CreateInformative(const char *Informative);\n\n    /// Create a new result type chunk.\n    static Chunk CreateResultType(const char *ResultType);\n\n    /// Create a new current-parameter chunk.\n    static Chunk CreateCurrentParameter(const char *CurrentParameter);\n  };\n\nprivate:\n  friend class CodeCompletionBuilder;\n  friend class CodeCompletionResult;\n\n  /// The number of chunks stored in this string.\n  unsigned NumChunks : 16;\n\n  /// The number of annotations for this code-completion result.\n  unsigned NumAnnotations : 16;\n\n  /// The priority of this code-completion string.\n  unsigned Priority : 16;\n\n  /// The availability of this code-completion result.\n  unsigned Availability : 2;\n\n  /// The name of the parent context.\n  StringRef ParentName;\n\n  /// A brief documentation comment attached to the declaration of\n  /// entity being completed by this result.\n  const char *BriefComment;\n\n  CodeCompletionString(const Chunk *Chunks, unsigned NumChunks,\n                       unsigned Priority, CXAvailabilityKind Availability,\n                       const char **Annotations, unsigned NumAnnotations,\n                       StringRef ParentName,\n                       const char *BriefComment);\n  ~CodeCompletionString() = default;\n\npublic:\n  CodeCompletionString(const CodeCompletionString &) = delete;\n  CodeCompletionString &operator=(const CodeCompletionString &) = delete;\n\n  using iterator = const Chunk *;\n\n  iterator begin() const { return reinterpret_cast<const Chunk *>(this + 1); }\n  iterator end() const { return begin() + NumChunks; }\n  bool empty() const { return NumChunks == 0; }\n  unsigned size() const { return NumChunks; }\n\n  const Chunk &operator[](unsigned I) const {\n    assert(I < size() && \"Chunk index out-of-range\");\n    return begin()[I];\n  }\n\n  /// Returns the text in the TypedText chunk.\n  const char *getTypedText() const;\n\n  /// Retrieve the priority of this code completion result.\n  unsigned getPriority() const { return Priority; }\n\n  /// Retrieve the availability of this code completion result.\n  unsigned getAvailability() const { return Availability; }\n\n  /// Retrieve the number of annotations for this code completion result.\n  unsigned getAnnotationCount() const;\n\n  /// Retrieve the annotation string specified by \\c AnnotationNr.\n  const char *getAnnotation(unsigned AnnotationNr) const;\n\n  /// Retrieve the name of the parent context.\n  StringRef getParentContextName() const {\n    return ParentName;\n  }\n\n  const char *getBriefComment() const {\n    return BriefComment;\n  }\n\n  /// Retrieve a string representation of the code completion string,\n  /// which is mainly useful for debugging.\n  std::string getAsString() const;\n};\n\n/// An allocator used specifically for the purpose of code completion.\nclass CodeCompletionAllocator : public llvm::BumpPtrAllocator {\npublic:\n  /// Copy the given string into this allocator.\n  const char *CopyString(const Twine &String);\n};\n\n/// Allocator for a cached set of global code completions.\nclass GlobalCodeCompletionAllocator : public CodeCompletionAllocator {};\n\nclass CodeCompletionTUInfo {\n  llvm::DenseMap<const DeclContext *, StringRef> ParentNames;\n  std::shared_ptr<GlobalCodeCompletionAllocator> AllocatorRef;\n\npublic:\n  explicit CodeCompletionTUInfo(\n      std::shared_ptr<GlobalCodeCompletionAllocator> Allocator)\n      : AllocatorRef(std::move(Allocator)) {}\n\n  std::shared_ptr<GlobalCodeCompletionAllocator> getAllocatorRef() const {\n    return AllocatorRef;\n  }\n\n  CodeCompletionAllocator &getAllocator() const {\n    assert(AllocatorRef);\n    return *AllocatorRef;\n  }\n\n  StringRef getParentName(const DeclContext *DC);\n};\n\n} // namespace clang\n\nnamespace clang {\n\n/// A builder class used to construct new code-completion strings.\nclass CodeCompletionBuilder {\npublic:\n  using Chunk = CodeCompletionString::Chunk;\n\nprivate:\n  CodeCompletionAllocator &Allocator;\n  CodeCompletionTUInfo &CCTUInfo;\n  unsigned Priority = 0;\n  CXAvailabilityKind Availability = CXAvailability_Available;\n  StringRef ParentName;\n  const char *BriefComment = nullptr;\n\n  /// The chunks stored in this string.\n  SmallVector<Chunk, 4> Chunks;\n\n  SmallVector<const char *, 2> Annotations;\n\npublic:\n  CodeCompletionBuilder(CodeCompletionAllocator &Allocator,\n                        CodeCompletionTUInfo &CCTUInfo)\n      : Allocator(Allocator), CCTUInfo(CCTUInfo) {}\n\n  CodeCompletionBuilder(CodeCompletionAllocator &Allocator,\n                        CodeCompletionTUInfo &CCTUInfo,\n                        unsigned Priority, CXAvailabilityKind Availability)\n      : Allocator(Allocator), CCTUInfo(CCTUInfo), Priority(Priority),\n        Availability(Availability) {}\n\n  /// Retrieve the allocator into which the code completion\n  /// strings should be allocated.\n  CodeCompletionAllocator &getAllocator() const { return Allocator; }\n\n  CodeCompletionTUInfo &getCodeCompletionTUInfo() const { return CCTUInfo; }\n\n  /// Take the resulting completion string.\n  ///\n  /// This operation can only be performed once.\n  CodeCompletionString *TakeString();\n\n  /// Add a new typed-text chunk.\n  void AddTypedTextChunk(const char *Text);\n\n  /// Add a new text chunk.\n  void AddTextChunk(const char *Text);\n\n  /// Add a new optional chunk.\n  void AddOptionalChunk(CodeCompletionString *Optional);\n\n  /// Add a new placeholder chunk.\n  void AddPlaceholderChunk(const char *Placeholder);\n\n  /// Add a new informative chunk.\n  void AddInformativeChunk(const char *Text);\n\n  /// Add a new result-type chunk.\n  void AddResultTypeChunk(const char *ResultType);\n\n  /// Add a new current-parameter chunk.\n  void AddCurrentParameterChunk(const char *CurrentParameter);\n\n  /// Add a new chunk.\n  void AddChunk(CodeCompletionString::ChunkKind CK, const char *Text = \"\");\n\n  void AddAnnotation(const char *A) { Annotations.push_back(A); }\n\n  /// Add the parent context information to this code completion.\n  void addParentContext(const DeclContext *DC);\n\n  const char *getBriefComment() const { return BriefComment; }\n  void addBriefComment(StringRef Comment);\n\n  StringRef getParentName() const { return ParentName; }\n};\n\n/// Captures a result of code completion.\nclass CodeCompletionResult {\npublic:\n  /// Describes the kind of result generated.\n  enum ResultKind {\n    /// Refers to a declaration.\n    RK_Declaration = 0,\n\n    /// Refers to a keyword or symbol.\n    RK_Keyword,\n\n    /// Refers to a macro.\n    RK_Macro,\n\n    /// Refers to a precomputed pattern.\n    RK_Pattern\n  };\n\n  /// When Kind == RK_Declaration or RK_Pattern, the declaration we are\n  /// referring to. In the latter case, the declaration might be NULL.\n  const NamedDecl *Declaration = nullptr;\n\n  union {\n    /// When Kind == RK_Keyword, the string representing the keyword\n    /// or symbol's spelling.\n    const char *Keyword;\n\n    /// When Kind == RK_Pattern, the code-completion string that\n    /// describes the completion text to insert.\n    CodeCompletionString *Pattern;\n\n    /// When Kind == RK_Macro, the identifier that refers to a macro.\n    const IdentifierInfo *Macro;\n  };\n\n  /// The priority of this particular code-completion result.\n  unsigned Priority;\n\n  /// Specifies which parameter (of a function, Objective-C method,\n  /// macro, etc.) we should start with when formatting the result.\n  unsigned StartParameter = 0;\n\n  /// The kind of result stored here.\n  ResultKind Kind;\n\n  /// The cursor kind that describes this result.\n  CXCursorKind CursorKind;\n\n  /// The availability of this result.\n  CXAvailabilityKind Availability = CXAvailability_Available;\n\n  /// Fix-its that *must* be applied before inserting the text for the\n  /// corresponding completion.\n  ///\n  /// By default, CodeCompletionBuilder only returns completions with empty\n  /// fix-its. Extra completions with non-empty fix-its should be explicitly\n  /// requested by setting CompletionOptions::IncludeFixIts.\n  ///\n  /// For the clients to be able to compute position of the cursor after\n  /// applying fix-its, the following conditions are guaranteed to hold for\n  /// RemoveRange of the stored fix-its:\n  ///  - Ranges in the fix-its are guaranteed to never contain the completion\n  ///  point (or identifier under completion point, if any) inside them, except\n  ///  at the start or at the end of the range.\n  ///  - If a fix-it range starts or ends with completion point (or starts or\n  ///  ends after the identifier under completion point), it will contain at\n  ///  least one character. It allows to unambiguously recompute completion\n  ///  point after applying the fix-it.\n  ///\n  /// The intuition is that provided fix-its change code around the identifier\n  /// we complete, but are not allowed to touch the identifier itself or the\n  /// completion point. One example of completions with corrections are the ones\n  /// replacing '.' with '->' and vice versa:\n  ///\n  /// std::unique_ptr<std::vector<int>> vec_ptr;\n  /// In 'vec_ptr.^', one of the completions is 'push_back', it requires\n  /// replacing '.' with '->'.\n  /// In 'vec_ptr->^', one of the completions is 'release', it requires\n  /// replacing '->' with '.'.\n  std::vector<FixItHint> FixIts;\n\n  /// Whether this result is hidden by another name.\n  bool Hidden : 1;\n\n  /// Whether this is a class member from base class.\n  bool InBaseClass : 1;\n\n  /// Whether this result was found via lookup into a base class.\n  bool QualifierIsInformative : 1;\n\n  /// Whether this declaration is the beginning of a\n  /// nested-name-specifier and, therefore, should be followed by '::'.\n  bool StartsNestedNameSpecifier : 1;\n\n  /// Whether all parameters (of a function, Objective-C\n  /// method, etc.) should be considered \"informative\".\n  bool AllParametersAreInformative : 1;\n\n  /// Whether we're completing a declaration of the given entity,\n  /// rather than a use of that entity.\n  bool DeclaringEntity : 1;\n\n  /// If the result should have a nested-name-specifier, this is it.\n  /// When \\c QualifierIsInformative, the nested-name-specifier is\n  /// informative rather than required.\n  NestedNameSpecifier *Qualifier = nullptr;\n\n  /// If this Decl was unshadowed by using declaration, this can store a\n  /// pointer to the UsingShadowDecl which was used in the unshadowing process.\n  /// This information can be used to uprank CodeCompletionResults / which have\n  /// corresponding `using decl::qualified::name;` nearby.\n  const UsingShadowDecl *ShadowDecl = nullptr;\n\n  /// If the result is RK_Macro, this can store the information about the macro\n  /// definition. This should be set in most cases but can be missing when\n  /// the macro has been undefined.\n  const MacroInfo *MacroDefInfo = nullptr;\n\n  /// Build a result that refers to a declaration.\n  CodeCompletionResult(const NamedDecl *Declaration, unsigned Priority,\n                       NestedNameSpecifier *Qualifier = nullptr,\n                       bool QualifierIsInformative = false,\n                       bool Accessible = true,\n                       std::vector<FixItHint> FixIts = std::vector<FixItHint>())\n      : Declaration(Declaration), Priority(Priority), Kind(RK_Declaration),\n        FixIts(std::move(FixIts)), Hidden(false), InBaseClass(false),\n        QualifierIsInformative(QualifierIsInformative),\n        StartsNestedNameSpecifier(false), AllParametersAreInformative(false),\n        DeclaringEntity(false), Qualifier(Qualifier) {\n    // FIXME: Add assert to check FixIts range requirements.\n    computeCursorKindAndAvailability(Accessible);\n  }\n\n  /// Build a result that refers to a keyword or symbol.\n  CodeCompletionResult(const char *Keyword, unsigned Priority = CCP_Keyword)\n      : Keyword(Keyword), Priority(Priority), Kind(RK_Keyword),\n        CursorKind(CXCursor_NotImplemented), Hidden(false), InBaseClass(false),\n        QualifierIsInformative(false), StartsNestedNameSpecifier(false),\n        AllParametersAreInformative(false), DeclaringEntity(false) {}\n\n  /// Build a result that refers to a macro.\n  CodeCompletionResult(const IdentifierInfo *Macro,\n                       const MacroInfo *MI = nullptr,\n                       unsigned Priority = CCP_Macro)\n      : Macro(Macro), Priority(Priority), Kind(RK_Macro),\n        CursorKind(CXCursor_MacroDefinition), Hidden(false), InBaseClass(false),\n        QualifierIsInformative(false), StartsNestedNameSpecifier(false),\n        AllParametersAreInformative(false), DeclaringEntity(false),\n        MacroDefInfo(MI) {}\n\n  /// Build a result that refers to a pattern.\n  CodeCompletionResult(\n      CodeCompletionString *Pattern, unsigned Priority = CCP_CodePattern,\n      CXCursorKind CursorKind = CXCursor_NotImplemented,\n      CXAvailabilityKind Availability = CXAvailability_Available,\n      const NamedDecl *D = nullptr)\n      : Declaration(D), Pattern(Pattern), Priority(Priority), Kind(RK_Pattern),\n        CursorKind(CursorKind), Availability(Availability), Hidden(false),\n        InBaseClass(false), QualifierIsInformative(false),\n        StartsNestedNameSpecifier(false), AllParametersAreInformative(false),\n        DeclaringEntity(false) {}\n\n  /// Build a result that refers to a pattern with an associated\n  /// declaration.\n  CodeCompletionResult(CodeCompletionString *Pattern, const NamedDecl *D,\n                       unsigned Priority)\n      : Declaration(D), Pattern(Pattern), Priority(Priority), Kind(RK_Pattern),\n        Hidden(false), InBaseClass(false), QualifierIsInformative(false),\n        StartsNestedNameSpecifier(false), AllParametersAreInformative(false),\n        DeclaringEntity(false) {\n    computeCursorKindAndAvailability();\n  }\n\n  /// Retrieve the declaration stored in this result. This might be nullptr if\n  /// Kind is RK_Pattern.\n  const NamedDecl *getDeclaration() const {\n    assert(((Kind == RK_Declaration) || (Kind == RK_Pattern)) &&\n           \"Not a declaration or pattern result\");\n    return Declaration;\n  }\n\n  /// Retrieve the keyword stored in this result.\n  const char *getKeyword() const {\n    assert(Kind == RK_Keyword && \"Not a keyword result\");\n    return Keyword;\n  }\n\n  /// Create a new code-completion string that describes how to insert\n  /// this result into a program.\n  ///\n  /// \\param S The semantic analysis that created the result.\n  ///\n  /// \\param Allocator The allocator that will be used to allocate the\n  /// string itself.\n  CodeCompletionString *CreateCodeCompletionString(Sema &S,\n                                         const CodeCompletionContext &CCContext,\n                                           CodeCompletionAllocator &Allocator,\n                                           CodeCompletionTUInfo &CCTUInfo,\n                                           bool IncludeBriefComments);\n  CodeCompletionString *CreateCodeCompletionString(ASTContext &Ctx,\n                                                   Preprocessor &PP,\n                                         const CodeCompletionContext &CCContext,\n                                           CodeCompletionAllocator &Allocator,\n                                           CodeCompletionTUInfo &CCTUInfo,\n                                           bool IncludeBriefComments);\n  /// Creates a new code-completion string for the macro result. Similar to the\n  /// above overloads, except this only requires preprocessor information.\n  /// The result kind must be `RK_Macro`.\n  CodeCompletionString *\n  CreateCodeCompletionStringForMacro(Preprocessor &PP,\n                                     CodeCompletionAllocator &Allocator,\n                                     CodeCompletionTUInfo &CCTUInfo);\n\n  CodeCompletionString *createCodeCompletionStringForDecl(\n      Preprocessor &PP, ASTContext &Ctx, CodeCompletionBuilder &Result,\n      bool IncludeBriefComments, const CodeCompletionContext &CCContext,\n      PrintingPolicy &Policy);\n\n  CodeCompletionString *createCodeCompletionStringForOverride(\n      Preprocessor &PP, ASTContext &Ctx, CodeCompletionBuilder &Result,\n      bool IncludeBriefComments, const CodeCompletionContext &CCContext,\n      PrintingPolicy &Policy);\n\n  /// Retrieve the name that should be used to order a result.\n  ///\n  /// If the name needs to be constructed as a string, that string will be\n  /// saved into Saved and the returned StringRef will refer to it.\n  StringRef getOrderedName(std::string &Saved) const;\n\nprivate:\n  void computeCursorKindAndAvailability(bool Accessible = true);\n};\n\nbool operator<(const CodeCompletionResult &X, const CodeCompletionResult &Y);\n\ninline bool operator>(const CodeCompletionResult &X,\n                      const CodeCompletionResult &Y) {\n  return Y < X;\n}\n\ninline bool operator<=(const CodeCompletionResult &X,\n                      const CodeCompletionResult &Y) {\n  return !(Y < X);\n}\n\ninline bool operator>=(const CodeCompletionResult &X,\n                       const CodeCompletionResult &Y) {\n  return !(X < Y);\n}\n\n/// Abstract interface for a consumer of code-completion\n/// information.\nclass CodeCompleteConsumer {\nprotected:\n  const CodeCompleteOptions CodeCompleteOpts;\n\npublic:\n  class OverloadCandidate {\n  public:\n    /// Describes the type of overload candidate.\n    enum CandidateKind {\n      /// The candidate is a function declaration.\n      CK_Function,\n\n      /// The candidate is a function template.\n      CK_FunctionTemplate,\n\n      /// The \"candidate\" is actually a variable, expression, or block\n      /// for which we only have a function prototype.\n      CK_FunctionType\n    };\n\n  private:\n    /// The kind of overload candidate.\n    CandidateKind Kind;\n\n    union {\n      /// The function overload candidate, available when\n      /// Kind == CK_Function.\n      FunctionDecl *Function;\n\n      /// The function template overload candidate, available when\n      /// Kind == CK_FunctionTemplate.\n      FunctionTemplateDecl *FunctionTemplate;\n\n      /// The function type that describes the entity being called,\n      /// when Kind == CK_FunctionType.\n      const FunctionType *Type;\n    };\n\n  public:\n    OverloadCandidate(FunctionDecl *Function)\n        : Kind(CK_Function), Function(Function) {}\n\n    OverloadCandidate(FunctionTemplateDecl *FunctionTemplateDecl)\n        : Kind(CK_FunctionTemplate), FunctionTemplate(FunctionTemplateDecl) {}\n\n    OverloadCandidate(const FunctionType *Type)\n        : Kind(CK_FunctionType), Type(Type) {}\n\n    /// Determine the kind of overload candidate.\n    CandidateKind getKind() const { return Kind; }\n\n    /// Retrieve the function overload candidate or the templated\n    /// function declaration for a function template.\n    FunctionDecl *getFunction() const;\n\n    /// Retrieve the function template overload candidate.\n    FunctionTemplateDecl *getFunctionTemplate() const {\n      assert(getKind() == CK_FunctionTemplate && \"Not a function template\");\n      return FunctionTemplate;\n    }\n\n    /// Retrieve the function type of the entity, regardless of how the\n    /// function is stored.\n    const FunctionType *getFunctionType() const;\n\n    /// Create a new code-completion string that describes the function\n    /// signature of this overload candidate.\n    CodeCompletionString *CreateSignatureString(unsigned CurrentArg,\n                                                Sema &S,\n                                      CodeCompletionAllocator &Allocator,\n                                      CodeCompletionTUInfo &CCTUInfo,\n                                      bool IncludeBriefComments) const;\n  };\n\n  CodeCompleteConsumer(const CodeCompleteOptions &CodeCompleteOpts)\n      : CodeCompleteOpts(CodeCompleteOpts) {}\n\n  /// Whether the code-completion consumer wants to see macros.\n  bool includeMacros() const {\n    return CodeCompleteOpts.IncludeMacros;\n  }\n\n  /// Whether the code-completion consumer wants to see code patterns.\n  bool includeCodePatterns() const {\n    return CodeCompleteOpts.IncludeCodePatterns;\n  }\n\n  /// Whether to include global (top-level) declaration results.\n  bool includeGlobals() const { return CodeCompleteOpts.IncludeGlobals; }\n\n  /// Whether to include declarations in namespace contexts (including\n  /// the global namespace). If this is false, `includeGlobals()` will be\n  /// ignored.\n  bool includeNamespaceLevelDecls() const {\n    return CodeCompleteOpts.IncludeNamespaceLevelDecls;\n  }\n\n  /// Whether to include brief documentation comments within the set of\n  /// code completions returned.\n  bool includeBriefComments() const {\n    return CodeCompleteOpts.IncludeBriefComments;\n  }\n\n  /// Whether to include completion items with small fix-its, e.g. change\n  /// '.' to '->' on member access, etc.\n  bool includeFixIts() const { return CodeCompleteOpts.IncludeFixIts; }\n\n  /// Hint whether to load data from the external AST in order to provide\n  /// full results. If false, declarations from the preamble may be omitted.\n  bool loadExternal() const {\n    return CodeCompleteOpts.LoadExternal;\n  }\n\n  /// Deregisters and destroys this code-completion consumer.\n  virtual ~CodeCompleteConsumer();\n\n  /// \\name Code-completion filtering\n  /// Check if the result should be filtered out.\n  virtual bool isResultFilteredOut(StringRef Filter,\n                                   CodeCompletionResult Results) {\n    return false;\n  }\n\n  /// \\name Code-completion callbacks\n  //@{\n  /// Process the finalized code-completion results.\n  virtual void ProcessCodeCompleteResults(Sema &S,\n                                          CodeCompletionContext Context,\n                                          CodeCompletionResult *Results,\n                                          unsigned NumResults) {}\n\n  /// \\param S the semantic-analyzer object for which code-completion is being\n  /// done.\n  ///\n  /// \\param CurrentArg the index of the current argument.\n  ///\n  /// \\param Candidates an array of overload candidates.\n  ///\n  /// \\param NumCandidates the number of overload candidates\n  ///\n  /// \\param OpenParLoc location of the opening parenthesis of the argument\n  ///        list.\n  virtual void ProcessOverloadCandidates(Sema &S, unsigned CurrentArg,\n                                         OverloadCandidate *Candidates,\n                                         unsigned NumCandidates,\n                                         SourceLocation OpenParLoc) {}\n  //@}\n\n  /// Retrieve the allocator that will be used to allocate\n  /// code completion strings.\n  virtual CodeCompletionAllocator &getAllocator() = 0;\n\n  virtual CodeCompletionTUInfo &getCodeCompletionTUInfo() = 0;\n};\n\n/// Get the documentation comment used to produce\n/// CodeCompletionString::BriefComment for RK_Declaration.\nconst RawComment *getCompletionComment(const ASTContext &Ctx,\n                                       const NamedDecl *Decl);\n\n/// Get the documentation comment used to produce\n/// CodeCompletionString::BriefComment for RK_Pattern.\nconst RawComment *getPatternCompletionComment(const ASTContext &Ctx,\n                                              const NamedDecl *Decl);\n\n/// Get the documentation comment used to produce\n/// CodeCompletionString::BriefComment for OverloadCandidate.\nconst RawComment *\ngetParameterComment(const ASTContext &Ctx,\n                    const CodeCompleteConsumer::OverloadCandidate &Result,\n                    unsigned ArgIndex);\n\n/// A simple code-completion consumer that prints the results it\n/// receives in a simple format.\nclass PrintingCodeCompleteConsumer : public CodeCompleteConsumer {\n  /// The raw output stream.\n  raw_ostream &OS;\n\n  CodeCompletionTUInfo CCTUInfo;\n\npublic:\n  /// Create a new printing code-completion consumer that prints its\n  /// results to the given raw output stream.\n  PrintingCodeCompleteConsumer(const CodeCompleteOptions &CodeCompleteOpts,\n                               raw_ostream &OS)\n      : CodeCompleteConsumer(CodeCompleteOpts), OS(OS),\n        CCTUInfo(std::make_shared<GlobalCodeCompletionAllocator>()) {}\n\n  /// Prints the finalized code-completion results.\n  void ProcessCodeCompleteResults(Sema &S, CodeCompletionContext Context,\n                                  CodeCompletionResult *Results,\n                                  unsigned NumResults) override;\n\n  void ProcessOverloadCandidates(Sema &S, unsigned CurrentArg,\n                                 OverloadCandidate *Candidates,\n                                 unsigned NumCandidates,\n                                 SourceLocation OpenParLoc) override;\n\n  bool isResultFilteredOut(StringRef Filter, CodeCompletionResult Results) override;\n\n  CodeCompletionAllocator &getAllocator() override {\n    return CCTUInfo.getAllocator();\n  }\n\n  CodeCompletionTUInfo &getCodeCompletionTUInfo() override { return CCTUInfo; }\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_SEMA_CODECOMPLETECONSUMER_H\n"}, "89": {"id": 89, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/CodeCompleteOptions.h", "content": "//===---- CodeCompleteOptions.h - Code Completion Options -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SEMA_CODECOMPLETEOPTIONS_H\n#define LLVM_CLANG_SEMA_CODECOMPLETEOPTIONS_H\n\nnamespace clang {\n\n/// Options controlling the behavior of code completion.\nclass CodeCompleteOptions {\npublic:\n  /// Show macros in code completion results.\n  unsigned IncludeMacros : 1;\n\n  /// Show code patterns in code completion results.\n  unsigned IncludeCodePatterns : 1;\n\n  /// Show top-level decls in code completion results.\n  unsigned IncludeGlobals : 1;\n\n  /// Show decls in namespace (including the global namespace) in code\n  /// completion results. If this is 0, `IncludeGlobals` will be ignored.\n  ///\n  /// Currently, this only works when completing qualified IDs (i.e.\n  /// `Sema::CodeCompleteQualifiedId`).\n  /// FIXME: consider supporting more completion cases with this option.\n  unsigned IncludeNamespaceLevelDecls : 1;\n\n  /// Show brief documentation comments in code completion results.\n  unsigned IncludeBriefComments : 1;\n\n  /// Hint whether to load data from the external AST to provide full results.\n  /// If false, namespace-level declarations and macros from the preamble may be\n  /// omitted.\n  unsigned LoadExternal : 1;\n\n  /// Include results after corrections (small fix-its), e.g. change '.' to '->'\n  /// on member access, etc.\n  unsigned IncludeFixIts : 1;\n\n  CodeCompleteOptions()\n      : IncludeMacros(0), IncludeCodePatterns(0), IncludeGlobals(1),\n        IncludeNamespaceLevelDecls(1), IncludeBriefComments(0),\n        LoadExternal(1), IncludeFixIts(0) {}\n};\n\n} // namespace clang\n\n#endif\n\n"}, "90": {"id": 90, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/DeclSpec.h", "content": "//===--- DeclSpec.h - Parsed declaration specifiers -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// This file defines the classes used to store parsed information about\n/// declaration-specifiers and declarators.\n///\n/// \\verbatim\n///   static const int volatile x, *y, *(*(*z)[10])(const void *x);\n///   ------------------------- -  --  ---------------------------\n///     declaration-specifiers  \\  |   /\n///                            declarators\n/// \\endverbatim\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SEMA_DECLSPEC_H\n#define LLVM_CLANG_SEMA_DECLSPEC_H\n\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclObjCCommon.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/Basic/ExceptionSpecificationType.h\"\n#include \"clang/Basic/Lambda.h\"\n#include \"clang/Basic/OperatorKinds.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Lex/Token.h\"\n#include \"clang/Sema/Ownership.h\"\n#include \"clang/Sema/ParsedAttr.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n\nnamespace clang {\n  class ASTContext;\n  class CXXRecordDecl;\n  class TypeLoc;\n  class LangOptions;\n  class IdentifierInfo;\n  class NamespaceAliasDecl;\n  class NamespaceDecl;\n  class ObjCDeclSpec;\n  class Sema;\n  class Declarator;\n  struct TemplateIdAnnotation;\n\n/// Represents a C++ nested-name-specifier or a global scope specifier.\n///\n/// These can be in 3 states:\n///   1) Not present, identified by isEmpty()\n///   2) Present, identified by isNotEmpty()\n///      2.a) Valid, identified by isValid()\n///      2.b) Invalid, identified by isInvalid().\n///\n/// isSet() is deprecated because it mostly corresponded to \"valid\" but was\n/// often used as if it meant \"present\".\n///\n/// The actual scope is described by getScopeRep().\nclass CXXScopeSpec {\n  SourceRange Range;\n  NestedNameSpecifierLocBuilder Builder;\n\npublic:\n  SourceRange getRange() const { return Range; }\n  void setRange(SourceRange R) { Range = R; }\n  void setBeginLoc(SourceLocation Loc) { Range.setBegin(Loc); }\n  void setEndLoc(SourceLocation Loc) { Range.setEnd(Loc); }\n  SourceLocation getBeginLoc() const { return Range.getBegin(); }\n  SourceLocation getEndLoc() const { return Range.getEnd(); }\n\n  /// Retrieve the representation of the nested-name-specifier.\n  NestedNameSpecifier *getScopeRep() const {\n    return Builder.getRepresentation();\n  }\n\n  /// Extend the current nested-name-specifier by another\n  /// nested-name-specifier component of the form 'type::'.\n  ///\n  /// \\param Context The AST context in which this nested-name-specifier\n  /// resides.\n  ///\n  /// \\param TemplateKWLoc The location of the 'template' keyword, if present.\n  ///\n  /// \\param TL The TypeLoc that describes the type preceding the '::'.\n  ///\n  /// \\param ColonColonLoc The location of the trailing '::'.\n  void Extend(ASTContext &Context, SourceLocation TemplateKWLoc, TypeLoc TL,\n              SourceLocation ColonColonLoc);\n\n  /// Extend the current nested-name-specifier by another\n  /// nested-name-specifier component of the form 'identifier::'.\n  ///\n  /// \\param Context The AST context in which this nested-name-specifier\n  /// resides.\n  ///\n  /// \\param Identifier The identifier.\n  ///\n  /// \\param IdentifierLoc The location of the identifier.\n  ///\n  /// \\param ColonColonLoc The location of the trailing '::'.\n  void Extend(ASTContext &Context, IdentifierInfo *Identifier,\n              SourceLocation IdentifierLoc, SourceLocation ColonColonLoc);\n\n  /// Extend the current nested-name-specifier by another\n  /// nested-name-specifier component of the form 'namespace::'.\n  ///\n  /// \\param Context The AST context in which this nested-name-specifier\n  /// resides.\n  ///\n  /// \\param Namespace The namespace.\n  ///\n  /// \\param NamespaceLoc The location of the namespace name.\n  ///\n  /// \\param ColonColonLoc The location of the trailing '::'.\n  void Extend(ASTContext &Context, NamespaceDecl *Namespace,\n              SourceLocation NamespaceLoc, SourceLocation ColonColonLoc);\n\n  /// Extend the current nested-name-specifier by another\n  /// nested-name-specifier component of the form 'namespace-alias::'.\n  ///\n  /// \\param Context The AST context in which this nested-name-specifier\n  /// resides.\n  ///\n  /// \\param Alias The namespace alias.\n  ///\n  /// \\param AliasLoc The location of the namespace alias\n  /// name.\n  ///\n  /// \\param ColonColonLoc The location of the trailing '::'.\n  void Extend(ASTContext &Context, NamespaceAliasDecl *Alias,\n              SourceLocation AliasLoc, SourceLocation ColonColonLoc);\n\n  /// Turn this (empty) nested-name-specifier into the global\n  /// nested-name-specifier '::'.\n  void MakeGlobal(ASTContext &Context, SourceLocation ColonColonLoc);\n\n  /// Turns this (empty) nested-name-specifier into '__super'\n  /// nested-name-specifier.\n  ///\n  /// \\param Context The AST context in which this nested-name-specifier\n  /// resides.\n  ///\n  /// \\param RD The declaration of the class in which nested-name-specifier\n  /// appeared.\n  ///\n  /// \\param SuperLoc The location of the '__super' keyword.\n  /// name.\n  ///\n  /// \\param ColonColonLoc The location of the trailing '::'.\n  void MakeSuper(ASTContext &Context, CXXRecordDecl *RD,\n                 SourceLocation SuperLoc, SourceLocation ColonColonLoc);\n\n  /// Make a new nested-name-specifier from incomplete source-location\n  /// information.\n  ///\n  /// FIXME: This routine should be used very, very rarely, in cases where we\n  /// need to synthesize a nested-name-specifier. Most code should instead use\n  /// \\c Adopt() with a proper \\c NestedNameSpecifierLoc.\n  void MakeTrivial(ASTContext &Context, NestedNameSpecifier *Qualifier,\n                   SourceRange R);\n\n  /// Adopt an existing nested-name-specifier (with source-range\n  /// information).\n  void Adopt(NestedNameSpecifierLoc Other);\n\n  /// Retrieve a nested-name-specifier with location information, copied\n  /// into the given AST context.\n  ///\n  /// \\param Context The context into which this nested-name-specifier will be\n  /// copied.\n  NestedNameSpecifierLoc getWithLocInContext(ASTContext &Context) const;\n\n  /// Retrieve the location of the name in the last qualifier\n  /// in this nested name specifier.\n  ///\n  /// For example, the location of \\c bar\n  /// in\n  /// \\verbatim\n  ///   \\::foo::bar<0>::\n  ///           ^~~\n  /// \\endverbatim\n  SourceLocation getLastQualifierNameLoc() const;\n\n  /// No scope specifier.\n  bool isEmpty() const { return Range.isInvalid() && getScopeRep() == nullptr; }\n  /// A scope specifier is present, but may be valid or invalid.\n  bool isNotEmpty() const { return !isEmpty(); }\n\n  /// An error occurred during parsing of the scope specifier.\n  bool isInvalid() const { return Range.isValid() && getScopeRep() == nullptr; }\n  /// A scope specifier is present, and it refers to a real scope.\n  bool isValid() const { return getScopeRep() != nullptr; }\n\n  /// Indicate that this nested-name-specifier is invalid.\n  void SetInvalid(SourceRange R) {\n    assert(R.isValid() && \"Must have a valid source range\");\n    if (Range.getBegin().isInvalid())\n      Range.setBegin(R.getBegin());\n    Range.setEnd(R.getEnd());\n    Builder.Clear();\n  }\n\n  /// Deprecated.  Some call sites intend isNotEmpty() while others intend\n  /// isValid().\n  bool isSet() const { return getScopeRep() != nullptr; }\n\n  void clear() {\n    Range = SourceRange();\n    Builder.Clear();\n  }\n\n  /// Retrieve the data associated with the source-location information.\n  char *location_data() const { return Builder.getBuffer().first; }\n\n  /// Retrieve the size of the data associated with source-location\n  /// information.\n  unsigned location_size() const { return Builder.getBuffer().second; }\n};\n\n/// Captures information about \"declaration specifiers\".\n///\n/// \"Declaration specifiers\" encompasses storage-class-specifiers,\n/// type-specifiers, type-qualifiers, and function-specifiers.\nclass DeclSpec {\npublic:\n  /// storage-class-specifier\n  /// \\note The order of these enumerators is important for diagnostics.\n  enum SCS {\n    SCS_unspecified = 0,\n    SCS_typedef,\n    SCS_extern,\n    SCS_static,\n    SCS_auto,\n    SCS_register,\n    SCS_private_extern,\n    SCS_mutable\n  };\n\n  // Import thread storage class specifier enumeration and constants.\n  // These can be combined with SCS_extern and SCS_static.\n  typedef ThreadStorageClassSpecifier TSCS;\n  static const TSCS TSCS_unspecified = clang::TSCS_unspecified;\n  static const TSCS TSCS___thread = clang::TSCS___thread;\n  static const TSCS TSCS_thread_local = clang::TSCS_thread_local;\n  static const TSCS TSCS__Thread_local = clang::TSCS__Thread_local;\n\n  enum TSC {\n    TSC_unspecified,\n    TSC_imaginary,\n    TSC_complex\n  };\n\n  // Import type specifier type enumeration and constants.\n  typedef TypeSpecifierType TST;\n  static const TST TST_unspecified = clang::TST_unspecified;\n  static const TST TST_void = clang::TST_void;\n  static const TST TST_char = clang::TST_char;\n  static const TST TST_wchar = clang::TST_wchar;\n  static const TST TST_char8 = clang::TST_char8;\n  static const TST TST_char16 = clang::TST_char16;\n  static const TST TST_char32 = clang::TST_char32;\n  static const TST TST_int = clang::TST_int;\n  static const TST TST_int128 = clang::TST_int128;\n  static const TST TST_extint = clang::TST_extint;\n  static const TST TST_half = clang::TST_half;\n  static const TST TST_BFloat16 = clang::TST_BFloat16;\n  static const TST TST_float = clang::TST_float;\n  static const TST TST_double = clang::TST_double;\n  static const TST TST_float16 = clang::TST_Float16;\n  static const TST TST_accum = clang::TST_Accum;\n  static const TST TST_fract = clang::TST_Fract;\n  static const TST TST_float128 = clang::TST_float128;\n  static const TST TST_bool = clang::TST_bool;\n  static const TST TST_decimal32 = clang::TST_decimal32;\n  static const TST TST_decimal64 = clang::TST_decimal64;\n  static const TST TST_decimal128 = clang::TST_decimal128;\n  static const TST TST_enum = clang::TST_enum;\n  static const TST TST_union = clang::TST_union;\n  static const TST TST_struct = clang::TST_struct;\n  static const TST TST_interface = clang::TST_interface;\n  static const TST TST_class = clang::TST_class;\n  static const TST TST_typename = clang::TST_typename;\n  static const TST TST_typeofType = clang::TST_typeofType;\n  static const TST TST_typeofExpr = clang::TST_typeofExpr;\n  static const TST TST_decltype = clang::TST_decltype;\n  static const TST TST_decltype_auto = clang::TST_decltype_auto;\n  static const TST TST_underlyingType = clang::TST_underlyingType;\n  static const TST TST_auto = clang::TST_auto;\n  static const TST TST_auto_type = clang::TST_auto_type;\n  static const TST TST_unknown_anytype = clang::TST_unknown_anytype;\n  static const TST TST_atomic = clang::TST_atomic;\n#define GENERIC_IMAGE_TYPE(ImgType, Id) \\\n  static const TST TST_##ImgType##_t = clang::TST_##ImgType##_t;\n#include \"clang/Basic/OpenCLImageTypes.def\"\n  static const TST TST_error = clang::TST_error;\n\n  // type-qualifiers\n  enum TQ {   // NOTE: These flags must be kept in sync with Qualifiers::TQ.\n    TQ_unspecified = 0,\n    TQ_const       = 1,\n    TQ_restrict    = 2,\n    TQ_volatile    = 4,\n    TQ_unaligned   = 8,\n    // This has no corresponding Qualifiers::TQ value, because it's not treated\n    // as a qualifier in our type system.\n    TQ_atomic      = 16\n  };\n\n  /// ParsedSpecifiers - Flags to query which specifiers were applied.  This is\n  /// returned by getParsedSpecifiers.\n  enum ParsedSpecifiers {\n    PQ_None                  = 0,\n    PQ_StorageClassSpecifier = 1,\n    PQ_TypeSpecifier         = 2,\n    PQ_TypeQualifier         = 4,\n    PQ_FunctionSpecifier     = 8\n    // FIXME: Attributes should be included here.\n  };\n\nprivate:\n  // storage-class-specifier\n  /*SCS*/unsigned StorageClassSpec : 3;\n  /*TSCS*/unsigned ThreadStorageClassSpec : 2;\n  unsigned SCS_extern_in_linkage_spec : 1;\n\n  // type-specifier\n  /*TypeSpecifierWidth*/ unsigned TypeSpecWidth : 2;\n  /*TSC*/unsigned TypeSpecComplex : 2;\n  /*TSS*/unsigned TypeSpecSign : 2;\n  /*TST*/unsigned TypeSpecType : 6;\n  unsigned TypeAltiVecVector : 1;\n  unsigned TypeAltiVecPixel : 1;\n  unsigned TypeAltiVecBool : 1;\n  unsigned TypeSpecOwned : 1;\n  unsigned TypeSpecPipe : 1;\n  unsigned TypeSpecSat : 1;\n  unsigned ConstrainedAuto : 1;\n\n  // type-qualifiers\n  unsigned TypeQualifiers : 5;  // Bitwise OR of TQ.\n\n  // function-specifier\n  unsigned FS_inline_specified : 1;\n  unsigned FS_forceinline_specified: 1;\n  unsigned FS_virtual_specified : 1;\n  unsigned FS_noreturn_specified : 1;\n\n  // friend-specifier\n  unsigned Friend_specified : 1;\n\n  // constexpr-specifier\n  unsigned ConstexprSpecifier : 2;\n\n  union {\n    UnionParsedType TypeRep;\n    Decl *DeclRep;\n    Expr *ExprRep;\n    TemplateIdAnnotation *TemplateIdRep;\n  };\n\n  /// ExplicitSpecifier - Store information about explicit spicifer.\n  ExplicitSpecifier FS_explicit_specifier;\n\n  // attributes.\n  ParsedAttributes Attrs;\n\n  // Scope specifier for the type spec, if applicable.\n  CXXScopeSpec TypeScope;\n\n  // SourceLocation info.  These are null if the item wasn't specified or if\n  // the setting was synthesized.\n  SourceRange Range;\n\n  SourceLocation StorageClassSpecLoc, ThreadStorageClassSpecLoc;\n  SourceRange TSWRange;\n  SourceLocation TSCLoc, TSSLoc, TSTLoc, AltiVecLoc, TSSatLoc;\n  /// TSTNameLoc - If TypeSpecType is any of class, enum, struct, union,\n  /// typename, then this is the location of the named type (if present);\n  /// otherwise, it is the same as TSTLoc. Hence, the pair TSTLoc and\n  /// TSTNameLoc provides source range info for tag types.\n  SourceLocation TSTNameLoc;\n  SourceRange TypeofParensRange;\n  SourceLocation TQ_constLoc, TQ_restrictLoc, TQ_volatileLoc, TQ_atomicLoc,\n      TQ_unalignedLoc;\n  SourceLocation FS_inlineLoc, FS_virtualLoc, FS_explicitLoc, FS_noreturnLoc;\n  SourceLocation FS_explicitCloseParenLoc;\n  SourceLocation FS_forceinlineLoc;\n  SourceLocation FriendLoc, ModulePrivateLoc, ConstexprLoc;\n  SourceLocation TQ_pipeLoc;\n\n  WrittenBuiltinSpecs writtenBS;\n  void SaveWrittenBuiltinSpecs();\n\n  ObjCDeclSpec *ObjCQualifiers;\n\n  static bool isTypeRep(TST T) {\n    return (T == TST_typename || T == TST_typeofType ||\n            T == TST_underlyingType || T == TST_atomic);\n  }\n  static bool isExprRep(TST T) {\n    return (T == TST_typeofExpr || T == TST_decltype || T == TST_extint);\n  }\n  static bool isTemplateIdRep(TST T) {\n    return (T == TST_auto || T == TST_decltype_auto);\n  }\n\n  DeclSpec(const DeclSpec &) = delete;\n  void operator=(const DeclSpec &) = delete;\npublic:\n  static bool isDeclRep(TST T) {\n    return (T == TST_enum || T == TST_struct ||\n            T == TST_interface || T == TST_union ||\n            T == TST_class);\n  }\n\n  DeclSpec(AttributeFactory &attrFactory)\n      : StorageClassSpec(SCS_unspecified),\n        ThreadStorageClassSpec(TSCS_unspecified),\n        SCS_extern_in_linkage_spec(false),\n        TypeSpecWidth(static_cast<unsigned>(TypeSpecifierWidth::Unspecified)),\n        TypeSpecComplex(TSC_unspecified),\n        TypeSpecSign(static_cast<unsigned>(TypeSpecifierSign::Unspecified)),\n        TypeSpecType(TST_unspecified), TypeAltiVecVector(false),\n        TypeAltiVecPixel(false), TypeAltiVecBool(false), TypeSpecOwned(false),\n        TypeSpecPipe(false), TypeSpecSat(false), ConstrainedAuto(false),\n        TypeQualifiers(TQ_unspecified), FS_inline_specified(false),\n        FS_forceinline_specified(false), FS_virtual_specified(false),\n        FS_noreturn_specified(false), Friend_specified(false),\n        ConstexprSpecifier(\n            static_cast<unsigned>(ConstexprSpecKind::Unspecified)),\n        FS_explicit_specifier(), Attrs(attrFactory), writtenBS(),\n        ObjCQualifiers(nullptr) {}\n\n  // storage-class-specifier\n  SCS getStorageClassSpec() const { return (SCS)StorageClassSpec; }\n  TSCS getThreadStorageClassSpec() const {\n    return (TSCS)ThreadStorageClassSpec;\n  }\n  bool isExternInLinkageSpec() const { return SCS_extern_in_linkage_spec; }\n  void setExternInLinkageSpec(bool Value) {\n    SCS_extern_in_linkage_spec = Value;\n  }\n\n  SourceLocation getStorageClassSpecLoc() const { return StorageClassSpecLoc; }\n  SourceLocation getThreadStorageClassSpecLoc() const {\n    return ThreadStorageClassSpecLoc;\n  }\n\n  void ClearStorageClassSpecs() {\n    StorageClassSpec           = DeclSpec::SCS_unspecified;\n    ThreadStorageClassSpec     = DeclSpec::TSCS_unspecified;\n    SCS_extern_in_linkage_spec = false;\n    StorageClassSpecLoc        = SourceLocation();\n    ThreadStorageClassSpecLoc  = SourceLocation();\n  }\n\n  void ClearTypeSpecType() {\n    TypeSpecType = DeclSpec::TST_unspecified;\n    TypeSpecOwned = false;\n    TSTLoc = SourceLocation();\n  }\n\n  // type-specifier\n  TypeSpecifierWidth getTypeSpecWidth() const {\n    return static_cast<TypeSpecifierWidth>(TypeSpecWidth);\n  }\n  TSC getTypeSpecComplex() const { return (TSC)TypeSpecComplex; }\n  TypeSpecifierSign getTypeSpecSign() const {\n    return static_cast<TypeSpecifierSign>(TypeSpecSign);\n  }\n  TST getTypeSpecType() const { return (TST)TypeSpecType; }\n  bool isTypeAltiVecVector() const { return TypeAltiVecVector; }\n  bool isTypeAltiVecPixel() const { return TypeAltiVecPixel; }\n  bool isTypeAltiVecBool() const { return TypeAltiVecBool; }\n  bool isTypeSpecOwned() const { return TypeSpecOwned; }\n  bool isTypeRep() const { return isTypeRep((TST) TypeSpecType); }\n  bool isTypeSpecPipe() const { return TypeSpecPipe; }\n  bool isTypeSpecSat() const { return TypeSpecSat; }\n  bool isConstrainedAuto() const { return ConstrainedAuto; }\n\n  ParsedType getRepAsType() const {\n    assert(isTypeRep((TST) TypeSpecType) && \"DeclSpec does not store a type\");\n    return TypeRep;\n  }\n  Decl *getRepAsDecl() const {\n    assert(isDeclRep((TST) TypeSpecType) && \"DeclSpec does not store a decl\");\n    return DeclRep;\n  }\n  Expr *getRepAsExpr() const {\n    assert(isExprRep((TST) TypeSpecType) && \"DeclSpec does not store an expr\");\n    return ExprRep;\n  }\n  TemplateIdAnnotation *getRepAsTemplateId() const {\n    assert(isTemplateIdRep((TST) TypeSpecType) &&\n           \"DeclSpec does not store a template id\");\n    return TemplateIdRep;\n  }\n  CXXScopeSpec &getTypeSpecScope() { return TypeScope; }\n  const CXXScopeSpec &getTypeSpecScope() const { return TypeScope; }\n\n  SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n\n  SourceLocation getTypeSpecWidthLoc() const { return TSWRange.getBegin(); }\n  SourceRange getTypeSpecWidthRange() const { return TSWRange; }\n  SourceLocation getTypeSpecComplexLoc() const { return TSCLoc; }\n  SourceLocation getTypeSpecSignLoc() const { return TSSLoc; }\n  SourceLocation getTypeSpecTypeLoc() const { return TSTLoc; }\n  SourceLocation getAltiVecLoc() const { return AltiVecLoc; }\n  SourceLocation getTypeSpecSatLoc() const { return TSSatLoc; }\n\n  SourceLocation getTypeSpecTypeNameLoc() const {\n    assert(isDeclRep((TST) TypeSpecType) || TypeSpecType == TST_typename);\n    return TSTNameLoc;\n  }\n\n  SourceRange getTypeofParensRange() const { return TypeofParensRange; }\n  void setTypeofParensRange(SourceRange range) { TypeofParensRange = range; }\n\n  bool hasAutoTypeSpec() const {\n    return (TypeSpecType == TST_auto || TypeSpecType == TST_auto_type ||\n            TypeSpecType == TST_decltype_auto);\n  }\n\n  bool hasTagDefinition() const;\n\n  /// Turn a type-specifier-type into a string like \"_Bool\" or \"union\".\n  static const char *getSpecifierName(DeclSpec::TST T,\n                                      const PrintingPolicy &Policy);\n  static const char *getSpecifierName(DeclSpec::TQ Q);\n  static const char *getSpecifierName(TypeSpecifierSign S);\n  static const char *getSpecifierName(DeclSpec::TSC C);\n  static const char *getSpecifierName(TypeSpecifierWidth W);\n  static const char *getSpecifierName(DeclSpec::SCS S);\n  static const char *getSpecifierName(DeclSpec::TSCS S);\n  static const char *getSpecifierName(ConstexprSpecKind C);\n\n  // type-qualifiers\n\n  /// getTypeQualifiers - Return a set of TQs.\n  unsigned getTypeQualifiers() const { return TypeQualifiers; }\n  SourceLocation getConstSpecLoc() const { return TQ_constLoc; }\n  SourceLocation getRestrictSpecLoc() const { return TQ_restrictLoc; }\n  SourceLocation getVolatileSpecLoc() const { return TQ_volatileLoc; }\n  SourceLocation getAtomicSpecLoc() const { return TQ_atomicLoc; }\n  SourceLocation getUnalignedSpecLoc() const { return TQ_unalignedLoc; }\n  SourceLocation getPipeLoc() const { return TQ_pipeLoc; }\n\n  /// Clear out all of the type qualifiers.\n  void ClearTypeQualifiers() {\n    TypeQualifiers = 0;\n    TQ_constLoc = SourceLocation();\n    TQ_restrictLoc = SourceLocation();\n    TQ_volatileLoc = SourceLocation();\n    TQ_atomicLoc = SourceLocation();\n    TQ_unalignedLoc = SourceLocation();\n    TQ_pipeLoc = SourceLocation();\n  }\n\n  // function-specifier\n  bool isInlineSpecified() const {\n    return FS_inline_specified | FS_forceinline_specified;\n  }\n  SourceLocation getInlineSpecLoc() const {\n    return FS_inline_specified ? FS_inlineLoc : FS_forceinlineLoc;\n  }\n\n  ExplicitSpecifier getExplicitSpecifier() const {\n    return FS_explicit_specifier;\n  }\n\n  bool isVirtualSpecified() const { return FS_virtual_specified; }\n  SourceLocation getVirtualSpecLoc() const { return FS_virtualLoc; }\n\n  bool hasExplicitSpecifier() const {\n    return FS_explicit_specifier.isSpecified();\n  }\n  SourceLocation getExplicitSpecLoc() const { return FS_explicitLoc; }\n  SourceRange getExplicitSpecRange() const {\n    return FS_explicit_specifier.getExpr()\n               ? SourceRange(FS_explicitLoc, FS_explicitCloseParenLoc)\n               : SourceRange(FS_explicitLoc);\n  }\n\n  bool isNoreturnSpecified() const { return FS_noreturn_specified; }\n  SourceLocation getNoreturnSpecLoc() const { return FS_noreturnLoc; }\n\n  void ClearFunctionSpecs() {\n    FS_inline_specified = false;\n    FS_inlineLoc = SourceLocation();\n    FS_forceinline_specified = false;\n    FS_forceinlineLoc = SourceLocation();\n    FS_virtual_specified = false;\n    FS_virtualLoc = SourceLocation();\n    FS_explicit_specifier = ExplicitSpecifier();\n    FS_explicitLoc = SourceLocation();\n    FS_explicitCloseParenLoc = SourceLocation();\n    FS_noreturn_specified = false;\n    FS_noreturnLoc = SourceLocation();\n  }\n\n  /// This method calls the passed in handler on each CVRU qual being\n  /// set.\n  /// Handle - a handler to be invoked.\n  void forEachCVRUQualifier(\n      llvm::function_ref<void(TQ, StringRef, SourceLocation)> Handle);\n\n  /// This method calls the passed in handler on each qual being\n  /// set.\n  /// Handle - a handler to be invoked.\n  void forEachQualifier(\n      llvm::function_ref<void(TQ, StringRef, SourceLocation)> Handle);\n\n  /// Return true if any type-specifier has been found.\n  bool hasTypeSpecifier() const {\n    return getTypeSpecType() != DeclSpec::TST_unspecified ||\n           getTypeSpecWidth() != TypeSpecifierWidth::Unspecified ||\n           getTypeSpecComplex() != DeclSpec::TSC_unspecified ||\n           getTypeSpecSign() != TypeSpecifierSign::Unspecified;\n  }\n\n  /// Return a bitmask of which flavors of specifiers this\n  /// DeclSpec includes.\n  unsigned getParsedSpecifiers() const;\n\n  /// isEmpty - Return true if this declaration specifier is completely empty:\n  /// no tokens were parsed in the production of it.\n  bool isEmpty() const {\n    return getParsedSpecifiers() == DeclSpec::PQ_None;\n  }\n\n  void SetRangeStart(SourceLocation Loc) { Range.setBegin(Loc); }\n  void SetRangeEnd(SourceLocation Loc) { Range.setEnd(Loc); }\n\n  /// These methods set the specified attribute of the DeclSpec and\n  /// return false if there was no error.  If an error occurs (for\n  /// example, if we tried to set \"auto\" on a spec with \"extern\"\n  /// already set), they return true and set PrevSpec and DiagID\n  /// such that\n  ///   Diag(Loc, DiagID) << PrevSpec;\n  /// will yield a useful result.\n  ///\n  /// TODO: use a more general approach that still allows these\n  /// diagnostics to be ignored when desired.\n  bool SetStorageClassSpec(Sema &S, SCS SC, SourceLocation Loc,\n                           const char *&PrevSpec, unsigned &DiagID,\n                           const PrintingPolicy &Policy);\n  bool SetStorageClassSpecThread(TSCS TSC, SourceLocation Loc,\n                                 const char *&PrevSpec, unsigned &DiagID);\n  bool SetTypeSpecWidth(TypeSpecifierWidth W, SourceLocation Loc,\n                        const char *&PrevSpec, unsigned &DiagID,\n                        const PrintingPolicy &Policy);\n  bool SetTypeSpecComplex(TSC C, SourceLocation Loc, const char *&PrevSpec,\n                          unsigned &DiagID);\n  bool SetTypeSpecSign(TypeSpecifierSign S, SourceLocation Loc,\n                       const char *&PrevSpec, unsigned &DiagID);\n  bool SetTypeSpecType(TST T, SourceLocation Loc, const char *&PrevSpec,\n                       unsigned &DiagID, const PrintingPolicy &Policy);\n  bool SetTypeSpecType(TST T, SourceLocation Loc, const char *&PrevSpec,\n                       unsigned &DiagID, ParsedType Rep,\n                       const PrintingPolicy &Policy);\n  bool SetTypeSpecType(TST T, SourceLocation Loc, const char *&PrevSpec,\n                       unsigned &DiagID, TypeResult Rep,\n                       const PrintingPolicy &Policy) {\n    if (Rep.isInvalid())\n      return SetTypeSpecError();\n    return SetTypeSpecType(T, Loc, PrevSpec, DiagID, Rep.get(), Policy);\n  }\n  bool SetTypeSpecType(TST T, SourceLocation Loc, const char *&PrevSpec,\n                       unsigned &DiagID, Decl *Rep, bool Owned,\n                       const PrintingPolicy &Policy);\n  bool SetTypeSpecType(TST T, SourceLocation TagKwLoc,\n                       SourceLocation TagNameLoc, const char *&PrevSpec,\n                       unsigned &DiagID, ParsedType Rep,\n                       const PrintingPolicy &Policy);\n  bool SetTypeSpecType(TST T, SourceLocation TagKwLoc,\n                       SourceLocation TagNameLoc, const char *&PrevSpec,\n                       unsigned &DiagID, Decl *Rep, bool Owned,\n                       const PrintingPolicy &Policy);\n  bool SetTypeSpecType(TST T, SourceLocation Loc, const char *&PrevSpec,\n                       unsigned &DiagID, TemplateIdAnnotation *Rep,\n                       const PrintingPolicy &Policy);\n\n  bool SetTypeSpecType(TST T, SourceLocation Loc, const char *&PrevSpec,\n                       unsigned &DiagID, Expr *Rep,\n                       const PrintingPolicy &policy);\n  bool SetTypeAltiVecVector(bool isAltiVecVector, SourceLocation Loc,\n                       const char *&PrevSpec, unsigned &DiagID,\n                       const PrintingPolicy &Policy);\n  bool SetTypeAltiVecPixel(bool isAltiVecPixel, SourceLocation Loc,\n                       const char *&PrevSpec, unsigned &DiagID,\n                       const PrintingPolicy &Policy);\n  bool SetTypeAltiVecBool(bool isAltiVecBool, SourceLocation Loc,\n                       const char *&PrevSpec, unsigned &DiagID,\n                       const PrintingPolicy &Policy);\n  bool SetTypePipe(bool isPipe, SourceLocation Loc,\n                       const char *&PrevSpec, unsigned &DiagID,\n                       const PrintingPolicy &Policy);\n  bool SetExtIntType(SourceLocation KWLoc, Expr *BitWidth,\n                     const char *&PrevSpec, unsigned &DiagID,\n                     const PrintingPolicy &Policy);\n  bool SetTypeSpecSat(SourceLocation Loc, const char *&PrevSpec,\n                      unsigned &DiagID);\n  bool SetTypeSpecError();\n  void UpdateDeclRep(Decl *Rep) {\n    assert(isDeclRep((TST) TypeSpecType));\n    DeclRep = Rep;\n  }\n  void UpdateTypeRep(ParsedType Rep) {\n    assert(isTypeRep((TST) TypeSpecType));\n    TypeRep = Rep;\n  }\n  void UpdateExprRep(Expr *Rep) {\n    assert(isExprRep((TST) TypeSpecType));\n    ExprRep = Rep;\n  }\n\n  bool SetTypeQual(TQ T, SourceLocation Loc);\n\n  bool SetTypeQual(TQ T, SourceLocation Loc, const char *&PrevSpec,\n                   unsigned &DiagID, const LangOptions &Lang);\n\n  bool setFunctionSpecInline(SourceLocation Loc, const char *&PrevSpec,\n                             unsigned &DiagID);\n  bool setFunctionSpecForceInline(SourceLocation Loc, const char *&PrevSpec,\n                                  unsigned &DiagID);\n  bool setFunctionSpecVirtual(SourceLocation Loc, const char *&PrevSpec,\n                              unsigned &DiagID);\n  bool setFunctionSpecExplicit(SourceLocation Loc, const char *&PrevSpec,\n                               unsigned &DiagID, ExplicitSpecifier ExplicitSpec,\n                               SourceLocation CloseParenLoc);\n  bool setFunctionSpecNoreturn(SourceLocation Loc, const char *&PrevSpec,\n                               unsigned &DiagID);\n\n  bool SetFriendSpec(SourceLocation Loc, const char *&PrevSpec,\n                     unsigned &DiagID);\n  bool setModulePrivateSpec(SourceLocation Loc, const char *&PrevSpec,\n                            unsigned &DiagID);\n  bool SetConstexprSpec(ConstexprSpecKind ConstexprKind, SourceLocation Loc,\n                        const char *&PrevSpec, unsigned &DiagID);\n\n  bool isFriendSpecified() const { return Friend_specified; }\n  SourceLocation getFriendSpecLoc() const { return FriendLoc; }\n\n  bool isModulePrivateSpecified() const { return ModulePrivateLoc.isValid(); }\n  SourceLocation getModulePrivateSpecLoc() const { return ModulePrivateLoc; }\n\n  ConstexprSpecKind getConstexprSpecifier() const {\n    return ConstexprSpecKind(ConstexprSpecifier);\n  }\n\n  SourceLocation getConstexprSpecLoc() const { return ConstexprLoc; }\n  bool hasConstexprSpecifier() const {\n    return getConstexprSpecifier() != ConstexprSpecKind::Unspecified;\n  }\n\n  void ClearConstexprSpec() {\n    ConstexprSpecifier = static_cast<unsigned>(ConstexprSpecKind::Unspecified);\n    ConstexprLoc = SourceLocation();\n  }\n\n  AttributePool &getAttributePool() const {\n    return Attrs.getPool();\n  }\n\n  /// Concatenates two attribute lists.\n  ///\n  /// The GCC attribute syntax allows for the following:\n  ///\n  /// \\code\n  /// short __attribute__(( unused, deprecated ))\n  /// int __attribute__(( may_alias, aligned(16) )) var;\n  /// \\endcode\n  ///\n  /// This declares 4 attributes using 2 lists. The following syntax is\n  /// also allowed and equivalent to the previous declaration.\n  ///\n  /// \\code\n  /// short __attribute__((unused)) __attribute__((deprecated))\n  /// int __attribute__((may_alias)) __attribute__((aligned(16))) var;\n  /// \\endcode\n  ///\n  void addAttributes(ParsedAttributesView &AL) {\n    Attrs.addAll(AL.begin(), AL.end());\n  }\n\n  bool hasAttributes() const { return !Attrs.empty(); }\n\n  ParsedAttributes &getAttributes() { return Attrs; }\n  const ParsedAttributes &getAttributes() const { return Attrs; }\n\n  void takeAttributesFrom(ParsedAttributes &attrs) {\n    Attrs.takeAllFrom(attrs);\n  }\n\n  /// Finish - This does final analysis of the declspec, issuing diagnostics for\n  /// things like \"_Imaginary\" (lacking an FP type).  After calling this method,\n  /// DeclSpec is guaranteed self-consistent, even if an error occurred.\n  void Finish(Sema &S, const PrintingPolicy &Policy);\n\n  const WrittenBuiltinSpecs& getWrittenBuiltinSpecs() const {\n    return writtenBS;\n  }\n\n  ObjCDeclSpec *getObjCQualifiers() const { return ObjCQualifiers; }\n  void setObjCQualifiers(ObjCDeclSpec *quals) { ObjCQualifiers = quals; }\n\n  /// Checks if this DeclSpec can stand alone, without a Declarator.\n  ///\n  /// Only tag declspecs can stand alone.\n  bool isMissingDeclaratorOk();\n};\n\n/// Captures information about \"declaration specifiers\" specific to\n/// Objective-C.\nclass ObjCDeclSpec {\npublic:\n  /// ObjCDeclQualifier - Qualifier used on types in method\n  /// declarations.  Not all combinations are sensible.  Parameters\n  /// can be one of { in, out, inout } with one of { bycopy, byref }.\n  /// Returns can either be { oneway } or not.\n  ///\n  /// This should be kept in sync with Decl::ObjCDeclQualifier.\n  enum ObjCDeclQualifier {\n    DQ_None = 0x0,\n    DQ_In = 0x1,\n    DQ_Inout = 0x2,\n    DQ_Out = 0x4,\n    DQ_Bycopy = 0x8,\n    DQ_Byref = 0x10,\n    DQ_Oneway = 0x20,\n    DQ_CSNullability = 0x40\n  };\n\n  ObjCDeclSpec()\n      : objcDeclQualifier(DQ_None),\n        PropertyAttributes(ObjCPropertyAttribute::kind_noattr), Nullability(0),\n        GetterName(nullptr), SetterName(nullptr) {}\n\n  ObjCDeclQualifier getObjCDeclQualifier() const {\n    return (ObjCDeclQualifier)objcDeclQualifier;\n  }\n  void setObjCDeclQualifier(ObjCDeclQualifier DQVal) {\n    objcDeclQualifier = (ObjCDeclQualifier) (objcDeclQualifier | DQVal);\n  }\n  void clearObjCDeclQualifier(ObjCDeclQualifier DQVal) {\n    objcDeclQualifier = (ObjCDeclQualifier) (objcDeclQualifier & ~DQVal);\n  }\n\n  ObjCPropertyAttribute::Kind getPropertyAttributes() const {\n    return ObjCPropertyAttribute::Kind(PropertyAttributes);\n  }\n  void setPropertyAttributes(ObjCPropertyAttribute::Kind PRVal) {\n    PropertyAttributes =\n        (ObjCPropertyAttribute::Kind)(PropertyAttributes | PRVal);\n  }\n\n  NullabilityKind getNullability() const {\n    assert(\n        ((getObjCDeclQualifier() & DQ_CSNullability) ||\n         (getPropertyAttributes() & ObjCPropertyAttribute::kind_nullability)) &&\n        \"Objective-C declspec doesn't have nullability\");\n    return static_cast<NullabilityKind>(Nullability);\n  }\n\n  SourceLocation getNullabilityLoc() const {\n    assert(\n        ((getObjCDeclQualifier() & DQ_CSNullability) ||\n         (getPropertyAttributes() & ObjCPropertyAttribute::kind_nullability)) &&\n        \"Objective-C declspec doesn't have nullability\");\n    return NullabilityLoc;\n  }\n\n  void setNullability(SourceLocation loc, NullabilityKind kind) {\n    assert(\n        ((getObjCDeclQualifier() & DQ_CSNullability) ||\n         (getPropertyAttributes() & ObjCPropertyAttribute::kind_nullability)) &&\n        \"Set the nullability declspec or property attribute first\");\n    Nullability = static_cast<unsigned>(kind);\n    NullabilityLoc = loc;\n  }\n\n  const IdentifierInfo *getGetterName() const { return GetterName; }\n  IdentifierInfo *getGetterName() { return GetterName; }\n  SourceLocation getGetterNameLoc() const { return GetterNameLoc; }\n  void setGetterName(IdentifierInfo *name, SourceLocation loc) {\n    GetterName = name;\n    GetterNameLoc = loc;\n  }\n\n  const IdentifierInfo *getSetterName() const { return SetterName; }\n  IdentifierInfo *getSetterName() { return SetterName; }\n  SourceLocation getSetterNameLoc() const { return SetterNameLoc; }\n  void setSetterName(IdentifierInfo *name, SourceLocation loc) {\n    SetterName = name;\n    SetterNameLoc = loc;\n  }\n\nprivate:\n  // FIXME: These two are unrelated and mutually exclusive. So perhaps\n  // we can put them in a union to reflect their mutual exclusivity\n  // (space saving is negligible).\n  unsigned objcDeclQualifier : 7;\n\n  // NOTE: VC++ treats enums as signed, avoid using ObjCPropertyAttribute::Kind\n  unsigned PropertyAttributes : NumObjCPropertyAttrsBits;\n\n  unsigned Nullability : 2;\n\n  SourceLocation NullabilityLoc;\n\n  IdentifierInfo *GetterName;    // getter name or NULL if no getter\n  IdentifierInfo *SetterName;    // setter name or NULL if no setter\n  SourceLocation GetterNameLoc; // location of the getter attribute's value\n  SourceLocation SetterNameLoc; // location of the setter attribute's value\n\n};\n\n/// Describes the kind of unqualified-id parsed.\nenum class UnqualifiedIdKind {\n  /// An identifier.\n  IK_Identifier,\n  /// An overloaded operator name, e.g., operator+.\n  IK_OperatorFunctionId,\n  /// A conversion function name, e.g., operator int.\n  IK_ConversionFunctionId,\n  /// A user-defined literal name, e.g., operator \"\" _i.\n  IK_LiteralOperatorId,\n  /// A constructor name.\n  IK_ConstructorName,\n  /// A constructor named via a template-id.\n  IK_ConstructorTemplateId,\n  /// A destructor name.\n  IK_DestructorName,\n  /// A template-id, e.g., f<int>.\n  IK_TemplateId,\n  /// An implicit 'self' parameter\n  IK_ImplicitSelfParam,\n  /// A deduction-guide name (a template-name)\n  IK_DeductionGuideName\n};\n\n/// Represents a C++ unqualified-id that has been parsed.\nclass UnqualifiedId {\nprivate:\n  UnqualifiedId(const UnqualifiedId &Other) = delete;\n  const UnqualifiedId &operator=(const UnqualifiedId &) = delete;\n\npublic:\n  /// Describes the kind of unqualified-id parsed.\n  UnqualifiedIdKind Kind;\n\n  struct OFI {\n    /// The kind of overloaded operator.\n    OverloadedOperatorKind Operator;\n\n    /// The source locations of the individual tokens that name\n    /// the operator, e.g., the \"new\", \"[\", and \"]\" tokens in\n    /// operator new [].\n    ///\n    /// Different operators have different numbers of tokens in their name,\n    /// up to three. Any remaining source locations in this array will be\n    /// set to an invalid value for operators with fewer than three tokens.\n    SourceLocation SymbolLocations[3];\n  };\n\n  /// Anonymous union that holds extra data associated with the\n  /// parsed unqualified-id.\n  union {\n    /// When Kind == IK_Identifier, the parsed identifier, or when\n    /// Kind == IK_UserLiteralId, the identifier suffix.\n    IdentifierInfo *Identifier;\n\n    /// When Kind == IK_OperatorFunctionId, the overloaded operator\n    /// that we parsed.\n    struct OFI OperatorFunctionId;\n\n    /// When Kind == IK_ConversionFunctionId, the type that the\n    /// conversion function names.\n    UnionParsedType ConversionFunctionId;\n\n    /// When Kind == IK_ConstructorName, the class-name of the type\n    /// whose constructor is being referenced.\n    UnionParsedType ConstructorName;\n\n    /// When Kind == IK_DestructorName, the type referred to by the\n    /// class-name.\n    UnionParsedType DestructorName;\n\n    /// When Kind == IK_DeductionGuideName, the parsed template-name.\n    UnionParsedTemplateTy TemplateName;\n\n    /// When Kind == IK_TemplateId or IK_ConstructorTemplateId,\n    /// the template-id annotation that contains the template name and\n    /// template arguments.\n    TemplateIdAnnotation *TemplateId;\n  };\n\n  /// The location of the first token that describes this unqualified-id,\n  /// which will be the location of the identifier, \"operator\" keyword,\n  /// tilde (for a destructor), or the template name of a template-id.\n  SourceLocation StartLocation;\n\n  /// The location of the last token that describes this unqualified-id.\n  SourceLocation EndLocation;\n\n  UnqualifiedId()\n      : Kind(UnqualifiedIdKind::IK_Identifier), Identifier(nullptr) {}\n\n  /// Clear out this unqualified-id, setting it to default (invalid)\n  /// state.\n  void clear() {\n    Kind = UnqualifiedIdKind::IK_Identifier;\n    Identifier = nullptr;\n    StartLocation = SourceLocation();\n    EndLocation = SourceLocation();\n  }\n\n  /// Determine whether this unqualified-id refers to a valid name.\n  bool isValid() const { return StartLocation.isValid(); }\n\n  /// Determine whether this unqualified-id refers to an invalid name.\n  bool isInvalid() const { return !isValid(); }\n\n  /// Determine what kind of name we have.\n  UnqualifiedIdKind getKind() const { return Kind; }\n\n  /// Specify that this unqualified-id was parsed as an identifier.\n  ///\n  /// \\param Id the parsed identifier.\n  /// \\param IdLoc the location of the parsed identifier.\n  void setIdentifier(const IdentifierInfo *Id, SourceLocation IdLoc) {\n    Kind = UnqualifiedIdKind::IK_Identifier;\n    Identifier = const_cast<IdentifierInfo *>(Id);\n    StartLocation = EndLocation = IdLoc;\n  }\n\n  /// Specify that this unqualified-id was parsed as an\n  /// operator-function-id.\n  ///\n  /// \\param OperatorLoc the location of the 'operator' keyword.\n  ///\n  /// \\param Op the overloaded operator.\n  ///\n  /// \\param SymbolLocations the locations of the individual operator symbols\n  /// in the operator.\n  void setOperatorFunctionId(SourceLocation OperatorLoc,\n                             OverloadedOperatorKind Op,\n                             SourceLocation SymbolLocations[3]);\n\n  /// Specify that this unqualified-id was parsed as a\n  /// conversion-function-id.\n  ///\n  /// \\param OperatorLoc the location of the 'operator' keyword.\n  ///\n  /// \\param Ty the type to which this conversion function is converting.\n  ///\n  /// \\param EndLoc the location of the last token that makes up the type name.\n  void setConversionFunctionId(SourceLocation OperatorLoc,\n                               ParsedType Ty,\n                               SourceLocation EndLoc) {\n    Kind = UnqualifiedIdKind::IK_ConversionFunctionId;\n    StartLocation = OperatorLoc;\n    EndLocation = EndLoc;\n    ConversionFunctionId = Ty;\n  }\n\n  /// Specific that this unqualified-id was parsed as a\n  /// literal-operator-id.\n  ///\n  /// \\param Id the parsed identifier.\n  ///\n  /// \\param OpLoc the location of the 'operator' keyword.\n  ///\n  /// \\param IdLoc the location of the identifier.\n  void setLiteralOperatorId(const IdentifierInfo *Id, SourceLocation OpLoc,\n                              SourceLocation IdLoc) {\n    Kind = UnqualifiedIdKind::IK_LiteralOperatorId;\n    Identifier = const_cast<IdentifierInfo *>(Id);\n    StartLocation = OpLoc;\n    EndLocation = IdLoc;\n  }\n\n  /// Specify that this unqualified-id was parsed as a constructor name.\n  ///\n  /// \\param ClassType the class type referred to by the constructor name.\n  ///\n  /// \\param ClassNameLoc the location of the class name.\n  ///\n  /// \\param EndLoc the location of the last token that makes up the type name.\n  void setConstructorName(ParsedType ClassType,\n                          SourceLocation ClassNameLoc,\n                          SourceLocation EndLoc) {\n    Kind = UnqualifiedIdKind::IK_ConstructorName;\n    StartLocation = ClassNameLoc;\n    EndLocation = EndLoc;\n    ConstructorName = ClassType;\n  }\n\n  /// Specify that this unqualified-id was parsed as a\n  /// template-id that names a constructor.\n  ///\n  /// \\param TemplateId the template-id annotation that describes the parsed\n  /// template-id. This UnqualifiedId instance will take ownership of the\n  /// \\p TemplateId and will free it on destruction.\n  void setConstructorTemplateId(TemplateIdAnnotation *TemplateId);\n\n  /// Specify that this unqualified-id was parsed as a destructor name.\n  ///\n  /// \\param TildeLoc the location of the '~' that introduces the destructor\n  /// name.\n  ///\n  /// \\param ClassType the name of the class referred to by the destructor name.\n  void setDestructorName(SourceLocation TildeLoc,\n                         ParsedType ClassType,\n                         SourceLocation EndLoc) {\n    Kind = UnqualifiedIdKind::IK_DestructorName;\n    StartLocation = TildeLoc;\n    EndLocation = EndLoc;\n    DestructorName = ClassType;\n  }\n\n  /// Specify that this unqualified-id was parsed as a template-id.\n  ///\n  /// \\param TemplateId the template-id annotation that describes the parsed\n  /// template-id. This UnqualifiedId instance will take ownership of the\n  /// \\p TemplateId and will free it on destruction.\n  void setTemplateId(TemplateIdAnnotation *TemplateId);\n\n  /// Specify that this unqualified-id was parsed as a template-name for\n  /// a deduction-guide.\n  ///\n  /// \\param Template The parsed template-name.\n  /// \\param TemplateLoc The location of the parsed template-name.\n  void setDeductionGuideName(ParsedTemplateTy Template,\n                             SourceLocation TemplateLoc) {\n    Kind = UnqualifiedIdKind::IK_DeductionGuideName;\n    TemplateName = Template;\n    StartLocation = EndLocation = TemplateLoc;\n  }\n\n  /// Specify that this unqualified-id is an implicit 'self'\n  /// parameter.\n  ///\n  /// \\param Id the identifier.\n  void setImplicitSelfParam(const IdentifierInfo *Id) {\n    Kind = UnqualifiedIdKind::IK_ImplicitSelfParam;\n    Identifier = const_cast<IdentifierInfo *>(Id);\n    StartLocation = EndLocation = SourceLocation();\n  }\n\n  /// Return the source range that covers this unqualified-id.\n  SourceRange getSourceRange() const LLVM_READONLY {\n    return SourceRange(StartLocation, EndLocation);\n  }\n  SourceLocation getBeginLoc() const LLVM_READONLY { return StartLocation; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return EndLocation; }\n};\n\n/// A set of tokens that has been cached for later parsing.\ntypedef SmallVector<Token, 4> CachedTokens;\n\n/// One instance of this struct is used for each type in a\n/// declarator that is parsed.\n///\n/// This is intended to be a small value object.\nstruct DeclaratorChunk {\n  DeclaratorChunk() {};\n\n  enum {\n    Pointer, Reference, Array, Function, BlockPointer, MemberPointer, Paren, Pipe\n  } Kind;\n\n  /// Loc - The place where this type was defined.\n  SourceLocation Loc;\n  /// EndLoc - If valid, the place where this chunck ends.\n  SourceLocation EndLoc;\n\n  SourceRange getSourceRange() const {\n    if (EndLoc.isInvalid())\n      return SourceRange(Loc, Loc);\n    return SourceRange(Loc, EndLoc);\n  }\n\n  ParsedAttributesView AttrList;\n\n  struct PointerTypeInfo {\n    /// The type qualifiers: const/volatile/restrict/unaligned/atomic.\n    unsigned TypeQuals : 5;\n\n    /// The location of the const-qualifier, if any.\n    SourceLocation ConstQualLoc;\n\n    /// The location of the volatile-qualifier, if any.\n    SourceLocation VolatileQualLoc;\n\n    /// The location of the restrict-qualifier, if any.\n    SourceLocation RestrictQualLoc;\n\n    /// The location of the _Atomic-qualifier, if any.\n    SourceLocation AtomicQualLoc;\n\n    /// The location of the __unaligned-qualifier, if any.\n    SourceLocation UnalignedQualLoc;\n\n    void destroy() {\n    }\n  };\n\n  struct ReferenceTypeInfo {\n    /// The type qualifier: restrict. [GNU] C++ extension\n    bool HasRestrict : 1;\n    /// True if this is an lvalue reference, false if it's an rvalue reference.\n    bool LValueRef : 1;\n    void destroy() {\n    }\n  };\n\n  struct ArrayTypeInfo {\n    /// The type qualifiers for the array:\n    /// const/volatile/restrict/__unaligned/_Atomic.\n    unsigned TypeQuals : 5;\n\n    /// True if this dimension included the 'static' keyword.\n    unsigned hasStatic : 1;\n\n    /// True if this dimension was [*].  In this case, NumElts is null.\n    unsigned isStar : 1;\n\n    /// This is the size of the array, or null if [] or [*] was specified.\n    /// Since the parser is multi-purpose, and we don't want to impose a root\n    /// expression class on all clients, NumElts is untyped.\n    Expr *NumElts;\n\n    void destroy() {}\n  };\n\n  /// ParamInfo - An array of paraminfo objects is allocated whenever a function\n  /// declarator is parsed.  There are two interesting styles of parameters\n  /// here:\n  /// K&R-style identifier lists and parameter type lists.  K&R-style identifier\n  /// lists will have information about the identifier, but no type information.\n  /// Parameter type lists will have type info (if the actions module provides\n  /// it), but may have null identifier info: e.g. for 'void foo(int X, int)'.\n  struct ParamInfo {\n    IdentifierInfo *Ident;\n    SourceLocation IdentLoc;\n    Decl *Param;\n\n    /// DefaultArgTokens - When the parameter's default argument\n    /// cannot be parsed immediately (because it occurs within the\n    /// declaration of a member function), it will be stored here as a\n    /// sequence of tokens to be parsed once the class definition is\n    /// complete. Non-NULL indicates that there is a default argument.\n    std::unique_ptr<CachedTokens> DefaultArgTokens;\n\n    ParamInfo() = default;\n    ParamInfo(IdentifierInfo *ident, SourceLocation iloc,\n              Decl *param,\n              std::unique_ptr<CachedTokens> DefArgTokens = nullptr)\n      : Ident(ident), IdentLoc(iloc), Param(param),\n        DefaultArgTokens(std::move(DefArgTokens)) {}\n  };\n\n  struct TypeAndRange {\n    ParsedType Ty;\n    SourceRange Range;\n  };\n\n  struct FunctionTypeInfo {\n    /// hasPrototype - This is true if the function had at least one typed\n    /// parameter.  If the function is () or (a,b,c), then it has no prototype,\n    /// and is treated as a K&R-style function.\n    unsigned hasPrototype : 1;\n\n    /// isVariadic - If this function has a prototype, and if that\n    /// proto ends with ',...)', this is true. When true, EllipsisLoc\n    /// contains the location of the ellipsis.\n    unsigned isVariadic : 1;\n\n    /// Can this declaration be a constructor-style initializer?\n    unsigned isAmbiguous : 1;\n\n    /// Whether the ref-qualifier (if any) is an lvalue reference.\n    /// Otherwise, it's an rvalue reference.\n    unsigned RefQualifierIsLValueRef : 1;\n\n    /// ExceptionSpecType - An ExceptionSpecificationType value.\n    unsigned ExceptionSpecType : 4;\n\n    /// DeleteParams - If this is true, we need to delete[] Params.\n    unsigned DeleteParams : 1;\n\n    /// HasTrailingReturnType - If this is true, a trailing return type was\n    /// specified.\n    unsigned HasTrailingReturnType : 1;\n\n    /// The location of the left parenthesis in the source.\n    SourceLocation LParenLoc;\n\n    /// When isVariadic is true, the location of the ellipsis in the source.\n    SourceLocation EllipsisLoc;\n\n    /// The location of the right parenthesis in the source.\n    SourceLocation RParenLoc;\n\n    /// NumParams - This is the number of formal parameters specified by the\n    /// declarator.\n    unsigned NumParams;\n\n    /// NumExceptionsOrDecls - This is the number of types in the\n    /// dynamic-exception-decl, if the function has one. In C, this is the\n    /// number of declarations in the function prototype.\n    unsigned NumExceptionsOrDecls;\n\n    /// The location of the ref-qualifier, if any.\n    ///\n    /// If this is an invalid location, there is no ref-qualifier.\n    SourceLocation RefQualifierLoc;\n\n    /// The location of the 'mutable' qualifer in a lambda-declarator, if\n    /// any.\n    SourceLocation MutableLoc;\n\n    /// The beginning location of the exception specification, if any.\n    SourceLocation ExceptionSpecLocBeg;\n\n    /// The end location of the exception specification, if any.\n    SourceLocation ExceptionSpecLocEnd;\n\n    /// Params - This is a pointer to a new[]'d array of ParamInfo objects that\n    /// describe the parameters specified by this function declarator.  null if\n    /// there are no parameters specified.\n    ParamInfo *Params;\n\n    /// DeclSpec for the function with the qualifier related info.\n    DeclSpec *MethodQualifiers;\n\n    /// AtttibuteFactory for the MethodQualifiers.\n    AttributeFactory *QualAttrFactory;\n\n    union {\n      /// Pointer to a new[]'d array of TypeAndRange objects that\n      /// contain the types in the function's dynamic exception specification\n      /// and their locations, if there is one.\n      TypeAndRange *Exceptions;\n\n      /// Pointer to the expression in the noexcept-specifier of this\n      /// function, if it has one.\n      Expr *NoexceptExpr;\n\n      /// Pointer to the cached tokens for an exception-specification\n      /// that has not yet been parsed.\n      CachedTokens *ExceptionSpecTokens;\n\n      /// Pointer to a new[]'d array of declarations that need to be available\n      /// for lookup inside the function body, if one exists. Does not exist in\n      /// C++.\n      NamedDecl **DeclsInPrototype;\n    };\n\n    /// If HasTrailingReturnType is true, this is the trailing return\n    /// type specified.\n    UnionParsedType TrailingReturnType;\n\n    /// If HasTrailingReturnType is true, this is the location of the trailing\n    /// return type.\n    SourceLocation TrailingReturnTypeLoc;\n\n    /// Reset the parameter list to having zero parameters.\n    ///\n    /// This is used in various places for error recovery.\n    void freeParams() {\n      for (unsigned I = 0; I < NumParams; ++I)\n        Params[I].DefaultArgTokens.reset();\n      if (DeleteParams) {\n        delete[] Params;\n        DeleteParams = false;\n      }\n      NumParams = 0;\n    }\n\n    void destroy() {\n      freeParams();\n      delete QualAttrFactory;\n      delete MethodQualifiers;\n      switch (getExceptionSpecType()) {\n      default:\n        break;\n      case EST_Dynamic:\n        delete[] Exceptions;\n        break;\n      case EST_Unparsed:\n        delete ExceptionSpecTokens;\n        break;\n      case EST_None:\n        if (NumExceptionsOrDecls != 0)\n          delete[] DeclsInPrototype;\n        break;\n      }\n    }\n\n    DeclSpec &getOrCreateMethodQualifiers() {\n      if (!MethodQualifiers) {\n        QualAttrFactory = new AttributeFactory();\n        MethodQualifiers = new DeclSpec(*QualAttrFactory);\n      }\n      return *MethodQualifiers;\n    }\n\n    /// isKNRPrototype - Return true if this is a K&R style identifier list,\n    /// like \"void foo(a,b,c)\".  In a function definition, this will be followed\n    /// by the parameter type definitions.\n    bool isKNRPrototype() const { return !hasPrototype && NumParams != 0; }\n\n    SourceLocation getLParenLoc() const { return LParenLoc; }\n\n    SourceLocation getEllipsisLoc() const { return EllipsisLoc; }\n\n    SourceLocation getRParenLoc() const { return RParenLoc; }\n\n    SourceLocation getExceptionSpecLocBeg() const {\n      return ExceptionSpecLocBeg;\n    }\n\n    SourceLocation getExceptionSpecLocEnd() const {\n      return ExceptionSpecLocEnd;\n    }\n\n    SourceRange getExceptionSpecRange() const {\n      return SourceRange(getExceptionSpecLocBeg(), getExceptionSpecLocEnd());\n    }\n\n    /// Retrieve the location of the ref-qualifier, if any.\n    SourceLocation getRefQualifierLoc() const { return RefQualifierLoc; }\n\n    /// Retrieve the location of the 'const' qualifier.\n    SourceLocation getConstQualifierLoc() const {\n      assert(MethodQualifiers);\n      return MethodQualifiers->getConstSpecLoc();\n    }\n\n    /// Retrieve the location of the 'volatile' qualifier.\n    SourceLocation getVolatileQualifierLoc() const {\n      assert(MethodQualifiers);\n      return MethodQualifiers->getVolatileSpecLoc();\n    }\n\n    /// Retrieve the location of the 'restrict' qualifier.\n    SourceLocation getRestrictQualifierLoc() const {\n      assert(MethodQualifiers);\n      return MethodQualifiers->getRestrictSpecLoc();\n    }\n\n    /// Retrieve the location of the 'mutable' qualifier, if any.\n    SourceLocation getMutableLoc() const { return MutableLoc; }\n\n    /// Determine whether this function declaration contains a\n    /// ref-qualifier.\n    bool hasRefQualifier() const { return getRefQualifierLoc().isValid(); }\n\n    /// Determine whether this lambda-declarator contains a 'mutable'\n    /// qualifier.\n    bool hasMutableQualifier() const { return getMutableLoc().isValid(); }\n\n    /// Determine whether this method has qualifiers.\n    bool hasMethodTypeQualifiers() const {\n      return MethodQualifiers && (MethodQualifiers->getTypeQualifiers() ||\n                                  MethodQualifiers->getAttributes().size());\n    }\n\n    /// Get the type of exception specification this function has.\n    ExceptionSpecificationType getExceptionSpecType() const {\n      return static_cast<ExceptionSpecificationType>(ExceptionSpecType);\n    }\n\n    /// Get the number of dynamic exception specifications.\n    unsigned getNumExceptions() const {\n      assert(ExceptionSpecType != EST_None);\n      return NumExceptionsOrDecls;\n    }\n\n    /// Get the non-parameter decls defined within this function\n    /// prototype. Typically these are tag declarations.\n    ArrayRef<NamedDecl *> getDeclsInPrototype() const {\n      assert(ExceptionSpecType == EST_None);\n      return llvm::makeArrayRef(DeclsInPrototype, NumExceptionsOrDecls);\n    }\n\n    /// Determine whether this function declarator had a\n    /// trailing-return-type.\n    bool hasTrailingReturnType() const { return HasTrailingReturnType; }\n\n    /// Get the trailing-return-type for this function declarator.\n    ParsedType getTrailingReturnType() const {\n      assert(HasTrailingReturnType);\n      return TrailingReturnType;\n    }\n\n    /// Get the trailing-return-type location for this function declarator.\n    SourceLocation getTrailingReturnTypeLoc() const {\n      assert(HasTrailingReturnType);\n      return TrailingReturnTypeLoc;\n    }\n  };\n\n  struct BlockPointerTypeInfo {\n    /// For now, sema will catch these as invalid.\n    /// The type qualifiers: const/volatile/restrict/__unaligned/_Atomic.\n    unsigned TypeQuals : 5;\n\n    void destroy() {\n    }\n  };\n\n  struct MemberPointerTypeInfo {\n    /// The type qualifiers: const/volatile/restrict/__unaligned/_Atomic.\n    unsigned TypeQuals : 5;\n    /// Location of the '*' token.\n    SourceLocation StarLoc;\n    // CXXScopeSpec has a constructor, so it can't be a direct member.\n    // So we need some pointer-aligned storage and a bit of trickery.\n    alignas(CXXScopeSpec) char ScopeMem[sizeof(CXXScopeSpec)];\n    CXXScopeSpec &Scope() {\n      return *reinterpret_cast<CXXScopeSpec *>(ScopeMem);\n    }\n    const CXXScopeSpec &Scope() const {\n      return *reinterpret_cast<const CXXScopeSpec *>(ScopeMem);\n    }\n    void destroy() {\n      Scope().~CXXScopeSpec();\n    }\n  };\n\n  struct PipeTypeInfo {\n    /// The access writes.\n    unsigned AccessWrites : 3;\n\n    void destroy() {}\n  };\n\n  union {\n    PointerTypeInfo       Ptr;\n    ReferenceTypeInfo     Ref;\n    ArrayTypeInfo         Arr;\n    FunctionTypeInfo      Fun;\n    BlockPointerTypeInfo  Cls;\n    MemberPointerTypeInfo Mem;\n    PipeTypeInfo          PipeInfo;\n  };\n\n  void destroy() {\n    switch (Kind) {\n    case DeclaratorChunk::Function:      return Fun.destroy();\n    case DeclaratorChunk::Pointer:       return Ptr.destroy();\n    case DeclaratorChunk::BlockPointer:  return Cls.destroy();\n    case DeclaratorChunk::Reference:     return Ref.destroy();\n    case DeclaratorChunk::Array:         return Arr.destroy();\n    case DeclaratorChunk::MemberPointer: return Mem.destroy();\n    case DeclaratorChunk::Paren:         return;\n    case DeclaratorChunk::Pipe:          return PipeInfo.destroy();\n    }\n  }\n\n  /// If there are attributes applied to this declaratorchunk, return\n  /// them.\n  const ParsedAttributesView &getAttrs() const { return AttrList; }\n  ParsedAttributesView &getAttrs() { return AttrList; }\n\n  /// Return a DeclaratorChunk for a pointer.\n  static DeclaratorChunk getPointer(unsigned TypeQuals, SourceLocation Loc,\n                                    SourceLocation ConstQualLoc,\n                                    SourceLocation VolatileQualLoc,\n                                    SourceLocation RestrictQualLoc,\n                                    SourceLocation AtomicQualLoc,\n                                    SourceLocation UnalignedQualLoc) {\n    DeclaratorChunk I;\n    I.Kind                = Pointer;\n    I.Loc                 = Loc;\n    new (&I.Ptr) PointerTypeInfo;\n    I.Ptr.TypeQuals       = TypeQuals;\n    I.Ptr.ConstQualLoc    = ConstQualLoc;\n    I.Ptr.VolatileQualLoc = VolatileQualLoc;\n    I.Ptr.RestrictQualLoc = RestrictQualLoc;\n    I.Ptr.AtomicQualLoc   = AtomicQualLoc;\n    I.Ptr.UnalignedQualLoc = UnalignedQualLoc;\n    return I;\n  }\n\n  /// Return a DeclaratorChunk for a reference.\n  static DeclaratorChunk getReference(unsigned TypeQuals, SourceLocation Loc,\n                                      bool lvalue) {\n    DeclaratorChunk I;\n    I.Kind            = Reference;\n    I.Loc             = Loc;\n    I.Ref.HasRestrict = (TypeQuals & DeclSpec::TQ_restrict) != 0;\n    I.Ref.LValueRef   = lvalue;\n    return I;\n  }\n\n  /// Return a DeclaratorChunk for an array.\n  static DeclaratorChunk getArray(unsigned TypeQuals,\n                                  bool isStatic, bool isStar, Expr *NumElts,\n                                  SourceLocation LBLoc, SourceLocation RBLoc) {\n    DeclaratorChunk I;\n    I.Kind          = Array;\n    I.Loc           = LBLoc;\n    I.EndLoc        = RBLoc;\n    I.Arr.TypeQuals = TypeQuals;\n    I.Arr.hasStatic = isStatic;\n    I.Arr.isStar    = isStar;\n    I.Arr.NumElts   = NumElts;\n    return I;\n  }\n\n  /// DeclaratorChunk::getFunction - Return a DeclaratorChunk for a function.\n  /// \"TheDeclarator\" is the declarator that this will be added to.\n  static DeclaratorChunk getFunction(bool HasProto,\n                                     bool IsAmbiguous,\n                                     SourceLocation LParenLoc,\n                                     ParamInfo *Params, unsigned NumParams,\n                                     SourceLocation EllipsisLoc,\n                                     SourceLocation RParenLoc,\n                                     bool RefQualifierIsLvalueRef,\n                                     SourceLocation RefQualifierLoc,\n                                     SourceLocation MutableLoc,\n                                     ExceptionSpecificationType ESpecType,\n                                     SourceRange ESpecRange,\n                                     ParsedType *Exceptions,\n                                     SourceRange *ExceptionRanges,\n                                     unsigned NumExceptions,\n                                     Expr *NoexceptExpr,\n                                     CachedTokens *ExceptionSpecTokens,\n                                     ArrayRef<NamedDecl *> DeclsInPrototype,\n                                     SourceLocation LocalRangeBegin,\n                                     SourceLocation LocalRangeEnd,\n                                     Declarator &TheDeclarator,\n                                     TypeResult TrailingReturnType =\n                                                    TypeResult(),\n                                     SourceLocation TrailingReturnTypeLoc =\n                                                    SourceLocation(),\n                                     DeclSpec *MethodQualifiers = nullptr);\n\n  /// Return a DeclaratorChunk for a block.\n  static DeclaratorChunk getBlockPointer(unsigned TypeQuals,\n                                         SourceLocation Loc) {\n    DeclaratorChunk I;\n    I.Kind          = BlockPointer;\n    I.Loc           = Loc;\n    I.Cls.TypeQuals = TypeQuals;\n    return I;\n  }\n\n  /// Return a DeclaratorChunk for a block.\n  static DeclaratorChunk getPipe(unsigned TypeQuals,\n                                 SourceLocation Loc) {\n    DeclaratorChunk I;\n    I.Kind          = Pipe;\n    I.Loc           = Loc;\n    I.Cls.TypeQuals = TypeQuals;\n    return I;\n  }\n\n  static DeclaratorChunk getMemberPointer(const CXXScopeSpec &SS,\n                                          unsigned TypeQuals,\n                                          SourceLocation StarLoc,\n                                          SourceLocation EndLoc) {\n    DeclaratorChunk I;\n    I.Kind          = MemberPointer;\n    I.Loc           = SS.getBeginLoc();\n    I.EndLoc = EndLoc;\n    new (&I.Mem) MemberPointerTypeInfo;\n    I.Mem.StarLoc = StarLoc;\n    I.Mem.TypeQuals = TypeQuals;\n    new (I.Mem.ScopeMem) CXXScopeSpec(SS);\n    return I;\n  }\n\n  /// Return a DeclaratorChunk for a paren.\n  static DeclaratorChunk getParen(SourceLocation LParenLoc,\n                                  SourceLocation RParenLoc) {\n    DeclaratorChunk I;\n    I.Kind          = Paren;\n    I.Loc           = LParenLoc;\n    I.EndLoc        = RParenLoc;\n    return I;\n  }\n\n  bool isParen() const {\n    return Kind == Paren;\n  }\n};\n\n/// A parsed C++17 decomposition declarator of the form\n///   '[' identifier-list ']'\nclass DecompositionDeclarator {\npublic:\n  struct Binding {\n    IdentifierInfo *Name;\n    SourceLocation NameLoc;\n  };\n\nprivate:\n  /// The locations of the '[' and ']' tokens.\n  SourceLocation LSquareLoc, RSquareLoc;\n\n  /// The bindings.\n  Binding *Bindings;\n  unsigned NumBindings : 31;\n  unsigned DeleteBindings : 1;\n\n  friend class Declarator;\n\npublic:\n  DecompositionDeclarator()\n      : Bindings(nullptr), NumBindings(0), DeleteBindings(false) {}\n  DecompositionDeclarator(const DecompositionDeclarator &G) = delete;\n  DecompositionDeclarator &operator=(const DecompositionDeclarator &G) = delete;\n  ~DecompositionDeclarator() {\n    if (DeleteBindings)\n      delete[] Bindings;\n  }\n\n  void clear() {\n    LSquareLoc = RSquareLoc = SourceLocation();\n    if (DeleteBindings)\n      delete[] Bindings;\n    Bindings = nullptr;\n    NumBindings = 0;\n    DeleteBindings = false;\n  }\n\n  ArrayRef<Binding> bindings() const {\n    return llvm::makeArrayRef(Bindings, NumBindings);\n  }\n\n  bool isSet() const { return LSquareLoc.isValid(); }\n\n  SourceLocation getLSquareLoc() const { return LSquareLoc; }\n  SourceLocation getRSquareLoc() const { return RSquareLoc; }\n  SourceRange getSourceRange() const {\n    return SourceRange(LSquareLoc, RSquareLoc);\n  }\n};\n\n/// Described the kind of function definition (if any) provided for\n/// a function.\nenum class FunctionDefinitionKind {\n  Declaration,\n  Definition,\n  Defaulted,\n  Deleted\n};\n\nenum class DeclaratorContext {\n  File,                // File scope declaration.\n  Prototype,           // Within a function prototype.\n  ObjCResult,          // An ObjC method result type.\n  ObjCParameter,       // An ObjC method parameter type.\n  KNRTypeList,         // K&R type definition list for formals.\n  TypeName,            // Abstract declarator for types.\n  FunctionalCast,      // Type in a C++ functional cast expression.\n  Member,              // Struct/Union field.\n  Block,               // Declaration within a block in a function.\n  ForInit,             // Declaration within first part of a for loop.\n  SelectionInit,       // Declaration within optional init stmt of if/switch.\n  Condition,           // Condition declaration in a C++ if/switch/while/for.\n  TemplateParam,       // Within a template parameter list.\n  CXXNew,              // C++ new-expression.\n  CXXCatch,            // C++ catch exception-declaration\n  ObjCCatch,           // Objective-C catch exception-declaration\n  BlockLiteral,        // Block literal declarator.\n  LambdaExpr,          // Lambda-expression declarator.\n  LambdaExprParameter, // Lambda-expression parameter declarator.\n  ConversionId,        // C++ conversion-type-id.\n  TrailingReturn,      // C++11 trailing-type-specifier.\n  TrailingReturnVar,   // C++11 trailing-type-specifier for variable.\n  TemplateArg,         // Any template argument (in template argument list).\n  TemplateTypeArg,     // Template type argument (in default argument).\n  AliasDecl,           // C++11 alias-declaration.\n  AliasTemplate,       // C++11 alias-declaration template.\n  RequiresExpr         // C++2a requires-expression.\n};\n\n/// Information about one declarator, including the parsed type\n/// information and the identifier.\n///\n/// When the declarator is fully formed, this is turned into the appropriate\n/// Decl object.\n///\n/// Declarators come in two types: normal declarators and abstract declarators.\n/// Abstract declarators are used when parsing types, and don't have an\n/// identifier.  Normal declarators do have ID's.\n///\n/// Instances of this class should be a transient object that lives on the\n/// stack, not objects that are allocated in large quantities on the heap.\nclass Declarator {\n\nprivate:\n  const DeclSpec &DS;\n  CXXScopeSpec SS;\n  UnqualifiedId Name;\n  SourceRange Range;\n\n  /// Where we are parsing this declarator.\n  DeclaratorContext Context;\n\n  /// The C++17 structured binding, if any. This is an alternative to a Name.\n  DecompositionDeclarator BindingGroup;\n\n  /// DeclTypeInfo - This holds each type that the declarator includes as it is\n  /// parsed.  This is pushed from the identifier out, which means that element\n  /// #0 will be the most closely bound to the identifier, and\n  /// DeclTypeInfo.back() will be the least closely bound.\n  SmallVector<DeclaratorChunk, 8> DeclTypeInfo;\n\n  /// InvalidType - Set by Sema::GetTypeForDeclarator().\n  unsigned InvalidType : 1;\n\n  /// GroupingParens - Set by Parser::ParseParenDeclarator().\n  unsigned GroupingParens : 1;\n\n  /// FunctionDefinition - Is this Declarator for a function or member\n  /// definition and, if so, what kind?\n  ///\n  /// Actually a FunctionDefinitionKind.\n  unsigned FunctionDefinition : 2;\n\n  /// Is this Declarator a redeclaration?\n  unsigned Redeclaration : 1;\n\n  /// true if the declaration is preceded by \\c __extension__.\n  unsigned Extension : 1;\n\n  /// Indicates whether this is an Objective-C instance variable.\n  unsigned ObjCIvar : 1;\n\n  /// Indicates whether this is an Objective-C 'weak' property.\n  unsigned ObjCWeakProperty : 1;\n\n  /// Indicates whether the InlineParams / InlineBindings storage has been used.\n  unsigned InlineStorageUsed : 1;\n\n  /// Indicates whether this declarator has an initializer.\n  unsigned HasInitializer : 1;\n\n  /// Attrs - Attributes.\n  ParsedAttributes Attrs;\n\n  /// The asm label, if specified.\n  Expr *AsmLabel;\n\n  /// \\brief The constraint-expression specified by the trailing\n  /// requires-clause, or null if no such clause was specified.\n  Expr *TrailingRequiresClause;\n\n  /// If this declarator declares a template, its template parameter lists.\n  ArrayRef<TemplateParameterList *> TemplateParameterLists;\n\n  /// If the declarator declares an abbreviated function template, the innermost\n  /// template parameter list containing the invented and explicit template\n  /// parameters (if any).\n  TemplateParameterList *InventedTemplateParameterList;\n\n#ifndef _MSC_VER\n  union {\n#endif\n    /// InlineParams - This is a local array used for the first function decl\n    /// chunk to avoid going to the heap for the common case when we have one\n    /// function chunk in the declarator.\n    DeclaratorChunk::ParamInfo InlineParams[16];\n    DecompositionDeclarator::Binding InlineBindings[16];\n#ifndef _MSC_VER\n  };\n#endif\n\n  /// If this is the second or subsequent declarator in this declaration,\n  /// the location of the comma before this declarator.\n  SourceLocation CommaLoc;\n\n  /// If provided, the source location of the ellipsis used to describe\n  /// this declarator as a parameter pack.\n  SourceLocation EllipsisLoc;\n\n  friend struct DeclaratorChunk;\n\npublic:\n  Declarator(const DeclSpec &ds, DeclaratorContext C)\n      : DS(ds), Range(ds.getSourceRange()), Context(C),\n        InvalidType(DS.getTypeSpecType() == DeclSpec::TST_error),\n        GroupingParens(false), FunctionDefinition(static_cast<unsigned>(\n                                   FunctionDefinitionKind::Declaration)),\n        Redeclaration(false), Extension(false), ObjCIvar(false),\n        ObjCWeakProperty(false), InlineStorageUsed(false),\n        HasInitializer(false), Attrs(ds.getAttributePool().getFactory()),\n        AsmLabel(nullptr), TrailingRequiresClause(nullptr),\n        InventedTemplateParameterList(nullptr) {}\n\n  ~Declarator() {\n    clear();\n  }\n  /// getDeclSpec - Return the declaration-specifier that this declarator was\n  /// declared with.\n  const DeclSpec &getDeclSpec() const { return DS; }\n\n  /// getMutableDeclSpec - Return a non-const version of the DeclSpec.  This\n  /// should be used with extreme care: declspecs can often be shared between\n  /// multiple declarators, so mutating the DeclSpec affects all of the\n  /// Declarators.  This should only be done when the declspec is known to not\n  /// be shared or when in error recovery etc.\n  DeclSpec &getMutableDeclSpec() { return const_cast<DeclSpec &>(DS); }\n\n  AttributePool &getAttributePool() const {\n    return Attrs.getPool();\n  }\n\n  /// getCXXScopeSpec - Return the C++ scope specifier (global scope or\n  /// nested-name-specifier) that is part of the declarator-id.\n  const CXXScopeSpec &getCXXScopeSpec() const { return SS; }\n  CXXScopeSpec &getCXXScopeSpec() { return SS; }\n\n  /// Retrieve the name specified by this declarator.\n  UnqualifiedId &getName() { return Name; }\n\n  const DecompositionDeclarator &getDecompositionDeclarator() const {\n    return BindingGroup;\n  }\n\n  DeclaratorContext getContext() const { return Context; }\n\n  bool isPrototypeContext() const {\n    return (Context == DeclaratorContext::Prototype ||\n            Context == DeclaratorContext::ObjCParameter ||\n            Context == DeclaratorContext::ObjCResult ||\n            Context == DeclaratorContext::LambdaExprParameter);\n  }\n\n  /// Get the source range that spans this declarator.\n  SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n\n  void SetSourceRange(SourceRange R) { Range = R; }\n  /// SetRangeBegin - Set the start of the source range to Loc, unless it's\n  /// invalid.\n  void SetRangeBegin(SourceLocation Loc) {\n    if (!Loc.isInvalid())\n      Range.setBegin(Loc);\n  }\n  /// SetRangeEnd - Set the end of the source range to Loc, unless it's invalid.\n  void SetRangeEnd(SourceLocation Loc) {\n    if (!Loc.isInvalid())\n      Range.setEnd(Loc);\n  }\n  /// ExtendWithDeclSpec - Extend the declarator source range to include the\n  /// given declspec, unless its location is invalid. Adopts the range start if\n  /// the current range start is invalid.\n  void ExtendWithDeclSpec(const DeclSpec &DS) {\n    SourceRange SR = DS.getSourceRange();\n    if (Range.getBegin().isInvalid())\n      Range.setBegin(SR.getBegin());\n    if (!SR.getEnd().isInvalid())\n      Range.setEnd(SR.getEnd());\n  }\n\n  /// Reset the contents of this Declarator.\n  void clear() {\n    SS.clear();\n    Name.clear();\n    Range = DS.getSourceRange();\n    BindingGroup.clear();\n\n    for (unsigned i = 0, e = DeclTypeInfo.size(); i != e; ++i)\n      DeclTypeInfo[i].destroy();\n    DeclTypeInfo.clear();\n    Attrs.clear();\n    AsmLabel = nullptr;\n    InlineStorageUsed = false;\n    HasInitializer = false;\n    ObjCIvar = false;\n    ObjCWeakProperty = false;\n    CommaLoc = SourceLocation();\n    EllipsisLoc = SourceLocation();\n  }\n\n  /// mayOmitIdentifier - Return true if the identifier is either optional or\n  /// not allowed.  This is true for typenames, prototypes, and template\n  /// parameter lists.\n  bool mayOmitIdentifier() const {\n    switch (Context) {\n    case DeclaratorContext::File:\n    case DeclaratorContext::KNRTypeList:\n    case DeclaratorContext::Member:\n    case DeclaratorContext::Block:\n    case DeclaratorContext::ForInit:\n    case DeclaratorContext::SelectionInit:\n    case DeclaratorContext::Condition:\n      return false;\n\n    case DeclaratorContext::TypeName:\n    case DeclaratorContext::FunctionalCast:\n    case DeclaratorContext::AliasDecl:\n    case DeclaratorContext::AliasTemplate:\n    case DeclaratorContext::Prototype:\n    case DeclaratorContext::LambdaExprParameter:\n    case DeclaratorContext::ObjCParameter:\n    case DeclaratorContext::ObjCResult:\n    case DeclaratorContext::TemplateParam:\n    case DeclaratorContext::CXXNew:\n    case DeclaratorContext::CXXCatch:\n    case DeclaratorContext::ObjCCatch:\n    case DeclaratorContext::BlockLiteral:\n    case DeclaratorContext::LambdaExpr:\n    case DeclaratorContext::ConversionId:\n    case DeclaratorContext::TemplateArg:\n    case DeclaratorContext::TemplateTypeArg:\n    case DeclaratorContext::TrailingReturn:\n    case DeclaratorContext::TrailingReturnVar:\n    case DeclaratorContext::RequiresExpr:\n      return true;\n    }\n    llvm_unreachable(\"unknown context kind!\");\n  }\n\n  /// mayHaveIdentifier - Return true if the identifier is either optional or\n  /// required.  This is true for normal declarators and prototypes, but not\n  /// typenames.\n  bool mayHaveIdentifier() const {\n    switch (Context) {\n    case DeclaratorContext::File:\n    case DeclaratorContext::KNRTypeList:\n    case DeclaratorContext::Member:\n    case DeclaratorContext::Block:\n    case DeclaratorContext::ForInit:\n    case DeclaratorContext::SelectionInit:\n    case DeclaratorContext::Condition:\n    case DeclaratorContext::Prototype:\n    case DeclaratorContext::LambdaExprParameter:\n    case DeclaratorContext::TemplateParam:\n    case DeclaratorContext::CXXCatch:\n    case DeclaratorContext::ObjCCatch:\n    case DeclaratorContext::RequiresExpr:\n      return true;\n\n    case DeclaratorContext::TypeName:\n    case DeclaratorContext::FunctionalCast:\n    case DeclaratorContext::CXXNew:\n    case DeclaratorContext::AliasDecl:\n    case DeclaratorContext::AliasTemplate:\n    case DeclaratorContext::ObjCParameter:\n    case DeclaratorContext::ObjCResult:\n    case DeclaratorContext::BlockLiteral:\n    case DeclaratorContext::LambdaExpr:\n    case DeclaratorContext::ConversionId:\n    case DeclaratorContext::TemplateArg:\n    case DeclaratorContext::TemplateTypeArg:\n    case DeclaratorContext::TrailingReturn:\n    case DeclaratorContext::TrailingReturnVar:\n      return false;\n    }\n    llvm_unreachable(\"unknown context kind!\");\n  }\n\n  /// Return true if the context permits a C++17 decomposition declarator.\n  bool mayHaveDecompositionDeclarator() const {\n    switch (Context) {\n    case DeclaratorContext::File:\n      // FIXME: It's not clear that the proposal meant to allow file-scope\n      // structured bindings, but it does.\n    case DeclaratorContext::Block:\n    case DeclaratorContext::ForInit:\n    case DeclaratorContext::SelectionInit:\n    case DeclaratorContext::Condition:\n      return true;\n\n    case DeclaratorContext::Member:\n    case DeclaratorContext::Prototype:\n    case DeclaratorContext::TemplateParam:\n    case DeclaratorContext::RequiresExpr:\n      // Maybe one day...\n      return false;\n\n    // These contexts don't allow any kind of non-abstract declarator.\n    case DeclaratorContext::KNRTypeList:\n    case DeclaratorContext::TypeName:\n    case DeclaratorContext::FunctionalCast:\n    case DeclaratorContext::AliasDecl:\n    case DeclaratorContext::AliasTemplate:\n    case DeclaratorContext::LambdaExprParameter:\n    case DeclaratorContext::ObjCParameter:\n    case DeclaratorContext::ObjCResult:\n    case DeclaratorContext::CXXNew:\n    case DeclaratorContext::CXXCatch:\n    case DeclaratorContext::ObjCCatch:\n    case DeclaratorContext::BlockLiteral:\n    case DeclaratorContext::LambdaExpr:\n    case DeclaratorContext::ConversionId:\n    case DeclaratorContext::TemplateArg:\n    case DeclaratorContext::TemplateTypeArg:\n    case DeclaratorContext::TrailingReturn:\n    case DeclaratorContext::TrailingReturnVar:\n      return false;\n    }\n    llvm_unreachable(\"unknown context kind!\");\n  }\n\n  /// mayBeFollowedByCXXDirectInit - Return true if the declarator can be\n  /// followed by a C++ direct initializer, e.g. \"int x(1);\".\n  bool mayBeFollowedByCXXDirectInit() const {\n    if (hasGroupingParens()) return false;\n\n    if (getDeclSpec().getStorageClassSpec() == DeclSpec::SCS_typedef)\n      return false;\n\n    if (getDeclSpec().getStorageClassSpec() == DeclSpec::SCS_extern &&\n        Context != DeclaratorContext::File)\n      return false;\n\n    // Special names can't have direct initializers.\n    if (Name.getKind() != UnqualifiedIdKind::IK_Identifier)\n      return false;\n\n    switch (Context) {\n    case DeclaratorContext::File:\n    case DeclaratorContext::Block:\n    case DeclaratorContext::ForInit:\n    case DeclaratorContext::SelectionInit:\n    case DeclaratorContext::TrailingReturnVar:\n      return true;\n\n    case DeclaratorContext::Condition:\n      // This may not be followed by a direct initializer, but it can't be a\n      // function declaration either, and we'd prefer to perform a tentative\n      // parse in order to produce the right diagnostic.\n      return true;\n\n    case DeclaratorContext::KNRTypeList:\n    case DeclaratorContext::Member:\n    case DeclaratorContext::Prototype:\n    case DeclaratorContext::LambdaExprParameter:\n    case DeclaratorContext::ObjCParameter:\n    case DeclaratorContext::ObjCResult:\n    case DeclaratorContext::TemplateParam:\n    case DeclaratorContext::CXXCatch:\n    case DeclaratorContext::ObjCCatch:\n    case DeclaratorContext::TypeName:\n    case DeclaratorContext::FunctionalCast: // FIXME\n    case DeclaratorContext::CXXNew:\n    case DeclaratorContext::AliasDecl:\n    case DeclaratorContext::AliasTemplate:\n    case DeclaratorContext::BlockLiteral:\n    case DeclaratorContext::LambdaExpr:\n    case DeclaratorContext::ConversionId:\n    case DeclaratorContext::TemplateArg:\n    case DeclaratorContext::TemplateTypeArg:\n    case DeclaratorContext::TrailingReturn:\n    case DeclaratorContext::RequiresExpr:\n      return false;\n    }\n    llvm_unreachable(\"unknown context kind!\");\n  }\n\n  /// isPastIdentifier - Return true if we have parsed beyond the point where\n  /// the name would appear. (This may happen even if we haven't actually parsed\n  /// a name, perhaps because this context doesn't require one.)\n  bool isPastIdentifier() const { return Name.isValid(); }\n\n  /// hasName - Whether this declarator has a name, which might be an\n  /// identifier (accessible via getIdentifier()) or some kind of\n  /// special C++ name (constructor, destructor, etc.), or a structured\n  /// binding (which is not exactly a name, but occupies the same position).\n  bool hasName() const {\n    return Name.getKind() != UnqualifiedIdKind::IK_Identifier ||\n           Name.Identifier || isDecompositionDeclarator();\n  }\n\n  /// Return whether this declarator is a decomposition declarator.\n  bool isDecompositionDeclarator() const {\n    return BindingGroup.isSet();\n  }\n\n  IdentifierInfo *getIdentifier() const {\n    if (Name.getKind() == UnqualifiedIdKind::IK_Identifier)\n      return Name.Identifier;\n\n    return nullptr;\n  }\n  SourceLocation getIdentifierLoc() const { return Name.StartLocation; }\n\n  /// Set the name of this declarator to be the given identifier.\n  void SetIdentifier(IdentifierInfo *Id, SourceLocation IdLoc) {\n    Name.setIdentifier(Id, IdLoc);\n  }\n\n  /// Set the decomposition bindings for this declarator.\n  void\n  setDecompositionBindings(SourceLocation LSquareLoc,\n                           ArrayRef<DecompositionDeclarator::Binding> Bindings,\n                           SourceLocation RSquareLoc);\n\n  /// AddTypeInfo - Add a chunk to this declarator. Also extend the range to\n  /// EndLoc, which should be the last token of the chunk.\n  /// This function takes attrs by R-Value reference because it takes ownership\n  /// of those attributes from the parameter.\n  void AddTypeInfo(const DeclaratorChunk &TI, ParsedAttributes &&attrs,\n                   SourceLocation EndLoc) {\n    DeclTypeInfo.push_back(TI);\n    DeclTypeInfo.back().getAttrs().addAll(attrs.begin(), attrs.end());\n    getAttributePool().takeAllFrom(attrs.getPool());\n\n    if (!EndLoc.isInvalid())\n      SetRangeEnd(EndLoc);\n  }\n\n  /// AddTypeInfo - Add a chunk to this declarator. Also extend the range to\n  /// EndLoc, which should be the last token of the chunk.\n  void AddTypeInfo(const DeclaratorChunk &TI, SourceLocation EndLoc) {\n    DeclTypeInfo.push_back(TI);\n\n    if (!EndLoc.isInvalid())\n      SetRangeEnd(EndLoc);\n  }\n\n  /// Add a new innermost chunk to this declarator.\n  void AddInnermostTypeInfo(const DeclaratorChunk &TI) {\n    DeclTypeInfo.insert(DeclTypeInfo.begin(), TI);\n  }\n\n  /// Return the number of types applied to this declarator.\n  unsigned getNumTypeObjects() const { return DeclTypeInfo.size(); }\n\n  /// Return the specified TypeInfo from this declarator.  TypeInfo #0 is\n  /// closest to the identifier.\n  const DeclaratorChunk &getTypeObject(unsigned i) const {\n    assert(i < DeclTypeInfo.size() && \"Invalid type chunk\");\n    return DeclTypeInfo[i];\n  }\n  DeclaratorChunk &getTypeObject(unsigned i) {\n    assert(i < DeclTypeInfo.size() && \"Invalid type chunk\");\n    return DeclTypeInfo[i];\n  }\n\n  typedef SmallVectorImpl<DeclaratorChunk>::const_iterator type_object_iterator;\n  typedef llvm::iterator_range<type_object_iterator> type_object_range;\n\n  /// Returns the range of type objects, from the identifier outwards.\n  type_object_range type_objects() const {\n    return type_object_range(DeclTypeInfo.begin(), DeclTypeInfo.end());\n  }\n\n  void DropFirstTypeObject() {\n    assert(!DeclTypeInfo.empty() && \"No type chunks to drop.\");\n    DeclTypeInfo.front().destroy();\n    DeclTypeInfo.erase(DeclTypeInfo.begin());\n  }\n\n  /// Return the innermost (closest to the declarator) chunk of this\n  /// declarator that is not a parens chunk, or null if there are no\n  /// non-parens chunks.\n  const DeclaratorChunk *getInnermostNonParenChunk() const {\n    for (unsigned i = 0, i_end = DeclTypeInfo.size(); i < i_end; ++i) {\n      if (!DeclTypeInfo[i].isParen())\n        return &DeclTypeInfo[i];\n    }\n    return nullptr;\n  }\n\n  /// Return the outermost (furthest from the declarator) chunk of\n  /// this declarator that is not a parens chunk, or null if there are\n  /// no non-parens chunks.\n  const DeclaratorChunk *getOutermostNonParenChunk() const {\n    for (unsigned i = DeclTypeInfo.size(), i_end = 0; i != i_end; --i) {\n      if (!DeclTypeInfo[i-1].isParen())\n        return &DeclTypeInfo[i-1];\n    }\n    return nullptr;\n  }\n\n  /// isArrayOfUnknownBound - This method returns true if the declarator\n  /// is a declarator for an array of unknown bound (looking through\n  /// parentheses).\n  bool isArrayOfUnknownBound() const {\n    const DeclaratorChunk *chunk = getInnermostNonParenChunk();\n    return (chunk && chunk->Kind == DeclaratorChunk::Array &&\n            !chunk->Arr.NumElts);\n  }\n\n  /// isFunctionDeclarator - This method returns true if the declarator\n  /// is a function declarator (looking through parentheses).\n  /// If true is returned, then the reference type parameter idx is\n  /// assigned with the index of the declaration chunk.\n  bool isFunctionDeclarator(unsigned& idx) const {\n    for (unsigned i = 0, i_end = DeclTypeInfo.size(); i < i_end; ++i) {\n      switch (DeclTypeInfo[i].Kind) {\n      case DeclaratorChunk::Function:\n        idx = i;\n        return true;\n      case DeclaratorChunk::Paren:\n        continue;\n      case DeclaratorChunk::Pointer:\n      case DeclaratorChunk::Reference:\n      case DeclaratorChunk::Array:\n      case DeclaratorChunk::BlockPointer:\n      case DeclaratorChunk::MemberPointer:\n      case DeclaratorChunk::Pipe:\n        return false;\n      }\n      llvm_unreachable(\"Invalid type chunk\");\n    }\n    return false;\n  }\n\n  /// isFunctionDeclarator - Once this declarator is fully parsed and formed,\n  /// this method returns true if the identifier is a function declarator\n  /// (looking through parentheses).\n  bool isFunctionDeclarator() const {\n    unsigned index;\n    return isFunctionDeclarator(index);\n  }\n\n  /// getFunctionTypeInfo - Retrieves the function type info object\n  /// (looking through parentheses).\n  DeclaratorChunk::FunctionTypeInfo &getFunctionTypeInfo() {\n    assert(isFunctionDeclarator() && \"Not a function declarator!\");\n    unsigned index = 0;\n    isFunctionDeclarator(index);\n    return DeclTypeInfo[index].Fun;\n  }\n\n  /// getFunctionTypeInfo - Retrieves the function type info object\n  /// (looking through parentheses).\n  const DeclaratorChunk::FunctionTypeInfo &getFunctionTypeInfo() const {\n    return const_cast<Declarator*>(this)->getFunctionTypeInfo();\n  }\n\n  /// Determine whether the declaration that will be produced from\n  /// this declaration will be a function.\n  ///\n  /// A declaration can declare a function even if the declarator itself\n  /// isn't a function declarator, if the type specifier refers to a function\n  /// type. This routine checks for both cases.\n  bool isDeclarationOfFunction() const;\n\n  /// Return true if this declaration appears in a context where a\n  /// function declarator would be a function declaration.\n  bool isFunctionDeclarationContext() const {\n    if (getDeclSpec().getStorageClassSpec() == DeclSpec::SCS_typedef)\n      return false;\n\n    switch (Context) {\n    case DeclaratorContext::File:\n    case DeclaratorContext::Member:\n    case DeclaratorContext::Block:\n    case DeclaratorContext::ForInit:\n    case DeclaratorContext::SelectionInit:\n      return true;\n\n    case DeclaratorContext::Condition:\n    case DeclaratorContext::KNRTypeList:\n    case DeclaratorContext::TypeName:\n    case DeclaratorContext::FunctionalCast:\n    case DeclaratorContext::AliasDecl:\n    case DeclaratorContext::AliasTemplate:\n    case DeclaratorContext::Prototype:\n    case DeclaratorContext::LambdaExprParameter:\n    case DeclaratorContext::ObjCParameter:\n    case DeclaratorContext::ObjCResult:\n    case DeclaratorContext::TemplateParam:\n    case DeclaratorContext::CXXNew:\n    case DeclaratorContext::CXXCatch:\n    case DeclaratorContext::ObjCCatch:\n    case DeclaratorContext::BlockLiteral:\n    case DeclaratorContext::LambdaExpr:\n    case DeclaratorContext::ConversionId:\n    case DeclaratorContext::TemplateArg:\n    case DeclaratorContext::TemplateTypeArg:\n    case DeclaratorContext::TrailingReturn:\n    case DeclaratorContext::TrailingReturnVar:\n    case DeclaratorContext::RequiresExpr:\n      return false;\n    }\n    llvm_unreachable(\"unknown context kind!\");\n  }\n\n  /// Determine whether this declaration appears in a context where an\n  /// expression could appear.\n  bool isExpressionContext() const {\n    switch (Context) {\n    case DeclaratorContext::File:\n    case DeclaratorContext::KNRTypeList:\n    case DeclaratorContext::Member:\n\n    // FIXME: sizeof(...) permits an expression.\n    case DeclaratorContext::TypeName:\n\n    case DeclaratorContext::FunctionalCast:\n    case DeclaratorContext::AliasDecl:\n    case DeclaratorContext::AliasTemplate:\n    case DeclaratorContext::Prototype:\n    case DeclaratorContext::LambdaExprParameter:\n    case DeclaratorContext::ObjCParameter:\n    case DeclaratorContext::ObjCResult:\n    case DeclaratorContext::TemplateParam:\n    case DeclaratorContext::CXXNew:\n    case DeclaratorContext::CXXCatch:\n    case DeclaratorContext::ObjCCatch:\n    case DeclaratorContext::BlockLiteral:\n    case DeclaratorContext::LambdaExpr:\n    case DeclaratorContext::ConversionId:\n    case DeclaratorContext::TrailingReturn:\n    case DeclaratorContext::TrailingReturnVar:\n    case DeclaratorContext::TemplateTypeArg:\n    case DeclaratorContext::RequiresExpr:\n      return false;\n\n    case DeclaratorContext::Block:\n    case DeclaratorContext::ForInit:\n    case DeclaratorContext::SelectionInit:\n    case DeclaratorContext::Condition:\n    case DeclaratorContext::TemplateArg:\n      return true;\n    }\n\n    llvm_unreachable(\"unknown context kind!\");\n  }\n\n  /// Return true if a function declarator at this position would be a\n  /// function declaration.\n  bool isFunctionDeclaratorAFunctionDeclaration() const {\n    if (!isFunctionDeclarationContext())\n      return false;\n\n    for (unsigned I = 0, N = getNumTypeObjects(); I != N; ++I)\n      if (getTypeObject(I).Kind != DeclaratorChunk::Paren)\n        return false;\n\n    return true;\n  }\n\n  /// Determine whether a trailing return type was written (at any\n  /// level) within this declarator.\n  bool hasTrailingReturnType() const {\n    for (const auto &Chunk : type_objects())\n      if (Chunk.Kind == DeclaratorChunk::Function &&\n          Chunk.Fun.hasTrailingReturnType())\n        return true;\n    return false;\n  }\n  /// Get the trailing return type appearing (at any level) within this\n  /// declarator.\n  ParsedType getTrailingReturnType() const {\n    for (const auto &Chunk : type_objects())\n      if (Chunk.Kind == DeclaratorChunk::Function &&\n          Chunk.Fun.hasTrailingReturnType())\n        return Chunk.Fun.getTrailingReturnType();\n    return ParsedType();\n  }\n\n  /// \\brief Sets a trailing requires clause for this declarator.\n  void setTrailingRequiresClause(Expr *TRC) {\n    TrailingRequiresClause = TRC;\n\n    SetRangeEnd(TRC->getEndLoc());\n  }\n\n  /// \\brief Sets a trailing requires clause for this declarator.\n  Expr *getTrailingRequiresClause() {\n    return TrailingRequiresClause;\n  }\n\n  /// \\brief Determine whether a trailing requires clause was written in this\n  /// declarator.\n  bool hasTrailingRequiresClause() const {\n    return TrailingRequiresClause != nullptr;\n  }\n\n  /// Sets the template parameter lists that preceded the declarator.\n  void setTemplateParameterLists(ArrayRef<TemplateParameterList *> TPLs) {\n    TemplateParameterLists = TPLs;\n  }\n\n  /// The template parameter lists that preceded the declarator.\n  ArrayRef<TemplateParameterList *> getTemplateParameterLists() const {\n    return TemplateParameterLists;\n  }\n\n  /// Sets the template parameter list generated from the explicit template\n  /// parameters along with any invented template parameters from\n  /// placeholder-typed parameters.\n  void setInventedTemplateParameterList(TemplateParameterList *Invented) {\n    InventedTemplateParameterList = Invented;\n  }\n\n  /// The template parameter list generated from the explicit template\n  /// parameters along with any invented template parameters from\n  /// placeholder-typed parameters, if there were any such parameters.\n  TemplateParameterList * getInventedTemplateParameterList() const {\n    return InventedTemplateParameterList;\n  }\n\n  /// takeAttributes - Takes attributes from the given parsed-attributes\n  /// set and add them to this declarator.\n  ///\n  /// These examples both add 3 attributes to \"var\":\n  ///  short int var __attribute__((aligned(16),common,deprecated));\n  ///  short int x, __attribute__((aligned(16)) var\n  ///                                 __attribute__((common,deprecated));\n  ///\n  /// Also extends the range of the declarator.\n  void takeAttributes(ParsedAttributes &attrs, SourceLocation lastLoc) {\n    Attrs.takeAllFrom(attrs);\n\n    if (!lastLoc.isInvalid())\n      SetRangeEnd(lastLoc);\n  }\n\n  const ParsedAttributes &getAttributes() const { return Attrs; }\n  ParsedAttributes &getAttributes() { return Attrs; }\n\n  /// hasAttributes - do we contain any attributes?\n  bool hasAttributes() const {\n    if (!getAttributes().empty() || getDeclSpec().hasAttributes())\n      return true;\n    for (unsigned i = 0, e = getNumTypeObjects(); i != e; ++i)\n      if (!getTypeObject(i).getAttrs().empty())\n        return true;\n    return false;\n  }\n\n  /// Return a source range list of C++11 attributes associated\n  /// with the declarator.\n  void getCXX11AttributeRanges(SmallVectorImpl<SourceRange> &Ranges) {\n    for (const ParsedAttr &AL : Attrs)\n      if (AL.isCXX11Attribute())\n        Ranges.push_back(AL.getRange());\n  }\n\n  void setAsmLabel(Expr *E) { AsmLabel = E; }\n  Expr *getAsmLabel() const { return AsmLabel; }\n\n  void setExtension(bool Val = true) { Extension = Val; }\n  bool getExtension() const { return Extension; }\n\n  void setObjCIvar(bool Val = true) { ObjCIvar = Val; }\n  bool isObjCIvar() const { return ObjCIvar; }\n\n  void setObjCWeakProperty(bool Val = true) { ObjCWeakProperty = Val; }\n  bool isObjCWeakProperty() const { return ObjCWeakProperty; }\n\n  void setInvalidType(bool Val = true) { InvalidType = Val; }\n  bool isInvalidType() const {\n    return InvalidType || DS.getTypeSpecType() == DeclSpec::TST_error;\n  }\n\n  void setGroupingParens(bool flag) { GroupingParens = flag; }\n  bool hasGroupingParens() const { return GroupingParens; }\n\n  bool isFirstDeclarator() const { return !CommaLoc.isValid(); }\n  SourceLocation getCommaLoc() const { return CommaLoc; }\n  void setCommaLoc(SourceLocation CL) { CommaLoc = CL; }\n\n  bool hasEllipsis() const { return EllipsisLoc.isValid(); }\n  SourceLocation getEllipsisLoc() const { return EllipsisLoc; }\n  void setEllipsisLoc(SourceLocation EL) { EllipsisLoc = EL; }\n\n  void setFunctionDefinitionKind(FunctionDefinitionKind Val) {\n    FunctionDefinition = static_cast<unsigned>(Val);\n  }\n\n  bool isFunctionDefinition() const {\n    return getFunctionDefinitionKind() != FunctionDefinitionKind::Declaration;\n  }\n\n  FunctionDefinitionKind getFunctionDefinitionKind() const {\n    return (FunctionDefinitionKind)FunctionDefinition;\n  }\n\n  void setHasInitializer(bool Val = true) { HasInitializer = Val; }\n  bool hasInitializer() const { return HasInitializer; }\n\n  /// Returns true if this declares a real member and not a friend.\n  bool isFirstDeclarationOfMember() {\n    return getContext() == DeclaratorContext::Member &&\n           !getDeclSpec().isFriendSpecified();\n  }\n\n  /// Returns true if this declares a static member.  This cannot be called on a\n  /// declarator outside of a MemberContext because we won't know until\n  /// redeclaration time if the decl is static.\n  bool isStaticMember();\n\n  /// Returns true if this declares a constructor or a destructor.\n  bool isCtorOrDtor();\n\n  void setRedeclaration(bool Val) { Redeclaration = Val; }\n  bool isRedeclaration() const { return Redeclaration; }\n};\n\n/// This little struct is used to capture information about\n/// structure field declarators, which is basically just a bitfield size.\nstruct FieldDeclarator {\n  Declarator D;\n  Expr *BitfieldSize;\n  explicit FieldDeclarator(const DeclSpec &DS)\n      : D(DS, DeclaratorContext::Member), BitfieldSize(nullptr) {}\n};\n\n/// Represents a C++11 virt-specifier-seq.\nclass VirtSpecifiers {\npublic:\n  enum Specifier {\n    VS_None = 0,\n    VS_Override = 1,\n    VS_Final = 2,\n    VS_Sealed = 4,\n    // Represents the __final keyword, which is legal for gcc in pre-C++11 mode.\n    VS_GNU_Final = 8\n  };\n\n  VirtSpecifiers() : Specifiers(0), LastSpecifier(VS_None) { }\n\n  bool SetSpecifier(Specifier VS, SourceLocation Loc,\n                    const char *&PrevSpec);\n\n  bool isUnset() const { return Specifiers == 0; }\n\n  bool isOverrideSpecified() const { return Specifiers & VS_Override; }\n  SourceLocation getOverrideLoc() const { return VS_overrideLoc; }\n\n  bool isFinalSpecified() const { return Specifiers & (VS_Final | VS_Sealed | VS_GNU_Final); }\n  bool isFinalSpelledSealed() const { return Specifiers & VS_Sealed; }\n  SourceLocation getFinalLoc() const { return VS_finalLoc; }\n\n  void clear() { Specifiers = 0; }\n\n  static const char *getSpecifierName(Specifier VS);\n\n  SourceLocation getFirstLocation() const { return FirstLocation; }\n  SourceLocation getLastLocation() const { return LastLocation; }\n  Specifier getLastSpecifier() const { return LastSpecifier; }\n\nprivate:\n  unsigned Specifiers;\n  Specifier LastSpecifier;\n\n  SourceLocation VS_overrideLoc, VS_finalLoc;\n  SourceLocation FirstLocation;\n  SourceLocation LastLocation;\n};\n\nenum class LambdaCaptureInitKind {\n  NoInit,     //!< [a]\n  CopyInit,   //!< [a = b], [a = {b}]\n  DirectInit, //!< [a(b)]\n  ListInit    //!< [a{b}]\n};\n\n/// Represents a complete lambda introducer.\nstruct LambdaIntroducer {\n  /// An individual capture in a lambda introducer.\n  struct LambdaCapture {\n    LambdaCaptureKind Kind;\n    SourceLocation Loc;\n    IdentifierInfo *Id;\n    SourceLocation EllipsisLoc;\n    LambdaCaptureInitKind InitKind;\n    ExprResult Init;\n    ParsedType InitCaptureType;\n    SourceRange ExplicitRange;\n\n    LambdaCapture(LambdaCaptureKind Kind, SourceLocation Loc,\n                  IdentifierInfo *Id, SourceLocation EllipsisLoc,\n                  LambdaCaptureInitKind InitKind, ExprResult Init,\n                  ParsedType InitCaptureType,\n                  SourceRange ExplicitRange)\n        : Kind(Kind), Loc(Loc), Id(Id), EllipsisLoc(EllipsisLoc),\n          InitKind(InitKind), Init(Init), InitCaptureType(InitCaptureType),\n          ExplicitRange(ExplicitRange) {}\n  };\n\n  SourceRange Range;\n  SourceLocation DefaultLoc;\n  LambdaCaptureDefault Default;\n  SmallVector<LambdaCapture, 4> Captures;\n\n  LambdaIntroducer()\n    : Default(LCD_None) {}\n\n  /// Append a capture in a lambda introducer.\n  void addCapture(LambdaCaptureKind Kind,\n                  SourceLocation Loc,\n                  IdentifierInfo* Id,\n                  SourceLocation EllipsisLoc,\n                  LambdaCaptureInitKind InitKind,\n                  ExprResult Init,\n                  ParsedType InitCaptureType,\n                  SourceRange ExplicitRange) {\n    Captures.push_back(LambdaCapture(Kind, Loc, Id, EllipsisLoc, InitKind, Init,\n                                     InitCaptureType, ExplicitRange));\n  }\n};\n\nstruct InventedTemplateParameterInfo {\n  /// The number of parameters in the template parameter list that were\n  /// explicitly specified by the user, as opposed to being invented by use\n  /// of an auto parameter.\n  unsigned NumExplicitTemplateParams = 0;\n\n  /// If this is a generic lambda or abbreviated function template, use this\n  /// as the depth of each 'auto' parameter, during initial AST construction.\n  unsigned AutoTemplateParameterDepth = 0;\n\n  /// Store the list of the template parameters for a generic lambda or an\n  /// abbreviated function template.\n  /// If this is a generic lambda or abbreviated function template, this holds\n  /// the explicit template parameters followed by the auto parameters\n  /// converted into TemplateTypeParmDecls.\n  /// It can be used to construct the generic lambda or abbreviated template's\n  /// template parameter list during initial AST construction.\n  SmallVector<NamedDecl*, 4> TemplateParams;\n};\n\n} // end namespace clang\n\n#endif // LLVM_CLANG_SEMA_DECLSPEC_H\n"}, "91": {"id": 91, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/ParsedAttr.h", "content": "//======- ParsedAttr.h - Parsed attribute sets ------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the ParsedAttr class, which is used to collect\n// parsed attributes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SEMA_ATTRIBUTELIST_H\n#define LLVM_CLANG_SEMA_ATTRIBUTELIST_H\n\n#include \"clang/Basic/AttrSubjectMatchRules.h\"\n#include \"clang/Basic/AttributeCommonInfo.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Sema/Ownership.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/TinyPtrVector.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Registry.h\"\n#include \"llvm/Support/VersionTuple.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstring>\n#include <utility>\n\nnamespace clang {\n\nclass ASTContext;\nclass Decl;\nclass Expr;\nclass IdentifierInfo;\nclass LangOptions;\nclass ParsedAttr;\nclass Sema;\nclass TargetInfo;\n\nstruct ParsedAttrInfo {\n  /// Corresponds to the Kind enum.\n  unsigned AttrKind : 16;\n  /// The number of required arguments of this attribute.\n  unsigned NumArgs : 4;\n  /// The number of optional arguments of this attributes.\n  unsigned OptArgs : 4;\n  /// True if the parsing does not match the semantic content.\n  unsigned HasCustomParsing : 1;\n  /// True if this attribute is only available for certain targets.\n  unsigned IsTargetSpecific : 1;\n  /// True if this attribute applies to types.\n  unsigned IsType : 1;\n  /// True if this attribute applies to statements.\n  unsigned IsStmt : 1;\n  /// True if this attribute has any spellings that are known to gcc.\n  unsigned IsKnownToGCC : 1;\n  /// True if this attribute is supported by #pragma clang attribute.\n  unsigned IsSupportedByPragmaAttribute : 1;\n  /// The syntaxes supported by this attribute and how they're spelled.\n  struct Spelling {\n    AttributeCommonInfo::Syntax Syntax;\n    const char *NormalizedFullName;\n  };\n  ArrayRef<Spelling> Spellings;\n\n  ParsedAttrInfo(AttributeCommonInfo::Kind AttrKind =\n                     AttributeCommonInfo::NoSemaHandlerAttribute)\n      : AttrKind(AttrKind), NumArgs(0), OptArgs(0), HasCustomParsing(0),\n        IsTargetSpecific(0), IsType(0), IsStmt(0), IsKnownToGCC(0),\n        IsSupportedByPragmaAttribute(0) {}\n\n  virtual ~ParsedAttrInfo() = default;\n\n  /// Check if this attribute appertains to D, and issue a diagnostic if not.\n  virtual bool diagAppertainsToDecl(Sema &S, const ParsedAttr &Attr,\n                                    const Decl *D) const {\n    return true;\n  }\n  /// Check if this attribute is allowed by the language we are compiling, and\n  /// issue a diagnostic if not.\n  virtual bool diagLangOpts(Sema &S, const ParsedAttr &Attr) const {\n    return true;\n  }\n  /// Check if this attribute is allowed when compiling for the given target.\n  virtual bool existsInTarget(const TargetInfo &Target) const {\n    return true;\n  }\n  /// Convert the spelling index of Attr to a semantic spelling enum value.\n  virtual unsigned\n  spellingIndexToSemanticSpelling(const ParsedAttr &Attr) const {\n    return UINT_MAX;\n  }\n  /// Populate Rules with the match rules of this attribute.\n  virtual void getPragmaAttributeMatchRules(\n      llvm::SmallVectorImpl<std::pair<attr::SubjectMatchRule, bool>> &Rules,\n      const LangOptions &LangOpts) const {\n  }\n  enum AttrHandling {\n    NotHandled,\n    AttributeApplied,\n    AttributeNotApplied\n  };\n  /// If this ParsedAttrInfo knows how to handle this ParsedAttr applied to this\n  /// Decl then do so and return either AttributeApplied if it was applied or\n  /// AttributeNotApplied if it wasn't. Otherwise return NotHandled.\n  virtual AttrHandling handleDeclAttribute(Sema &S, Decl *D,\n                                           const ParsedAttr &Attr) const {\n    return NotHandled;\n  }\n\n  static const ParsedAttrInfo &get(const AttributeCommonInfo &A);\n};\n\ntypedef llvm::Registry<ParsedAttrInfo> ParsedAttrInfoRegistry;\n\n/// Represents information about a change in availability for\n/// an entity, which is part of the encoding of the 'availability'\n/// attribute.\nstruct AvailabilityChange {\n  /// The location of the keyword indicating the kind of change.\n  SourceLocation KeywordLoc;\n\n  /// The version number at which the change occurred.\n  VersionTuple Version;\n\n  /// The source range covering the version number.\n  SourceRange VersionRange;\n\n  /// Determine whether this availability change is valid.\n  bool isValid() const { return !Version.empty(); }\n};\n\nnamespace detail {\nenum AvailabilitySlot {\n  IntroducedSlot, DeprecatedSlot, ObsoletedSlot, NumAvailabilitySlots\n};\n\n/// Describes the trailing object for Availability attribute in ParsedAttr.\nstruct AvailabilityData {\n  AvailabilityChange Changes[NumAvailabilitySlots];\n  SourceLocation StrictLoc;\n  const Expr *Replacement;\n\n  AvailabilityData(const AvailabilityChange &Introduced,\n                   const AvailabilityChange &Deprecated,\n                   const AvailabilityChange &Obsoleted,\n                   SourceLocation Strict, const Expr *ReplaceExpr)\n    : StrictLoc(Strict), Replacement(ReplaceExpr) {\n    Changes[IntroducedSlot] = Introduced;\n    Changes[DeprecatedSlot] = Deprecated;\n    Changes[ObsoletedSlot] = Obsoleted;\n  }\n};\n\nstruct TypeTagForDatatypeData {\n  ParsedType MatchingCType;\n  unsigned LayoutCompatible : 1;\n  unsigned MustBeNull : 1;\n};\nstruct PropertyData {\n  IdentifierInfo *GetterId, *SetterId;\n\n  PropertyData(IdentifierInfo *getterId, IdentifierInfo *setterId)\n      : GetterId(getterId), SetterId(setterId) {}\n};\n\n} // namespace\n\n/// Wraps an identifier and optional source location for the identifier.\nstruct IdentifierLoc {\n  SourceLocation Loc;\n  IdentifierInfo *Ident;\n\n  static IdentifierLoc *create(ASTContext &Ctx, SourceLocation Loc,\n                               IdentifierInfo *Ident);\n};\n\n/// A union of the various pointer types that can be passed to an\n/// ParsedAttr as an argument.\nusing ArgsUnion = llvm::PointerUnion<Expr *, IdentifierLoc *>;\nusing ArgsVector = llvm::SmallVector<ArgsUnion, 12U>;\n\n/// ParsedAttr - Represents a syntactic attribute.\n///\n/// For a GNU attribute, there are four forms of this construct:\n///\n/// 1: __attribute__(( const )). ParmName/Args/NumArgs will all be unused.\n/// 2: __attribute__(( mode(byte) )). ParmName used, Args/NumArgs unused.\n/// 3: __attribute__(( format(printf, 1, 2) )). ParmName/Args/NumArgs all used.\n/// 4: __attribute__(( aligned(16) )). ParmName is unused, Args/Num used.\n///\nclass ParsedAttr final\n    : public AttributeCommonInfo,\n      private llvm::TrailingObjects<\n          ParsedAttr, ArgsUnion, detail::AvailabilityData,\n          detail::TypeTagForDatatypeData, ParsedType, detail::PropertyData> {\n  friend TrailingObjects;\n\n  size_t numTrailingObjects(OverloadToken<ArgsUnion>) const { return NumArgs; }\n  size_t numTrailingObjects(OverloadToken<detail::AvailabilityData>) const {\n    return IsAvailability;\n  }\n  size_t\n      numTrailingObjects(OverloadToken<detail::TypeTagForDatatypeData>) const {\n    return IsTypeTagForDatatype;\n  }\n  size_t numTrailingObjects(OverloadToken<ParsedType>) const {\n    return HasParsedType;\n  }\n  size_t numTrailingObjects(OverloadToken<detail::PropertyData>) const {\n    return IsProperty;\n  }\n\nprivate:\n  IdentifierInfo *MacroII = nullptr;\n  SourceLocation MacroExpansionLoc;\n  SourceLocation EllipsisLoc;\n\n  /// The number of expression arguments this attribute has.\n  /// The expressions themselves are stored after the object.\n  unsigned NumArgs : 16;\n\n  /// True if already diagnosed as invalid.\n  mutable unsigned Invalid : 1;\n\n  /// True if this attribute was used as a type attribute.\n  mutable unsigned UsedAsTypeAttr : 1;\n\n  /// True if this has the extra information associated with an\n  /// availability attribute.\n  unsigned IsAvailability : 1;\n\n  /// True if this has extra information associated with a\n  /// type_tag_for_datatype attribute.\n  unsigned IsTypeTagForDatatype : 1;\n\n  /// True if this has extra information associated with a\n  /// Microsoft __delcspec(property) attribute.\n  unsigned IsProperty : 1;\n\n  /// True if this has a ParsedType\n  unsigned HasParsedType : 1;\n\n  /// True if the processing cache is valid.\n  mutable unsigned HasProcessingCache : 1;\n\n  /// A cached value.\n  mutable unsigned ProcessingCache : 8;\n\n  /// True if the attribute is specified using '#pragma clang attribute'.\n  mutable unsigned IsPragmaClangAttribute : 1;\n\n  /// The location of the 'unavailable' keyword in an\n  /// availability attribute.\n  SourceLocation UnavailableLoc;\n\n  const Expr *MessageExpr;\n\n  const ParsedAttrInfo &Info;\n\n  ArgsUnion *getArgsBuffer() { return getTrailingObjects<ArgsUnion>(); }\n  ArgsUnion const *getArgsBuffer() const {\n    return getTrailingObjects<ArgsUnion>();\n  }\n\n  detail::AvailabilityData *getAvailabilityData() {\n    return getTrailingObjects<detail::AvailabilityData>();\n  }\n  const detail::AvailabilityData *getAvailabilityData() const {\n    return getTrailingObjects<detail::AvailabilityData>();\n  }\n\nprivate:\n  friend class AttributeFactory;\n  friend class AttributePool;\n\n  /// Constructor for attributes with expression arguments.\n  ParsedAttr(IdentifierInfo *attrName, SourceRange attrRange,\n             IdentifierInfo *scopeName, SourceLocation scopeLoc,\n             ArgsUnion *args, unsigned numArgs, Syntax syntaxUsed,\n             SourceLocation ellipsisLoc)\n      : AttributeCommonInfo(attrName, scopeName, attrRange, scopeLoc,\n                            syntaxUsed),\n        EllipsisLoc(ellipsisLoc), NumArgs(numArgs), Invalid(false),\n        UsedAsTypeAttr(false), IsAvailability(false),\n        IsTypeTagForDatatype(false), IsProperty(false), HasParsedType(false),\n        HasProcessingCache(false), IsPragmaClangAttribute(false),\n        Info(ParsedAttrInfo::get(*this)) {\n    if (numArgs)\n      memcpy(getArgsBuffer(), args, numArgs * sizeof(ArgsUnion));\n  }\n\n  /// Constructor for availability attributes.\n  ParsedAttr(IdentifierInfo *attrName, SourceRange attrRange,\n             IdentifierInfo *scopeName, SourceLocation scopeLoc,\n             IdentifierLoc *Parm, const AvailabilityChange &introduced,\n             const AvailabilityChange &deprecated,\n             const AvailabilityChange &obsoleted, SourceLocation unavailable,\n             const Expr *messageExpr, Syntax syntaxUsed, SourceLocation strict,\n             const Expr *replacementExpr)\n      : AttributeCommonInfo(attrName, scopeName, attrRange, scopeLoc,\n                            syntaxUsed),\n        NumArgs(1), Invalid(false), UsedAsTypeAttr(false), IsAvailability(true),\n        IsTypeTagForDatatype(false), IsProperty(false), HasParsedType(false),\n        HasProcessingCache(false), IsPragmaClangAttribute(false),\n        UnavailableLoc(unavailable), MessageExpr(messageExpr),\n        Info(ParsedAttrInfo::get(*this)) {\n    ArgsUnion PVal(Parm);\n    memcpy(getArgsBuffer(), &PVal, sizeof(ArgsUnion));\n    new (getAvailabilityData()) detail::AvailabilityData(\n        introduced, deprecated, obsoleted, strict, replacementExpr);\n  }\n\n  /// Constructor for objc_bridge_related attributes.\n  ParsedAttr(IdentifierInfo *attrName, SourceRange attrRange,\n             IdentifierInfo *scopeName, SourceLocation scopeLoc,\n             IdentifierLoc *Parm1, IdentifierLoc *Parm2, IdentifierLoc *Parm3,\n             Syntax syntaxUsed)\n      : AttributeCommonInfo(attrName, scopeName, attrRange, scopeLoc,\n                            syntaxUsed),\n        NumArgs(3), Invalid(false), UsedAsTypeAttr(false),\n        IsAvailability(false), IsTypeTagForDatatype(false), IsProperty(false),\n        HasParsedType(false), HasProcessingCache(false),\n        IsPragmaClangAttribute(false), Info(ParsedAttrInfo::get(*this)) {\n    ArgsUnion *Args = getArgsBuffer();\n    Args[0] = Parm1;\n    Args[1] = Parm2;\n    Args[2] = Parm3;\n  }\n\n  /// Constructor for type_tag_for_datatype attribute.\n  ParsedAttr(IdentifierInfo *attrName, SourceRange attrRange,\n             IdentifierInfo *scopeName, SourceLocation scopeLoc,\n             IdentifierLoc *ArgKind, ParsedType matchingCType,\n             bool layoutCompatible, bool mustBeNull, Syntax syntaxUsed)\n      : AttributeCommonInfo(attrName, scopeName, attrRange, scopeLoc,\n                            syntaxUsed),\n        NumArgs(1), Invalid(false), UsedAsTypeAttr(false),\n        IsAvailability(false), IsTypeTagForDatatype(true), IsProperty(false),\n        HasParsedType(false), HasProcessingCache(false),\n        IsPragmaClangAttribute(false), Info(ParsedAttrInfo::get(*this)) {\n    ArgsUnion PVal(ArgKind);\n    memcpy(getArgsBuffer(), &PVal, sizeof(ArgsUnion));\n    detail::TypeTagForDatatypeData &ExtraData = getTypeTagForDatatypeDataSlot();\n    new (&ExtraData.MatchingCType) ParsedType(matchingCType);\n    ExtraData.LayoutCompatible = layoutCompatible;\n    ExtraData.MustBeNull = mustBeNull;\n  }\n\n  /// Constructor for attributes with a single type argument.\n  ParsedAttr(IdentifierInfo *attrName, SourceRange attrRange,\n             IdentifierInfo *scopeName, SourceLocation scopeLoc,\n             ParsedType typeArg, Syntax syntaxUsed)\n      : AttributeCommonInfo(attrName, scopeName, attrRange, scopeLoc,\n                            syntaxUsed),\n        NumArgs(0), Invalid(false), UsedAsTypeAttr(false),\n        IsAvailability(false), IsTypeTagForDatatype(false), IsProperty(false),\n        HasParsedType(true), HasProcessingCache(false),\n        IsPragmaClangAttribute(false), Info(ParsedAttrInfo::get(*this)) {\n    new (&getTypeBuffer()) ParsedType(typeArg);\n  }\n\n  /// Constructor for microsoft __declspec(property) attribute.\n  ParsedAttr(IdentifierInfo *attrName, SourceRange attrRange,\n             IdentifierInfo *scopeName, SourceLocation scopeLoc,\n             IdentifierInfo *getterId, IdentifierInfo *setterId,\n             Syntax syntaxUsed)\n      : AttributeCommonInfo(attrName, scopeName, attrRange, scopeLoc,\n                            syntaxUsed),\n        NumArgs(0), Invalid(false), UsedAsTypeAttr(false),\n        IsAvailability(false), IsTypeTagForDatatype(false), IsProperty(true),\n        HasParsedType(false), HasProcessingCache(false),\n        IsPragmaClangAttribute(false), Info(ParsedAttrInfo::get(*this)) {\n    new (&getPropertyDataBuffer()) detail::PropertyData(getterId, setterId);\n  }\n\n  /// Type tag information is stored immediately following the arguments, if\n  /// any, at the end of the object.  They are mutually exclusive with\n  /// availability slots.\n  detail::TypeTagForDatatypeData &getTypeTagForDatatypeDataSlot() {\n    return *getTrailingObjects<detail::TypeTagForDatatypeData>();\n  }\n  const detail::TypeTagForDatatypeData &getTypeTagForDatatypeDataSlot() const {\n    return *getTrailingObjects<detail::TypeTagForDatatypeData>();\n  }\n\n  /// The type buffer immediately follows the object and are mutually exclusive\n  /// with arguments.\n  ParsedType &getTypeBuffer() { return *getTrailingObjects<ParsedType>(); }\n  const ParsedType &getTypeBuffer() const {\n    return *getTrailingObjects<ParsedType>();\n  }\n\n  /// The property data immediately follows the object is is mutually exclusive\n  /// with arguments.\n  detail::PropertyData &getPropertyDataBuffer() {\n    assert(IsProperty);\n    return *getTrailingObjects<detail::PropertyData>();\n  }\n  const detail::PropertyData &getPropertyDataBuffer() const {\n    assert(IsProperty);\n    return *getTrailingObjects<detail::PropertyData>();\n  }\n\n  size_t allocated_size() const;\n\npublic:\n  ParsedAttr(const ParsedAttr &) = delete;\n  ParsedAttr(ParsedAttr &&) = delete;\n  ParsedAttr &operator=(const ParsedAttr &) = delete;\n  ParsedAttr &operator=(ParsedAttr &&) = delete;\n  ~ParsedAttr() = delete;\n\n  void operator delete(void *) = delete;\n\n  bool hasParsedType() const { return HasParsedType; }\n\n  /// Is this the Microsoft __declspec(property) attribute?\n  bool isDeclspecPropertyAttribute() const  {\n    return IsProperty;\n  }\n\n  bool isInvalid() const { return Invalid; }\n  void setInvalid(bool b = true) const { Invalid = b; }\n\n  bool hasProcessingCache() const { return HasProcessingCache; }\n\n  unsigned getProcessingCache() const {\n    assert(hasProcessingCache());\n    return ProcessingCache;\n  }\n\n  void setProcessingCache(unsigned value) const {\n    ProcessingCache = value;\n    HasProcessingCache = true;\n  }\n\n  bool isUsedAsTypeAttr() const { return UsedAsTypeAttr; }\n  void setUsedAsTypeAttr(bool Used = true) { UsedAsTypeAttr = Used; }\n\n  /// True if the attribute is specified using '#pragma clang attribute'.\n  bool isPragmaClangAttribute() const { return IsPragmaClangAttribute; }\n\n  void setIsPragmaClangAttribute() { IsPragmaClangAttribute = true; }\n\n  bool isPackExpansion() const { return EllipsisLoc.isValid(); }\n  SourceLocation getEllipsisLoc() const { return EllipsisLoc; }\n\n  /// getNumArgs - Return the number of actual arguments to this attribute.\n  unsigned getNumArgs() const { return NumArgs; }\n\n  /// getArg - Return the specified argument.\n  ArgsUnion getArg(unsigned Arg) const {\n    assert(Arg < NumArgs && \"Arg access out of range!\");\n    return getArgsBuffer()[Arg];\n  }\n\n  bool isArgExpr(unsigned Arg) const {\n    return Arg < NumArgs && getArg(Arg).is<Expr*>();\n  }\n\n  Expr *getArgAsExpr(unsigned Arg) const {\n    return getArg(Arg).get<Expr*>();\n  }\n\n  bool isArgIdent(unsigned Arg) const {\n    return Arg < NumArgs && getArg(Arg).is<IdentifierLoc*>();\n  }\n\n  IdentifierLoc *getArgAsIdent(unsigned Arg) const {\n    return getArg(Arg).get<IdentifierLoc*>();\n  }\n\n  const AvailabilityChange &getAvailabilityIntroduced() const {\n    assert(getParsedKind() == AT_Availability &&\n           \"Not an availability attribute\");\n    return getAvailabilityData()->Changes[detail::IntroducedSlot];\n  }\n\n  const AvailabilityChange &getAvailabilityDeprecated() const {\n    assert(getParsedKind() == AT_Availability &&\n           \"Not an availability attribute\");\n    return getAvailabilityData()->Changes[detail::DeprecatedSlot];\n  }\n\n  const AvailabilityChange &getAvailabilityObsoleted() const {\n    assert(getParsedKind() == AT_Availability &&\n           \"Not an availability attribute\");\n    return getAvailabilityData()->Changes[detail::ObsoletedSlot];\n  }\n\n  SourceLocation getStrictLoc() const {\n    assert(getParsedKind() == AT_Availability &&\n           \"Not an availability attribute\");\n    return getAvailabilityData()->StrictLoc;\n  }\n\n  SourceLocation getUnavailableLoc() const {\n    assert(getParsedKind() == AT_Availability &&\n           \"Not an availability attribute\");\n    return UnavailableLoc;\n  }\n\n  const Expr * getMessageExpr() const {\n    assert(getParsedKind() == AT_Availability &&\n           \"Not an availability attribute\");\n    return MessageExpr;\n  }\n\n  const Expr *getReplacementExpr() const {\n    assert(getParsedKind() == AT_Availability &&\n           \"Not an availability attribute\");\n    return getAvailabilityData()->Replacement;\n  }\n\n  const ParsedType &getMatchingCType() const {\n    assert(getParsedKind() == AT_TypeTagForDatatype &&\n           \"Not a type_tag_for_datatype attribute\");\n    return getTypeTagForDatatypeDataSlot().MatchingCType;\n  }\n\n  bool getLayoutCompatible() const {\n    assert(getParsedKind() == AT_TypeTagForDatatype &&\n           \"Not a type_tag_for_datatype attribute\");\n    return getTypeTagForDatatypeDataSlot().LayoutCompatible;\n  }\n\n  bool getMustBeNull() const {\n    assert(getParsedKind() == AT_TypeTagForDatatype &&\n           \"Not a type_tag_for_datatype attribute\");\n    return getTypeTagForDatatypeDataSlot().MustBeNull;\n  }\n\n  const ParsedType &getTypeArg() const {\n    assert(HasParsedType && \"Not a type attribute\");\n    return getTypeBuffer();\n  }\n\n  IdentifierInfo *getPropertyDataGetter() const {\n    assert(isDeclspecPropertyAttribute() &&\n           \"Not a __delcspec(property) attribute\");\n    return getPropertyDataBuffer().GetterId;\n  }\n\n  IdentifierInfo *getPropertyDataSetter() const {\n    assert(isDeclspecPropertyAttribute() &&\n           \"Not a __delcspec(property) attribute\");\n    return getPropertyDataBuffer().SetterId;\n  }\n\n  /// Set the macro identifier info object that this parsed attribute was\n  /// declared in if it was declared in a macro. Also set the expansion location\n  /// of the macro.\n  void setMacroIdentifier(IdentifierInfo *MacroName, SourceLocation Loc) {\n    MacroII = MacroName;\n    MacroExpansionLoc = Loc;\n  }\n\n  /// Returns true if this attribute was declared in a macro.\n  bool hasMacroIdentifier() const { return MacroII != nullptr; }\n\n  /// Return the macro identifier if this attribute was declared in a macro.\n  /// nullptr is returned if it was not declared in a macro.\n  IdentifierInfo *getMacroIdentifier() const { return MacroII; }\n\n  SourceLocation getMacroExpansionLoc() const {\n    assert(hasMacroIdentifier() && \"Can only get the macro expansion location \"\n                                   \"if this attribute has a macro identifier.\");\n    return MacroExpansionLoc;\n  }\n\n  /// Check if the attribute has exactly as many args as Num. May output an\n  /// error. Returns false if a diagnostic is produced.\n  bool checkExactlyNumArgs(class Sema &S, unsigned Num) const;\n  /// Check if the attribute has at least as many args as Num. May output an\n  /// error. Returns false if a diagnostic is produced.\n  bool checkAtLeastNumArgs(class Sema &S, unsigned Num) const;\n  /// Check if the attribute has at most as many args as Num. May output an\n  /// error. Returns false if a diagnostic is produced.\n  bool checkAtMostNumArgs(class Sema &S, unsigned Num) const;\n\n  bool isTargetSpecificAttr() const;\n  bool isTypeAttr() const;\n  bool isStmtAttr() const;\n\n  bool hasCustomParsing() const;\n  unsigned getMinArgs() const;\n  unsigned getMaxArgs() const;\n  bool hasVariadicArg() const;\n  bool diagnoseAppertainsTo(class Sema &S, const Decl *D) const;\n  bool appliesToDecl(const Decl *D, attr::SubjectMatchRule MatchRule) const;\n  void getMatchRules(const LangOptions &LangOpts,\n                     SmallVectorImpl<std::pair<attr::SubjectMatchRule, bool>>\n                         &MatchRules) const;\n  bool diagnoseLangOpts(class Sema &S) const;\n  bool existsInTarget(const TargetInfo &Target) const;\n  bool isKnownToGCC() const;\n  bool isSupportedByPragmaAttribute() const;\n\n  /// If the parsed attribute has a semantic equivalent, and it would\n  /// have a semantic Spelling enumeration (due to having semantically-distinct\n  /// spelling variations), return the value of that semantic spelling. If the\n  /// parsed attribute does not have a semantic equivalent, or would not have\n  /// a Spelling enumeration, the value UINT_MAX is returned.\n  unsigned getSemanticSpelling() const;\n\n  /// If this is an OpenCL addr space attribute returns its representation\n  /// in LangAS, otherwise returns default addr space.\n  LangAS asOpenCLLangAS() const {\n    switch (getParsedKind()) {\n    case ParsedAttr::AT_OpenCLConstantAddressSpace:\n      return LangAS::opencl_constant;\n    case ParsedAttr::AT_OpenCLGlobalAddressSpace:\n      return LangAS::opencl_global;\n    case ParsedAttr::AT_OpenCLGlobalDeviceAddressSpace:\n      return LangAS::opencl_global_device;\n    case ParsedAttr::AT_OpenCLGlobalHostAddressSpace:\n      return LangAS::opencl_global_host;\n    case ParsedAttr::AT_OpenCLLocalAddressSpace:\n      return LangAS::opencl_local;\n    case ParsedAttr::AT_OpenCLPrivateAddressSpace:\n      return LangAS::opencl_private;\n    case ParsedAttr::AT_OpenCLGenericAddressSpace:\n      return LangAS::opencl_generic;\n    default:\n      return LangAS::Default;\n    }\n  }\n\n  AttributeCommonInfo::Kind getKind() const {\n    return AttributeCommonInfo::Kind(Info.AttrKind);\n  }\n  const ParsedAttrInfo &getInfo() const { return Info; }\n};\n\nclass AttributePool;\n/// A factory, from which one makes pools, from which one creates\n/// individual attributes which are deallocated with the pool.\n///\n/// Note that it's tolerably cheap to create and destroy one of\n/// these as long as you don't actually allocate anything in it.\nclass AttributeFactory {\npublic:\n  enum {\n    AvailabilityAllocSize =\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(1, 1, 0, 0, 0),\n    TypeTagForDatatypeAllocSize =\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(1, 0, 1, 0, 0),\n    PropertyAllocSize =\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(0, 0, 0, 0, 1),\n  };\n\nprivate:\n  enum {\n    /// The number of free lists we want to be sure to support\n    /// inline.  This is just enough that availability attributes\n    /// don't surpass it.  It's actually very unlikely we'll see an\n    /// attribute that needs more than that; on x86-64 you'd need 10\n    /// expression arguments, and on i386 you'd need 19.\n    InlineFreeListsCapacity =\n        1 + (AvailabilityAllocSize - sizeof(ParsedAttr)) / sizeof(void *)\n  };\n\n  llvm::BumpPtrAllocator Alloc;\n\n  /// Free lists.  The index is determined by the following formula:\n  ///   (size - sizeof(ParsedAttr)) / sizeof(void*)\n  SmallVector<SmallVector<ParsedAttr *, 8>, InlineFreeListsCapacity> FreeLists;\n\n  // The following are the private interface used by AttributePool.\n  friend class AttributePool;\n\n  /// Allocate an attribute of the given size.\n  void *allocate(size_t size);\n\n  void deallocate(ParsedAttr *AL);\n\n  /// Reclaim all the attributes in the given pool chain, which is\n  /// non-empty.  Note that the current implementation is safe\n  /// against reclaiming things which were not actually allocated\n  /// with the allocator, although of course it's important to make\n  /// sure that their allocator lives at least as long as this one.\n  void reclaimPool(AttributePool &head);\n\npublic:\n  AttributeFactory();\n  ~AttributeFactory();\n};\n\nclass AttributePool {\n  friend class AttributeFactory;\n  friend class ParsedAttributes;\n  AttributeFactory &Factory;\n  llvm::TinyPtrVector<ParsedAttr *> Attrs;\n\n  void *allocate(size_t size) {\n    return Factory.allocate(size);\n  }\n\n  ParsedAttr *add(ParsedAttr *attr) {\n    Attrs.push_back(attr);\n    return attr;\n  }\n\n  void remove(ParsedAttr *attr) {\n    assert(llvm::is_contained(Attrs, attr) &&\n           \"Can't take attribute from a pool that doesn't own it!\");\n    Attrs.erase(llvm::find(Attrs, attr));\n  }\n\n  void takePool(AttributePool &pool);\n\npublic:\n  /// Create a new pool for a factory.\n  AttributePool(AttributeFactory &factory) : Factory(factory) {}\n\n  AttributePool(const AttributePool &) = delete;\n\n  ~AttributePool() { Factory.reclaimPool(*this); }\n\n  /// Move the given pool's allocations to this pool.\n  AttributePool(AttributePool &&pool) = default;\n\n  AttributeFactory &getFactory() const { return Factory; }\n\n  void clear() {\n    Factory.reclaimPool(*this);\n    Attrs.clear();\n  }\n\n  /// Take the given pool's allocations and add them to this pool.\n  void takeAllFrom(AttributePool &pool) {\n    takePool(pool);\n    pool.Attrs.clear();\n  }\n\n  ParsedAttr *create(IdentifierInfo *attrName, SourceRange attrRange,\n                     IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                     ArgsUnion *args, unsigned numArgs,\n                     ParsedAttr::Syntax syntax,\n                     SourceLocation ellipsisLoc = SourceLocation()) {\n    size_t temp =\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(numArgs, 0, 0, 0, 0);\n    (void)temp;\n    void *memory = allocate(\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(numArgs, 0, 0, 0,\n                                                           0));\n    return add(new (memory) ParsedAttr(attrName, attrRange, scopeName, scopeLoc,\n                                       args, numArgs, syntax, ellipsisLoc));\n  }\n\n  ParsedAttr *create(IdentifierInfo *attrName, SourceRange attrRange,\n                     IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                     IdentifierLoc *Param, const AvailabilityChange &introduced,\n                     const AvailabilityChange &deprecated,\n                     const AvailabilityChange &obsoleted,\n                     SourceLocation unavailable, const Expr *MessageExpr,\n                     ParsedAttr::Syntax syntax, SourceLocation strict,\n                     const Expr *ReplacementExpr) {\n    void *memory = allocate(AttributeFactory::AvailabilityAllocSize);\n    return add(new (memory) ParsedAttr(\n        attrName, attrRange, scopeName, scopeLoc, Param, introduced, deprecated,\n        obsoleted, unavailable, MessageExpr, syntax, strict, ReplacementExpr));\n  }\n\n  ParsedAttr *create(IdentifierInfo *attrName, SourceRange attrRange,\n                     IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                     IdentifierLoc *Param1, IdentifierLoc *Param2,\n                     IdentifierLoc *Param3, ParsedAttr::Syntax syntax) {\n    void *memory = allocate(\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(3, 0, 0, 0, 0));\n    return add(new (memory) ParsedAttr(attrName, attrRange, scopeName, scopeLoc,\n                                       Param1, Param2, Param3, syntax));\n  }\n\n  ParsedAttr *\n  createTypeTagForDatatype(IdentifierInfo *attrName, SourceRange attrRange,\n                           IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                           IdentifierLoc *argumentKind,\n                           ParsedType matchingCType, bool layoutCompatible,\n                           bool mustBeNull, ParsedAttr::Syntax syntax) {\n    void *memory = allocate(AttributeFactory::TypeTagForDatatypeAllocSize);\n    return add(new (memory) ParsedAttr(attrName, attrRange, scopeName, scopeLoc,\n                                       argumentKind, matchingCType,\n                                       layoutCompatible, mustBeNull, syntax));\n  }\n\n  ParsedAttr *createTypeAttribute(IdentifierInfo *attrName,\n                                  SourceRange attrRange,\n                                  IdentifierInfo *scopeName,\n                                  SourceLocation scopeLoc, ParsedType typeArg,\n                                  ParsedAttr::Syntax syntaxUsed) {\n    void *memory = allocate(\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(0, 0, 0, 1, 0));\n    return add(new (memory) ParsedAttr(attrName, attrRange, scopeName, scopeLoc,\n                                       typeArg, syntaxUsed));\n  }\n\n  ParsedAttr *\n  createPropertyAttribute(IdentifierInfo *attrName, SourceRange attrRange,\n                          IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                          IdentifierInfo *getterId, IdentifierInfo *setterId,\n                          ParsedAttr::Syntax syntaxUsed) {\n    void *memory = allocate(AttributeFactory::PropertyAllocSize);\n    return add(new (memory) ParsedAttr(attrName, attrRange, scopeName, scopeLoc,\n                                       getterId, setterId, syntaxUsed));\n  }\n};\n\nclass ParsedAttributesView {\n  using VecTy = llvm::TinyPtrVector<ParsedAttr *>;\n  using SizeType = decltype(std::declval<VecTy>().size());\n\npublic:\n  bool empty() const { return AttrList.empty(); }\n  SizeType size() const { return AttrList.size(); }\n  ParsedAttr &operator[](SizeType pos) { return *AttrList[pos]; }\n  const ParsedAttr &operator[](SizeType pos) const { return *AttrList[pos]; }\n\n  void addAtEnd(ParsedAttr *newAttr) {\n    assert(newAttr);\n    AttrList.push_back(newAttr);\n  }\n\n  void remove(ParsedAttr *ToBeRemoved) {\n    assert(is_contained(AttrList, ToBeRemoved) &&\n           \"Cannot remove attribute that isn't in the list\");\n    AttrList.erase(llvm::find(AttrList, ToBeRemoved));\n  }\n\n  void clearListOnly() { AttrList.clear(); }\n\n  struct iterator : llvm::iterator_adaptor_base<iterator, VecTy::iterator,\n                                                std::random_access_iterator_tag,\n                                                ParsedAttr> {\n    iterator() : iterator_adaptor_base(nullptr) {}\n    iterator(VecTy::iterator I) : iterator_adaptor_base(I) {}\n    reference operator*() { return **I; }\n    friend class ParsedAttributesView;\n  };\n  struct const_iterator\n      : llvm::iterator_adaptor_base<const_iterator, VecTy::const_iterator,\n                                    std::random_access_iterator_tag,\n                                    ParsedAttr> {\n    const_iterator() : iterator_adaptor_base(nullptr) {}\n    const_iterator(VecTy::const_iterator I) : iterator_adaptor_base(I) {}\n\n    reference operator*() const { return **I; }\n    friend class ParsedAttributesView;\n  };\n\n  void addAll(iterator B, iterator E) {\n    AttrList.insert(AttrList.begin(), B.I, E.I);\n  }\n\n  void addAll(const_iterator B, const_iterator E) {\n    AttrList.insert(AttrList.begin(), B.I, E.I);\n  }\n\n  void addAllAtEnd(iterator B, iterator E) {\n    AttrList.insert(AttrList.end(), B.I, E.I);\n  }\n\n  void addAllAtEnd(const_iterator B, const_iterator E) {\n    AttrList.insert(AttrList.end(), B.I, E.I);\n  }\n\n  iterator begin() { return iterator(AttrList.begin()); }\n  const_iterator begin() const { return const_iterator(AttrList.begin()); }\n  iterator end() { return iterator(AttrList.end()); }\n  const_iterator end() const { return const_iterator(AttrList.end()); }\n\n  ParsedAttr &front() {\n    assert(!empty());\n    return *AttrList.front();\n  }\n  const ParsedAttr &front() const {\n    assert(!empty());\n    return *AttrList.front();\n  }\n  ParsedAttr &back() {\n    assert(!empty());\n    return *AttrList.back();\n  }\n  const ParsedAttr &back() const {\n    assert(!empty());\n    return *AttrList.back();\n  }\n\n  bool hasAttribute(ParsedAttr::Kind K) const {\n    return llvm::any_of(AttrList, [K](const ParsedAttr *AL) {\n      return AL->getParsedKind() == K;\n    });\n  }\n\nprivate:\n  VecTy AttrList;\n};\n\n/// ParsedAttributes - A collection of parsed attributes.  Currently\n/// we don't differentiate between the various attribute syntaxes,\n/// which is basically silly.\n///\n/// Right now this is a very lightweight container, but the expectation\n/// is that this will become significantly more serious.\nclass ParsedAttributes : public ParsedAttributesView {\npublic:\n  ParsedAttributes(AttributeFactory &factory) : pool(factory) {}\n  ParsedAttributes(const ParsedAttributes &) = delete;\n\n  AttributePool &getPool() const { return pool; }\n\n  void takeAllFrom(ParsedAttributes &attrs) {\n    addAll(attrs.begin(), attrs.end());\n    attrs.clearListOnly();\n    pool.takeAllFrom(attrs.pool);\n  }\n\n  void takeOneFrom(ParsedAttributes &Attrs, ParsedAttr *PA) {\n    Attrs.getPool().remove(PA);\n    Attrs.remove(PA);\n    getPool().add(PA);\n    addAtEnd(PA);\n  }\n\n  void clear() {\n    clearListOnly();\n    pool.clear();\n  }\n\n  /// Add attribute with expression arguments.\n  ParsedAttr *addNew(IdentifierInfo *attrName, SourceRange attrRange,\n                     IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                     ArgsUnion *args, unsigned numArgs,\n                     ParsedAttr::Syntax syntax,\n                     SourceLocation ellipsisLoc = SourceLocation()) {\n    ParsedAttr *attr = pool.create(attrName, attrRange, scopeName, scopeLoc,\n                                   args, numArgs, syntax, ellipsisLoc);\n    addAtEnd(attr);\n    return attr;\n  }\n\n  /// Add availability attribute.\n  ParsedAttr *addNew(IdentifierInfo *attrName, SourceRange attrRange,\n                     IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                     IdentifierLoc *Param, const AvailabilityChange &introduced,\n                     const AvailabilityChange &deprecated,\n                     const AvailabilityChange &obsoleted,\n                     SourceLocation unavailable, const Expr *MessageExpr,\n                     ParsedAttr::Syntax syntax, SourceLocation strict,\n                     const Expr *ReplacementExpr) {\n    ParsedAttr *attr = pool.create(\n        attrName, attrRange, scopeName, scopeLoc, Param, introduced, deprecated,\n        obsoleted, unavailable, MessageExpr, syntax, strict, ReplacementExpr);\n    addAtEnd(attr);\n    return attr;\n  }\n\n  /// Add objc_bridge_related attribute.\n  ParsedAttr *addNew(IdentifierInfo *attrName, SourceRange attrRange,\n                     IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                     IdentifierLoc *Param1, IdentifierLoc *Param2,\n                     IdentifierLoc *Param3, ParsedAttr::Syntax syntax) {\n    ParsedAttr *attr = pool.create(attrName, attrRange, scopeName, scopeLoc,\n                                   Param1, Param2, Param3, syntax);\n    addAtEnd(attr);\n    return attr;\n  }\n\n  /// Add type_tag_for_datatype attribute.\n  ParsedAttr *\n  addNewTypeTagForDatatype(IdentifierInfo *attrName, SourceRange attrRange,\n                           IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                           IdentifierLoc *argumentKind,\n                           ParsedType matchingCType, bool layoutCompatible,\n                           bool mustBeNull, ParsedAttr::Syntax syntax) {\n    ParsedAttr *attr = pool.createTypeTagForDatatype(\n        attrName, attrRange, scopeName, scopeLoc, argumentKind, matchingCType,\n        layoutCompatible, mustBeNull, syntax);\n    addAtEnd(attr);\n    return attr;\n  }\n\n  /// Add an attribute with a single type argument.\n  ParsedAttr *addNewTypeAttr(IdentifierInfo *attrName, SourceRange attrRange,\n                             IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                             ParsedType typeArg,\n                             ParsedAttr::Syntax syntaxUsed) {\n    ParsedAttr *attr = pool.createTypeAttribute(attrName, attrRange, scopeName,\n                                                scopeLoc, typeArg, syntaxUsed);\n    addAtEnd(attr);\n    return attr;\n  }\n\n  /// Add microsoft __delspec(property) attribute.\n  ParsedAttr *\n  addNewPropertyAttr(IdentifierInfo *attrName, SourceRange attrRange,\n                     IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                     IdentifierInfo *getterId, IdentifierInfo *setterId,\n                     ParsedAttr::Syntax syntaxUsed) {\n    ParsedAttr *attr =\n        pool.createPropertyAttribute(attrName, attrRange, scopeName, scopeLoc,\n                                     getterId, setterId, syntaxUsed);\n    addAtEnd(attr);\n    return attr;\n  }\n\nprivate:\n  mutable AttributePool pool;\n};\n\n/// These constants match the enumerated choices of\n/// err_attribute_argument_n_type and err_attribute_argument_type.\nenum AttributeArgumentNType {\n  AANT_ArgumentIntOrBool,\n  AANT_ArgumentIntegerConstant,\n  AANT_ArgumentString,\n  AANT_ArgumentIdentifier,\n  AANT_ArgumentConstantExpr,\n};\n\n/// These constants match the enumerated choices of\n/// warn_attribute_wrong_decl_type and err_attribute_wrong_decl_type.\nenum AttributeDeclKind {\n  ExpectedFunction,\n  ExpectedUnion,\n  ExpectedVariableOrFunction,\n  ExpectedFunctionOrMethod,\n  ExpectedFunctionMethodOrBlock,\n  ExpectedFunctionMethodOrParameter,\n  ExpectedVariable,\n  ExpectedVariableOrField,\n  ExpectedVariableFieldOrTag,\n  ExpectedTypeOrNamespace,\n  ExpectedFunctionVariableOrClass,\n  ExpectedKernelFunction,\n  ExpectedFunctionWithProtoType,\n};\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             const ParsedAttr &At) {\n  DB.AddTaggedVal(reinterpret_cast<intptr_t>(At.getAttrName()),\n                  DiagnosticsEngine::ak_identifierinfo);\n  return DB;\n}\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             const ParsedAttr *At) {\n  DB.AddTaggedVal(reinterpret_cast<intptr_t>(At->getAttrName()),\n                  DiagnosticsEngine::ak_identifierinfo);\n  return DB;\n}\n\n/// AttributeCommonInfo has a non-explicit constructor which takes an\n/// SourceRange as its only argument, this constructor has many uses so making\n/// it explicit is hard. This constructor causes ambiguity with\n/// DiagnosticBuilder &operator<<(const DiagnosticBuilder &DB, SourceRange R).\n/// We use SFINAE to disable any conversion and remove any ambiguity.\ntemplate <typename ACI,\n          typename std::enable_if_t<\n              std::is_same<ACI, AttributeCommonInfo>::value, int> = 0>\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                           const ACI &CI) {\n  DB.AddTaggedVal(reinterpret_cast<intptr_t>(CI.getAttrName()),\n                  DiagnosticsEngine::ak_identifierinfo);\n  return DB;\n}\n\ntemplate <typename ACI,\n          typename std::enable_if_t<\n              std::is_same<ACI, AttributeCommonInfo>::value, int> = 0>\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                           const ACI* CI) {\n  DB.AddTaggedVal(reinterpret_cast<intptr_t>(CI->getAttrName()),\n                  DiagnosticsEngine::ak_identifierinfo);\n  return DB;\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_SEMA_ATTRIBUTELIST_H\n"}, "92": {"id": 92, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "content": "//===- ASTBitCodes.h - Enum values for the PCH bitcode format ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This header defines Bitcode enum values for Clang serialized AST files.\n//\n// The enum values defined in this file should be considered permanent.  If\n// new features are added, they should have values added at the end of the\n// respective lists.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SERIALIZATION_ASTBITCODES_H\n#define LLVM_CLANG_SERIALIZATION_ASTBITCODES_H\n\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/OperatorKinds.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/Bitstream/BitCodes.h\"\n#include <cassert>\n#include <cstdint>\n\nnamespace clang {\nnamespace serialization {\n\n/// AST file major version number supported by this version of\n/// Clang.\n///\n/// Whenever the AST file format changes in a way that makes it\n/// incompatible with previous versions (such that a reader\n/// designed for the previous version could not support reading\n/// the new version), this number should be increased.\n///\n/// Version 4 of AST files also requires that the version control branch and\n/// revision match exactly, since there is no backward compatibility of\n/// AST files at this time.\nconst unsigned VERSION_MAJOR = 13;\n\n/// AST file minor version number supported by this version of\n/// Clang.\n///\n/// Whenever the AST format changes in a way that is still\n/// compatible with previous versions (such that a reader designed\n/// for the previous version could still support reading the new\n/// version by ignoring new kinds of subblocks), this number\n/// should be increased.\nconst unsigned VERSION_MINOR = 0;\n\n/// An ID number that refers to an identifier in an AST file.\n///\n/// The ID numbers of identifiers are consecutive (in order of discovery)\n/// and start at 1. 0 is reserved for NULL.\nusing IdentifierID = uint32_t;\n\n/// An ID number that refers to a declaration in an AST file.\n///\n/// The ID numbers of declarations are consecutive (in order of\n/// discovery), with values below NUM_PREDEF_DECL_IDS being reserved.\n/// At the start of a chain of precompiled headers, declaration ID 1 is\n/// used for the translation unit declaration.\nusing DeclID = uint32_t;\n\n// FIXME: Turn these into classes so we can have some type safety when\n// we go from local ID to global and vice-versa.\nusing LocalDeclID = DeclID;\nusing GlobalDeclID = DeclID;\n\n/// An ID number that refers to a type in an AST file.\n///\n/// The ID of a type is partitioned into two parts: the lower\n/// three bits are used to store the const/volatile/restrict\n/// qualifiers (as with QualType) and the upper bits provide a\n/// type index. The type index values are partitioned into two\n/// sets. The values below NUM_PREDEF_TYPE_IDs are predefined type\n/// IDs (based on the PREDEF_TYPE_*_ID constants), with 0 as a\n/// placeholder for \"no type\". Values from NUM_PREDEF_TYPE_IDs are\n/// other types that have serialized representations.\nusing TypeID = uint32_t;\n\n/// A type index; the type ID with the qualifier bits removed.\nclass TypeIdx {\n  uint32_t Idx = 0;\n\npublic:\n  TypeIdx() = default;\n  explicit TypeIdx(uint32_t index) : Idx(index) {}\n\n  uint32_t getIndex() const { return Idx; }\n\n  TypeID asTypeID(unsigned FastQuals) const {\n    if (Idx == uint32_t(-1))\n      return TypeID(-1);\n\n    return (Idx << Qualifiers::FastWidth) | FastQuals;\n  }\n\n  static TypeIdx fromTypeID(TypeID ID) {\n    if (ID == TypeID(-1))\n      return TypeIdx(-1);\n\n    return TypeIdx(ID >> Qualifiers::FastWidth);\n  }\n};\n\n/// A structure for putting \"fast\"-unqualified QualTypes into a\n/// DenseMap.  This uses the standard pointer hash function.\nstruct UnsafeQualTypeDenseMapInfo {\n  static bool isEqual(QualType A, QualType B) { return A == B; }\n\n  static QualType getEmptyKey() {\n    return QualType::getFromOpaquePtr((void *)1);\n  }\n\n  static QualType getTombstoneKey() {\n    return QualType::getFromOpaquePtr((void *)2);\n  }\n\n  static unsigned getHashValue(QualType T) {\n    assert(!T.getLocalFastQualifiers() &&\n           \"hash invalid for types with fast quals\");\n    uintptr_t v = reinterpret_cast<uintptr_t>(T.getAsOpaquePtr());\n    return (unsigned(v) >> 4) ^ (unsigned(v) >> 9);\n  }\n};\n\n/// An ID number that refers to an identifier in an AST file.\nusing IdentID = uint32_t;\n\n/// The number of predefined identifier IDs.\nconst unsigned int NUM_PREDEF_IDENT_IDS = 1;\n\n/// An ID number that refers to a macro in an AST file.\nusing MacroID = uint32_t;\n\n/// A global ID number that refers to a macro in an AST file.\nusing GlobalMacroID = uint32_t;\n\n/// A local to a module ID number that refers to a macro in an\n/// AST file.\nusing LocalMacroID = uint32_t;\n\n/// The number of predefined macro IDs.\nconst unsigned int NUM_PREDEF_MACRO_IDS = 1;\n\n/// An ID number that refers to an ObjC selector in an AST file.\nusing SelectorID = uint32_t;\n\n/// The number of predefined selector IDs.\nconst unsigned int NUM_PREDEF_SELECTOR_IDS = 1;\n\n/// An ID number that refers to a set of CXXBaseSpecifiers in an\n/// AST file.\nusing CXXBaseSpecifiersID = uint32_t;\n\n/// An ID number that refers to a list of CXXCtorInitializers in an\n/// AST file.\nusing CXXCtorInitializersID = uint32_t;\n\n/// An ID number that refers to an entity in the detailed\n/// preprocessing record.\nusing PreprocessedEntityID = uint32_t;\n\n/// An ID number that refers to a submodule in a module file.\nusing SubmoduleID = uint32_t;\n\n/// The number of predefined submodule IDs.\nconst unsigned int NUM_PREDEF_SUBMODULE_IDS = 1;\n\n/// Source range/offset of a preprocessed entity.\nstruct PPEntityOffset {\n  /// Raw source location of beginning of range.\n  unsigned Begin;\n\n  /// Raw source location of end of range.\n  unsigned End;\n\n  /// Offset in the AST file relative to ModuleFile::MacroOffsetsBase.\n  uint32_t BitOffset;\n\n  PPEntityOffset(SourceRange R, uint32_t BitOffset)\n      : Begin(R.getBegin().getRawEncoding()), End(R.getEnd().getRawEncoding()),\n        BitOffset(BitOffset) {}\n\n  SourceLocation getBegin() const {\n    return SourceLocation::getFromRawEncoding(Begin);\n  }\n\n  SourceLocation getEnd() const {\n    return SourceLocation::getFromRawEncoding(End);\n  }\n};\n\n/// Source range of a skipped preprocessor region\nstruct PPSkippedRange {\n  /// Raw source location of beginning of range.\n  unsigned Begin;\n  /// Raw source location of end of range.\n  unsigned End;\n\n  PPSkippedRange(SourceRange R)\n      : Begin(R.getBegin().getRawEncoding()), End(R.getEnd().getRawEncoding()) {\n  }\n\n  SourceLocation getBegin() const {\n    return SourceLocation::getFromRawEncoding(Begin);\n  }\n  SourceLocation getEnd() const {\n    return SourceLocation::getFromRawEncoding(End);\n  }\n};\n\n/// Offset in the AST file. Use splitted 64-bit integer into low/high\n/// parts to keep structure alignment 32-bit (it is important because\n/// blobs in bitstream are 32-bit aligned). This structure is serialized\n/// \"as is\" to the AST file.\nstruct UnderalignedInt64 {\n  uint32_t BitOffsetLow = 0;\n  uint32_t BitOffsetHigh = 0;\n\n  UnderalignedInt64() = default;\n  UnderalignedInt64(uint64_t BitOffset) { setBitOffset(BitOffset); }\n\n  void setBitOffset(uint64_t Offset) {\n    BitOffsetLow = Offset;\n    BitOffsetHigh = Offset >> 32;\n  }\n\n  uint64_t getBitOffset() const {\n    return BitOffsetLow | (uint64_t(BitOffsetHigh) << 32);\n  }\n};\n\n/// Source location and bit offset of a declaration.\nstruct DeclOffset {\n  /// Raw source location.\n  unsigned Loc = 0;\n\n  /// Offset relative to the start of the DECLTYPES_BLOCK block. Keep\n  /// structure alignment 32-bit and avoid padding gap because undefined\n  /// value in the padding affects AST hash.\n  UnderalignedInt64 BitOffset;\n\n  DeclOffset() = default;\n  DeclOffset(SourceLocation Loc, uint64_t BitOffset,\n             uint64_t DeclTypesBlockStartOffset) {\n    setLocation(Loc);\n    setBitOffset(BitOffset, DeclTypesBlockStartOffset);\n  }\n\n  void setLocation(SourceLocation L) { Loc = L.getRawEncoding(); }\n\n  SourceLocation getLocation() const {\n    return SourceLocation::getFromRawEncoding(Loc);\n  }\n\n  void setBitOffset(uint64_t Offset, const uint64_t DeclTypesBlockStartOffset) {\n    BitOffset.setBitOffset(Offset - DeclTypesBlockStartOffset);\n  }\n\n  uint64_t getBitOffset(const uint64_t DeclTypesBlockStartOffset) const {\n    return BitOffset.getBitOffset() + DeclTypesBlockStartOffset;\n  }\n};\n\n/// The number of predefined preprocessed entity IDs.\nconst unsigned int NUM_PREDEF_PP_ENTITY_IDS = 1;\n\n/// Describes the various kinds of blocks that occur within\n/// an AST file.\nenum BlockIDs {\n  /// The AST block, which acts as a container around the\n  /// full AST block.\n  AST_BLOCK_ID = llvm::bitc::FIRST_APPLICATION_BLOCKID,\n\n  /// The block containing information about the source\n  /// manager.\n  SOURCE_MANAGER_BLOCK_ID,\n\n  /// The block containing information about the\n  /// preprocessor.\n  PREPROCESSOR_BLOCK_ID,\n\n  /// The block containing the definitions of all of the\n  /// types and decls used within the AST file.\n  DECLTYPES_BLOCK_ID,\n\n  /// The block containing the detailed preprocessing record.\n  PREPROCESSOR_DETAIL_BLOCK_ID,\n\n  /// The block containing the submodule structure.\n  SUBMODULE_BLOCK_ID,\n\n  /// The block containing comments.\n  COMMENTS_BLOCK_ID,\n\n  /// The control block, which contains all of the\n  /// information that needs to be validated prior to committing\n  /// to loading the AST file.\n  CONTROL_BLOCK_ID,\n\n  /// The block of input files, which were used as inputs\n  /// to create this AST file.\n  ///\n  /// This block is part of the control block.\n  INPUT_FILES_BLOCK_ID,\n\n  /// The block of configuration options, used to check that\n  /// a module is being used in a configuration compatible with the\n  /// configuration in which it was built.\n  ///\n  /// This block is part of the control block.\n  OPTIONS_BLOCK_ID,\n\n  /// A block containing a module file extension.\n  EXTENSION_BLOCK_ID,\n\n  /// A block with unhashed content.\n  ///\n  /// These records should not change the \\a ASTFileSignature.  See \\a\n  /// UnhashedControlBlockRecordTypes for the list of records.\n  UNHASHED_CONTROL_BLOCK_ID,\n};\n\n/// Record types that occur within the control block.\nenum ControlRecordTypes {\n  /// AST file metadata, including the AST file version number\n  /// and information about the compiler used to build this AST file.\n  METADATA = 1,\n\n  /// Record code for the list of other AST files imported by\n  /// this AST file.\n  IMPORTS,\n\n  /// Record code for the original file that was used to\n  /// generate the AST file, including both its file ID and its\n  /// name.\n  ORIGINAL_FILE,\n\n  /// The directory that the PCH was originally created in.\n  ORIGINAL_PCH_DIR,\n\n  /// Record code for file ID of the file or buffer that was used to\n  /// generate the AST file.\n  ORIGINAL_FILE_ID,\n\n  /// Offsets into the input-files block where input files\n  /// reside.\n  INPUT_FILE_OFFSETS,\n\n  /// Record code for the module name.\n  MODULE_NAME,\n\n  /// Record code for the module map file that was used to build this\n  /// AST file.\n  MODULE_MAP_FILE,\n\n  /// Record code for the module build directory.\n  MODULE_DIRECTORY,\n};\n\n/// Record types that occur within the options block inside\n/// the control block.\nenum OptionsRecordTypes {\n  /// Record code for the language options table.\n  ///\n  /// The record with this code contains the contents of the\n  /// LangOptions structure. We serialize the entire contents of\n  /// the structure, and let the reader decide which options are\n  /// actually important to check.\n  LANGUAGE_OPTIONS = 1,\n\n  /// Record code for the target options table.\n  TARGET_OPTIONS,\n\n  /// Record code for the filesystem options table.\n  FILE_SYSTEM_OPTIONS,\n\n  /// Record code for the headers search options table.\n  HEADER_SEARCH_OPTIONS,\n\n  /// Record code for the preprocessor options table.\n  PREPROCESSOR_OPTIONS,\n};\n\n/// Record codes for the unhashed control block.\nenum UnhashedControlBlockRecordTypes {\n  /// Record code for the signature that identifiers this AST file.\n  SIGNATURE = 1,\n\n  /// Record code for the content hash of the AST block.\n  AST_BLOCK_HASH,\n\n  /// Record code for the diagnostic options table.\n  DIAGNOSTIC_OPTIONS,\n\n  /// Record code for \\#pragma diagnostic mappings.\n  DIAG_PRAGMA_MAPPINGS,\n};\n\n/// Record code for extension blocks.\nenum ExtensionBlockRecordTypes {\n  /// Metadata describing this particular extension.\n  EXTENSION_METADATA = 1,\n\n  /// The first record ID allocated to the extensions themselves.\n  FIRST_EXTENSION_RECORD_ID = 4\n};\n\n/// Record types that occur within the input-files block\n/// inside the control block.\nenum InputFileRecordTypes {\n  /// An input file.\n  INPUT_FILE = 1,\n\n  /// The input file content hash\n  INPUT_FILE_HASH\n};\n\n/// Record types that occur within the AST block itself.\nenum ASTRecordTypes {\n  /// Record code for the offsets of each type.\n  ///\n  /// The TYPE_OFFSET constant describes the record that occurs\n  /// within the AST block. The record itself is an array of offsets that\n  /// point into the declarations and types block (identified by\n  /// DECLTYPES_BLOCK_ID). The index into the array is based on the ID\n  /// of a type. For a given type ID @c T, the lower three bits of\n  /// @c T are its qualifiers (const, volatile, restrict), as in\n  /// the QualType class. The upper bits, after being shifted and\n  /// subtracting NUM_PREDEF_TYPE_IDS, are used to index into the\n  /// TYPE_OFFSET block to determine the offset of that type's\n  /// corresponding record within the DECLTYPES_BLOCK_ID block.\n  TYPE_OFFSET = 1,\n\n  /// Record code for the offsets of each decl.\n  ///\n  /// The DECL_OFFSET constant describes the record that occurs\n  /// within the block identified by DECL_OFFSETS_BLOCK_ID within\n  /// the AST block. The record itself is an array of offsets that\n  /// point into the declarations and types block (identified by\n  /// DECLTYPES_BLOCK_ID). The declaration ID is an index into this\n  /// record, after subtracting one to account for the use of\n  /// declaration ID 0 for a NULL declaration pointer. Index 0 is\n  /// reserved for the translation unit declaration.\n  DECL_OFFSET = 2,\n\n  /// Record code for the table of offsets of each\n  /// identifier ID.\n  ///\n  /// The offset table contains offsets into the blob stored in\n  /// the IDENTIFIER_TABLE record. Each offset points to the\n  /// NULL-terminated string that corresponds to that identifier.\n  IDENTIFIER_OFFSET = 3,\n\n  /// This is so that older clang versions, before the introduction\n  /// of the control block, can read and reject the newer PCH format.\n  /// *DON'T CHANGE THIS NUMBER*.\n  METADATA_OLD_FORMAT = 4,\n\n  /// Record code for the identifier table.\n  ///\n  /// The identifier table is a simple blob that contains\n  /// NULL-terminated strings for all of the identifiers\n  /// referenced by the AST file. The IDENTIFIER_OFFSET table\n  /// contains the mapping from identifier IDs to the characters\n  /// in this blob. Note that the starting offsets of all of the\n  /// identifiers are odd, so that, when the identifier offset\n  /// table is loaded in, we can use the low bit to distinguish\n  /// between offsets (for unresolved identifier IDs) and\n  /// IdentifierInfo pointers (for already-resolved identifier\n  /// IDs).\n  IDENTIFIER_TABLE = 5,\n\n  /// Record code for the array of eagerly deserialized decls.\n  ///\n  /// The AST file contains a list of all of the declarations that should be\n  /// eagerly deserialized present within the parsed headers, stored as an\n  /// array of declaration IDs. These declarations will be\n  /// reported to the AST consumer after the AST file has been\n  /// read, since their presence can affect the semantics of the\n  /// program (e.g., for code generation).\n  EAGERLY_DESERIALIZED_DECLS = 6,\n\n  /// Record code for the set of non-builtin, special\n  /// types.\n  ///\n  /// This record contains the type IDs for the various type nodes\n  /// that are constructed during semantic analysis (e.g.,\n  /// __builtin_va_list). The SPECIAL_TYPE_* constants provide\n  /// offsets into this record.\n  SPECIAL_TYPES = 7,\n\n  /// Record code for the extra statistics we gather while\n  /// generating an AST file.\n  STATISTICS = 8,\n\n  /// Record code for the array of tentative definitions.\n  TENTATIVE_DEFINITIONS = 9,\n\n  // ID 10 used to be for a list of extern \"C\" declarations.\n\n  /// Record code for the table of offsets into the\n  /// Objective-C method pool.\n  SELECTOR_OFFSETS = 11,\n\n  /// Record code for the Objective-C method pool,\n  METHOD_POOL = 12,\n\n  /// The value of the next __COUNTER__ to dispense.\n  /// [PP_COUNTER_VALUE, Val]\n  PP_COUNTER_VALUE = 13,\n\n  /// Record code for the table of offsets into the block\n  /// of source-location information.\n  SOURCE_LOCATION_OFFSETS = 14,\n\n  /// Record code for the set of source location entries\n  /// that need to be preloaded by the AST reader.\n  ///\n  /// This set contains the source location entry for the\n  /// predefines buffer and for any file entries that need to be\n  /// preloaded.\n  SOURCE_LOCATION_PRELOADS = 15,\n\n  /// Record code for the set of ext_vector type names.\n  EXT_VECTOR_DECLS = 16,\n\n  /// Record code for the array of unused file scoped decls.\n  UNUSED_FILESCOPED_DECLS = 17,\n\n  /// Record code for the table of offsets to entries in the\n  /// preprocessing record.\n  PPD_ENTITIES_OFFSETS = 18,\n\n  /// Record code for the array of VTable uses.\n  VTABLE_USES = 19,\n\n  // ID 20 used to be for a list of dynamic classes.\n\n  /// Record code for referenced selector pool.\n  REFERENCED_SELECTOR_POOL = 21,\n\n  /// Record code for an update to the TU's lexically contained\n  /// declarations.\n  TU_UPDATE_LEXICAL = 22,\n\n  // ID 23 used to be for a list of local redeclarations.\n\n  /// Record code for declarations that Sema keeps references of.\n  SEMA_DECL_REFS = 24,\n\n  /// Record code for weak undeclared identifiers.\n  WEAK_UNDECLARED_IDENTIFIERS = 25,\n\n  /// Record code for pending implicit instantiations.\n  PENDING_IMPLICIT_INSTANTIATIONS = 26,\n\n  // ID 27 used to be for a list of replacement decls.\n\n  /// Record code for an update to a decl context's lookup table.\n  ///\n  /// In practice, this should only be used for the TU and namespaces.\n  UPDATE_VISIBLE = 28,\n\n  /// Record for offsets of DECL_UPDATES records for declarations\n  /// that were modified after being deserialized and need updates.\n  DECL_UPDATE_OFFSETS = 29,\n\n  // ID 30 used to be a decl update record. These are now in the DECLTYPES\n  // block.\n\n  // ID 31 used to be a list of offsets to DECL_CXX_BASE_SPECIFIERS records.\n\n  // ID 32 used to be the code for \\#pragma diagnostic mappings.\n\n  /// Record code for special CUDA declarations.\n  CUDA_SPECIAL_DECL_REFS = 33,\n\n  /// Record code for header search information.\n  HEADER_SEARCH_TABLE = 34,\n\n  /// Record code for floating point \\#pragma options.\n  FP_PRAGMA_OPTIONS = 35,\n\n  /// Record code for enabled OpenCL extensions.\n  OPENCL_EXTENSIONS = 36,\n\n  /// The list of delegating constructor declarations.\n  DELEGATING_CTORS = 37,\n\n  /// Record code for the set of known namespaces, which are used\n  /// for typo correction.\n  KNOWN_NAMESPACES = 38,\n\n  /// Record code for the remapping information used to relate\n  /// loaded modules to the various offsets and IDs(e.g., source location\n  /// offests, declaration and type IDs) that are used in that module to\n  /// refer to other modules.\n  MODULE_OFFSET_MAP = 39,\n\n  /// Record code for the source manager line table information,\n  /// which stores information about \\#line directives.\n  SOURCE_MANAGER_LINE_TABLE = 40,\n\n  /// Record code for map of Objective-C class definition IDs to the\n  /// ObjC categories in a module that are attached to that class.\n  OBJC_CATEGORIES_MAP = 41,\n\n  /// Record code for a file sorted array of DeclIDs in a module.\n  FILE_SORTED_DECLS = 42,\n\n  /// Record code for an array of all of the (sub)modules that were\n  /// imported by the AST file.\n  IMPORTED_MODULES = 43,\n\n  // ID 44 used to be a table of merged canonical declarations.\n  // ID 45 used to be a list of declaration IDs of local redeclarations.\n\n  /// Record code for the array of Objective-C categories (including\n  /// extensions).\n  ///\n  /// This array can only be interpreted properly using the Objective-C\n  /// categories map.\n  OBJC_CATEGORIES = 46,\n\n  /// Record code for the table of offsets of each macro ID.\n  ///\n  /// The offset table contains offsets into the blob stored in\n  /// the preprocessor block. Each offset points to the corresponding\n  /// macro definition.\n  MACRO_OFFSET = 47,\n\n  /// A list of \"interesting\" identifiers. Only used in C++ (where we\n  /// don't normally do lookups into the serialized identifier table). These\n  /// are eagerly deserialized.\n  INTERESTING_IDENTIFIERS = 48,\n\n  /// Record code for undefined but used functions and variables that\n  /// need a definition in this TU.\n  UNDEFINED_BUT_USED = 49,\n\n  /// Record code for late parsed template functions.\n  LATE_PARSED_TEMPLATE = 50,\n\n  /// Record code for \\#pragma optimize options.\n  OPTIMIZE_PRAGMA_OPTIONS = 51,\n\n  /// Record code for potentially unused local typedef names.\n  UNUSED_LOCAL_TYPEDEF_NAME_CANDIDATES = 52,\n\n  // ID 53 used to be a table of constructor initializer records.\n\n  /// Delete expressions that will be analyzed later.\n  DELETE_EXPRS_TO_ANALYZE = 54,\n\n  /// Record code for \\#pragma ms_struct options.\n  MSSTRUCT_PRAGMA_OPTIONS = 55,\n\n  /// Record code for \\#pragma ms_struct options.\n  POINTERS_TO_MEMBERS_PRAGMA_OPTIONS = 56,\n\n  /// Number of unmatched #pragma clang cuda_force_host_device begin\n  /// directives we've seen.\n  CUDA_PRAGMA_FORCE_HOST_DEVICE_DEPTH = 57,\n\n  /// Record code for types associated with OpenCL extensions.\n  OPENCL_EXTENSION_TYPES = 58,\n\n  /// Record code for declarations associated with OpenCL extensions.\n  OPENCL_EXTENSION_DECLS = 59,\n\n  MODULAR_CODEGEN_DECLS = 60,\n\n  /// Record code for \\#pragma align/pack options.\n  ALIGN_PACK_PRAGMA_OPTIONS = 61,\n\n  /// The stack of open #ifs/#ifdefs recorded in a preamble.\n  PP_CONDITIONAL_STACK = 62,\n\n  /// A table of skipped ranges within the preprocessing record.\n  PPD_SKIPPED_RANGES = 63,\n\n  /// Record code for the Decls to be checked for deferred diags.\n  DECLS_TO_CHECK_FOR_DEFERRED_DIAGS = 64,\n\n  /// Record code for \\#pragma float_control options.\n  FLOAT_CONTROL_PRAGMA_OPTIONS = 65,\n};\n\n/// Record types used within a source manager block.\nenum SourceManagerRecordTypes {\n  /// Describes a source location entry (SLocEntry) for a\n  /// file.\n  SM_SLOC_FILE_ENTRY = 1,\n\n  /// Describes a source location entry (SLocEntry) for a\n  /// buffer.\n  SM_SLOC_BUFFER_ENTRY = 2,\n\n  /// Describes a blob that contains the data for a buffer\n  /// entry. This kind of record always directly follows a\n  /// SM_SLOC_BUFFER_ENTRY record or a SM_SLOC_FILE_ENTRY with an\n  /// overridden buffer.\n  SM_SLOC_BUFFER_BLOB = 3,\n\n  /// Describes a zlib-compressed blob that contains the data for\n  /// a buffer entry.\n  SM_SLOC_BUFFER_BLOB_COMPRESSED = 4,\n\n  /// Describes a source location entry (SLocEntry) for a\n  /// macro expansion.\n  SM_SLOC_EXPANSION_ENTRY = 5\n};\n\n/// Record types used within a preprocessor block.\nenum PreprocessorRecordTypes {\n  // The macros in the PP section are a PP_MACRO_* instance followed by a\n  // list of PP_TOKEN instances for each token in the definition.\n\n  /// An object-like macro definition.\n  /// [PP_MACRO_OBJECT_LIKE, IdentInfoID, SLoc, IsUsed]\n  PP_MACRO_OBJECT_LIKE = 1,\n\n  /// A function-like macro definition.\n  /// [PP_MACRO_FUNCTION_LIKE, \\<ObjectLikeStuff>, IsC99Varargs,\n  /// IsGNUVarars, NumArgs, ArgIdentInfoID* ]\n  PP_MACRO_FUNCTION_LIKE = 2,\n\n  /// Describes one token.\n  /// [PP_TOKEN, SLoc, Length, IdentInfoID, Kind, Flags]\n  PP_TOKEN = 3,\n\n  /// The macro directives history for a particular identifier.\n  PP_MACRO_DIRECTIVE_HISTORY = 4,\n\n  /// A macro directive exported by a module.\n  /// [PP_MODULE_MACRO, SubmoduleID, MacroID, (Overridden SubmoduleID)*]\n  PP_MODULE_MACRO = 5,\n};\n\n/// Record types used within a preprocessor detail block.\nenum PreprocessorDetailRecordTypes {\n  /// Describes a macro expansion within the preprocessing record.\n  PPD_MACRO_EXPANSION = 0,\n\n  /// Describes a macro definition within the preprocessing record.\n  PPD_MACRO_DEFINITION = 1,\n\n  /// Describes an inclusion directive within the preprocessing\n  /// record.\n  PPD_INCLUSION_DIRECTIVE = 2\n};\n\n/// Record types used within a submodule description block.\nenum SubmoduleRecordTypes {\n  /// Metadata for submodules as a whole.\n  SUBMODULE_METADATA = 0,\n\n  /// Defines the major attributes of a submodule, including its\n  /// name and parent.\n  SUBMODULE_DEFINITION = 1,\n\n  /// Specifies the umbrella header used to create this module,\n  /// if any.\n  SUBMODULE_UMBRELLA_HEADER = 2,\n\n  /// Specifies a header that falls into this (sub)module.\n  SUBMODULE_HEADER = 3,\n\n  /// Specifies a top-level header that falls into this (sub)module.\n  SUBMODULE_TOPHEADER = 4,\n\n  /// Specifies an umbrella directory.\n  SUBMODULE_UMBRELLA_DIR = 5,\n\n  /// Specifies the submodules that are imported by this\n  /// submodule.\n  SUBMODULE_IMPORTS = 6,\n\n  /// Specifies the submodules that are re-exported from this\n  /// submodule.\n  SUBMODULE_EXPORTS = 7,\n\n  /// Specifies a required feature.\n  SUBMODULE_REQUIRES = 8,\n\n  /// Specifies a header that has been explicitly excluded\n  /// from this submodule.\n  SUBMODULE_EXCLUDED_HEADER = 9,\n\n  /// Specifies a library or framework to link against.\n  SUBMODULE_LINK_LIBRARY = 10,\n\n  /// Specifies a configuration macro for this module.\n  SUBMODULE_CONFIG_MACRO = 11,\n\n  /// Specifies a conflict with another module.\n  SUBMODULE_CONFLICT = 12,\n\n  /// Specifies a header that is private to this submodule.\n  SUBMODULE_PRIVATE_HEADER = 13,\n\n  /// Specifies a header that is part of the module but must be\n  /// textually included.\n  SUBMODULE_TEXTUAL_HEADER = 14,\n\n  /// Specifies a header that is private to this submodule but\n  /// must be textually included.\n  SUBMODULE_PRIVATE_TEXTUAL_HEADER = 15,\n\n  /// Specifies some declarations with initializers that must be\n  /// emitted to initialize the module.\n  SUBMODULE_INITIALIZERS = 16,\n\n  /// Specifies the name of the module that will eventually\n  /// re-export the entities in this module.\n  SUBMODULE_EXPORT_AS = 17,\n};\n\n/// Record types used within a comments block.\nenum CommentRecordTypes { COMMENTS_RAW_COMMENT = 0 };\n\n/// \\defgroup ASTAST AST file AST constants\n///\n/// The constants in this group describe various components of the\n/// abstract syntax tree within an AST file.\n///\n/// @{\n\n/// Predefined type IDs.\n///\n/// These type IDs correspond to predefined types in the AST\n/// context, such as built-in types (int) and special place-holder\n/// types (the \\<overload> and \\<dependent> type markers). Such\n/// types are never actually serialized, since they will be built\n/// by the AST context when it is created.\nenum PredefinedTypeIDs {\n  /// The NULL type.\n  PREDEF_TYPE_NULL_ID = 0,\n\n  /// The void type.\n  PREDEF_TYPE_VOID_ID = 1,\n\n  /// The 'bool' or '_Bool' type.\n  PREDEF_TYPE_BOOL_ID = 2,\n\n  /// The 'char' type, when it is unsigned.\n  PREDEF_TYPE_CHAR_U_ID = 3,\n\n  /// The 'unsigned char' type.\n  PREDEF_TYPE_UCHAR_ID = 4,\n\n  /// The 'unsigned short' type.\n  PREDEF_TYPE_USHORT_ID = 5,\n\n  /// The 'unsigned int' type.\n  PREDEF_TYPE_UINT_ID = 6,\n\n  /// The 'unsigned long' type.\n  PREDEF_TYPE_ULONG_ID = 7,\n\n  /// The 'unsigned long long' type.\n  PREDEF_TYPE_ULONGLONG_ID = 8,\n\n  /// The 'char' type, when it is signed.\n  PREDEF_TYPE_CHAR_S_ID = 9,\n\n  /// The 'signed char' type.\n  PREDEF_TYPE_SCHAR_ID = 10,\n\n  /// The C++ 'wchar_t' type.\n  PREDEF_TYPE_WCHAR_ID = 11,\n\n  /// The (signed) 'short' type.\n  PREDEF_TYPE_SHORT_ID = 12,\n\n  /// The (signed) 'int' type.\n  PREDEF_TYPE_INT_ID = 13,\n\n  /// The (signed) 'long' type.\n  PREDEF_TYPE_LONG_ID = 14,\n\n  /// The (signed) 'long long' type.\n  PREDEF_TYPE_LONGLONG_ID = 15,\n\n  /// The 'float' type.\n  PREDEF_TYPE_FLOAT_ID = 16,\n\n  /// The 'double' type.\n  PREDEF_TYPE_DOUBLE_ID = 17,\n\n  /// The 'long double' type.\n  PREDEF_TYPE_LONGDOUBLE_ID = 18,\n\n  /// The placeholder type for overloaded function sets.\n  PREDEF_TYPE_OVERLOAD_ID = 19,\n\n  /// The placeholder type for dependent types.\n  PREDEF_TYPE_DEPENDENT_ID = 20,\n\n  /// The '__uint128_t' type.\n  PREDEF_TYPE_UINT128_ID = 21,\n\n  /// The '__int128_t' type.\n  PREDEF_TYPE_INT128_ID = 22,\n\n  /// The type of 'nullptr'.\n  PREDEF_TYPE_NULLPTR_ID = 23,\n\n  /// The C++ 'char16_t' type.\n  PREDEF_TYPE_CHAR16_ID = 24,\n\n  /// The C++ 'char32_t' type.\n  PREDEF_TYPE_CHAR32_ID = 25,\n\n  /// The ObjC 'id' type.\n  PREDEF_TYPE_OBJC_ID = 26,\n\n  /// The ObjC 'Class' type.\n  PREDEF_TYPE_OBJC_CLASS = 27,\n\n  /// The ObjC 'SEL' type.\n  PREDEF_TYPE_OBJC_SEL = 28,\n\n  /// The 'unknown any' placeholder type.\n  PREDEF_TYPE_UNKNOWN_ANY = 29,\n\n  /// The placeholder type for bound member functions.\n  PREDEF_TYPE_BOUND_MEMBER = 30,\n\n  /// The \"auto\" deduction type.\n  PREDEF_TYPE_AUTO_DEDUCT = 31,\n\n  /// The \"auto &&\" deduction type.\n  PREDEF_TYPE_AUTO_RREF_DEDUCT = 32,\n\n  /// The OpenCL 'half' / ARM NEON __fp16 type.\n  PREDEF_TYPE_HALF_ID = 33,\n\n  /// ARC's unbridged-cast placeholder type.\n  PREDEF_TYPE_ARC_UNBRIDGED_CAST = 34,\n\n  /// The pseudo-object placeholder type.\n  PREDEF_TYPE_PSEUDO_OBJECT = 35,\n\n  /// The placeholder type for builtin functions.\n  PREDEF_TYPE_BUILTIN_FN = 36,\n\n  /// OpenCL event type.\n  PREDEF_TYPE_EVENT_ID = 37,\n\n  /// OpenCL clk event type.\n  PREDEF_TYPE_CLK_EVENT_ID = 38,\n\n  /// OpenCL sampler type.\n  PREDEF_TYPE_SAMPLER_ID = 39,\n\n  /// OpenCL queue type.\n  PREDEF_TYPE_QUEUE_ID = 40,\n\n  /// OpenCL reserve_id type.\n  PREDEF_TYPE_RESERVE_ID_ID = 41,\n\n  /// The placeholder type for OpenMP array section.\n  PREDEF_TYPE_OMP_ARRAY_SECTION = 42,\n\n  /// The '__float128' type\n  PREDEF_TYPE_FLOAT128_ID = 43,\n\n  /// The '_Float16' type\n  PREDEF_TYPE_FLOAT16_ID = 44,\n\n  /// The C++ 'char8_t' type.\n  PREDEF_TYPE_CHAR8_ID = 45,\n\n  /// \\brief The 'short _Accum' type\n  PREDEF_TYPE_SHORT_ACCUM_ID = 46,\n\n  /// \\brief The '_Accum' type\n  PREDEF_TYPE_ACCUM_ID = 47,\n\n  /// \\brief The 'long _Accum' type\n  PREDEF_TYPE_LONG_ACCUM_ID = 48,\n\n  /// \\brief The 'unsigned short _Accum' type\n  PREDEF_TYPE_USHORT_ACCUM_ID = 49,\n\n  /// \\brief The 'unsigned _Accum' type\n  PREDEF_TYPE_UACCUM_ID = 50,\n\n  /// \\brief The 'unsigned long _Accum' type\n  PREDEF_TYPE_ULONG_ACCUM_ID = 51,\n\n  /// \\brief The 'short _Fract' type\n  PREDEF_TYPE_SHORT_FRACT_ID = 52,\n\n  /// \\brief The '_Fract' type\n  PREDEF_TYPE_FRACT_ID = 53,\n\n  /// \\brief The 'long _Fract' type\n  PREDEF_TYPE_LONG_FRACT_ID = 54,\n\n  /// \\brief The 'unsigned short _Fract' type\n  PREDEF_TYPE_USHORT_FRACT_ID = 55,\n\n  /// \\brief The 'unsigned _Fract' type\n  PREDEF_TYPE_UFRACT_ID = 56,\n\n  /// \\brief The 'unsigned long _Fract' type\n  PREDEF_TYPE_ULONG_FRACT_ID = 57,\n\n  /// \\brief The '_Sat short _Accum' type\n  PREDEF_TYPE_SAT_SHORT_ACCUM_ID = 58,\n\n  /// \\brief The '_Sat _Accum' type\n  PREDEF_TYPE_SAT_ACCUM_ID = 59,\n\n  /// \\brief The '_Sat long _Accum' type\n  PREDEF_TYPE_SAT_LONG_ACCUM_ID = 60,\n\n  /// \\brief The '_Sat unsigned short _Accum' type\n  PREDEF_TYPE_SAT_USHORT_ACCUM_ID = 61,\n\n  /// \\brief The '_Sat unsigned _Accum' type\n  PREDEF_TYPE_SAT_UACCUM_ID = 62,\n\n  /// \\brief The '_Sat unsigned long _Accum' type\n  PREDEF_TYPE_SAT_ULONG_ACCUM_ID = 63,\n\n  /// \\brief The '_Sat short _Fract' type\n  PREDEF_TYPE_SAT_SHORT_FRACT_ID = 64,\n\n  /// \\brief The '_Sat _Fract' type\n  PREDEF_TYPE_SAT_FRACT_ID = 65,\n\n  /// \\brief The '_Sat long _Fract' type\n  PREDEF_TYPE_SAT_LONG_FRACT_ID = 66,\n\n  /// \\brief The '_Sat unsigned short _Fract' type\n  PREDEF_TYPE_SAT_USHORT_FRACT_ID = 67,\n\n  /// \\brief The '_Sat unsigned _Fract' type\n  PREDEF_TYPE_SAT_UFRACT_ID = 68,\n\n  /// \\brief The '_Sat unsigned long _Fract' type\n  PREDEF_TYPE_SAT_ULONG_FRACT_ID = 69,\n\n  /// The placeholder type for OpenMP array shaping operation.\n  PREDEF_TYPE_OMP_ARRAY_SHAPING = 70,\n\n  /// The placeholder type for OpenMP iterator expression.\n  PREDEF_TYPE_OMP_ITERATOR = 71,\n\n  /// A placeholder type for incomplete matrix index operations.\n  PREDEF_TYPE_INCOMPLETE_MATRIX_IDX = 72,\n\n  /// \\brief The '__bf16' type\n  PREDEF_TYPE_BFLOAT16_ID = 73,\n\n/// OpenCL image types with auto numeration\n#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix)                   \\\n  PREDEF_TYPE_##Id##_ID,\n#include \"clang/Basic/OpenCLImageTypes.def\"\n/// \\brief OpenCL extension types with auto numeration\n#define EXT_OPAQUE_TYPE(ExtType, Id, Ext) PREDEF_TYPE_##Id##_ID,\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n// \\brief SVE types with auto numeration\n#define SVE_TYPE(Name, Id, SingletonId) PREDEF_TYPE_##Id##_ID,\n#include \"clang/Basic/AArch64SVEACLETypes.def\"\n// \\brief  PowerPC MMA types with auto numeration\n#define PPC_VECTOR_TYPE(Name, Id, Size) PREDEF_TYPE_##Id##_ID,\n#include \"clang/Basic/PPCTypes.def\"\n// \\brief RISC-V V types with auto numeration\n#define RVV_TYPE(Name, Id, SingletonId) PREDEF_TYPE_##Id##_ID,\n#include \"clang/Basic/RISCVVTypes.def\"\n};\n\n/// The number of predefined type IDs that are reserved for\n/// the PREDEF_TYPE_* constants.\n///\n/// Type IDs for non-predefined types will start at\n/// NUM_PREDEF_TYPE_IDs.\nconst unsigned NUM_PREDEF_TYPE_IDS = 300;\n\n/// Record codes for each kind of type.\n///\n/// These constants describe the type records that can occur within a\n/// block identified by DECLTYPES_BLOCK_ID in the AST file. Each\n/// constant describes a record for a specific type class in the\n/// AST. Note that DeclCode values share this code space.\nenum TypeCode {\n#define TYPE_BIT_CODE(CLASS_ID, CODE_ID, CODE_VALUE)                           \\\n  TYPE_##CODE_ID = CODE_VALUE,\n#include \"clang/Serialization/TypeBitCodes.def\"\n\n  /// An ExtQualType record.\n  TYPE_EXT_QUAL = 1\n};\n\n/// The type IDs for special types constructed by semantic\n/// analysis.\n///\n/// The constants in this enumeration are indices into the\n/// SPECIAL_TYPES record.\nenum SpecialTypeIDs {\n  /// CFConstantString type\n  SPECIAL_TYPE_CF_CONSTANT_STRING = 0,\n\n  /// C FILE typedef type\n  SPECIAL_TYPE_FILE = 1,\n\n  /// C jmp_buf typedef type\n  SPECIAL_TYPE_JMP_BUF = 2,\n\n  /// C sigjmp_buf typedef type\n  SPECIAL_TYPE_SIGJMP_BUF = 3,\n\n  /// Objective-C \"id\" redefinition type\n  SPECIAL_TYPE_OBJC_ID_REDEFINITION = 4,\n\n  /// Objective-C \"Class\" redefinition type\n  SPECIAL_TYPE_OBJC_CLASS_REDEFINITION = 5,\n\n  /// Objective-C \"SEL\" redefinition type\n  SPECIAL_TYPE_OBJC_SEL_REDEFINITION = 6,\n\n  /// C ucontext_t typedef type\n  SPECIAL_TYPE_UCONTEXT_T = 7\n};\n\n/// The number of special type IDs.\nconst unsigned NumSpecialTypeIDs = 8;\n\n/// Predefined declaration IDs.\n///\n/// These declaration IDs correspond to predefined declarations in the AST\n/// context, such as the NULL declaration ID. Such declarations are never\n/// actually serialized, since they will be built by the AST context when\n/// it is created.\nenum PredefinedDeclIDs {\n  /// The NULL declaration.\n  PREDEF_DECL_NULL_ID = 0,\n\n  /// The translation unit.\n  PREDEF_DECL_TRANSLATION_UNIT_ID = 1,\n\n  /// The Objective-C 'id' type.\n  PREDEF_DECL_OBJC_ID_ID = 2,\n\n  /// The Objective-C 'SEL' type.\n  PREDEF_DECL_OBJC_SEL_ID = 3,\n\n  /// The Objective-C 'Class' type.\n  PREDEF_DECL_OBJC_CLASS_ID = 4,\n\n  /// The Objective-C 'Protocol' type.\n  PREDEF_DECL_OBJC_PROTOCOL_ID = 5,\n\n  /// The signed 128-bit integer type.\n  PREDEF_DECL_INT_128_ID = 6,\n\n  /// The unsigned 128-bit integer type.\n  PREDEF_DECL_UNSIGNED_INT_128_ID = 7,\n\n  /// The internal 'instancetype' typedef.\n  PREDEF_DECL_OBJC_INSTANCETYPE_ID = 8,\n\n  /// The internal '__builtin_va_list' typedef.\n  PREDEF_DECL_BUILTIN_VA_LIST_ID = 9,\n\n  /// The internal '__va_list_tag' struct, if any.\n  PREDEF_DECL_VA_LIST_TAG = 10,\n\n  /// The internal '__builtin_ms_va_list' typedef.\n  PREDEF_DECL_BUILTIN_MS_VA_LIST_ID = 11,\n\n  /// The predeclared '_GUID' struct.\n  PREDEF_DECL_BUILTIN_MS_GUID_ID = 12,\n\n  /// The extern \"C\" context.\n  PREDEF_DECL_EXTERN_C_CONTEXT_ID = 13,\n\n  /// The internal '__make_integer_seq' template.\n  PREDEF_DECL_MAKE_INTEGER_SEQ_ID = 14,\n\n  /// The internal '__NSConstantString' typedef.\n  PREDEF_DECL_CF_CONSTANT_STRING_ID = 15,\n\n  /// The internal '__NSConstantString' tag type.\n  PREDEF_DECL_CF_CONSTANT_STRING_TAG_ID = 16,\n\n  /// The internal '__type_pack_element' template.\n  PREDEF_DECL_TYPE_PACK_ELEMENT_ID = 17,\n};\n\n/// The number of declaration IDs that are predefined.\n///\n/// For more information about predefined declarations, see the\n/// \\c PredefinedDeclIDs type and the PREDEF_DECL_*_ID constants.\nconst unsigned int NUM_PREDEF_DECL_IDS = 18;\n\n/// Record of updates for a declaration that was modified after\n/// being deserialized. This can occur within DECLTYPES_BLOCK_ID.\nconst unsigned int DECL_UPDATES = 49;\n\n/// Record code for a list of local redeclarations of a declaration.\n/// This can occur within DECLTYPES_BLOCK_ID.\nconst unsigned int LOCAL_REDECLARATIONS = 50;\n\n/// Record codes for each kind of declaration.\n///\n/// These constants describe the declaration records that can occur within\n/// a declarations block (identified by DECLTYPES_BLOCK_ID). Each\n/// constant describes a record for a specific declaration class\n/// in the AST. Note that TypeCode values share this code space.\nenum DeclCode {\n  /// A TypedefDecl record.\n  DECL_TYPEDEF = 51,\n  /// A TypeAliasDecl record.\n\n  DECL_TYPEALIAS,\n\n  /// An EnumDecl record.\n  DECL_ENUM,\n\n  /// A RecordDecl record.\n  DECL_RECORD,\n\n  /// An EnumConstantDecl record.\n  DECL_ENUM_CONSTANT,\n\n  /// A FunctionDecl record.\n  DECL_FUNCTION,\n\n  /// A ObjCMethodDecl record.\n  DECL_OBJC_METHOD,\n\n  /// A ObjCInterfaceDecl record.\n  DECL_OBJC_INTERFACE,\n\n  /// A ObjCProtocolDecl record.\n  DECL_OBJC_PROTOCOL,\n\n  /// A ObjCIvarDecl record.\n  DECL_OBJC_IVAR,\n\n  /// A ObjCAtDefsFieldDecl record.\n  DECL_OBJC_AT_DEFS_FIELD,\n\n  /// A ObjCCategoryDecl record.\n  DECL_OBJC_CATEGORY,\n\n  /// A ObjCCategoryImplDecl record.\n  DECL_OBJC_CATEGORY_IMPL,\n\n  /// A ObjCImplementationDecl record.\n  DECL_OBJC_IMPLEMENTATION,\n\n  /// A ObjCCompatibleAliasDecl record.\n  DECL_OBJC_COMPATIBLE_ALIAS,\n\n  /// A ObjCPropertyDecl record.\n  DECL_OBJC_PROPERTY,\n\n  /// A ObjCPropertyImplDecl record.\n  DECL_OBJC_PROPERTY_IMPL,\n\n  /// A FieldDecl record.\n  DECL_FIELD,\n\n  /// A MSPropertyDecl record.\n  DECL_MS_PROPERTY,\n\n  /// A MSGuidDecl record.\n  DECL_MS_GUID,\n\n  /// A TemplateParamObjectDecl record.\n  DECL_TEMPLATE_PARAM_OBJECT,\n\n  /// A VarDecl record.\n  DECL_VAR,\n\n  /// An ImplicitParamDecl record.\n  DECL_IMPLICIT_PARAM,\n\n  /// A ParmVarDecl record.\n  DECL_PARM_VAR,\n\n  /// A DecompositionDecl record.\n  DECL_DECOMPOSITION,\n\n  /// A BindingDecl record.\n  DECL_BINDING,\n\n  /// A FileScopeAsmDecl record.\n  DECL_FILE_SCOPE_ASM,\n\n  /// A BlockDecl record.\n  DECL_BLOCK,\n\n  /// A CapturedDecl record.\n  DECL_CAPTURED,\n\n  /// A record that stores the set of declarations that are\n  /// lexically stored within a given DeclContext.\n  ///\n  /// The record itself is a blob that is an array of declaration IDs,\n  /// in the order in which those declarations were added to the\n  /// declaration context. This data is used when iterating over\n  /// the contents of a DeclContext, e.g., via\n  /// DeclContext::decls_begin() and DeclContext::decls_end().\n  DECL_CONTEXT_LEXICAL,\n\n  /// A record that stores the set of declarations that are\n  /// visible from a given DeclContext.\n  ///\n  /// The record itself stores a set of mappings, each of which\n  /// associates a declaration name with one or more declaration\n  /// IDs. This data is used when performing qualified name lookup\n  /// into a DeclContext via DeclContext::lookup.\n  DECL_CONTEXT_VISIBLE,\n\n  /// A LabelDecl record.\n  DECL_LABEL,\n\n  /// A NamespaceDecl record.\n  DECL_NAMESPACE,\n\n  /// A NamespaceAliasDecl record.\n  DECL_NAMESPACE_ALIAS,\n\n  /// A UsingDecl record.\n  DECL_USING,\n\n  /// A UsingPackDecl record.\n  DECL_USING_PACK,\n\n  /// A UsingShadowDecl record.\n  DECL_USING_SHADOW,\n\n  /// A ConstructorUsingShadowDecl record.\n  DECL_CONSTRUCTOR_USING_SHADOW,\n\n  /// A UsingDirecitveDecl record.\n  DECL_USING_DIRECTIVE,\n\n  /// An UnresolvedUsingValueDecl record.\n  DECL_UNRESOLVED_USING_VALUE,\n\n  /// An UnresolvedUsingTypenameDecl record.\n  DECL_UNRESOLVED_USING_TYPENAME,\n\n  /// A LinkageSpecDecl record.\n  DECL_LINKAGE_SPEC,\n\n  /// An ExportDecl record.\n  DECL_EXPORT,\n\n  /// A CXXRecordDecl record.\n  DECL_CXX_RECORD,\n\n  /// A CXXDeductionGuideDecl record.\n  DECL_CXX_DEDUCTION_GUIDE,\n\n  /// A CXXMethodDecl record.\n  DECL_CXX_METHOD,\n\n  /// A CXXConstructorDecl record.\n  DECL_CXX_CONSTRUCTOR,\n\n  /// A CXXDestructorDecl record.\n  DECL_CXX_DESTRUCTOR,\n\n  /// A CXXConversionDecl record.\n  DECL_CXX_CONVERSION,\n\n  /// An AccessSpecDecl record.\n  DECL_ACCESS_SPEC,\n\n  /// A FriendDecl record.\n  DECL_FRIEND,\n\n  /// A FriendTemplateDecl record.\n  DECL_FRIEND_TEMPLATE,\n\n  /// A ClassTemplateDecl record.\n  DECL_CLASS_TEMPLATE,\n\n  /// A ClassTemplateSpecializationDecl record.\n  DECL_CLASS_TEMPLATE_SPECIALIZATION,\n\n  /// A ClassTemplatePartialSpecializationDecl record.\n  DECL_CLASS_TEMPLATE_PARTIAL_SPECIALIZATION,\n\n  /// A VarTemplateDecl record.\n  DECL_VAR_TEMPLATE,\n\n  /// A VarTemplateSpecializationDecl record.\n  DECL_VAR_TEMPLATE_SPECIALIZATION,\n\n  /// A VarTemplatePartialSpecializationDecl record.\n  DECL_VAR_TEMPLATE_PARTIAL_SPECIALIZATION,\n\n  /// A FunctionTemplateDecl record.\n  DECL_FUNCTION_TEMPLATE,\n\n  /// A TemplateTypeParmDecl record.\n  DECL_TEMPLATE_TYPE_PARM,\n\n  /// A NonTypeTemplateParmDecl record.\n  DECL_NON_TYPE_TEMPLATE_PARM,\n\n  /// A TemplateTemplateParmDecl record.\n  DECL_TEMPLATE_TEMPLATE_PARM,\n\n  /// A TypeAliasTemplateDecl record.\n  DECL_TYPE_ALIAS_TEMPLATE,\n\n  /// \\brief A ConceptDecl record.\n  DECL_CONCEPT,\n\n  /// \\brief A StaticAssertDecl record.\n  DECL_STATIC_ASSERT,\n\n  /// A record containing CXXBaseSpecifiers.\n  DECL_CXX_BASE_SPECIFIERS,\n\n  /// A record containing CXXCtorInitializers.\n  DECL_CXX_CTOR_INITIALIZERS,\n\n  /// A IndirectFieldDecl record.\n  DECL_INDIRECTFIELD,\n\n  /// A NonTypeTemplateParmDecl record that stores an expanded\n  /// non-type template parameter pack.\n  DECL_EXPANDED_NON_TYPE_TEMPLATE_PARM_PACK,\n\n  /// A TemplateTemplateParmDecl record that stores an expanded\n  /// template template parameter pack.\n  DECL_EXPANDED_TEMPLATE_TEMPLATE_PARM_PACK,\n\n  /// A ClassScopeFunctionSpecializationDecl record a class scope\n  /// function specialization. (Microsoft extension).\n  DECL_CLASS_SCOPE_FUNCTION_SPECIALIZATION,\n\n  /// An ImportDecl recording a module import.\n  DECL_IMPORT,\n\n  /// An OMPThreadPrivateDecl record.\n  DECL_OMP_THREADPRIVATE,\n\n  /// An OMPRequiresDecl record.\n  DECL_OMP_REQUIRES,\n\n  /// An OMPAllocateDcl record.\n  DECL_OMP_ALLOCATE,\n\n  /// An EmptyDecl record.\n  DECL_EMPTY,\n\n  /// An LifetimeExtendedTemporaryDecl record.\n  DECL_LIFETIME_EXTENDED_TEMPORARY,\n\n  /// A RequiresExprBodyDecl record.\n  DECL_REQUIRES_EXPR_BODY,\n\n  /// An ObjCTypeParamDecl record.\n  DECL_OBJC_TYPE_PARAM,\n\n  /// An OMPCapturedExprDecl record.\n  DECL_OMP_CAPTUREDEXPR,\n\n  /// A PragmaCommentDecl record.\n  DECL_PRAGMA_COMMENT,\n\n  /// A PragmaDetectMismatchDecl record.\n  DECL_PRAGMA_DETECT_MISMATCH,\n\n  /// An OMPDeclareMapperDecl record.\n  DECL_OMP_DECLARE_MAPPER,\n\n  /// An OMPDeclareReductionDecl record.\n  DECL_OMP_DECLARE_REDUCTION,\n\n  DECL_LAST = DECL_OMP_DECLARE_REDUCTION\n};\n\n/// Record codes for each kind of statement or expression.\n///\n/// These constants describe the records that describe statements\n/// or expressions. These records  occur within type and declarations\n/// block, so they begin with record values of 128.  Each constant\n/// describes a record for a specific statement or expression class in the\n/// AST.\nenum StmtCode {\n  /// A marker record that indicates that we are at the end\n  /// of an expression.\n  STMT_STOP = DECL_LAST + 1,\n\n  /// A NULL expression.\n  STMT_NULL_PTR,\n\n  /// A reference to a previously [de]serialized Stmt record.\n  STMT_REF_PTR,\n\n  /// A NullStmt record.\n  STMT_NULL,\n\n  /// A CompoundStmt record.\n  STMT_COMPOUND,\n\n  /// A CaseStmt record.\n  STMT_CASE,\n\n  /// A DefaultStmt record.\n  STMT_DEFAULT,\n\n  /// A LabelStmt record.\n  STMT_LABEL,\n\n  /// An AttributedStmt record.\n  STMT_ATTRIBUTED,\n\n  /// An IfStmt record.\n  STMT_IF,\n\n  /// A SwitchStmt record.\n  STMT_SWITCH,\n\n  /// A WhileStmt record.\n  STMT_WHILE,\n\n  /// A DoStmt record.\n  STMT_DO,\n\n  /// A ForStmt record.\n  STMT_FOR,\n\n  /// A GotoStmt record.\n  STMT_GOTO,\n\n  /// An IndirectGotoStmt record.\n  STMT_INDIRECT_GOTO,\n\n  /// A ContinueStmt record.\n  STMT_CONTINUE,\n\n  /// A BreakStmt record.\n  STMT_BREAK,\n\n  /// A ReturnStmt record.\n  STMT_RETURN,\n\n  /// A DeclStmt record.\n  STMT_DECL,\n\n  /// A CapturedStmt record.\n  STMT_CAPTURED,\n\n  /// A GCC-style AsmStmt record.\n  STMT_GCCASM,\n\n  /// A MS-style AsmStmt record.\n  STMT_MSASM,\n\n  /// A constant expression context.\n  EXPR_CONSTANT,\n\n  /// A PredefinedExpr record.\n  EXPR_PREDEFINED,\n\n  /// A DeclRefExpr record.\n  EXPR_DECL_REF,\n\n  /// An IntegerLiteral record.\n  EXPR_INTEGER_LITERAL,\n\n  /// A FloatingLiteral record.\n  EXPR_FLOATING_LITERAL,\n\n  /// An ImaginaryLiteral record.\n  EXPR_IMAGINARY_LITERAL,\n\n  /// A StringLiteral record.\n  EXPR_STRING_LITERAL,\n\n  /// A CharacterLiteral record.\n  EXPR_CHARACTER_LITERAL,\n\n  /// A ParenExpr record.\n  EXPR_PAREN,\n\n  /// A ParenListExpr record.\n  EXPR_PAREN_LIST,\n\n  /// A UnaryOperator record.\n  EXPR_UNARY_OPERATOR,\n\n  /// An OffsetOfExpr record.\n  EXPR_OFFSETOF,\n\n  /// A SizefAlignOfExpr record.\n  EXPR_SIZEOF_ALIGN_OF,\n\n  /// An ArraySubscriptExpr record.\n  EXPR_ARRAY_SUBSCRIPT,\n\n  /// An MatrixSubscriptExpr record.\n  EXPR_MATRIX_SUBSCRIPT,\n\n  /// A CallExpr record.\n  EXPR_CALL,\n\n  /// A MemberExpr record.\n  EXPR_MEMBER,\n\n  /// A BinaryOperator record.\n  EXPR_BINARY_OPERATOR,\n\n  /// A CompoundAssignOperator record.\n  EXPR_COMPOUND_ASSIGN_OPERATOR,\n\n  /// A ConditionOperator record.\n  EXPR_CONDITIONAL_OPERATOR,\n\n  /// An ImplicitCastExpr record.\n  EXPR_IMPLICIT_CAST,\n\n  /// A CStyleCastExpr record.\n  EXPR_CSTYLE_CAST,\n\n  /// A CompoundLiteralExpr record.\n  EXPR_COMPOUND_LITERAL,\n\n  /// An ExtVectorElementExpr record.\n  EXPR_EXT_VECTOR_ELEMENT,\n\n  /// An InitListExpr record.\n  EXPR_INIT_LIST,\n\n  /// A DesignatedInitExpr record.\n  EXPR_DESIGNATED_INIT,\n\n  /// A DesignatedInitUpdateExpr record.\n  EXPR_DESIGNATED_INIT_UPDATE,\n\n  /// An NoInitExpr record.\n  EXPR_NO_INIT,\n\n  /// An ArrayInitLoopExpr record.\n  EXPR_ARRAY_INIT_LOOP,\n\n  /// An ArrayInitIndexExpr record.\n  EXPR_ARRAY_INIT_INDEX,\n\n  /// An ImplicitValueInitExpr record.\n  EXPR_IMPLICIT_VALUE_INIT,\n\n  /// A VAArgExpr record.\n  EXPR_VA_ARG,\n\n  /// An AddrLabelExpr record.\n  EXPR_ADDR_LABEL,\n\n  /// A StmtExpr record.\n  EXPR_STMT,\n\n  /// A ChooseExpr record.\n  EXPR_CHOOSE,\n\n  /// A GNUNullExpr record.\n  EXPR_GNU_NULL,\n\n  /// A SourceLocExpr record.\n  EXPR_SOURCE_LOC,\n\n  /// A ShuffleVectorExpr record.\n  EXPR_SHUFFLE_VECTOR,\n\n  /// A ConvertVectorExpr record.\n  EXPR_CONVERT_VECTOR,\n\n  /// BlockExpr\n  EXPR_BLOCK,\n\n  /// A GenericSelectionExpr record.\n  EXPR_GENERIC_SELECTION,\n\n  /// A PseudoObjectExpr record.\n  EXPR_PSEUDO_OBJECT,\n\n  /// An AtomicExpr record.\n  EXPR_ATOMIC,\n\n  /// A RecoveryExpr record.\n  EXPR_RECOVERY,\n\n  // Objective-C\n\n  /// An ObjCStringLiteral record.\n  EXPR_OBJC_STRING_LITERAL,\n\n  EXPR_OBJC_BOXED_EXPRESSION,\n  EXPR_OBJC_ARRAY_LITERAL,\n  EXPR_OBJC_DICTIONARY_LITERAL,\n\n  /// An ObjCEncodeExpr record.\n  EXPR_OBJC_ENCODE,\n\n  /// An ObjCSelectorExpr record.\n  EXPR_OBJC_SELECTOR_EXPR,\n\n  /// An ObjCProtocolExpr record.\n  EXPR_OBJC_PROTOCOL_EXPR,\n\n  /// An ObjCIvarRefExpr record.\n  EXPR_OBJC_IVAR_REF_EXPR,\n\n  /// An ObjCPropertyRefExpr record.\n  EXPR_OBJC_PROPERTY_REF_EXPR,\n\n  /// An ObjCSubscriptRefExpr record.\n  EXPR_OBJC_SUBSCRIPT_REF_EXPR,\n\n  /// UNUSED\n  EXPR_OBJC_KVC_REF_EXPR,\n\n  /// An ObjCMessageExpr record.\n  EXPR_OBJC_MESSAGE_EXPR,\n\n  /// An ObjCIsa Expr record.\n  EXPR_OBJC_ISA,\n\n  /// An ObjCIndirectCopyRestoreExpr record.\n  EXPR_OBJC_INDIRECT_COPY_RESTORE,\n\n  /// An ObjCForCollectionStmt record.\n  STMT_OBJC_FOR_COLLECTION,\n\n  /// An ObjCAtCatchStmt record.\n  STMT_OBJC_CATCH,\n\n  /// An ObjCAtFinallyStmt record.\n  STMT_OBJC_FINALLY,\n\n  /// An ObjCAtTryStmt record.\n  STMT_OBJC_AT_TRY,\n\n  /// An ObjCAtSynchronizedStmt record.\n  STMT_OBJC_AT_SYNCHRONIZED,\n\n  /// An ObjCAtThrowStmt record.\n  STMT_OBJC_AT_THROW,\n\n  /// An ObjCAutoreleasePoolStmt record.\n  STMT_OBJC_AUTORELEASE_POOL,\n\n  /// An ObjCBoolLiteralExpr record.\n  EXPR_OBJC_BOOL_LITERAL,\n\n  /// An ObjCAvailabilityCheckExpr record.\n  EXPR_OBJC_AVAILABILITY_CHECK,\n\n  // C++\n\n  /// A CXXCatchStmt record.\n  STMT_CXX_CATCH,\n\n  /// A CXXTryStmt record.\n  STMT_CXX_TRY,\n  /// A CXXForRangeStmt record.\n\n  STMT_CXX_FOR_RANGE,\n\n  /// A CXXOperatorCallExpr record.\n  EXPR_CXX_OPERATOR_CALL,\n\n  /// A CXXMemberCallExpr record.\n  EXPR_CXX_MEMBER_CALL,\n\n  /// A CXXRewrittenBinaryOperator record.\n  EXPR_CXX_REWRITTEN_BINARY_OPERATOR,\n\n  /// A CXXConstructExpr record.\n  EXPR_CXX_CONSTRUCT,\n\n  /// A CXXInheritedCtorInitExpr record.\n  EXPR_CXX_INHERITED_CTOR_INIT,\n\n  /// A CXXTemporaryObjectExpr record.\n  EXPR_CXX_TEMPORARY_OBJECT,\n\n  /// A CXXStaticCastExpr record.\n  EXPR_CXX_STATIC_CAST,\n\n  /// A CXXDynamicCastExpr record.\n  EXPR_CXX_DYNAMIC_CAST,\n\n  /// A CXXReinterpretCastExpr record.\n  EXPR_CXX_REINTERPRET_CAST,\n\n  /// A CXXConstCastExpr record.\n  EXPR_CXX_CONST_CAST,\n\n  /// A CXXAddrspaceCastExpr record.\n  EXPR_CXX_ADDRSPACE_CAST,\n\n  /// A CXXFunctionalCastExpr record.\n  EXPR_CXX_FUNCTIONAL_CAST,\n\n  /// A BuiltinBitCastExpr record.\n  EXPR_BUILTIN_BIT_CAST,\n\n  /// A UserDefinedLiteral record.\n  EXPR_USER_DEFINED_LITERAL,\n\n  /// A CXXStdInitializerListExpr record.\n  EXPR_CXX_STD_INITIALIZER_LIST,\n\n  /// A CXXBoolLiteralExpr record.\n  EXPR_CXX_BOOL_LITERAL,\n\n  EXPR_CXX_NULL_PTR_LITERAL, // CXXNullPtrLiteralExpr\n  EXPR_CXX_TYPEID_EXPR,      // CXXTypeidExpr (of expr).\n  EXPR_CXX_TYPEID_TYPE,      // CXXTypeidExpr (of type).\n  EXPR_CXX_THIS,             // CXXThisExpr\n  EXPR_CXX_THROW,            // CXXThrowExpr\n  EXPR_CXX_DEFAULT_ARG,      // CXXDefaultArgExpr\n  EXPR_CXX_DEFAULT_INIT,     // CXXDefaultInitExpr\n  EXPR_CXX_BIND_TEMPORARY,   // CXXBindTemporaryExpr\n\n  EXPR_CXX_SCALAR_VALUE_INIT, // CXXScalarValueInitExpr\n  EXPR_CXX_NEW,               // CXXNewExpr\n  EXPR_CXX_DELETE,            // CXXDeleteExpr\n  EXPR_CXX_PSEUDO_DESTRUCTOR, // CXXPseudoDestructorExpr\n\n  EXPR_EXPR_WITH_CLEANUPS, // ExprWithCleanups\n\n  EXPR_CXX_DEPENDENT_SCOPE_MEMBER,   // CXXDependentScopeMemberExpr\n  EXPR_CXX_DEPENDENT_SCOPE_DECL_REF, // DependentScopeDeclRefExpr\n  EXPR_CXX_UNRESOLVED_CONSTRUCT,     // CXXUnresolvedConstructExpr\n  EXPR_CXX_UNRESOLVED_MEMBER,        // UnresolvedMemberExpr\n  EXPR_CXX_UNRESOLVED_LOOKUP,        // UnresolvedLookupExpr\n\n  EXPR_CXX_EXPRESSION_TRAIT, // ExpressionTraitExpr\n  EXPR_CXX_NOEXCEPT,         // CXXNoexceptExpr\n\n  EXPR_OPAQUE_VALUE,                // OpaqueValueExpr\n  EXPR_BINARY_CONDITIONAL_OPERATOR, // BinaryConditionalOperator\n  EXPR_TYPE_TRAIT,                  // TypeTraitExpr\n  EXPR_ARRAY_TYPE_TRAIT,            // ArrayTypeTraitIntExpr\n\n  EXPR_PACK_EXPANSION,                    // PackExpansionExpr\n  EXPR_SIZEOF_PACK,                       // SizeOfPackExpr\n  EXPR_SUBST_NON_TYPE_TEMPLATE_PARM,      // SubstNonTypeTemplateParmExpr\n  EXPR_SUBST_NON_TYPE_TEMPLATE_PARM_PACK, // SubstNonTypeTemplateParmPackExpr\n  EXPR_FUNCTION_PARM_PACK,                // FunctionParmPackExpr\n  EXPR_MATERIALIZE_TEMPORARY,             // MaterializeTemporaryExpr\n  EXPR_CXX_FOLD,                          // CXXFoldExpr\n  EXPR_CONCEPT_SPECIALIZATION,            // ConceptSpecializationExpr\n  EXPR_REQUIRES,                          // RequiresExpr\n\n  // CUDA\n  EXPR_CUDA_KERNEL_CALL, // CUDAKernelCallExpr\n\n  // OpenCL\n  EXPR_ASTYPE, // AsTypeExpr\n\n  // Microsoft\n  EXPR_CXX_PROPERTY_REF_EXPR,       // MSPropertyRefExpr\n  EXPR_CXX_PROPERTY_SUBSCRIPT_EXPR, // MSPropertySubscriptExpr\n  EXPR_CXX_UUIDOF_EXPR,             // CXXUuidofExpr (of expr).\n  EXPR_CXX_UUIDOF_TYPE,             // CXXUuidofExpr (of type).\n  STMT_SEH_LEAVE,                   // SEHLeaveStmt\n  STMT_SEH_EXCEPT,                  // SEHExceptStmt\n  STMT_SEH_FINALLY,                 // SEHFinallyStmt\n  STMT_SEH_TRY,                     // SEHTryStmt\n\n  // OpenMP directives\n  STMT_OMP_CANONICAL_LOOP,\n  STMT_OMP_PARALLEL_DIRECTIVE,\n  STMT_OMP_SIMD_DIRECTIVE,\n  STMT_OMP_TILE_DIRECTIVE,\n  STMT_OMP_FOR_DIRECTIVE,\n  STMT_OMP_FOR_SIMD_DIRECTIVE,\n  STMT_OMP_SECTIONS_DIRECTIVE,\n  STMT_OMP_SECTION_DIRECTIVE,\n  STMT_OMP_SINGLE_DIRECTIVE,\n  STMT_OMP_MASTER_DIRECTIVE,\n  STMT_OMP_CRITICAL_DIRECTIVE,\n  STMT_OMP_PARALLEL_FOR_DIRECTIVE,\n  STMT_OMP_PARALLEL_FOR_SIMD_DIRECTIVE,\n  STMT_OMP_PARALLEL_MASTER_DIRECTIVE,\n  STMT_OMP_PARALLEL_SECTIONS_DIRECTIVE,\n  STMT_OMP_TASK_DIRECTIVE,\n  STMT_OMP_TASKYIELD_DIRECTIVE,\n  STMT_OMP_BARRIER_DIRECTIVE,\n  STMT_OMP_TASKWAIT_DIRECTIVE,\n  STMT_OMP_FLUSH_DIRECTIVE,\n  STMT_OMP_DEPOBJ_DIRECTIVE,\n  STMT_OMP_SCAN_DIRECTIVE,\n  STMT_OMP_ORDERED_DIRECTIVE,\n  STMT_OMP_ATOMIC_DIRECTIVE,\n  STMT_OMP_TARGET_DIRECTIVE,\n  STMT_OMP_TARGET_DATA_DIRECTIVE,\n  STMT_OMP_TARGET_ENTER_DATA_DIRECTIVE,\n  STMT_OMP_TARGET_EXIT_DATA_DIRECTIVE,\n  STMT_OMP_TARGET_PARALLEL_DIRECTIVE,\n  STMT_OMP_TARGET_PARALLEL_FOR_DIRECTIVE,\n  STMT_OMP_TEAMS_DIRECTIVE,\n  STMT_OMP_TASKGROUP_DIRECTIVE,\n  STMT_OMP_CANCELLATION_POINT_DIRECTIVE,\n  STMT_OMP_CANCEL_DIRECTIVE,\n  STMT_OMP_TASKLOOP_DIRECTIVE,\n  STMT_OMP_TASKLOOP_SIMD_DIRECTIVE,\n  STMT_OMP_MASTER_TASKLOOP_DIRECTIVE,\n  STMT_OMP_MASTER_TASKLOOP_SIMD_DIRECTIVE,\n  STMT_OMP_PARALLEL_MASTER_TASKLOOP_DIRECTIVE,\n  STMT_OMP_PARALLEL_MASTER_TASKLOOP_SIMD_DIRECTIVE,\n  STMT_OMP_DISTRIBUTE_DIRECTIVE,\n  STMT_OMP_TARGET_UPDATE_DIRECTIVE,\n  STMT_OMP_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE,\n  STMT_OMP_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE,\n  STMT_OMP_DISTRIBUTE_SIMD_DIRECTIVE,\n  STMT_OMP_TARGET_PARALLEL_FOR_SIMD_DIRECTIVE,\n  STMT_OMP_TARGET_SIMD_DIRECTIVE,\n  STMT_OMP_TEAMS_DISTRIBUTE_DIRECTIVE,\n  STMT_OMP_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE,\n  STMT_OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE,\n  STMT_OMP_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE,\n  STMT_OMP_TARGET_TEAMS_DIRECTIVE,\n  STMT_OMP_TARGET_TEAMS_DISTRIBUTE_DIRECTIVE,\n  STMT_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_DIRECTIVE,\n  STMT_OMP_TARGET_TEAMS_DISTRIBUTE_PARALLEL_FOR_SIMD_DIRECTIVE,\n  STMT_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD_DIRECTIVE,\n  EXPR_OMP_ARRAY_SECTION,\n  EXPR_OMP_ARRAY_SHAPING,\n  EXPR_OMP_ITERATOR,\n\n  // ARC\n  EXPR_OBJC_BRIDGED_CAST, // ObjCBridgedCastExpr\n\n  STMT_MS_DEPENDENT_EXISTS, // MSDependentExistsStmt\n  EXPR_LAMBDA,              // LambdaExpr\n  STMT_COROUTINE_BODY,\n  STMT_CORETURN,\n  EXPR_COAWAIT,\n  EXPR_COYIELD,\n  EXPR_DEPENDENT_COAWAIT,\n\n  // FixedPointLiteral\n  EXPR_FIXEDPOINT_LITERAL,\n};\n\n/// The kinds of designators that can occur in a\n/// DesignatedInitExpr.\nenum DesignatorTypes {\n  /// Field designator where only the field name is known.\n  DESIG_FIELD_NAME = 0,\n\n  /// Field designator where the field has been resolved to\n  /// a declaration.\n  DESIG_FIELD_DECL = 1,\n\n  /// Array designator.\n  DESIG_ARRAY = 2,\n\n  /// GNU array range designator.\n  DESIG_ARRAY_RANGE = 3\n};\n\n/// The different kinds of data that can occur in a\n/// CtorInitializer.\nenum CtorInitializerType {\n  CTOR_INITIALIZER_BASE,\n  CTOR_INITIALIZER_DELEGATING,\n  CTOR_INITIALIZER_MEMBER,\n  CTOR_INITIALIZER_INDIRECT_MEMBER\n};\n\n/// Kinds of cleanup objects owned by ExprWithCleanups.\nenum CleanupObjectKind { COK_Block, COK_CompoundLiteral };\n\n/// Describes the redeclarations of a declaration.\nstruct LocalRedeclarationsInfo {\n  // The ID of the first declaration\n  DeclID FirstID;\n\n  // Offset into the array of redeclaration chains.\n  unsigned Offset;\n\n  friend bool operator<(const LocalRedeclarationsInfo &X,\n                        const LocalRedeclarationsInfo &Y) {\n    return X.FirstID < Y.FirstID;\n  }\n\n  friend bool operator>(const LocalRedeclarationsInfo &X,\n                        const LocalRedeclarationsInfo &Y) {\n    return X.FirstID > Y.FirstID;\n  }\n\n  friend bool operator<=(const LocalRedeclarationsInfo &X,\n                         const LocalRedeclarationsInfo &Y) {\n    return X.FirstID <= Y.FirstID;\n  }\n\n  friend bool operator>=(const LocalRedeclarationsInfo &X,\n                         const LocalRedeclarationsInfo &Y) {\n    return X.FirstID >= Y.FirstID;\n  }\n};\n\n/// Describes the categories of an Objective-C class.\nstruct ObjCCategoriesInfo {\n  // The ID of the definition\n  DeclID DefinitionID;\n\n  // Offset into the array of category lists.\n  unsigned Offset;\n\n  friend bool operator<(const ObjCCategoriesInfo &X,\n                        const ObjCCategoriesInfo &Y) {\n    return X.DefinitionID < Y.DefinitionID;\n  }\n\n  friend bool operator>(const ObjCCategoriesInfo &X,\n                        const ObjCCategoriesInfo &Y) {\n    return X.DefinitionID > Y.DefinitionID;\n  }\n\n  friend bool operator<=(const ObjCCategoriesInfo &X,\n                         const ObjCCategoriesInfo &Y) {\n    return X.DefinitionID <= Y.DefinitionID;\n  }\n\n  friend bool operator>=(const ObjCCategoriesInfo &X,\n                         const ObjCCategoriesInfo &Y) {\n    return X.DefinitionID >= Y.DefinitionID;\n  }\n};\n\n/// A key used when looking up entities by \\ref DeclarationName.\n///\n/// Different \\ref DeclarationNames are mapped to different keys, but the\n/// same key can occasionally represent multiple names (for names that\n/// contain types, in particular).\nclass DeclarationNameKey {\n  using NameKind = unsigned;\n\n  NameKind Kind = 0;\n  uint64_t Data = 0;\n\npublic:\n  DeclarationNameKey() = default;\n  DeclarationNameKey(DeclarationName Name);\n  DeclarationNameKey(NameKind Kind, uint64_t Data) : Kind(Kind), Data(Data) {}\n\n  NameKind getKind() const { return Kind; }\n\n  IdentifierInfo *getIdentifier() const {\n    assert(Kind == DeclarationName::Identifier ||\n           Kind == DeclarationName::CXXLiteralOperatorName ||\n           Kind == DeclarationName::CXXDeductionGuideName);\n    return (IdentifierInfo *)Data;\n  }\n\n  Selector getSelector() const {\n    assert(Kind == DeclarationName::ObjCZeroArgSelector ||\n           Kind == DeclarationName::ObjCOneArgSelector ||\n           Kind == DeclarationName::ObjCMultiArgSelector);\n    return Selector(Data);\n  }\n\n  OverloadedOperatorKind getOperatorKind() const {\n    assert(Kind == DeclarationName::CXXOperatorName);\n    return (OverloadedOperatorKind)Data;\n  }\n\n  /// Compute a fingerprint of this key for use in on-disk hash table.\n  unsigned getHash() const;\n\n  friend bool operator==(const DeclarationNameKey &A,\n                         const DeclarationNameKey &B) {\n    return A.Kind == B.Kind && A.Data == B.Data;\n  }\n};\n\n/// @}\n\n} // namespace serialization\n} // namespace clang\n\nnamespace llvm {\n\ntemplate <> struct DenseMapInfo<clang::serialization::DeclarationNameKey> {\n  static clang::serialization::DeclarationNameKey getEmptyKey() {\n    return clang::serialization::DeclarationNameKey(-1, 1);\n  }\n\n  static clang::serialization::DeclarationNameKey getTombstoneKey() {\n    return clang::serialization::DeclarationNameKey(-1, 2);\n  }\n\n  static unsigned\n  getHashValue(const clang::serialization::DeclarationNameKey &Key) {\n    return Key.getHash();\n  }\n\n  static bool isEqual(const clang::serialization::DeclarationNameKey &L,\n                      const clang::serialization::DeclarationNameKey &R) {\n    return L == R;\n  }\n};\n\n} // namespace llvm\n\n#endif // LLVM_CLANG_SERIALIZATION_ASTBITCODES_H\n"}, "93": {"id": 93, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ModuleFileExtension.h", "content": "//===-- ModuleFileExtension.h - Module File Extensions ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SERIALIZATION_MODULEFILEEXTENSION_H\n#define LLVM_CLANG_SERIALIZATION_MODULEFILEEXTENSION_H\n\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/Support/ExtensibleRTTI.h\"\n#include <memory>\n#include <string>\n\nnamespace llvm {\nclass BitstreamCursor;\nclass BitstreamWriter;\nclass hash_code;\nclass raw_ostream;\n}\n\nnamespace clang {\n\nclass ASTReader;\nclass ASTWriter;\nclass Sema;\n\nnamespace serialization {\n  class ModuleFile;\n} // end namespace serialization\n\n/// Metadata for a module file extension.\nstruct ModuleFileExtensionMetadata {\n  /// The name used to identify this particular extension block within\n  /// the resulting module file. It should be unique to the particular\n  /// extension, because this name will be used to match the name of\n  /// an extension block to the appropriate reader.\n  std::string BlockName;\n\n  /// The major version of the extension data.\n  unsigned MajorVersion;\n\n  /// The minor version of the extension data.\n  unsigned MinorVersion;\n\n  /// A string containing additional user information that will be\n  /// stored with the metadata.\n  std::string UserInfo;\n};\n\nclass ModuleFileExtensionReader;\nclass ModuleFileExtensionWriter;\n\n/// An abstract superclass that describes a custom extension to the\n/// module/precompiled header file format.\n///\n/// A module file extension can introduce additional information into\n/// compiled module files (.pcm) and precompiled headers (.pch) via a\n/// custom writer that can then be accessed via a custom reader when\n/// the module file or precompiled header is loaded.\n///\n/// Subclasses must use LLVM RTTI for open class hierarchies.\nclass ModuleFileExtension\n    : public llvm::RTTIExtends<ModuleFileExtension, llvm::RTTIRoot> {\npublic:\n  /// Discriminator for LLVM RTTI.\n  static char ID;\n\n  virtual ~ModuleFileExtension();\n\n  /// Retrieves the metadata for this module file extension.\n  virtual ModuleFileExtensionMetadata getExtensionMetadata() const = 0;\n\n  /// Hash information about the presence of this extension into the\n  /// module hash code.\n  ///\n  /// The module hash code is used to distinguish different variants\n  /// of a module that are incompatible. If the presence, absence, or\n  /// version of the module file extension should force the creation\n  /// of a separate set of module files, override this method to\n  /// combine that distinguishing information into the module hash\n  /// code.\n  ///\n  /// The default implementation of this function simply returns the\n  /// hash code as given, so the presence/absence of this extension\n  /// does not distinguish module files.\n  virtual llvm::hash_code hashExtension(llvm::hash_code c) const;\n\n  /// Create a new module file extension writer, which will be\n  /// responsible for writing the extension contents into a particular\n  /// module file.\n  virtual std::unique_ptr<ModuleFileExtensionWriter>\n  createExtensionWriter(ASTWriter &Writer) = 0;\n\n  /// Create a new module file extension reader, given the\n  /// metadata read from the block and the cursor into the extension\n  /// block.\n  ///\n  /// May return null to indicate that an extension block with the\n  /// given metadata cannot be read.\n  virtual std::unique_ptr<ModuleFileExtensionReader>\n  createExtensionReader(const ModuleFileExtensionMetadata &Metadata,\n                        ASTReader &Reader, serialization::ModuleFile &Mod,\n                        const llvm::BitstreamCursor &Stream) = 0;\n};\n\n/// Abstract base class that writes a module file extension block into\n/// a module file.\nclass ModuleFileExtensionWriter {\n  ModuleFileExtension *Extension;\n\nprotected:\n  ModuleFileExtensionWriter(ModuleFileExtension *Extension)\n    : Extension(Extension) { }\n\npublic:\n  virtual ~ModuleFileExtensionWriter();\n\n  /// Retrieve the module file extension with which this writer is\n  /// associated.\n  ModuleFileExtension *getExtension() const { return Extension; }\n\n  /// Write the contents of the extension block into the given bitstream.\n  ///\n  /// Responsible for writing the contents of the extension into the\n  /// given stream. All of the contents should be written into custom\n  /// records with IDs >= FIRST_EXTENSION_RECORD_ID.\n  virtual void writeExtensionContents(Sema &SemaRef,\n                                      llvm::BitstreamWriter &Stream) = 0;\n};\n\n/// Abstract base class that reads a module file extension block from\n/// a module file.\n///\n/// Subclasses\nclass ModuleFileExtensionReader {\n  ModuleFileExtension *Extension;\n\nprotected:\n  ModuleFileExtensionReader(ModuleFileExtension *Extension)\n    : Extension(Extension) { }\n\npublic:\n  /// Retrieve the module file extension with which this reader is\n  /// associated.\n  ModuleFileExtension *getExtension() const { return Extension; }\n\n  virtual ~ModuleFileExtensionReader();\n};\n\n} // end namespace clang\n\n#endif // LLVM_CLANG_FRONTEND_MODULEFILEEXTENSION_H\n"}, "94": {"id": 94, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/PCHContainerOperations.h", "content": "//===--- Serialization/PCHContainerOperations.h - PCH Containers --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SERIALIZATION_PCHCONTAINEROPERATIONS_H\n#define LLVM_CLANG_SERIALIZATION_PCHCONTAINEROPERATIONS_H\n\n#include \"clang/Basic/Module.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include <memory>\n\nnamespace llvm {\nclass raw_pwrite_stream;\n}\n\nnamespace clang {\n\nclass ASTConsumer;\nclass CodeGenOptions;\nclass DiagnosticsEngine;\nclass CompilerInstance;\n\nstruct PCHBuffer {\n  ASTFileSignature Signature;\n  llvm::SmallVector<char, 0> Data;\n  bool IsComplete;\n};\n\n/// This abstract interface provides operations for creating\n/// containers for serialized ASTs (precompiled headers and clang\n/// modules).\nclass PCHContainerWriter {\npublic:\n  virtual ~PCHContainerWriter() = 0;\n  virtual llvm::StringRef getFormat() const = 0;\n\n  /// Return an ASTConsumer that can be chained with a\n  /// PCHGenerator that produces a wrapper file format containing a\n  /// serialized AST bitstream.\n  virtual std::unique_ptr<ASTConsumer>\n  CreatePCHContainerGenerator(CompilerInstance &CI,\n                              const std::string &MainFileName,\n                              const std::string &OutputFileName,\n                              std::unique_ptr<llvm::raw_pwrite_stream> OS,\n                              std::shared_ptr<PCHBuffer> Buffer) const = 0;\n};\n\n/// This abstract interface provides operations for unwrapping\n/// containers for serialized ASTs (precompiled headers and clang\n/// modules).\nclass PCHContainerReader {\npublic:\n  virtual ~PCHContainerReader() = 0;\n  /// Equivalent to the format passed to -fmodule-format=\n  virtual llvm::StringRef getFormat() const = 0;\n\n  /// Returns the serialized AST inside the PCH container Buffer.\n  virtual llvm::StringRef ExtractPCH(llvm::MemoryBufferRef Buffer) const = 0;\n};\n\n/// Implements write operations for a raw pass-through PCH container.\nclass RawPCHContainerWriter : public PCHContainerWriter {\n  llvm::StringRef getFormat() const override { return \"raw\"; }\n\n  /// Return an ASTConsumer that can be chained with a\n  /// PCHGenerator that writes the module to a flat file.\n  std::unique_ptr<ASTConsumer>\n  CreatePCHContainerGenerator(CompilerInstance &CI,\n                              const std::string &MainFileName,\n                              const std::string &OutputFileName,\n                              std::unique_ptr<llvm::raw_pwrite_stream> OS,\n                              std::shared_ptr<PCHBuffer> Buffer) const override;\n};\n\n/// Implements read operations for a raw pass-through PCH container.\nclass RawPCHContainerReader : public PCHContainerReader {\n  llvm::StringRef getFormat() const override { return \"raw\"; }\n\n  /// Simply returns the buffer contained in Buffer.\n  llvm::StringRef ExtractPCH(llvm::MemoryBufferRef Buffer) const override;\n};\n\n/// A registry of PCHContainerWriter and -Reader objects for different formats.\nclass PCHContainerOperations {\n  llvm::StringMap<std::unique_ptr<PCHContainerWriter>> Writers;\n  llvm::StringMap<std::unique_ptr<PCHContainerReader>> Readers;\npublic:\n  /// Automatically registers a RawPCHContainerWriter and\n  /// RawPCHContainerReader.\n  PCHContainerOperations();\n  void registerWriter(std::unique_ptr<PCHContainerWriter> Writer) {\n    Writers[Writer->getFormat()] = std::move(Writer);\n  }\n  void registerReader(std::unique_ptr<PCHContainerReader> Reader) {\n    Readers[Reader->getFormat()] = std::move(Reader);\n  }\n  const PCHContainerWriter *getWriterOrNull(llvm::StringRef Format) {\n    return Writers[Format].get();\n  }\n  const PCHContainerReader *getReaderOrNull(llvm::StringRef Format) {\n    return Readers[Format].get();\n  }\n  const PCHContainerReader &getRawReader() {\n    return *getReaderOrNull(\"raw\");\n  }\n};\n\n}\n\n#endif\n"}, "95": {"id": 95, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/AnalyzerOptions.h", "content": "//===- AnalyzerOptions.h - Analysis Engine Options --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This header defines various options for the static analyzer that are set\n// by the frontend and are consulted throughout the analyzer.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_ANALYZEROPTIONS_H\n#define LLVM_CLANG_STATICANALYZER_CORE_ANALYZEROPTIONS_H\n\n#include \"clang/Analysis/PathDiagnostic.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/StringSwitch.h\"\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace clang {\n\nnamespace ento {\n\nclass CheckerBase;\n\n} // namespace ento\n\n/// Analysis - Set of available source code analyses.\nenum Analyses {\n#define ANALYSIS(NAME, CMDFLAG, DESC, SCOPE) NAME,\n#include \"clang/StaticAnalyzer/Core/Analyses.def\"\nNumAnalyses\n};\n\n/// AnalysisStores - Set of available analysis store models.\nenum AnalysisStores {\n#define ANALYSIS_STORE(NAME, CMDFLAG, DESC, CREATFN) NAME##Model,\n#include \"clang/StaticAnalyzer/Core/Analyses.def\"\nNumStores\n};\n\n/// AnalysisConstraints - Set of available constraint models.\nenum AnalysisConstraints {\n#define ANALYSIS_CONSTRAINTS(NAME, CMDFLAG, DESC, CREATFN) NAME##Model,\n#include \"clang/StaticAnalyzer/Core/Analyses.def\"\nNumConstraints\n};\n\n/// AnalysisDiagClients - Set of available diagnostic clients for rendering\n///  analysis results.\nenum AnalysisDiagClients {\n#define ANALYSIS_DIAGNOSTICS(NAME, CMDFLAG, DESC, CREATFN) PD_##NAME,\n#include \"clang/StaticAnalyzer/Core/Analyses.def\"\nPD_NONE,\nNUM_ANALYSIS_DIAG_CLIENTS\n};\n\n/// AnalysisPurgeModes - Set of available strategies for dead symbol removal.\nenum AnalysisPurgeMode {\n#define ANALYSIS_PURGE(NAME, CMDFLAG, DESC) NAME,\n#include \"clang/StaticAnalyzer/Core/Analyses.def\"\nNumPurgeModes\n};\n\n/// AnalysisInlineFunctionSelection - Set of inlining function selection heuristics.\nenum AnalysisInliningMode {\n#define ANALYSIS_INLINING_MODE(NAME, CMDFLAG, DESC) NAME,\n#include \"clang/StaticAnalyzer/Core/Analyses.def\"\nNumInliningModes\n};\n\n/// Describes the different kinds of C++ member functions which can be\n/// considered for inlining by the analyzer.\n///\n/// These options are cumulative; enabling one kind of member function will\n/// enable all kinds with lower enum values.\nenum CXXInlineableMemberKind {\n  // Uninitialized = 0,\n\n  /// A dummy mode in which no C++ inlining is enabled.\n  CIMK_None,\n\n  /// Refers to regular member function and operator calls.\n  CIMK_MemberFunctions,\n\n  /// Refers to constructors (implicit or explicit).\n  ///\n  /// Note that a constructor will not be inlined if the corresponding\n  /// destructor is non-trivial.\n  CIMK_Constructors,\n\n  /// Refers to destructors (implicit or explicit).\n  CIMK_Destructors\n};\n\n/// Describes the different modes of inter-procedural analysis.\nenum IPAKind {\n  /// Perform only intra-procedural analysis.\n  IPAK_None = 1,\n\n  /// Inline C functions and blocks when their definitions are available.\n  IPAK_BasicInlining = 2,\n\n  /// Inline callees(C, C++, ObjC) when their definitions are available.\n  IPAK_Inlining = 3,\n\n  /// Enable inlining of dynamically dispatched methods.\n  IPAK_DynamicDispatch = 4,\n\n  /// Enable inlining of dynamically dispatched methods, bifurcate paths when\n  /// exact type info is unavailable.\n  IPAK_DynamicDispatchBifurcate = 5\n};\n\nenum class ExplorationStrategyKind {\n  DFS,\n  BFS,\n  UnexploredFirst,\n  UnexploredFirstQueue,\n  UnexploredFirstLocationQueue,\n  BFSBlockDFSContents,\n};\n\n/// Describes the kinds for high-level analyzer mode.\nenum UserModeKind {\n  /// Perform shallow but fast analyzes.\n  UMK_Shallow = 1,\n\n  /// Perform deep analyzes.\n  UMK_Deep = 2\n};\n\n/// Stores options for the analyzer from the command line.\n///\n/// Some options are frontend flags (e.g.: -analyzer-output), but some are\n/// analyzer configuration options, which are preceded by -analyzer-config\n/// (e.g.: -analyzer-config notes-as-events=true).\n///\n/// If you'd like to add a new frontend flag, add it to\n/// include/clang/Driver/CC1Options.td, add a new field to store the value of\n/// that flag in this class, and initialize it in\n/// lib/Frontend/CompilerInvocation.cpp.\n///\n/// If you'd like to add a new non-checker configuration, register it in\n/// include/clang/StaticAnalyzer/Core/AnalyzerOptions.def, and refer to the\n/// top of the file for documentation.\n///\n/// If you'd like to add a new checker option, call getChecker*Option()\n/// whenever.\n///\n/// Some of the options are controlled by raw frontend flags for no good reason,\n/// and should be eventually converted into -analyzer-config flags. New analyzer\n/// options should not be implemented as frontend flags. Frontend flags still\n/// make sense for things that do not affect the actual analysis.\nclass AnalyzerOptions : public RefCountedBase<AnalyzerOptions> {\npublic:\n  using ConfigTable = llvm::StringMap<std::string>;\n\n  /// Retrieves the list of checkers generated from Checkers.td. This doesn't\n  /// contain statically linked but non-generated checkers and plugin checkers!\n  static std::vector<StringRef>\n  getRegisteredCheckers(bool IncludeExperimental = false);\n\n  /// Retrieves the list of packages generated from Checkers.td. This doesn't\n  /// contain statically linked but non-generated packages and plugin packages!\n  static std::vector<StringRef>\n  getRegisteredPackages(bool IncludeExperimental = false);\n\n  /// Convenience function for printing options or checkers and their\n  /// description in a formatted manner. If \\p MinLineWidth is set to 0, no line\n  /// breaks are introduced for the description.\n  ///\n  /// Format, depending whether the option name's length is less than\n  /// \\p EntryWidth:\n  ///\n  ///   <padding>EntryName<padding>Description\n  ///   <---------padding--------->Description\n  ///   <---------padding--------->Description\n  ///\n  ///   <padding>VeryVeryLongEntryName\n  ///   <---------padding--------->Description\n  ///   <---------padding--------->Description\n  ///   ^~~~~~~~~InitialPad\n  ///            ^~~~~~~~~~~~~~~~~~EntryWidth\n  ///   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~MinLineWidth\n  static void printFormattedEntry(llvm::raw_ostream &Out,\n                                  std::pair<StringRef, StringRef> EntryDescPair,\n                                  size_t InitialPad, size_t EntryWidth,\n                                  size_t MinLineWidth = 0);\n\n  /// Pairs of checker/package name and enable/disable.\n  std::vector<std::pair<std::string, bool>> CheckersAndPackages;\n\n  /// Vector of checker/package names which will not emit warnings.\n  std::vector<std::string> SilencedCheckersAndPackages;\n\n  /// A key-value table of use-specified configuration values.\n  // TODO: This shouldn't be public.\n  ConfigTable Config;\n  AnalysisStores AnalysisStoreOpt = RegionStoreModel;\n  AnalysisConstraints AnalysisConstraintsOpt = RangeConstraintsModel;\n  AnalysisDiagClients AnalysisDiagOpt = PD_HTML;\n  AnalysisPurgeMode AnalysisPurgeOpt = PurgeStmt;\n\n  std::string AnalyzeSpecificFunction;\n\n  /// File path to which the exploded graph should be dumped.\n  std::string DumpExplodedGraphTo;\n\n  /// Store full compiler invocation for reproducible instructions in the\n  /// generated report.\n  std::string FullCompilerInvocation;\n\n  /// The maximum number of times the analyzer visits a block.\n  unsigned maxBlockVisitOnPath;\n\n  /// Disable all analyzer checkers.\n  ///\n  /// This flag allows one to disable analyzer checkers on the code processed by\n  /// the given analysis consumer. Note, the code will get parsed and the\n  /// command-line options will get checked.\n  unsigned DisableAllCheckers : 1;\n\n  unsigned ShowCheckerHelp : 1;\n  unsigned ShowCheckerHelpAlpha : 1;\n  unsigned ShowCheckerHelpDeveloper : 1;\n\n  unsigned ShowCheckerOptionList : 1;\n  unsigned ShowCheckerOptionAlphaList : 1;\n  unsigned ShowCheckerOptionDeveloperList : 1;\n\n  unsigned ShowEnabledCheckerList : 1;\n  unsigned ShowConfigOptionsList : 1;\n  unsigned ShouldEmitErrorsOnInvalidConfigValue : 1;\n  unsigned AnalyzeAll : 1;\n  unsigned AnalyzerDisplayProgress : 1;\n  unsigned AnalyzeNestedBlocks : 1;\n\n  unsigned eagerlyAssumeBinOpBifurcation : 1;\n\n  unsigned TrimGraph : 1;\n  unsigned visualizeExplodedGraphWithGraphViz : 1;\n  unsigned UnoptimizedCFG : 1;\n  unsigned PrintStats : 1;\n\n  /// Do not re-analyze paths leading to exhausted nodes with a different\n  /// strategy. We get better code coverage when retry is enabled.\n  unsigned NoRetryExhausted : 1;\n\n  /// Emit analyzer warnings as errors.\n  bool AnalyzerWerror : 1;\n\n  /// The inlining stack depth limit.\n  unsigned InlineMaxStackDepth;\n\n  /// The mode of function selection used during inlining.\n  AnalysisInliningMode InliningMode = NoRedundancy;\n\n  // Create a field for each -analyzer-config option.\n#define ANALYZER_OPTION_DEPENDS_ON_USER_MODE(TYPE, NAME, CMDFLAG, DESC,        \\\n                                             SHALLOW_VAL, DEEP_VAL)            \\\n  ANALYZER_OPTION(TYPE, NAME, CMDFLAG, DESC, SHALLOW_VAL)\n\n#define ANALYZER_OPTION(TYPE, NAME, CMDFLAG, DESC, DEFAULT_VAL)                \\\n  TYPE NAME;\n\n#include \"clang/StaticAnalyzer/Core/AnalyzerOptions.def\"\n#undef ANALYZER_OPTION\n#undef ANALYZER_OPTION_DEPENDS_ON_USER_MODE\n\n  // Create an array of all -analyzer-config command line options. Sort it in\n  // the constructor.\n  std::vector<llvm::StringLiteral> AnalyzerConfigCmdFlags = {\n#define ANALYZER_OPTION_DEPENDS_ON_USER_MODE(TYPE, NAME, CMDFLAG, DESC,        \\\n                                             SHALLOW_VAL, DEEP_VAL)            \\\n  ANALYZER_OPTION(TYPE, NAME, CMDFLAG, DESC, SHALLOW_VAL)\n\n#define ANALYZER_OPTION(TYPE, NAME, CMDFLAG, DESC, DEFAULT_VAL)                \\\n  llvm::StringLiteral(CMDFLAG),\n\n#include \"clang/StaticAnalyzer/Core/AnalyzerOptions.def\"\n#undef ANALYZER_OPTION\n#undef ANALYZER_OPTION_DEPENDS_ON_USER_MODE\n  };\n\n  bool isUnknownAnalyzerConfig(StringRef Name) const {\n    assert(llvm::is_sorted(AnalyzerConfigCmdFlags));\n\n    return !std::binary_search(AnalyzerConfigCmdFlags.begin(),\n                               AnalyzerConfigCmdFlags.end(), Name);\n  }\n\n  AnalyzerOptions()\n      : DisableAllCheckers(false), ShowCheckerHelp(false),\n        ShowCheckerHelpAlpha(false), ShowCheckerHelpDeveloper(false),\n        ShowCheckerOptionList(false), ShowCheckerOptionAlphaList(false),\n        ShowCheckerOptionDeveloperList(false), ShowEnabledCheckerList(false),\n        ShowConfigOptionsList(false), AnalyzeAll(false),\n        AnalyzerDisplayProgress(false), AnalyzeNestedBlocks(false),\n        eagerlyAssumeBinOpBifurcation(false), TrimGraph(false),\n        visualizeExplodedGraphWithGraphViz(false), UnoptimizedCFG(false),\n        PrintStats(false), NoRetryExhausted(false), AnalyzerWerror(false) {\n    llvm::sort(AnalyzerConfigCmdFlags);\n  }\n\n  /// Interprets an option's string value as a boolean. The \"true\" string is\n  /// interpreted as true and the \"false\" string is interpreted as false.\n  ///\n  /// If an option value is not provided, returns the given \\p DefaultVal.\n  /// @param [in] CheckerName The *full name* of the checker. One may retrieve\n  /// this from the checker object's field \\c Name, or through \\c\n  /// CheckerManager::getCurrentCheckerName within the checker's registry\n  /// function.\n  /// Checker options are retrieved in the following format:\n  /// `-analyzer-config CheckerName:OptionName=Value.\n  /// @param [in] OptionName Name for option to retrieve.\n  /// @param [in] SearchInParents If set to true and the searched option was not\n  /// specified for the given checker the options for the parent packages will\n  /// be searched as well. The inner packages take precedence over the outer\n  /// ones.\n  bool getCheckerBooleanOption(StringRef CheckerName, StringRef OptionName,\n                               bool SearchInParents = false) const;\n\n  bool getCheckerBooleanOption(const ento::CheckerBase *C, StringRef OptionName,\n                               bool SearchInParents = false) const;\n\n  /// Interprets an option's string value as an integer value.\n  ///\n  /// If an option value is not provided, returns the given \\p DefaultVal.\n  /// @param [in] CheckerName The *full name* of the checker. One may retrieve\n  /// this from the checker object's field \\c Name, or through \\c\n  /// CheckerManager::getCurrentCheckerName within the checker's registry\n  /// function.\n  /// Checker options are retrieved in the following format:\n  /// `-analyzer-config CheckerName:OptionName=Value.\n  /// @param [in] OptionName Name for option to retrieve.\n  /// @param [in] SearchInParents If set to true and the searched option was not\n  /// specified for the given checker the options for the parent packages will\n  /// be searched as well. The inner packages take precedence over the outer\n  /// ones.\n  int getCheckerIntegerOption(StringRef CheckerName, StringRef OptionName,\n                              bool SearchInParents = false) const;\n\n  int getCheckerIntegerOption(const ento::CheckerBase *C, StringRef OptionName,\n                              bool SearchInParents = false) const;\n\n  /// Query an option's string value.\n  ///\n  /// If an option value is not provided, returns the given \\p DefaultVal.\n  /// @param [in] CheckerName The *full name* of the checker. One may retrieve\n  /// this from the checker object's field \\c Name, or through \\c\n  /// CheckerManager::getCurrentCheckerName within the checker's registry\n  /// function.\n  /// Checker options are retrieved in the following format:\n  /// `-analyzer-config CheckerName:OptionName=Value.\n  /// @param [in] OptionName Name for option to retrieve.\n  /// @param [in] SearchInParents If set to true and the searched option was not\n  /// specified for the given checker the options for the parent packages will\n  /// be searched as well. The inner packages take precedence over the outer\n  /// ones.\n  StringRef getCheckerStringOption(StringRef CheckerName, StringRef OptionName,\n                                   bool SearchInParents = false) const;\n\n  StringRef getCheckerStringOption(const ento::CheckerBase *C,\n                                   StringRef OptionName,\n                                   bool SearchInParents = false) const;\n\n  /// Retrieves and sets the UserMode. This is a high-level option,\n  /// which is used to set other low-level options. It is not accessible\n  /// outside of AnalyzerOptions.\n  UserModeKind getUserMode() const;\n\n  ExplorationStrategyKind getExplorationStrategy() const;\n\n  /// Returns the inter-procedural analysis mode.\n  IPAKind getIPAMode() const;\n\n  /// Returns the option controlling which C++ member functions will be\n  /// considered for inlining.\n  ///\n  /// This is controlled by the 'c++-inlining' config option.\n  ///\n  /// \\sa CXXMemberInliningMode\n  bool mayInlineCXXMemberFunction(CXXInlineableMemberKind K) const;\n\n  ento::PathDiagnosticConsumerOptions getDiagOpts() const {\n    return {FullCompilerInvocation,\n            ShouldDisplayMacroExpansions,\n            ShouldSerializeStats,\n            ShouldWriteStableReportFilename,\n            AnalyzerWerror,\n            ShouldApplyFixIts,\n            ShouldDisplayCheckerNameForText};\n  }\n};\n\nusing AnalyzerOptionsRef = IntrusiveRefCntPtr<AnalyzerOptions>;\n\n//===----------------------------------------------------------------------===//\n// We'll use AnalyzerOptions in the frontend, but we can't link the frontend\n// with clangStaticAnalyzerCore, because clangStaticAnalyzerCore depends on\n// clangFrontend.\n//\n// For this reason, implement some methods in this header file.\n//===----------------------------------------------------------------------===//\n\ninline UserModeKind AnalyzerOptions::getUserMode() const {\n  auto K = llvm::StringSwitch<llvm::Optional<UserModeKind>>(UserMode)\n    .Case(\"shallow\", UMK_Shallow)\n    .Case(\"deep\", UMK_Deep)\n    .Default(None);\n  assert(K.hasValue() && \"User mode is invalid.\");\n  return K.getValue();\n}\n\ninline std::vector<StringRef>\nAnalyzerOptions::getRegisteredCheckers(bool IncludeExperimental) {\n  static constexpr llvm::StringLiteral StaticAnalyzerCheckerNames[] = {\n#define GET_CHECKERS\n#define CHECKER(FULLNAME, CLASS, HELPTEXT, DOC_URI, IS_HIDDEN)                 \\\n  llvm::StringLiteral(FULLNAME),\n#include \"clang/StaticAnalyzer/Checkers/Checkers.inc\"\n#undef CHECKER\n#undef GET_CHECKERS\n  };\n  std::vector<StringRef> Checkers;\n  for (StringRef CheckerName : StaticAnalyzerCheckerNames) {\n    if (!CheckerName.startswith(\"debug.\") &&\n        (IncludeExperimental || !CheckerName.startswith(\"alpha.\")))\n      Checkers.push_back(CheckerName);\n  }\n  return Checkers;\n}\n\ninline std::vector<StringRef>\nAnalyzerOptions::getRegisteredPackages(bool IncludeExperimental) {\n  static constexpr llvm::StringLiteral StaticAnalyzerPackageNames[] = {\n#define GET_PACKAGES\n#define PACKAGE(FULLNAME) llvm::StringLiteral(FULLNAME),\n#include \"clang/StaticAnalyzer/Checkers/Checkers.inc\"\n#undef PACKAGE\n#undef GET_PACKAGES\n  };\n  std::vector<StringRef> Packages;\n  for (StringRef PackageName : StaticAnalyzerPackageNames) {\n    if (PackageName != \"debug\" &&\n        (IncludeExperimental || PackageName != \"alpha\"))\n      Packages.push_back(PackageName);\n  }\n  return Packages;\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_STATICANALYZER_CORE_ANALYZEROPTIONS_H\n"}, "96": {"id": 96, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h", "content": "//===- CompilationDatabase.h ------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file provides an interface and multiple implementations for\n//  CompilationDatabases.\n//\n//  While C++ refactoring and analysis tools are not compilers, and thus\n//  don't run as part of the build system, they need the exact information\n//  of a build in order to be able to correctly understand the C++ code of\n//  the project. This information is provided via the CompilationDatabase\n//  interface.\n//\n//  To create a CompilationDatabase from a build directory one can call\n//  CompilationDatabase::loadFromDirectory(), which deduces the correct\n//  compilation database from the root of the build tree.\n//\n//  See the concrete subclasses of CompilationDatabase for currently supported\n//  formats.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLING_COMPILATIONDATABASE_H\n#define LLVM_CLANG_TOOLING_COMPILATIONDATABASE_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/Support/VirtualFileSystem.h\"\n#include <memory>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace clang {\nnamespace tooling {\n\n/// Specifies the working directory and command of a compilation.\nstruct CompileCommand {\n  CompileCommand() = default;\n  CompileCommand(const Twine &Directory, const Twine &Filename,\n                 std::vector<std::string> CommandLine, const Twine &Output)\n      : Directory(Directory.str()), Filename(Filename.str()),\n        CommandLine(std::move(CommandLine)), Output(Output.str()) {}\n\n  /// The working directory the command was executed from.\n  std::string Directory;\n\n  /// The source file associated with the command.\n  std::string Filename;\n\n  /// The command line that was executed.\n  std::vector<std::string> CommandLine;\n\n  /// The output file associated with the command.\n  std::string Output;\n\n  /// If this compile command was guessed rather than read from an authoritative\n  /// source, a short human-readable explanation.\n  /// e.g. \"inferred from foo/bar.h\".\n  std::string Heuristic;\n\n  friend bool operator==(const CompileCommand &LHS, const CompileCommand &RHS) {\n    return LHS.Directory == RHS.Directory && LHS.Filename == RHS.Filename &&\n           LHS.CommandLine == RHS.CommandLine && LHS.Output == RHS.Output &&\n           LHS.Heuristic == RHS.Heuristic;\n  }\n\n  friend bool operator!=(const CompileCommand &LHS, const CompileCommand &RHS) {\n    return !(LHS == RHS);\n  }\n};\n\n/// Interface for compilation databases.\n///\n/// A compilation database allows the user to retrieve compile command lines\n/// for the files in a project.\n///\n/// Many implementations are enumerable, allowing all command lines to be\n/// retrieved. These can be used to run clang tools over a subset of the files\n/// in a project.\nclass CompilationDatabase {\npublic:\n  virtual ~CompilationDatabase();\n\n  /// Loads a compilation database from a build directory.\n  ///\n  /// Looks at the specified 'BuildDirectory' and creates a compilation database\n  /// that allows to query compile commands for source files in the\n  /// corresponding source tree.\n  ///\n  /// Returns NULL and sets ErrorMessage if we were not able to build up a\n  /// compilation database for the build directory.\n  ///\n  /// FIXME: Currently only supports JSON compilation databases, which\n  /// are named 'compile_commands.json' in the given directory. Extend this\n  /// for other build types (like ninja build files).\n  static std::unique_ptr<CompilationDatabase>\n  loadFromDirectory(StringRef BuildDirectory, std::string &ErrorMessage);\n\n  /// Tries to detect a compilation database location and load it.\n  ///\n  /// Looks for a compilation database in all parent paths of file 'SourceFile'\n  /// by calling loadFromDirectory.\n  static std::unique_ptr<CompilationDatabase>\n  autoDetectFromSource(StringRef SourceFile, std::string &ErrorMessage);\n\n  /// Tries to detect a compilation database location and load it.\n  ///\n  /// Looks for a compilation database in directory 'SourceDir' and all\n  /// its parent paths by calling loadFromDirectory.\n  static std::unique_ptr<CompilationDatabase>\n  autoDetectFromDirectory(StringRef SourceDir, std::string &ErrorMessage);\n\n  /// Returns all compile commands in which the specified file was\n  /// compiled.\n  ///\n  /// This includes compile commands that span multiple source files.\n  /// For example, consider a project with the following compilations:\n  /// $ clang++ -o test a.cc b.cc t.cc\n  /// $ clang++ -o production a.cc b.cc -DPRODUCTION\n  /// A compilation database representing the project would return both command\n  /// lines for a.cc and b.cc and only the first command line for t.cc.\n  virtual std::vector<CompileCommand> getCompileCommands(\n      StringRef FilePath) const = 0;\n\n  /// Returns the list of all files available in the compilation database.\n  ///\n  /// By default, returns nothing. Implementations should override this if they\n  /// can enumerate their source files.\n  virtual std::vector<std::string> getAllFiles() const { return {}; }\n\n  /// Returns all compile commands for all the files in the compilation\n  /// database.\n  ///\n  /// FIXME: Add a layer in Tooling that provides an interface to run a tool\n  /// over all files in a compilation database. Not all build systems have the\n  /// ability to provide a feasible implementation for \\c getAllCompileCommands.\n  ///\n  /// By default, this is implemented in terms of getAllFiles() and\n  /// getCompileCommands(). Subclasses may override this for efficiency.\n  virtual std::vector<CompileCommand> getAllCompileCommands() const;\n};\n\n/// A compilation database that returns a single compile command line.\n///\n/// Useful when we want a tool to behave more like a compiler invocation.\n/// This compilation database is not enumerable: getAllFiles() returns {}.\nclass FixedCompilationDatabase : public CompilationDatabase {\npublic:\n  /// Creates a FixedCompilationDatabase from the arguments after \"--\".\n  ///\n  /// Parses the given command line for \"--\". If \"--\" is found, the rest of\n  /// the arguments will make up the command line in the returned\n  /// FixedCompilationDatabase.\n  /// The arguments after \"--\" must not include positional parameters or the\n  /// argv[0] of the tool. Those will be added by the FixedCompilationDatabase\n  /// when a CompileCommand is requested. The argv[0] of the returned command\n  /// line will be \"clang-tool\".\n  ///\n  /// Returns NULL in case \"--\" is not found.\n  ///\n  /// The argument list is meant to be compatible with normal llvm command line\n  /// parsing in main methods.\n  /// int main(int argc, char **argv) {\n  ///   std::unique_ptr<FixedCompilationDatabase> Compilations(\n  ///     FixedCompilationDatabase::loadFromCommandLine(argc, argv));\n  ///   cl::ParseCommandLineOptions(argc, argv);\n  ///   ...\n  /// }\n  ///\n  /// \\param Argc The number of command line arguments - will be changed to\n  /// the number of arguments before \"--\", if \"--\" was found in the argument\n  /// list.\n  /// \\param Argv Points to the command line arguments.\n  /// \\param ErrorMsg Contains error text if the function returns null pointer.\n  /// \\param Directory The base directory used in the FixedCompilationDatabase.\n  static std::unique_ptr<FixedCompilationDatabase>\n  loadFromCommandLine(int &Argc, const char *const *Argv, std::string &ErrorMsg,\n                      const Twine &Directory = \".\");\n\n  /// Reads flags from the given file, one-per-line.\n  /// Returns nullptr and sets ErrorMessage if we can't read the file.\n  static std::unique_ptr<FixedCompilationDatabase>\n  loadFromFile(StringRef Path, std::string &ErrorMsg);\n\n  /// Reads flags from the given buffer, one-per-line.\n  /// Directory is the command CWD, typically the parent of compile_flags.txt.\n  static std::unique_ptr<FixedCompilationDatabase>\n  loadFromBuffer(StringRef Directory, StringRef Data, std::string &ErrorMsg);\n\n  /// Constructs a compilation data base from a specified directory\n  /// and command line.\n  FixedCompilationDatabase(const Twine &Directory,\n                           ArrayRef<std::string> CommandLine);\n\n  /// Returns the given compile command.\n  ///\n  /// Will always return a vector with one entry that contains the directory\n  /// and command line specified at construction with \"clang-tool\" as argv[0]\n  /// and 'FilePath' as positional argument.\n  std::vector<CompileCommand>\n  getCompileCommands(StringRef FilePath) const override;\n\nprivate:\n  /// This is built up to contain a single entry vector to be returned from\n  /// getCompileCommands after adding the positional argument.\n  std::vector<CompileCommand> CompileCommands;\n};\n\n/// Transforms a compile command so that it applies the same configuration to\n/// a different file. Most args are left intact, but tweaks may be needed\n/// to certain flags (-x, -std etc).\ntooling::CompileCommand transferCompileCommand(tooling::CompileCommand,\n                                               StringRef Filename);\n\n/// Returns a wrapped CompilationDatabase that defers to the provided one,\n/// but getCompileCommands() will infer commands for unknown files.\n/// The return value of getAllFiles() or getAllCompileCommands() is unchanged.\n/// See InterpolatingCompilationDatabase.cpp for details on heuristics.\nstd::unique_ptr<CompilationDatabase>\n    inferMissingCompileCommands(std::unique_ptr<CompilationDatabase>);\n\n/// Returns a wrapped CompilationDatabase that will add -target and -mode flags\n/// to commandline when they can be deduced from argv[0] of commandline returned\n/// by underlying database.\nstd::unique_ptr<CompilationDatabase>\ninferTargetAndDriverMode(std::unique_ptr<CompilationDatabase> Base);\n\n/// Returns a wrapped CompilationDatabase that will expand all rsp(response)\n/// files on commandline returned by underlying database.\nstd::unique_ptr<CompilationDatabase>\nexpandResponseFiles(std::unique_ptr<CompilationDatabase> Base,\n                    llvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem> FS);\n\n} // namespace tooling\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLING_COMPILATIONDATABASE_H\n"}, "98": {"id": 98, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Inclusions/HeaderIncludes.h", "content": "//===--- HeaderIncludes.h - Insert/Delete #includes for C++ code--*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLING_INCLUSIONS_HEADERINCLUDES_H\n#define LLVM_CLANG_TOOLING_INCLUSIONS_HEADERINCLUDES_H\n\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Tooling/Core/Replacement.h\"\n#include \"clang/Tooling/Inclusions/IncludeStyle.h\"\n#include \"llvm/Support/Path.h\"\n#include \"llvm/Support/Regex.h\"\n#include <unordered_map>\n\nnamespace clang {\nnamespace tooling {\n\n/// This class manages priorities of C++ #include categories and calculates\n/// priorities for headers.\n/// FIXME(ioeric): move this class into implementation file when clang-format's\n/// include sorting functions are also moved here.\nclass IncludeCategoryManager {\npublic:\n  IncludeCategoryManager(const IncludeStyle &Style, StringRef FileName);\n\n  /// Returns the priority of the category which \\p IncludeName belongs to.\n  /// If \\p CheckMainHeader is true and \\p IncludeName is a main header, returns\n  /// 0. Otherwise, returns the priority of the matching category or INT_MAX.\n  /// NOTE: this API is not thread-safe!\n  int getIncludePriority(StringRef IncludeName, bool CheckMainHeader) const;\n  int getSortIncludePriority(StringRef IncludeName, bool CheckMainHeader) const;\n\nprivate:\n  bool isMainHeader(StringRef IncludeName) const;\n\n  const IncludeStyle Style;\n  bool IsMainFile;\n  std::string FileName;\n  SmallVector<llvm::Regex, 4> CategoryRegexs;\n};\n\n/// Generates replacements for inserting or deleting #include directives in a\n/// file.\nclass HeaderIncludes {\npublic:\n  HeaderIncludes(llvm::StringRef FileName, llvm::StringRef Code,\n                 const IncludeStyle &Style);\n\n  /// Inserts an #include directive of \\p Header into the code. If \\p IsAngled\n  /// is true, \\p Header will be quoted with <> in the directive; otherwise, it\n  /// will be quoted with \"\".\n  ///\n  /// When searching for points to insert new header, this ignores #include's\n  /// after the #include block(s) in the beginning of a file to avoid inserting\n  /// headers into code sections where new #include's should not be added by\n  /// default. These code sections include:\n  ///   - raw string literals (containing #include).\n  ///   - #if blocks.\n  ///   - Special #include's among declarations (e.g. functions).\n  ///\n  /// Returns a replacement that inserts the new header into a suitable #include\n  /// block of the same category. This respects the order of the existing\n  /// #includes in the block; if the existing #includes are not already sorted,\n  /// this will simply insert the #include in front of the first #include of the\n  /// same category in the code that should be sorted after \\p IncludeName. If\n  /// \\p IncludeName already exists (with exactly the same spelling), this\n  /// returns None.\n  llvm::Optional<tooling::Replacement> insert(llvm::StringRef Header,\n                                              bool IsAngled) const;\n\n  /// Removes all existing #includes of \\p Header quoted with <> if \\p IsAngled\n  /// is true or \"\" if \\p IsAngled is false.\n  /// This doesn't resolve the header file path; it only deletes #includes with\n  /// exactly the same spelling.\n  tooling::Replacements remove(llvm::StringRef Header, bool IsAngled) const;\n\nprivate:\n  struct Include {\n    Include(StringRef Name, tooling::Range R) : Name(Name), R(R) {}\n\n    // An include header quoted with either <> or \"\".\n    std::string Name;\n    // The range of the whole line of include directive including any eading\n    // whitespaces and trailing comment.\n    tooling::Range R;\n  };\n\n  void addExistingInclude(Include IncludeToAdd, unsigned NextLineOffset);\n\n  std::string FileName;\n  std::string Code;\n\n  // Map from include name (quotation trimmed) to a list of existing includes\n  // (in case there are more than one) with the name in the current file. <x>\n  // and \"x\" will be treated as the same header when deleting #includes.\n  llvm::StringMap<llvm::SmallVector<Include, 1>> ExistingIncludes;\n\n  /// Map from priorities of #include categories to all #includes in the same\n  /// category. This is used to find #includes of the same category when\n  /// inserting new #includes. #includes in the same categories are sorted in\n  /// in the order they appear in the source file.\n  /// See comment for \"FormatStyle::IncludeCategories\" for details about include\n  /// priorities.\n  std::unordered_map<int, llvm::SmallVector<const Include *, 8>>\n      IncludesByPriority;\n\n  int FirstIncludeOffset;\n  // All new headers should be inserted after this offset (e.g. after header\n  // guards, file comment).\n  unsigned MinInsertOffset;\n  // Max insertion offset in the original code. For example, we want to avoid\n  // inserting new #includes into the actual code section (e.g. after a\n  // declaration).\n  unsigned MaxInsertOffset;\n  IncludeCategoryManager Categories;\n  // Record the offset of the end of the last include in each category.\n  std::unordered_map<int, int> CategoryEndOffsets;\n\n  // All possible priorities.\n  std::set<int> Priorities;\n\n  // Matches a whole #include directive.\n  llvm::Regex IncludeRegex;\n};\n\n\n} // namespace tooling\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLING_INCLUSIONS_HEADERINCLUDES_H\n"}, "99": {"id": 99, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Inclusions/IncludeStyle.h", "content": "//===--- IncludeStyle.h - Style of C++ #include directives -------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLING_INCLUSIONS_INCLUDESTYLE_H\n#define LLVM_CLANG_TOOLING_INCLUSIONS_INCLUDESTYLE_H\n\n#include \"llvm/Support/YAMLTraits.h\"\n#include <string>\n#include <vector>\n\nnamespace clang {\nnamespace tooling {\n\n/// Style for sorting and grouping C++ #include directives.\nstruct IncludeStyle {\n  /// Styles for sorting multiple ``#include`` blocks.\n  enum IncludeBlocksStyle {\n    /// Sort each ``#include`` block separately.\n    /// \\code\n    ///    #include \"b.h\"               into      #include \"b.h\"\n    ///\n    ///    #include <lib/main.h>                  #include \"a.h\"\n    ///    #include \"a.h\"                         #include <lib/main.h>\n    /// \\endcode\n    IBS_Preserve,\n    /// Merge multiple ``#include`` blocks together and sort as one.\n    /// \\code\n    ///    #include \"b.h\"               into      #include \"a.h\"\n    ///                                           #include \"b.h\"\n    ///    #include <lib/main.h>                  #include <lib/main.h>\n    ///    #include \"a.h\"\n    /// \\endcode\n    IBS_Merge,\n    /// Merge multiple ``#include`` blocks together and sort as one.\n    /// Then split into groups based on category priority. See\n    /// ``IncludeCategories``.\n    /// \\code\n    ///    #include \"b.h\"               into      #include \"a.h\"\n    ///                                           #include \"b.h\"\n    ///    #include <lib/main.h>\n    ///    #include \"a.h\"                         #include <lib/main.h>\n    /// \\endcode\n    IBS_Regroup,\n  };\n\n  /// Dependent on the value, multiple ``#include`` blocks can be sorted\n  /// as one and divided based on category.\n  IncludeBlocksStyle IncludeBlocks;\n\n  /// See documentation of ``IncludeCategories``.\n  struct IncludeCategory {\n    /// The regular expression that this category matches.\n    std::string Regex;\n    /// The priority to assign to this category.\n    int Priority;\n    /// The custom priority to sort before grouping.\n    int SortPriority;\n    /// If the regular expression is case sensitive.\n    bool RegexIsCaseSensitive;\n    bool operator==(const IncludeCategory &Other) const {\n      return Regex == Other.Regex && Priority == Other.Priority &&\n             RegexIsCaseSensitive == Other.RegexIsCaseSensitive;\n    }\n  };\n\n  /// Regular expressions denoting the different ``#include`` categories\n  /// used for ordering ``#includes``.\n  ///\n  /// `POSIX extended\n  /// <https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html>`_\n  /// regular expressions are supported.\n  ///\n  /// These regular expressions are matched against the filename of an include\n  /// (including the <> or \"\") in order. The value belonging to the first\n  /// matching regular expression is assigned and ``#includes`` are sorted first\n  /// according to increasing category number and then alphabetically within\n  /// each category.\n  ///\n  /// If none of the regular expressions match, INT_MAX is assigned as\n  /// category. The main header for a source file automatically gets category 0.\n  /// so that it is generally kept at the beginning of the ``#includes``\n  /// (https://llvm.org/docs/CodingStandards.html#include-style). However, you\n  /// can also assign negative priorities if you have certain headers that\n  /// always need to be first.\n  ///\n  /// There is a third and optional field ``SortPriority`` which can used while\n  /// ``IncludeBlocks = IBS_Regroup`` to define the priority in which\n  /// ``#includes`` should be ordered. The value of ``Priority`` defines the\n  /// order of ``#include blocks`` and also allows the grouping of ``#includes``\n  /// of different priority. ``SortPriority`` is set to the value of\n  /// ``Priority`` as default if it is not assigned.\n  ///\n  /// Each regular expression can be marked as case sensitive with the field\n  /// ``CaseSensitive``, per default it is not.\n  ///\n  /// To configure this in the .clang-format file, use:\n  /// \\code{.yaml}\n  ///   IncludeCategories:\n  ///     - Regex:           '^\"(llvm|llvm-c|clang|clang-c)/'\n  ///       Priority:        2\n  ///       SortPriority:    2\n  ///       CaseSensitive:   true\n  ///     - Regex:           '^(<|\"(gtest|gmock|isl|json)/)'\n  ///       Priority:        3\n  ///     - Regex:           '<[[:alnum:].]+>'\n  ///       Priority:        4\n  ///     - Regex:           '.*'\n  ///       Priority:        1\n  ///       SortPriority:    0\n  /// \\endcode\n  std::vector<IncludeCategory> IncludeCategories;\n\n  /// Specify a regular expression of suffixes that are allowed in the\n  /// file-to-main-include mapping.\n  ///\n  /// When guessing whether a #include is the \"main\" include (to assign\n  /// category 0, see above), use this regex of allowed suffixes to the header\n  /// stem. A partial match is done, so that:\n  /// - \"\" means \"arbitrary suffix\"\n  /// - \"$\" means \"no suffix\"\n  ///\n  /// For example, if configured to \"(_test)?$\", then a header a.h would be seen\n  /// as the \"main\" include in both a.cc and a_test.cc.\n  std::string IncludeIsMainRegex;\n\n  /// Specify a regular expression for files being formatted\n  /// that are allowed to be considered \"main\" in the\n  /// file-to-main-include mapping.\n  ///\n  /// By default, clang-format considers files as \"main\" only when they end\n  /// with: ``.c``, ``.cc``, ``.cpp``, ``.c++``, ``.cxx``, ``.m`` or ``.mm``\n  /// extensions.\n  /// For these files a guessing of \"main\" include takes place\n  /// (to assign category 0, see above). This config option allows for\n  /// additional suffixes and extensions for files to be considered as \"main\".\n  ///\n  /// For example, if this option is configured to ``(Impl\\.hpp)$``,\n  /// then a file ``ClassImpl.hpp`` is considered \"main\" (in addition to\n  /// ``Class.c``, ``Class.cc``, ``Class.cpp`` and so on) and \"main\n  /// include file\" logic will be executed (with *IncludeIsMainRegex* setting\n  /// also being respected in later phase). Without this option set,\n  /// ``ClassImpl.hpp`` would not have the main include file put on top\n  /// before any other include.\n  std::string IncludeIsMainSourceRegex;\n};\n\n} // namespace tooling\n} // namespace clang\n\nLLVM_YAML_IS_SEQUENCE_VECTOR(clang::tooling::IncludeStyle::IncludeCategory)\n\nnamespace llvm {\nnamespace yaml {\n\ntemplate <>\nstruct MappingTraits<clang::tooling::IncludeStyle::IncludeCategory> {\n  static void mapping(IO &IO,\n                      clang::tooling::IncludeStyle::IncludeCategory &Category);\n};\n\ntemplate <>\nstruct ScalarEnumerationTraits<\n    clang::tooling::IncludeStyle::IncludeBlocksStyle> {\n  static void\n  enumeration(IO &IO, clang::tooling::IncludeStyle::IncludeBlocksStyle &Value);\n};\n\n} // namespace yaml\n} // namespace llvm\n\n#endif // LLVM_CLANG_TOOLING_INCLUSIONS_INCLUDESTYLE_H\n"}, "100": {"id": 100, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "content": "//===- Nodes.h - syntax nodes for C/C++ grammar constructs ----*- C++ -*-=====//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n// Syntax tree nodes for C, C++ and Objective-C grammar constructs.\n//\n// Nodes provide access to their syntactic components, e.g. IfStatement provides\n// a way to get its condition, then and else branches, tokens for 'if' and\n// 'else' keywords.\n// When using the accessors, please assume they can return null. This happens\n// because:\n//   - the corresponding subnode is optional in the C++ grammar, e.g. an else\n//     branch of an if statement,\n//   - syntactic errors occurred while parsing the corresponding subnode.\n// One notable exception is \"introducer\" keywords, e.g. the accessor for the\n// 'if' keyword of an if statement will never return null.\n//===----------------------------------------------------------------------===//\n#ifndef LLVM_CLANG_TOOLING_SYNTAX_NODES_H\n#define LLVM_CLANG_TOOLING_SYNTAX_NODES_H\n\n#include \"clang/Basic/TokenKinds.h\"\n#include \"clang/Lex/Token.h\"\n#include \"clang/Tooling/Syntax/Tokens.h\"\n#include \"clang/Tooling/Syntax/Tree.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/raw_ostream.h\"\nnamespace clang {\nnamespace syntax {\n\n/// A kind of a syntax node, used for implementing casts. The ordering and\n/// blocks of enumerator constants must correspond to the inheritance hierarchy\n/// of syntax::Node.\nenum class NodeKind : uint16_t {\n#define CONCRETE_NODE(Kind, Base) Kind,\n#include \"clang/Tooling/Syntax/Nodes.inc\"\n};\n/// For debugging purposes.\nraw_ostream &operator<<(raw_ostream &OS, NodeKind K);\n\n/// A relation between a parent and child node, e.g. 'left-hand-side of\n/// a binary expression'. Used for implementing accessors.\n///\n/// In general `NodeRole`s should be named the same as their accessors.\n///\n/// Some roles describe parent/child relations that occur multiple times in\n/// language grammar. We define only one role to describe all instances of such\n/// recurring relations. For example, grammar for both \"if\" and \"while\"\n/// statements requires an opening paren and a closing paren. The opening\n/// paren token is assigned the OpenParen role regardless of whether it appears\n/// as a child of IfStatement or WhileStatement node. More generally, when\n/// grammar requires a certain fixed token (like a specific keyword, or an\n/// opening paren), we define a role for this token and use it across all\n/// grammar rules with the same requirement. Names of such reusable roles end\n/// with a ~Token or a ~Keyword suffix.\nenum class NodeRole : uint8_t {\n  // Roles common to multiple node kinds.\n  /// A node without a parent\n  Detached,\n  /// Children of an unknown semantic nature, e.g. skipped tokens, comments.\n  Unknown,\n  /// An opening parenthesis in argument lists and blocks, e.g. '{', '(', etc.\n  OpenParen,\n  /// A closing parenthesis in argument lists and blocks, e.g. '}', ')', etc.\n  CloseParen,\n  /// A keywords that introduces some grammar construct, e.g. 'if', 'try', etc.\n  IntroducerKeyword,\n  /// A token that represents a literal, e.g. 'nullptr', '1', 'true', etc.\n  LiteralToken,\n  /// Tokens or Keywords.\n  ArrowToken,\n  ExternKeyword,\n  TemplateKeyword,\n  /// An inner statement for those that have only a single child of kind\n  /// statement, e.g. loop body for while, for, etc; inner statement for case,\n  /// default, etc.\n  BodyStatement,\n  /// List API roles.\n  ListElement,\n  ListDelimiter,\n\n  // Roles specific to particular node kinds.\n  OperatorToken,\n  Operand,\n  LeftHandSide,\n  RightHandSide,\n  ReturnValue,\n  CaseValue,\n  ThenStatement,\n  ElseKeyword,\n  ElseStatement,\n  Expression,\n  Statement,\n  Condition,\n  Message,\n  Declarator,\n  Declaration,\n  Size,\n  Parameters,\n  TrailingReturn,\n  UnqualifiedId,\n  Qualifier,\n  SubExpression,\n  Object,\n  AccessToken,\n  Member,\n  Callee,\n  Arguments,\n  Declarators\n};\n/// For debugging purposes.\nraw_ostream &operator<<(raw_ostream &OS, NodeRole R);\n\n#include \"clang/Tooling/Syntax/NodeClasses.inc\"\n\n/// Models a `nested-name-specifier`. C++ [expr.prim.id.qual]\n/// e.g. the `std::vector<int>::` in `std::vector<int>::size`.\nclass NestedNameSpecifier final : public List {\npublic:\n  NestedNameSpecifier() : List(NodeKind::NestedNameSpecifier) {}\n  static bool classof(const Node *N);\n  std::vector<NameSpecifier *> getSpecifiers();\n  std::vector<List::ElementAndDelimiter<syntax::NameSpecifier>>\n  getSpecifiersAndDoubleColons();\n};\n\n/// Models an `unqualified-id`. C++ [expr.prim.id.unqual]\n/// e.g. the `size` in `std::vector<int>::size`.\nclass UnqualifiedId final : public Tree {\npublic:\n  UnqualifiedId() : Tree(NodeKind::UnqualifiedId) {}\n  static bool classof(const Node *N);\n};\n\n/// An expression of an unknown kind, i.e. one not currently handled by the\n/// syntax tree.\nclass UnknownExpression final : public Expression {\npublic:\n  UnknownExpression() : Expression(NodeKind::UnknownExpression) {}\n  static bool classof(const Node *N);\n};\n\n/// Models arguments of a function call.\n///   call-arguments:\n///     delimited_list(expression, ',')\n/// Note: This construct is a simplification of the grammar rule for\n/// `expression-list`, that is used in the definition of `call-expression`\nclass CallArguments final : public List {\npublic:\n  CallArguments() : List(NodeKind::CallArguments) {}\n  static bool classof(const Node *N);\n  std::vector<Expression *> getArguments();\n  std::vector<List::ElementAndDelimiter<Expression>> getArgumentsAndCommas();\n};\n\n/// An abstract class for prefix and postfix unary operators.\nclass UnaryOperatorExpression : public Expression {\npublic:\n  UnaryOperatorExpression(NodeKind K) : Expression(K) {}\n  static bool classof(const Node *N);\n  Leaf *getOperatorToken();\n  Expression *getOperand();\n};\n\n/// <operator> <operand>\n///\n/// For example:\n///   +a          -b\n///   !c          not c\n///   ~d          compl d\n///   *e          &f\n///   ++h         --h\n///   __real i    __imag i\nclass PrefixUnaryOperatorExpression final : public UnaryOperatorExpression {\npublic:\n  PrefixUnaryOperatorExpression()\n      : UnaryOperatorExpression(NodeKind::PrefixUnaryOperatorExpression) {}\n  static bool classof(const Node *N);\n};\n\n/// <operand> <operator>\n///\n/// For example:\n///   a++\n///   b--\nclass PostfixUnaryOperatorExpression final : public UnaryOperatorExpression {\npublic:\n  PostfixUnaryOperatorExpression()\n      : UnaryOperatorExpression(NodeKind::PostfixUnaryOperatorExpression) {}\n  static bool classof(const Node *N);\n};\n\n/// <lhs> <operator> <rhs>\n///\n/// For example:\n///   a + b\n///   a bitor 1\n///   a |= b\n///   a and_eq b\nclass BinaryOperatorExpression final : public Expression {\npublic:\n  BinaryOperatorExpression() : Expression(NodeKind::BinaryOperatorExpression) {}\n  static bool classof(const Node *N);\n  Expression *getLhs();\n  Leaf *getOperatorToken();\n  Expression *getRhs();\n};\n\n/// An abstract node for C++ statements, e.g. 'while', 'if', etc.\n/// FIXME: add accessors for semicolon of statements that have it.\nclass Statement : public Tree {\npublic:\n  Statement(NodeKind K) : Tree(K) {}\n  static bool classof(const Node *N);\n};\n\n/// A statement of an unknown kind, i.e. one not currently handled by the syntax\n/// tree.\nclass UnknownStatement final : public Statement {\npublic:\n  UnknownStatement() : Statement(NodeKind::UnknownStatement) {}\n  static bool classof(const Node *N);\n};\n\n/// E.g. 'int a, b = 10;'\nclass DeclarationStatement final : public Statement {\npublic:\n  DeclarationStatement() : Statement(NodeKind::DeclarationStatement) {}\n  static bool classof(const Node *N);\n};\n\n/// The no-op statement, i.e. ';'.\nclass EmptyStatement final : public Statement {\npublic:\n  EmptyStatement() : Statement(NodeKind::EmptyStatement) {}\n  static bool classof(const Node *N);\n};\n\n/// switch (<cond>) <body>\nclass SwitchStatement final : public Statement {\npublic:\n  SwitchStatement() : Statement(NodeKind::SwitchStatement) {}\n  static bool classof(const Node *N);\n  Leaf *getSwitchKeyword();\n  Statement *getBody();\n};\n\n/// case <value>: <body>\nclass CaseStatement final : public Statement {\npublic:\n  CaseStatement() : Statement(NodeKind::CaseStatement) {}\n  static bool classof(const Node *N);\n  Leaf *getCaseKeyword();\n  Expression *getCaseValue();\n  Statement *getBody();\n};\n\n/// default: <body>\nclass DefaultStatement final : public Statement {\npublic:\n  DefaultStatement() : Statement(NodeKind::DefaultStatement) {}\n  static bool classof(const Node *N);\n  Leaf *getDefaultKeyword();\n  Statement *getBody();\n};\n\n/// if (cond) <then-statement> else <else-statement>\n/// FIXME: add condition that models 'expression  or variable declaration'\nclass IfStatement final : public Statement {\npublic:\n  IfStatement() : Statement(NodeKind::IfStatement) {}\n  static bool classof(const Node *N);\n  Leaf *getIfKeyword();\n  Statement *getThenStatement();\n  Leaf *getElseKeyword();\n  Statement *getElseStatement();\n};\n\n/// for (<init>; <cond>; <increment>) <body>\nclass ForStatement final : public Statement {\npublic:\n  ForStatement() : Statement(NodeKind::ForStatement) {}\n  static bool classof(const Node *N);\n  Leaf *getForKeyword();\n  Statement *getBody();\n};\n\n/// while (<cond>) <body>\nclass WhileStatement final : public Statement {\npublic:\n  WhileStatement() : Statement(NodeKind::WhileStatement) {}\n  static bool classof(const Node *N);\n  Leaf *getWhileKeyword();\n  Statement *getBody();\n};\n\n/// continue;\nclass ContinueStatement final : public Statement {\npublic:\n  ContinueStatement() : Statement(NodeKind::ContinueStatement) {}\n  static bool classof(const Node *N);\n  Leaf *getContinueKeyword();\n};\n\n/// break;\nclass BreakStatement final : public Statement {\npublic:\n  BreakStatement() : Statement(NodeKind::BreakStatement) {}\n  static bool classof(const Node *N);\n  Leaf *getBreakKeyword();\n};\n\n/// return <expr>;\n/// return;\nclass ReturnStatement final : public Statement {\npublic:\n  ReturnStatement() : Statement(NodeKind::ReturnStatement) {}\n  static bool classof(const Node *N);\n  Leaf *getReturnKeyword();\n  Expression *getReturnValue();\n};\n\n/// for (<decl> : <init>) <body>\nclass RangeBasedForStatement final : public Statement {\npublic:\n  RangeBasedForStatement() : Statement(NodeKind::RangeBasedForStatement) {}\n  static bool classof(const Node *N);\n  Leaf *getForKeyword();\n  Statement *getBody();\n};\n\n/// Expression in a statement position, e.g. functions calls inside compound\n/// statements or inside a loop body.\nclass ExpressionStatement final : public Statement {\npublic:\n  ExpressionStatement() : Statement(NodeKind::ExpressionStatement) {}\n  static bool classof(const Node *N);\n  Expression *getExpression();\n};\n\n/// { statement1; statement2; \u2026 }\nclass CompoundStatement final : public Statement {\npublic:\n  CompoundStatement() : Statement(NodeKind::CompoundStatement) {}\n  static bool classof(const Node *N);\n  Leaf *getLbrace();\n  /// FIXME: use custom iterator instead of 'vector'.\n  std::vector<Statement *> getStatements();\n  Leaf *getRbrace();\n};\n\n/// A declaration that can appear at the top-level. Note that this does *not*\n/// correspond 1-to-1 to clang::Decl. Syntax trees distinguish between top-level\n/// declarations (e.g. namespace definitions) and declarators (e.g. variables,\n/// typedefs, etc.). Declarators are stored inside SimpleDeclaration.\nclass Declaration : public Tree {\npublic:\n  Declaration(NodeKind K) : Tree(K) {}\n  static bool classof(const Node *N);\n};\n\n/// Declaration of an unknown kind, e.g. not yet supported in syntax trees.\nclass UnknownDeclaration final : public Declaration {\npublic:\n  UnknownDeclaration() : Declaration(NodeKind::UnknownDeclaration) {}\n  static bool classof(const Node *N);\n};\n\n/// A semicolon in the top-level context. Does not declare anything.\nclass EmptyDeclaration final : public Declaration {\npublic:\n  EmptyDeclaration() : Declaration(NodeKind::EmptyDeclaration) {}\n  static bool classof(const Node *N);\n};\n\n/// static_assert(<condition>, <message>)\n/// static_assert(<condition>)\nclass StaticAssertDeclaration final : public Declaration {\npublic:\n  StaticAssertDeclaration() : Declaration(NodeKind::StaticAssertDeclaration) {}\n  static bool classof(const Node *N);\n  Expression *getCondition();\n  Expression *getMessage();\n};\n\n/// extern <string-literal> declaration\n/// extern <string-literal> { <decls>  }\nclass LinkageSpecificationDeclaration final : public Declaration {\npublic:\n  LinkageSpecificationDeclaration()\n      : Declaration(NodeKind::LinkageSpecificationDeclaration) {}\n  static bool classof(const Node *N);\n};\n\nclass DeclaratorList final : public List {\npublic:\n  DeclaratorList() : List(NodeKind::DeclaratorList) {}\n  static bool classof(const Node *N);\n  std::vector<SimpleDeclarator *> getDeclarators();\n  std::vector<List::ElementAndDelimiter<syntax::SimpleDeclarator>>\n  getDeclaratorsAndCommas();\n};\n\n/// Groups multiple declarators (e.g. variables, typedefs, etc.) together. All\n/// grouped declarators share the same declaration specifiers (e.g. 'int' or\n/// 'typedef').\nclass SimpleDeclaration final : public Declaration {\npublic:\n  SimpleDeclaration() : Declaration(NodeKind::SimpleDeclaration) {}\n  static bool classof(const Node *N);\n  /// FIXME: use custom iterator instead of 'vector'.\n  std::vector<SimpleDeclarator *> getDeclarators();\n};\n\n/// template <template-parameters> <declaration>\nclass TemplateDeclaration final : public Declaration {\npublic:\n  TemplateDeclaration() : Declaration(NodeKind::TemplateDeclaration) {}\n  static bool classof(const Node *N);\n  Leaf *getTemplateKeyword();\n  Declaration *getDeclaration();\n};\n\n/// template <declaration>\n/// Examples:\n///     template struct X<int>\n///     template void foo<int>()\n///     template int var<double>\nclass ExplicitTemplateInstantiation final : public Declaration {\npublic:\n  ExplicitTemplateInstantiation()\n      : Declaration(NodeKind::ExplicitTemplateInstantiation) {}\n  static bool classof(const Node *N);\n  Leaf *getTemplateKeyword();\n  Leaf *getExternKeyword();\n  Declaration *getDeclaration();\n};\n\n/// namespace <name> { <decls> }\nclass NamespaceDefinition final : public Declaration {\npublic:\n  NamespaceDefinition() : Declaration(NodeKind::NamespaceDefinition) {}\n  static bool classof(const Node *N);\n};\n\n/// namespace <name> = <namespace-reference>\nclass NamespaceAliasDefinition final : public Declaration {\npublic:\n  NamespaceAliasDefinition()\n      : Declaration(NodeKind::NamespaceAliasDefinition) {}\n  static bool classof(const Node *N);\n};\n\n/// using namespace <name>\nclass UsingNamespaceDirective final : public Declaration {\npublic:\n  UsingNamespaceDirective() : Declaration(NodeKind::UsingNamespaceDirective) {}\n  static bool classof(const Node *N);\n};\n\n/// using <scope>::<name>\n/// using typename <scope>::<name>\nclass UsingDeclaration final : public Declaration {\npublic:\n  UsingDeclaration() : Declaration(NodeKind::UsingDeclaration) {}\n  static bool classof(const Node *N);\n};\n\n/// using <name> = <type>\nclass TypeAliasDeclaration final : public Declaration {\npublic:\n  TypeAliasDeclaration() : Declaration(NodeKind::TypeAliasDeclaration) {}\n  static bool classof(const Node *N);\n};\n\n/// Covers a name, an initializer and a part of the type outside declaration\n/// specifiers. Examples are:\n///     `*a` in `int *a`\n///     `a[10]` in `int a[10]`\n///     `*a = nullptr` in `int *a = nullptr`\n/// Declarators can be unnamed too:\n///     `**` in `new int**`\n///     `* = nullptr` in `void foo(int* = nullptr)`\n/// Most declarators you encounter are instances of SimpleDeclarator. They may\n/// contain an inner declarator inside parentheses, we represent it as\n/// ParenDeclarator. E.g.\n///     `(*a)` in `int (*a) = 10`\nclass Declarator : public Tree {\npublic:\n  Declarator(NodeKind K) : Tree(K) {}\n  static bool classof(const Node *N);\n};\n\n/// A top-level declarator without parentheses. See comment of Declarator for\n/// more details.\nclass SimpleDeclarator final : public Declarator {\npublic:\n  SimpleDeclarator() : Declarator(NodeKind::SimpleDeclarator) {}\n  static bool classof(const Node *N);\n};\n\n/// Declarator inside parentheses.\n/// E.g. `(***a)` from `int (***a) = nullptr;`\n/// See comment of Declarator for more details.\nclass ParenDeclarator final : public Declarator {\npublic:\n  ParenDeclarator() : Declarator(NodeKind::ParenDeclarator) {}\n  static bool classof(const Node *N);\n  Leaf *getLparen();\n  Leaf *getRparen();\n};\n\n/// Array size specified inside a declarator.\n/// E.g:\n///   `[10]` in `int a[10];`\n///   `[static 10]` in `void f(int xs[static 10]);`\nclass ArraySubscript final : public Tree {\npublic:\n  ArraySubscript() : Tree(NodeKind::ArraySubscript) {}\n  static bool classof(const Node *N);\n  // TODO: add an accessor for the \"static\" keyword.\n  Leaf *getLbracket();\n  Expression *getSize();\n  Leaf *getRbracket();\n};\n\n/// Trailing return type after the parameter list, including the arrow token.\n/// E.g. `-> int***`.\nclass TrailingReturnType final : public Tree {\npublic:\n  TrailingReturnType() : Tree(NodeKind::TrailingReturnType) {}\n  static bool classof(const Node *N);\n  // TODO: add accessors for specifiers.\n  Leaf *getArrowToken();\n  // FIXME: This should be a `type-id` following the grammar. Fix this once we\n  // have a representation of `type-id`s.\n  SimpleDeclarator *getDeclarator();\n};\n\n/// Models a `parameter-declaration-list` which appears within\n/// `parameters-and-qualifiers`. See C++ [dcl.fct]\nclass ParameterDeclarationList final : public List {\npublic:\n  ParameterDeclarationList() : List(NodeKind::ParameterDeclarationList) {}\n  static bool classof(const Node *N);\n  std::vector<SimpleDeclaration *> getParameterDeclarations();\n  std::vector<List::ElementAndDelimiter<syntax::SimpleDeclaration>>\n  getParametersAndCommas();\n};\n\n/// Parameter list for a function type and a trailing return type, if the\n/// function has one.\n/// E.g.:\n///  `(int a) volatile ` in `int foo(int a) volatile;`\n///  `(int a) &&` in `int foo(int a) &&;`\n///  `() -> int` in `auto foo() -> int;`\n///  `() const` in `int foo() const;`\n///  `() noexcept` in `int foo() noexcept;`\n///  `() throw()` in `int foo() throw();`\n///\n/// (!) override doesn't belong here.\nclass ParametersAndQualifiers final : public Tree {\npublic:\n  ParametersAndQualifiers() : Tree(NodeKind::ParametersAndQualifiers) {}\n  static bool classof(const Node *N);\n  Leaf *getLparen();\n  ParameterDeclarationList *getParameters();\n  Leaf *getRparen();\n  TrailingReturnType *getTrailingReturn();\n};\n\n/// Member pointer inside a declarator\n/// E.g. `X::*` in `int X::* a = 0;`\nclass MemberPointer final : public Tree {\npublic:\n  MemberPointer() : Tree(NodeKind::MemberPointer) {}\n  static bool classof(const Node *N);\n};\n\n#define CONCRETE_NODE(Kind, Base)                                              \\\n  inline bool Kind::classof(const Node *N) {                                   \\\n    return N->getKind() == NodeKind::Kind;                                     \\\n  }\n#define ABSTRACT_NODE(Kind, Base, First, Last)                                 \\\n  inline bool Kind::classof(const Node *N) {                                   \\\n    return N->getKind() >= NodeKind::First && N->getKind() <= NodeKind::Last;  \\\n  }\n#include \"clang/Tooling/Syntax/Nodes.inc\"\n\n} // namespace syntax\n} // namespace clang\n#endif\n"}, "101": {"id": 101, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h", "content": "//===- Tokens.h - collect tokens from preprocessing --------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n// Record tokens that a preprocessor emits and define operations to map between\n// the tokens written in a file and tokens produced by the preprocessor.\n//\n// When running the compiler, there are two token streams we are interested in:\n//   - \"spelled\" tokens directly correspond to a substring written in some\n//     source file.\n//   - \"expanded\" tokens represent the result of preprocessing, parses consumes\n//     this token stream to produce the AST.\n//\n// Expanded tokens correspond directly to locations found in the AST, allowing\n// to find subranges of the token stream covered by various AST nodes. Spelled\n// tokens correspond directly to the source code written by the user.\n//\n// To allow composing these two use-cases, we also define operations that map\n// between expanded and spelled tokens that produced them (macro calls,\n// directives, etc).\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLING_SYNTAX_TOKENS_H\n#define LLVM_CLANG_TOOLING_SYNTAX_TOKENS_H\n\n#include \"clang/Basic/FileManager.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Basic/TokenKinds.h\"\n#include \"clang/Lex/Token.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cstdint>\n#include <tuple>\n\nnamespace clang {\nclass Preprocessor;\n\nnamespace syntax {\n\n/// A half-open character range inside a particular file, the start offset is\n/// included and the end offset is excluded from the range.\nstruct FileRange {\n  /// EXPECTS: File.isValid() && Begin <= End.\n  FileRange(FileID File, unsigned BeginOffset, unsigned EndOffset);\n  /// EXPECTS: BeginLoc.isValid() && BeginLoc.isFileID().\n  FileRange(const SourceManager &SM, SourceLocation BeginLoc, unsigned Length);\n  /// EXPECTS: BeginLoc.isValid() && BeginLoc.isFileID(), Begin <= End and files\n  ///          are the same.\n  FileRange(const SourceManager &SM, SourceLocation BeginLoc,\n            SourceLocation EndLoc);\n\n  FileID file() const { return File; }\n  /// Start is a start offset (inclusive) in the corresponding file.\n  unsigned beginOffset() const { return Begin; }\n  /// End offset (exclusive) in the corresponding file.\n  unsigned endOffset() const { return End; }\n\n  unsigned length() const { return End - Begin; }\n\n  /// Check if \\p Offset is inside the range.\n  bool contains(unsigned Offset) const {\n    return Begin <= Offset && Offset < End;\n  }\n  /// Check \\p Offset is inside the range or equal to its endpoint.\n  bool touches(unsigned Offset) const {\n    return Begin <= Offset && Offset <= End;\n  }\n\n  /// Gets the substring that this FileRange refers to.\n  llvm::StringRef text(const SourceManager &SM) const;\n\n  /// Convert to the clang range. The returned range is always a char range,\n  /// never a token range.\n  CharSourceRange toCharRange(const SourceManager &SM) const;\n\n  friend bool operator==(const FileRange &L, const FileRange &R) {\n    return std::tie(L.File, L.Begin, L.End) == std::tie(R.File, R.Begin, R.End);\n  }\n  friend bool operator!=(const FileRange &L, const FileRange &R) {\n    return !(L == R);\n  }\n\nprivate:\n  FileID File;\n  unsigned Begin;\n  unsigned End;\n};\n\n/// For debugging purposes.\nllvm::raw_ostream &operator<<(llvm::raw_ostream &OS, const FileRange &R);\n\n/// A token coming directly from a file or from a macro invocation. Has just\n/// enough information to locate the token in the source code.\n/// Can represent both expanded and spelled tokens.\nclass Token {\npublic:\n  Token(SourceLocation Location, unsigned Length, tok::TokenKind Kind);\n  /// EXPECTS: clang::Token is not an annotation token.\n  explicit Token(const clang::Token &T);\n\n  tok::TokenKind kind() const { return Kind; }\n  /// Location of the first character of a token.\n  SourceLocation location() const { return Location; }\n  /// Location right after the last character of a token.\n  SourceLocation endLocation() const {\n    return Location.getLocWithOffset(Length);\n  }\n  unsigned length() const { return Length; }\n\n  /// Get the substring covered by the token. Note that will include all\n  /// digraphs, newline continuations, etc. E.g. tokens for 'int' and\n  ///    in\\\n  ///    t\n  /// both have the same kind tok::kw_int, but results of text() are different.\n  llvm::StringRef text(const SourceManager &SM) const;\n\n  /// Gets a range of this token.\n  /// EXPECTS: token comes from a file, not from a macro expansion.\n  FileRange range(const SourceManager &SM) const;\n\n  /// Given two tokens inside the same file, returns a file range that starts at\n  /// \\p First and ends at \\p Last.\n  /// EXPECTS: First and Last are file tokens from the same file, Last starts\n  ///          after First.\n  static FileRange range(const SourceManager &SM, const syntax::Token &First,\n                         const syntax::Token &Last);\n\n  std::string dumpForTests(const SourceManager &SM) const;\n  /// For debugging purposes.\n  std::string str() const;\n\nprivate:\n  SourceLocation Location;\n  unsigned Length;\n  tok::TokenKind Kind;\n};\n/// For debugging purposes. Equivalent to a call to Token::str().\nllvm::raw_ostream &operator<<(llvm::raw_ostream &OS, const Token &T);\n\n/// A list of tokens obtained by preprocessing a text buffer and operations to\n/// map between the expanded and spelled tokens, i.e. TokenBuffer has\n/// information about two token streams:\n///    1. Expanded tokens: tokens produced by the preprocessor after all macro\n///       replacements,\n///    2. Spelled tokens: corresponding directly to the source code of a file\n///       before any macro replacements occurred.\n/// Here's an example to illustrate a difference between those two:\n///     #define FOO 10\n///     int a = FOO;\n///\n/// Spelled tokens are {'#','define','FOO','10','int','a','=','FOO',';'}.\n/// Expanded tokens are {'int','a','=','10',';','eof'}.\n///\n/// Note that the expanded token stream has a tok::eof token at the end, the\n/// spelled tokens never store a 'eof' token.\n///\n/// The full list expanded tokens can be obtained with expandedTokens(). Spelled\n/// tokens for each of the files can be obtained via spelledTokens(FileID).\n///\n/// To map between the expanded and spelled tokens use findSpelledByExpanded().\n///\n/// To build a token buffer use the TokenCollector class. You can also compute\n/// the spelled tokens of a file using the tokenize() helper.\n///\n/// FIXME: allow mappings into macro arguments.\nclass TokenBuffer {\npublic:\n  TokenBuffer(const SourceManager &SourceMgr) : SourceMgr(&SourceMgr) {}\n\n  TokenBuffer(TokenBuffer &&) = default;\n  TokenBuffer(const TokenBuffer &) = delete;\n  TokenBuffer &operator=(TokenBuffer &&) = default;\n  TokenBuffer &operator=(const TokenBuffer &) = delete;\n\n  /// All tokens produced by the preprocessor after all macro replacements,\n  /// directives, etc. Source locations found in the clang AST will always\n  /// point to one of these tokens.\n  /// Tokens are in TU order (per SourceManager::isBeforeInTranslationUnit()).\n  /// FIXME: figure out how to handle token splitting, e.g. '>>' can be split\n  ///        into two '>' tokens by the parser. However, TokenBuffer currently\n  ///        keeps it as a single '>>' token.\n  llvm::ArrayRef<syntax::Token> expandedTokens() const {\n    return ExpandedTokens;\n  }\n\n  /// Returns the subrange of expandedTokens() corresponding to the closed\n  /// token range R.\n  llvm::ArrayRef<syntax::Token> expandedTokens(SourceRange R) const;\n\n  /// Returns the subrange of spelled tokens corresponding to AST node spanning\n  /// \\p Expanded. This is the text that should be replaced if a refactoring\n  /// were to rewrite the node. If \\p Expanded is empty, the returned value is\n  /// llvm::None.\n  ///\n  /// Will fail if the expanded tokens do not correspond to a sequence of\n  /// spelled tokens. E.g. for the following example:\n  ///\n  ///   #define FIRST f1 f2 f3\n  ///   #define SECOND s1 s2 s3\n  ///   #define ID2(X, Y) X Y\n  ///\n  ///   a FIRST b SECOND c // expanded tokens are: a f1 f2 f3 b s1 s2 s3 c\n  ///   d ID2(e f g, h) i  // expanded tokens are: d e f g h i\n  ///\n  /// the results would be:\n  ///   expanded   => spelled\n  ///   ------------------------\n  ///            a => a\n  ///     s1 s2 s3 => SECOND\n  ///   a f1 f2 f3 => a FIRST\n  ///         a f1 => can't map\n  ///        s1 s2 => can't map\n  ///         e f  => e f\n  ///         g h  => can't map\n  ///\n  /// EXPECTS: \\p Expanded is a subrange of expandedTokens().\n  /// Complexity is logarithmic.\n  llvm::Optional<llvm::ArrayRef<syntax::Token>>\n  spelledForExpanded(llvm::ArrayRef<syntax::Token> Expanded) const;\n\n  /// Find the subranges of expanded tokens, corresponding to \\p Spelled.\n  ///\n  /// Some spelled tokens may not be present in the expanded token stream, so\n  /// this function can return an empty vector, e.g. for tokens of macro\n  /// directives or disabled preprocessor branches.\n  ///\n  /// Some spelled tokens can be duplicated in the expanded token stream\n  /// multiple times and this function will return multiple results in those\n  /// cases. This happens when \\p Spelled is inside a macro argument.\n  ///\n  /// FIXME: return correct results on macro arguments. For now, we return an\n  ///        empty list.\n  ///\n  /// (!) will return empty vector on tokens from #define body:\n  /// E.g. for the following example:\n  ///\n  ///   #define FIRST(A) f1 A = A f2\n  ///   #define SECOND s\n  ///\n  ///   a FIRST(arg) b SECOND c // expanded tokens are: a f1 arg = arg f2 b s\n  /// The results would be\n  ///   spelled           => expanded\n  ///   ------------------------\n  ///   #define FIRST     => {}\n  ///   a FIRST(arg)      => {a f1 arg = arg f2}\n  ///   arg               => {arg, arg} // arg #1 is before `=` and arg #2 is\n  ///                                   // after `=` in the expanded tokens.\n  llvm::SmallVector<llvm::ArrayRef<syntax::Token>, 1>\n  expandedForSpelled(llvm::ArrayRef<syntax::Token> Spelled) const;\n\n  /// An expansion produced by the preprocessor, includes macro expansions and\n  /// preprocessor directives. Preprocessor always maps a non-empty range of\n  /// spelled tokens to a (possibly empty) range of expanded tokens. Here is a\n  /// few examples of expansions:\n  ///    #pragma once      // Expands to an empty range.\n  ///    #define FOO 1 2 3 // Expands an empty range.\n  ///    FOO               // Expands to \"1 2 3\".\n  /// FIXME(ibiryukov): implement this, currently #include expansions are empty.\n  ///    #include <vector> // Expands to tokens produced by the include.\n  struct Expansion {\n    llvm::ArrayRef<syntax::Token> Spelled;\n    llvm::ArrayRef<syntax::Token> Expanded;\n  };\n  /// If \\p Spelled starts a mapping (e.g. if it's a macro name or '#' starting\n  /// a preprocessor directive) return the subrange of expanded tokens that the\n  /// macro expands to.\n  llvm::Optional<Expansion>\n  expansionStartingAt(const syntax::Token *Spelled) const;\n  /// Returns all expansions (partially) expanded from the specified tokens.\n  /// This is the expansions whose Spelled range intersects \\p Spelled.\n  std::vector<Expansion>\n  expansionsOverlapping(llvm::ArrayRef<syntax::Token> Spelled) const;\n\n  /// Lexed tokens of a file before preprocessing. E.g. for the following input\n  ///     #define DECL(name) int name = 10\n  ///     DECL(a);\n  /// spelledTokens() returns\n  ///    {\"#\", \"define\", \"DECL\", \"(\", \"name\", \")\", \"int\", \"name\", \"=\", \"10\",\n  ///     \"DECL\", \"(\", \"a\", \")\", \";\"}\n  llvm::ArrayRef<syntax::Token> spelledTokens(FileID FID) const;\n\n  /// Returns the spelled Token starting at Loc, if there are no such tokens\n  /// returns nullptr.\n  const syntax::Token *spelledTokenAt(SourceLocation Loc) const;\n\n  /// Get all tokens that expand a macro in \\p FID. For the following input\n  ///     #define FOO B\n  ///     #define FOO2(X) int X\n  ///     FOO2(XY)\n  ///     int B;\n  ///     FOO;\n  /// macroExpansions() returns {\"FOO2\", \"FOO\"} (from line 3 and 5\n  /// respecitvely).\n  std::vector<const syntax::Token *> macroExpansions(FileID FID) const;\n\n  const SourceManager &sourceManager() const { return *SourceMgr; }\n\n  std::string dumpForTests() const;\n\nprivate:\n  /// Describes a mapping between a continuous subrange of spelled tokens and\n  /// expanded tokens. Represents macro expansions, preprocessor directives,\n  /// conditionally disabled pp regions, etc.\n  ///   #define FOO 1+2\n  ///   #define BAR(a) a + 1\n  ///   FOO    // invocation #1, tokens = {'1','+','2'}, macroTokens = {'FOO'}.\n  ///   BAR(1) // invocation #2, tokens = {'a', '+', '1'},\n  ///                            macroTokens = {'BAR', '(', '1', ')'}.\n  struct Mapping {\n    // Positions in the corresponding spelled token stream. The corresponding\n    // range is never empty.\n    unsigned BeginSpelled = 0;\n    unsigned EndSpelled = 0;\n    // Positions in the expanded token stream. The corresponding range can be\n    // empty.\n    unsigned BeginExpanded = 0;\n    unsigned EndExpanded = 0;\n\n    /// For debugging purposes.\n    std::string str() const;\n  };\n  /// Spelled tokens of the file with information about the subranges.\n  struct MarkedFile {\n    /// Lexed, but not preprocessed, tokens of the file. These map directly to\n    /// text in the corresponding files and include tokens of all preprocessor\n    /// directives.\n    /// FIXME: spelled tokens don't change across FileID that map to the same\n    ///        FileEntry. We could consider deduplicating them to save memory.\n    std::vector<syntax::Token> SpelledTokens;\n    /// A sorted list to convert between the spelled and expanded token streams.\n    std::vector<Mapping> Mappings;\n    /// The first expanded token produced for this FileID.\n    unsigned BeginExpanded = 0;\n    unsigned EndExpanded = 0;\n  };\n\n  friend class TokenCollector;\n\n  /// Maps a single expanded token to its spelled counterpart or a mapping that\n  /// produced it.\n  std::pair<const syntax::Token *, const Mapping *>\n  spelledForExpandedToken(const syntax::Token *Expanded) const;\n\n  /// Returns a mapping starting before \\p Spelled token, or nullptr if no\n  /// such mapping exists.\n  static const Mapping *\n  mappingStartingBeforeSpelled(const MarkedFile &F,\n                               const syntax::Token *Spelled);\n\n  /// Convert a private Mapping to a public Expansion.\n  Expansion makeExpansion(const MarkedFile &, const Mapping &) const;\n  /// Returns the file that the Spelled tokens are taken from.\n  /// Asserts that they are non-empty, from a tracked file, and in-bounds.\n  const MarkedFile &fileForSpelled(llvm::ArrayRef<syntax::Token> Spelled) const;\n\n  /// Token stream produced after preprocessing, conceputally this captures the\n  /// same stream as 'clang -E' (excluding the preprocessor directives like\n  /// #file, etc.).\n  std::vector<syntax::Token> ExpandedTokens;\n  llvm::DenseMap<FileID, MarkedFile> Files;\n  // The value is never null, pointer instead of reference to avoid disabling\n  // implicit assignment operator.\n  const SourceManager *SourceMgr;\n};\n\n/// The spelled tokens that overlap or touch a spelling location Loc.\n/// This always returns 0-2 tokens.\nllvm::ArrayRef<syntax::Token>\nspelledTokensTouching(SourceLocation Loc, const syntax::TokenBuffer &Tokens);\nllvm::ArrayRef<syntax::Token>\nspelledTokensTouching(SourceLocation Loc, llvm::ArrayRef<syntax::Token> Tokens);\n\n/// The identifier token that overlaps or touches a spelling location Loc.\n/// If there is none, returns nullptr.\nconst syntax::Token *\nspelledIdentifierTouching(SourceLocation Loc,\n                          llvm::ArrayRef<syntax::Token> Tokens);\nconst syntax::Token *\nspelledIdentifierTouching(SourceLocation Loc,\n                          const syntax::TokenBuffer &Tokens);\n\n/// Lex the text buffer, corresponding to \\p FID, in raw mode and record the\n/// resulting spelled tokens. Does minimal post-processing on raw identifiers,\n/// setting the appropriate token kind (instead of the raw_identifier reported\n/// by lexer in raw mode). This is a very low-level function, most users should\n/// prefer to use TokenCollector. Lexing in raw mode produces wildly different\n/// results from what one might expect when running a C++ frontend, e.g.\n/// preprocessor does not run at all.\n/// The result will *not* have a 'eof' token at the end.\nstd::vector<syntax::Token> tokenize(FileID FID, const SourceManager &SM,\n                                    const LangOptions &LO);\n/// Similar to one above, instead of whole file tokenizes a part of it. Note\n/// that, the first token might be incomplete if FR.startOffset is not at the\n/// beginning of a token, and the last token returned will start before the\n/// FR.endOffset but might end after it.\nstd::vector<syntax::Token>\ntokenize(const FileRange &FR, const SourceManager &SM, const LangOptions &LO);\n\n/// Collects tokens for the main file while running the frontend action. An\n/// instance of this object should be created on\n/// FrontendAction::BeginSourceFile() and the results should be consumed after\n/// FrontendAction::Execute() finishes.\nclass TokenCollector {\npublic:\n  /// Adds the hooks to collect the tokens. Should be called before the\n  /// preprocessing starts, i.e. as a part of BeginSourceFile() or\n  /// CreateASTConsumer().\n  TokenCollector(Preprocessor &P);\n\n  /// Finalizes token collection. Should be called after preprocessing is\n  /// finished, i.e. after running Execute().\n  LLVM_NODISCARD TokenBuffer consume() &&;\n\nprivate:\n  /// Maps from a start to an end spelling location of transformations\n  /// performed by the preprocessor. These include:\n  ///   1. range from '#' to the last token in the line for PP directives,\n  ///   2. macro name and arguments for macro expansions.\n  /// Note that we record only top-level macro expansions, intermediate\n  /// expansions (e.g. inside macro arguments) are ignored.\n  ///\n  /// Used to find correct boundaries of macro calls and directives when\n  /// building mappings from spelled to expanded tokens.\n  ///\n  /// Logically, at each point of the preprocessor execution there is a stack of\n  /// macro expansions being processed and we could use it to recover the\n  /// location information we need. However, the public preprocessor API only\n  /// exposes the points when macro expansions start (when we push a macro onto\n  /// the stack) and not when they end (when we pop a macro from the stack).\n  /// To workaround this limitation, we rely on source location information\n  /// stored in this map.\n  using PPExpansions = llvm::DenseMap<SourceLocation, SourceLocation>;\n  class Builder;\n  class CollectPPExpansions;\n\n  std::vector<syntax::Token> Expanded;\n  // FIXME: we only store macro expansions, also add directives(#pragma, etc.)\n  PPExpansions Expansions;\n  Preprocessor &PP;\n  CollectPPExpansions *Collector;\n};\n\n} // namespace syntax\n} // namespace clang\n\n#endif\n"}, "102": {"id": 102, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h", "content": "//===- Tree.h - structure of the syntax tree ------------------*- C++ -*-=====//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n// Defines the basic structure of the syntax tree. There are two kinds of nodes:\n//   - leaf nodes correspond to a token in the expanded token stream,\n//   - tree nodes correspond to language grammar constructs.\n//\n// The tree is initially built from an AST. Each node of a newly built tree\n// covers a continous subrange of expanded tokens (i.e. tokens after\n// preprocessing), the specific tokens coverered are stored in the leaf nodes of\n// a tree. A post-order traversal of a tree will visit leaf nodes in an order\n// corresponding the original order of expanded tokens.\n//\n// This is still work in progress and highly experimental, we leave room for\n// ourselves to completely change the design and/or implementation.\n//===----------------------------------------------------------------------===//\n#ifndef LLVM_CLANG_TOOLING_SYNTAX_TREE_CASCADE_H\n#define LLVM_CLANG_TOOLING_SYNTAX_TREE_CASCADE_H\n\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Basic/TokenKinds.h\"\n#include \"clang/Tooling/Syntax/Tokens.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <cstdint>\n#include <iterator>\n\nnamespace clang {\nnamespace syntax {\n\n/// A memory arena for syntax trees. Also tracks the underlying token buffers,\n/// source manager, etc.\nclass Arena {\npublic:\n  Arena(SourceManager &SourceMgr, const LangOptions &LangOpts,\n        const TokenBuffer &Tokens);\n\n  const SourceManager &getSourceManager() const { return SourceMgr; }\n  const LangOptions &getLangOptions() const { return LangOpts; }\n\n  const TokenBuffer &getTokenBuffer() const;\n  llvm::BumpPtrAllocator &getAllocator() { return Allocator; }\n\nprivate:\n  /// Add \\p Buffer to the underlying source manager, tokenize it and store the\n  /// resulting tokens. Used exclusively in `FactoryImpl` to materialize tokens\n  /// that were not written in user code.\n  std::pair<FileID, ArrayRef<Token>>\n  lexBuffer(std::unique_ptr<llvm::MemoryBuffer> Buffer);\n  friend class FactoryImpl;\n\nprivate:\n  SourceManager &SourceMgr;\n  const LangOptions &LangOpts;\n  const TokenBuffer &Tokens;\n  /// IDs and storage for additional tokenized files.\n  llvm::DenseMap<FileID, std::vector<Token>> ExtraTokens;\n  /// Keeps all the allocated nodes and their intermediate data structures.\n  llvm::BumpPtrAllocator Allocator;\n};\n\nclass Tree;\nclass TreeBuilder;\nclass FactoryImpl;\nclass MutationsImpl;\n\nenum class NodeKind : uint16_t;\nenum class NodeRole : uint8_t;\n\n/// A node in a syntax tree. Each node is either a Leaf (representing tokens) or\n/// a Tree (representing language constructrs).\nclass Node {\nprotected:\n  /// Newly created nodes are detached from a tree, parent and sibling links are\n  /// set when the node is added as a child to another one.\n  Node(NodeKind Kind);\n  /// Nodes are allocated on Arenas; the destructor is never called.\n  ~Node() = default;\n\npublic:\n  /// Nodes cannot simply be copied without violating tree invariants.\n  Node(const Node &) = delete;\n  Node &operator=(const Node &) = delete;\n  /// Idiomatically, nodes are allocated on an Arena and never moved.\n  Node(Node &&) = delete;\n  Node &operator=(Node &&) = delete;\n\n  NodeKind getKind() const { return static_cast<NodeKind>(Kind); }\n  NodeRole getRole() const { return static_cast<NodeRole>(Role); }\n\n  /// Whether the node is detached from a tree, i.e. does not have a parent.\n  bool isDetached() const;\n  /// Whether the node was created from the AST backed by the source code\n  /// rather than added later through mutation APIs or created with factory\n  /// functions.\n  /// When this flag is true, all subtrees are also original.\n  /// This flag is set to false on any modifications to the node or any of its\n  /// subtrees, even if this simply involves swapping existing subtrees.\n  bool isOriginal() const { return Original; }\n  /// If this function return false, the tree cannot be modified because there\n  /// is no reasonable way to produce the corresponding textual replacements.\n  /// This can happen when the node crosses macro expansion boundaries.\n  ///\n  /// Note that even if the node is not modifiable, its child nodes can be\n  /// modifiable.\n  bool canModify() const { return CanModify; }\n\n  const Tree *getParent() const { return Parent; }\n  Tree *getParent() { return Parent; }\n\n  const Node *getNextSibling() const { return NextSibling; }\n  Node *getNextSibling() { return NextSibling; }\n  const Node *getPreviousSibling() const { return PreviousSibling; }\n  Node *getPreviousSibling() { return PreviousSibling; }\n\n  /// Dumps the structure of a subtree. For debugging and testing purposes.\n  std::string dump(const SourceManager &SM) const;\n  /// Dumps the tokens forming this subtree.\n  std::string dumpTokens(const SourceManager &SM) const;\n\n  /// Asserts invariants on this node of the tree and its immediate children.\n  /// Will not recurse into the subtree. No-op if NDEBUG is set.\n  void assertInvariants() const;\n  /// Runs checkInvariants on all nodes in the subtree. No-op if NDEBUG is set.\n  void assertInvariantsRecursive() const;\n\nprivate:\n  // Tree is allowed to change the Parent link and Role.\n  friend class Tree;\n  // TreeBuilder is allowed to set the Original and CanModify flags.\n  friend class TreeBuilder;\n  // MutationsImpl sets roles and CanModify flag.\n  friend class MutationsImpl;\n  // FactoryImpl sets CanModify flag.\n  friend class FactoryImpl;\n\n  void setRole(NodeRole NR);\n\n  Tree *Parent;\n  Node *NextSibling;\n  Node *PreviousSibling;\n  unsigned Kind : 16;\n  unsigned Role : 8;\n  unsigned Original : 1;\n  unsigned CanModify : 1;\n};\n\n/// A leaf node points to a single token inside the expanded token stream.\nclass Leaf final : public Node {\npublic:\n  Leaf(const Token *T);\n  static bool classof(const Node *N);\n\n  const Token *getToken() const { return Tok; }\n\nprivate:\n  const Token *Tok;\n};\n\n/// A node that has children and represents a syntactic language construct.\nclass Tree : public Node {\n  /// Iterator over children (common base for const/non-const).\n  /// Not invalidated by tree mutations (holds a stable node pointer).\n  template <typename DerivedT, typename NodeT>\n  class ChildIteratorBase\n      : public llvm::iterator_facade_base<DerivedT, std::forward_iterator_tag,\n                                          NodeT> {\n  protected:\n    NodeT *N = nullptr;\n    using Base = ChildIteratorBase;\n\n  public:\n    ChildIteratorBase() = default;\n    explicit ChildIteratorBase(NodeT *N) : N(N) {}\n\n    bool operator==(const DerivedT &O) const { return O.N == N; }\n    NodeT &operator*() const { return *N; }\n    DerivedT &operator++() {\n      N = N->getNextSibling();\n      return *static_cast<DerivedT *>(this);\n    }\n\n    /// Truthy if valid (not past-the-end).\n    /// This allows: if (auto It = find_if(N.children(), ...) )\n    explicit operator bool() const { return N != nullptr; }\n    /// The element, or nullptr if past-the-end.\n    NodeT *asPointer() const { return N; }\n  };\n\npublic:\n  static bool classof(const Node *N);\n\n  Node *getFirstChild() { return FirstChild; }\n  const Node *getFirstChild() const { return FirstChild; }\n  Node *getLastChild() { return LastChild; }\n  const Node *getLastChild() const { return LastChild; }\n\n  const Leaf *findFirstLeaf() const;\n  Leaf *findFirstLeaf() {\n    return const_cast<Leaf *>(const_cast<const Tree *>(this)->findFirstLeaf());\n  }\n\n  const Leaf *findLastLeaf() const;\n  Leaf *findLastLeaf() {\n    return const_cast<Leaf *>(const_cast<const Tree *>(this)->findLastLeaf());\n  }\n\n  /// child_iterator is not invalidated by mutations.\n  struct ChildIterator : ChildIteratorBase<ChildIterator, Node> {\n    using Base::ChildIteratorBase;\n  };\n  struct ConstChildIterator\n      : ChildIteratorBase<ConstChildIterator, const Node> {\n    using Base::ChildIteratorBase;\n    ConstChildIterator() = default;\n    ConstChildIterator(const ChildIterator &I) : Base(I.asPointer()) {}\n  };\n\n  llvm::iterator_range<ChildIterator> getChildren() {\n    return {ChildIterator(getFirstChild()), ChildIterator()};\n  }\n  llvm::iterator_range<ConstChildIterator> getChildren() const {\n    return {ConstChildIterator(getFirstChild()), ConstChildIterator()};\n  }\n\n  /// Find the first node with a corresponding role.\n  const Node *findChild(NodeRole R) const;\n  Node *findChild(NodeRole R) {\n    return const_cast<Node *>(const_cast<const Tree *>(this)->findChild(R));\n  }\n\nprotected:\n  using Node::Node;\n\nprivate:\n  /// Append \\p Child to the list of children and sets the parent pointer.\n  /// A very low-level operation that does not check any invariants, only used\n  /// by TreeBuilder and FactoryImpl.\n  /// EXPECTS: Role != Detached.\n  void appendChildLowLevel(Node *Child, NodeRole Role);\n  /// Similar but prepends.\n  void prependChildLowLevel(Node *Child, NodeRole Role);\n\n  /// Like the previous overloads, but does not set role for \\p Child.\n  /// EXPECTS: Child->Role != Detached\n  void appendChildLowLevel(Node *Child);\n  void prependChildLowLevel(Node *Child);\n  friend class TreeBuilder;\n  friend class FactoryImpl;\n\n  /// Replace a range of children [Begin, End) with a list of\n  /// new nodes starting at \\p New.\n  /// Only used by MutationsImpl to implement higher-level mutation operations.\n  /// (!) \\p New can be null to model removal of the child range.\n  /// (!) \\p End can be null to model one past the end.\n  /// (!) \\p Begin can be null to model an append.\n  void replaceChildRangeLowLevel(Node *Begin, Node *End, Node *New);\n  friend class MutationsImpl;\n\n  Node *FirstChild = nullptr;\n  Node *LastChild = nullptr;\n};\n\n// Provide missing non_const == const overload.\n// iterator_facade_base requires == to be a member, but implicit conversions\n// don't work on the LHS of a member operator.\ninline bool operator==(const Tree::ConstChildIterator &A,\n                       const Tree::ConstChildIterator &B) {\n  return A.operator==(B);\n}\n\n/// A list of Elements separated or terminated by a fixed token.\n///\n/// This type models the following grammar construct:\n/// delimited-list(element, delimiter, termination, canBeEmpty)\nclass List : public Tree {\npublic:\n  template <typename Element> struct ElementAndDelimiter {\n    Element *element;\n    Leaf *delimiter;\n  };\n\n  enum class TerminationKind {\n    Terminated,\n    MaybeTerminated,\n    Separated,\n  };\n\n  using Tree::Tree;\n  static bool classof(const Node *N);\n  /// Returns the elements and corresponding delimiters. Missing elements\n  /// and delimiters are represented as null pointers.\n  ///\n  /// For example, in a separated list:\n  /// \"a, b, c\"  <=> [(\"a\" , \",\"), (\"b\" , \",\" ), (\"c\" , null)]\n  /// \"a,  , c\"  <=> [(\"a\" , \",\"), (null, \",\" ), (\"c\" , null)]\n  /// \"a, b  c\"  <=> [(\"a\" , \",\"), (\"b\" , null), (\"c\" , null)]\n  /// \"a, b,\"    <=> [(\"a\" , \",\"), (\"b\" , \",\" ), (null, null)]\n  ///\n  /// In a terminated or maybe-terminated list:\n  /// \"a; b; c;\" <=> [(\"a\" , \";\"), (\"b\" , \";\" ), (\"c\" , \";\" )]\n  /// \"a;  ; c;\" <=> [(\"a\" , \";\"), (null, \";\" ), (\"c\" , \";\" )]\n  /// \"a; b  c;\" <=> [(\"a\" , \";\"), (\"b\" , null), (\"c\" , \";\" )]\n  /// \"a; b; c\"  <=> [(\"a\" , \";\"), (\"b\" , \";\" ), (\"c\" , null)]\n  std::vector<ElementAndDelimiter<Node>> getElementsAsNodesAndDelimiters();\n\n  /// Returns the elements of the list. Missing elements are represented\n  /// as null pointers in the same way as in the return value of\n  /// `getElementsAsNodesAndDelimiters()`.\n  std::vector<Node *> getElementsAsNodes();\n\n  // These can't be implemented with the information we have!\n\n  /// Returns the appropriate delimiter for this list.\n  ///\n  /// Useful for discovering the correct delimiter to use when adding\n  /// elements to empty or one-element lists.\n  clang::tok::TokenKind getDelimiterTokenKind() const;\n\n  TerminationKind getTerminationKind() const;\n\n  /// Whether this list can be empty in syntactically and semantically correct\n  /// code.\n  ///\n  /// This list may be empty when the source code has errors even if\n  /// canBeEmpty() returns false.\n  bool canBeEmpty() const;\n};\n\n} // namespace syntax\n} // namespace clang\n\n#endif\n"}, "131": {"id": 131, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Option/OptSpecifier.h", "content": "//===- OptSpecifier.h - Option Specifiers -----------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_OPTION_OPTSPECIFIER_H\n#define LLVM_OPTION_OPTSPECIFIER_H\n\nnamespace llvm {\nnamespace opt {\n\nclass Option;\n\n/// OptSpecifier - Wrapper class for abstracting references to option IDs.\nclass OptSpecifier {\n  unsigned ID = 0;\n\npublic:\n  OptSpecifier() = default;\n  explicit OptSpecifier(bool) = delete;\n  /*implicit*/ OptSpecifier(unsigned ID) : ID(ID) {}\n  /*implicit*/ OptSpecifier(const Option *Opt);\n\n  bool isValid() const { return ID != 0; }\n\n  unsigned getID() const { return ID; }\n\n  bool operator==(OptSpecifier Opt) const { return ID == Opt.getID(); }\n  bool operator!=(OptSpecifier Opt) const { return !(*this == Opt); }\n};\n\n} // end namespace opt\n} // end namespace llvm\n\n#endif // LLVM_OPTION_OPTSPECIFIER_H\n"}, "143": {"id": 143, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "content": "//===--- JSON.h - JSON values, parsing and serialization -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===---------------------------------------------------------------------===//\n///\n/// \\file\n/// This file supports working with JSON data.\n///\n/// It comprises:\n///\n/// - classes which hold dynamically-typed parsed JSON structures\n///   These are value types that can be composed, inspected, and modified.\n///   See json::Value, and the related types json::Object and json::Array.\n///\n/// - functions to parse JSON text into Values, and to serialize Values to text.\n///   See parse(), operator<<, and format_provider.\n///\n/// - a convention and helpers for mapping between json::Value and user-defined\n///   types. See fromJSON(), ObjectMapper, and the class comment on Value.\n///\n/// - an output API json::OStream which can emit JSON without materializing\n///   all structures as json::Value.\n///\n/// Typically, JSON data would be read from an external source, parsed into\n/// a Value, and then converted into some native data structure before doing\n/// real work on it. (And vice versa when writing).\n///\n/// Other serialization mechanisms you may consider:\n///\n/// - YAML is also text-based, and more human-readable than JSON. It's a more\n///   complex format and data model, and YAML parsers aren't ubiquitous.\n///   YAMLParser.h is a streaming parser suitable for parsing large documents\n///   (including JSON, as YAML is a superset). It can be awkward to use\n///   directly. YAML I/O (YAMLTraits.h) provides data mapping that is more\n///   declarative than the toJSON/fromJSON conventions here.\n///\n/// - LLVM bitstream is a space- and CPU- efficient binary format. Typically it\n///   encodes LLVM IR (\"bitcode\"), but it can be a container for other data.\n///   Low-level reader/writer libraries are in Bitstream/Bitstream*.h\n///\n//===---------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_JSON_H\n#define LLVM_SUPPORT_JSON_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/FormatVariadic.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <map>\n\nnamespace llvm {\nnamespace json {\n\n// === String encodings ===\n//\n// JSON strings are character sequences (not byte sequences like std::string).\n// We need to know the encoding, and for simplicity only support UTF-8.\n//\n//   - When parsing, invalid UTF-8 is a syntax error like any other\n//\n//   - When creating Values from strings, callers must ensure they are UTF-8.\n//        with asserts on, invalid UTF-8 will crash the program\n//        with asserts off, we'll substitute the replacement character (U+FFFD)\n//     Callers can use json::isUTF8() and json::fixUTF8() for validation.\n//\n//   - When retrieving strings from Values (e.g. asString()), the result will\n//     always be valid UTF-8.\n\n/// Returns true if \\p S is valid UTF-8, which is required for use as JSON.\n/// If it returns false, \\p Offset is set to a byte offset near the first error.\nbool isUTF8(llvm::StringRef S, size_t *ErrOffset = nullptr);\n/// Replaces invalid UTF-8 sequences in \\p S with the replacement character\n/// (U+FFFD). The returned string is valid UTF-8.\n/// This is much slower than isUTF8, so test that first.\nstd::string fixUTF8(llvm::StringRef S);\n\nclass Array;\nclass ObjectKey;\nclass Value;\ntemplate <typename T> Value toJSON(const llvm::Optional<T> &Opt);\n\n/// An Object is a JSON object, which maps strings to heterogenous JSON values.\n/// It simulates DenseMap<ObjectKey, Value>. ObjectKey is a maybe-owned string.\nclass Object {\n  using Storage = DenseMap<ObjectKey, Value, llvm::DenseMapInfo<StringRef>>;\n  Storage M;\n\npublic:\n  using key_type = ObjectKey;\n  using mapped_type = Value;\n  using value_type = Storage::value_type;\n  using iterator = Storage::iterator;\n  using const_iterator = Storage::const_iterator;\n\n  Object() = default;\n  // KV is a trivial key-value struct for list-initialization.\n  // (using std::pair forces extra copies).\n  struct KV;\n  explicit Object(std::initializer_list<KV> Properties);\n\n  iterator begin() { return M.begin(); }\n  const_iterator begin() const { return M.begin(); }\n  iterator end() { return M.end(); }\n  const_iterator end() const { return M.end(); }\n\n  bool empty() const { return M.empty(); }\n  size_t size() const { return M.size(); }\n\n  void clear() { M.clear(); }\n  std::pair<iterator, bool> insert(KV E);\n  template <typename... Ts>\n  std::pair<iterator, bool> try_emplace(const ObjectKey &K, Ts &&... Args) {\n    return M.try_emplace(K, std::forward<Ts>(Args)...);\n  }\n  template <typename... Ts>\n  std::pair<iterator, bool> try_emplace(ObjectKey &&K, Ts &&... Args) {\n    return M.try_emplace(std::move(K), std::forward<Ts>(Args)...);\n  }\n  bool erase(StringRef K);\n  void erase(iterator I) { M.erase(I); }\n\n  iterator find(StringRef K) { return M.find_as(K); }\n  const_iterator find(StringRef K) const { return M.find_as(K); }\n  // operator[] acts as if Value was default-constructible as null.\n  Value &operator[](const ObjectKey &K);\n  Value &operator[](ObjectKey &&K);\n  // Look up a property, returning nullptr if it doesn't exist.\n  Value *get(StringRef K);\n  const Value *get(StringRef K) const;\n  // Typed accessors return None/nullptr if\n  //   - the property doesn't exist\n  //   - or it has the wrong type\n  llvm::Optional<std::nullptr_t> getNull(StringRef K) const;\n  llvm::Optional<bool> getBoolean(StringRef K) const;\n  llvm::Optional<double> getNumber(StringRef K) const;\n  llvm::Optional<int64_t> getInteger(StringRef K) const;\n  llvm::Optional<llvm::StringRef> getString(StringRef K) const;\n  const json::Object *getObject(StringRef K) const;\n  json::Object *getObject(StringRef K);\n  const json::Array *getArray(StringRef K) const;\n  json::Array *getArray(StringRef K);\n};\nbool operator==(const Object &LHS, const Object &RHS);\ninline bool operator!=(const Object &LHS, const Object &RHS) {\n  return !(LHS == RHS);\n}\n\n/// An Array is a JSON array, which contains heterogeneous JSON values.\n/// It simulates std::vector<Value>.\nclass Array {\n  std::vector<Value> V;\n\npublic:\n  using value_type = Value;\n  using iterator = std::vector<Value>::iterator;\n  using const_iterator = std::vector<Value>::const_iterator;\n\n  Array() = default;\n  explicit Array(std::initializer_list<Value> Elements);\n  template <typename Collection> explicit Array(const Collection &C) {\n    for (const auto &V : C)\n      emplace_back(V);\n  }\n\n  Value &operator[](size_t I) { return V[I]; }\n  const Value &operator[](size_t I) const { return V[I]; }\n  Value &front() { return V.front(); }\n  const Value &front() const { return V.front(); }\n  Value &back() { return V.back(); }\n  const Value &back() const { return V.back(); }\n  Value *data() { return V.data(); }\n  const Value *data() const { return V.data(); }\n\n  iterator begin() { return V.begin(); }\n  const_iterator begin() const { return V.begin(); }\n  iterator end() { return V.end(); }\n  const_iterator end() const { return V.end(); }\n\n  bool empty() const { return V.empty(); }\n  size_t size() const { return V.size(); }\n  void reserve(size_t S) { V.reserve(S); }\n\n  void clear() { V.clear(); }\n  void push_back(const Value &E) { V.push_back(E); }\n  void push_back(Value &&E) { V.push_back(std::move(E)); }\n  template <typename... Args> void emplace_back(Args &&... A) {\n    V.emplace_back(std::forward<Args>(A)...);\n  }\n  void pop_back() { V.pop_back(); }\n  // FIXME: insert() takes const_iterator since C++11, old libstdc++ disagrees.\n  iterator insert(iterator P, const Value &E) { return V.insert(P, E); }\n  iterator insert(iterator P, Value &&E) {\n    return V.insert(P, std::move(E));\n  }\n  template <typename It> iterator insert(iterator P, It A, It Z) {\n    return V.insert(P, A, Z);\n  }\n  template <typename... Args> iterator emplace(const_iterator P, Args &&... A) {\n    return V.emplace(P, std::forward<Args>(A)...);\n  }\n\n  friend bool operator==(const Array &L, const Array &R) { return L.V == R.V; }\n};\ninline bool operator!=(const Array &L, const Array &R) { return !(L == R); }\n\n/// A Value is an JSON value of unknown type.\n/// They can be copied, but should generally be moved.\n///\n/// === Composing values ===\n///\n/// You can implicitly construct Values from:\n///   - strings: std::string, SmallString, formatv, StringRef, char*\n///              (char*, and StringRef are references, not copies!)\n///   - numbers\n///   - booleans\n///   - null: nullptr\n///   - arrays: {\"foo\", 42.0, false}\n///   - serializable things: types with toJSON(const T&)->Value, found by ADL\n///\n/// They can also be constructed from object/array helpers:\n///   - json::Object is a type like map<ObjectKey, Value>\n///   - json::Array is a type like vector<Value>\n/// These can be list-initialized, or used to build up collections in a loop.\n/// json::ary(Collection) converts all items in a collection to Values.\n///\n/// === Inspecting values ===\n///\n/// Each Value is one of the JSON kinds:\n///   null    (nullptr_t)\n///   boolean (bool)\n///   number  (double or int64)\n///   string  (StringRef)\n///   array   (json::Array)\n///   object  (json::Object)\n///\n/// The kind can be queried directly, or implicitly via the typed accessors:\n///   if (Optional<StringRef> S = E.getAsString()\n///     assert(E.kind() == Value::String);\n///\n/// Array and Object also have typed indexing accessors for easy traversal:\n///   Expected<Value> E = parse(R\"( {\"options\": {\"font\": \"sans-serif\"}} )\");\n///   if (Object* O = E->getAsObject())\n///     if (Object* Opts = O->getObject(\"options\"))\n///       if (Optional<StringRef> Font = Opts->getString(\"font\"))\n///         assert(Opts->at(\"font\").kind() == Value::String);\n///\n/// === Converting JSON values to C++ types ===\n///\n/// The convention is to have a deserializer function findable via ADL:\n///     fromJSON(const json::Value&, T&, Path) -> bool\n///\n/// The return value indicates overall success, and Path is used for precise\n/// error reporting. (The Path::Root passed in at the top level fromJSON call\n/// captures any nested error and can render it in context).\n/// If conversion fails, fromJSON calls Path::report() and immediately returns.\n/// This ensures that the first fatal error survives.\n///\n/// Deserializers are provided for:\n///   - bool\n///   - int and int64_t\n///   - double\n///   - std::string\n///   - vector<T>, where T is deserializable\n///   - map<string, T>, where T is deserializable\n///   - Optional<T>, where T is deserializable\n/// ObjectMapper can help writing fromJSON() functions for object types.\n///\n/// For conversion in the other direction, the serializer function is:\n///    toJSON(const T&) -> json::Value\n/// If this exists, then it also allows constructing Value from T, and can\n/// be used to serialize vector<T>, map<string, T>, and Optional<T>.\n///\n/// === Serialization ===\n///\n/// Values can be serialized to JSON:\n///   1) raw_ostream << Value                    // Basic formatting.\n///   2) raw_ostream << formatv(\"{0}\", Value)    // Basic formatting.\n///   3) raw_ostream << formatv(\"{0:2}\", Value)  // Pretty-print with indent 2.\n///\n/// And parsed:\n///   Expected<Value> E = json::parse(\"[1, 2, null]\");\n///   assert(E && E->kind() == Value::Array);\nclass Value {\npublic:\n  enum Kind {\n    Null,\n    Boolean,\n    /// Number values can store both int64s and doubles at full precision,\n    /// depending on what they were constructed/parsed from.\n    Number,\n    String,\n    Array,\n    Object,\n  };\n\n  // It would be nice to have Value() be null. But that would make {} null too.\n  Value(const Value &M) { copyFrom(M); }\n  Value(Value &&M) { moveFrom(std::move(M)); }\n  Value(std::initializer_list<Value> Elements);\n  Value(json::Array &&Elements) : Type(T_Array) {\n    create<json::Array>(std::move(Elements));\n  }\n  template <typename Elt>\n  Value(const std::vector<Elt> &C) : Value(json::Array(C)) {}\n  Value(json::Object &&Properties) : Type(T_Object) {\n    create<json::Object>(std::move(Properties));\n  }\n  template <typename Elt>\n  Value(const std::map<std::string, Elt> &C) : Value(json::Object(C)) {}\n  // Strings: types with value semantics. Must be valid UTF-8.\n  Value(std::string V) : Type(T_String) {\n    if (LLVM_UNLIKELY(!isUTF8(V))) {\n      assert(false && \"Invalid UTF-8 in value used as JSON\");\n      V = fixUTF8(std::move(V));\n    }\n    create<std::string>(std::move(V));\n  }\n  Value(const llvm::SmallVectorImpl<char> &V)\n      : Value(std::string(V.begin(), V.end())) {}\n  Value(const llvm::formatv_object_base &V) : Value(V.str()) {}\n  // Strings: types with reference semantics. Must be valid UTF-8.\n  Value(StringRef V) : Type(T_StringRef) {\n    create<llvm::StringRef>(V);\n    if (LLVM_UNLIKELY(!isUTF8(V))) {\n      assert(false && \"Invalid UTF-8 in value used as JSON\");\n      *this = Value(fixUTF8(V));\n    }\n  }\n  Value(const char *V) : Value(StringRef(V)) {}\n  Value(std::nullptr_t) : Type(T_Null) {}\n  // Boolean (disallow implicit conversions).\n  // (The last template parameter is a dummy to keep templates distinct.)\n  template <typename T,\n            typename = std::enable_if_t<std::is_same<T, bool>::value>,\n            bool = false>\n  Value(T B) : Type(T_Boolean) {\n    create<bool>(B);\n  }\n  // Integers (except boolean). Must be non-narrowing convertible to int64_t.\n  template <typename T, typename = std::enable_if_t<std::is_integral<T>::value>,\n            typename = std::enable_if_t<!std::is_same<T, bool>::value>>\n  Value(T I) : Type(T_Integer) {\n    create<int64_t>(int64_t{I});\n  }\n  // Floating point. Must be non-narrowing convertible to double.\n  template <typename T,\n            typename = std::enable_if_t<std::is_floating_point<T>::value>,\n            double * = nullptr>\n  Value(T D) : Type(T_Double) {\n    create<double>(double{D});\n  }\n  // Serializable types: with a toJSON(const T&)->Value function, found by ADL.\n  template <typename T,\n            typename = std::enable_if_t<std::is_same<\n                Value, decltype(toJSON(*(const T *)nullptr))>::value>,\n            Value * = nullptr>\n  Value(const T &V) : Value(toJSON(V)) {}\n\n  Value &operator=(const Value &M) {\n    destroy();\n    copyFrom(M);\n    return *this;\n  }\n  Value &operator=(Value &&M) {\n    destroy();\n    moveFrom(std::move(M));\n    return *this;\n  }\n  ~Value() { destroy(); }\n\n  Kind kind() const {\n    switch (Type) {\n    case T_Null:\n      return Null;\n    case T_Boolean:\n      return Boolean;\n    case T_Double:\n    case T_Integer:\n      return Number;\n    case T_String:\n    case T_StringRef:\n      return String;\n    case T_Object:\n      return Object;\n    case T_Array:\n      return Array;\n    }\n    llvm_unreachable(\"Unknown kind\");\n  }\n\n  // Typed accessors return None/nullptr if the Value is not of this type.\n  llvm::Optional<std::nullptr_t> getAsNull() const {\n    if (LLVM_LIKELY(Type == T_Null))\n      return nullptr;\n    return llvm::None;\n  }\n  llvm::Optional<bool> getAsBoolean() const {\n    if (LLVM_LIKELY(Type == T_Boolean))\n      return as<bool>();\n    return llvm::None;\n  }\n  llvm::Optional<double> getAsNumber() const {\n    if (LLVM_LIKELY(Type == T_Double))\n      return as<double>();\n    if (LLVM_LIKELY(Type == T_Integer))\n      return as<int64_t>();\n    return llvm::None;\n  }\n  // Succeeds if the Value is a Number, and exactly representable as int64_t.\n  llvm::Optional<int64_t> getAsInteger() const {\n    if (LLVM_LIKELY(Type == T_Integer))\n      return as<int64_t>();\n    if (LLVM_LIKELY(Type == T_Double)) {\n      double D = as<double>();\n      if (LLVM_LIKELY(std::modf(D, &D) == 0.0 &&\n                      D >= double(std::numeric_limits<int64_t>::min()) &&\n                      D <= double(std::numeric_limits<int64_t>::max())))\n        return D;\n    }\n    return llvm::None;\n  }\n  llvm::Optional<llvm::StringRef> getAsString() const {\n    if (Type == T_String)\n      return llvm::StringRef(as<std::string>());\n    if (LLVM_LIKELY(Type == T_StringRef))\n      return as<llvm::StringRef>();\n    return llvm::None;\n  }\n  const json::Object *getAsObject() const {\n    return LLVM_LIKELY(Type == T_Object) ? &as<json::Object>() : nullptr;\n  }\n  json::Object *getAsObject() {\n    return LLVM_LIKELY(Type == T_Object) ? &as<json::Object>() : nullptr;\n  }\n  const json::Array *getAsArray() const {\n    return LLVM_LIKELY(Type == T_Array) ? &as<json::Array>() : nullptr;\n  }\n  json::Array *getAsArray() {\n    return LLVM_LIKELY(Type == T_Array) ? &as<json::Array>() : nullptr;\n  }\n\nprivate:\n  void destroy();\n  void copyFrom(const Value &M);\n  // We allow moving from *const* Values, by marking all members as mutable!\n  // This hack is needed to support initializer-list syntax efficiently.\n  // (std::initializer_list<T> is a container of const T).\n  void moveFrom(const Value &&M);\n  friend class Array;\n  friend class Object;\n\n  template <typename T, typename... U> void create(U &&... V) {\n    new (reinterpret_cast<T *>(&Union)) T(std::forward<U>(V)...);\n  }\n  template <typename T> T &as() const {\n    // Using this two-step static_cast via void * instead of reinterpret_cast\n    // silences a -Wstrict-aliasing false positive from GCC6 and earlier.\n    void *Storage = static_cast<void *>(&Union);\n    return *static_cast<T *>(Storage);\n  }\n\n  friend class OStream;\n\n  enum ValueType : char {\n    T_Null,\n    T_Boolean,\n    T_Double,\n    T_Integer,\n    T_StringRef,\n    T_String,\n    T_Object,\n    T_Array,\n  };\n  // All members mutable, see moveFrom().\n  mutable ValueType Type;\n  mutable llvm::AlignedCharArrayUnion<bool, double, int64_t, llvm::StringRef,\n                                      std::string, json::Array, json::Object>\n      Union;\n  friend bool operator==(const Value &, const Value &);\n};\n\nbool operator==(const Value &, const Value &);\ninline bool operator!=(const Value &L, const Value &R) { return !(L == R); }\n\n/// ObjectKey is a used to capture keys in Object. Like Value but:\n///   - only strings are allowed\n///   - it's optimized for the string literal case (Owned == nullptr)\n/// Like Value, strings must be UTF-8. See isUTF8 documentation for details.\nclass ObjectKey {\npublic:\n  ObjectKey(const char *S) : ObjectKey(StringRef(S)) {}\n  ObjectKey(std::string S) : Owned(new std::string(std::move(S))) {\n    if (LLVM_UNLIKELY(!isUTF8(*Owned))) {\n      assert(false && \"Invalid UTF-8 in value used as JSON\");\n      *Owned = fixUTF8(std::move(*Owned));\n    }\n    Data = *Owned;\n  }\n  ObjectKey(llvm::StringRef S) : Data(S) {\n    if (LLVM_UNLIKELY(!isUTF8(Data))) {\n      assert(false && \"Invalid UTF-8 in value used as JSON\");\n      *this = ObjectKey(fixUTF8(S));\n    }\n  }\n  ObjectKey(const llvm::SmallVectorImpl<char> &V)\n      : ObjectKey(std::string(V.begin(), V.end())) {}\n  ObjectKey(const llvm::formatv_object_base &V) : ObjectKey(V.str()) {}\n\n  ObjectKey(const ObjectKey &C) { *this = C; }\n  ObjectKey(ObjectKey &&C) : ObjectKey(static_cast<const ObjectKey &&>(C)) {}\n  ObjectKey &operator=(const ObjectKey &C) {\n    if (C.Owned) {\n      Owned.reset(new std::string(*C.Owned));\n      Data = *Owned;\n    } else {\n      Data = C.Data;\n    }\n    return *this;\n  }\n  ObjectKey &operator=(ObjectKey &&) = default;\n\n  operator llvm::StringRef() const { return Data; }\n  std::string str() const { return Data.str(); }\n\nprivate:\n  // FIXME: this is unneccesarily large (3 pointers). Pointer + length + owned\n  // could be 2 pointers at most.\n  std::unique_ptr<std::string> Owned;\n  llvm::StringRef Data;\n};\n\ninline bool operator==(const ObjectKey &L, const ObjectKey &R) {\n  return llvm::StringRef(L) == llvm::StringRef(R);\n}\ninline bool operator!=(const ObjectKey &L, const ObjectKey &R) {\n  return !(L == R);\n}\ninline bool operator<(const ObjectKey &L, const ObjectKey &R) {\n  return StringRef(L) < StringRef(R);\n}\n\nstruct Object::KV {\n  ObjectKey K;\n  Value V;\n};\n\ninline Object::Object(std::initializer_list<KV> Properties) {\n  for (const auto &P : Properties) {\n    auto R = try_emplace(P.K, nullptr);\n    if (R.second)\n      R.first->getSecond().moveFrom(std::move(P.V));\n  }\n}\ninline std::pair<Object::iterator, bool> Object::insert(KV E) {\n  return try_emplace(std::move(E.K), std::move(E.V));\n}\ninline bool Object::erase(StringRef K) {\n  return M.erase(ObjectKey(K));\n}\n\n/// A \"cursor\" marking a position within a Value.\n/// The Value is a tree, and this is the path from the root to the current node.\n/// This is used to associate errors with particular subobjects.\nclass Path {\npublic:\n  class Root;\n\n  /// Records that the value at the current path is invalid.\n  /// Message is e.g. \"expected number\" and becomes part of the final error.\n  /// This overwrites any previously written error message in the root.\n  void report(llvm::StringLiteral Message);\n\n  /// The root may be treated as a Path.\n  Path(Root &R) : Parent(nullptr), Seg(&R) {}\n  /// Derives a path for an array element: this[Index]\n  Path index(unsigned Index) const { return Path(this, Segment(Index)); }\n  /// Derives a path for an object field: this.Field\n  Path field(StringRef Field) const { return Path(this, Segment(Field)); }\n\nprivate:\n  /// One element in a JSON path: an object field (.foo) or array index [27].\n  /// Exception: the root Path encodes a pointer to the Path::Root.\n  class Segment {\n    uintptr_t Pointer;\n    unsigned Offset;\n\n  public:\n    Segment() = default;\n    Segment(Root *R) : Pointer(reinterpret_cast<uintptr_t>(R)) {}\n    Segment(llvm::StringRef Field)\n        : Pointer(reinterpret_cast<uintptr_t>(Field.data())),\n          Offset(static_cast<unsigned>(Field.size())) {}\n    Segment(unsigned Index) : Pointer(0), Offset(Index) {}\n\n    bool isField() const { return Pointer != 0; }\n    StringRef field() const {\n      return StringRef(reinterpret_cast<const char *>(Pointer), Offset);\n    }\n    unsigned index() const { return Offset; }\n    Root *root() const { return reinterpret_cast<Root *>(Pointer); }\n  };\n\n  const Path *Parent;\n  Segment Seg;\n\n  Path(const Path *Parent, Segment S) : Parent(Parent), Seg(S) {}\n};\n\n/// The root is the trivial Path to the root value.\n/// It also stores the latest reported error and the path where it occurred.\nclass Path::Root {\n  llvm::StringRef Name;\n  llvm::StringLiteral ErrorMessage;\n  std::vector<Path::Segment> ErrorPath; // Only valid in error state. Reversed.\n\n  friend void Path::report(llvm::StringLiteral Message);\n\npublic:\n  Root(llvm::StringRef Name = \"\") : Name(Name), ErrorMessage(\"\") {}\n  // No copy/move allowed as there are incoming pointers.\n  Root(Root &&) = delete;\n  Root &operator=(Root &&) = delete;\n  Root(const Root &) = delete;\n  Root &operator=(const Root &) = delete;\n\n  /// Returns the last error reported, or else a generic error.\n  Error getError() const;\n  /// Print the root value with the error shown inline as a comment.\n  /// Unrelated parts of the value are elided for brevity, e.g.\n  ///   {\n  ///      \"id\": 42,\n  ///      \"name\": /* expected string */ null,\n  ///      \"properties\": { ... }\n  ///   }\n  void printErrorContext(const Value &, llvm::raw_ostream &) const;\n};\n\n// Standard deserializers are provided for primitive types.\n// See comments on Value.\ninline bool fromJSON(const Value &E, std::string &Out, Path P) {\n  if (auto S = E.getAsString()) {\n    Out = std::string(*S);\n    return true;\n  }\n  P.report(\"expected string\");\n  return false;\n}\ninline bool fromJSON(const Value &E, int &Out, Path P) {\n  if (auto S = E.getAsInteger()) {\n    Out = *S;\n    return true;\n  }\n  P.report(\"expected integer\");\n  return false;\n}\ninline bool fromJSON(const Value &E, int64_t &Out, Path P) {\n  if (auto S = E.getAsInteger()) {\n    Out = *S;\n    return true;\n  }\n  P.report(\"expected integer\");\n  return false;\n}\ninline bool fromJSON(const Value &E, double &Out, Path P) {\n  if (auto S = E.getAsNumber()) {\n    Out = *S;\n    return true;\n  }\n  P.report(\"expected number\");\n  return false;\n}\ninline bool fromJSON(const Value &E, bool &Out, Path P) {\n  if (auto S = E.getAsBoolean()) {\n    Out = *S;\n    return true;\n  }\n  P.report(\"expected boolean\");\n  return false;\n}\ninline bool fromJSON(const Value &E, std::nullptr_t &Out, Path P) {\n  if (auto S = E.getAsNull()) {\n    Out = *S;\n    return true;\n  }\n  P.report(\"expected null\");\n  return false;\n}\ntemplate <typename T>\nbool fromJSON(const Value &E, llvm::Optional<T> &Out, Path P) {\n  if (E.getAsNull()) {\n    Out = llvm::None;\n    return true;\n  }\n  T Result;\n  if (!fromJSON(E, Result, P))\n    return false;\n  Out = std::move(Result);\n  return true;\n}\ntemplate <typename T>\nbool fromJSON(const Value &E, std::vector<T> &Out, Path P) {\n  if (auto *A = E.getAsArray()) {\n    Out.clear();\n    Out.resize(A->size());\n    for (size_t I = 0; I < A->size(); ++I)\n      if (!fromJSON((*A)[I], Out[I], P.index(I)))\n        return false;\n    return true;\n  }\n  P.report(\"expected array\");\n  return false;\n}\ntemplate <typename T>\nbool fromJSON(const Value &E, std::map<std::string, T> &Out, Path P) {\n  if (auto *O = E.getAsObject()) {\n    Out.clear();\n    for (const auto &KV : *O)\n      if (!fromJSON(KV.second, Out[std::string(llvm::StringRef(KV.first))],\n                    P.field(KV.first)))\n        return false;\n    return true;\n  }\n  P.report(\"expected object\");\n  return false;\n}\n\n// Allow serialization of Optional<T> for supported T.\ntemplate <typename T> Value toJSON(const llvm::Optional<T> &Opt) {\n  return Opt ? Value(*Opt) : Value(nullptr);\n}\n\n/// Helper for mapping JSON objects onto protocol structs.\n///\n/// Example:\n/// \\code\n///   bool fromJSON(const Value &E, MyStruct &R, Path P) {\n///     ObjectMapper O(E, P);\n///     // When returning false, error details were already reported.\n///     return O && O.map(\"mandatory_field\", R.MandatoryField) &&\n///         O.mapOptional(\"optional_field\", R.OptionalField);\n///   }\n/// \\endcode\nclass ObjectMapper {\npublic:\n  /// If O is not an object, this mapper is invalid and an error is reported.\n  ObjectMapper(const Value &E, Path P) : O(E.getAsObject()), P(P) {\n    if (!O)\n      P.report(\"expected object\");\n  }\n\n  /// True if the expression is an object.\n  /// Must be checked before calling map().\n  operator bool() const { return O; }\n\n  /// Maps a property to a field.\n  /// If the property is missing or invalid, reports an error.\n  template <typename T> bool map(StringLiteral Prop, T &Out) {\n    assert(*this && \"Must check this is an object before calling map()\");\n    if (const Value *E = O->get(Prop))\n      return fromJSON(*E, Out, P.field(Prop));\n    P.field(Prop).report(\"missing value\");\n    return false;\n  }\n\n  /// Maps a property to a field, if it exists.\n  /// If the property exists and is invalid, reports an error.\n  /// (Optional requires special handling, because missing keys are OK).\n  template <typename T> bool map(StringLiteral Prop, llvm::Optional<T> &Out) {\n    assert(*this && \"Must check this is an object before calling map()\");\n    if (const Value *E = O->get(Prop))\n      return fromJSON(*E, Out, P.field(Prop));\n    Out = llvm::None;\n    return true;\n  }\n\n  /// Maps a property to a field, if it exists.\n  /// If the property exists and is invalid, reports an error.\n  /// If the property does not exist, Out is unchanged.\n  template <typename T> bool mapOptional(StringLiteral Prop, T &Out) {\n    assert(*this && \"Must check this is an object before calling map()\");\n    if (const Value *E = O->get(Prop))\n      return fromJSON(*E, Out, P.field(Prop));\n    return true;\n  }\n\nprivate:\n  const Object *O;\n  Path P;\n};\n\n/// Parses the provided JSON source, or returns a ParseError.\n/// The returned Value is self-contained and owns its strings (they do not refer\n/// to the original source).\nllvm::Expected<Value> parse(llvm::StringRef JSON);\n\nclass ParseError : public llvm::ErrorInfo<ParseError> {\n  const char *Msg;\n  unsigned Line, Column, Offset;\n\npublic:\n  static char ID;\n  ParseError(const char *Msg, unsigned Line, unsigned Column, unsigned Offset)\n      : Msg(Msg), Line(Line), Column(Column), Offset(Offset) {}\n  void log(llvm::raw_ostream &OS) const override {\n    OS << llvm::formatv(\"[{0}:{1}, byte={2}]: {3}\", Line, Column, Offset, Msg);\n  }\n  std::error_code convertToErrorCode() const override {\n    return llvm::inconvertibleErrorCode();\n  }\n};\n\n/// Version of parse() that converts the parsed value to the type T.\n/// RootName describes the root object and is used in error messages.\ntemplate <typename T>\nExpected<T> parse(const llvm::StringRef &JSON, const char *RootName = \"\") {\n  auto V = parse(JSON);\n  if (!V)\n    return V.takeError();\n  Path::Root R(RootName);\n  T Result;\n  if (fromJSON(*V, Result, R))\n    return std::move(Result);\n  return R.getError();\n}\n\n/// json::OStream allows writing well-formed JSON without materializing\n/// all structures as json::Value ahead of time.\n/// It's faster, lower-level, and less safe than OS << json::Value.\n/// It also allows emitting more constructs, such as comments.\n///\n/// Only one \"top-level\" object can be written to a stream.\n/// Simplest usage involves passing lambdas (Blocks) to fill in containers:\n///\n///   json::OStream J(OS);\n///   J.array([&]{\n///     for (const Event &E : Events)\n///       J.object([&] {\n///         J.attribute(\"timestamp\", int64_t(E.Time));\n///         J.attributeArray(\"participants\", [&] {\n///           for (const Participant &P : E.Participants)\n///             J.value(P.toString());\n///         });\n///       });\n///   });\n///\n/// This would produce JSON like:\n///\n///   [\n///     {\n///       \"timestamp\": 19287398741,\n///       \"participants\": [\n///         \"King Kong\",\n///         \"Miley Cyrus\",\n///         \"Cleopatra\"\n///       ]\n///     },\n///     ...\n///   ]\n///\n/// The lower level begin/end methods (arrayBegin()) are more flexible but\n/// care must be taken to pair them correctly:\n///\n///   json::OStream J(OS);\n//    J.arrayBegin();\n///   for (const Event &E : Events) {\n///     J.objectBegin();\n///     J.attribute(\"timestamp\", int64_t(E.Time));\n///     J.attributeBegin(\"participants\");\n///     for (const Participant &P : E.Participants)\n///       J.value(P.toString());\n///     J.attributeEnd();\n///     J.objectEnd();\n///   }\n///   J.arrayEnd();\n///\n/// If the call sequence isn't valid JSON, asserts will fire in debug mode.\n/// This can be mismatched begin()/end() pairs, trying to emit attributes inside\n/// an array, and so on.\n/// With asserts disabled, this is undefined behavior.\nclass OStream {\n public:\n  using Block = llvm::function_ref<void()>;\n  // If IndentSize is nonzero, output is pretty-printed.\n  explicit OStream(llvm::raw_ostream &OS, unsigned IndentSize = 0)\n      : OS(OS), IndentSize(IndentSize) {\n    Stack.emplace_back();\n  }\n  ~OStream() {\n    assert(Stack.size() == 1 && \"Unmatched begin()/end()\");\n    assert(Stack.back().Ctx == Singleton);\n    assert(Stack.back().HasValue && \"Did not write top-level value\");\n  }\n\n  /// Flushes the underlying ostream. OStream does not buffer internally.\n  void flush() { OS.flush(); }\n\n  // High level functions to output a value.\n  // Valid at top-level (exactly once), in an attribute value (exactly once),\n  // or in an array (any number of times).\n\n  /// Emit a self-contained value (number, string, vector<string> etc).\n  void value(const Value &V);\n  /// Emit an array whose elements are emitted in the provided Block.\n  void array(Block Contents) {\n    arrayBegin();\n    Contents();\n    arrayEnd();\n  }\n  /// Emit an object whose elements are emitted in the provided Block.\n  void object(Block Contents) {\n    objectBegin();\n    Contents();\n    objectEnd();\n  }\n  /// Emit an externally-serialized value.\n  /// The caller must write exactly one valid JSON value to the provided stream.\n  /// No validation or formatting of this value occurs.\n  void rawValue(llvm::function_ref<void(raw_ostream &)> Contents) {\n    rawValueBegin();\n    Contents(OS);\n    rawValueEnd();\n  }\n  void rawValue(llvm::StringRef Contents) {\n    rawValue([&](raw_ostream &OS) { OS << Contents; });\n  }\n  /// Emit a JavaScript comment associated with the next printed value.\n  /// The string must be valid until the next attribute or value is emitted.\n  /// Comments are not part of standard JSON, and many parsers reject them!\n  void comment(llvm::StringRef);\n\n  // High level functions to output object attributes.\n  // Valid only within an object (any number of times).\n\n  /// Emit an attribute whose value is self-contained (number, vector<int> etc).\n  void attribute(llvm::StringRef Key, const Value& Contents) {\n    attributeImpl(Key, [&] { value(Contents); });\n  }\n  /// Emit an attribute whose value is an array with elements from the Block.\n  void attributeArray(llvm::StringRef Key, Block Contents) {\n    attributeImpl(Key, [&] { array(Contents); });\n  }\n  /// Emit an attribute whose value is an object with attributes from the Block.\n  void attributeObject(llvm::StringRef Key, Block Contents) {\n    attributeImpl(Key, [&] { object(Contents); });\n  }\n\n  // Low-level begin/end functions to output arrays, objects, and attributes.\n  // Must be correctly paired. Allowed contexts are as above.\n\n  void arrayBegin();\n  void arrayEnd();\n  void objectBegin();\n  void objectEnd();\n  void attributeBegin(llvm::StringRef Key);\n  void attributeEnd();\n  raw_ostream &rawValueBegin();\n  void rawValueEnd();\n\nprivate:\n  void attributeImpl(llvm::StringRef Key, Block Contents) {\n    attributeBegin(Key);\n    Contents();\n    attributeEnd();\n  }\n\n  void valueBegin();\n  void flushComment();\n  void newline();\n\n  enum Context {\n    Singleton, // Top level, or object attribute.\n    Array,\n    Object,\n    RawValue, // External code writing a value to OS directly.\n  };\n  struct State {\n    Context Ctx = Singleton;\n    bool HasValue = false;\n  };\n  llvm::SmallVector<State, 16> Stack; // Never empty.\n  llvm::StringRef PendingComment;\n  llvm::raw_ostream &OS;\n  unsigned IndentSize;\n  unsigned Indent = 0;\n};\n\n/// Serializes this Value to JSON, writing it to the provided stream.\n/// The formatting is compact (no extra whitespace) and deterministic.\n/// For pretty-printing, use the formatv() format_provider below.\ninline llvm::raw_ostream &operator<<(llvm::raw_ostream &OS, const Value &V) {\n  OStream(OS).value(V);\n  return OS;\n}\n} // namespace json\n\n/// Allow printing json::Value with formatv().\n/// The default style is basic/compact formatting, like operator<<.\n/// A format string like formatv(\"{0:2}\", Value) pretty-prints with indent 2.\ntemplate <> struct format_provider<llvm::json::Value> {\n  static void format(const llvm::json::Value &, raw_ostream &, StringRef);\n};\n} // namespace llvm\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 7, "file": 1, "line": 46}, "message": "'CollectMainFileMacros' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/CollectMacros.h", "reportHash": "0c84805689b2d7ffe4a9b459d21bcb6e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 2, "line": 64}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 2, "line": 64}, "message": "'ArgStripper' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/CompileCommands.h", "reportHash": "95c4f495bcb69ccfe927988502aaea0a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 3, "line": 29}, "message": "'IgnoreDiagnostics' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Compiler.h", "reportHash": "b5bbf34b221af6524a50b2eaa7ff022a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 3, "line": 44}, "message": "'ParseInputs' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Compiler.h", "reportHash": "ce0a97b46283c2cd371518c3e4fc86b3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 4, "line": 55}, "message": "'DiagBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Diagnostics.h", "reportHash": "49e94995ee2be84e28e7c3a4bd26da5b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 4, "line": 74}, "message": "'Fix' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Diagnostics.h", "reportHash": "2a6aa2beb4c5f4d4cace13c206001475", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 4, "line": 87}, "message": "'Diag' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Diagnostics.h", "reportHash": "0def37622588c0563491022818e2eef3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 4, "line": 124}, "message": "'StoreDiags' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Diagnostics.h", "reportHash": "853774f817f12a74b864ce2d2dac86be", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 5, "line": 38}, "message": "'PreambleFileStatusCache' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/FS.h", "reportHash": "3dbfb4f945ecca389c747b7748e4d14e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 6, "line": 29}, "message": "'ProjectInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/GlobalCompilationDatabase.h", "reportHash": "1a3147c79d486b6394487522fe4150eb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 6, "line": 70}, "message": "'DelegatingCDB' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/GlobalCompilationDatabase.h", "reportHash": "e2b56a0cbe1e916a4df50f5df2e863d4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 6, "line": 95}, "message": "'Options' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/GlobalCompilationDatabase.h", "reportHash": "eb0c70206cbe7428cc07523de05b955a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 6, "line": 174}, "message": "'OverlayCDB' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/GlobalCompilationDatabase.h", "reportHash": "1d4c7a871657d08fd430edf1b469dec5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 7, "line": 35}, "message": "'HeaderFile' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Headers.h", "reportHash": "0efaf644ba611d2cf5b9b022b353d1fa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 7, "line": 54}, "message": "'Inclusion' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Headers.h", "reportHash": "c32548e8de10277e896f2b85ca14082b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 8, "line": 60}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 8, "line": 60}, "message": "'ParsedAST' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/ParsedAST.h", "reportHash": "a6e10d25b47c80f1fd7ec3e16b6a2130", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 9, "line": 49}, "message": "'PreambleData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Preamble.h", "reportHash": "072d7c253665ca6134580567650dd1e8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 99}, "message": "'PreamblePatch' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Preamble.h", "reportHash": "a1914216f9dd291b75aab9966756999a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 57}, "message": "'LSPError' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "b0b1e16d80113acbb939d611869611e0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 75}, "message": "'URIForFile' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "ad183846368ff8455ffeb642b2638256", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 122}, "message": "'TextDocumentIdentifier' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "670986aa2ab9a0dda35c1fb7d0a28fa8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 130}, "message": "'VersionedTextDocumentIdentifier' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "95348d5544c8cdb9d1ee9218fea53b42", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 176}, "message": "'Range' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "766ce459296d314f34932c51c38582a3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 202}, "message": "'Location' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "3bc04b7122863bfb13cf6400c2c7d57c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 222}, "message": "'TextEdit' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "2a8f581b42add4b05bc4973ca11079fa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 238}, "message": "'TextDocumentItem' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "fa462f5d3f446d50c93a4fb8e1579269", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 488}, "message": "'ClangdCompileCommand' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "bac5062bd4b4b97be7fc69939dd874ee", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 577}, "message": "'WorkDoneProgressBegin' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "4e31c7cb2761996d7b8dbb9f74de2276", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 603}, "message": "'WorkDoneProgressReport' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "cc23f713b5fc49885eb106b62f26e8a0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 656}, "message": "'ShowMessageParams' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "bed67b7215135abbdc6ecebe57d99945", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 685}, "message": "'TextDocumentContentChangeEvent' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "27c2b8770f9b50a7b83c5c6e6e7e95fd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 698}, "message": "'DidChangeTextDocumentParams' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "772e7535d99811e4a0186909163c0eac", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 772}, "message": "'DocumentOnTypeFormattingParams' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "e5a4e10301ce187a37852051b34d181e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 802}, "message": "'DiagnosticRelatedInformation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "1d3eaff5777c55b66818f6f47d30d4ce", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 811}, "message": "'Diagnostic' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "f71338933121cc53b08cb2ca6e481457", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 859}, "message": "'PublishDiagnosticsParams' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "11ca05ea812455c19f405cdc16406aac", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 912}, "message": "'TweakArgs' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "e4104c179d18947795bdc311d7e31e1d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 923}, "message": "'ExecuteCommandParams' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "6cc5611a952acef4f3b6a2e5760209dc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 934}, "message": "'Command' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "9134c6669a675577e2ce5f6f1b63d168", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 944}, "message": "'CodeAction' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "8b7c16dd339a7fd9dc65cbec3fdef87d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 978}, "message": "'DocumentSymbol' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "961514df467a4cc4a86ffde9dcc5c8d2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 1009}, "message": "'SymbolInformation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "3d88ab38230ac4689bdab3f797b70250", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 1035}, "message": "'SymbolDetails' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "05dc6de0931753b3a554c94eb06cc30e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 1054}, "message": "'WorkspaceSymbolParams' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "3c732d6150744f251828fb2d0793f35d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 1094}, "message": "'CompletionContext' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "f4fc7b2058699c9b39eb69c3deb6735e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 1108}, "message": "'MarkupContent' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "348e888518f26814d96c2ed4695f28b9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 1142}, "message": "'CompletionItem' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "176a57a26297906160c3281f825654c7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 1221}, "message": "'ParameterInformation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "37ce6b90fa63e2e6361149a9bd56b1d5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 1238}, "message": "'SignatureInformation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "038a46cf7ff024d9b809f2da90caba97", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 1274}, "message": "'RenameParams' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "1f082361cc62e2daccdcd4064184e7c4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 1331}, "message": "'TypeHierarchyItem' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "d4a4722df8876126b8d1acdf24660fdb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 1399}, "message": "'CallHierarchyItem' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "504370e52536e24d7eeb0cf4157e0f92", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 1480}, "message": "'FileStatus' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "a70fa4b788b864b622a527b1f2c12f2d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 1493}, "message": "'SemanticToken' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "7e2d27b07257a43021475e6edfe691f4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 1509}, "message": "'SemanticTokens' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "b40e21223fcd62aa90600c3f54f63231", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 1531}, "message": "'SemanticTokensDeltaParams' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "32a5d78086228888a4fae1f0fb3199fb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 1553}, "message": "'SemanticTokensOrDelta' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "709e61c6a7b36c5e3c5e6b2a47272b67", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 1572}, "message": "'SelectionRange' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "4f84bfe72c78dee743bc4f327948ad9c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 1628}, "message": "'FoldingRange' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "09a4497ada2c39f9595464220f5829bb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 1672}, "message": "'ASTNode' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "d7531330a2cf9ae303797b67b746858f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 11, "line": 102}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 11, "line": 102}, "message": "'SelectionTree' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Selection.h", "reportHash": "0e177ac7a0744c79e4282d47fd926ce1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 12, "line": 180}, "message": "'Edit' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/SourceCode.h", "reportHash": "5dff82bfff5728e5ccd55434e840c4e9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 12, "line": 283}, "message": "'EligibleRegion' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/SourceCode.h", "reportHash": "d6b4858fd4632db4c1566f0be441cb59", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 13, "line": 28}, "message": "'URI' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/URI.h", "reportHash": "fe783d660fb0c1c7960c5ab7eed2f4f1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 14, "line": 27}, "message": "'FuzzyFindRequest' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Index.h", "reportHash": "a18d238ef6e2ac8e29f5bc8b5823cdf7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 14, "line": 160}, "message": "'SwapIndex' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Index.h", "reportHash": "92fbf7015758248b93f1864a859ab5a1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 15, "line": 87}, "message": "'Ref' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Ref.h", "reportHash": "5861f1ab5fb3ca7ac367be5702e50447", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 15, "line": 118}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 15, "line": 118}, "message": "'RefSlab' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Ref.h", "reportHash": "accce9268afefea7697f746fde30491d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 15, "line": 134}, "message": "'Builder' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Ref.h", "reportHash": "0028a6a71b52780464c4f79eeb54d2ee", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 15, "line": 145}, "message": "'Entry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Ref.h", "reportHash": "9bb1edd9e093bb51d521f0938eb46ff5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 16, "line": 59}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 16, "line": 59}, "message": "'RelationSlab' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Relation.h", "reportHash": "b3c2ad15afc73202b7f4cb00e8ebbc62", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 177}, "message": "'SymbolSlab' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Symbol.h", "reportHash": "bb94c9f99303a50c52e665f2390c81df", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 17, "line": 200}, "message": "'Builder' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Symbol.h", "reportHash": "c6e734a9112558ef6e84cd776a6adaa9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 18, "line": 19}, "message": "'SymbolLocation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolLocation.h", "reportHash": "55c92f0a6d251b9b6c05b5bdae7e635c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 18, "line": 32}, "message": "'Position' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolLocation.h", "reportHash": "7c18d25fa15e5332d54cdde528bcab78", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 19, "line": 49}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 19, "line": 49}, "message": "'Key<Type>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/Context.h", "reportHash": "b3559cbd9465e9fdeb398edafc150e86", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 19, "line": 92}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 19, "line": 92}, "message": "'Context' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/Context.h", "reportHash": "bf9c5354f2325887e5308224745cdeff", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 19, "line": 193}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 19, "line": 193}, "message": "'WithContext' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/Context.h", "reportHash": "48ecc11bb43187d37bd3c3a5b8bd27bd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 20, "line": 48}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 20, "line": 48}, "message": "'Subscription' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/Function.h", "reportHash": "abd637bc4224383813677d2584ab2759", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 21, "line": 46}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 21, "line": 46}, "message": "'MemoryTree' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/MemoryTree.h", "reportHash": "5e42b7793dfc143fca35fa8f0a3f97fc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 22, "line": 27}, "message": "'Notification' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/Threading.h", "reportHash": "3f9cbb418df6b38d445adf3c7f11a558", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 22, "line": 41}, "message": "'Semaphore' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/Threading.h", "reportHash": "c817838b47c4a773934bb3f28c539da7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 22, "line": 183}, "message": "'PeriodicThrottler' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/Threading.h", "reportHash": "127d319db559fe8eb1aee35490f134f1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 23, "line": 49}, "message": "'RealThreadsafeFS' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/ThreadsafeFS.h", "reportHash": "a4792619b087aab3c5e2d1d80e3ae25e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 24, "line": 38}, "message": "'Metric' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/Trace.h", "reportHash": "48446c87f9cef78a871eb0d1c10dfec4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 25, "line": 260}, "message": "'ComplexAPSInt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/APValue.h", "reportHash": "2e38f786e7cc4b5ff282c5f992cff9c6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 25, "line": 264}, "message": "'ComplexAPFloat' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/APValue.h", "reportHash": "70c03240612435ae3842fd11d426c9ba", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 25, "line": 294}, "message": "'AddrLabelDiffData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/APValue.h", "reportHash": "0271c765c0dc08c45c988917fbed9982", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 28, "line": 799}, "message": "'EvaluatedStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Decl.h", "reportHash": "a6f1f2b8535143592de2e06093719fc4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 30, "line": 3998}, "message": "'MSGuidDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclCXX.h", "reportHash": "c54cf5e3c26779de12567e572876dfe6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 32, "line": 3282}, "message": "'TemplateParamObjectDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclTemplate.h", "reportHash": "5f8d479d6e74db1a759f93ca350f1625", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 34, "line": 578}, "message": "'EvalStatus' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "9b08f36a71696f958a740b8607596a41", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 34, "line": 608}, "message": "'EvalResult' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "66372e5c84a7dc7ffb095a332df140c2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 48, "line": 63}, "message": "'PathDiagnosticConsumerOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/PathDiagnostic.h", "reportHash": "72230ae10a837aa82a71418239d3e60c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 48, "line": 102}, "message": "'PDFileEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/PathDiagnostic.h", "reportHash": "551269cf2b6ce79806aa52ee05c82b0a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 48, "line": 374}, "message": "'PathDiagnosticLocationPair' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/PathDiagnostic.h", "reportHash": "f300a016b10e43d009fbb2b38cadf4bf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 48, "line": 509}, "message": "'PathDiagnosticSpotPiece' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/PathDiagnostic.h", "reportHash": "b4e68236db269b4625d3975a4ae77d4a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 50, "line": 123}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 50, "line": 123}, "message": "'AttributeCommonInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/AttributeCommonInfo.h", "reportHash": "03bd6ce8468b83d0b1367b8b9167dd2c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 55, "line": 88}, "message": "'optional_none_tag' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/DirectoryEntry.h", "reportHash": "8cbd6e68f68aa31579a631cdc24e79bf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 55, "line": 254}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 55, "line": 254}, "message": "'OptionalDirectoryEntryRefDegradesToDirectoryEntryPtr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/DirectoryEntry.h", "reportHash": "8849b61fd689e5c7739efe7e09d0d6f8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 56, "line": 163}, "message": "'optional_none_tag' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "reportHash": "63477017ec4518eb2840c761538fe2d1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 56, "line": 284}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 56, "line": 284}, "message": "'OptionalFileEntryRefDegradesToFileEntryPtr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileEntry.h", "reportHash": "6af7d8035ff9a000d719abe962ac85b4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 57, "line": 22}, "message": "'FileSystemOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/FileSystemOptions.h", "reportHash": "6b14249863e2cd865975960074f77912", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 40, "file": 59, "line": 34}, "message": "'SmallString' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/LLVM.h", "reportHash": "35a88e5b993ebb6dc1d0cf0bc6515a4c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 61, "line": 198}, "message": "'DirectoryName' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Module.h", "reportHash": "cb8f169f23c4459a9dd8dd1edeeb1614", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 61, "line": 210}, "message": "'UnresolvedHeaderDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Module.h", "reportHash": "b39df44288602c87e54c9bb6b0ceb048", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 61, "line": 359}, "message": "'LinkLibrary' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Module.h", "reportHash": "29d02359d028cf1fd00fe88e3a6efdcd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 61, "line": 387}, "message": "'UnresolvedConflict' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Module.h", "reportHash": "9e1141b260e6385c1649aa850863484c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 61, "line": 400}, "message": "'Conflict' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Module.h", "reportHash": "c24a6a25fc9d149265151f32524da2e1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 61, "line": 653}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 61, "line": 653}, "message": "'VisibleModuleSet' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Module.h", "reportHash": "575ba59a4a2722f408126b7337d0baae", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 65, "line": 98}, "message": "'LineOffsetMapping' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceManager.h", "reportHash": "2e6aea2e9b83fffe0c2c5473575d9805", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 65, "line": 653}, "message": "'OverriddenFilesInfoTy' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceManager.h", "reportHash": "2c1b2695021eff4441c41f51ff68ff9a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 66, "line": 88}, "message": "'WrittenBuiltinSpecs' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Specifiers.h", "reportHash": "33708e243422578e4c34b0ad54a8ea14", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 68, "line": 45}, "message": "'ParseErrorCategory' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Format/Format.h", "reportHash": "3c6d4ed74c80c5de5f90072cc13a4c0d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 68, "line": 55}, "message": "'FormatStyle' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Format/Format.h", "reportHash": "4cf5e299f28c2c38bbfdcfd5f69bc811", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 68, "line": 1444}, "message": "'BraceWrappingFlags' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Format/Format.h", "reportHash": "11687633033a635c6f4ee86e2e915d7b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 68, "line": 2576}, "message": "'RawStringFormat' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Format/Format.h", "reportHash": "455d5b8c244e725b0dfc2441f0bd6a50", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 69, "line": 91}, "message": "'StandaloneFixIt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/ASTUnit.h", "reportHash": "6e84a79ff333ce39f15cffec6e60efa5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 69, "line": 98}, "message": "'StandaloneDiagnostic' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/ASTUnit.h", "reportHash": "478d2fb2c59c1aa80e391d2b25e9d3df", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 70, "line": 61}, "message": "'ParsedSourceRange' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/CommandLineSourceLoc.h", "reportHash": "8f5c0f6f8be7ad7e869bc542b267219d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 71, "line": 166}, "message": "'OutputFile' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/CompilerInstance.h", "reportHash": "be96c3fda6272ef9d031a868e435ca0b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 72, "line": 120}, "message": "'CompilerInvocation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/CompilerInvocation.h", "reportHash": "4189007655b3aa3a2406b1a8ec128e52", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 73, "line": 33}, "message": "'DependencyOutputOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/DependencyOutputOptions.h", "reportHash": "aa2529a560798ec190309c17ebfef8d8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 74, "line": 243}, "message": "'ASTFrontendAction' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/FrontendAction.h", "reportHash": "4c218a6e36a78c79497571f61c4c8a6f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 74, "line": 287}, "message": "'PreprocessorFrontendAction' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/FrontendAction.h", "reportHash": "7ca04126163b4c70fe6401e0de91c46b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 74, "line": 304}, "message": "'WrapperFrontendAction' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/FrontendAction.h", "reportHash": "f5868bc54d9454d71d400b74aa14dcb7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 75, "line": 184}, "message": "'FrontendInputFile' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/FrontendOptions.h", "reportHash": "3e58f16942155ff77f6de3c9a9a7812e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 75, "line": 227}, "message": "'FrontendOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/FrontendOptions.h", "reportHash": "3330163a6e235a79910262100bb62019", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 76, "line": 89}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 76, "line": 89}, "message": "'PrecompiledPreamble' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/PrecompiledPreamble.h", "reportHash": "fac2682c4b10a58ec5b82b592b0e9d8a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 76, "line": 150}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 76, "line": 150}, "message": "'TempPCHFile' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/PrecompiledPreamble.h", "reportHash": "272c08ab560ae67383dcafe3f07160d4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 76, "line": 166}, "message": "'InMemoryPreamble' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/PrecompiledPreamble.h", "reportHash": "0834a646c5c210052a8ee371f1402f5b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 76, "line": 182}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 76, "line": 182}, "message": "'PCHStorage' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/PrecompiledPreamble.h", "reportHash": "c024d223af26f996617c97daf92f3deb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 76, "line": 312}, "message": "'BuildPreambleErrorCategory' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/PrecompiledPreamble.h", "reportHash": "effab89c892545cba9fb367570d44ce5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 77, "line": 118}, "message": "'DependencyFileGenerator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/Utils.h", "reportHash": "b684863885f3d3888aae649f508e3828", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 78, "line": 38}, "message": "'DLU' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/DirectoryLookup.h", "reportHash": "e32203fa3c810c06303f57f849e7bbe5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 79, "line": 67}, "message": "'HeaderSearchOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h", "reportHash": "ad38b468ba34ac0119b49b57afda4024", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 79, "line": 69}, "message": "'Entry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h", "reportHash": "2a9020b74dccfbfd3becf222a8a4227b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 79, "line": 85}, "message": "'SystemHeaderPrefix' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h", "reportHash": "613351b4eaa08e68b1d678ddad98440f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 80, "line": 58}, "message": "'PreambleBounds' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/Lexer.h", "reportHash": "048d5502f9f58037066821bfba416716", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 81, "line": 290}, "message": "'MacroDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/MacroInfo.h", "reportHash": "08d319884798490a77c93c160179a6d4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 81, "line": 406}, "message": "'DefMacroDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/MacroInfo.h", "reportHash": "9ff03ebd3f11d67674700d7b37278835", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 82, "line": 35}, "message": "'ModuleLoadResult' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/ModuleLoader.h", "reportHash": "5fdb853db6dfcb5f172c758348e0ba7b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 82, "line": 164}, "message": "'TrivialModuleLoader' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/ModuleLoader.h", "reportHash": "96f019e421cbebdfaed7ecbbeb224706", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 83, "line": 230}, "message": "'Attributes' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/ModuleMap.h", "reportHash": "7c50ea8cc2c59fbbbd892c5eac85312e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 83, "line": 250}, "message": "'InferredDirectory' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/ModuleMap.h", "reportHash": "8518deb3500cc6a714bc83058f72ea0b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 84, "line": 28}, "message": "'MultipleIncludeOpt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/MultipleIncludeOpt.h", "reportHash": "5a439826afe28d54cf60deba378a214f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 85, "line": 84}, "message": "'EmptyPragmaHandler' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/Pragma.h", "reportHash": "9958d4e4b8aa28ee38bd1d0281727126", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 85, "line": 96}, "message": "'PragmaNamespace' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/Pragma.h", "reportHash": "14dadf305b2984b155fe1e274d7b9be7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 86, "line": 60}, "message": "'PreprocessedEntity' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h", "reportHash": "b1ac1cae14d81da5c1aed4145418861e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 86, "line": 135}, "message": "'PreprocessingDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h", "reportHash": "aa2dc290cb6ed95cd6e1ddd11f632cd1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 86, "line": 308}, "message": "'PreprocessingRecord' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h", "reportHash": "40931e74073cb85313300d88ee711c10", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 87, "line": 34}, "message": "'Token' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/Token.h", "reportHash": "cddb2bb8b4d83171586b4fe9b06a88c7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 87, "line": 315}, "message": "'PPConditionalInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/Token.h", "reportHash": "aa12b6a94956689444f96c58b54029cb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 88, "line": 636}, "message": "'CodeCompletionAllocator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h", "reportHash": "e27bd8f5e0798e4df02e42ac9ddce2c6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 88, "line": 746}, "message": "'CodeCompletionResult' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h", "reportHash": "b83c4c67b234156c61c053b6db7a1628", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 88, "line": 767}, "message": "'' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h", "reportHash": "dda8c389219bf159ae049b1b2f2ab66b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 88, "line": 1171}, "message": "'PrintingCodeCompleteConsumer' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h", "reportHash": "d7fac093c2602fca7829d70b0ed35e46", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 89, "line": 15}, "message": "'CodeCompleteOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/CodeCompleteOptions.h", "reportHash": "be540f1664da3074d43941aaf0e132e0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 90, "line": 64}, "message": "'CXXScopeSpec' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/DeclSpec.h", "reportHash": "e493786162cc57ed2ee80e5ea97055c1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 90, "line": 1193}, "message": "'PointerTypeInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/DeclSpec.h", "reportHash": "c27d357c0e6b77b8366ae3c30b46fbbf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 90, "line": 1522}, "message": "'MemberPointerTypeInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/DeclSpec.h", "reportHash": "23c977aaf5bf9e561fea274ae3987f38", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 91, "line": 123}, "message": "'AvailabilityChange' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/ParsedAttr.h", "reportHash": "192db8b7294b8e4988ca3a4341480c3c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 91, "line": 143}, "message": "'AvailabilityData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/ParsedAttr.h", "reportHash": "98217a64cf6a8996b641e6780d9a57a4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 91, "line": 164}, "message": "'PropertyData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/ParsedAttr.h", "reportHash": "ad69f7add379f1b2a36a2eefa5b57975", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 91, "line": 413}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 91, "line": 413}, "message": "'ParsedAttr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/ParsedAttr.h", "reportHash": "8929b40f4a91993ff38a8970045cc1bc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 91, "line": 732}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 91, "line": 732}, "message": "'AttributePool' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/ParsedAttr.h", "reportHash": "c45b1f6104d3b12092326acc6bbebf29", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 91, "line": 828}, "message": "'ParsedAttributesView' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/ParsedAttr.h", "reportHash": "228ab7faa3e530922c65e6ea2470c350", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 92, "line": 223}, "message": "'UnderalignedInt64' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h", "reportHash": "a4db6dc82487c6365f34e0ce531efb9b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 93, "line": 35}, "message": "'ModuleFileExtensionMetadata' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ModuleFileExtension.h", "reportHash": "b875b83124761dcddba64e40cc6ef117", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 94, "line": 29}, "message": "'PCHBuffer' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/PCHContainerOperations.h", "reportHash": "f2f98f455e4b59947c501cbec0cec420", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 94, "line": 68}, "message": "'RawPCHContainerWriter' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/PCHContainerOperations.h", "reportHash": "3a60561f49eb14fe15c2349df7e2d35c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 94, "line": 82}, "message": "'RawPCHContainerReader' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/PCHContainerOperations.h", "reportHash": "ffdf7e39915c4270e4a0a5ef7d057288", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 95, "line": 163}, "message": "'AnalyzerOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/AnalyzerOptions.h", "reportHash": "183c628e4add9ded62629ee1e57d9488", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 96, "line": 44}, "message": "'CompileCommand' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h", "reportHash": "60a6fd01a44ca13e1be63911ef4fdf6b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 96, "line": 154}, "message": "'FixedCompilationDatabase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h", "reportHash": "8880c6a45e57fc6692589d335e5dbf05", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 98, "line": 26}, "message": "'IncludeCategoryManager' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Inclusions/HeaderIncludes.h", "reportHash": "7147be7bbf3edc245ffcc0aa8095bf19", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 98, "line": 48}, "message": "'HeaderIncludes' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Inclusions/HeaderIncludes.h", "reportHash": "e3ebd69984c64c561d6ab042416dc575", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 98, "line": 82}, "message": "'Include' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Inclusions/HeaderIncludes.h", "reportHash": "e5ee47857a500de2e7070ed6312137eb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 99, "line": 20}, "message": "'IncludeStyle' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Inclusions/IncludeStyle.h", "reportHash": "2958ec3e7f868944d54ef2774c9102f0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 99, "line": 56}, "message": "'IncludeCategory' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Inclusions/IncludeStyle.h", "reportHash": "1d4934f9a205ac350e3bd5a0a2c52191", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 121}, "message": "'NestedNameSpecifier' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "7217851cc6e2b3b9533d416933e92e38", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 132}, "message": "'UnqualifiedId' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "b6b6df2a193f383a70ffb272fe4a11a1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 151}, "message": "'CallArguments' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "572e13963a39854fe0786861370a6c9b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 214}, "message": "'Statement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "19fcf04d075cbd77eefc7efd8fe06379", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 222}, "message": "'UnknownStatement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "82bff2026bed7bea872aa63d4f47fadd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 229}, "message": "'DeclarationStatement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "f16f5f53994a6256ee9300ae6b501a81", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 236}, "message": "'EmptyStatement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "2841db5392f32d3349fde76a0093a9ab", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 243}, "message": "'SwitchStatement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "a8e5f370ae254b5b22b4e46445d4ca26", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 252}, "message": "'CaseStatement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "2d53a9bf788c2621e7612e2bb7466ed4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 262}, "message": "'DefaultStatement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "c4e1dfd0dd240f901195391c547d7f1b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 272}, "message": "'IfStatement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "a3613ce966783aa737c515c9edc059b7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 283}, "message": "'ForStatement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "a4389f8242d25d419a7d648d10df0877", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 292}, "message": "'WhileStatement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "57fafebd67438a82dd1cae3c5901d3d5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 301}, "message": "'ContinueStatement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "57a33dc4c3a3e6247c1a275b17af8e82", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 309}, "message": "'BreakStatement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "3a23960dc0884fea1d6fac2ddc5f32f7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 318}, "message": "'ReturnStatement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "ec960090ac5cb92f39aee2e5ddf39bf6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 327}, "message": "'RangeBasedForStatement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "4da299b3102ba63097641df80ed8e480", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 337}, "message": "'ExpressionStatement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "aa3e9c69d6439de17cef974a44d7ddcf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 345}, "message": "'CompoundStatement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "391b36e0b2b457bb5bcaa0e1c34f29cf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 359}, "message": "'Declaration' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "4588b4d88bdc6b0344a915253d5ac268", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 366}, "message": "'UnknownDeclaration' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "5cf16f960c31ad07158e855c55166a79", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 373}, "message": "'EmptyDeclaration' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "bc639786b07ed5aa56e384625241297b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 381}, "message": "'StaticAssertDeclaration' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "8e7d40a8254b444552a44da66558e6c0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 391}, "message": "'LinkageSpecificationDeclaration' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "75a3c2056792e1eccd819577b19b4e6a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 398}, "message": "'DeclaratorList' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "8e78b8ec9581a88107adcd8fe0ffedfc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 410}, "message": "'SimpleDeclaration' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "19a1ef50ae1c3bd4fefafddc03c8fe86", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 419}, "message": "'TemplateDeclaration' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "c7c14609d4e48f9719989a3636a51800", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 432}, "message": "'ExplicitTemplateInstantiation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "eb2b324e55fe00e19795184f9ff3f5db", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 443}, "message": "'NamespaceDefinition' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "acb4d95d1c23ca2e9f8ef6e9255b5e36", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 450}, "message": "'NamespaceAliasDefinition' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "7325e70b8fcf2c0a1639d7a778fca4d1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 458}, "message": "'UsingNamespaceDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "c11321c3106b35438fba763f00e25ded", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 466}, "message": "'UsingDeclaration' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "a47a121ad672afd5b541a540eacd7f95", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 473}, "message": "'TypeAliasDeclaration' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "d55917844afcbfc8ad4c3ba4e0880975", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 491}, "message": "'Declarator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "c3e7f71b00f52545503a66ef7d6974ba", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 499}, "message": "'SimpleDeclarator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "cfa4064125b504598c0578799eb1f6ef", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 508}, "message": "'ParenDeclarator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "4c2f76de8b2921778817b1bc5b287f20", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 520}, "message": "'ArraySubscript' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "5185205c39189cb584b5a23ab11248ab", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 532}, "message": "'TrailingReturnType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "096a8943e7e0d8ec5a3fe23b06ad3380", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 545}, "message": "'ParameterDeclarationList' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "4da685f1fd319f4b39474b5d61c1d643", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 565}, "message": "'ParametersAndQualifiers' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "1293e11969555c4ac20c56b890f715da", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 100, "line": 577}, "message": "'MemberPointer' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h", "reportHash": "396e93166140e511f0fec2e015ee1499", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 101, "line": 179}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 101, "line": 179}, "message": "'TokenBuffer' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h", "reportHash": "f053c6792480eeb1abbd3afa0e4290d0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 102, "line": 41}, "message": "'Arena' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h", "reportHash": "b727b33ab29759c2cbd53bcffe33706a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 102, "line": 93}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 102, "line": 93}, "message": "'Node' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h", "reportHash": "f8130228d46bb94724ccf2c8a1e2ce9b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 102, "line": 157}, "message": "'Leaf' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h", "reportHash": "9e5249c6c2c5879b5ab6e991062d0065", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 102, "line": 169}, "message": "'Tree' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h", "reportHash": "6d5b201a473f7fd0b807bef62a00343d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 102, "line": 217}, "message": "'ChildIterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h", "reportHash": "4cfa3421c6b648f0be26ca73687e07eb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 102, "line": 220}, "message": "'ConstChildIterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h", "reportHash": "5bc05018d8f72c86aa783504b52e8b19", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 102, "line": 284}, "message": "'List' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h", "reportHash": "a7d1bab4b24b508bf821c3637a5eb678", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 131, "line": 18}, "message": "'OptSpecifier' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Option/OptSpecifier.h", "reportHash": "a92804a1854b77ea52bbd5dcb0871db3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 143, "line": 156}, "message": "'Array' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "db2328718ae19b0a1b5e03e44c2b844c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
