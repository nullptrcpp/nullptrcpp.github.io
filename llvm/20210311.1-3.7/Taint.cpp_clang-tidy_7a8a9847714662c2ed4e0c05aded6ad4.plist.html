<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/APValue.h", "content": "//===--- APValue.h - Union class for APFloat/APSInt/Complex -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the APValue class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_APVALUE_H\n#define LLVM_CLANG_AST_APVALUE_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/APFixedPoint.h\"\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/Support/AlignOf.h\"\n\nnamespace clang {\nnamespace serialization {\ntemplate <typename T> class BasicReaderBase;\n} // end namespace serialization\n\n  class AddrLabelExpr;\n  class ASTContext;\n  class CharUnits;\n  class CXXRecordDecl;\n  class Decl;\n  class DiagnosticBuilder;\n  class Expr;\n  class FieldDecl;\n  struct PrintingPolicy;\n  class Type;\n  class ValueDecl;\n  class QualType;\n\n/// Symbolic representation of typeid(T) for some type T.\nclass TypeInfoLValue {\n  const Type *T;\n\npublic:\n  TypeInfoLValue() : T() {}\n  explicit TypeInfoLValue(const Type *T);\n\n  const Type *getType() const { return T; }\n  explicit operator bool() const { return T; }\n\n  void *getOpaqueValue() { return const_cast<Type*>(T); }\n  static TypeInfoLValue getFromOpaqueValue(void *Value) {\n    TypeInfoLValue V;\n    V.T = reinterpret_cast<const Type*>(Value);\n    return V;\n  }\n\n  void print(llvm::raw_ostream &Out, const PrintingPolicy &Policy) const;\n};\n\n/// Symbolic representation of a dynamic allocation.\nclass DynamicAllocLValue {\n  unsigned Index;\n\npublic:\n  DynamicAllocLValue() : Index(0) {}\n  explicit DynamicAllocLValue(unsigned Index) : Index(Index + 1) {}\n  unsigned getIndex() { return Index - 1; }\n\n  explicit operator bool() const { return Index != 0; }\n\n  void *getOpaqueValue() {\n    return reinterpret_cast<void *>(static_cast<uintptr_t>(Index)\n                                    << NumLowBitsAvailable);\n  }\n  static DynamicAllocLValue getFromOpaqueValue(void *Value) {\n    DynamicAllocLValue V;\n    V.Index = reinterpret_cast<uintptr_t>(Value) >> NumLowBitsAvailable;\n    return V;\n  }\n\n  static unsigned getMaxIndex() {\n    return (std::numeric_limits<unsigned>::max() >> NumLowBitsAvailable) - 1;\n  }\n\n  static constexpr int NumLowBitsAvailable = 3;\n};\n}\n\nnamespace llvm {\ntemplate<> struct PointerLikeTypeTraits<clang::TypeInfoLValue> {\n  static void *getAsVoidPointer(clang::TypeInfoLValue V) {\n    return V.getOpaqueValue();\n  }\n  static clang::TypeInfoLValue getFromVoidPointer(void *P) {\n    return clang::TypeInfoLValue::getFromOpaqueValue(P);\n  }\n  // Validated by static_assert in APValue.cpp; hardcoded to avoid needing\n  // to include Type.h.\n  static constexpr int NumLowBitsAvailable = 3;\n};\n\ntemplate<> struct PointerLikeTypeTraits<clang::DynamicAllocLValue> {\n  static void *getAsVoidPointer(clang::DynamicAllocLValue V) {\n    return V.getOpaqueValue();\n  }\n  static clang::DynamicAllocLValue getFromVoidPointer(void *P) {\n    return clang::DynamicAllocLValue::getFromOpaqueValue(P);\n  }\n  static constexpr int NumLowBitsAvailable =\n      clang::DynamicAllocLValue::NumLowBitsAvailable;\n};\n}\n\nnamespace clang {\n/// APValue - This class implements a discriminated union of [uninitialized]\n/// [APSInt] [APFloat], [Complex APSInt] [Complex APFloat], [Expr + Offset],\n/// [Vector: N * APValue], [Array: N * APValue]\nclass APValue {\n  typedef llvm::APFixedPoint APFixedPoint;\n  typedef llvm::APSInt APSInt;\n  typedef llvm::APFloat APFloat;\npublic:\n  enum ValueKind {\n    /// There is no such object (it's outside its lifetime).\n    None,\n    /// This object has an indeterminate value (C++ [basic.indet]).\n    Indeterminate,\n    Int,\n    Float,\n    FixedPoint,\n    ComplexInt,\n    ComplexFloat,\n    LValue,\n    Vector,\n    Array,\n    Struct,\n    Union,\n    MemberPointer,\n    AddrLabelDiff\n  };\n\n  class LValueBase {\n    typedef llvm::PointerUnion<const ValueDecl *, const Expr *, TypeInfoLValue,\n                               DynamicAllocLValue>\n        PtrTy;\n\n  public:\n    LValueBase() : Local{} {}\n    LValueBase(const ValueDecl *P, unsigned I = 0, unsigned V = 0);\n    LValueBase(const Expr *P, unsigned I = 0, unsigned V = 0);\n    static LValueBase getDynamicAlloc(DynamicAllocLValue LV, QualType Type);\n    static LValueBase getTypeInfo(TypeInfoLValue LV, QualType TypeInfo);\n\n    void Profile(llvm::FoldingSetNodeID &ID) const;\n\n    template <class T>\n    bool is() const { return Ptr.is<T>(); }\n\n    template <class T>\n    T get() const { return Ptr.get<T>(); }\n\n    template <class T>\n    T dyn_cast() const { return Ptr.dyn_cast<T>(); }\n\n    void *getOpaqueValue() const;\n\n    bool isNull() const;\n\n    explicit operator bool() const;\n\n    unsigned getCallIndex() const;\n    unsigned getVersion() const;\n    QualType getTypeInfoType() const;\n    QualType getDynamicAllocType() const;\n\n    QualType getType() const;\n\n    friend bool operator==(const LValueBase &LHS, const LValueBase &RHS);\n    friend bool operator!=(const LValueBase &LHS, const LValueBase &RHS) {\n      return !(LHS == RHS);\n    }\n    friend llvm::hash_code hash_value(const LValueBase &Base);\n    friend struct llvm::DenseMapInfo<LValueBase>;\n\n  private:\n    PtrTy Ptr;\n    struct LocalState {\n      unsigned CallIndex, Version;\n    };\n    union {\n      LocalState Local;\n      /// The type std::type_info, if this is a TypeInfoLValue.\n      void *TypeInfoType;\n      /// The QualType, if this is a DynamicAllocLValue.\n      void *DynamicAllocType;\n    };\n  };\n\n  /// A FieldDecl or CXXRecordDecl, along with a flag indicating whether we\n  /// mean a virtual or non-virtual base class subobject.\n  typedef llvm::PointerIntPair<const Decl *, 1, bool> BaseOrMemberType;\n\n  /// A non-discriminated union of a base, field, or array index.\n  class LValuePathEntry {\n    static_assert(sizeof(uintptr_t) <= sizeof(uint64_t),\n                  \"pointer doesn't fit in 64 bits?\");\n    uint64_t Value;\n\n  public:\n    LValuePathEntry() : Value() {}\n    LValuePathEntry(BaseOrMemberType BaseOrMember);\n    static LValuePathEntry ArrayIndex(uint64_t Index) {\n      LValuePathEntry Result;\n      Result.Value = Index;\n      return Result;\n    }\n\n    BaseOrMemberType getAsBaseOrMember() const {\n      return BaseOrMemberType::getFromOpaqueValue(\n          reinterpret_cast<void *>(Value));\n    }\n    uint64_t getAsArrayIndex() const { return Value; }\n\n    void Profile(llvm::FoldingSetNodeID &ID) const;\n\n    friend bool operator==(LValuePathEntry A, LValuePathEntry B) {\n      return A.Value == B.Value;\n    }\n    friend bool operator!=(LValuePathEntry A, LValuePathEntry B) {\n      return A.Value != B.Value;\n    }\n    friend llvm::hash_code hash_value(LValuePathEntry A) {\n      return llvm::hash_value(A.Value);\n    }\n  };\n  class LValuePathSerializationHelper {\n    const void *ElemTy;\n\n  public:\n    ArrayRef<LValuePathEntry> Path;\n\n    LValuePathSerializationHelper(ArrayRef<LValuePathEntry>, QualType);\n    QualType getType();\n  };\n  struct NoLValuePath {};\n  struct UninitArray {};\n  struct UninitStruct {};\n\n  template <typename Impl> friend class clang::serialization::BasicReaderBase;\n  friend class ASTImporter;\n  friend class ASTNodeImporter;\n\nprivate:\n  ValueKind Kind;\n\n  struct ComplexAPSInt {\n    APSInt Real, Imag;\n    ComplexAPSInt() : Real(1), Imag(1) {}\n  };\n  struct ComplexAPFloat {\n    APFloat Real, Imag;\n    ComplexAPFloat() : Real(0.0), Imag(0.0) {}\n  };\n  struct LV;\n  struct Vec {\n    APValue *Elts;\n    unsigned NumElts;\n    Vec() : Elts(nullptr), NumElts(0) {}\n    ~Vec() { delete[] Elts; }\n  };\n  struct Arr {\n    APValue *Elts;\n    unsigned NumElts, ArrSize;\n    Arr(unsigned NumElts, unsigned ArrSize);\n    ~Arr();\n  };\n  struct StructData {\n    APValue *Elts;\n    unsigned NumBases;\n    unsigned NumFields;\n    StructData(unsigned NumBases, unsigned NumFields);\n    ~StructData();\n  };\n  struct UnionData {\n    const FieldDecl *Field;\n    APValue *Value;\n    UnionData();\n    ~UnionData();\n  };\n  struct AddrLabelDiffData {\n    const AddrLabelExpr* LHSExpr;\n    const AddrLabelExpr* RHSExpr;\n  };\n  struct MemberPointerData;\n\n  // We ensure elsewhere that Data is big enough for LV and MemberPointerData.\n  typedef llvm::AlignedCharArrayUnion<void *, APSInt, APFloat, ComplexAPSInt,\n                                      ComplexAPFloat, Vec, Arr, StructData,\n                                      UnionData, AddrLabelDiffData> DataType;\n  static const size_t DataSize = sizeof(DataType);\n\n  DataType Data;\n\npublic:\n  APValue() : Kind(None) {}\n  explicit APValue(APSInt I) : Kind(None) {\n    MakeInt(); setInt(std::move(I));\n  }\n  explicit APValue(APFloat F) : Kind(None) {\n    MakeFloat(); setFloat(std::move(F));\n  }\n  explicit APValue(APFixedPoint FX) : Kind(None) {\n    MakeFixedPoint(std::move(FX));\n  }\n  explicit APValue(const APValue *E, unsigned N) : Kind(None) {\n    MakeVector(); setVector(E, N);\n  }\n  APValue(APSInt R, APSInt I) : Kind(None) {\n    MakeComplexInt(); setComplexInt(std::move(R), std::move(I));\n  }\n  APValue(APFloat R, APFloat I) : Kind(None) {\n    MakeComplexFloat(); setComplexFloat(std::move(R), std::move(I));\n  }\n  APValue(const APValue &RHS);\n  APValue(APValue &&RHS);\n  APValue(LValueBase B, const CharUnits &O, NoLValuePath N,\n          bool IsNullPtr = false)\n      : Kind(None) {\n    MakeLValue(); setLValue(B, O, N, IsNullPtr);\n  }\n  APValue(LValueBase B, const CharUnits &O, ArrayRef<LValuePathEntry> Path,\n          bool OnePastTheEnd, bool IsNullPtr = false)\n      : Kind(None) {\n    MakeLValue(); setLValue(B, O, Path, OnePastTheEnd, IsNullPtr);\n  }\n  APValue(UninitArray, unsigned InitElts, unsigned Size) : Kind(None) {\n    MakeArray(InitElts, Size);\n  }\n  APValue(UninitStruct, unsigned B, unsigned M) : Kind(None) {\n    MakeStruct(B, M);\n  }\n  explicit APValue(const FieldDecl *D, const APValue &V = APValue())\n      : Kind(None) {\n    MakeUnion(); setUnion(D, V);\n  }\n  APValue(const ValueDecl *Member, bool IsDerivedMember,\n          ArrayRef<const CXXRecordDecl*> Path) : Kind(None) {\n    MakeMemberPointer(Member, IsDerivedMember, Path);\n  }\n  APValue(const AddrLabelExpr* LHSExpr, const AddrLabelExpr* RHSExpr)\n      : Kind(None) {\n    MakeAddrLabelDiff(); setAddrLabelDiff(LHSExpr, RHSExpr);\n  }\n  static APValue IndeterminateValue() {\n    APValue Result;\n    Result.Kind = Indeterminate;\n    return Result;\n  }\n\n  APValue &operator=(const APValue &RHS);\n  APValue &operator=(APValue &&RHS);\n\n  ~APValue() {\n    if (Kind != None && Kind != Indeterminate)\n      DestroyDataAndMakeUninit();\n  }\n\n  /// Returns whether the object performed allocations.\n  ///\n  /// If APValues are constructed via placement new, \\c needsCleanup()\n  /// indicates whether the destructor must be called in order to correctly\n  /// free all allocated memory.\n  bool needsCleanup() const;\n\n  /// Swaps the contents of this and the given APValue.\n  void swap(APValue &RHS);\n\n  /// profile this value. There is no guarantee that values of different\n  /// types will not produce the same profiled value, so the type should\n  /// typically also be profiled if it's not implied by the context.\n  void Profile(llvm::FoldingSetNodeID &ID) const;\n\n  ValueKind getKind() const { return Kind; }\n\n  bool isAbsent() const { return Kind == None; }\n  bool isIndeterminate() const { return Kind == Indeterminate; }\n  bool hasValue() const { return Kind != None && Kind != Indeterminate; }\n\n  bool isInt() const { return Kind == Int; }\n  bool isFloat() const { return Kind == Float; }\n  bool isFixedPoint() const { return Kind == FixedPoint; }\n  bool isComplexInt() const { return Kind == ComplexInt; }\n  bool isComplexFloat() const { return Kind == ComplexFloat; }\n  bool isLValue() const { return Kind == LValue; }\n  bool isVector() const { return Kind == Vector; }\n  bool isArray() const { return Kind == Array; }\n  bool isStruct() const { return Kind == Struct; }\n  bool isUnion() const { return Kind == Union; }\n  bool isMemberPointer() const { return Kind == MemberPointer; }\n  bool isAddrLabelDiff() const { return Kind == AddrLabelDiff; }\n\n  void dump() const;\n  void dump(raw_ostream &OS, const ASTContext &Context) const;\n\n  void printPretty(raw_ostream &OS, const ASTContext &Ctx, QualType Ty) const;\n  void printPretty(raw_ostream &OS, const PrintingPolicy &Policy, QualType Ty,\n                   const ASTContext *Ctx = nullptr) const;\n\n  std::string getAsString(const ASTContext &Ctx, QualType Ty) const;\n\n  APSInt &getInt() {\n    assert(isInt() && \"Invalid accessor\");\n    return *(APSInt *)(char *)&Data;\n  }\n  const APSInt &getInt() const {\n    return const_cast<APValue*>(this)->getInt();\n  }\n\n  /// Try to convert this value to an integral constant. This works if it's an\n  /// integer, null pointer, or offset from a null pointer. Returns true on\n  /// success.\n  bool toIntegralConstant(APSInt &Result, QualType SrcTy,\n                          const ASTContext &Ctx) const;\n\n  APFloat &getFloat() {\n    assert(isFloat() && \"Invalid accessor\");\n    return *(APFloat *)(char *)&Data;\n  }\n  const APFloat &getFloat() const {\n    return const_cast<APValue*>(this)->getFloat();\n  }\n\n  APFixedPoint &getFixedPoint() {\n    assert(isFixedPoint() && \"Invalid accessor\");\n    return *(APFixedPoint *)(char *)&Data;\n  }\n  const APFixedPoint &getFixedPoint() const {\n    return const_cast<APValue *>(this)->getFixedPoint();\n  }\n\n  APSInt &getComplexIntReal() {\n    assert(isComplexInt() && \"Invalid accessor\");\n    return ((ComplexAPSInt *)(char *)&Data)->Real;\n  }\n  const APSInt &getComplexIntReal() const {\n    return const_cast<APValue*>(this)->getComplexIntReal();\n  }\n\n  APSInt &getComplexIntImag() {\n    assert(isComplexInt() && \"Invalid accessor\");\n    return ((ComplexAPSInt *)(char *)&Data)->Imag;\n  }\n  const APSInt &getComplexIntImag() const {\n    return const_cast<APValue*>(this)->getComplexIntImag();\n  }\n\n  APFloat &getComplexFloatReal() {\n    assert(isComplexFloat() && \"Invalid accessor\");\n    return ((ComplexAPFloat *)(char *)&Data)->Real;\n  }\n  const APFloat &getComplexFloatReal() const {\n    return const_cast<APValue*>(this)->getComplexFloatReal();\n  }\n\n  APFloat &getComplexFloatImag() {\n    assert(isComplexFloat() && \"Invalid accessor\");\n    return ((ComplexAPFloat *)(char *)&Data)->Imag;\n  }\n  const APFloat &getComplexFloatImag() const {\n    return const_cast<APValue*>(this)->getComplexFloatImag();\n  }\n\n  const LValueBase getLValueBase() const;\n  CharUnits &getLValueOffset();\n  const CharUnits &getLValueOffset() const {\n    return const_cast<APValue*>(this)->getLValueOffset();\n  }\n  bool isLValueOnePastTheEnd() const;\n  bool hasLValuePath() const;\n  ArrayRef<LValuePathEntry> getLValuePath() const;\n  unsigned getLValueCallIndex() const;\n  unsigned getLValueVersion() const;\n  bool isNullPointer() const;\n\n  APValue &getVectorElt(unsigned I) {\n    assert(isVector() && \"Invalid accessor\");\n    assert(I < getVectorLength() && \"Index out of range\");\n    return ((Vec *)(char *)&Data)->Elts[I];\n  }\n  const APValue &getVectorElt(unsigned I) const {\n    return const_cast<APValue*>(this)->getVectorElt(I);\n  }\n  unsigned getVectorLength() const {\n    assert(isVector() && \"Invalid accessor\");\n    return ((const Vec *)(const void *)&Data)->NumElts;\n  }\n\n  APValue &getArrayInitializedElt(unsigned I) {\n    assert(isArray() && \"Invalid accessor\");\n    assert(I < getArrayInitializedElts() && \"Index out of range\");\n    return ((Arr *)(char *)&Data)->Elts[I];\n  }\n  const APValue &getArrayInitializedElt(unsigned I) const {\n    return const_cast<APValue*>(this)->getArrayInitializedElt(I);\n  }\n  bool hasArrayFiller() const {\n    return getArrayInitializedElts() != getArraySize();\n  }\n  APValue &getArrayFiller() {\n    assert(isArray() && \"Invalid accessor\");\n    assert(hasArrayFiller() && \"No array filler\");\n    return ((Arr *)(char *)&Data)->Elts[getArrayInitializedElts()];\n  }\n  const APValue &getArrayFiller() const {\n    return const_cast<APValue*>(this)->getArrayFiller();\n  }\n  unsigned getArrayInitializedElts() const {\n    assert(isArray() && \"Invalid accessor\");\n    return ((const Arr *)(const void *)&Data)->NumElts;\n  }\n  unsigned getArraySize() const {\n    assert(isArray() && \"Invalid accessor\");\n    return ((const Arr *)(const void *)&Data)->ArrSize;\n  }\n\n  unsigned getStructNumBases() const {\n    assert(isStruct() && \"Invalid accessor\");\n    return ((const StructData *)(const char *)&Data)->NumBases;\n  }\n  unsigned getStructNumFields() const {\n    assert(isStruct() && \"Invalid accessor\");\n    return ((const StructData *)(const char *)&Data)->NumFields;\n  }\n  APValue &getStructBase(unsigned i) {\n    assert(isStruct() && \"Invalid accessor\");\n    assert(i < getStructNumBases() && \"base class index OOB\");\n    return ((StructData *)(char *)&Data)->Elts[i];\n  }\n  APValue &getStructField(unsigned i) {\n    assert(isStruct() && \"Invalid accessor\");\n    assert(i < getStructNumFields() && \"field index OOB\");\n    return ((StructData *)(char *)&Data)->Elts[getStructNumBases() + i];\n  }\n  const APValue &getStructBase(unsigned i) const {\n    return const_cast<APValue*>(this)->getStructBase(i);\n  }\n  const APValue &getStructField(unsigned i) const {\n    return const_cast<APValue*>(this)->getStructField(i);\n  }\n\n  const FieldDecl *getUnionField() const {\n    assert(isUnion() && \"Invalid accessor\");\n    return ((const UnionData *)(const char *)&Data)->Field;\n  }\n  APValue &getUnionValue() {\n    assert(isUnion() && \"Invalid accessor\");\n    return *((UnionData *)(char *)&Data)->Value;\n  }\n  const APValue &getUnionValue() const {\n    return const_cast<APValue*>(this)->getUnionValue();\n  }\n\n  const ValueDecl *getMemberPointerDecl() const;\n  bool isMemberPointerToDerivedMember() const;\n  ArrayRef<const CXXRecordDecl*> getMemberPointerPath() const;\n\n  const AddrLabelExpr* getAddrLabelDiffLHS() const {\n    assert(isAddrLabelDiff() && \"Invalid accessor\");\n    return ((const AddrLabelDiffData *)(const char *)&Data)->LHSExpr;\n  }\n  const AddrLabelExpr* getAddrLabelDiffRHS() const {\n    assert(isAddrLabelDiff() && \"Invalid accessor\");\n    return ((const AddrLabelDiffData *)(const char *)&Data)->RHSExpr;\n  }\n\n  void setInt(APSInt I) {\n    assert(isInt() && \"Invalid accessor\");\n    *(APSInt *)(char *)&Data = std::move(I);\n  }\n  void setFloat(APFloat F) {\n    assert(isFloat() && \"Invalid accessor\");\n    *(APFloat *)(char *)&Data = std::move(F);\n  }\n  void setFixedPoint(APFixedPoint FX) {\n    assert(isFixedPoint() && \"Invalid accessor\");\n    *(APFixedPoint *)(char *)&Data = std::move(FX);\n  }\n  void setVector(const APValue *E, unsigned N) {\n    MutableArrayRef<APValue> InternalElts = setVectorUninit(N);\n    for (unsigned i = 0; i != N; ++i)\n      InternalElts[i] = E[i];\n  }\n  void setComplexInt(APSInt R, APSInt I) {\n    assert(R.getBitWidth() == I.getBitWidth() &&\n           \"Invalid complex int (type mismatch).\");\n    assert(isComplexInt() && \"Invalid accessor\");\n    ((ComplexAPSInt *)(char *)&Data)->Real = std::move(R);\n    ((ComplexAPSInt *)(char *)&Data)->Imag = std::move(I);\n  }\n  void setComplexFloat(APFloat R, APFloat I) {\n    assert(&R.getSemantics() == &I.getSemantics() &&\n           \"Invalid complex float (type mismatch).\");\n    assert(isComplexFloat() && \"Invalid accessor\");\n    ((ComplexAPFloat *)(char *)&Data)->Real = std::move(R);\n    ((ComplexAPFloat *)(char *)&Data)->Imag = std::move(I);\n  }\n  void setLValue(LValueBase B, const CharUnits &O, NoLValuePath,\n                 bool IsNullPtr);\n  void setLValue(LValueBase B, const CharUnits &O,\n                 ArrayRef<LValuePathEntry> Path, bool OnePastTheEnd,\n                 bool IsNullPtr);\n  void setUnion(const FieldDecl *Field, const APValue &Value);\n  void setAddrLabelDiff(const AddrLabelExpr* LHSExpr,\n                        const AddrLabelExpr* RHSExpr) {\n    ((AddrLabelDiffData *)(char *)&Data)->LHSExpr = LHSExpr;\n    ((AddrLabelDiffData *)(char *)&Data)->RHSExpr = RHSExpr;\n  }\n\nprivate:\n  void DestroyDataAndMakeUninit();\n  void MakeInt() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)&Data) APSInt(1);\n    Kind = Int;\n  }\n  void MakeFloat() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) APFloat(0.0);\n    Kind = Float;\n  }\n  void MakeFixedPoint(APFixedPoint &&FX) {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) APFixedPoint(std::move(FX));\n    Kind = FixedPoint;\n  }\n  void MakeVector() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) Vec();\n    Kind = Vector;\n  }\n  void MakeComplexInt() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) ComplexAPSInt();\n    Kind = ComplexInt;\n  }\n  void MakeComplexFloat() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) ComplexAPFloat();\n    Kind = ComplexFloat;\n  }\n  void MakeLValue();\n  void MakeArray(unsigned InitElts, unsigned Size);\n  void MakeStruct(unsigned B, unsigned M) {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) StructData(B, M);\n    Kind = Struct;\n  }\n  void MakeUnion() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) UnionData();\n    Kind = Union;\n  }\n  void MakeMemberPointer(const ValueDecl *Member, bool IsDerivedMember,\n                         ArrayRef<const CXXRecordDecl*> Path);\n  void MakeAddrLabelDiff() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) AddrLabelDiffData();\n    Kind = AddrLabelDiff;\n  }\n\nprivate:\n  /// The following functions are used as part of initialization, during\n  /// deserialization and importing. Reserve the space so that it can be\n  /// filled in by those steps.\n  MutableArrayRef<APValue> setVectorUninit(unsigned N) {\n    assert(isVector() && \"Invalid accessor\");\n    Vec *V = ((Vec *)(char *)&Data);\n    V->Elts = new APValue[N];\n    V->NumElts = N;\n    return {V->Elts, V->NumElts};\n  }\n  MutableArrayRef<LValuePathEntry>\n  setLValueUninit(LValueBase B, const CharUnits &O, unsigned Size,\n                  bool OnePastTheEnd, bool IsNullPtr);\n  MutableArrayRef<const CXXRecordDecl *>\n  setMemberPointerUninit(const ValueDecl *Member, bool IsDerivedMember,\n                         unsigned Size);\n};\n\n} // end namespace clang.\n\nnamespace llvm {\ntemplate<> struct DenseMapInfo<clang::APValue::LValueBase> {\n  static clang::APValue::LValueBase getEmptyKey();\n  static clang::APValue::LValueBase getTombstoneKey();\n  static unsigned getHashValue(const clang::APValue::LValueBase &Base);\n  static bool isEqual(const clang::APValue::LValueBase &LHS,\n                      const clang::APValue::LValueBase &RHS);\n};\n}\n\n#endif\n"}, "1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTConcept.h", "content": "//===--- ASTConcept.h - Concepts Related AST Data Structures ----*- C++ -*-===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// \\brief This file provides AST data structures related to concepts.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_ASTCONCEPT_H\n#define LLVM_CLANG_AST_ASTCONCEPT_H\n#include \"clang/AST/Expr.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include <string>\n#include <utility>\nnamespace clang {\nclass ConceptDecl;\nclass ConceptSpecializationExpr;\n\n/// The result of a constraint satisfaction check, containing the necessary\n/// information to diagnose an unsatisfied constraint.\nclass ConstraintSatisfaction : public llvm::FoldingSetNode {\n  // The template-like entity that 'owns' the constraint checked here (can be a\n  // constrained entity or a concept).\n  const NamedDecl *ConstraintOwner = nullptr;\n  llvm::SmallVector<TemplateArgument, 4> TemplateArgs;\n\npublic:\n\n  ConstraintSatisfaction() = default;\n\n  ConstraintSatisfaction(const NamedDecl *ConstraintOwner,\n                         ArrayRef<TemplateArgument> TemplateArgs) :\n      ConstraintOwner(ConstraintOwner), TemplateArgs(TemplateArgs.begin(),\n                                                     TemplateArgs.end()) { }\n\n  using SubstitutionDiagnostic = std::pair<SourceLocation, StringRef>;\n  using Detail = llvm::PointerUnion<Expr *, SubstitutionDiagnostic *>;\n\n  bool IsSatisfied = false;\n\n  /// \\brief Pairs of unsatisfied atomic constraint expressions along with the\n  /// substituted constraint expr, if the template arguments could be\n  /// substituted into them, or a diagnostic if substitution resulted in an\n  /// invalid expression.\n  llvm::SmallVector<std::pair<const Expr *, Detail>, 4> Details;\n\n  void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &C) {\n    Profile(ID, C, ConstraintOwner, TemplateArgs);\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &C,\n                      const NamedDecl *ConstraintOwner,\n                      ArrayRef<TemplateArgument> TemplateArgs);\n};\n\n/// Pairs of unsatisfied atomic constraint expressions along with the\n/// substituted constraint expr, if the template arguments could be\n/// substituted into them, or a diagnostic if substitution resulted in\n/// an invalid expression.\nusing UnsatisfiedConstraintRecord =\n    std::pair<const Expr *,\n              llvm::PointerUnion<Expr *,\n                                 std::pair<SourceLocation, StringRef> *>>;\n\n/// \\brief The result of a constraint satisfaction check, containing the\n/// necessary information to diagnose an unsatisfied constraint.\n///\n/// This is safe to store in an AST node, as opposed to ConstraintSatisfaction.\nstruct ASTConstraintSatisfaction final :\n    llvm::TrailingObjects<ASTConstraintSatisfaction,\n                          UnsatisfiedConstraintRecord> {\n  std::size_t NumRecords;\n  bool IsSatisfied : 1;\n\n  const UnsatisfiedConstraintRecord *begin() const {\n    return getTrailingObjects<UnsatisfiedConstraintRecord>();\n  }\n\n  const UnsatisfiedConstraintRecord *end() const {\n    return getTrailingObjects<UnsatisfiedConstraintRecord>() + NumRecords;\n  }\n\n  ASTConstraintSatisfaction(const ASTContext &C,\n                            const ConstraintSatisfaction &Satisfaction);\n\n  static ASTConstraintSatisfaction *\n  Create(const ASTContext &C, const ConstraintSatisfaction &Satisfaction);\n};\n\n/// \\brief Common data class for constructs that reference concepts with\n/// template arguments.\nclass ConceptReference {\nprotected:\n  // \\brief The optional nested name specifier used when naming the concept.\n  NestedNameSpecifierLoc NestedNameSpec;\n\n  /// \\brief The location of the template keyword, if specified when naming the\n  /// concept.\n  SourceLocation TemplateKWLoc;\n\n  /// \\brief The concept name used.\n  DeclarationNameInfo ConceptName;\n\n  /// \\brief The declaration found by name lookup when the expression was\n  /// created.\n  /// Can differ from NamedConcept when, for example, the concept was found\n  /// through a UsingShadowDecl.\n  NamedDecl *FoundDecl;\n\n  /// \\brief The concept named.\n  ConceptDecl *NamedConcept;\n\n  /// \\brief The template argument list source info used to specialize the\n  /// concept.\n  const ASTTemplateArgumentListInfo *ArgsAsWritten;\n\npublic:\n\n  ConceptReference(NestedNameSpecifierLoc NNS, SourceLocation TemplateKWLoc,\n                   DeclarationNameInfo ConceptNameInfo, NamedDecl *FoundDecl,\n                   ConceptDecl *NamedConcept,\n                   const ASTTemplateArgumentListInfo *ArgsAsWritten) :\n      NestedNameSpec(NNS), TemplateKWLoc(TemplateKWLoc),\n      ConceptName(ConceptNameInfo), FoundDecl(FoundDecl),\n      NamedConcept(NamedConcept), ArgsAsWritten(ArgsAsWritten) {}\n\n  ConceptReference() : NestedNameSpec(), TemplateKWLoc(), ConceptName(),\n      FoundDecl(nullptr), NamedConcept(nullptr), ArgsAsWritten(nullptr) {}\n\n  const NestedNameSpecifierLoc &getNestedNameSpecifierLoc() const {\n    return NestedNameSpec;\n  }\n\n  const DeclarationNameInfo &getConceptNameInfo() const { return ConceptName; }\n\n  SourceLocation getConceptNameLoc() const {\n    return getConceptNameInfo().getLoc();\n  }\n\n  SourceLocation getTemplateKWLoc() const { return TemplateKWLoc; }\n\n  NamedDecl *getFoundDecl() const {\n    return FoundDecl;\n  }\n\n  ConceptDecl *getNamedConcept() const {\n    return NamedConcept;\n  }\n\n  const ASTTemplateArgumentListInfo *getTemplateArgsAsWritten() const {\n    return ArgsAsWritten;\n  }\n\n  /// \\brief Whether or not template arguments were explicitly specified in the\n  /// concept reference (they might not be in type constraints, for example)\n  bool hasExplicitTemplateArgs() const {\n    return ArgsAsWritten != nullptr;\n  }\n};\n\nclass TypeConstraint : public ConceptReference {\n  /// \\brief The immediately-declared constraint expression introduced by this\n  /// type-constraint.\n  Expr *ImmediatelyDeclaredConstraint = nullptr;\n\npublic:\n  TypeConstraint(NestedNameSpecifierLoc NNS,\n                 DeclarationNameInfo ConceptNameInfo, NamedDecl *FoundDecl,\n                 ConceptDecl *NamedConcept,\n                 const ASTTemplateArgumentListInfo *ArgsAsWritten,\n                 Expr *ImmediatelyDeclaredConstraint) :\n      ConceptReference(NNS, /*TemplateKWLoc=*/SourceLocation(), ConceptNameInfo,\n                       FoundDecl, NamedConcept, ArgsAsWritten),\n      ImmediatelyDeclaredConstraint(ImmediatelyDeclaredConstraint) {}\n\n  /// \\brief Get the immediately-declared constraint expression introduced by\n  /// this type-constraint, that is - the constraint expression that is added to\n  /// the associated constraints of the enclosing declaration in practice.\n  Expr *getImmediatelyDeclaredConstraint() const {\n    return ImmediatelyDeclaredConstraint;\n  }\n\n  void print(llvm::raw_ostream &OS, PrintingPolicy Policy) const;\n};\n\n} // clang\n\n#endif // LLVM_CLANG_AST_ASTCONCEPT_H\n"}, "2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTVector.h", "content": "//===- ASTVector.h - Vector that uses ASTContext for allocation ---*- C++ -*-=//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file provides ASTVector, a vector  ADT whose contents are\n//  allocated using the allocator associated with an ASTContext..\n//\n//===----------------------------------------------------------------------===//\n\n// FIXME: Most of this is copy-and-paste from BumpVector.h and SmallVector.h.\n// We can refactor this core logic into something common.\n\n#ifndef LLVM_CLANG_AST_ASTVECTOR_H\n#define LLVM_CLANG_AST_ASTVECTOR_H\n\n#include \"clang/AST/ASTContextAllocate.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstring>\n#include <iterator>\n#include <memory>\n#include <type_traits>\n#include <utility>\n\nnamespace clang {\n\nclass ASTContext;\n\ntemplate<typename T>\nclass ASTVector {\nprivate:\n  T *Begin = nullptr;\n  T *End = nullptr;\n  llvm::PointerIntPair<T *, 1, bool> Capacity;\n\n  void setEnd(T *P) { this->End = P; }\n\nprotected:\n  // Make a tag bit available to users of this class.\n  // FIXME: This is a horrible hack.\n  bool getTag() const { return Capacity.getInt(); }\n  void setTag(bool B) { Capacity.setInt(B); }\n\npublic:\n  // Default ctor - Initialize to empty.\n  ASTVector() : Capacity(nullptr, false) {}\n\n  ASTVector(ASTVector &&O) : Begin(O.Begin), End(O.End), Capacity(O.Capacity) {\n    O.Begin = O.End = nullptr;\n    O.Capacity.setPointer(nullptr);\n    O.Capacity.setInt(false);\n  }\n\n  ASTVector(const ASTContext &C, unsigned N) : Capacity(nullptr, false) {\n    reserve(C, N);\n  }\n\n  ASTVector &operator=(ASTVector &&RHS) {\n    ASTVector O(std::move(RHS));\n\n    using std::swap;\n\n    swap(Begin, O.Begin);\n    swap(End, O.End);\n    swap(Capacity, O.Capacity);\n    return *this;\n  }\n\n  ~ASTVector() {\n    if (std::is_class<T>::value) {\n      // Destroy the constructed elements in the vector.\n      destroy_range(Begin, End);\n    }\n  }\n\n  using size_type = size_t;\n  using difference_type = ptrdiff_t;\n  using value_type = T;\n  using iterator = T *;\n  using const_iterator = const T *;\n\n  using const_reverse_iterator = std::reverse_iterator<const_iterator>;\n  using reverse_iterator = std::reverse_iterator<iterator>;\n\n  using reference = T &;\n  using const_reference = const T &;\n  using pointer = T *;\n  using const_pointer = const T *;\n\n  // forward iterator creation methods.\n  iterator begin() { return Begin; }\n  const_iterator begin() const { return Begin; }\n  iterator end() { return End; }\n  const_iterator end() const { return End; }\n\n  // reverse iterator creation methods.\n  reverse_iterator rbegin()            { return reverse_iterator(end()); }\n  const_reverse_iterator rbegin() const{ return const_reverse_iterator(end()); }\n  reverse_iterator rend()              { return reverse_iterator(begin()); }\n  const_reverse_iterator rend() const { return const_reverse_iterator(begin());}\n\n  bool empty() const { return Begin == End; }\n  size_type size() const { return End-Begin; }\n\n  reference operator[](unsigned idx) {\n    assert(Begin + idx < End);\n    return Begin[idx];\n  }\n  const_reference operator[](unsigned idx) const {\n    assert(Begin + idx < End);\n    return Begin[idx];\n  }\n\n  reference front() {\n    return begin()[0];\n  }\n  const_reference front() const {\n    return begin()[0];\n  }\n\n  reference back() {\n    return end()[-1];\n  }\n  const_reference back() const {\n    return end()[-1];\n  }\n\n  void pop_back() {\n    --End;\n    End->~T();\n  }\n\n  T pop_back_val() {\n    T Result = back();\n    pop_back();\n    return Result;\n  }\n\n  void clear() {\n    if (std::is_class<T>::value) {\n      destroy_range(Begin, End);\n    }\n    End = Begin;\n  }\n\n  /// data - Return a pointer to the vector's buffer, even if empty().\n  pointer data() {\n    return pointer(Begin);\n  }\n\n  /// data - Return a pointer to the vector's buffer, even if empty().\n  const_pointer data() const {\n    return const_pointer(Begin);\n  }\n\n  void push_back(const_reference Elt, const ASTContext &C) {\n    if (End < this->capacity_ptr()) {\n    Retry:\n      new (End) T(Elt);\n      ++End;\n      return;\n    }\n    grow(C);\n    goto Retry;\n  }\n\n  void reserve(const ASTContext &C, unsigned N) {\n    if (unsigned(this->capacity_ptr()-Begin) < N)\n      grow(C, N);\n  }\n\n  /// capacity - Return the total number of elements in the currently allocated\n  /// buffer.\n  size_t capacity() const { return this->capacity_ptr() - Begin; }\n\n  /// append - Add the specified range to the end of the SmallVector.\n  template<typename in_iter>\n  void append(const ASTContext &C, in_iter in_start, in_iter in_end) {\n    size_type NumInputs = std::distance(in_start, in_end);\n\n    if (NumInputs == 0)\n      return;\n\n    // Grow allocated space if needed.\n    if (NumInputs > size_type(this->capacity_ptr()-this->end()))\n      this->grow(C, this->size()+NumInputs);\n\n    // Copy the new elements over.\n    // TODO: NEED To compile time dispatch on whether in_iter is a random access\n    // iterator to use the fast uninitialized_copy.\n    std::uninitialized_copy(in_start, in_end, this->end());\n    this->setEnd(this->end() + NumInputs);\n  }\n\n  /// append - Add the specified range to the end of the SmallVector.\n  void append(const ASTContext &C, size_type NumInputs, const T &Elt) {\n    // Grow allocated space if needed.\n    if (NumInputs > size_type(this->capacity_ptr()-this->end()))\n      this->grow(C, this->size()+NumInputs);\n\n    // Copy the new elements over.\n    std::uninitialized_fill_n(this->end(), NumInputs, Elt);\n    this->setEnd(this->end() + NumInputs);\n  }\n\n  /// uninitialized_copy - Copy the range [I, E) onto the uninitialized memory\n  /// starting with \"Dest\", constructing elements into it as needed.\n  template<typename It1, typename It2>\n  static void uninitialized_copy(It1 I, It1 E, It2 Dest) {\n    std::uninitialized_copy(I, E, Dest);\n  }\n\n  iterator insert(const ASTContext &C, iterator I, const T &Elt) {\n    if (I == this->end()) {  // Important special case for empty vector.\n      push_back(Elt, C);\n      return this->end()-1;\n    }\n\n    if (this->End < this->capacity_ptr()) {\n    Retry:\n      new (this->end()) T(this->back());\n      this->setEnd(this->end()+1);\n      // Push everything else over.\n      std::copy_backward(I, this->end()-1, this->end());\n      *I = Elt;\n      return I;\n    }\n    size_t EltNo = I-this->begin();\n    this->grow(C);\n    I = this->begin()+EltNo;\n    goto Retry;\n  }\n\n  iterator insert(const ASTContext &C, iterator I, size_type NumToInsert,\n                  const T &Elt) {\n    // Convert iterator to elt# to avoid invalidating iterator when we reserve()\n    size_t InsertElt = I - this->begin();\n\n    if (I == this->end()) { // Important special case for empty vector.\n      append(C, NumToInsert, Elt);\n      return this->begin() + InsertElt;\n    }\n\n    // Ensure there is enough space.\n    reserve(C, static_cast<unsigned>(this->size() + NumToInsert));\n\n    // Uninvalidate the iterator.\n    I = this->begin()+InsertElt;\n\n    // If there are more elements between the insertion point and the end of the\n    // range than there are being inserted, we can use a simple approach to\n    // insertion.  Since we already reserved space, we know that this won't\n    // reallocate the vector.\n    if (size_t(this->end()-I) >= NumToInsert) {\n      T *OldEnd = this->end();\n      append(C, this->end()-NumToInsert, this->end());\n\n      // Copy the existing elements that get replaced.\n      std::copy_backward(I, OldEnd-NumToInsert, OldEnd);\n\n      std::fill_n(I, NumToInsert, Elt);\n      return I;\n    }\n\n    // Otherwise, we're inserting more elements than exist already, and we're\n    // not inserting at the end.\n\n    // Copy over the elements that we're about to overwrite.\n    T *OldEnd = this->end();\n    this->setEnd(this->end() + NumToInsert);\n    size_t NumOverwritten = OldEnd-I;\n    this->uninitialized_copy(I, OldEnd, this->end()-NumOverwritten);\n\n    // Replace the overwritten part.\n    std::fill_n(I, NumOverwritten, Elt);\n\n    // Insert the non-overwritten middle part.\n    std::uninitialized_fill_n(OldEnd, NumToInsert-NumOverwritten, Elt);\n    return I;\n  }\n\n  template<typename ItTy>\n  iterator insert(const ASTContext &C, iterator I, ItTy From, ItTy To) {\n    // Convert iterator to elt# to avoid invalidating iterator when we reserve()\n    size_t InsertElt = I - this->begin();\n\n    if (I == this->end()) { // Important special case for empty vector.\n      append(C, From, To);\n      return this->begin() + InsertElt;\n    }\n\n    size_t NumToInsert = std::distance(From, To);\n\n    // Ensure there is enough space.\n    reserve(C, static_cast<unsigned>(this->size() + NumToInsert));\n\n    // Uninvalidate the iterator.\n    I = this->begin()+InsertElt;\n\n    // If there are more elements between the insertion point and the end of the\n    // range than there are being inserted, we can use a simple approach to\n    // insertion.  Since we already reserved space, we know that this won't\n    // reallocate the vector.\n    if (size_t(this->end()-I) >= NumToInsert) {\n      T *OldEnd = this->end();\n      append(C, this->end()-NumToInsert, this->end());\n\n      // Copy the existing elements that get replaced.\n      std::copy_backward(I, OldEnd-NumToInsert, OldEnd);\n\n      std::copy(From, To, I);\n      return I;\n    }\n\n    // Otherwise, we're inserting more elements than exist already, and we're\n    // not inserting at the end.\n\n    // Copy over the elements that we're about to overwrite.\n    T *OldEnd = this->end();\n    this->setEnd(this->end() + NumToInsert);\n    size_t NumOverwritten = OldEnd-I;\n    this->uninitialized_copy(I, OldEnd, this->end()-NumOverwritten);\n\n    // Replace the overwritten part.\n    for (; NumOverwritten > 0; --NumOverwritten) {\n      *I = *From;\n      ++I; ++From;\n    }\n\n    // Insert the non-overwritten middle part.\n    this->uninitialized_copy(From, To, OldEnd);\n    return I;\n  }\n\n  void resize(const ASTContext &C, unsigned N, const T &NV) {\n    if (N < this->size()) {\n      this->destroy_range(this->begin()+N, this->end());\n      this->setEnd(this->begin()+N);\n    } else if (N > this->size()) {\n      if (this->capacity() < N)\n        this->grow(C, N);\n      construct_range(this->end(), this->begin()+N, NV);\n      this->setEnd(this->begin()+N);\n    }\n  }\n\nprivate:\n  /// grow - double the size of the allocated memory, guaranteeing space for at\n  /// least one more element or MinSize if specified.\n  void grow(const ASTContext &C, size_type MinSize = 1);\n\n  void construct_range(T *S, T *E, const T &Elt) {\n    for (; S != E; ++S)\n      new (S) T(Elt);\n  }\n\n  void destroy_range(T *S, T *E) {\n    while (S != E) {\n      --E;\n      E->~T();\n    }\n  }\n\nprotected:\n  const_iterator capacity_ptr() const {\n    return (iterator) Capacity.getPointer();\n  }\n\n  iterator capacity_ptr() { return (iterator)Capacity.getPointer(); }\n};\n\n// Define this out-of-line to dissuade the C++ compiler from inlining it.\ntemplate <typename T>\nvoid ASTVector<T>::grow(const ASTContext &C, size_t MinSize) {\n  size_t CurCapacity = this->capacity();\n  size_t CurSize = size();\n  size_t NewCapacity = 2*CurCapacity;\n  if (NewCapacity < MinSize)\n    NewCapacity = MinSize;\n\n  // Allocate the memory from the ASTContext.\n  T *NewElts = new (C, alignof(T)) T[NewCapacity];\n\n  // Copy the elements over.\n  if (Begin != End) {\n    if (std::is_class<T>::value) {\n      std::uninitialized_copy(Begin, End, NewElts);\n      // Destroy the original elements.\n      destroy_range(Begin, End);\n    } else {\n      // Use memcpy for PODs (std::uninitialized_copy optimizes to memmove).\n      memcpy(NewElts, Begin, CurSize * sizeof(T));\n    }\n  }\n\n  // ASTContext never frees any memory.\n  Begin = NewElts;\n  End = NewElts+CurSize;\n  Capacity.setPointer(Begin+NewCapacity);\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_ASTVECTOR_H\n"}, "3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Decl.h", "content": "//===- Decl.h - Classes for representing declarations -----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the Decl subclasses.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_DECL_H\n#define LLVM_CLANG_AST_DECL_H\n\n#include \"clang/AST/APValue.h\"\n#include \"clang/AST/ASTContextAllocate.h\"\n#include \"clang/AST/DeclAccessPair.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/ExternalASTSource.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/Redeclarable.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/AddressSpaces.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/Linkage.h\"\n#include \"clang/Basic/OperatorKinds.h\"\n#include \"clang/Basic/PartialDiagnostic.h\"\n#include \"clang/Basic/PragmaKinds.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Basic/Visibility.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <string>\n#include <utility>\n\nnamespace clang {\n\nclass ASTContext;\nstruct ASTTemplateArgumentListInfo;\nclass Attr;\nclass CompoundStmt;\nclass DependentFunctionTemplateSpecializationInfo;\nclass EnumDecl;\nclass Expr;\nclass FunctionTemplateDecl;\nclass FunctionTemplateSpecializationInfo;\nclass FunctionTypeLoc;\nclass LabelStmt;\nclass MemberSpecializationInfo;\nclass Module;\nclass NamespaceDecl;\nclass ParmVarDecl;\nclass RecordDecl;\nclass Stmt;\nclass StringLiteral;\nclass TagDecl;\nclass TemplateArgumentList;\nclass TemplateArgumentListInfo;\nclass TemplateParameterList;\nclass TypeAliasTemplateDecl;\nclass TypeLoc;\nclass UnresolvedSetImpl;\nclass VarTemplateDecl;\n\n/// The top declaration context.\nclass TranslationUnitDecl : public Decl, public DeclContext {\n  ASTContext &Ctx;\n\n  /// The (most recently entered) anonymous namespace for this\n  /// translation unit, if one has been created.\n  NamespaceDecl *AnonymousNamespace = nullptr;\n\n  explicit TranslationUnitDecl(ASTContext &ctx);\n\n  virtual void anchor();\n\npublic:\n  ASTContext &getASTContext() const { return Ctx; }\n\n  NamespaceDecl *getAnonymousNamespace() const { return AnonymousNamespace; }\n  void setAnonymousNamespace(NamespaceDecl *D) { AnonymousNamespace = D; }\n\n  static TranslationUnitDecl *Create(ASTContext &C);\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == TranslationUnit; }\n  static DeclContext *castToDeclContext(const TranslationUnitDecl *D) {\n    return static_cast<DeclContext *>(const_cast<TranslationUnitDecl*>(D));\n  }\n  static TranslationUnitDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<TranslationUnitDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Represents a `#pragma comment` line. Always a child of\n/// TranslationUnitDecl.\nclass PragmaCommentDecl final\n    : public Decl,\n      private llvm::TrailingObjects<PragmaCommentDecl, char> {\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend TrailingObjects;\n\n  PragmaMSCommentKind CommentKind;\n\n  PragmaCommentDecl(TranslationUnitDecl *TU, SourceLocation CommentLoc,\n                    PragmaMSCommentKind CommentKind)\n      : Decl(PragmaComment, TU, CommentLoc), CommentKind(CommentKind) {}\n\n  virtual void anchor();\n\npublic:\n  static PragmaCommentDecl *Create(const ASTContext &C, TranslationUnitDecl *DC,\n                                   SourceLocation CommentLoc,\n                                   PragmaMSCommentKind CommentKind,\n                                   StringRef Arg);\n  static PragmaCommentDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                               unsigned ArgSize);\n\n  PragmaMSCommentKind getCommentKind() const { return CommentKind; }\n\n  StringRef getArg() const { return getTrailingObjects<char>(); }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == PragmaComment; }\n};\n\n/// Represents a `#pragma detect_mismatch` line. Always a child of\n/// TranslationUnitDecl.\nclass PragmaDetectMismatchDecl final\n    : public Decl,\n      private llvm::TrailingObjects<PragmaDetectMismatchDecl, char> {\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend TrailingObjects;\n\n  size_t ValueStart;\n\n  PragmaDetectMismatchDecl(TranslationUnitDecl *TU, SourceLocation Loc,\n                           size_t ValueStart)\n      : Decl(PragmaDetectMismatch, TU, Loc), ValueStart(ValueStart) {}\n\n  virtual void anchor();\n\npublic:\n  static PragmaDetectMismatchDecl *Create(const ASTContext &C,\n                                          TranslationUnitDecl *DC,\n                                          SourceLocation Loc, StringRef Name,\n                                          StringRef Value);\n  static PragmaDetectMismatchDecl *\n  CreateDeserialized(ASTContext &C, unsigned ID, unsigned NameValueSize);\n\n  StringRef getName() const { return getTrailingObjects<char>(); }\n  StringRef getValue() const { return getTrailingObjects<char>() + ValueStart; }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == PragmaDetectMismatch; }\n};\n\n/// Declaration context for names declared as extern \"C\" in C++. This\n/// is neither the semantic nor lexical context for such declarations, but is\n/// used to check for conflicts with other extern \"C\" declarations. Example:\n///\n/// \\code\n///   namespace N { extern \"C\" void f(); } // #1\n///   void N::f() {}                       // #2\n///   namespace M { extern \"C\" void f(); } // #3\n/// \\endcode\n///\n/// The semantic context of #1 is namespace N and its lexical context is the\n/// LinkageSpecDecl; the semantic context of #2 is namespace N and its lexical\n/// context is the TU. However, both declarations are also visible in the\n/// extern \"C\" context.\n///\n/// The declaration at #3 finds it is a redeclaration of \\c N::f through\n/// lookup in the extern \"C\" context.\nclass ExternCContextDecl : public Decl, public DeclContext {\n  explicit ExternCContextDecl(TranslationUnitDecl *TU)\n    : Decl(ExternCContext, TU, SourceLocation()),\n      DeclContext(ExternCContext) {}\n\n  virtual void anchor();\n\npublic:\n  static ExternCContextDecl *Create(const ASTContext &C,\n                                    TranslationUnitDecl *TU);\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ExternCContext; }\n  static DeclContext *castToDeclContext(const ExternCContextDecl *D) {\n    return static_cast<DeclContext *>(const_cast<ExternCContextDecl*>(D));\n  }\n  static ExternCContextDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<ExternCContextDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// This represents a decl that may have a name.  Many decls have names such\n/// as ObjCMethodDecl, but not \\@class, etc.\n///\n/// Note that not every NamedDecl is actually named (e.g., a struct might\n/// be anonymous), and not every name is an identifier.\nclass NamedDecl : public Decl {\n  /// The name of this declaration, which is typically a normal\n  /// identifier but may also be a special kind of name (C++\n  /// constructor, Objective-C selector, etc.)\n  DeclarationName Name;\n\n  virtual void anchor();\n\nprivate:\n  NamedDecl *getUnderlyingDeclImpl() LLVM_READONLY;\n\nprotected:\n  NamedDecl(Kind DK, DeclContext *DC, SourceLocation L, DeclarationName N)\n      : Decl(DK, DC, L), Name(N) {}\n\npublic:\n  /// Get the identifier that names this declaration, if there is one.\n  ///\n  /// This will return NULL if this declaration has no name (e.g., for\n  /// an unnamed class) or if the name is a special name (C++ constructor,\n  /// Objective-C selector, etc.).\n  IdentifierInfo *getIdentifier() const { return Name.getAsIdentifierInfo(); }\n\n  /// Get the name of identifier for this declaration as a StringRef.\n  ///\n  /// This requires that the declaration have a name and that it be a simple\n  /// identifier.\n  StringRef getName() const {\n    assert(Name.isIdentifier() && \"Name is not a simple identifier\");\n    return getIdentifier() ? getIdentifier()->getName() : \"\";\n  }\n\n  /// Get a human-readable name for the declaration, even if it is one of the\n  /// special kinds of names (C++ constructor, Objective-C selector, etc).\n  ///\n  /// Creating this name requires expensive string manipulation, so it should\n  /// be called only when performance doesn't matter. For simple declarations,\n  /// getNameAsCString() should suffice.\n  //\n  // FIXME: This function should be renamed to indicate that it is not just an\n  // alternate form of getName(), and clients should move as appropriate.\n  //\n  // FIXME: Deprecated, move clients to getName().\n  std::string getNameAsString() const { return Name.getAsString(); }\n\n  /// Pretty-print the unqualified name of this declaration. Can be overloaded\n  /// by derived classes to provide a more user-friendly name when appropriate.\n  virtual void printName(raw_ostream &os) const;\n\n  /// Get the actual, stored name of the declaration, which may be a special\n  /// name.\n  ///\n  /// Note that generally in diagnostics, the non-null \\p NamedDecl* itself\n  /// should be sent into the diagnostic instead of using the result of\n  /// \\p getDeclName().\n  ///\n  /// A \\p DeclarationName in a diagnostic will just be streamed to the output,\n  /// which will directly result in a call to \\p DeclarationName::print.\n  ///\n  /// A \\p NamedDecl* in a diagnostic will also ultimately result in a call to\n  /// \\p DeclarationName::print, but with two customisation points along the\n  /// way (\\p getNameForDiagnostic and \\p printName). These are used to print\n  /// the template arguments if any, and to provide a user-friendly name for\n  /// some entities (such as unnamed variables and anonymous records).\n  DeclarationName getDeclName() const { return Name; }\n\n  /// Set the name of this declaration.\n  void setDeclName(DeclarationName N) { Name = N; }\n\n  /// Returns a human-readable qualified name for this declaration, like\n  /// A::B::i, for i being member of namespace A::B.\n  ///\n  /// If the declaration is not a member of context which can be named (record,\n  /// namespace), it will return the same result as printName().\n  ///\n  /// Creating this name is expensive, so it should be called only when\n  /// performance doesn't matter.\n  void printQualifiedName(raw_ostream &OS) const;\n  void printQualifiedName(raw_ostream &OS, const PrintingPolicy &Policy) const;\n\n  /// Print only the nested name specifier part of a fully-qualified name,\n  /// including the '::' at the end. E.g.\n  ///    when `printQualifiedName(D)` prints \"A::B::i\",\n  ///    this function prints \"A::B::\".\n  void printNestedNameSpecifier(raw_ostream &OS) const;\n  void printNestedNameSpecifier(raw_ostream &OS,\n                                const PrintingPolicy &Policy) const;\n\n  // FIXME: Remove string version.\n  std::string getQualifiedNameAsString() const;\n\n  /// Appends a human-readable name for this declaration into the given stream.\n  ///\n  /// This is the method invoked by Sema when displaying a NamedDecl\n  /// in a diagnostic.  It does not necessarily produce the same\n  /// result as printName(); for example, class template\n  /// specializations are printed with their template arguments.\n  virtual void getNameForDiagnostic(raw_ostream &OS,\n                                    const PrintingPolicy &Policy,\n                                    bool Qualified) const;\n\n  /// Determine whether this declaration, if known to be well-formed within\n  /// its context, will replace the declaration OldD if introduced into scope.\n  ///\n  /// A declaration will replace another declaration if, for example, it is\n  /// a redeclaration of the same variable or function, but not if it is a\n  /// declaration of a different kind (function vs. class) or an overloaded\n  /// function.\n  ///\n  /// \\param IsKnownNewer \\c true if this declaration is known to be newer\n  /// than \\p OldD (for instance, if this declaration is newly-created).\n  bool declarationReplaces(NamedDecl *OldD, bool IsKnownNewer = true) const;\n\n  /// Determine whether this declaration has linkage.\n  bool hasLinkage() const;\n\n  using Decl::isModulePrivate;\n  using Decl::setModulePrivate;\n\n  /// Determine whether this declaration is a C++ class member.\n  bool isCXXClassMember() const {\n    const DeclContext *DC = getDeclContext();\n\n    // C++0x [class.mem]p1:\n    //   The enumerators of an unscoped enumeration defined in\n    //   the class are members of the class.\n    if (isa<EnumDecl>(DC))\n      DC = DC->getRedeclContext();\n\n    return DC->isRecord();\n  }\n\n  /// Determine whether the given declaration is an instance member of\n  /// a C++ class.\n  bool isCXXInstanceMember() const;\n\n  /// Determine what kind of linkage this entity has.\n  ///\n  /// This is not the linkage as defined by the standard or the codegen notion\n  /// of linkage. It is just an implementation detail that is used to compute\n  /// those.\n  Linkage getLinkageInternal() const;\n\n  /// Get the linkage from a semantic point of view. Entities in\n  /// anonymous namespaces are external (in c++98).\n  Linkage getFormalLinkage() const {\n    return clang::getFormalLinkage(getLinkageInternal());\n  }\n\n  /// True if this decl has external linkage.\n  bool hasExternalFormalLinkage() const {\n    return isExternalFormalLinkage(getLinkageInternal());\n  }\n\n  bool isExternallyVisible() const {\n    return clang::isExternallyVisible(getLinkageInternal());\n  }\n\n  /// Determine whether this declaration can be redeclared in a\n  /// different translation unit.\n  bool isExternallyDeclarable() const {\n    return isExternallyVisible() && !getOwningModuleForLinkage();\n  }\n\n  /// Determines the visibility of this entity.\n  Visibility getVisibility() const {\n    return getLinkageAndVisibility().getVisibility();\n  }\n\n  /// Determines the linkage and visibility of this entity.\n  LinkageInfo getLinkageAndVisibility() const;\n\n  /// Kinds of explicit visibility.\n  enum ExplicitVisibilityKind {\n    /// Do an LV computation for, ultimately, a type.\n    /// Visibility may be restricted by type visibility settings and\n    /// the visibility of template arguments.\n    VisibilityForType,\n\n    /// Do an LV computation for, ultimately, a non-type declaration.\n    /// Visibility may be restricted by value visibility settings and\n    /// the visibility of template arguments.\n    VisibilityForValue\n  };\n\n  /// If visibility was explicitly specified for this\n  /// declaration, return that visibility.\n  Optional<Visibility>\n  getExplicitVisibility(ExplicitVisibilityKind kind) const;\n\n  /// True if the computed linkage is valid. Used for consistency\n  /// checking. Should always return true.\n  bool isLinkageValid() const;\n\n  /// True if something has required us to compute the linkage\n  /// of this declaration.\n  ///\n  /// Language features which can retroactively change linkage (like a\n  /// typedef name for linkage purposes) may need to consider this,\n  /// but hopefully only in transitory ways during parsing.\n  bool hasLinkageBeenComputed() const {\n    return hasCachedLinkage();\n  }\n\n  /// Looks through UsingDecls and ObjCCompatibleAliasDecls for\n  /// the underlying named decl.\n  NamedDecl *getUnderlyingDecl() {\n    // Fast-path the common case.\n    if (this->getKind() != UsingShadow &&\n        this->getKind() != ConstructorUsingShadow &&\n        this->getKind() != ObjCCompatibleAlias &&\n        this->getKind() != NamespaceAlias)\n      return this;\n\n    return getUnderlyingDeclImpl();\n  }\n  const NamedDecl *getUnderlyingDecl() const {\n    return const_cast<NamedDecl*>(this)->getUnderlyingDecl();\n  }\n\n  NamedDecl *getMostRecentDecl() {\n    return cast<NamedDecl>(static_cast<Decl *>(this)->getMostRecentDecl());\n  }\n  const NamedDecl *getMostRecentDecl() const {\n    return const_cast<NamedDecl*>(this)->getMostRecentDecl();\n  }\n\n  ObjCStringFormatFamily getObjCFStringFormattingFamily() const;\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K >= firstNamed && K <= lastNamed; }\n};\n\ninline raw_ostream &operator<<(raw_ostream &OS, const NamedDecl &ND) {\n  ND.printName(OS);\n  return OS;\n}\n\n/// Represents the declaration of a label.  Labels also have a\n/// corresponding LabelStmt, which indicates the position that the label was\n/// defined at.  For normal labels, the location of the decl is the same as the\n/// location of the statement.  For GNU local labels (__label__), the decl\n/// location is where the __label__ is.\nclass LabelDecl : public NamedDecl {\n  LabelStmt *TheStmt;\n  StringRef MSAsmName;\n  bool MSAsmNameResolved = false;\n\n  /// For normal labels, this is the same as the main declaration\n  /// label, i.e., the location of the identifier; for GNU local labels,\n  /// this is the location of the __label__ keyword.\n  SourceLocation LocStart;\n\n  LabelDecl(DeclContext *DC, SourceLocation IdentL, IdentifierInfo *II,\n            LabelStmt *S, SourceLocation StartL)\n      : NamedDecl(Label, DC, IdentL, II), TheStmt(S), LocStart(StartL) {}\n\n  void anchor() override;\n\npublic:\n  static LabelDecl *Create(ASTContext &C, DeclContext *DC,\n                           SourceLocation IdentL, IdentifierInfo *II);\n  static LabelDecl *Create(ASTContext &C, DeclContext *DC,\n                           SourceLocation IdentL, IdentifierInfo *II,\n                           SourceLocation GnuLabelL);\n  static LabelDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  LabelStmt *getStmt() const { return TheStmt; }\n  void setStmt(LabelStmt *T) { TheStmt = T; }\n\n  bool isGnuLocal() const { return LocStart != getLocation(); }\n  void setLocStart(SourceLocation L) { LocStart = L; }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(LocStart, getLocation());\n  }\n\n  bool isMSAsmLabel() const { return !MSAsmName.empty(); }\n  bool isResolvedMSAsmLabel() const { return isMSAsmLabel() && MSAsmNameResolved; }\n  void setMSAsmLabel(StringRef Name);\n  StringRef getMSAsmLabel() const { return MSAsmName; }\n  void setMSAsmLabelResolved() { MSAsmNameResolved = true; }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Label; }\n};\n\n/// Represent a C++ namespace.\nclass NamespaceDecl : public NamedDecl, public DeclContext,\n                      public Redeclarable<NamespaceDecl>\n{\n  /// The starting location of the source range, pointing\n  /// to either the namespace or the inline keyword.\n  SourceLocation LocStart;\n\n  /// The ending location of the source range.\n  SourceLocation RBraceLoc;\n\n  /// A pointer to either the anonymous namespace that lives just inside\n  /// this namespace or to the first namespace in the chain (the latter case\n  /// only when this is not the first in the chain), along with a\n  /// boolean value indicating whether this is an inline namespace.\n  llvm::PointerIntPair<NamespaceDecl *, 1, bool> AnonOrFirstNamespaceAndInline;\n\n  NamespaceDecl(ASTContext &C, DeclContext *DC, bool Inline,\n                SourceLocation StartLoc, SourceLocation IdLoc,\n                IdentifierInfo *Id, NamespaceDecl *PrevDecl);\n\n  using redeclarable_base = Redeclarable<NamespaceDecl>;\n\n  NamespaceDecl *getNextRedeclarationImpl() override;\n  NamespaceDecl *getPreviousDeclImpl() override;\n  NamespaceDecl *getMostRecentDeclImpl() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static NamespaceDecl *Create(ASTContext &C, DeclContext *DC,\n                               bool Inline, SourceLocation StartLoc,\n                               SourceLocation IdLoc, IdentifierInfo *Id,\n                               NamespaceDecl *PrevDecl);\n\n  static NamespaceDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  /// Returns true if this is an anonymous namespace declaration.\n  ///\n  /// For example:\n  /// \\code\n  ///   namespace {\n  ///     ...\n  ///   };\n  /// \\endcode\n  /// q.v. C++ [namespace.unnamed]\n  bool isAnonymousNamespace() const {\n    return !getIdentifier();\n  }\n\n  /// Returns true if this is an inline namespace declaration.\n  bool isInline() const {\n    return AnonOrFirstNamespaceAndInline.getInt();\n  }\n\n  /// Set whether this is an inline namespace declaration.\n  void setInline(bool Inline) {\n    AnonOrFirstNamespaceAndInline.setInt(Inline);\n  }\n\n  /// Get the original (first) namespace declaration.\n  NamespaceDecl *getOriginalNamespace();\n\n  /// Get the original (first) namespace declaration.\n  const NamespaceDecl *getOriginalNamespace() const;\n\n  /// Return true if this declaration is an original (first) declaration\n  /// of the namespace. This is false for non-original (subsequent) namespace\n  /// declarations and anonymous namespaces.\n  bool isOriginalNamespace() const;\n\n  /// Retrieve the anonymous namespace nested inside this namespace,\n  /// if any.\n  NamespaceDecl *getAnonymousNamespace() const {\n    return getOriginalNamespace()->AnonOrFirstNamespaceAndInline.getPointer();\n  }\n\n  void setAnonymousNamespace(NamespaceDecl *D) {\n    getOriginalNamespace()->AnonOrFirstNamespaceAndInline.setPointer(D);\n  }\n\n  /// Retrieves the canonical declaration of this namespace.\n  NamespaceDecl *getCanonicalDecl() override {\n    return getOriginalNamespace();\n  }\n  const NamespaceDecl *getCanonicalDecl() const {\n    return getOriginalNamespace();\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(LocStart, RBraceLoc);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return LocStart; }\n  SourceLocation getRBraceLoc() const { return RBraceLoc; }\n  void setLocStart(SourceLocation L) { LocStart = L; }\n  void setRBraceLoc(SourceLocation L) { RBraceLoc = L; }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Namespace; }\n  static DeclContext *castToDeclContext(const NamespaceDecl *D) {\n    return static_cast<DeclContext *>(const_cast<NamespaceDecl*>(D));\n  }\n  static NamespaceDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<NamespaceDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Represent the declaration of a variable (in which case it is\n/// an lvalue) a function (in which case it is a function designator) or\n/// an enum constant.\nclass ValueDecl : public NamedDecl {\n  QualType DeclType;\n\n  void anchor() override;\n\nprotected:\n  ValueDecl(Kind DK, DeclContext *DC, SourceLocation L,\n            DeclarationName N, QualType T)\n    : NamedDecl(DK, DC, L, N), DeclType(T) {}\n\npublic:\n  QualType getType() const { return DeclType; }\n  void setType(QualType newType) { DeclType = newType; }\n\n  /// Determine whether this symbol is weakly-imported,\n  ///        or declared with the weak or weak-ref attr.\n  bool isWeak() const;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K >= firstValue && K <= lastValue; }\n};\n\n/// A struct with extended info about a syntactic\n/// name qualifier, to be used for the case of out-of-line declarations.\nstruct QualifierInfo {\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// The number of \"outer\" template parameter lists.\n  /// The count includes all of the template parameter lists that were matched\n  /// against the template-ids occurring into the NNS and possibly (in the\n  /// case of an explicit specialization) a final \"template <>\".\n  unsigned NumTemplParamLists = 0;\n\n  /// A new-allocated array of size NumTemplParamLists,\n  /// containing pointers to the \"outer\" template parameter lists.\n  /// It includes all of the template parameter lists that were matched\n  /// against the template-ids occurring into the NNS and possibly (in the\n  /// case of an explicit specialization) a final \"template <>\".\n  TemplateParameterList** TemplParamLists = nullptr;\n\n  QualifierInfo() = default;\n  QualifierInfo(const QualifierInfo &) = delete;\n  QualifierInfo& operator=(const QualifierInfo &) = delete;\n\n  /// Sets info about \"outer\" template parameter lists.\n  void setTemplateParameterListsInfo(ASTContext &Context,\n                                     ArrayRef<TemplateParameterList *> TPLists);\n};\n\n/// Represents a ValueDecl that came out of a declarator.\n/// Contains type source information through TypeSourceInfo.\nclass DeclaratorDecl : public ValueDecl {\n  // A struct representing a TInfo, a trailing requires-clause and a syntactic\n  // qualifier, to be used for the (uncommon) case of out-of-line declarations\n  // and constrained function decls.\n  struct ExtInfo : public QualifierInfo {\n    TypeSourceInfo *TInfo;\n    Expr *TrailingRequiresClause = nullptr;\n  };\n\n  llvm::PointerUnion<TypeSourceInfo *, ExtInfo *> DeclInfo;\n\n  /// The start of the source range for this declaration,\n  /// ignoring outer template declarations.\n  SourceLocation InnerLocStart;\n\n  bool hasExtInfo() const { return DeclInfo.is<ExtInfo*>(); }\n  ExtInfo *getExtInfo() { return DeclInfo.get<ExtInfo*>(); }\n  const ExtInfo *getExtInfo() const { return DeclInfo.get<ExtInfo*>(); }\n\nprotected:\n  DeclaratorDecl(Kind DK, DeclContext *DC, SourceLocation L,\n                 DeclarationName N, QualType T, TypeSourceInfo *TInfo,\n                 SourceLocation StartL)\n      : ValueDecl(DK, DC, L, N, T), DeclInfo(TInfo), InnerLocStart(StartL) {}\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return hasExtInfo()\n      ? getExtInfo()->TInfo\n      : DeclInfo.get<TypeSourceInfo*>();\n  }\n\n  void setTypeSourceInfo(TypeSourceInfo *TI) {\n    if (hasExtInfo())\n      getExtInfo()->TInfo = TI;\n    else\n      DeclInfo = TI;\n  }\n\n  /// Return start of source range ignoring outer template declarations.\n  SourceLocation getInnerLocStart() const { return InnerLocStart; }\n  void setInnerLocStart(SourceLocation L) { InnerLocStart = L; }\n\n  /// Return start of source range taking into account any outer template\n  /// declarations.\n  SourceLocation getOuterLocStart() const;\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getOuterLocStart();\n  }\n\n  /// Retrieve the nested-name-specifier that qualifies the name of this\n  /// declaration, if it was present in the source.\n  NestedNameSpecifier *getQualifier() const {\n    return hasExtInfo() ? getExtInfo()->QualifierLoc.getNestedNameSpecifier()\n                        : nullptr;\n  }\n\n  /// Retrieve the nested-name-specifier (with source-location\n  /// information) that qualifies the name of this declaration, if it was\n  /// present in the source.\n  NestedNameSpecifierLoc getQualifierLoc() const {\n    return hasExtInfo() ? getExtInfo()->QualifierLoc\n                        : NestedNameSpecifierLoc();\n  }\n\n  void setQualifierInfo(NestedNameSpecifierLoc QualifierLoc);\n\n  /// \\brief Get the constraint-expression introduced by the trailing\n  /// requires-clause in the function/member declaration, or null if no\n  /// requires-clause was provided.\n  Expr *getTrailingRequiresClause() {\n    return hasExtInfo() ? getExtInfo()->TrailingRequiresClause\n                        : nullptr;\n  }\n\n  const Expr *getTrailingRequiresClause() const {\n    return hasExtInfo() ? getExtInfo()->TrailingRequiresClause\n                        : nullptr;\n  }\n\n  void setTrailingRequiresClause(Expr *TrailingRequiresClause);\n\n  unsigned getNumTemplateParameterLists() const {\n    return hasExtInfo() ? getExtInfo()->NumTemplParamLists : 0;\n  }\n\n  TemplateParameterList *getTemplateParameterList(unsigned index) const {\n    assert(index < getNumTemplateParameterLists());\n    return getExtInfo()->TemplParamLists[index];\n  }\n\n  void setTemplateParameterListsInfo(ASTContext &Context,\n                                     ArrayRef<TemplateParameterList *> TPLists);\n\n  SourceLocation getTypeSpecStartLoc() const;\n  SourceLocation getTypeSpecEndLoc() const;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K >= firstDeclarator && K <= lastDeclarator;\n  }\n};\n\n/// Structure used to store a statement, the constant value to\n/// which it was evaluated (if any), and whether or not the statement\n/// is an integral constant expression (if known).\nstruct EvaluatedStmt {\n  /// Whether this statement was already evaluated.\n  bool WasEvaluated : 1;\n\n  /// Whether this statement is being evaluated.\n  bool IsEvaluating : 1;\n\n  /// Whether this variable is known to have constant initialization. This is\n  /// currently only computed in C++, for static / thread storage duration\n  /// variables that might have constant initialization and for variables that\n  /// are usable in constant expressions.\n  bool HasConstantInitialization : 1;\n\n  /// Whether this variable is known to have constant destruction. That is,\n  /// whether running the destructor on the initial value is a side-effect\n  /// (and doesn't inspect any state that might have changed during program\n  /// execution). This is currently only computed if the destructor is\n  /// non-trivial.\n  bool HasConstantDestruction : 1;\n\n  /// In C++98, whether the initializer is an ICE. This affects whether the\n  /// variable is usable in constant expressions.\n  bool HasICEInit : 1;\n  bool CheckedForICEInit : 1;\n\n  Stmt *Value;\n  APValue Evaluated;\n\n  EvaluatedStmt()\n      : WasEvaluated(false), IsEvaluating(false),\n        HasConstantInitialization(false), HasConstantDestruction(false),\n        HasICEInit(false), CheckedForICEInit(false) {}\n};\n\n/// Represents a variable declaration or definition.\nclass VarDecl : public DeclaratorDecl, public Redeclarable<VarDecl> {\npublic:\n  /// Initialization styles.\n  enum InitializationStyle {\n    /// C-style initialization with assignment\n    CInit,\n\n    /// Call-style initialization (C++98)\n    CallInit,\n\n    /// Direct list-initialization (C++11)\n    ListInit\n  };\n\n  /// Kinds of thread-local storage.\n  enum TLSKind {\n    /// Not a TLS variable.\n    TLS_None,\n\n    /// TLS with a known-constant initializer.\n    TLS_Static,\n\n    /// TLS with a dynamic initializer.\n    TLS_Dynamic\n  };\n\n  /// Return the string used to specify the storage class \\p SC.\n  ///\n  /// It is illegal to call this function with SC == None.\n  static const char *getStorageClassSpecifierString(StorageClass SC);\n\nprotected:\n  // A pointer union of Stmt * and EvaluatedStmt *. When an EvaluatedStmt, we\n  // have allocated the auxiliary struct of information there.\n  //\n  // TODO: It is a bit unfortunate to use a PointerUnion inside the VarDecl for\n  // this as *many* VarDecls are ParmVarDecls that don't have default\n  // arguments. We could save some space by moving this pointer union to be\n  // allocated in trailing space when necessary.\n  using InitType = llvm::PointerUnion<Stmt *, EvaluatedStmt *>;\n\n  /// The initializer for this variable or, for a ParmVarDecl, the\n  /// C++ default argument.\n  mutable InitType Init;\n\nprivate:\n  friend class ASTDeclReader;\n  friend class ASTNodeImporter;\n  friend class StmtIteratorBase;\n\n  class VarDeclBitfields {\n    friend class ASTDeclReader;\n    friend class VarDecl;\n\n    unsigned SClass : 3;\n    unsigned TSCSpec : 2;\n    unsigned InitStyle : 2;\n\n    /// Whether this variable is an ARC pseudo-__strong variable; see\n    /// isARCPseudoStrong() for details.\n    unsigned ARCPseudoStrong : 1;\n  };\n  enum { NumVarDeclBits = 8 };\n\nprotected:\n  enum { NumParameterIndexBits = 8 };\n\n  enum DefaultArgKind {\n    DAK_None,\n    DAK_Unparsed,\n    DAK_Uninstantiated,\n    DAK_Normal\n  };\n\n  enum { NumScopeDepthOrObjCQualsBits = 7 };\n\n  class ParmVarDeclBitfields {\n    friend class ASTDeclReader;\n    friend class ParmVarDecl;\n\n    unsigned : NumVarDeclBits;\n\n    /// Whether this parameter inherits a default argument from a\n    /// prior declaration.\n    unsigned HasInheritedDefaultArg : 1;\n\n    /// Describes the kind of default argument for this parameter. By default\n    /// this is none. If this is normal, then the default argument is stored in\n    /// the \\c VarDecl initializer expression unless we were unable to parse\n    /// (even an invalid) expression for the default argument.\n    unsigned DefaultArgKind : 2;\n\n    /// Whether this parameter undergoes K&R argument promotion.\n    unsigned IsKNRPromoted : 1;\n\n    /// Whether this parameter is an ObjC method parameter or not.\n    unsigned IsObjCMethodParam : 1;\n\n    /// If IsObjCMethodParam, a Decl::ObjCDeclQualifier.\n    /// Otherwise, the number of function parameter scopes enclosing\n    /// the function parameter scope in which this parameter was\n    /// declared.\n    unsigned ScopeDepthOrObjCQuals : NumScopeDepthOrObjCQualsBits;\n\n    /// The number of parameters preceding this parameter in the\n    /// function parameter scope in which it was declared.\n    unsigned ParameterIndex : NumParameterIndexBits;\n  };\n\n  class NonParmVarDeclBitfields {\n    friend class ASTDeclReader;\n    friend class ImplicitParamDecl;\n    friend class VarDecl;\n\n    unsigned : NumVarDeclBits;\n\n    // FIXME: We need something similar to CXXRecordDecl::DefinitionData.\n    /// Whether this variable is a definition which was demoted due to\n    /// module merge.\n    unsigned IsThisDeclarationADemotedDefinition : 1;\n\n    /// Whether this variable is the exception variable in a C++ catch\n    /// or an Objective-C @catch statement.\n    unsigned ExceptionVar : 1;\n\n    /// Whether this local variable could be allocated in the return\n    /// slot of its function, enabling the named return value optimization\n    /// (NRVO).\n    unsigned NRVOVariable : 1;\n\n    /// Whether this variable is the for-range-declaration in a C++0x\n    /// for-range statement.\n    unsigned CXXForRangeDecl : 1;\n\n    /// Whether this variable is the for-in loop declaration in Objective-C.\n    unsigned ObjCForDecl : 1;\n\n    /// Whether this variable is (C++1z) inline.\n    unsigned IsInline : 1;\n\n    /// Whether this variable has (C++1z) inline explicitly specified.\n    unsigned IsInlineSpecified : 1;\n\n    /// Whether this variable is (C++0x) constexpr.\n    unsigned IsConstexpr : 1;\n\n    /// Whether this variable is the implicit variable for a lambda\n    /// init-capture.\n    unsigned IsInitCapture : 1;\n\n    /// Whether this local extern variable's previous declaration was\n    /// declared in the same block scope. This controls whether we should merge\n    /// the type of this declaration with its previous declaration.\n    unsigned PreviousDeclInSameBlockScope : 1;\n\n    /// Defines kind of the ImplicitParamDecl: 'this', 'self', 'vtt', '_cmd' or\n    /// something else.\n    unsigned ImplicitParamKind : 3;\n\n    unsigned EscapingByref : 1;\n  };\n\n  union {\n    unsigned AllBits;\n    VarDeclBitfields VarDeclBits;\n    ParmVarDeclBitfields ParmVarDeclBits;\n    NonParmVarDeclBitfields NonParmVarDeclBits;\n  };\n\n  VarDecl(Kind DK, ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n          SourceLocation IdLoc, IdentifierInfo *Id, QualType T,\n          TypeSourceInfo *TInfo, StorageClass SC);\n\n  using redeclarable_base = Redeclarable<VarDecl>;\n\n  VarDecl *getNextRedeclarationImpl() override {\n    return getNextRedeclaration();\n  }\n\n  VarDecl *getPreviousDeclImpl() override {\n    return getPreviousDecl();\n  }\n\n  VarDecl *getMostRecentDeclImpl() override {\n    return getMostRecentDecl();\n  }\n\npublic:\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  static VarDecl *Create(ASTContext &C, DeclContext *DC,\n                         SourceLocation StartLoc, SourceLocation IdLoc,\n                         IdentifierInfo *Id, QualType T, TypeSourceInfo *TInfo,\n                         StorageClass S);\n\n  static VarDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  /// Returns the storage class as written in the source. For the\n  /// computed linkage of symbol, see getLinkage.\n  StorageClass getStorageClass() const {\n    return (StorageClass) VarDeclBits.SClass;\n  }\n  void setStorageClass(StorageClass SC);\n\n  void setTSCSpec(ThreadStorageClassSpecifier TSC) {\n    VarDeclBits.TSCSpec = TSC;\n    assert(VarDeclBits.TSCSpec == TSC && \"truncation\");\n  }\n  ThreadStorageClassSpecifier getTSCSpec() const {\n    return static_cast<ThreadStorageClassSpecifier>(VarDeclBits.TSCSpec);\n  }\n  TLSKind getTLSKind() const;\n\n  /// Returns true if a variable with function scope is a non-static local\n  /// variable.\n  bool hasLocalStorage() const {\n    if (getStorageClass() == SC_None) {\n      // OpenCL v1.2 s6.5.3: The __constant or constant address space name is\n      // used to describe variables allocated in global memory and which are\n      // accessed inside a kernel(s) as read-only variables. As such, variables\n      // in constant address space cannot have local storage.\n      if (getType().getAddressSpace() == LangAS::opencl_constant)\n        return false;\n      // Second check is for C++11 [dcl.stc]p4.\n      return !isFileVarDecl() && getTSCSpec() == TSCS_unspecified;\n    }\n\n    // Global Named Register (GNU extension)\n    if (getStorageClass() == SC_Register && !isLocalVarDeclOrParm())\n      return false;\n\n    // Return true for:  Auto, Register.\n    // Return false for: Extern, Static, PrivateExtern, OpenCLWorkGroupLocal.\n\n    return getStorageClass() >= SC_Auto;\n  }\n\n  /// Returns true if a variable with function scope is a static local\n  /// variable.\n  bool isStaticLocal() const {\n    return (getStorageClass() == SC_Static ||\n            // C++11 [dcl.stc]p4\n            (getStorageClass() == SC_None && getTSCSpec() == TSCS_thread_local))\n      && !isFileVarDecl();\n  }\n\n  /// Returns true if a variable has extern or __private_extern__\n  /// storage.\n  bool hasExternalStorage() const {\n    return getStorageClass() == SC_Extern ||\n           getStorageClass() == SC_PrivateExtern;\n  }\n\n  /// Returns true for all variables that do not have local storage.\n  ///\n  /// This includes all global variables as well as static variables declared\n  /// within a function.\n  bool hasGlobalStorage() const { return !hasLocalStorage(); }\n\n  /// Get the storage duration of this variable, per C++ [basic.stc].\n  StorageDuration getStorageDuration() const {\n    return hasLocalStorage() ? SD_Automatic :\n           getTSCSpec() ? SD_Thread : SD_Static;\n  }\n\n  /// Compute the language linkage.\n  LanguageLinkage getLanguageLinkage() const;\n\n  /// Determines whether this variable is a variable with external, C linkage.\n  bool isExternC() const;\n\n  /// Determines whether this variable's context is, or is nested within,\n  /// a C++ extern \"C\" linkage spec.\n  bool isInExternCContext() const;\n\n  /// Determines whether this variable's context is, or is nested within,\n  /// a C++ extern \"C++\" linkage spec.\n  bool isInExternCXXContext() const;\n\n  /// Returns true for local variable declarations other than parameters.\n  /// Note that this includes static variables inside of functions. It also\n  /// includes variables inside blocks.\n  ///\n  ///   void foo() { int x; static int y; extern int z; }\n  bool isLocalVarDecl() const {\n    if (getKind() != Decl::Var && getKind() != Decl::Decomposition)\n      return false;\n    if (const DeclContext *DC = getLexicalDeclContext())\n      return DC->getRedeclContext()->isFunctionOrMethod();\n    return false;\n  }\n\n  /// Similar to isLocalVarDecl but also includes parameters.\n  bool isLocalVarDeclOrParm() const {\n    return isLocalVarDecl() || getKind() == Decl::ParmVar;\n  }\n\n  /// Similar to isLocalVarDecl, but excludes variables declared in blocks.\n  bool isFunctionOrMethodVarDecl() const {\n    if (getKind() != Decl::Var && getKind() != Decl::Decomposition)\n      return false;\n    const DeclContext *DC = getLexicalDeclContext()->getRedeclContext();\n    return DC->isFunctionOrMethod() && DC->getDeclKind() != Decl::Block;\n  }\n\n  /// Determines whether this is a static data member.\n  ///\n  /// This will only be true in C++, and applies to, e.g., the\n  /// variable 'x' in:\n  /// \\code\n  /// struct S {\n  ///   static int x;\n  /// };\n  /// \\endcode\n  bool isStaticDataMember() const {\n    // If it wasn't static, it would be a FieldDecl.\n    return getKind() != Decl::ParmVar && getDeclContext()->isRecord();\n  }\n\n  VarDecl *getCanonicalDecl() override;\n  const VarDecl *getCanonicalDecl() const {\n    return const_cast<VarDecl*>(this)->getCanonicalDecl();\n  }\n\n  enum DefinitionKind {\n    /// This declaration is only a declaration.\n    DeclarationOnly,\n\n    /// This declaration is a tentative definition.\n    TentativeDefinition,\n\n    /// This declaration is definitely a definition.\n    Definition\n  };\n\n  /// Check whether this declaration is a definition. If this could be\n  /// a tentative definition (in C), don't check whether there's an overriding\n  /// definition.\n  DefinitionKind isThisDeclarationADefinition(ASTContext &) const;\n  DefinitionKind isThisDeclarationADefinition() const {\n    return isThisDeclarationADefinition(getASTContext());\n  }\n\n  /// Check whether this variable is defined in this translation unit.\n  DefinitionKind hasDefinition(ASTContext &) const;\n  DefinitionKind hasDefinition() const {\n    return hasDefinition(getASTContext());\n  }\n\n  /// Get the tentative definition that acts as the real definition in a TU.\n  /// Returns null if there is a proper definition available.\n  VarDecl *getActingDefinition();\n  const VarDecl *getActingDefinition() const {\n    return const_cast<VarDecl*>(this)->getActingDefinition();\n  }\n\n  /// Get the real (not just tentative) definition for this declaration.\n  VarDecl *getDefinition(ASTContext &);\n  const VarDecl *getDefinition(ASTContext &C) const {\n    return const_cast<VarDecl*>(this)->getDefinition(C);\n  }\n  VarDecl *getDefinition() {\n    return getDefinition(getASTContext());\n  }\n  const VarDecl *getDefinition() const {\n    return const_cast<VarDecl*>(this)->getDefinition();\n  }\n\n  /// Determine whether this is or was instantiated from an out-of-line\n  /// definition of a static data member.\n  bool isOutOfLine() const override;\n\n  /// Returns true for file scoped variable declaration.\n  bool isFileVarDecl() const {\n    Kind K = getKind();\n    if (K == ParmVar || K == ImplicitParam)\n      return false;\n\n    if (getLexicalDeclContext()->getRedeclContext()->isFileContext())\n      return true;\n\n    if (isStaticDataMember())\n      return true;\n\n    return false;\n  }\n\n  /// Get the initializer for this variable, no matter which\n  /// declaration it is attached to.\n  const Expr *getAnyInitializer() const {\n    const VarDecl *D;\n    return getAnyInitializer(D);\n  }\n\n  /// Get the initializer for this variable, no matter which\n  /// declaration it is attached to. Also get that declaration.\n  const Expr *getAnyInitializer(const VarDecl *&D) const;\n\n  bool hasInit() const;\n  const Expr *getInit() const {\n    return const_cast<VarDecl *>(this)->getInit();\n  }\n  Expr *getInit();\n\n  /// Retrieve the address of the initializer expression.\n  Stmt **getInitAddress();\n\n  void setInit(Expr *I);\n\n  /// Get the initializing declaration of this variable, if any. This is\n  /// usually the definition, except that for a static data member it can be\n  /// the in-class declaration.\n  VarDecl *getInitializingDeclaration();\n  const VarDecl *getInitializingDeclaration() const {\n    return const_cast<VarDecl *>(this)->getInitializingDeclaration();\n  }\n\n  /// Determine whether this variable's value might be usable in a\n  /// constant expression, according to the relevant language standard.\n  /// This only checks properties of the declaration, and does not check\n  /// whether the initializer is in fact a constant expression.\n  ///\n  /// This corresponds to C++20 [expr.const]p3's notion of a\n  /// \"potentially-constant\" variable.\n  bool mightBeUsableInConstantExpressions(const ASTContext &C) const;\n\n  /// Determine whether this variable's value can be used in a\n  /// constant expression, according to the relevant language standard,\n  /// including checking whether it was initialized by a constant expression.\n  bool isUsableInConstantExpressions(const ASTContext &C) const;\n\n  EvaluatedStmt *ensureEvaluatedStmt() const;\n  EvaluatedStmt *getEvaluatedStmt() const;\n\n  /// Attempt to evaluate the value of the initializer attached to this\n  /// declaration, and produce notes explaining why it cannot be evaluated.\n  /// Returns a pointer to the value if evaluation succeeded, 0 otherwise.\n  APValue *evaluateValue() const;\n\nprivate:\n  APValue *evaluateValueImpl(SmallVectorImpl<PartialDiagnosticAt> &Notes,\n                             bool IsConstantInitialization) const;\n\npublic:\n  /// Return the already-evaluated value of this variable's\n  /// initializer, or NULL if the value is not yet known. Returns pointer\n  /// to untyped APValue if the value could not be evaluated.\n  APValue *getEvaluatedValue() const;\n\n  /// Evaluate the destruction of this variable to determine if it constitutes\n  /// constant destruction.\n  ///\n  /// \\pre hasConstantInitialization()\n  /// \\return \\c true if this variable has constant destruction, \\c false if\n  ///         not.\n  bool evaluateDestruction(SmallVectorImpl<PartialDiagnosticAt> &Notes) const;\n\n  /// Determine whether this variable has constant initialization.\n  ///\n  /// This is only set in two cases: when the language semantics require\n  /// constant initialization (globals in C and some globals in C++), and when\n  /// the variable is usable in constant expressions (constexpr, const int, and\n  /// reference variables in C++).\n  bool hasConstantInitialization() const;\n\n  /// Determine whether the initializer of this variable is an integer constant\n  /// expression. For use in C++98, where this affects whether the variable is\n  /// usable in constant expressions.\n  bool hasICEInitializer(const ASTContext &Context) const;\n\n  /// Evaluate the initializer of this variable to determine whether it's a\n  /// constant initializer. Should only be called once, after completing the\n  /// definition of the variable.\n  bool checkForConstantInitialization(\n      SmallVectorImpl<PartialDiagnosticAt> &Notes) const;\n\n  void setInitStyle(InitializationStyle Style) {\n    VarDeclBits.InitStyle = Style;\n  }\n\n  /// The style of initialization for this declaration.\n  ///\n  /// C-style initialization is \"int x = 1;\". Call-style initialization is\n  /// a C++98 direct-initializer, e.g. \"int x(1);\". The Init expression will be\n  /// the expression inside the parens or a \"ClassType(a,b,c)\" class constructor\n  /// expression for class types. List-style initialization is C++11 syntax,\n  /// e.g. \"int x{1};\". Clients can distinguish between different forms of\n  /// initialization by checking this value. In particular, \"int x = {1};\" is\n  /// C-style, \"int x({1})\" is call-style, and \"int x{1};\" is list-style; the\n  /// Init expression in all three cases is an InitListExpr.\n  InitializationStyle getInitStyle() const {\n    return static_cast<InitializationStyle>(VarDeclBits.InitStyle);\n  }\n\n  /// Whether the initializer is a direct-initializer (list or call).\n  bool isDirectInit() const {\n    return getInitStyle() != CInit;\n  }\n\n  /// If this definition should pretend to be a declaration.\n  bool isThisDeclarationADemotedDefinition() const {\n    return isa<ParmVarDecl>(this) ? false :\n      NonParmVarDeclBits.IsThisDeclarationADemotedDefinition;\n  }\n\n  /// This is a definition which should be demoted to a declaration.\n  ///\n  /// In some cases (mostly module merging) we can end up with two visible\n  /// definitions one of which needs to be demoted to a declaration to keep\n  /// the AST invariants.\n  void demoteThisDefinitionToDeclaration() {\n    assert(isThisDeclarationADefinition() && \"Not a definition!\");\n    assert(!isa<ParmVarDecl>(this) && \"Cannot demote ParmVarDecls!\");\n    NonParmVarDeclBits.IsThisDeclarationADemotedDefinition = 1;\n  }\n\n  /// Determine whether this variable is the exception variable in a\n  /// C++ catch statememt or an Objective-C \\@catch statement.\n  bool isExceptionVariable() const {\n    return isa<ParmVarDecl>(this) ? false : NonParmVarDeclBits.ExceptionVar;\n  }\n  void setExceptionVariable(bool EV) {\n    assert(!isa<ParmVarDecl>(this));\n    NonParmVarDeclBits.ExceptionVar = EV;\n  }\n\n  /// Determine whether this local variable can be used with the named\n  /// return value optimization (NRVO).\n  ///\n  /// The named return value optimization (NRVO) works by marking certain\n  /// non-volatile local variables of class type as NRVO objects. These\n  /// locals can be allocated within the return slot of their containing\n  /// function, in which case there is no need to copy the object to the\n  /// return slot when returning from the function. Within the function body,\n  /// each return that returns the NRVO object will have this variable as its\n  /// NRVO candidate.\n  bool isNRVOVariable() const {\n    return isa<ParmVarDecl>(this) ? false : NonParmVarDeclBits.NRVOVariable;\n  }\n  void setNRVOVariable(bool NRVO) {\n    assert(!isa<ParmVarDecl>(this));\n    NonParmVarDeclBits.NRVOVariable = NRVO;\n  }\n\n  /// Determine whether this variable is the for-range-declaration in\n  /// a C++0x for-range statement.\n  bool isCXXForRangeDecl() const {\n    return isa<ParmVarDecl>(this) ? false : NonParmVarDeclBits.CXXForRangeDecl;\n  }\n  void setCXXForRangeDecl(bool FRD) {\n    assert(!isa<ParmVarDecl>(this));\n    NonParmVarDeclBits.CXXForRangeDecl = FRD;\n  }\n\n  /// Determine whether this variable is a for-loop declaration for a\n  /// for-in statement in Objective-C.\n  bool isObjCForDecl() const {\n    return NonParmVarDeclBits.ObjCForDecl;\n  }\n\n  void setObjCForDecl(bool FRD) {\n    NonParmVarDeclBits.ObjCForDecl = FRD;\n  }\n\n  /// Determine whether this variable is an ARC pseudo-__strong variable. A\n  /// pseudo-__strong variable has a __strong-qualified type but does not\n  /// actually retain the object written into it. Generally such variables are\n  /// also 'const' for safety. There are 3 cases where this will be set, 1) if\n  /// the variable is annotated with the objc_externally_retained attribute, 2)\n  /// if its 'self' in a non-init method, or 3) if its the variable in an for-in\n  /// loop.\n  bool isARCPseudoStrong() const { return VarDeclBits.ARCPseudoStrong; }\n  void setARCPseudoStrong(bool PS) { VarDeclBits.ARCPseudoStrong = PS; }\n\n  /// Whether this variable is (C++1z) inline.\n  bool isInline() const {\n    return isa<ParmVarDecl>(this) ? false : NonParmVarDeclBits.IsInline;\n  }\n  bool isInlineSpecified() const {\n    return isa<ParmVarDecl>(this) ? false\n                                  : NonParmVarDeclBits.IsInlineSpecified;\n  }\n  void setInlineSpecified() {\n    assert(!isa<ParmVarDecl>(this));\n    NonParmVarDeclBits.IsInline = true;\n    NonParmVarDeclBits.IsInlineSpecified = true;\n  }\n  void setImplicitlyInline() {\n    assert(!isa<ParmVarDecl>(this));\n    NonParmVarDeclBits.IsInline = true;\n  }\n\n  /// Whether this variable is (C++11) constexpr.\n  bool isConstexpr() const {\n    return isa<ParmVarDecl>(this) ? false : NonParmVarDeclBits.IsConstexpr;\n  }\n  void setConstexpr(bool IC) {\n    assert(!isa<ParmVarDecl>(this));\n    NonParmVarDeclBits.IsConstexpr = IC;\n  }\n\n  /// Whether this variable is the implicit variable for a lambda init-capture.\n  bool isInitCapture() const {\n    return isa<ParmVarDecl>(this) ? false : NonParmVarDeclBits.IsInitCapture;\n  }\n  void setInitCapture(bool IC) {\n    assert(!isa<ParmVarDecl>(this));\n    NonParmVarDeclBits.IsInitCapture = IC;\n  }\n\n  /// Determine whether this variable is actually a function parameter pack or\n  /// init-capture pack.\n  bool isParameterPack() const;\n\n  /// Whether this local extern variable declaration's previous declaration\n  /// was declared in the same block scope. Only correct in C++.\n  bool isPreviousDeclInSameBlockScope() const {\n    return isa<ParmVarDecl>(this)\n               ? false\n               : NonParmVarDeclBits.PreviousDeclInSameBlockScope;\n  }\n  void setPreviousDeclInSameBlockScope(bool Same) {\n    assert(!isa<ParmVarDecl>(this));\n    NonParmVarDeclBits.PreviousDeclInSameBlockScope = Same;\n  }\n\n  /// Indicates the capture is a __block variable that is captured by a block\n  /// that can potentially escape (a block for which BlockDecl::doesNotEscape\n  /// returns false).\n  bool isEscapingByref() const;\n\n  /// Indicates the capture is a __block variable that is never captured by an\n  /// escaping block.\n  bool isNonEscapingByref() const;\n\n  void setEscapingByref() {\n    NonParmVarDeclBits.EscapingByref = true;\n  }\n\n  /// Retrieve the variable declaration from which this variable could\n  /// be instantiated, if it is an instantiation (rather than a non-template).\n  VarDecl *getTemplateInstantiationPattern() const;\n\n  /// If this variable is an instantiated static data member of a\n  /// class template specialization, returns the templated static data member\n  /// from which it was instantiated.\n  VarDecl *getInstantiatedFromStaticDataMember() const;\n\n  /// If this variable is an instantiation of a variable template or a\n  /// static data member of a class template, determine what kind of\n  /// template specialization or instantiation this is.\n  TemplateSpecializationKind getTemplateSpecializationKind() const;\n\n  /// Get the template specialization kind of this variable for the purposes of\n  /// template instantiation. This differs from getTemplateSpecializationKind()\n  /// for an instantiation of a class-scope explicit specialization.\n  TemplateSpecializationKind\n  getTemplateSpecializationKindForInstantiation() const;\n\n  /// If this variable is an instantiation of a variable template or a\n  /// static data member of a class template, determine its point of\n  /// instantiation.\n  SourceLocation getPointOfInstantiation() const;\n\n  /// If this variable is an instantiation of a static data member of a\n  /// class template specialization, retrieves the member specialization\n  /// information.\n  MemberSpecializationInfo *getMemberSpecializationInfo() const;\n\n  /// For a static data member that was instantiated from a static\n  /// data member of a class template, set the template specialiation kind.\n  void setTemplateSpecializationKind(TemplateSpecializationKind TSK,\n                        SourceLocation PointOfInstantiation = SourceLocation());\n\n  /// Specify that this variable is an instantiation of the\n  /// static data member VD.\n  void setInstantiationOfStaticDataMember(VarDecl *VD,\n                                          TemplateSpecializationKind TSK);\n\n  /// Retrieves the variable template that is described by this\n  /// variable declaration.\n  ///\n  /// Every variable template is represented as a VarTemplateDecl and a\n  /// VarDecl. The former contains template properties (such as\n  /// the template parameter lists) while the latter contains the\n  /// actual description of the template's\n  /// contents. VarTemplateDecl::getTemplatedDecl() retrieves the\n  /// VarDecl that from a VarTemplateDecl, while\n  /// getDescribedVarTemplate() retrieves the VarTemplateDecl from\n  /// a VarDecl.\n  VarTemplateDecl *getDescribedVarTemplate() const;\n\n  void setDescribedVarTemplate(VarTemplateDecl *Template);\n\n  // Is this variable known to have a definition somewhere in the complete\n  // program? This may be true even if the declaration has internal linkage and\n  // has no definition within this source file.\n  bool isKnownToBeDefined() const;\n\n  /// Is destruction of this variable entirely suppressed? If so, the variable\n  /// need not have a usable destructor at all.\n  bool isNoDestroy(const ASTContext &) const;\n\n  /// Would the destruction of this variable have any effect, and if so, what\n  /// kind?\n  QualType::DestructionKind needsDestruction(const ASTContext &Ctx) const;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K >= firstVar && K <= lastVar; }\n};\n\nclass ImplicitParamDecl : public VarDecl {\n  void anchor() override;\n\npublic:\n  /// Defines the kind of the implicit parameter: is this an implicit parameter\n  /// with pointer to 'this', 'self', '_cmd', virtual table pointers, captured\n  /// context or something else.\n  enum ImplicitParamKind : unsigned {\n    /// Parameter for Objective-C 'self' argument\n    ObjCSelf,\n\n    /// Parameter for Objective-C '_cmd' argument\n    ObjCCmd,\n\n    /// Parameter for C++ 'this' argument\n    CXXThis,\n\n    /// Parameter for C++ virtual table pointers\n    CXXVTT,\n\n    /// Parameter for captured context\n    CapturedContext,\n\n    /// Other implicit parameter\n    Other,\n  };\n\n  /// Create implicit parameter.\n  static ImplicitParamDecl *Create(ASTContext &C, DeclContext *DC,\n                                   SourceLocation IdLoc, IdentifierInfo *Id,\n                                   QualType T, ImplicitParamKind ParamKind);\n  static ImplicitParamDecl *Create(ASTContext &C, QualType T,\n                                   ImplicitParamKind ParamKind);\n\n  static ImplicitParamDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  ImplicitParamDecl(ASTContext &C, DeclContext *DC, SourceLocation IdLoc,\n                    IdentifierInfo *Id, QualType Type,\n                    ImplicitParamKind ParamKind)\n      : VarDecl(ImplicitParam, C, DC, IdLoc, IdLoc, Id, Type,\n                /*TInfo=*/nullptr, SC_None) {\n    NonParmVarDeclBits.ImplicitParamKind = ParamKind;\n    setImplicit();\n  }\n\n  ImplicitParamDecl(ASTContext &C, QualType Type, ImplicitParamKind ParamKind)\n      : VarDecl(ImplicitParam, C, /*DC=*/nullptr, SourceLocation(),\n                SourceLocation(), /*Id=*/nullptr, Type,\n                /*TInfo=*/nullptr, SC_None) {\n    NonParmVarDeclBits.ImplicitParamKind = ParamKind;\n    setImplicit();\n  }\n\n  /// Returns the implicit parameter kind.\n  ImplicitParamKind getParameterKind() const {\n    return static_cast<ImplicitParamKind>(NonParmVarDeclBits.ImplicitParamKind);\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ImplicitParam; }\n};\n\n/// Represents a parameter to a function.\nclass ParmVarDecl : public VarDecl {\npublic:\n  enum { MaxFunctionScopeDepth = 255 };\n  enum { MaxFunctionScopeIndex = 255 };\n\nprotected:\n  ParmVarDecl(Kind DK, ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n              SourceLocation IdLoc, IdentifierInfo *Id, QualType T,\n              TypeSourceInfo *TInfo, StorageClass S, Expr *DefArg)\n      : VarDecl(DK, C, DC, StartLoc, IdLoc, Id, T, TInfo, S) {\n    assert(ParmVarDeclBits.HasInheritedDefaultArg == false);\n    assert(ParmVarDeclBits.DefaultArgKind == DAK_None);\n    assert(ParmVarDeclBits.IsKNRPromoted == false);\n    assert(ParmVarDeclBits.IsObjCMethodParam == false);\n    setDefaultArg(DefArg);\n  }\n\npublic:\n  static ParmVarDecl *Create(ASTContext &C, DeclContext *DC,\n                             SourceLocation StartLoc,\n                             SourceLocation IdLoc, IdentifierInfo *Id,\n                             QualType T, TypeSourceInfo *TInfo,\n                             StorageClass S, Expr *DefArg);\n\n  static ParmVarDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  void setObjCMethodScopeInfo(unsigned parameterIndex) {\n    ParmVarDeclBits.IsObjCMethodParam = true;\n    setParameterIndex(parameterIndex);\n  }\n\n  void setScopeInfo(unsigned scopeDepth, unsigned parameterIndex) {\n    assert(!ParmVarDeclBits.IsObjCMethodParam);\n\n    ParmVarDeclBits.ScopeDepthOrObjCQuals = scopeDepth;\n    assert(ParmVarDeclBits.ScopeDepthOrObjCQuals == scopeDepth\n           && \"truncation!\");\n\n    setParameterIndex(parameterIndex);\n  }\n\n  bool isObjCMethodParameter() const {\n    return ParmVarDeclBits.IsObjCMethodParam;\n  }\n\n  /// Determines whether this parameter is destroyed in the callee function.\n  bool isDestroyedInCallee() const;\n\n  unsigned getFunctionScopeDepth() const {\n    if (ParmVarDeclBits.IsObjCMethodParam) return 0;\n    return ParmVarDeclBits.ScopeDepthOrObjCQuals;\n  }\n\n  static constexpr unsigned getMaxFunctionScopeDepth() {\n    return (1u << NumScopeDepthOrObjCQualsBits) - 1;\n  }\n\n  /// Returns the index of this parameter in its prototype or method scope.\n  unsigned getFunctionScopeIndex() const {\n    return getParameterIndex();\n  }\n\n  ObjCDeclQualifier getObjCDeclQualifier() const {\n    if (!ParmVarDeclBits.IsObjCMethodParam) return OBJC_TQ_None;\n    return ObjCDeclQualifier(ParmVarDeclBits.ScopeDepthOrObjCQuals);\n  }\n  void setObjCDeclQualifier(ObjCDeclQualifier QTVal) {\n    assert(ParmVarDeclBits.IsObjCMethodParam);\n    ParmVarDeclBits.ScopeDepthOrObjCQuals = QTVal;\n  }\n\n  /// True if the value passed to this parameter must undergo\n  /// K&R-style default argument promotion:\n  ///\n  /// C99 6.5.2.2.\n  ///   If the expression that denotes the called function has a type\n  ///   that does not include a prototype, the integer promotions are\n  ///   performed on each argument, and arguments that have type float\n  ///   are promoted to double.\n  bool isKNRPromoted() const {\n    return ParmVarDeclBits.IsKNRPromoted;\n  }\n  void setKNRPromoted(bool promoted) {\n    ParmVarDeclBits.IsKNRPromoted = promoted;\n  }\n\n  Expr *getDefaultArg();\n  const Expr *getDefaultArg() const {\n    return const_cast<ParmVarDecl *>(this)->getDefaultArg();\n  }\n\n  void setDefaultArg(Expr *defarg);\n\n  /// Retrieve the source range that covers the entire default\n  /// argument.\n  SourceRange getDefaultArgRange() const;\n  void setUninstantiatedDefaultArg(Expr *arg);\n  Expr *getUninstantiatedDefaultArg();\n  const Expr *getUninstantiatedDefaultArg() const {\n    return const_cast<ParmVarDecl *>(this)->getUninstantiatedDefaultArg();\n  }\n\n  /// Determines whether this parameter has a default argument,\n  /// either parsed or not.\n  bool hasDefaultArg() const;\n\n  /// Determines whether this parameter has a default argument that has not\n  /// yet been parsed. This will occur during the processing of a C++ class\n  /// whose member functions have default arguments, e.g.,\n  /// @code\n  ///   class X {\n  ///   public:\n  ///     void f(int x = 17); // x has an unparsed default argument now\n  ///   }; // x has a regular default argument now\n  /// @endcode\n  bool hasUnparsedDefaultArg() const {\n    return ParmVarDeclBits.DefaultArgKind == DAK_Unparsed;\n  }\n\n  bool hasUninstantiatedDefaultArg() const {\n    return ParmVarDeclBits.DefaultArgKind == DAK_Uninstantiated;\n  }\n\n  /// Specify that this parameter has an unparsed default argument.\n  /// The argument will be replaced with a real default argument via\n  /// setDefaultArg when the class definition enclosing the function\n  /// declaration that owns this default argument is completed.\n  void setUnparsedDefaultArg() {\n    ParmVarDeclBits.DefaultArgKind = DAK_Unparsed;\n  }\n\n  bool hasInheritedDefaultArg() const {\n    return ParmVarDeclBits.HasInheritedDefaultArg;\n  }\n\n  void setHasInheritedDefaultArg(bool I = true) {\n    ParmVarDeclBits.HasInheritedDefaultArg = I;\n  }\n\n  QualType getOriginalType() const;\n\n  /// Sets the function declaration that owns this\n  /// ParmVarDecl. Since ParmVarDecls are often created before the\n  /// FunctionDecls that own them, this routine is required to update\n  /// the DeclContext appropriately.\n  void setOwningFunction(DeclContext *FD) { setDeclContext(FD); }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ParmVar; }\n\nprivate:\n  enum { ParameterIndexSentinel = (1 << NumParameterIndexBits) - 1 };\n\n  void setParameterIndex(unsigned parameterIndex) {\n    if (parameterIndex >= ParameterIndexSentinel) {\n      setParameterIndexLarge(parameterIndex);\n      return;\n    }\n\n    ParmVarDeclBits.ParameterIndex = parameterIndex;\n    assert(ParmVarDeclBits.ParameterIndex == parameterIndex && \"truncation!\");\n  }\n  unsigned getParameterIndex() const {\n    unsigned d = ParmVarDeclBits.ParameterIndex;\n    return d == ParameterIndexSentinel ? getParameterIndexLarge() : d;\n  }\n\n  void setParameterIndexLarge(unsigned parameterIndex);\n  unsigned getParameterIndexLarge() const;\n};\n\nenum class MultiVersionKind {\n  None,\n  Target,\n  CPUSpecific,\n  CPUDispatch\n};\n\n/// Represents a function declaration or definition.\n///\n/// Since a given function can be declared several times in a program,\n/// there may be several FunctionDecls that correspond to that\n/// function. Only one of those FunctionDecls will be found when\n/// traversing the list of declarations in the context of the\n/// FunctionDecl (e.g., the translation unit); this FunctionDecl\n/// contains all of the information known about the function. Other,\n/// previous declarations of the function are available via the\n/// getPreviousDecl() chain.\nclass FunctionDecl : public DeclaratorDecl,\n                     public DeclContext,\n                     public Redeclarable<FunctionDecl> {\n  // This class stores some data in DeclContext::FunctionDeclBits\n  // to save some space. Use the provided accessors to access it.\npublic:\n  /// The kind of templated function a FunctionDecl can be.\n  enum TemplatedKind {\n    // Not templated.\n    TK_NonTemplate,\n    // The pattern in a function template declaration.\n    TK_FunctionTemplate,\n    // A non-template function that is an instantiation or explicit\n    // specialization of a member of a templated class.\n    TK_MemberSpecialization,\n    // An instantiation or explicit specialization of a function template.\n    // Note: this might have been instantiated from a templated class if it\n    // is a class-scope explicit specialization.\n    TK_FunctionTemplateSpecialization,\n    // A function template specialization that hasn't yet been resolved to a\n    // particular specialized function template.\n    TK_DependentFunctionTemplateSpecialization\n  };\n\n  /// Stashed information about a defaulted function definition whose body has\n  /// not yet been lazily generated.\n  class DefaultedFunctionInfo final\n      : llvm::TrailingObjects<DefaultedFunctionInfo, DeclAccessPair> {\n    friend TrailingObjects;\n    unsigned NumLookups;\n\n  public:\n    static DefaultedFunctionInfo *Create(ASTContext &Context,\n                                         ArrayRef<DeclAccessPair> Lookups);\n    /// Get the unqualified lookup results that should be used in this\n    /// defaulted function definition.\n    ArrayRef<DeclAccessPair> getUnqualifiedLookups() const {\n      return {getTrailingObjects<DeclAccessPair>(), NumLookups};\n    }\n  };\n\nprivate:\n  /// A new[]'d array of pointers to VarDecls for the formal\n  /// parameters of this function.  This is null if a prototype or if there are\n  /// no formals.\n  ParmVarDecl **ParamInfo = nullptr;\n\n  /// The active member of this union is determined by\n  /// FunctionDeclBits.HasDefaultedFunctionInfo.\n  union {\n    /// The body of the function.\n    LazyDeclStmtPtr Body;\n    /// Information about a future defaulted function definition.\n    DefaultedFunctionInfo *DefaultedInfo;\n  };\n\n  unsigned ODRHash;\n\n  /// End part of this FunctionDecl's source range.\n  ///\n  /// We could compute the full range in getSourceRange(). However, when we're\n  /// dealing with a function definition deserialized from a PCH/AST file,\n  /// we can only compute the full range once the function body has been\n  /// de-serialized, so it's far better to have the (sometimes-redundant)\n  /// EndRangeLoc.\n  SourceLocation EndRangeLoc;\n\n  /// The template or declaration that this declaration\n  /// describes or was instantiated from, respectively.\n  ///\n  /// For non-templates, this value will be NULL. For function\n  /// declarations that describe a function template, this will be a\n  /// pointer to a FunctionTemplateDecl. For member functions\n  /// of class template specializations, this will be a MemberSpecializationInfo\n  /// pointer containing information about the specialization.\n  /// For function template specializations, this will be a\n  /// FunctionTemplateSpecializationInfo, which contains information about\n  /// the template being specialized and the template arguments involved in\n  /// that specialization.\n  llvm::PointerUnion<FunctionTemplateDecl *,\n                     MemberSpecializationInfo *,\n                     FunctionTemplateSpecializationInfo *,\n                     DependentFunctionTemplateSpecializationInfo *>\n    TemplateOrSpecialization;\n\n  /// Provides source/type location info for the declaration name embedded in\n  /// the DeclaratorDecl base class.\n  DeclarationNameLoc DNLoc;\n\n  /// Specify that this function declaration is actually a function\n  /// template specialization.\n  ///\n  /// \\param C the ASTContext.\n  ///\n  /// \\param Template the function template that this function template\n  /// specialization specializes.\n  ///\n  /// \\param TemplateArgs the template arguments that produced this\n  /// function template specialization from the template.\n  ///\n  /// \\param InsertPos If non-NULL, the position in the function template\n  /// specialization set where the function template specialization data will\n  /// be inserted.\n  ///\n  /// \\param TSK the kind of template specialization this is.\n  ///\n  /// \\param TemplateArgsAsWritten location info of template arguments.\n  ///\n  /// \\param PointOfInstantiation point at which the function template\n  /// specialization was first instantiated.\n  void setFunctionTemplateSpecialization(ASTContext &C,\n                                         FunctionTemplateDecl *Template,\n                                       const TemplateArgumentList *TemplateArgs,\n                                         void *InsertPos,\n                                         TemplateSpecializationKind TSK,\n                          const TemplateArgumentListInfo *TemplateArgsAsWritten,\n                                         SourceLocation PointOfInstantiation);\n\n  /// Specify that this record is an instantiation of the\n  /// member function FD.\n  void setInstantiationOfMemberFunction(ASTContext &C, FunctionDecl *FD,\n                                        TemplateSpecializationKind TSK);\n\n  void setParams(ASTContext &C, ArrayRef<ParmVarDecl *> NewParamInfo);\n\n  // This is unfortunately needed because ASTDeclWriter::VisitFunctionDecl\n  // need to access this bit but we want to avoid making ASTDeclWriter\n  // a friend of FunctionDeclBitfields just for this.\n  bool isDeletedBit() const { return FunctionDeclBits.IsDeleted; }\n\n  /// Whether an ODRHash has been stored.\n  bool hasODRHash() const { return FunctionDeclBits.HasODRHash; }\n\n  /// State that an ODRHash has been stored.\n  void setHasODRHash(bool B = true) { FunctionDeclBits.HasODRHash = B; }\n\nprotected:\n  FunctionDecl(Kind DK, ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n               const DeclarationNameInfo &NameInfo, QualType T,\n               TypeSourceInfo *TInfo, StorageClass S, bool isInlineSpecified,\n               ConstexprSpecKind ConstexprKind,\n               Expr *TrailingRequiresClause = nullptr);\n\n  using redeclarable_base = Redeclarable<FunctionDecl>;\n\n  FunctionDecl *getNextRedeclarationImpl() override {\n    return getNextRedeclaration();\n  }\n\n  FunctionDecl *getPreviousDeclImpl() override {\n    return getPreviousDecl();\n  }\n\n  FunctionDecl *getMostRecentDeclImpl() override {\n    return getMostRecentDecl();\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  static FunctionDecl *\n  Create(ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n         SourceLocation NLoc, DeclarationName N, QualType T,\n         TypeSourceInfo *TInfo, StorageClass SC, bool isInlineSpecified = false,\n         bool hasWrittenPrototype = true,\n         ConstexprSpecKind ConstexprKind = ConstexprSpecKind::Unspecified,\n         Expr *TrailingRequiresClause = nullptr) {\n    DeclarationNameInfo NameInfo(N, NLoc);\n    return FunctionDecl::Create(C, DC, StartLoc, NameInfo, T, TInfo, SC,\n                                isInlineSpecified, hasWrittenPrototype,\n                                ConstexprKind, TrailingRequiresClause);\n  }\n\n  static FunctionDecl *Create(ASTContext &C, DeclContext *DC,\n                              SourceLocation StartLoc,\n                              const DeclarationNameInfo &NameInfo, QualType T,\n                              TypeSourceInfo *TInfo, StorageClass SC,\n                              bool isInlineSpecified, bool hasWrittenPrototype,\n                              ConstexprSpecKind ConstexprKind,\n                              Expr *TrailingRequiresClause);\n\n  static FunctionDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  DeclarationNameInfo getNameInfo() const {\n    return DeclarationNameInfo(getDeclName(), getLocation(), DNLoc);\n  }\n\n  void getNameForDiagnostic(raw_ostream &OS, const PrintingPolicy &Policy,\n                            bool Qualified) const override;\n\n  void setRangeEnd(SourceLocation E) { EndRangeLoc = E; }\n\n  /// Returns the location of the ellipsis of a variadic function.\n  SourceLocation getEllipsisLoc() const {\n    const auto *FPT = getType()->getAs<FunctionProtoType>();\n    if (FPT && FPT->isVariadic())\n      return FPT->getEllipsisLoc();\n    return SourceLocation();\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  // Function definitions.\n  //\n  // A function declaration may be:\n  // - a non defining declaration,\n  // - a definition. A function may be defined because:\n  //   - it has a body, or will have it in the case of late parsing.\n  //   - it has an uninstantiated body. The body does not exist because the\n  //     function is not used yet, but the declaration is considered a\n  //     definition and does not allow other definition of this function.\n  //   - it does not have a user specified body, but it does not allow\n  //     redefinition, because it is deleted/defaulted or is defined through\n  //     some other mechanism (alias, ifunc).\n\n  /// Returns true if the function has a body.\n  ///\n  /// The function body might be in any of the (re-)declarations of this\n  /// function. The variant that accepts a FunctionDecl pointer will set that\n  /// function declaration to the actual declaration containing the body (if\n  /// there is one).\n  bool hasBody(const FunctionDecl *&Definition) const;\n\n  bool hasBody() const override {\n    const FunctionDecl* Definition;\n    return hasBody(Definition);\n  }\n\n  /// Returns whether the function has a trivial body that does not require any\n  /// specific codegen.\n  bool hasTrivialBody() const;\n\n  /// Returns true if the function has a definition that does not need to be\n  /// instantiated.\n  ///\n  /// The variant that accepts a FunctionDecl pointer will set that function\n  /// declaration to the declaration that is a definition (if there is one).\n  ///\n  /// \\param CheckForPendingFriendDefinition If \\c true, also check for friend\n  ///        declarations that were instantiataed from function definitions.\n  ///        Such a declaration behaves as if it is a definition for the\n  ///        purpose of redefinition checking, but isn't actually a \"real\"\n  ///        definition until its body is instantiated.\n  bool isDefined(const FunctionDecl *&Definition,\n                 bool CheckForPendingFriendDefinition = false) const;\n\n  bool isDefined() const {\n    const FunctionDecl* Definition;\n    return isDefined(Definition);\n  }\n\n  /// Get the definition for this declaration.\n  FunctionDecl *getDefinition() {\n    const FunctionDecl *Definition;\n    if (isDefined(Definition))\n      return const_cast<FunctionDecl *>(Definition);\n    return nullptr;\n  }\n  const FunctionDecl *getDefinition() const {\n    return const_cast<FunctionDecl *>(this)->getDefinition();\n  }\n\n  /// Retrieve the body (definition) of the function. The function body might be\n  /// in any of the (re-)declarations of this function. The variant that accepts\n  /// a FunctionDecl pointer will set that function declaration to the actual\n  /// declaration containing the body (if there is one).\n  /// NOTE: For checking if there is a body, use hasBody() instead, to avoid\n  /// unnecessary AST de-serialization of the body.\n  Stmt *getBody(const FunctionDecl *&Definition) const;\n\n  Stmt *getBody() const override {\n    const FunctionDecl* Definition;\n    return getBody(Definition);\n  }\n\n  /// Returns whether this specific declaration of the function is also a\n  /// definition that does not contain uninstantiated body.\n  ///\n  /// This does not determine whether the function has been defined (e.g., in a\n  /// previous definition); for that information, use isDefined.\n  ///\n  /// Note: the function declaration does not become a definition until the\n  /// parser reaches the definition, if called before, this function will return\n  /// `false`.\n  bool isThisDeclarationADefinition() const {\n    return isDeletedAsWritten() || isDefaulted() ||\n           doesThisDeclarationHaveABody() || hasSkippedBody() ||\n           willHaveBody() || hasDefiningAttr();\n  }\n\n  /// Determine whether this specific declaration of the function is a friend\n  /// declaration that was instantiated from a function definition. Such\n  /// declarations behave like definitions in some contexts.\n  bool isThisDeclarationInstantiatedFromAFriendDefinition() const;\n\n  /// Returns whether this specific declaration of the function has a body.\n  bool doesThisDeclarationHaveABody() const {\n    return (!FunctionDeclBits.HasDefaultedFunctionInfo && Body) ||\n           isLateTemplateParsed();\n  }\n\n  void setBody(Stmt *B);\n  void setLazyBody(uint64_t Offset) {\n    FunctionDeclBits.HasDefaultedFunctionInfo = false;\n    Body = LazyDeclStmtPtr(Offset);\n  }\n\n  void setDefaultedFunctionInfo(DefaultedFunctionInfo *Info);\n  DefaultedFunctionInfo *getDefaultedFunctionInfo() const;\n\n  /// Whether this function is variadic.\n  bool isVariadic() const;\n\n  /// Whether this function is marked as virtual explicitly.\n  bool isVirtualAsWritten() const {\n    return FunctionDeclBits.IsVirtualAsWritten;\n  }\n\n  /// State that this function is marked as virtual explicitly.\n  void setVirtualAsWritten(bool V) { FunctionDeclBits.IsVirtualAsWritten = V; }\n\n  /// Whether this virtual function is pure, i.e. makes the containing class\n  /// abstract.\n  bool isPure() const { return FunctionDeclBits.IsPure; }\n  void setPure(bool P = true);\n\n  /// Whether this templated function will be late parsed.\n  bool isLateTemplateParsed() const {\n    return FunctionDeclBits.IsLateTemplateParsed;\n  }\n\n  /// State that this templated function will be late parsed.\n  void setLateTemplateParsed(bool ILT = true) {\n    FunctionDeclBits.IsLateTemplateParsed = ILT;\n  }\n\n  /// Whether this function is \"trivial\" in some specialized C++ senses.\n  /// Can only be true for default constructors, copy constructors,\n  /// copy assignment operators, and destructors.  Not meaningful until\n  /// the class has been fully built by Sema.\n  bool isTrivial() const { return FunctionDeclBits.IsTrivial; }\n  void setTrivial(bool IT) { FunctionDeclBits.IsTrivial = IT; }\n\n  bool isTrivialForCall() const { return FunctionDeclBits.IsTrivialForCall; }\n  void setTrivialForCall(bool IT) { FunctionDeclBits.IsTrivialForCall = IT; }\n\n  /// Whether this function is defaulted. Valid for e.g.\n  /// special member functions, defaulted comparisions (not methods!).\n  bool isDefaulted() const { return FunctionDeclBits.IsDefaulted; }\n  void setDefaulted(bool D = true) { FunctionDeclBits.IsDefaulted = D; }\n\n  /// Whether this function is explicitly defaulted.\n  bool isExplicitlyDefaulted() const {\n    return FunctionDeclBits.IsExplicitlyDefaulted;\n  }\n\n  /// State that this function is explicitly defaulted.\n  void setExplicitlyDefaulted(bool ED = true) {\n    FunctionDeclBits.IsExplicitlyDefaulted = ED;\n  }\n\n  /// True if this method is user-declared and was not\n  /// deleted or defaulted on its first declaration.\n  bool isUserProvided() const {\n    auto *DeclAsWritten = this;\n    if (FunctionDecl *Pattern = getTemplateInstantiationPattern())\n      DeclAsWritten = Pattern;\n    return !(DeclAsWritten->isDeleted() ||\n             DeclAsWritten->getCanonicalDecl()->isDefaulted());\n  }\n\n  /// Whether falling off this function implicitly returns null/zero.\n  /// If a more specific implicit return value is required, front-ends\n  /// should synthesize the appropriate return statements.\n  bool hasImplicitReturnZero() const {\n    return FunctionDeclBits.HasImplicitReturnZero;\n  }\n\n  /// State that falling off this function implicitly returns null/zero.\n  /// If a more specific implicit return value is required, front-ends\n  /// should synthesize the appropriate return statements.\n  void setHasImplicitReturnZero(bool IRZ) {\n    FunctionDeclBits.HasImplicitReturnZero = IRZ;\n  }\n\n  /// Whether this function has a prototype, either because one\n  /// was explicitly written or because it was \"inherited\" by merging\n  /// a declaration without a prototype with a declaration that has a\n  /// prototype.\n  bool hasPrototype() const {\n    return hasWrittenPrototype() || hasInheritedPrototype();\n  }\n\n  /// Whether this function has a written prototype.\n  bool hasWrittenPrototype() const {\n    return FunctionDeclBits.HasWrittenPrototype;\n  }\n\n  /// State that this function has a written prototype.\n  void setHasWrittenPrototype(bool P = true) {\n    FunctionDeclBits.HasWrittenPrototype = P;\n  }\n\n  /// Whether this function inherited its prototype from a\n  /// previous declaration.\n  bool hasInheritedPrototype() const {\n    return FunctionDeclBits.HasInheritedPrototype;\n  }\n\n  /// State that this function inherited its prototype from a\n  /// previous declaration.\n  void setHasInheritedPrototype(bool P = true) {\n    FunctionDeclBits.HasInheritedPrototype = P;\n  }\n\n  /// Whether this is a (C++11) constexpr function or constexpr constructor.\n  bool isConstexpr() const {\n    return getConstexprKind() != ConstexprSpecKind::Unspecified;\n  }\n  void setConstexprKind(ConstexprSpecKind CSK) {\n    FunctionDeclBits.ConstexprKind = static_cast<uint64_t>(CSK);\n  }\n  ConstexprSpecKind getConstexprKind() const {\n    return static_cast<ConstexprSpecKind>(FunctionDeclBits.ConstexprKind);\n  }\n  bool isConstexprSpecified() const {\n    return getConstexprKind() == ConstexprSpecKind::Constexpr;\n  }\n  bool isConsteval() const {\n    return getConstexprKind() == ConstexprSpecKind::Consteval;\n  }\n\n  /// Whether the instantiation of this function is pending.\n  /// This bit is set when the decision to instantiate this function is made\n  /// and unset if and when the function body is created. That leaves out\n  /// cases where instantiation did not happen because the template definition\n  /// was not seen in this TU. This bit remains set in those cases, under the\n  /// assumption that the instantiation will happen in some other TU.\n  bool instantiationIsPending() const {\n    return FunctionDeclBits.InstantiationIsPending;\n  }\n\n  /// State that the instantiation of this function is pending.\n  /// (see instantiationIsPending)\n  void setInstantiationIsPending(bool IC) {\n    FunctionDeclBits.InstantiationIsPending = IC;\n  }\n\n  /// Indicates the function uses __try.\n  bool usesSEHTry() const { return FunctionDeclBits.UsesSEHTry; }\n  void setUsesSEHTry(bool UST) { FunctionDeclBits.UsesSEHTry = UST; }\n\n  /// Whether this function has been deleted.\n  ///\n  /// A function that is \"deleted\" (via the C++0x \"= delete\" syntax)\n  /// acts like a normal function, except that it cannot actually be\n  /// called or have its address taken. Deleted functions are\n  /// typically used in C++ overload resolution to attract arguments\n  /// whose type or lvalue/rvalue-ness would permit the use of a\n  /// different overload that would behave incorrectly. For example,\n  /// one might use deleted functions to ban implicit conversion from\n  /// a floating-point number to an Integer type:\n  ///\n  /// @code\n  /// struct Integer {\n  ///   Integer(long); // construct from a long\n  ///   Integer(double) = delete; // no construction from float or double\n  ///   Integer(long double) = delete; // no construction from long double\n  /// };\n  /// @endcode\n  // If a function is deleted, its first declaration must be.\n  bool isDeleted() const {\n    return getCanonicalDecl()->FunctionDeclBits.IsDeleted;\n  }\n\n  bool isDeletedAsWritten() const {\n    return FunctionDeclBits.IsDeleted && !isDefaulted();\n  }\n\n  void setDeletedAsWritten(bool D = true) { FunctionDeclBits.IsDeleted = D; }\n\n  /// Determines whether this function is \"main\", which is the\n  /// entry point into an executable program.\n  bool isMain() const;\n\n  /// Determines whether this function is a MSVCRT user defined entry\n  /// point.\n  bool isMSVCRTEntryPoint() const;\n\n  /// Determines whether this operator new or delete is one\n  /// of the reserved global placement operators:\n  ///    void *operator new(size_t, void *);\n  ///    void *operator new[](size_t, void *);\n  ///    void operator delete(void *, void *);\n  ///    void operator delete[](void *, void *);\n  /// These functions have special behavior under [new.delete.placement]:\n  ///    These functions are reserved, a C++ program may not define\n  ///    functions that displace the versions in the Standard C++ library.\n  ///    The provisions of [basic.stc.dynamic] do not apply to these\n  ///    reserved placement forms of operator new and operator delete.\n  ///\n  /// This function must be an allocation or deallocation function.\n  bool isReservedGlobalPlacementOperator() const;\n\n  /// Determines whether this function is one of the replaceable\n  /// global allocation functions:\n  ///    void *operator new(size_t);\n  ///    void *operator new(size_t, const std::nothrow_t &) noexcept;\n  ///    void *operator new[](size_t);\n  ///    void *operator new[](size_t, const std::nothrow_t &) noexcept;\n  ///    void operator delete(void *) noexcept;\n  ///    void operator delete(void *, std::size_t) noexcept;      [C++1y]\n  ///    void operator delete(void *, const std::nothrow_t &) noexcept;\n  ///    void operator delete[](void *) noexcept;\n  ///    void operator delete[](void *, std::size_t) noexcept;    [C++1y]\n  ///    void operator delete[](void *, const std::nothrow_t &) noexcept;\n  /// These functions have special behavior under C++1y [expr.new]:\n  ///    An implementation is allowed to omit a call to a replaceable global\n  ///    allocation function. [...]\n  ///\n  /// If this function is an aligned allocation/deallocation function, return\n  /// the parameter number of the requested alignment through AlignmentParam.\n  ///\n  /// If this function is an allocation/deallocation function that takes\n  /// the `std::nothrow_t` tag, return true through IsNothrow,\n  bool isReplaceableGlobalAllocationFunction(\n      Optional<unsigned> *AlignmentParam = nullptr,\n      bool *IsNothrow = nullptr) const;\n\n  /// Determine if this function provides an inline implementation of a builtin.\n  bool isInlineBuiltinDeclaration() const;\n\n  /// Determine whether this is a destroying operator delete.\n  bool isDestroyingOperatorDelete() const;\n\n  /// Compute the language linkage.\n  LanguageLinkage getLanguageLinkage() const;\n\n  /// Determines whether this function is a function with\n  /// external, C linkage.\n  bool isExternC() const;\n\n  /// Determines whether this function's context is, or is nested within,\n  /// a C++ extern \"C\" linkage spec.\n  bool isInExternCContext() const;\n\n  /// Determines whether this function's context is, or is nested within,\n  /// a C++ extern \"C++\" linkage spec.\n  bool isInExternCXXContext() const;\n\n  /// Determines whether this is a global function.\n  bool isGlobal() const;\n\n  /// Determines whether this function is known to be 'noreturn', through\n  /// an attribute on its declaration or its type.\n  bool isNoReturn() const;\n\n  /// True if the function was a definition but its body was skipped.\n  bool hasSkippedBody() const { return FunctionDeclBits.HasSkippedBody; }\n  void setHasSkippedBody(bool Skipped = true) {\n    FunctionDeclBits.HasSkippedBody = Skipped;\n  }\n\n  /// True if this function will eventually have a body, once it's fully parsed.\n  bool willHaveBody() const { return FunctionDeclBits.WillHaveBody; }\n  void setWillHaveBody(bool V = true) { FunctionDeclBits.WillHaveBody = V; }\n\n  /// True if this function is considered a multiversioned function.\n  bool isMultiVersion() const {\n    return getCanonicalDecl()->FunctionDeclBits.IsMultiVersion;\n  }\n\n  /// Sets the multiversion state for this declaration and all of its\n  /// redeclarations.\n  void setIsMultiVersion(bool V = true) {\n    getCanonicalDecl()->FunctionDeclBits.IsMultiVersion = V;\n  }\n\n  /// Gets the kind of multiversioning attribute this declaration has. Note that\n  /// this can return a value even if the function is not multiversion, such as\n  /// the case of 'target'.\n  MultiVersionKind getMultiVersionKind() const;\n\n\n  /// True if this function is a multiversioned dispatch function as a part of\n  /// the cpu_specific/cpu_dispatch functionality.\n  bool isCPUDispatchMultiVersion() const;\n  /// True if this function is a multiversioned processor specific function as a\n  /// part of the cpu_specific/cpu_dispatch functionality.\n  bool isCPUSpecificMultiVersion() const;\n\n  /// True if this function is a multiversioned dispatch function as a part of\n  /// the target functionality.\n  bool isTargetMultiVersion() const;\n\n  /// \\brief Get the associated-constraints of this function declaration.\n  /// Currently, this will either be a vector of size 1 containing the\n  /// trailing-requires-clause or an empty vector.\n  ///\n  /// Use this instead of getTrailingRequiresClause for concepts APIs that\n  /// accept an ArrayRef of constraint expressions.\n  void getAssociatedConstraints(SmallVectorImpl<const Expr *> &AC) const {\n    if (auto *TRC = getTrailingRequiresClause())\n      AC.push_back(TRC);\n  }\n\n  void setPreviousDeclaration(FunctionDecl * PrevDecl);\n\n  FunctionDecl *getCanonicalDecl() override;\n  const FunctionDecl *getCanonicalDecl() const {\n    return const_cast<FunctionDecl*>(this)->getCanonicalDecl();\n  }\n\n  unsigned getBuiltinID(bool ConsiderWrapperFunctions = false) const;\n\n  // ArrayRef interface to parameters.\n  ArrayRef<ParmVarDecl *> parameters() const {\n    return {ParamInfo, getNumParams()};\n  }\n  MutableArrayRef<ParmVarDecl *> parameters() {\n    return {ParamInfo, getNumParams()};\n  }\n\n  // Iterator access to formal parameters.\n  using param_iterator = MutableArrayRef<ParmVarDecl *>::iterator;\n  using param_const_iterator = ArrayRef<ParmVarDecl *>::const_iterator;\n\n  bool param_empty() const { return parameters().empty(); }\n  param_iterator param_begin() { return parameters().begin(); }\n  param_iterator param_end() { return parameters().end(); }\n  param_const_iterator param_begin() const { return parameters().begin(); }\n  param_const_iterator param_end() const { return parameters().end(); }\n  size_t param_size() const { return parameters().size(); }\n\n  /// Return the number of parameters this function must have based on its\n  /// FunctionType.  This is the length of the ParamInfo array after it has been\n  /// created.\n  unsigned getNumParams() const;\n\n  const ParmVarDecl *getParamDecl(unsigned i) const {\n    assert(i < getNumParams() && \"Illegal param #\");\n    return ParamInfo[i];\n  }\n  ParmVarDecl *getParamDecl(unsigned i) {\n    assert(i < getNumParams() && \"Illegal param #\");\n    return ParamInfo[i];\n  }\n  void setParams(ArrayRef<ParmVarDecl *> NewParamInfo) {\n    setParams(getASTContext(), NewParamInfo);\n  }\n\n  /// Returns the minimum number of arguments needed to call this function. This\n  /// may be fewer than the number of function parameters, if some of the\n  /// parameters have default arguments (in C++).\n  unsigned getMinRequiredArguments() const;\n\n  /// Determine whether this function has a single parameter, or multiple\n  /// parameters where all but the first have default arguments.\n  ///\n  /// This notion is used in the definition of copy/move constructors and\n  /// initializer list constructors. Note that, unlike getMinRequiredArguments,\n  /// parameter packs are not treated specially here.\n  bool hasOneParamOrDefaultArgs() const;\n\n  /// Find the source location information for how the type of this function\n  /// was written. May be absent (for example if the function was declared via\n  /// a typedef) and may contain a different type from that of the function\n  /// (for example if the function type was adjusted by an attribute).\n  FunctionTypeLoc getFunctionTypeLoc() const;\n\n  QualType getReturnType() const {\n    return getType()->castAs<FunctionType>()->getReturnType();\n  }\n\n  /// Attempt to compute an informative source range covering the\n  /// function return type. This may omit qualifiers and other information with\n  /// limited representation in the AST.\n  SourceRange getReturnTypeSourceRange() const;\n\n  /// Attempt to compute an informative source range covering the\n  /// function parameters, including the ellipsis of a variadic function.\n  /// The source range excludes the parentheses, and is invalid if there are\n  /// no parameters and no ellipsis.\n  SourceRange getParametersSourceRange() const;\n\n  /// Get the declared return type, which may differ from the actual return\n  /// type if the return type is deduced.\n  QualType getDeclaredReturnType() const {\n    auto *TSI = getTypeSourceInfo();\n    QualType T = TSI ? TSI->getType() : getType();\n    return T->castAs<FunctionType>()->getReturnType();\n  }\n\n  /// Gets the ExceptionSpecificationType as declared.\n  ExceptionSpecificationType getExceptionSpecType() const {\n    auto *TSI = getTypeSourceInfo();\n    QualType T = TSI ? TSI->getType() : getType();\n    const auto *FPT = T->getAs<FunctionProtoType>();\n    return FPT ? FPT->getExceptionSpecType() : EST_None;\n  }\n\n  /// Attempt to compute an informative source range covering the\n  /// function exception specification, if any.\n  SourceRange getExceptionSpecSourceRange() const;\n\n  /// Determine the type of an expression that calls this function.\n  QualType getCallResultType() const {\n    return getType()->castAs<FunctionType>()->getCallResultType(\n        getASTContext());\n  }\n\n  /// Returns the storage class as written in the source. For the\n  /// computed linkage of symbol, see getLinkage.\n  StorageClass getStorageClass() const {\n    return static_cast<StorageClass>(FunctionDeclBits.SClass);\n  }\n\n  /// Sets the storage class as written in the source.\n  void setStorageClass(StorageClass SClass) {\n    FunctionDeclBits.SClass = SClass;\n  }\n\n  /// Determine whether the \"inline\" keyword was specified for this\n  /// function.\n  bool isInlineSpecified() const { return FunctionDeclBits.IsInlineSpecified; }\n\n  /// Set whether the \"inline\" keyword was specified for this function.\n  void setInlineSpecified(bool I) {\n    FunctionDeclBits.IsInlineSpecified = I;\n    FunctionDeclBits.IsInline = I;\n  }\n\n  /// Flag that this function is implicitly inline.\n  void setImplicitlyInline(bool I = true) { FunctionDeclBits.IsInline = I; }\n\n  /// Determine whether this function should be inlined, because it is\n  /// either marked \"inline\" or \"constexpr\" or is a member function of a class\n  /// that was defined in the class body.\n  bool isInlined() const { return FunctionDeclBits.IsInline; }\n\n  bool isInlineDefinitionExternallyVisible() const;\n\n  bool isMSExternInline() const;\n\n  bool doesDeclarationForceExternallyVisibleDefinition() const;\n\n  bool isStatic() const { return getStorageClass() == SC_Static; }\n\n  /// Whether this function declaration represents an C++ overloaded\n  /// operator, e.g., \"operator+\".\n  bool isOverloadedOperator() const {\n    return getOverloadedOperator() != OO_None;\n  }\n\n  OverloadedOperatorKind getOverloadedOperator() const;\n\n  const IdentifierInfo *getLiteralIdentifier() const;\n\n  /// If this function is an instantiation of a member function\n  /// of a class template specialization, retrieves the function from\n  /// which it was instantiated.\n  ///\n  /// This routine will return non-NULL for (non-templated) member\n  /// functions of class templates and for instantiations of function\n  /// templates. For example, given:\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   void f(T);\n  /// };\n  /// \\endcode\n  ///\n  /// The declaration for X<int>::f is a (non-templated) FunctionDecl\n  /// whose parent is the class template specialization X<int>. For\n  /// this declaration, getInstantiatedFromFunction() will return\n  /// the FunctionDecl X<T>::A. When a complete definition of\n  /// X<int>::A is required, it will be instantiated from the\n  /// declaration returned by getInstantiatedFromMemberFunction().\n  FunctionDecl *getInstantiatedFromMemberFunction() const;\n\n  /// What kind of templated function this is.\n  TemplatedKind getTemplatedKind() const;\n\n  /// If this function is an instantiation of a member function of a\n  /// class template specialization, retrieves the member specialization\n  /// information.\n  MemberSpecializationInfo *getMemberSpecializationInfo() const;\n\n  /// Specify that this record is an instantiation of the\n  /// member function FD.\n  void setInstantiationOfMemberFunction(FunctionDecl *FD,\n                                        TemplateSpecializationKind TSK) {\n    setInstantiationOfMemberFunction(getASTContext(), FD, TSK);\n  }\n\n  /// Retrieves the function template that is described by this\n  /// function declaration.\n  ///\n  /// Every function template is represented as a FunctionTemplateDecl\n  /// and a FunctionDecl (or something derived from FunctionDecl). The\n  /// former contains template properties (such as the template\n  /// parameter lists) while the latter contains the actual\n  /// description of the template's\n  /// contents. FunctionTemplateDecl::getTemplatedDecl() retrieves the\n  /// FunctionDecl that describes the function template,\n  /// getDescribedFunctionTemplate() retrieves the\n  /// FunctionTemplateDecl from a FunctionDecl.\n  FunctionTemplateDecl *getDescribedFunctionTemplate() const;\n\n  void setDescribedFunctionTemplate(FunctionTemplateDecl *Template);\n\n  /// Determine whether this function is a function template\n  /// specialization.\n  bool isFunctionTemplateSpecialization() const {\n    return getPrimaryTemplate() != nullptr;\n  }\n\n  /// If this function is actually a function template specialization,\n  /// retrieve information about this function template specialization.\n  /// Otherwise, returns NULL.\n  FunctionTemplateSpecializationInfo *getTemplateSpecializationInfo() const;\n\n  /// Determines whether this function is a function template\n  /// specialization or a member of a class template specialization that can\n  /// be implicitly instantiated.\n  bool isImplicitlyInstantiable() const;\n\n  /// Determines if the given function was instantiated from a\n  /// function template.\n  bool isTemplateInstantiation() const;\n\n  /// Retrieve the function declaration from which this function could\n  /// be instantiated, if it is an instantiation (rather than a non-template\n  /// or a specialization, for example).\n  ///\n  /// If \\p ForDefinition is \\c false, explicit specializations will be treated\n  /// as if they were implicit instantiations. This will then find the pattern\n  /// corresponding to non-definition portions of the declaration, such as\n  /// default arguments and the exception specification.\n  FunctionDecl *\n  getTemplateInstantiationPattern(bool ForDefinition = true) const;\n\n  /// Retrieve the primary template that this function template\n  /// specialization either specializes or was instantiated from.\n  ///\n  /// If this function declaration is not a function template specialization,\n  /// returns NULL.\n  FunctionTemplateDecl *getPrimaryTemplate() const;\n\n  /// Retrieve the template arguments used to produce this function\n  /// template specialization from the primary template.\n  ///\n  /// If this function declaration is not a function template specialization,\n  /// returns NULL.\n  const TemplateArgumentList *getTemplateSpecializationArgs() const;\n\n  /// Retrieve the template argument list as written in the sources,\n  /// if any.\n  ///\n  /// If this function declaration is not a function template specialization\n  /// or if it had no explicit template argument list, returns NULL.\n  /// Note that it an explicit template argument list may be written empty,\n  /// e.g., template<> void foo<>(char* s);\n  const ASTTemplateArgumentListInfo*\n  getTemplateSpecializationArgsAsWritten() const;\n\n  /// Specify that this function declaration is actually a function\n  /// template specialization.\n  ///\n  /// \\param Template the function template that this function template\n  /// specialization specializes.\n  ///\n  /// \\param TemplateArgs the template arguments that produced this\n  /// function template specialization from the template.\n  ///\n  /// \\param InsertPos If non-NULL, the position in the function template\n  /// specialization set where the function template specialization data will\n  /// be inserted.\n  ///\n  /// \\param TSK the kind of template specialization this is.\n  ///\n  /// \\param TemplateArgsAsWritten location info of template arguments.\n  ///\n  /// \\param PointOfInstantiation point at which the function template\n  /// specialization was first instantiated.\n  void setFunctionTemplateSpecialization(FunctionTemplateDecl *Template,\n                const TemplateArgumentList *TemplateArgs,\n                void *InsertPos,\n                TemplateSpecializationKind TSK = TSK_ImplicitInstantiation,\n                const TemplateArgumentListInfo *TemplateArgsAsWritten = nullptr,\n                SourceLocation PointOfInstantiation = SourceLocation()) {\n    setFunctionTemplateSpecialization(getASTContext(), Template, TemplateArgs,\n                                      InsertPos, TSK, TemplateArgsAsWritten,\n                                      PointOfInstantiation);\n  }\n\n  /// Specifies that this function declaration is actually a\n  /// dependent function template specialization.\n  void setDependentTemplateSpecialization(ASTContext &Context,\n                             const UnresolvedSetImpl &Templates,\n                      const TemplateArgumentListInfo &TemplateArgs);\n\n  DependentFunctionTemplateSpecializationInfo *\n  getDependentSpecializationInfo() const;\n\n  /// Determine what kind of template instantiation this function\n  /// represents.\n  TemplateSpecializationKind getTemplateSpecializationKind() const;\n\n  /// Determine the kind of template specialization this function represents\n  /// for the purpose of template instantiation.\n  TemplateSpecializationKind\n  getTemplateSpecializationKindForInstantiation() const;\n\n  /// Determine what kind of template instantiation this function\n  /// represents.\n  void setTemplateSpecializationKind(TemplateSpecializationKind TSK,\n                        SourceLocation PointOfInstantiation = SourceLocation());\n\n  /// Retrieve the (first) point of instantiation of a function template\n  /// specialization or a member of a class template specialization.\n  ///\n  /// \\returns the first point of instantiation, if this function was\n  /// instantiated from a template; otherwise, returns an invalid source\n  /// location.\n  SourceLocation getPointOfInstantiation() const;\n\n  /// Determine whether this is or was instantiated from an out-of-line\n  /// definition of a member function.\n  bool isOutOfLine() const override;\n\n  /// Identify a memory copying or setting function.\n  /// If the given function is a memory copy or setting function, returns\n  /// the corresponding Builtin ID. If the function is not a memory function,\n  /// returns 0.\n  unsigned getMemoryFunctionKind() const;\n\n  /// Returns ODRHash of the function.  This value is calculated and\n  /// stored on first call, then the stored value returned on the other calls.\n  unsigned getODRHash();\n\n  /// Returns cached ODRHash of the function.  This must have been previously\n  /// computed and stored.\n  unsigned getODRHash() const;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K >= firstFunction && K <= lastFunction;\n  }\n  static DeclContext *castToDeclContext(const FunctionDecl *D) {\n    return static_cast<DeclContext *>(const_cast<FunctionDecl*>(D));\n  }\n  static FunctionDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<FunctionDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Represents a member of a struct/union/class.\nclass FieldDecl : public DeclaratorDecl, public Mergeable<FieldDecl> {\n  unsigned BitField : 1;\n  unsigned Mutable : 1;\n  mutable unsigned CachedFieldIndex : 30;\n\n  /// The kinds of value we can store in InitializerOrBitWidth.\n  ///\n  /// Note that this is compatible with InClassInitStyle except for\n  /// ISK_CapturedVLAType.\n  enum InitStorageKind {\n    /// If the pointer is null, there's nothing special.  Otherwise,\n    /// this is a bitfield and the pointer is the Expr* storing the\n    /// bit-width.\n    ISK_NoInit = (unsigned) ICIS_NoInit,\n\n    /// The pointer is an (optional due to delayed parsing) Expr*\n    /// holding the copy-initializer.\n    ISK_InClassCopyInit = (unsigned) ICIS_CopyInit,\n\n    /// The pointer is an (optional due to delayed parsing) Expr*\n    /// holding the list-initializer.\n    ISK_InClassListInit = (unsigned) ICIS_ListInit,\n\n    /// The pointer is a VariableArrayType* that's been captured;\n    /// the enclosing context is a lambda or captured statement.\n    ISK_CapturedVLAType,\n  };\n\n  /// If this is a bitfield with a default member initializer, this\n  /// structure is used to represent the two expressions.\n  struct InitAndBitWidth {\n    Expr *Init;\n    Expr *BitWidth;\n  };\n\n  /// Storage for either the bit-width, the in-class initializer, or\n  /// both (via InitAndBitWidth), or the captured variable length array bound.\n  ///\n  /// If the storage kind is ISK_InClassCopyInit or\n  /// ISK_InClassListInit, but the initializer is null, then this\n  /// field has an in-class initializer that has not yet been parsed\n  /// and attached.\n  // FIXME: Tail-allocate this to reduce the size of FieldDecl in the\n  // overwhelmingly common case that we have none of these things.\n  llvm::PointerIntPair<void *, 2, InitStorageKind> InitStorage;\n\nprotected:\n  FieldDecl(Kind DK, DeclContext *DC, SourceLocation StartLoc,\n            SourceLocation IdLoc, IdentifierInfo *Id,\n            QualType T, TypeSourceInfo *TInfo, Expr *BW, bool Mutable,\n            InClassInitStyle InitStyle)\n    : DeclaratorDecl(DK, DC, IdLoc, Id, T, TInfo, StartLoc),\n      BitField(false), Mutable(Mutable), CachedFieldIndex(0),\n      InitStorage(nullptr, (InitStorageKind) InitStyle) {\n    if (BW)\n      setBitWidth(BW);\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static FieldDecl *Create(const ASTContext &C, DeclContext *DC,\n                           SourceLocation StartLoc, SourceLocation IdLoc,\n                           IdentifierInfo *Id, QualType T,\n                           TypeSourceInfo *TInfo, Expr *BW, bool Mutable,\n                           InClassInitStyle InitStyle);\n\n  static FieldDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// Returns the index of this field within its record,\n  /// as appropriate for passing to ASTRecordLayout::getFieldOffset.\n  unsigned getFieldIndex() const;\n\n  /// Determines whether this field is mutable (C++ only).\n  bool isMutable() const { return Mutable; }\n\n  /// Determines whether this field is a bitfield.\n  bool isBitField() const { return BitField; }\n\n  /// Determines whether this is an unnamed bitfield.\n  bool isUnnamedBitfield() const { return isBitField() && !getDeclName(); }\n\n  /// Determines whether this field is a\n  /// representative for an anonymous struct or union. Such fields are\n  /// unnamed and are implicitly generated by the implementation to\n  /// store the data for the anonymous union or struct.\n  bool isAnonymousStructOrUnion() const;\n\n  Expr *getBitWidth() const {\n    if (!BitField)\n      return nullptr;\n    void *Ptr = InitStorage.getPointer();\n    if (getInClassInitStyle())\n      return static_cast<InitAndBitWidth*>(Ptr)->BitWidth;\n    return static_cast<Expr*>(Ptr);\n  }\n\n  unsigned getBitWidthValue(const ASTContext &Ctx) const;\n\n  /// Set the bit-field width for this member.\n  // Note: used by some clients (i.e., do not remove it).\n  void setBitWidth(Expr *Width) {\n    assert(!hasCapturedVLAType() && !BitField &&\n           \"bit width or captured type already set\");\n    assert(Width && \"no bit width specified\");\n    InitStorage.setPointer(\n        InitStorage.getInt()\n            ? new (getASTContext())\n                  InitAndBitWidth{getInClassInitializer(), Width}\n            : static_cast<void*>(Width));\n    BitField = true;\n  }\n\n  /// Remove the bit-field width from this member.\n  // Note: used by some clients (i.e., do not remove it).\n  void removeBitWidth() {\n    assert(isBitField() && \"no bitfield width to remove\");\n    InitStorage.setPointer(getInClassInitializer());\n    BitField = false;\n  }\n\n  /// Is this a zero-length bit-field? Such bit-fields aren't really bit-fields\n  /// at all and instead act as a separator between contiguous runs of other\n  /// bit-fields.\n  bool isZeroLengthBitField(const ASTContext &Ctx) const;\n\n  /// Determine if this field is a subobject of zero size, that is, either a\n  /// zero-length bit-field or a field of empty class type with the\n  /// [[no_unique_address]] attribute.\n  bool isZeroSize(const ASTContext &Ctx) const;\n\n  /// Get the kind of (C++11) default member initializer that this field has.\n  InClassInitStyle getInClassInitStyle() const {\n    InitStorageKind storageKind = InitStorage.getInt();\n    return (storageKind == ISK_CapturedVLAType\n              ? ICIS_NoInit : (InClassInitStyle) storageKind);\n  }\n\n  /// Determine whether this member has a C++11 default member initializer.\n  bool hasInClassInitializer() const {\n    return getInClassInitStyle() != ICIS_NoInit;\n  }\n\n  /// Get the C++11 default member initializer for this member, or null if one\n  /// has not been set. If a valid declaration has a default member initializer,\n  /// but this returns null, then we have not parsed and attached it yet.\n  Expr *getInClassInitializer() const {\n    if (!hasInClassInitializer())\n      return nullptr;\n    void *Ptr = InitStorage.getPointer();\n    if (BitField)\n      return static_cast<InitAndBitWidth*>(Ptr)->Init;\n    return static_cast<Expr*>(Ptr);\n  }\n\n  /// Set the C++11 in-class initializer for this member.\n  void setInClassInitializer(Expr *Init) {\n    assert(hasInClassInitializer() && !getInClassInitializer());\n    if (BitField)\n      static_cast<InitAndBitWidth*>(InitStorage.getPointer())->Init = Init;\n    else\n      InitStorage.setPointer(Init);\n  }\n\n  /// Remove the C++11 in-class initializer from this member.\n  void removeInClassInitializer() {\n    assert(hasInClassInitializer() && \"no initializer to remove\");\n    InitStorage.setPointerAndInt(getBitWidth(), ISK_NoInit);\n  }\n\n  /// Determine whether this member captures the variable length array\n  /// type.\n  bool hasCapturedVLAType() const {\n    return InitStorage.getInt() == ISK_CapturedVLAType;\n  }\n\n  /// Get the captured variable length array type.\n  const VariableArrayType *getCapturedVLAType() const {\n    return hasCapturedVLAType() ? static_cast<const VariableArrayType *>(\n                                      InitStorage.getPointer())\n                                : nullptr;\n  }\n\n  /// Set the captured variable length array type for this field.\n  void setCapturedVLAType(const VariableArrayType *VLAType);\n\n  /// Returns the parent of this field declaration, which\n  /// is the struct in which this field is defined.\n  ///\n  /// Returns null if this is not a normal class/struct field declaration, e.g.\n  /// ObjCAtDefsFieldDecl, ObjCIvarDecl.\n  const RecordDecl *getParent() const {\n    return dyn_cast<RecordDecl>(getDeclContext());\n  }\n\n  RecordDecl *getParent() {\n    return dyn_cast<RecordDecl>(getDeclContext());\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  /// Retrieves the canonical declaration of this field.\n  FieldDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const FieldDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K >= firstField && K <= lastField; }\n};\n\n/// An instance of this object exists for each enum constant\n/// that is defined.  For example, in \"enum X {a,b}\", each of a/b are\n/// EnumConstantDecl's, X is an instance of EnumDecl, and the type of a/b is a\n/// TagType for the X EnumDecl.\nclass EnumConstantDecl : public ValueDecl, public Mergeable<EnumConstantDecl> {\n  Stmt *Init; // an integer constant expression\n  llvm::APSInt Val; // The value.\n\nprotected:\n  EnumConstantDecl(DeclContext *DC, SourceLocation L,\n                   IdentifierInfo *Id, QualType T, Expr *E,\n                   const llvm::APSInt &V)\n    : ValueDecl(EnumConstant, DC, L, Id, T), Init((Stmt*)E), Val(V) {}\n\npublic:\n  friend class StmtIteratorBase;\n\n  static EnumConstantDecl *Create(ASTContext &C, EnumDecl *DC,\n                                  SourceLocation L, IdentifierInfo *Id,\n                                  QualType T, Expr *E,\n                                  const llvm::APSInt &V);\n  static EnumConstantDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  const Expr *getInitExpr() const { return (const Expr*) Init; }\n  Expr *getInitExpr() { return (Expr*) Init; }\n  const llvm::APSInt &getInitVal() const { return Val; }\n\n  void setInitExpr(Expr *E) { Init = (Stmt*) E; }\n  void setInitVal(const llvm::APSInt &V) { Val = V; }\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  /// Retrieves the canonical declaration of this enumerator.\n  EnumConstantDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const EnumConstantDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == EnumConstant; }\n};\n\n/// Represents a field injected from an anonymous union/struct into the parent\n/// scope. These are always implicit.\nclass IndirectFieldDecl : public ValueDecl,\n                          public Mergeable<IndirectFieldDecl> {\n  NamedDecl **Chaining;\n  unsigned ChainingSize;\n\n  IndirectFieldDecl(ASTContext &C, DeclContext *DC, SourceLocation L,\n                    DeclarationName N, QualType T,\n                    MutableArrayRef<NamedDecl *> CH);\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n\n  static IndirectFieldDecl *Create(ASTContext &C, DeclContext *DC,\n                                   SourceLocation L, IdentifierInfo *Id,\n                                   QualType T, llvm::MutableArrayRef<NamedDecl *> CH);\n\n  static IndirectFieldDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  using chain_iterator = ArrayRef<NamedDecl *>::const_iterator;\n\n  ArrayRef<NamedDecl *> chain() const {\n    return llvm::makeArrayRef(Chaining, ChainingSize);\n  }\n  chain_iterator chain_begin() const { return chain().begin(); }\n  chain_iterator chain_end() const { return chain().end(); }\n\n  unsigned getChainingSize() const { return ChainingSize; }\n\n  FieldDecl *getAnonField() const {\n    assert(chain().size() >= 2);\n    return cast<FieldDecl>(chain().back());\n  }\n\n  VarDecl *getVarDecl() const {\n    assert(chain().size() >= 2);\n    return dyn_cast<VarDecl>(chain().front());\n  }\n\n  IndirectFieldDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const IndirectFieldDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == IndirectField; }\n};\n\n/// Represents a declaration of a type.\nclass TypeDecl : public NamedDecl {\n  friend class ASTContext;\n\n  /// This indicates the Type object that represents\n  /// this TypeDecl.  It is a cache maintained by\n  /// ASTContext::getTypedefType, ASTContext::getTagDeclType, and\n  /// ASTContext::getTemplateTypeParmType, and TemplateTypeParmDecl.\n  mutable const Type *TypeForDecl = nullptr;\n\n  /// The start of the source range for this declaration.\n  SourceLocation LocStart;\n\n  void anchor() override;\n\nprotected:\n  TypeDecl(Kind DK, DeclContext *DC, SourceLocation L, IdentifierInfo *Id,\n           SourceLocation StartL = SourceLocation())\n    : NamedDecl(DK, DC, L, Id), LocStart(StartL) {}\n\npublic:\n  // Low-level accessor. If you just want the type defined by this node,\n  // check out ASTContext::getTypeDeclType or one of\n  // ASTContext::getTypedefType, ASTContext::getRecordType, etc. if you\n  // already know the specific kind of node this is.\n  const Type *getTypeForDecl() const { return TypeForDecl; }\n  void setTypeForDecl(const Type *TD) { TypeForDecl = TD; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return LocStart; }\n  void setLocStart(SourceLocation L) { LocStart = L; }\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    if (LocStart.isValid())\n      return SourceRange(LocStart, getLocation());\n    else\n      return SourceRange(getLocation());\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K >= firstType && K <= lastType; }\n};\n\n/// Base class for declarations which introduce a typedef-name.\nclass TypedefNameDecl : public TypeDecl, public Redeclarable<TypedefNameDecl> {\n  struct alignas(8) ModedTInfo {\n    TypeSourceInfo *first;\n    QualType second;\n  };\n\n  /// If int part is 0, we have not computed IsTransparentTag.\n  /// Otherwise, IsTransparentTag is (getInt() >> 1).\n  mutable llvm::PointerIntPair<\n      llvm::PointerUnion<TypeSourceInfo *, ModedTInfo *>, 2>\n      MaybeModedTInfo;\n\n  void anchor() override;\n\nprotected:\n  TypedefNameDecl(Kind DK, ASTContext &C, DeclContext *DC,\n                  SourceLocation StartLoc, SourceLocation IdLoc,\n                  IdentifierInfo *Id, TypeSourceInfo *TInfo)\n      : TypeDecl(DK, DC, IdLoc, Id, StartLoc), redeclarable_base(C),\n        MaybeModedTInfo(TInfo, 0) {}\n\n  using redeclarable_base = Redeclarable<TypedefNameDecl>;\n\n  TypedefNameDecl *getNextRedeclarationImpl() override {\n    return getNextRedeclaration();\n  }\n\n  TypedefNameDecl *getPreviousDeclImpl() override {\n    return getPreviousDecl();\n  }\n\n  TypedefNameDecl *getMostRecentDeclImpl() override {\n    return getMostRecentDecl();\n  }\n\npublic:\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  bool isModed() const {\n    return MaybeModedTInfo.getPointer().is<ModedTInfo *>();\n  }\n\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return isModed() ? MaybeModedTInfo.getPointer().get<ModedTInfo *>()->first\n                     : MaybeModedTInfo.getPointer().get<TypeSourceInfo *>();\n  }\n\n  QualType getUnderlyingType() const {\n    return isModed() ? MaybeModedTInfo.getPointer().get<ModedTInfo *>()->second\n                     : MaybeModedTInfo.getPointer()\n                           .get<TypeSourceInfo *>()\n                           ->getType();\n  }\n\n  void setTypeSourceInfo(TypeSourceInfo *newType) {\n    MaybeModedTInfo.setPointer(newType);\n  }\n\n  void setModedTypeSourceInfo(TypeSourceInfo *unmodedTSI, QualType modedTy) {\n    MaybeModedTInfo.setPointer(new (getASTContext(), 8)\n                                   ModedTInfo({unmodedTSI, modedTy}));\n  }\n\n  /// Retrieves the canonical declaration of this typedef-name.\n  TypedefNameDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const TypedefNameDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  /// Retrieves the tag declaration for which this is the typedef name for\n  /// linkage purposes, if any.\n  ///\n  /// \\param AnyRedecl Look for the tag declaration in any redeclaration of\n  /// this typedef declaration.\n  TagDecl *getAnonDeclWithTypedefName(bool AnyRedecl = false) const;\n\n  /// Determines if this typedef shares a name and spelling location with its\n  /// underlying tag type, as is the case with the NS_ENUM macro.\n  bool isTransparentTag() const {\n    if (MaybeModedTInfo.getInt())\n      return MaybeModedTInfo.getInt() & 0x2;\n    return isTransparentTagSlow();\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K >= firstTypedefName && K <= lastTypedefName;\n  }\n\nprivate:\n  bool isTransparentTagSlow() const;\n};\n\n/// Represents the declaration of a typedef-name via the 'typedef'\n/// type specifier.\nclass TypedefDecl : public TypedefNameDecl {\n  TypedefDecl(ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n              SourceLocation IdLoc, IdentifierInfo *Id, TypeSourceInfo *TInfo)\n      : TypedefNameDecl(Typedef, C, DC, StartLoc, IdLoc, Id, TInfo) {}\n\npublic:\n  static TypedefDecl *Create(ASTContext &C, DeclContext *DC,\n                             SourceLocation StartLoc, SourceLocation IdLoc,\n                             IdentifierInfo *Id, TypeSourceInfo *TInfo);\n  static TypedefDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Typedef; }\n};\n\n/// Represents the declaration of a typedef-name via a C++11\n/// alias-declaration.\nclass TypeAliasDecl : public TypedefNameDecl {\n  /// The template for which this is the pattern, if any.\n  TypeAliasTemplateDecl *Template;\n\n  TypeAliasDecl(ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n                SourceLocation IdLoc, IdentifierInfo *Id, TypeSourceInfo *TInfo)\n      : TypedefNameDecl(TypeAlias, C, DC, StartLoc, IdLoc, Id, TInfo),\n        Template(nullptr) {}\n\npublic:\n  static TypeAliasDecl *Create(ASTContext &C, DeclContext *DC,\n                               SourceLocation StartLoc, SourceLocation IdLoc,\n                               IdentifierInfo *Id, TypeSourceInfo *TInfo);\n  static TypeAliasDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  TypeAliasTemplateDecl *getDescribedAliasTemplate() const { return Template; }\n  void setDescribedAliasTemplate(TypeAliasTemplateDecl *TAT) { Template = TAT; }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == TypeAlias; }\n};\n\n/// Represents the declaration of a struct/union/class/enum.\nclass TagDecl : public TypeDecl,\n                public DeclContext,\n                public Redeclarable<TagDecl> {\n  // This class stores some data in DeclContext::TagDeclBits\n  // to save some space. Use the provided accessors to access it.\npublic:\n  // This is really ugly.\n  using TagKind = TagTypeKind;\n\nprivate:\n  SourceRange BraceRange;\n\n  // A struct representing syntactic qualifier info,\n  // to be used for the (uncommon) case of out-of-line declarations.\n  using ExtInfo = QualifierInfo;\n\n  /// If the (out-of-line) tag declaration name\n  /// is qualified, it points to the qualifier info (nns and range);\n  /// otherwise, if the tag declaration is anonymous and it is part of\n  /// a typedef or alias, it points to the TypedefNameDecl (used for mangling);\n  /// otherwise, if the tag declaration is anonymous and it is used as a\n  /// declaration specifier for variables, it points to the first VarDecl (used\n  /// for mangling);\n  /// otherwise, it is a null (TypedefNameDecl) pointer.\n  llvm::PointerUnion<TypedefNameDecl *, ExtInfo *> TypedefNameDeclOrQualifier;\n\n  bool hasExtInfo() const { return TypedefNameDeclOrQualifier.is<ExtInfo *>(); }\n  ExtInfo *getExtInfo() { return TypedefNameDeclOrQualifier.get<ExtInfo *>(); }\n  const ExtInfo *getExtInfo() const {\n    return TypedefNameDeclOrQualifier.get<ExtInfo *>();\n  }\n\nprotected:\n  TagDecl(Kind DK, TagKind TK, const ASTContext &C, DeclContext *DC,\n          SourceLocation L, IdentifierInfo *Id, TagDecl *PrevDecl,\n          SourceLocation StartL);\n\n  using redeclarable_base = Redeclarable<TagDecl>;\n\n  TagDecl *getNextRedeclarationImpl() override {\n    return getNextRedeclaration();\n  }\n\n  TagDecl *getPreviousDeclImpl() override {\n    return getPreviousDecl();\n  }\n\n  TagDecl *getMostRecentDeclImpl() override {\n    return getMostRecentDecl();\n  }\n\n  /// Completes the definition of this tag declaration.\n  ///\n  /// This is a helper function for derived classes.\n  void completeDefinition();\n\n  /// True if this decl is currently being defined.\n  void setBeingDefined(bool V = true) { TagDeclBits.IsBeingDefined = V; }\n\n  /// Indicates whether it is possible for declarations of this kind\n  /// to have an out-of-date definition.\n  ///\n  /// This option is only enabled when modules are enabled.\n  void setMayHaveOutOfDateDef(bool V = true) {\n    TagDeclBits.MayHaveOutOfDateDef = V;\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  SourceRange getBraceRange() const { return BraceRange; }\n  void setBraceRange(SourceRange R) { BraceRange = R; }\n\n  /// Return SourceLocation representing start of source\n  /// range ignoring outer template declarations.\n  SourceLocation getInnerLocStart() const { return getBeginLoc(); }\n\n  /// Return SourceLocation representing start of source\n  /// range taking into account any outer template declarations.\n  SourceLocation getOuterLocStart() const;\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  TagDecl *getCanonicalDecl() override;\n  const TagDecl *getCanonicalDecl() const {\n    return const_cast<TagDecl*>(this)->getCanonicalDecl();\n  }\n\n  /// Return true if this declaration is a completion definition of the type.\n  /// Provided for consistency.\n  bool isThisDeclarationADefinition() const {\n    return isCompleteDefinition();\n  }\n\n  /// Return true if this decl has its body fully specified.\n  bool isCompleteDefinition() const { return TagDeclBits.IsCompleteDefinition; }\n\n  /// True if this decl has its body fully specified.\n  void setCompleteDefinition(bool V = true) {\n    TagDeclBits.IsCompleteDefinition = V;\n  }\n\n  /// Return true if this complete decl is\n  /// required to be complete for some existing use.\n  bool isCompleteDefinitionRequired() const {\n    return TagDeclBits.IsCompleteDefinitionRequired;\n  }\n\n  /// True if this complete decl is\n  /// required to be complete for some existing use.\n  void setCompleteDefinitionRequired(bool V = true) {\n    TagDeclBits.IsCompleteDefinitionRequired = V;\n  }\n\n  /// Return true if this decl is currently being defined.\n  bool isBeingDefined() const { return TagDeclBits.IsBeingDefined; }\n\n  /// True if this tag declaration is \"embedded\" (i.e., defined or declared\n  /// for the very first time) in the syntax of a declarator.\n  bool isEmbeddedInDeclarator() const {\n    return TagDeclBits.IsEmbeddedInDeclarator;\n  }\n\n  /// True if this tag declaration is \"embedded\" (i.e., defined or declared\n  /// for the very first time) in the syntax of a declarator.\n  void setEmbeddedInDeclarator(bool isInDeclarator) {\n    TagDeclBits.IsEmbeddedInDeclarator = isInDeclarator;\n  }\n\n  /// True if this tag is free standing, e.g. \"struct foo;\".\n  bool isFreeStanding() const { return TagDeclBits.IsFreeStanding; }\n\n  /// True if this tag is free standing, e.g. \"struct foo;\".\n  void setFreeStanding(bool isFreeStanding = true) {\n    TagDeclBits.IsFreeStanding = isFreeStanding;\n  }\n\n  /// Indicates whether it is possible for declarations of this kind\n  /// to have an out-of-date definition.\n  ///\n  /// This option is only enabled when modules are enabled.\n  bool mayHaveOutOfDateDef() const { return TagDeclBits.MayHaveOutOfDateDef; }\n\n  /// Whether this declaration declares a type that is\n  /// dependent, i.e., a type that somehow depends on template\n  /// parameters.\n  bool isDependentType() const { return isDependentContext(); }\n\n  /// Starts the definition of this tag declaration.\n  ///\n  /// This method should be invoked at the beginning of the definition\n  /// of this tag declaration. It will set the tag type into a state\n  /// where it is in the process of being defined.\n  void startDefinition();\n\n  /// Returns the TagDecl that actually defines this\n  ///  struct/union/class/enum.  When determining whether or not a\n  ///  struct/union/class/enum has a definition, one should use this\n  ///  method as opposed to 'isDefinition'.  'isDefinition' indicates\n  ///  whether or not a specific TagDecl is defining declaration, not\n  ///  whether or not the struct/union/class/enum type is defined.\n  ///  This method returns NULL if there is no TagDecl that defines\n  ///  the struct/union/class/enum.\n  TagDecl *getDefinition() const;\n\n  StringRef getKindName() const {\n    return TypeWithKeyword::getTagTypeKindName(getTagKind());\n  }\n\n  TagKind getTagKind() const {\n    return static_cast<TagKind>(TagDeclBits.TagDeclKind);\n  }\n\n  void setTagKind(TagKind TK) { TagDeclBits.TagDeclKind = TK; }\n\n  bool isStruct() const { return getTagKind() == TTK_Struct; }\n  bool isInterface() const { return getTagKind() == TTK_Interface; }\n  bool isClass()  const { return getTagKind() == TTK_Class; }\n  bool isUnion()  const { return getTagKind() == TTK_Union; }\n  bool isEnum()   const { return getTagKind() == TTK_Enum; }\n\n  /// Is this tag type named, either directly or via being defined in\n  /// a typedef of this type?\n  ///\n  /// C++11 [basic.link]p8:\n  ///   A type is said to have linkage if and only if:\n  ///     - it is a class or enumeration type that is named (or has a\n  ///       name for linkage purposes) and the name has linkage; ...\n  /// C++11 [dcl.typedef]p9:\n  ///   If the typedef declaration defines an unnamed class (or enum),\n  ///   the first typedef-name declared by the declaration to be that\n  ///   class type (or enum type) is used to denote the class type (or\n  ///   enum type) for linkage purposes only.\n  ///\n  /// C does not have an analogous rule, but the same concept is\n  /// nonetheless useful in some places.\n  bool hasNameForLinkage() const {\n    return (getDeclName() || getTypedefNameForAnonDecl());\n  }\n\n  TypedefNameDecl *getTypedefNameForAnonDecl() const {\n    return hasExtInfo() ? nullptr\n                        : TypedefNameDeclOrQualifier.get<TypedefNameDecl *>();\n  }\n\n  void setTypedefNameForAnonDecl(TypedefNameDecl *TDD);\n\n  /// Retrieve the nested-name-specifier that qualifies the name of this\n  /// declaration, if it was present in the source.\n  NestedNameSpecifier *getQualifier() const {\n    return hasExtInfo() ? getExtInfo()->QualifierLoc.getNestedNameSpecifier()\n                        : nullptr;\n  }\n\n  /// Retrieve the nested-name-specifier (with source-location\n  /// information) that qualifies the name of this declaration, if it was\n  /// present in the source.\n  NestedNameSpecifierLoc getQualifierLoc() const {\n    return hasExtInfo() ? getExtInfo()->QualifierLoc\n                        : NestedNameSpecifierLoc();\n  }\n\n  void setQualifierInfo(NestedNameSpecifierLoc QualifierLoc);\n\n  unsigned getNumTemplateParameterLists() const {\n    return hasExtInfo() ? getExtInfo()->NumTemplParamLists : 0;\n  }\n\n  TemplateParameterList *getTemplateParameterList(unsigned i) const {\n    assert(i < getNumTemplateParameterLists());\n    return getExtInfo()->TemplParamLists[i];\n  }\n\n  void setTemplateParameterListsInfo(ASTContext &Context,\n                                     ArrayRef<TemplateParameterList *> TPLists);\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K >= firstTag && K <= lastTag; }\n\n  static DeclContext *castToDeclContext(const TagDecl *D) {\n    return static_cast<DeclContext *>(const_cast<TagDecl*>(D));\n  }\n\n  static TagDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<TagDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Represents an enum.  In C++11, enums can be forward-declared\n/// with a fixed underlying type, and in C we allow them to be forward-declared\n/// with no underlying type as an extension.\nclass EnumDecl : public TagDecl {\n  // This class stores some data in DeclContext::EnumDeclBits\n  // to save some space. Use the provided accessors to access it.\n\n  /// This represent the integer type that the enum corresponds\n  /// to for code generation purposes.  Note that the enumerator constants may\n  /// have a different type than this does.\n  ///\n  /// If the underlying integer type was explicitly stated in the source\n  /// code, this is a TypeSourceInfo* for that type. Otherwise this type\n  /// was automatically deduced somehow, and this is a Type*.\n  ///\n  /// Normally if IsFixed(), this would contain a TypeSourceInfo*, but in\n  /// some cases it won't.\n  ///\n  /// The underlying type of an enumeration never has any qualifiers, so\n  /// we can get away with just storing a raw Type*, and thus save an\n  /// extra pointer when TypeSourceInfo is needed.\n  llvm::PointerUnion<const Type *, TypeSourceInfo *> IntegerType;\n\n  /// The integer type that values of this type should\n  /// promote to.  In C, enumerators are generally of an integer type\n  /// directly, but gcc-style large enumerators (and all enumerators\n  /// in C++) are of the enum type instead.\n  QualType PromotionType;\n\n  /// If this enumeration is an instantiation of a member enumeration\n  /// of a class template specialization, this is the member specialization\n  /// information.\n  MemberSpecializationInfo *SpecializationInfo = nullptr;\n\n  /// Store the ODRHash after first calculation.\n  /// The corresponding flag HasODRHash is in EnumDeclBits\n  /// and can be accessed with the provided accessors.\n  unsigned ODRHash;\n\n  EnumDecl(ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n           SourceLocation IdLoc, IdentifierInfo *Id, EnumDecl *PrevDecl,\n           bool Scoped, bool ScopedUsingClassTag, bool Fixed);\n\n  void anchor() override;\n\n  void setInstantiationOfMemberEnum(ASTContext &C, EnumDecl *ED,\n                                    TemplateSpecializationKind TSK);\n\n  /// Sets the width in bits required to store all the\n  /// non-negative enumerators of this enum.\n  void setNumPositiveBits(unsigned Num) {\n    EnumDeclBits.NumPositiveBits = Num;\n    assert(EnumDeclBits.NumPositiveBits == Num && \"can't store this bitcount\");\n  }\n\n  /// Returns the width in bits required to store all the\n  /// negative enumerators of this enum. (see getNumNegativeBits)\n  void setNumNegativeBits(unsigned Num) { EnumDeclBits.NumNegativeBits = Num; }\n\npublic:\n  /// True if this tag declaration is a scoped enumeration. Only\n  /// possible in C++11 mode.\n  void setScoped(bool Scoped = true) { EnumDeclBits.IsScoped = Scoped; }\n\n  /// If this tag declaration is a scoped enum,\n  /// then this is true if the scoped enum was declared using the class\n  /// tag, false if it was declared with the struct tag. No meaning is\n  /// associated if this tag declaration is not a scoped enum.\n  void setScopedUsingClassTag(bool ScopedUCT = true) {\n    EnumDeclBits.IsScopedUsingClassTag = ScopedUCT;\n  }\n\n  /// True if this is an Objective-C, C++11, or\n  /// Microsoft-style enumeration with a fixed underlying type.\n  void setFixed(bool Fixed = true) { EnumDeclBits.IsFixed = Fixed; }\n\nprivate:\n  /// True if a valid hash is stored in ODRHash.\n  bool hasODRHash() const { return EnumDeclBits.HasODRHash; }\n  void setHasODRHash(bool Hash = true) { EnumDeclBits.HasODRHash = Hash; }\n\npublic:\n  friend class ASTDeclReader;\n\n  EnumDecl *getCanonicalDecl() override {\n    return cast<EnumDecl>(TagDecl::getCanonicalDecl());\n  }\n  const EnumDecl *getCanonicalDecl() const {\n    return const_cast<EnumDecl*>(this)->getCanonicalDecl();\n  }\n\n  EnumDecl *getPreviousDecl() {\n    return cast_or_null<EnumDecl>(\n            static_cast<TagDecl *>(this)->getPreviousDecl());\n  }\n  const EnumDecl *getPreviousDecl() const {\n    return const_cast<EnumDecl*>(this)->getPreviousDecl();\n  }\n\n  EnumDecl *getMostRecentDecl() {\n    return cast<EnumDecl>(static_cast<TagDecl *>(this)->getMostRecentDecl());\n  }\n  const EnumDecl *getMostRecentDecl() const {\n    return const_cast<EnumDecl*>(this)->getMostRecentDecl();\n  }\n\n  EnumDecl *getDefinition() const {\n    return cast_or_null<EnumDecl>(TagDecl::getDefinition());\n  }\n\n  static EnumDecl *Create(ASTContext &C, DeclContext *DC,\n                          SourceLocation StartLoc, SourceLocation IdLoc,\n                          IdentifierInfo *Id, EnumDecl *PrevDecl,\n                          bool IsScoped, bool IsScopedUsingClassTag,\n                          bool IsFixed);\n  static EnumDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// When created, the EnumDecl corresponds to a\n  /// forward-declared enum. This method is used to mark the\n  /// declaration as being defined; its enumerators have already been\n  /// added (via DeclContext::addDecl). NewType is the new underlying\n  /// type of the enumeration type.\n  void completeDefinition(QualType NewType,\n                          QualType PromotionType,\n                          unsigned NumPositiveBits,\n                          unsigned NumNegativeBits);\n\n  // Iterates through the enumerators of this enumeration.\n  using enumerator_iterator = specific_decl_iterator<EnumConstantDecl>;\n  using enumerator_range =\n      llvm::iterator_range<specific_decl_iterator<EnumConstantDecl>>;\n\n  enumerator_range enumerators() const {\n    return enumerator_range(enumerator_begin(), enumerator_end());\n  }\n\n  enumerator_iterator enumerator_begin() const {\n    const EnumDecl *E = getDefinition();\n    if (!E)\n      E = this;\n    return enumerator_iterator(E->decls_begin());\n  }\n\n  enumerator_iterator enumerator_end() const {\n    const EnumDecl *E = getDefinition();\n    if (!E)\n      E = this;\n    return enumerator_iterator(E->decls_end());\n  }\n\n  /// Return the integer type that enumerators should promote to.\n  QualType getPromotionType() const { return PromotionType; }\n\n  /// Set the promotion type.\n  void setPromotionType(QualType T) { PromotionType = T; }\n\n  /// Return the integer type this enum decl corresponds to.\n  /// This returns a null QualType for an enum forward definition with no fixed\n  /// underlying type.\n  QualType getIntegerType() const {\n    if (!IntegerType)\n      return QualType();\n    if (const Type *T = IntegerType.dyn_cast<const Type*>())\n      return QualType(T, 0);\n    return IntegerType.get<TypeSourceInfo*>()->getType().getUnqualifiedType();\n  }\n\n  /// Set the underlying integer type.\n  void setIntegerType(QualType T) { IntegerType = T.getTypePtrOrNull(); }\n\n  /// Set the underlying integer type source info.\n  void setIntegerTypeSourceInfo(TypeSourceInfo *TInfo) { IntegerType = TInfo; }\n\n  /// Return the type source info for the underlying integer type,\n  /// if no type source info exists, return 0.\n  TypeSourceInfo *getIntegerTypeSourceInfo() const {\n    return IntegerType.dyn_cast<TypeSourceInfo*>();\n  }\n\n  /// Retrieve the source range that covers the underlying type if\n  /// specified.\n  SourceRange getIntegerTypeRange() const LLVM_READONLY;\n\n  /// Returns the width in bits required to store all the\n  /// non-negative enumerators of this enum.\n  unsigned getNumPositiveBits() const { return EnumDeclBits.NumPositiveBits; }\n\n  /// Returns the width in bits required to store all the\n  /// negative enumerators of this enum.  These widths include\n  /// the rightmost leading 1;  that is:\n  ///\n  /// MOST NEGATIVE ENUMERATOR     PATTERN     NUM NEGATIVE BITS\n  /// ------------------------     -------     -----------------\n  ///                       -1     1111111                     1\n  ///                      -10     1110110                     5\n  ///                     -101     1001011                     8\n  unsigned getNumNegativeBits() const { return EnumDeclBits.NumNegativeBits; }\n\n  /// Returns true if this is a C++11 scoped enumeration.\n  bool isScoped() const { return EnumDeclBits.IsScoped; }\n\n  /// Returns true if this is a C++11 scoped enumeration.\n  bool isScopedUsingClassTag() const {\n    return EnumDeclBits.IsScopedUsingClassTag;\n  }\n\n  /// Returns true if this is an Objective-C, C++11, or\n  /// Microsoft-style enumeration with a fixed underlying type.\n  bool isFixed() const { return EnumDeclBits.IsFixed; }\n\n  unsigned getODRHash();\n\n  /// Returns true if this can be considered a complete type.\n  bool isComplete() const {\n    // IntegerType is set for fixed type enums and non-fixed but implicitly\n    // int-sized Microsoft enums.\n    return isCompleteDefinition() || IntegerType;\n  }\n\n  /// Returns true if this enum is either annotated with\n  /// enum_extensibility(closed) or isn't annotated with enum_extensibility.\n  bool isClosed() const;\n\n  /// Returns true if this enum is annotated with flag_enum and isn't annotated\n  /// with enum_extensibility(open).\n  bool isClosedFlag() const;\n\n  /// Returns true if this enum is annotated with neither flag_enum nor\n  /// enum_extensibility(open).\n  bool isClosedNonFlag() const;\n\n  /// Retrieve the enum definition from which this enumeration could\n  /// be instantiated, if it is an instantiation (rather than a non-template).\n  EnumDecl *getTemplateInstantiationPattern() const;\n\n  /// Returns the enumeration (declared within the template)\n  /// from which this enumeration type was instantiated, or NULL if\n  /// this enumeration was not instantiated from any template.\n  EnumDecl *getInstantiatedFromMemberEnum() const;\n\n  /// If this enumeration is a member of a specialization of a\n  /// templated class, determine what kind of template specialization\n  /// or instantiation this is.\n  TemplateSpecializationKind getTemplateSpecializationKind() const;\n\n  /// For an enumeration member that was instantiated from a member\n  /// enumeration of a templated class, set the template specialiation kind.\n  void setTemplateSpecializationKind(TemplateSpecializationKind TSK,\n                        SourceLocation PointOfInstantiation = SourceLocation());\n\n  /// If this enumeration is an instantiation of a member enumeration of\n  /// a class template specialization, retrieves the member specialization\n  /// information.\n  MemberSpecializationInfo *getMemberSpecializationInfo() const {\n    return SpecializationInfo;\n  }\n\n  /// Specify that this enumeration is an instantiation of the\n  /// member enumeration ED.\n  void setInstantiationOfMemberEnum(EnumDecl *ED,\n                                    TemplateSpecializationKind TSK) {\n    setInstantiationOfMemberEnum(getASTContext(), ED, TSK);\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Enum; }\n};\n\n/// Represents a struct/union/class.  For example:\n///   struct X;                  // Forward declaration, no \"body\".\n///   union Y { int A, B; };     // Has body with members A and B (FieldDecls).\n/// This decl will be marked invalid if *any* members are invalid.\nclass RecordDecl : public TagDecl {\n  // This class stores some data in DeclContext::RecordDeclBits\n  // to save some space. Use the provided accessors to access it.\npublic:\n  friend class DeclContext;\n  /// Enum that represents the different ways arguments are passed to and\n  /// returned from function calls. This takes into account the target-specific\n  /// and version-specific rules along with the rules determined by the\n  /// language.\n  enum ArgPassingKind : unsigned {\n    /// The argument of this type can be passed directly in registers.\n    APK_CanPassInRegs,\n\n    /// The argument of this type cannot be passed directly in registers.\n    /// Records containing this type as a subobject are not forced to be passed\n    /// indirectly. This value is used only in C++. This value is required by\n    /// C++ because, in uncommon situations, it is possible for a class to have\n    /// only trivial copy/move constructors even when one of its subobjects has\n    /// a non-trivial copy/move constructor (if e.g. the corresponding copy/move\n    /// constructor in the derived class is deleted).\n    APK_CannotPassInRegs,\n\n    /// The argument of this type cannot be passed directly in registers.\n    /// Records containing this type as a subobject are forced to be passed\n    /// indirectly.\n    APK_CanNeverPassInRegs\n  };\n\nprotected:\n  RecordDecl(Kind DK, TagKind TK, const ASTContext &C, DeclContext *DC,\n             SourceLocation StartLoc, SourceLocation IdLoc,\n             IdentifierInfo *Id, RecordDecl *PrevDecl);\n\npublic:\n  static RecordDecl *Create(const ASTContext &C, TagKind TK, DeclContext *DC,\n                            SourceLocation StartLoc, SourceLocation IdLoc,\n                            IdentifierInfo *Id, RecordDecl* PrevDecl = nullptr);\n  static RecordDecl *CreateDeserialized(const ASTContext &C, unsigned ID);\n\n  RecordDecl *getPreviousDecl() {\n    return cast_or_null<RecordDecl>(\n            static_cast<TagDecl *>(this)->getPreviousDecl());\n  }\n  const RecordDecl *getPreviousDecl() const {\n    return const_cast<RecordDecl*>(this)->getPreviousDecl();\n  }\n\n  RecordDecl *getMostRecentDecl() {\n    return cast<RecordDecl>(static_cast<TagDecl *>(this)->getMostRecentDecl());\n  }\n  const RecordDecl *getMostRecentDecl() const {\n    return const_cast<RecordDecl*>(this)->getMostRecentDecl();\n  }\n\n  bool hasFlexibleArrayMember() const {\n    return RecordDeclBits.HasFlexibleArrayMember;\n  }\n\n  void setHasFlexibleArrayMember(bool V) {\n    RecordDeclBits.HasFlexibleArrayMember = V;\n  }\n\n  /// Whether this is an anonymous struct or union. To be an anonymous\n  /// struct or union, it must have been declared without a name and\n  /// there must be no objects of this type declared, e.g.,\n  /// @code\n  ///   union { int i; float f; };\n  /// @endcode\n  /// is an anonymous union but neither of the following are:\n  /// @code\n  ///  union X { int i; float f; };\n  ///  union { int i; float f; } obj;\n  /// @endcode\n  bool isAnonymousStructOrUnion() const {\n    return RecordDeclBits.AnonymousStructOrUnion;\n  }\n\n  void setAnonymousStructOrUnion(bool Anon) {\n    RecordDeclBits.AnonymousStructOrUnion = Anon;\n  }\n\n  bool hasObjectMember() const { return RecordDeclBits.HasObjectMember; }\n  void setHasObjectMember(bool val) { RecordDeclBits.HasObjectMember = val; }\n\n  bool hasVolatileMember() const { return RecordDeclBits.HasVolatileMember; }\n\n  void setHasVolatileMember(bool val) {\n    RecordDeclBits.HasVolatileMember = val;\n  }\n\n  bool hasLoadedFieldsFromExternalStorage() const {\n    return RecordDeclBits.LoadedFieldsFromExternalStorage;\n  }\n\n  void setHasLoadedFieldsFromExternalStorage(bool val) const {\n    RecordDeclBits.LoadedFieldsFromExternalStorage = val;\n  }\n\n  /// Functions to query basic properties of non-trivial C structs.\n  bool isNonTrivialToPrimitiveDefaultInitialize() const {\n    return RecordDeclBits.NonTrivialToPrimitiveDefaultInitialize;\n  }\n\n  void setNonTrivialToPrimitiveDefaultInitialize(bool V) {\n    RecordDeclBits.NonTrivialToPrimitiveDefaultInitialize = V;\n  }\n\n  bool isNonTrivialToPrimitiveCopy() const {\n    return RecordDeclBits.NonTrivialToPrimitiveCopy;\n  }\n\n  void setNonTrivialToPrimitiveCopy(bool V) {\n    RecordDeclBits.NonTrivialToPrimitiveCopy = V;\n  }\n\n  bool isNonTrivialToPrimitiveDestroy() const {\n    return RecordDeclBits.NonTrivialToPrimitiveDestroy;\n  }\n\n  void setNonTrivialToPrimitiveDestroy(bool V) {\n    RecordDeclBits.NonTrivialToPrimitiveDestroy = V;\n  }\n\n  bool hasNonTrivialToPrimitiveDefaultInitializeCUnion() const {\n    return RecordDeclBits.HasNonTrivialToPrimitiveDefaultInitializeCUnion;\n  }\n\n  void setHasNonTrivialToPrimitiveDefaultInitializeCUnion(bool V) {\n    RecordDeclBits.HasNonTrivialToPrimitiveDefaultInitializeCUnion = V;\n  }\n\n  bool hasNonTrivialToPrimitiveDestructCUnion() const {\n    return RecordDeclBits.HasNonTrivialToPrimitiveDestructCUnion;\n  }\n\n  void setHasNonTrivialToPrimitiveDestructCUnion(bool V) {\n    RecordDeclBits.HasNonTrivialToPrimitiveDestructCUnion = V;\n  }\n\n  bool hasNonTrivialToPrimitiveCopyCUnion() const {\n    return RecordDeclBits.HasNonTrivialToPrimitiveCopyCUnion;\n  }\n\n  void setHasNonTrivialToPrimitiveCopyCUnion(bool V) {\n    RecordDeclBits.HasNonTrivialToPrimitiveCopyCUnion = V;\n  }\n\n  /// Determine whether this class can be passed in registers. In C++ mode,\n  /// it must have at least one trivial, non-deleted copy or move constructor.\n  /// FIXME: This should be set as part of completeDefinition.\n  bool canPassInRegisters() const {\n    return getArgPassingRestrictions() == APK_CanPassInRegs;\n  }\n\n  ArgPassingKind getArgPassingRestrictions() const {\n    return static_cast<ArgPassingKind>(RecordDeclBits.ArgPassingRestrictions);\n  }\n\n  void setArgPassingRestrictions(ArgPassingKind Kind) {\n    RecordDeclBits.ArgPassingRestrictions = Kind;\n  }\n\n  bool isParamDestroyedInCallee() const {\n    return RecordDeclBits.ParamDestroyedInCallee;\n  }\n\n  void setParamDestroyedInCallee(bool V) {\n    RecordDeclBits.ParamDestroyedInCallee = V;\n  }\n\n  /// Determines whether this declaration represents the\n  /// injected class name.\n  ///\n  /// The injected class name in C++ is the name of the class that\n  /// appears inside the class itself. For example:\n  ///\n  /// \\code\n  /// struct C {\n  ///   // C is implicitly declared here as a synonym for the class name.\n  /// };\n  ///\n  /// C::C c; // same as \"C c;\"\n  /// \\endcode\n  bool isInjectedClassName() const;\n\n  /// Determine whether this record is a class describing a lambda\n  /// function object.\n  bool isLambda() const;\n\n  /// Determine whether this record is a record for captured variables in\n  /// CapturedStmt construct.\n  bool isCapturedRecord() const;\n\n  /// Mark the record as a record for captured variables in CapturedStmt\n  /// construct.\n  void setCapturedRecord();\n\n  /// Returns the RecordDecl that actually defines\n  ///  this struct/union/class.  When determining whether or not a\n  ///  struct/union/class is completely defined, one should use this\n  ///  method as opposed to 'isCompleteDefinition'.\n  ///  'isCompleteDefinition' indicates whether or not a specific\n  ///  RecordDecl is a completed definition, not whether or not the\n  ///  record type is defined.  This method returns NULL if there is\n  ///  no RecordDecl that defines the struct/union/tag.\n  RecordDecl *getDefinition() const {\n    return cast_or_null<RecordDecl>(TagDecl::getDefinition());\n  }\n\n  /// Returns whether this record is a union, or contains (at any nesting level)\n  /// a union member. This is used by CMSE to warn about possible information\n  /// leaks.\n  bool isOrContainsUnion() const;\n\n  // Iterator access to field members. The field iterator only visits\n  // the non-static data members of this class, ignoring any static\n  // data members, functions, constructors, destructors, etc.\n  using field_iterator = specific_decl_iterator<FieldDecl>;\n  using field_range = llvm::iterator_range<specific_decl_iterator<FieldDecl>>;\n\n  field_range fields() const { return field_range(field_begin(), field_end()); }\n  field_iterator field_begin() const;\n\n  field_iterator field_end() const {\n    return field_iterator(decl_iterator());\n  }\n\n  // Whether there are any fields (non-static data members) in this record.\n  bool field_empty() const {\n    return field_begin() == field_end();\n  }\n\n  /// Note that the definition of this type is now complete.\n  virtual void completeDefinition();\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K >= firstRecord && K <= lastRecord;\n  }\n\n  /// Get whether or not this is an ms_struct which can\n  /// be turned on with an attribute, pragma, or -mms-bitfields\n  /// commandline option.\n  bool isMsStruct(const ASTContext &C) const;\n\n  /// Whether we are allowed to insert extra padding between fields.\n  /// These padding are added to help AddressSanitizer detect\n  /// intra-object-overflow bugs.\n  bool mayInsertExtraPadding(bool EmitRemark = false) const;\n\n  /// Finds the first data member which has a name.\n  /// nullptr is returned if no named data member exists.\n  const FieldDecl *findFirstNamedDataMember() const;\n\nprivate:\n  /// Deserialize just the fields.\n  void LoadFieldsFromExternalStorage() const;\n};\n\nclass FileScopeAsmDecl : public Decl {\n  StringLiteral *AsmString;\n  SourceLocation RParenLoc;\n\n  FileScopeAsmDecl(DeclContext *DC, StringLiteral *asmstring,\n                   SourceLocation StartL, SourceLocation EndL)\n    : Decl(FileScopeAsm, DC, StartL), AsmString(asmstring), RParenLoc(EndL) {}\n\n  virtual void anchor();\n\npublic:\n  static FileScopeAsmDecl *Create(ASTContext &C, DeclContext *DC,\n                                  StringLiteral *Str, SourceLocation AsmLoc,\n                                  SourceLocation RParenLoc);\n\n  static FileScopeAsmDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceLocation getAsmLoc() const { return getLocation(); }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(getAsmLoc(), getRParenLoc());\n  }\n\n  const StringLiteral *getAsmString() const { return AsmString; }\n  StringLiteral *getAsmString() { return AsmString; }\n  void setAsmString(StringLiteral *Asm) { AsmString = Asm; }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == FileScopeAsm; }\n};\n\n/// Represents a block literal declaration, which is like an\n/// unnamed FunctionDecl.  For example:\n/// ^{ statement-body }   or   ^(int arg1, float arg2){ statement-body }\nclass BlockDecl : public Decl, public DeclContext {\n  // This class stores some data in DeclContext::BlockDeclBits\n  // to save some space. Use the provided accessors to access it.\npublic:\n  /// A class which contains all the information about a particular\n  /// captured value.\n  class Capture {\n    enum {\n      flag_isByRef = 0x1,\n      flag_isNested = 0x2\n    };\n\n    /// The variable being captured.\n    llvm::PointerIntPair<VarDecl*, 2> VariableAndFlags;\n\n    /// The copy expression, expressed in terms of a DeclRef (or\n    /// BlockDeclRef) to the captured variable.  Only required if the\n    /// variable has a C++ class type.\n    Expr *CopyExpr;\n\n  public:\n    Capture(VarDecl *variable, bool byRef, bool nested, Expr *copy)\n      : VariableAndFlags(variable,\n                  (byRef ? flag_isByRef : 0) | (nested ? flag_isNested : 0)),\n        CopyExpr(copy) {}\n\n    /// The variable being captured.\n    VarDecl *getVariable() const { return VariableAndFlags.getPointer(); }\n\n    /// Whether this is a \"by ref\" capture, i.e. a capture of a __block\n    /// variable.\n    bool isByRef() const { return VariableAndFlags.getInt() & flag_isByRef; }\n\n    bool isEscapingByref() const {\n      return getVariable()->isEscapingByref();\n    }\n\n    bool isNonEscapingByref() const {\n      return getVariable()->isNonEscapingByref();\n    }\n\n    /// Whether this is a nested capture, i.e. the variable captured\n    /// is not from outside the immediately enclosing function/block.\n    bool isNested() const { return VariableAndFlags.getInt() & flag_isNested; }\n\n    bool hasCopyExpr() const { return CopyExpr != nullptr; }\n    Expr *getCopyExpr() const { return CopyExpr; }\n    void setCopyExpr(Expr *e) { CopyExpr = e; }\n  };\n\nprivate:\n  /// A new[]'d array of pointers to ParmVarDecls for the formal\n  /// parameters of this function.  This is null if a prototype or if there are\n  /// no formals.\n  ParmVarDecl **ParamInfo = nullptr;\n  unsigned NumParams = 0;\n\n  Stmt *Body = nullptr;\n  TypeSourceInfo *SignatureAsWritten = nullptr;\n\n  const Capture *Captures = nullptr;\n  unsigned NumCaptures = 0;\n\n  unsigned ManglingNumber = 0;\n  Decl *ManglingContextDecl = nullptr;\n\nprotected:\n  BlockDecl(DeclContext *DC, SourceLocation CaretLoc);\n\npublic:\n  static BlockDecl *Create(ASTContext &C, DeclContext *DC, SourceLocation L);\n  static BlockDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceLocation getCaretLocation() const { return getLocation(); }\n\n  bool isVariadic() const { return BlockDeclBits.IsVariadic; }\n  void setIsVariadic(bool value) { BlockDeclBits.IsVariadic = value; }\n\n  CompoundStmt *getCompoundBody() const { return (CompoundStmt*) Body; }\n  Stmt *getBody() const override { return (Stmt*) Body; }\n  void setBody(CompoundStmt *B) { Body = (Stmt*) B; }\n\n  void setSignatureAsWritten(TypeSourceInfo *Sig) { SignatureAsWritten = Sig; }\n  TypeSourceInfo *getSignatureAsWritten() const { return SignatureAsWritten; }\n\n  // ArrayRef access to formal parameters.\n  ArrayRef<ParmVarDecl *> parameters() const {\n    return {ParamInfo, getNumParams()};\n  }\n  MutableArrayRef<ParmVarDecl *> parameters() {\n    return {ParamInfo, getNumParams()};\n  }\n\n  // Iterator access to formal parameters.\n  using param_iterator = MutableArrayRef<ParmVarDecl *>::iterator;\n  using param_const_iterator = ArrayRef<ParmVarDecl *>::const_iterator;\n\n  bool param_empty() const { return parameters().empty(); }\n  param_iterator param_begin() { return parameters().begin(); }\n  param_iterator param_end() { return parameters().end(); }\n  param_const_iterator param_begin() const { return parameters().begin(); }\n  param_const_iterator param_end() const { return parameters().end(); }\n  size_t param_size() const { return parameters().size(); }\n\n  unsigned getNumParams() const { return NumParams; }\n\n  const ParmVarDecl *getParamDecl(unsigned i) const {\n    assert(i < getNumParams() && \"Illegal param #\");\n    return ParamInfo[i];\n  }\n  ParmVarDecl *getParamDecl(unsigned i) {\n    assert(i < getNumParams() && \"Illegal param #\");\n    return ParamInfo[i];\n  }\n\n  void setParams(ArrayRef<ParmVarDecl *> NewParamInfo);\n\n  /// True if this block (or its nested blocks) captures\n  /// anything of local storage from its enclosing scopes.\n  bool hasCaptures() const { return NumCaptures || capturesCXXThis(); }\n\n  /// Returns the number of captured variables.\n  /// Does not include an entry for 'this'.\n  unsigned getNumCaptures() const { return NumCaptures; }\n\n  using capture_const_iterator = ArrayRef<Capture>::const_iterator;\n\n  ArrayRef<Capture> captures() const { return {Captures, NumCaptures}; }\n\n  capture_const_iterator capture_begin() const { return captures().begin(); }\n  capture_const_iterator capture_end() const { return captures().end(); }\n\n  bool capturesCXXThis() const { return BlockDeclBits.CapturesCXXThis; }\n  void setCapturesCXXThis(bool B = true) { BlockDeclBits.CapturesCXXThis = B; }\n\n  bool blockMissingReturnType() const {\n    return BlockDeclBits.BlockMissingReturnType;\n  }\n\n  void setBlockMissingReturnType(bool val = true) {\n    BlockDeclBits.BlockMissingReturnType = val;\n  }\n\n  bool isConversionFromLambda() const {\n    return BlockDeclBits.IsConversionFromLambda;\n  }\n\n  void setIsConversionFromLambda(bool val = true) {\n    BlockDeclBits.IsConversionFromLambda = val;\n  }\n\n  bool doesNotEscape() const { return BlockDeclBits.DoesNotEscape; }\n  void setDoesNotEscape(bool B = true) { BlockDeclBits.DoesNotEscape = B; }\n\n  bool canAvoidCopyToHeap() const {\n    return BlockDeclBits.CanAvoidCopyToHeap;\n  }\n  void setCanAvoidCopyToHeap(bool B = true) {\n    BlockDeclBits.CanAvoidCopyToHeap = B;\n  }\n\n  bool capturesVariable(const VarDecl *var) const;\n\n  void setCaptures(ASTContext &Context, ArrayRef<Capture> Captures,\n                   bool CapturesCXXThis);\n\n  unsigned getBlockManglingNumber() const { return ManglingNumber; }\n\n  Decl *getBlockManglingContextDecl() const { return ManglingContextDecl; }\n\n  void setBlockMangling(unsigned Number, Decl *Ctx) {\n    ManglingNumber = Number;\n    ManglingContextDecl = Ctx;\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Block; }\n  static DeclContext *castToDeclContext(const BlockDecl *D) {\n    return static_cast<DeclContext *>(const_cast<BlockDecl*>(D));\n  }\n  static BlockDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<BlockDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Represents the body of a CapturedStmt, and serves as its DeclContext.\nclass CapturedDecl final\n    : public Decl,\n      public DeclContext,\n      private llvm::TrailingObjects<CapturedDecl, ImplicitParamDecl *> {\nprotected:\n  size_t numTrailingObjects(OverloadToken<ImplicitParamDecl>) {\n    return NumParams;\n  }\n\nprivate:\n  /// The number of parameters to the outlined function.\n  unsigned NumParams;\n\n  /// The position of context parameter in list of parameters.\n  unsigned ContextParam;\n\n  /// The body of the outlined function.\n  llvm::PointerIntPair<Stmt *, 1, bool> BodyAndNothrow;\n\n  explicit CapturedDecl(DeclContext *DC, unsigned NumParams);\n\n  ImplicitParamDecl *const *getParams() const {\n    return getTrailingObjects<ImplicitParamDecl *>();\n  }\n\n  ImplicitParamDecl **getParams() {\n    return getTrailingObjects<ImplicitParamDecl *>();\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend TrailingObjects;\n\n  static CapturedDecl *Create(ASTContext &C, DeclContext *DC,\n                              unsigned NumParams);\n  static CapturedDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                          unsigned NumParams);\n\n  Stmt *getBody() const override;\n  void setBody(Stmt *B);\n\n  bool isNothrow() const;\n  void setNothrow(bool Nothrow = true);\n\n  unsigned getNumParams() const { return NumParams; }\n\n  ImplicitParamDecl *getParam(unsigned i) const {\n    assert(i < NumParams);\n    return getParams()[i];\n  }\n  void setParam(unsigned i, ImplicitParamDecl *P) {\n    assert(i < NumParams);\n    getParams()[i] = P;\n  }\n\n  // ArrayRef interface to parameters.\n  ArrayRef<ImplicitParamDecl *> parameters() const {\n    return {getParams(), getNumParams()};\n  }\n  MutableArrayRef<ImplicitParamDecl *> parameters() {\n    return {getParams(), getNumParams()};\n  }\n\n  /// Retrieve the parameter containing captured variables.\n  ImplicitParamDecl *getContextParam() const {\n    assert(ContextParam < NumParams);\n    return getParam(ContextParam);\n  }\n  void setContextParam(unsigned i, ImplicitParamDecl *P) {\n    assert(i < NumParams);\n    ContextParam = i;\n    setParam(i, P);\n  }\n  unsigned getContextParamPosition() const { return ContextParam; }\n\n  using param_iterator = ImplicitParamDecl *const *;\n  using param_range = llvm::iterator_range<param_iterator>;\n\n  /// Retrieve an iterator pointing to the first parameter decl.\n  param_iterator param_begin() const { return getParams(); }\n  /// Retrieve an iterator one past the last parameter decl.\n  param_iterator param_end() const { return getParams() + NumParams; }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Captured; }\n  static DeclContext *castToDeclContext(const CapturedDecl *D) {\n    return static_cast<DeclContext *>(const_cast<CapturedDecl *>(D));\n  }\n  static CapturedDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<CapturedDecl *>(const_cast<DeclContext *>(DC));\n  }\n};\n\n/// Describes a module import declaration, which makes the contents\n/// of the named module visible in the current translation unit.\n///\n/// An import declaration imports the named module (or submodule). For example:\n/// \\code\n///   @import std.vector;\n/// \\endcode\n///\n/// Import declarations can also be implicitly generated from\n/// \\#include/\\#import directives.\nclass ImportDecl final : public Decl,\n                         llvm::TrailingObjects<ImportDecl, SourceLocation> {\n  friend class ASTContext;\n  friend class ASTDeclReader;\n  friend class ASTReader;\n  friend TrailingObjects;\n\n  /// The imported module.\n  Module *ImportedModule = nullptr;\n\n  /// The next import in the list of imports local to the translation\n  /// unit being parsed (not loaded from an AST file).\n  ///\n  /// Includes a bit that indicates whether we have source-location information\n  /// for each identifier in the module name.\n  ///\n  /// When the bit is false, we only have a single source location for the\n  /// end of the import declaration.\n  llvm::PointerIntPair<ImportDecl *, 1, bool> NextLocalImportAndComplete;\n\n  ImportDecl(DeclContext *DC, SourceLocation StartLoc, Module *Imported,\n             ArrayRef<SourceLocation> IdentifierLocs);\n\n  ImportDecl(DeclContext *DC, SourceLocation StartLoc, Module *Imported,\n             SourceLocation EndLoc);\n\n  ImportDecl(EmptyShell Empty) : Decl(Import, Empty) {}\n\n  bool isImportComplete() const { return NextLocalImportAndComplete.getInt(); }\n\n  void setImportComplete(bool C) { NextLocalImportAndComplete.setInt(C); }\n\n  /// The next import in the list of imports local to the translation\n  /// unit being parsed (not loaded from an AST file).\n  ImportDecl *getNextLocalImport() const {\n    return NextLocalImportAndComplete.getPointer();\n  }\n\n  void setNextLocalImport(ImportDecl *Import) {\n    NextLocalImportAndComplete.setPointer(Import);\n  }\n\npublic:\n  /// Create a new module import declaration.\n  static ImportDecl *Create(ASTContext &C, DeclContext *DC,\n                            SourceLocation StartLoc, Module *Imported,\n                            ArrayRef<SourceLocation> IdentifierLocs);\n\n  /// Create a new module import declaration for an implicitly-generated\n  /// import.\n  static ImportDecl *CreateImplicit(ASTContext &C, DeclContext *DC,\n                                    SourceLocation StartLoc, Module *Imported,\n                                    SourceLocation EndLoc);\n\n  /// Create a new, deserialized module import declaration.\n  static ImportDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                        unsigned NumLocations);\n\n  /// Retrieve the module that was imported by the import declaration.\n  Module *getImportedModule() const { return ImportedModule; }\n\n  /// Retrieves the locations of each of the identifiers that make up\n  /// the complete module name in the import declaration.\n  ///\n  /// This will return an empty array if the locations of the individual\n  /// identifiers aren't available.\n  ArrayRef<SourceLocation> getIdentifierLocs() const;\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Import; }\n};\n\n/// Represents a C++ Modules TS module export declaration.\n///\n/// For example:\n/// \\code\n///   export void foo();\n/// \\endcode\nclass ExportDecl final : public Decl, public DeclContext {\n  virtual void anchor();\n\nprivate:\n  friend class ASTDeclReader;\n\n  /// The source location for the right brace (if valid).\n  SourceLocation RBraceLoc;\n\n  ExportDecl(DeclContext *DC, SourceLocation ExportLoc)\n      : Decl(Export, DC, ExportLoc), DeclContext(Export),\n        RBraceLoc(SourceLocation()) {}\n\npublic:\n  static ExportDecl *Create(ASTContext &C, DeclContext *DC,\n                            SourceLocation ExportLoc);\n  static ExportDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceLocation getExportLoc() const { return getLocation(); }\n  SourceLocation getRBraceLoc() const { return RBraceLoc; }\n  void setRBraceLoc(SourceLocation L) { RBraceLoc = L; }\n\n  bool hasBraces() const { return RBraceLoc.isValid(); }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    if (hasBraces())\n      return RBraceLoc;\n    // No braces: get the end location of the (only) declaration in context\n    // (if present).\n    return decls_empty() ? getLocation() : decls_begin()->getEndLoc();\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(getLocation(), getEndLoc());\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Export; }\n  static DeclContext *castToDeclContext(const ExportDecl *D) {\n    return static_cast<DeclContext *>(const_cast<ExportDecl*>(D));\n  }\n  static ExportDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<ExportDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Represents an empty-declaration.\nclass EmptyDecl : public Decl {\n  EmptyDecl(DeclContext *DC, SourceLocation L) : Decl(Empty, DC, L) {}\n\n  virtual void anchor();\n\npublic:\n  static EmptyDecl *Create(ASTContext &C, DeclContext *DC,\n                           SourceLocation L);\n  static EmptyDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Empty; }\n};\n\n/// Insertion operator for diagnostics.  This allows sending NamedDecl's\n/// into a diagnostic with <<.\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &PD,\n                                             const NamedDecl *ND) {\n  PD.AddTaggedVal(reinterpret_cast<intptr_t>(ND),\n                  DiagnosticsEngine::ak_nameddecl);\n  return PD;\n}\n\ntemplate<typename decl_type>\nvoid Redeclarable<decl_type>::setPreviousDecl(decl_type *PrevDecl) {\n  // Note: This routine is implemented here because we need both NamedDecl\n  // and Redeclarable to be defined.\n  assert(RedeclLink.isFirst() &&\n         \"setPreviousDecl on a decl already in a redeclaration chain\");\n\n  if (PrevDecl) {\n    // Point to previous. Make sure that this is actually the most recent\n    // redeclaration, or we can build invalid chains. If the most recent\n    // redeclaration is invalid, it won't be PrevDecl, but we want it anyway.\n    First = PrevDecl->getFirstDecl();\n    assert(First->RedeclLink.isFirst() && \"Expected first\");\n    decl_type *MostRecent = First->getNextRedeclaration();\n    RedeclLink = PreviousDeclLink(cast<decl_type>(MostRecent));\n\n    // If the declaration was previously visible, a redeclaration of it remains\n    // visible even if it wouldn't be visible by itself.\n    static_cast<decl_type*>(this)->IdentifierNamespace |=\n      MostRecent->getIdentifierNamespace() &\n      (Decl::IDNS_Ordinary | Decl::IDNS_Tag | Decl::IDNS_Type);\n  } else {\n    // Make this first.\n    First = static_cast<decl_type*>(this);\n  }\n\n  // First one will point to this one as latest.\n  First->RedeclLink.setLatest(static_cast<decl_type*>(this));\n\n  assert(!isa<NamedDecl>(static_cast<decl_type*>(this)) ||\n         cast<NamedDecl>(static_cast<decl_type*>(this))->isLinkageValid());\n}\n\n// Inline function definitions.\n\n/// Check if the given decl is complete.\n///\n/// We use this function to break a cycle between the inline definitions in\n/// Type.h and Decl.h.\ninline bool IsEnumDeclComplete(EnumDecl *ED) {\n  return ED->isComplete();\n}\n\n/// Check if the given decl is scoped.\n///\n/// We use this function to break a cycle between the inline definitions in\n/// Type.h and Decl.h.\ninline bool IsEnumDeclScoped(EnumDecl *ED) {\n  return ED->isScoped();\n}\n\n/// OpenMP variants are mangled early based on their OpenMP context selector.\n/// The new name looks likes this:\n///  <name> + OpenMPVariantManglingSeparatorStr + <mangled OpenMP context>\nstatic constexpr StringRef getOpenMPVariantManglingSeparatorStr() {\n  return \"$ompvariant\";\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_DECL_H\n"}, "4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclBase.h", "content": "//===- DeclBase.h - Base Classes for representing declarations --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the Decl and DeclContext interfaces.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_DECLBASE_H\n#define LLVM_CLANG_AST_DECLBASE_H\n\n#include \"clang/AST/ASTDumperUtils.h\"\n#include \"clang/AST/AttrIterator.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/PrettyStackTrace.h\"\n#include \"llvm/Support/VersionTuple.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <string>\n#include <type_traits>\n#include <utility>\n\nnamespace clang {\n\nclass ASTContext;\nclass ASTMutationListener;\nclass Attr;\nclass BlockDecl;\nclass DeclContext;\nclass ExternalSourceSymbolAttr;\nclass FunctionDecl;\nclass FunctionType;\nclass IdentifierInfo;\nenum Linkage : unsigned char;\nclass LinkageSpecDecl;\nclass Module;\nclass NamedDecl;\nclass ObjCCategoryDecl;\nclass ObjCCategoryImplDecl;\nclass ObjCContainerDecl;\nclass ObjCImplDecl;\nclass ObjCImplementationDecl;\nclass ObjCInterfaceDecl;\nclass ObjCMethodDecl;\nclass ObjCProtocolDecl;\nstruct PrintingPolicy;\nclass RecordDecl;\nclass SourceManager;\nclass Stmt;\nclass StoredDeclsMap;\nclass TemplateDecl;\nclass TemplateParameterList;\nclass TranslationUnitDecl;\nclass UsingDirectiveDecl;\n\n/// Captures the result of checking the availability of a\n/// declaration.\nenum AvailabilityResult {\n  AR_Available = 0,\n  AR_NotYetIntroduced,\n  AR_Deprecated,\n  AR_Unavailable\n};\n\n/// Decl - This represents one declaration (or definition), e.g. a variable,\n/// typedef, function, struct, etc.\n///\n/// Note: There are objects tacked on before the *beginning* of Decl\n/// (and its subclasses) in its Decl::operator new(). Proper alignment\n/// of all subclasses (not requiring more than the alignment of Decl) is\n/// asserted in DeclBase.cpp.\nclass alignas(8) Decl {\npublic:\n  /// Lists the kind of concrete classes of Decl.\n  enum Kind {\n#define DECL(DERIVED, BASE) DERIVED,\n#define ABSTRACT_DECL(DECL)\n#define DECL_RANGE(BASE, START, END) \\\n        first##BASE = START, last##BASE = END,\n#define LAST_DECL_RANGE(BASE, START, END) \\\n        first##BASE = START, last##BASE = END\n#include \"clang/AST/DeclNodes.inc\"\n  };\n\n  /// A placeholder type used to construct an empty shell of a\n  /// decl-derived type that will be filled in later (e.g., by some\n  /// deserialization method).\n  struct EmptyShell {};\n\n  /// IdentifierNamespace - The different namespaces in which\n  /// declarations may appear.  According to C99 6.2.3, there are\n  /// four namespaces, labels, tags, members and ordinary\n  /// identifiers.  C++ describes lookup completely differently:\n  /// certain lookups merely \"ignore\" certain kinds of declarations,\n  /// usually based on whether the declaration is of a type, etc.\n  ///\n  /// These are meant as bitmasks, so that searches in\n  /// C++ can look into the \"tag\" namespace during ordinary lookup.\n  ///\n  /// Decl currently provides 15 bits of IDNS bits.\n  enum IdentifierNamespace {\n    /// Labels, declared with 'x:' and referenced with 'goto x'.\n    IDNS_Label               = 0x0001,\n\n    /// Tags, declared with 'struct foo;' and referenced with\n    /// 'struct foo'.  All tags are also types.  This is what\n    /// elaborated-type-specifiers look for in C.\n    /// This also contains names that conflict with tags in the\n    /// same scope but that are otherwise ordinary names (non-type\n    /// template parameters and indirect field declarations).\n    IDNS_Tag                 = 0x0002,\n\n    /// Types, declared with 'struct foo', typedefs, etc.\n    /// This is what elaborated-type-specifiers look for in C++,\n    /// but note that it's ill-formed to find a non-tag.\n    IDNS_Type                = 0x0004,\n\n    /// Members, declared with object declarations within tag\n    /// definitions.  In C, these can only be found by \"qualified\"\n    /// lookup in member expressions.  In C++, they're found by\n    /// normal lookup.\n    IDNS_Member              = 0x0008,\n\n    /// Namespaces, declared with 'namespace foo {}'.\n    /// Lookup for nested-name-specifiers find these.\n    IDNS_Namespace           = 0x0010,\n\n    /// Ordinary names.  In C, everything that's not a label, tag,\n    /// member, or function-local extern ends up here.\n    IDNS_Ordinary            = 0x0020,\n\n    /// Objective C \\@protocol.\n    IDNS_ObjCProtocol        = 0x0040,\n\n    /// This declaration is a friend function.  A friend function\n    /// declaration is always in this namespace but may also be in\n    /// IDNS_Ordinary if it was previously declared.\n    IDNS_OrdinaryFriend      = 0x0080,\n\n    /// This declaration is a friend class.  A friend class\n    /// declaration is always in this namespace but may also be in\n    /// IDNS_Tag|IDNS_Type if it was previously declared.\n    IDNS_TagFriend           = 0x0100,\n\n    /// This declaration is a using declaration.  A using declaration\n    /// *introduces* a number of other declarations into the current\n    /// scope, and those declarations use the IDNS of their targets,\n    /// but the actual using declarations go in this namespace.\n    IDNS_Using               = 0x0200,\n\n    /// This declaration is a C++ operator declared in a non-class\n    /// context.  All such operators are also in IDNS_Ordinary.\n    /// C++ lexical operator lookup looks for these.\n    IDNS_NonMemberOperator   = 0x0400,\n\n    /// This declaration is a function-local extern declaration of a\n    /// variable or function. This may also be IDNS_Ordinary if it\n    /// has been declared outside any function. These act mostly like\n    /// invisible friend declarations, but are also visible to unqualified\n    /// lookup within the scope of the declaring function.\n    IDNS_LocalExtern         = 0x0800,\n\n    /// This declaration is an OpenMP user defined reduction construction.\n    IDNS_OMPReduction        = 0x1000,\n\n    /// This declaration is an OpenMP user defined mapper.\n    IDNS_OMPMapper           = 0x2000,\n  };\n\n  /// ObjCDeclQualifier - 'Qualifiers' written next to the return and\n  /// parameter types in method declarations.  Other than remembering\n  /// them and mangling them into the method's signature string, these\n  /// are ignored by the compiler; they are consumed by certain\n  /// remote-messaging frameworks.\n  ///\n  /// in, inout, and out are mutually exclusive and apply only to\n  /// method parameters.  bycopy and byref are mutually exclusive and\n  /// apply only to method parameters (?).  oneway applies only to\n  /// results.  All of these expect their corresponding parameter to\n  /// have a particular type.  None of this is currently enforced by\n  /// clang.\n  ///\n  /// This should be kept in sync with ObjCDeclSpec::ObjCDeclQualifier.\n  enum ObjCDeclQualifier {\n    OBJC_TQ_None = 0x0,\n    OBJC_TQ_In = 0x1,\n    OBJC_TQ_Inout = 0x2,\n    OBJC_TQ_Out = 0x4,\n    OBJC_TQ_Bycopy = 0x8,\n    OBJC_TQ_Byref = 0x10,\n    OBJC_TQ_Oneway = 0x20,\n\n    /// The nullability qualifier is set when the nullability of the\n    /// result or parameter was expressed via a context-sensitive\n    /// keyword.\n    OBJC_TQ_CSNullability = 0x40\n  };\n\n  /// The kind of ownership a declaration has, for visibility purposes.\n  /// This enumeration is designed such that higher values represent higher\n  /// levels of name hiding.\n  enum class ModuleOwnershipKind : unsigned {\n    /// This declaration is not owned by a module.\n    Unowned,\n\n    /// This declaration has an owning module, but is globally visible\n    /// (typically because its owning module is visible and we know that\n    /// modules cannot later become hidden in this compilation).\n    /// After serialization and deserialization, this will be converted\n    /// to VisibleWhenImported.\n    Visible,\n\n    /// This declaration has an owning module, and is visible when that\n    /// module is imported.\n    VisibleWhenImported,\n\n    /// This declaration has an owning module, but is only visible to\n    /// lookups that occur within that module.\n    ModulePrivate\n  };\n\nprotected:\n  /// The next declaration within the same lexical\n  /// DeclContext. These pointers form the linked list that is\n  /// traversed via DeclContext's decls_begin()/decls_end().\n  ///\n  /// The extra two bits are used for the ModuleOwnershipKind.\n  llvm::PointerIntPair<Decl *, 2, ModuleOwnershipKind> NextInContextAndBits;\n\nprivate:\n  friend class DeclContext;\n\n  struct MultipleDC {\n    DeclContext *SemanticDC;\n    DeclContext *LexicalDC;\n  };\n\n  /// DeclCtx - Holds either a DeclContext* or a MultipleDC*.\n  /// For declarations that don't contain C++ scope specifiers, it contains\n  /// the DeclContext where the Decl was declared.\n  /// For declarations with C++ scope specifiers, it contains a MultipleDC*\n  /// with the context where it semantically belongs (SemanticDC) and the\n  /// context where it was lexically declared (LexicalDC).\n  /// e.g.:\n  ///\n  ///   namespace A {\n  ///      void f(); // SemanticDC == LexicalDC == 'namespace A'\n  ///   }\n  ///   void A::f(); // SemanticDC == namespace 'A'\n  ///                // LexicalDC == global namespace\n  llvm::PointerUnion<DeclContext*, MultipleDC*> DeclCtx;\n\n  bool isInSemaDC() const { return DeclCtx.is<DeclContext*>(); }\n  bool isOutOfSemaDC() const { return DeclCtx.is<MultipleDC*>(); }\n\n  MultipleDC *getMultipleDC() const {\n    return DeclCtx.get<MultipleDC*>();\n  }\n\n  DeclContext *getSemanticDC() const {\n    return DeclCtx.get<DeclContext*>();\n  }\n\n  /// Loc - The location of this decl.\n  SourceLocation Loc;\n\n  /// DeclKind - This indicates which class this is.\n  unsigned DeclKind : 7;\n\n  /// InvalidDecl - This indicates a semantic error occurred.\n  unsigned InvalidDecl :  1;\n\n  /// HasAttrs - This indicates whether the decl has attributes or not.\n  unsigned HasAttrs : 1;\n\n  /// Implicit - Whether this declaration was implicitly generated by\n  /// the implementation rather than explicitly written by the user.\n  unsigned Implicit : 1;\n\n  /// Whether this declaration was \"used\", meaning that a definition is\n  /// required.\n  unsigned Used : 1;\n\n  /// Whether this declaration was \"referenced\".\n  /// The difference with 'Used' is whether the reference appears in a\n  /// evaluated context or not, e.g. functions used in uninstantiated templates\n  /// are regarded as \"referenced\" but not \"used\".\n  unsigned Referenced : 1;\n\n  /// Whether this declaration is a top-level declaration (function,\n  /// global variable, etc.) that is lexically inside an objc container\n  /// definition.\n  unsigned TopLevelDeclInObjCContainer : 1;\n\n  /// Whether statistic collection is enabled.\n  static bool StatisticsEnabled;\n\nprotected:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend class ASTNodeImporter;\n  friend class ASTReader;\n  friend class CXXClassMemberWrapper;\n  friend class LinkageComputer;\n  template<typename decl_type> friend class Redeclarable;\n\n  /// Access - Used by C++ decls for the access specifier.\n  // NOTE: VC++ treats enums as signed, avoid using the AccessSpecifier enum\n  unsigned Access : 2;\n\n  /// Whether this declaration was loaded from an AST file.\n  unsigned FromASTFile : 1;\n\n  /// IdentifierNamespace - This specifies what IDNS_* namespace this lives in.\n  unsigned IdentifierNamespace : 14;\n\n  /// If 0, we have not computed the linkage of this declaration.\n  /// Otherwise, it is the linkage + 1.\n  mutable unsigned CacheValidAndLinkage : 3;\n\n  /// Allocate memory for a deserialized declaration.\n  ///\n  /// This routine must be used to allocate memory for any declaration that is\n  /// deserialized from a module file.\n  ///\n  /// \\param Size The size of the allocated object.\n  /// \\param Ctx The context in which we will allocate memory.\n  /// \\param ID The global ID of the deserialized declaration.\n  /// \\param Extra The amount of extra space to allocate after the object.\n  void *operator new(std::size_t Size, const ASTContext &Ctx, unsigned ID,\n                     std::size_t Extra = 0);\n\n  /// Allocate memory for a non-deserialized declaration.\n  void *operator new(std::size_t Size, const ASTContext &Ctx,\n                     DeclContext *Parent, std::size_t Extra = 0);\n\nprivate:\n  bool AccessDeclContextSanity() const;\n\n  /// Get the module ownership kind to use for a local lexical child of \\p DC,\n  /// which may be either a local or (rarely) an imported declaration.\n  static ModuleOwnershipKind getModuleOwnershipKindForChildOf(DeclContext *DC) {\n    if (DC) {\n      auto *D = cast<Decl>(DC);\n      auto MOK = D->getModuleOwnershipKind();\n      if (MOK != ModuleOwnershipKind::Unowned &&\n          (!D->isFromASTFile() || D->hasLocalOwningModuleStorage()))\n        return MOK;\n      // If D is not local and we have no local module storage, then we don't\n      // need to track module ownership at all.\n    }\n    return ModuleOwnershipKind::Unowned;\n  }\n\npublic:\n  Decl() = delete;\n  Decl(const Decl&) = delete;\n  Decl(Decl &&) = delete;\n  Decl &operator=(const Decl&) = delete;\n  Decl &operator=(Decl&&) = delete;\n\nprotected:\n  Decl(Kind DK, DeclContext *DC, SourceLocation L)\n      : NextInContextAndBits(nullptr, getModuleOwnershipKindForChildOf(DC)),\n        DeclCtx(DC), Loc(L), DeclKind(DK), InvalidDecl(false), HasAttrs(false),\n        Implicit(false), Used(false), Referenced(false),\n        TopLevelDeclInObjCContainer(false), Access(AS_none), FromASTFile(0),\n        IdentifierNamespace(getIdentifierNamespaceForKind(DK)),\n        CacheValidAndLinkage(0) {\n    if (StatisticsEnabled) add(DK);\n  }\n\n  Decl(Kind DK, EmptyShell Empty)\n      : DeclKind(DK), InvalidDecl(false), HasAttrs(false), Implicit(false),\n        Used(false), Referenced(false), TopLevelDeclInObjCContainer(false),\n        Access(AS_none), FromASTFile(0),\n        IdentifierNamespace(getIdentifierNamespaceForKind(DK)),\n        CacheValidAndLinkage(0) {\n    if (StatisticsEnabled) add(DK);\n  }\n\n  virtual ~Decl();\n\n  /// Update a potentially out-of-date declaration.\n  void updateOutOfDate(IdentifierInfo &II) const;\n\n  Linkage getCachedLinkage() const {\n    return Linkage(CacheValidAndLinkage - 1);\n  }\n\n  void setCachedLinkage(Linkage L) const {\n    CacheValidAndLinkage = L + 1;\n  }\n\n  bool hasCachedLinkage() const {\n    return CacheValidAndLinkage;\n  }\n\npublic:\n  /// Source range that this declaration covers.\n  virtual SourceRange getSourceRange() const LLVM_READONLY {\n    return SourceRange(getLocation(), getLocation());\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getSourceRange().getBegin();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getSourceRange().getEnd();\n  }\n\n  SourceLocation getLocation() const { return Loc; }\n  void setLocation(SourceLocation L) { Loc = L; }\n\n  Kind getKind() const { return static_cast<Kind>(DeclKind); }\n  const char *getDeclKindName() const;\n\n  Decl *getNextDeclInContext() { return NextInContextAndBits.getPointer(); }\n  const Decl *getNextDeclInContext() const {return NextInContextAndBits.getPointer();}\n\n  DeclContext *getDeclContext() {\n    if (isInSemaDC())\n      return getSemanticDC();\n    return getMultipleDC()->SemanticDC;\n  }\n  const DeclContext *getDeclContext() const {\n    return const_cast<Decl*>(this)->getDeclContext();\n  }\n\n  /// Find the innermost non-closure ancestor of this declaration,\n  /// walking up through blocks, lambdas, etc.  If that ancestor is\n  /// not a code context (!isFunctionOrMethod()), returns null.\n  ///\n  /// A declaration may be its own non-closure context.\n  Decl *getNonClosureContext();\n  const Decl *getNonClosureContext() const {\n    return const_cast<Decl*>(this)->getNonClosureContext();\n  }\n\n  TranslationUnitDecl *getTranslationUnitDecl();\n  const TranslationUnitDecl *getTranslationUnitDecl() const {\n    return const_cast<Decl*>(this)->getTranslationUnitDecl();\n  }\n\n  bool isInAnonymousNamespace() const;\n\n  bool isInStdNamespace() const;\n\n  ASTContext &getASTContext() const LLVM_READONLY;\n\n  /// Helper to get the language options from the ASTContext.\n  /// Defined out of line to avoid depending on ASTContext.h.\n  const LangOptions &getLangOpts() const LLVM_READONLY;\n\n  void setAccess(AccessSpecifier AS) {\n    Access = AS;\n    assert(AccessDeclContextSanity());\n  }\n\n  AccessSpecifier getAccess() const {\n    assert(AccessDeclContextSanity());\n    return AccessSpecifier(Access);\n  }\n\n  /// Retrieve the access specifier for this declaration, even though\n  /// it may not yet have been properly set.\n  AccessSpecifier getAccessUnsafe() const {\n    return AccessSpecifier(Access);\n  }\n\n  bool hasAttrs() const { return HasAttrs; }\n\n  void setAttrs(const AttrVec& Attrs) {\n    return setAttrsImpl(Attrs, getASTContext());\n  }\n\n  AttrVec &getAttrs() {\n    return const_cast<AttrVec&>(const_cast<const Decl*>(this)->getAttrs());\n  }\n\n  const AttrVec &getAttrs() const;\n  void dropAttrs();\n  void addAttr(Attr *A);\n\n  using attr_iterator = AttrVec::const_iterator;\n  using attr_range = llvm::iterator_range<attr_iterator>;\n\n  attr_range attrs() const {\n    return attr_range(attr_begin(), attr_end());\n  }\n\n  attr_iterator attr_begin() const {\n    return hasAttrs() ? getAttrs().begin() : nullptr;\n  }\n  attr_iterator attr_end() const {\n    return hasAttrs() ? getAttrs().end() : nullptr;\n  }\n\n  template <typename T>\n  void dropAttr() {\n    if (!HasAttrs) return;\n\n    AttrVec &Vec = getAttrs();\n    llvm::erase_if(Vec, [](Attr *A) { return isa<T>(A); });\n\n    if (Vec.empty())\n      HasAttrs = false;\n  }\n\n  template <typename T>\n  llvm::iterator_range<specific_attr_iterator<T>> specific_attrs() const {\n    return llvm::make_range(specific_attr_begin<T>(), specific_attr_end<T>());\n  }\n\n  template <typename T>\n  specific_attr_iterator<T> specific_attr_begin() const {\n    return specific_attr_iterator<T>(attr_begin());\n  }\n\n  template <typename T>\n  specific_attr_iterator<T> specific_attr_end() const {\n    return specific_attr_iterator<T>(attr_end());\n  }\n\n  template<typename T> T *getAttr() const {\n    return hasAttrs() ? getSpecificAttr<T>(getAttrs()) : nullptr;\n  }\n\n  template<typename T> bool hasAttr() const {\n    return hasAttrs() && hasSpecificAttr<T>(getAttrs());\n  }\n\n  /// getMaxAlignment - return the maximum alignment specified by attributes\n  /// on this decl, 0 if there are none.\n  unsigned getMaxAlignment() const;\n\n  /// setInvalidDecl - Indicates the Decl had a semantic error. This\n  /// allows for graceful error recovery.\n  void setInvalidDecl(bool Invalid = true);\n  bool isInvalidDecl() const { return (bool) InvalidDecl; }\n\n  /// isImplicit - Indicates whether the declaration was implicitly\n  /// generated by the implementation. If false, this declaration\n  /// was written explicitly in the source code.\n  bool isImplicit() const { return Implicit; }\n  void setImplicit(bool I = true) { Implicit = I; }\n\n  /// Whether *any* (re-)declaration of the entity was used, meaning that\n  /// a definition is required.\n  ///\n  /// \\param CheckUsedAttr When true, also consider the \"used\" attribute\n  /// (in addition to the \"used\" bit set by \\c setUsed()) when determining\n  /// whether the function is used.\n  bool isUsed(bool CheckUsedAttr = true) const;\n\n  /// Set whether the declaration is used, in the sense of odr-use.\n  ///\n  /// This should only be used immediately after creating a declaration.\n  /// It intentionally doesn't notify any listeners.\n  void setIsUsed() { getCanonicalDecl()->Used = true; }\n\n  /// Mark the declaration used, in the sense of odr-use.\n  ///\n  /// This notifies any mutation listeners in addition to setting a bit\n  /// indicating the declaration is used.\n  void markUsed(ASTContext &C);\n\n  /// Whether any declaration of this entity was referenced.\n  bool isReferenced() const;\n\n  /// Whether this declaration was referenced. This should not be relied\n  /// upon for anything other than debugging.\n  bool isThisDeclarationReferenced() const { return Referenced; }\n\n  void setReferenced(bool R = true) { Referenced = R; }\n\n  /// Whether this declaration is a top-level declaration (function,\n  /// global variable, etc.) that is lexically inside an objc container\n  /// definition.\n  bool isTopLevelDeclInObjCContainer() const {\n    return TopLevelDeclInObjCContainer;\n  }\n\n  void setTopLevelDeclInObjCContainer(bool V = true) {\n    TopLevelDeclInObjCContainer = V;\n  }\n\n  /// Looks on this and related declarations for an applicable\n  /// external source symbol attribute.\n  ExternalSourceSymbolAttr *getExternalSourceSymbolAttr() const;\n\n  /// Whether this declaration was marked as being private to the\n  /// module in which it was defined.\n  bool isModulePrivate() const {\n    return getModuleOwnershipKind() == ModuleOwnershipKind::ModulePrivate;\n  }\n\n  /// Return true if this declaration has an attribute which acts as\n  /// definition of the entity, such as 'alias' or 'ifunc'.\n  bool hasDefiningAttr() const;\n\n  /// Return this declaration's defining attribute if it has one.\n  const Attr *getDefiningAttr() const;\n\nprotected:\n  /// Specify that this declaration was marked as being private\n  /// to the module in which it was defined.\n  void setModulePrivate() {\n    // The module-private specifier has no effect on unowned declarations.\n    // FIXME: We should track this in some way for source fidelity.\n    if (getModuleOwnershipKind() == ModuleOwnershipKind::Unowned)\n      return;\n    setModuleOwnershipKind(ModuleOwnershipKind::ModulePrivate);\n  }\n\npublic:\n  /// Set the FromASTFile flag. This indicates that this declaration\n  /// was deserialized and not parsed from source code and enables\n  /// features such as module ownership information.\n  void setFromASTFile() {\n    FromASTFile = true;\n  }\n\n  /// Set the owning module ID.  This may only be called for\n  /// deserialized Decls.\n  void setOwningModuleID(unsigned ID) {\n    assert(isFromASTFile() && \"Only works on a deserialized declaration\");\n    *((unsigned*)this - 2) = ID;\n  }\n\npublic:\n  /// Determine the availability of the given declaration.\n  ///\n  /// This routine will determine the most restrictive availability of\n  /// the given declaration (e.g., preferring 'unavailable' to\n  /// 'deprecated').\n  ///\n  /// \\param Message If non-NULL and the result is not \\c\n  /// AR_Available, will be set to a (possibly empty) message\n  /// describing why the declaration has not been introduced, is\n  /// deprecated, or is unavailable.\n  ///\n  /// \\param EnclosingVersion The version to compare with. If empty, assume the\n  /// deployment target version.\n  ///\n  /// \\param RealizedPlatform If non-NULL and the availability result is found\n  /// in an available attribute it will set to the platform which is written in\n  /// the available attribute.\n  AvailabilityResult\n  getAvailability(std::string *Message = nullptr,\n                  VersionTuple EnclosingVersion = VersionTuple(),\n                  StringRef *RealizedPlatform = nullptr) const;\n\n  /// Retrieve the version of the target platform in which this\n  /// declaration was introduced.\n  ///\n  /// \\returns An empty version tuple if this declaration has no 'introduced'\n  /// availability attributes, or the version tuple that's specified in the\n  /// attribute otherwise.\n  VersionTuple getVersionIntroduced() const;\n\n  /// Determine whether this declaration is marked 'deprecated'.\n  ///\n  /// \\param Message If non-NULL and the declaration is deprecated,\n  /// this will be set to the message describing why the declaration\n  /// was deprecated (which may be empty).\n  bool isDeprecated(std::string *Message = nullptr) const {\n    return getAvailability(Message) == AR_Deprecated;\n  }\n\n  /// Determine whether this declaration is marked 'unavailable'.\n  ///\n  /// \\param Message If non-NULL and the declaration is unavailable,\n  /// this will be set to the message describing why the declaration\n  /// was made unavailable (which may be empty).\n  bool isUnavailable(std::string *Message = nullptr) const {\n    return getAvailability(Message) == AR_Unavailable;\n  }\n\n  /// Determine whether this is a weak-imported symbol.\n  ///\n  /// Weak-imported symbols are typically marked with the\n  /// 'weak_import' attribute, but may also be marked with an\n  /// 'availability' attribute where we're targing a platform prior to\n  /// the introduction of this feature.\n  bool isWeakImported() const;\n\n  /// Determines whether this symbol can be weak-imported,\n  /// e.g., whether it would be well-formed to add the weak_import\n  /// attribute.\n  ///\n  /// \\param IsDefinition Set to \\c true to indicate that this\n  /// declaration cannot be weak-imported because it has a definition.\n  bool canBeWeakImported(bool &IsDefinition) const;\n\n  /// Determine whether this declaration came from an AST file (such as\n  /// a precompiled header or module) rather than having been parsed.\n  bool isFromASTFile() const { return FromASTFile; }\n\n  /// Retrieve the global declaration ID associated with this\n  /// declaration, which specifies where this Decl was loaded from.\n  unsigned getGlobalID() const {\n    if (isFromASTFile())\n      return *((const unsigned*)this - 1);\n    return 0;\n  }\n\n  /// Retrieve the global ID of the module that owns this particular\n  /// declaration.\n  unsigned getOwningModuleID() const {\n    if (isFromASTFile())\n      return *((const unsigned*)this - 2);\n    return 0;\n  }\n\nprivate:\n  Module *getOwningModuleSlow() const;\n\nprotected:\n  bool hasLocalOwningModuleStorage() const;\n\npublic:\n  /// Get the imported owning module, if this decl is from an imported\n  /// (non-local) module.\n  Module *getImportedOwningModule() const {\n    if (!isFromASTFile() || !hasOwningModule())\n      return nullptr;\n\n    return getOwningModuleSlow();\n  }\n\n  /// Get the local owning module, if known. Returns nullptr if owner is\n  /// not yet known or declaration is not from a module.\n  Module *getLocalOwningModule() const {\n    if (isFromASTFile() || !hasOwningModule())\n      return nullptr;\n\n    assert(hasLocalOwningModuleStorage() &&\n           \"owned local decl but no local module storage\");\n    return reinterpret_cast<Module *const *>(this)[-1];\n  }\n  void setLocalOwningModule(Module *M) {\n    assert(!isFromASTFile() && hasOwningModule() &&\n           hasLocalOwningModuleStorage() &&\n           \"should not have a cached owning module\");\n    reinterpret_cast<Module **>(this)[-1] = M;\n  }\n\n  /// Is this declaration owned by some module?\n  bool hasOwningModule() const {\n    return getModuleOwnershipKind() != ModuleOwnershipKind::Unowned;\n  }\n\n  /// Get the module that owns this declaration (for visibility purposes).\n  Module *getOwningModule() const {\n    return isFromASTFile() ? getImportedOwningModule() : getLocalOwningModule();\n  }\n\n  /// Get the module that owns this declaration for linkage purposes.\n  /// There only ever is such a module under the C++ Modules TS.\n  ///\n  /// \\param IgnoreLinkage Ignore the linkage of the entity; assume that\n  /// all declarations in a global module fragment are unowned.\n  Module *getOwningModuleForLinkage(bool IgnoreLinkage = false) const;\n\n  /// Determine whether this declaration is definitely visible to name lookup,\n  /// independent of whether the owning module is visible.\n  /// Note: The declaration may be visible even if this returns \\c false if the\n  /// owning module is visible within the query context. This is a low-level\n  /// helper function; most code should be calling Sema::isVisible() instead.\n  bool isUnconditionallyVisible() const {\n    return (int)getModuleOwnershipKind() <= (int)ModuleOwnershipKind::Visible;\n  }\n\n  /// Set that this declaration is globally visible, even if it came from a\n  /// module that is not visible.\n  void setVisibleDespiteOwningModule() {\n    if (!isUnconditionallyVisible())\n      setModuleOwnershipKind(ModuleOwnershipKind::Visible);\n  }\n\n  /// Get the kind of module ownership for this declaration.\n  ModuleOwnershipKind getModuleOwnershipKind() const {\n    return NextInContextAndBits.getInt();\n  }\n\n  /// Set whether this declaration is hidden from name lookup.\n  void setModuleOwnershipKind(ModuleOwnershipKind MOK) {\n    assert(!(getModuleOwnershipKind() == ModuleOwnershipKind::Unowned &&\n             MOK != ModuleOwnershipKind::Unowned && !isFromASTFile() &&\n             !hasLocalOwningModuleStorage()) &&\n           \"no storage available for owning module for this declaration\");\n    NextInContextAndBits.setInt(MOK);\n  }\n\n  unsigned getIdentifierNamespace() const {\n    return IdentifierNamespace;\n  }\n\n  bool isInIdentifierNamespace(unsigned NS) const {\n    return getIdentifierNamespace() & NS;\n  }\n\n  static unsigned getIdentifierNamespaceForKind(Kind DK);\n\n  bool hasTagIdentifierNamespace() const {\n    return isTagIdentifierNamespace(getIdentifierNamespace());\n  }\n\n  static bool isTagIdentifierNamespace(unsigned NS) {\n    // TagDecls have Tag and Type set and may also have TagFriend.\n    return (NS & ~IDNS_TagFriend) == (IDNS_Tag | IDNS_Type);\n  }\n\n  /// getLexicalDeclContext - The declaration context where this Decl was\n  /// lexically declared (LexicalDC). May be different from\n  /// getDeclContext() (SemanticDC).\n  /// e.g.:\n  ///\n  ///   namespace A {\n  ///      void f(); // SemanticDC == LexicalDC == 'namespace A'\n  ///   }\n  ///   void A::f(); // SemanticDC == namespace 'A'\n  ///                // LexicalDC == global namespace\n  DeclContext *getLexicalDeclContext() {\n    if (isInSemaDC())\n      return getSemanticDC();\n    return getMultipleDC()->LexicalDC;\n  }\n  const DeclContext *getLexicalDeclContext() const {\n    return const_cast<Decl*>(this)->getLexicalDeclContext();\n  }\n\n  /// Determine whether this declaration is declared out of line (outside its\n  /// semantic context).\n  virtual bool isOutOfLine() const;\n\n  /// setDeclContext - Set both the semantic and lexical DeclContext\n  /// to DC.\n  void setDeclContext(DeclContext *DC);\n\n  void setLexicalDeclContext(DeclContext *DC);\n\n  /// Determine whether this declaration is a templated entity (whether it is\n  // within the scope of a template parameter).\n  bool isTemplated() const;\n\n  /// Determine the number of levels of template parameter surrounding this\n  /// declaration.\n  unsigned getTemplateDepth() const;\n\n  /// isDefinedOutsideFunctionOrMethod - This predicate returns true if this\n  /// scoped decl is defined outside the current function or method.  This is\n  /// roughly global variables and functions, but also handles enums (which\n  /// could be defined inside or outside a function etc).\n  bool isDefinedOutsideFunctionOrMethod() const {\n    return getParentFunctionOrMethod() == nullptr;\n  }\n\n  /// Determine whether a substitution into this declaration would occur as\n  /// part of a substitution into a dependent local scope. Such a substitution\n  /// transitively substitutes into all constructs nested within this\n  /// declaration.\n  ///\n  /// This recognizes non-defining declarations as well as members of local\n  /// classes and lambdas:\n  /// \\code\n  ///     template<typename T> void foo() { void bar(); }\n  ///     template<typename T> void foo2() { class ABC { void bar(); }; }\n  ///     template<typename T> inline int x = [](){ return 0; }();\n  /// \\endcode\n  bool isInLocalScopeForInstantiation() const;\n\n  /// If this decl is defined inside a function/method/block it returns\n  /// the corresponding DeclContext, otherwise it returns null.\n  const DeclContext *getParentFunctionOrMethod() const;\n  DeclContext *getParentFunctionOrMethod() {\n    return const_cast<DeclContext*>(\n                    const_cast<const Decl*>(this)->getParentFunctionOrMethod());\n  }\n\n  /// Retrieves the \"canonical\" declaration of the given declaration.\n  virtual Decl *getCanonicalDecl() { return this; }\n  const Decl *getCanonicalDecl() const {\n    return const_cast<Decl*>(this)->getCanonicalDecl();\n  }\n\n  /// Whether this particular Decl is a canonical one.\n  bool isCanonicalDecl() const { return getCanonicalDecl() == this; }\n\nprotected:\n  /// Returns the next redeclaration or itself if this is the only decl.\n  ///\n  /// Decl subclasses that can be redeclared should override this method so that\n  /// Decl::redecl_iterator can iterate over them.\n  virtual Decl *getNextRedeclarationImpl() { return this; }\n\n  /// Implementation of getPreviousDecl(), to be overridden by any\n  /// subclass that has a redeclaration chain.\n  virtual Decl *getPreviousDeclImpl() { return nullptr; }\n\n  /// Implementation of getMostRecentDecl(), to be overridden by any\n  /// subclass that has a redeclaration chain.\n  virtual Decl *getMostRecentDeclImpl() { return this; }\n\npublic:\n  /// Iterates through all the redeclarations of the same decl.\n  class redecl_iterator {\n    /// Current - The current declaration.\n    Decl *Current = nullptr;\n    Decl *Starter;\n\n  public:\n    using value_type = Decl *;\n    using reference = const value_type &;\n    using pointer = const value_type *;\n    using iterator_category = std::forward_iterator_tag;\n    using difference_type = std::ptrdiff_t;\n\n    redecl_iterator() = default;\n    explicit redecl_iterator(Decl *C) : Current(C), Starter(C) {}\n\n    reference operator*() const { return Current; }\n    value_type operator->() const { return Current; }\n\n    redecl_iterator& operator++() {\n      assert(Current && \"Advancing while iterator has reached end\");\n      // Get either previous decl or latest decl.\n      Decl *Next = Current->getNextRedeclarationImpl();\n      assert(Next && \"Should return next redeclaration or itself, never null!\");\n      Current = (Next != Starter) ? Next : nullptr;\n      return *this;\n    }\n\n    redecl_iterator operator++(int) {\n      redecl_iterator tmp(*this);\n      ++(*this);\n      return tmp;\n    }\n\n    friend bool operator==(redecl_iterator x, redecl_iterator y) {\n      return x.Current == y.Current;\n    }\n\n    friend bool operator!=(redecl_iterator x, redecl_iterator y) {\n      return x.Current != y.Current;\n    }\n  };\n\n  using redecl_range = llvm::iterator_range<redecl_iterator>;\n\n  /// Returns an iterator range for all the redeclarations of the same\n  /// decl. It will iterate at least once (when this decl is the only one).\n  redecl_range redecls() const {\n    return redecl_range(redecls_begin(), redecls_end());\n  }\n\n  redecl_iterator redecls_begin() const {\n    return redecl_iterator(const_cast<Decl *>(this));\n  }\n\n  redecl_iterator redecls_end() const { return redecl_iterator(); }\n\n  /// Retrieve the previous declaration that declares the same entity\n  /// as this declaration, or NULL if there is no previous declaration.\n  Decl *getPreviousDecl() { return getPreviousDeclImpl(); }\n\n  /// Retrieve the previous declaration that declares the same entity\n  /// as this declaration, or NULL if there is no previous declaration.\n  const Decl *getPreviousDecl() const {\n    return const_cast<Decl *>(this)->getPreviousDeclImpl();\n  }\n\n  /// True if this is the first declaration in its redeclaration chain.\n  bool isFirstDecl() const {\n    return getPreviousDecl() == nullptr;\n  }\n\n  /// Retrieve the most recent declaration that declares the same entity\n  /// as this declaration (which may be this declaration).\n  Decl *getMostRecentDecl() { return getMostRecentDeclImpl(); }\n\n  /// Retrieve the most recent declaration that declares the same entity\n  /// as this declaration (which may be this declaration).\n  const Decl *getMostRecentDecl() const {\n    return const_cast<Decl *>(this)->getMostRecentDeclImpl();\n  }\n\n  /// getBody - If this Decl represents a declaration for a body of code,\n  ///  such as a function or method definition, this method returns the\n  ///  top-level Stmt* of that body.  Otherwise this method returns null.\n  virtual Stmt* getBody() const { return nullptr; }\n\n  /// Returns true if this \\c Decl represents a declaration for a body of\n  /// code, such as a function or method definition.\n  /// Note that \\c hasBody can also return true if any redeclaration of this\n  /// \\c Decl represents a declaration for a body of code.\n  virtual bool hasBody() const { return getBody() != nullptr; }\n\n  /// getBodyRBrace - Gets the right brace of the body, if a body exists.\n  /// This works whether the body is a CompoundStmt or a CXXTryStmt.\n  SourceLocation getBodyRBrace() const;\n\n  // global temp stats (until we have a per-module visitor)\n  static void add(Kind k);\n  static void EnableStatistics();\n  static void PrintStats();\n\n  /// isTemplateParameter - Determines whether this declaration is a\n  /// template parameter.\n  bool isTemplateParameter() const;\n\n  /// isTemplateParameter - Determines whether this declaration is a\n  /// template parameter pack.\n  bool isTemplateParameterPack() const;\n\n  /// Whether this declaration is a parameter pack.\n  bool isParameterPack() const;\n\n  /// returns true if this declaration is a template\n  bool isTemplateDecl() const;\n\n  /// Whether this declaration is a function or function template.\n  bool isFunctionOrFunctionTemplate() const {\n    return (DeclKind >= Decl::firstFunction &&\n            DeclKind <= Decl::lastFunction) ||\n           DeclKind == FunctionTemplate;\n  }\n\n  /// If this is a declaration that describes some template, this\n  /// method returns that template declaration.\n  ///\n  /// Note that this returns nullptr for partial specializations, because they\n  /// are not modeled as TemplateDecls. Use getDescribedTemplateParams to handle\n  /// those cases.\n  TemplateDecl *getDescribedTemplate() const;\n\n  /// If this is a declaration that describes some template or partial\n  /// specialization, this returns the corresponding template parameter list.\n  const TemplateParameterList *getDescribedTemplateParams() const;\n\n  /// Returns the function itself, or the templated function if this is a\n  /// function template.\n  FunctionDecl *getAsFunction() LLVM_READONLY;\n\n  const FunctionDecl *getAsFunction() const {\n    return const_cast<Decl *>(this)->getAsFunction();\n  }\n\n  /// Changes the namespace of this declaration to reflect that it's\n  /// a function-local extern declaration.\n  ///\n  /// These declarations appear in the lexical context of the extern\n  /// declaration, but in the semantic context of the enclosing namespace\n  /// scope.\n  void setLocalExternDecl() {\n    Decl *Prev = getPreviousDecl();\n    IdentifierNamespace &= ~IDNS_Ordinary;\n\n    // It's OK for the declaration to still have the \"invisible friend\" flag or\n    // the \"conflicts with tag declarations in this scope\" flag for the outer\n    // scope.\n    assert((IdentifierNamespace & ~(IDNS_OrdinaryFriend | IDNS_Tag)) == 0 &&\n           \"namespace is not ordinary\");\n\n    IdentifierNamespace |= IDNS_LocalExtern;\n    if (Prev && Prev->getIdentifierNamespace() & IDNS_Ordinary)\n      IdentifierNamespace |= IDNS_Ordinary;\n  }\n\n  /// Determine whether this is a block-scope declaration with linkage.\n  /// This will either be a local variable declaration declared 'extern', or a\n  /// local function declaration.\n  bool isLocalExternDecl() {\n    return IdentifierNamespace & IDNS_LocalExtern;\n  }\n\n  /// Changes the namespace of this declaration to reflect that it's\n  /// the object of a friend declaration.\n  ///\n  /// These declarations appear in the lexical context of the friending\n  /// class, but in the semantic context of the actual entity.  This property\n  /// applies only to a specific decl object;  other redeclarations of the\n  /// same entity may not (and probably don't) share this property.\n  void setObjectOfFriendDecl(bool PerformFriendInjection = false) {\n    unsigned OldNS = IdentifierNamespace;\n    assert((OldNS & (IDNS_Tag | IDNS_Ordinary |\n                     IDNS_TagFriend | IDNS_OrdinaryFriend |\n                     IDNS_LocalExtern | IDNS_NonMemberOperator)) &&\n           \"namespace includes neither ordinary nor tag\");\n    assert(!(OldNS & ~(IDNS_Tag | IDNS_Ordinary | IDNS_Type |\n                       IDNS_TagFriend | IDNS_OrdinaryFriend |\n                       IDNS_LocalExtern | IDNS_NonMemberOperator)) &&\n           \"namespace includes other than ordinary or tag\");\n\n    Decl *Prev = getPreviousDecl();\n    IdentifierNamespace &= ~(IDNS_Ordinary | IDNS_Tag | IDNS_Type);\n\n    if (OldNS & (IDNS_Tag | IDNS_TagFriend)) {\n      IdentifierNamespace |= IDNS_TagFriend;\n      if (PerformFriendInjection ||\n          (Prev && Prev->getIdentifierNamespace() & IDNS_Tag))\n        IdentifierNamespace |= IDNS_Tag | IDNS_Type;\n    }\n\n    if (OldNS & (IDNS_Ordinary | IDNS_OrdinaryFriend |\n                 IDNS_LocalExtern | IDNS_NonMemberOperator)) {\n      IdentifierNamespace |= IDNS_OrdinaryFriend;\n      if (PerformFriendInjection ||\n          (Prev && Prev->getIdentifierNamespace() & IDNS_Ordinary))\n        IdentifierNamespace |= IDNS_Ordinary;\n    }\n  }\n\n  enum FriendObjectKind {\n    FOK_None,      ///< Not a friend object.\n    FOK_Declared,  ///< A friend of a previously-declared entity.\n    FOK_Undeclared ///< A friend of a previously-undeclared entity.\n  };\n\n  /// Determines whether this declaration is the object of a\n  /// friend declaration and, if so, what kind.\n  ///\n  /// There is currently no direct way to find the associated FriendDecl.\n  FriendObjectKind getFriendObjectKind() const {\n    unsigned mask =\n        (IdentifierNamespace & (IDNS_TagFriend | IDNS_OrdinaryFriend));\n    if (!mask) return FOK_None;\n    return (IdentifierNamespace & (IDNS_Tag | IDNS_Ordinary) ? FOK_Declared\n                                                             : FOK_Undeclared);\n  }\n\n  /// Specifies that this declaration is a C++ overloaded non-member.\n  void setNonMemberOperator() {\n    assert(getKind() == Function || getKind() == FunctionTemplate);\n    assert((IdentifierNamespace & IDNS_Ordinary) &&\n           \"visible non-member operators should be in ordinary namespace\");\n    IdentifierNamespace |= IDNS_NonMemberOperator;\n  }\n\n  static bool classofKind(Kind K) { return true; }\n  static DeclContext *castToDeclContext(const Decl *);\n  static Decl *castFromDeclContext(const DeclContext *);\n\n  void print(raw_ostream &Out, unsigned Indentation = 0,\n             bool PrintInstantiation = false) const;\n  void print(raw_ostream &Out, const PrintingPolicy &Policy,\n             unsigned Indentation = 0, bool PrintInstantiation = false) const;\n  static void printGroup(Decl** Begin, unsigned NumDecls,\n                         raw_ostream &Out, const PrintingPolicy &Policy,\n                         unsigned Indentation = 0);\n\n  // Debuggers don't usually respect default arguments.\n  void dump() const;\n\n  // Same as dump(), but forces color printing.\n  void dumpColor() const;\n\n  void dump(raw_ostream &Out, bool Deserialize = false,\n            ASTDumpOutputFormat OutputFormat = ADOF_Default) const;\n\n  /// \\return Unique reproducible object identifier\n  int64_t getID() const;\n\n  /// Looks through the Decl's underlying type to extract a FunctionType\n  /// when possible. Will return null if the type underlying the Decl does not\n  /// have a FunctionType.\n  const FunctionType *getFunctionType(bool BlocksToo = true) const;\n\nprivate:\n  void setAttrsImpl(const AttrVec& Attrs, ASTContext &Ctx);\n  void setDeclContextsImpl(DeclContext *SemaDC, DeclContext *LexicalDC,\n                           ASTContext &Ctx);\n\nprotected:\n  ASTMutationListener *getASTMutationListener() const;\n};\n\n/// Determine whether two declarations declare the same entity.\ninline bool declaresSameEntity(const Decl *D1, const Decl *D2) {\n  if (!D1 || !D2)\n    return false;\n\n  if (D1 == D2)\n    return true;\n\n  return D1->getCanonicalDecl() == D2->getCanonicalDecl();\n}\n\n/// PrettyStackTraceDecl - If a crash occurs, indicate that it happened when\n/// doing something to a specific decl.\nclass PrettyStackTraceDecl : public llvm::PrettyStackTraceEntry {\n  const Decl *TheDecl;\n  SourceLocation Loc;\n  SourceManager &SM;\n  const char *Message;\n\npublic:\n  PrettyStackTraceDecl(const Decl *theDecl, SourceLocation L,\n                       SourceManager &sm, const char *Msg)\n      : TheDecl(theDecl), Loc(L), SM(sm), Message(Msg) {}\n\n  void print(raw_ostream &OS) const override;\n};\n\n/// The results of name lookup within a DeclContext. This is either a\n/// single result (with no stable storage) or a collection of results (with\n/// stable storage provided by the lookup table).\nclass DeclContextLookupResult {\n  using ResultTy = ArrayRef<NamedDecl *>;\n\n  ResultTy Result;\n\n  // If there is only one lookup result, it would be invalidated by\n  // reallocations of the name table, so store it separately.\n  NamedDecl *Single = nullptr;\n\n  static NamedDecl *const SingleElementDummyList;\n\npublic:\n  DeclContextLookupResult() = default;\n  DeclContextLookupResult(ArrayRef<NamedDecl *> Result)\n      : Result(Result) {}\n  DeclContextLookupResult(NamedDecl *Single)\n      : Result(SingleElementDummyList), Single(Single) {}\n\n  class iterator;\n\n  using IteratorBase =\n      llvm::iterator_adaptor_base<iterator, ResultTy::iterator,\n                                  std::random_access_iterator_tag, NamedDecl *>;\n\n  class iterator : public IteratorBase {\n    value_type SingleElement;\n\n  public:\n    explicit iterator(pointer Pos, value_type Single = nullptr)\n        : IteratorBase(Pos), SingleElement(Single) {}\n\n    reference operator*() const {\n      return SingleElement ? SingleElement : IteratorBase::operator*();\n    }\n  };\n\n  using const_iterator = iterator;\n  using pointer = iterator::pointer;\n  using reference = iterator::reference;\n\n  iterator begin() const { return iterator(Result.begin(), Single); }\n  iterator end() const { return iterator(Result.end(), Single); }\n\n  bool empty() const { return Result.empty(); }\n  pointer data() const { return Single ? &Single : Result.data(); }\n  size_t size() const { return Single ? 1 : Result.size(); }\n  reference front() const { return Single ? Single : Result.front(); }\n  reference back() const { return Single ? Single : Result.back(); }\n  reference operator[](size_t N) const { return Single ? Single : Result[N]; }\n\n  // FIXME: Remove this from the interface\n  DeclContextLookupResult slice(size_t N) const {\n    DeclContextLookupResult Sliced = Result.slice(N);\n    Sliced.Single = Single;\n    return Sliced;\n  }\n};\n\n/// DeclContext - This is used only as base class of specific decl types that\n/// can act as declaration contexts. These decls are (only the top classes\n/// that directly derive from DeclContext are mentioned, not their subclasses):\n///\n///   TranslationUnitDecl\n///   ExternCContext\n///   NamespaceDecl\n///   TagDecl\n///   OMPDeclareReductionDecl\n///   OMPDeclareMapperDecl\n///   FunctionDecl\n///   ObjCMethodDecl\n///   ObjCContainerDecl\n///   LinkageSpecDecl\n///   ExportDecl\n///   BlockDecl\n///   CapturedDecl\nclass DeclContext {\n  /// For makeDeclVisibleInContextImpl\n  friend class ASTDeclReader;\n  /// For reconcileExternalVisibleStorage, CreateStoredDeclsMap,\n  /// hasNeedToReconcileExternalVisibleStorage\n  friend class ExternalASTSource;\n  /// For CreateStoredDeclsMap\n  friend class DependentDiagnostic;\n  /// For hasNeedToReconcileExternalVisibleStorage,\n  /// hasLazyLocalLexicalLookups, hasLazyExternalLexicalLookups\n  friend class ASTWriter;\n\n  // We use uint64_t in the bit-fields below since some bit-fields\n  // cross the unsigned boundary and this breaks the packing.\n\n  /// Stores the bits used by DeclContext.\n  /// If modified NumDeclContextBit, the ctor of DeclContext and the accessor\n  /// methods in DeclContext should be updated appropriately.\n  class DeclContextBitfields {\n    friend class DeclContext;\n    /// DeclKind - This indicates which class this is.\n    uint64_t DeclKind : 7;\n\n    /// Whether this declaration context also has some external\n    /// storage that contains additional declarations that are lexically\n    /// part of this context.\n    mutable uint64_t ExternalLexicalStorage : 1;\n\n    /// Whether this declaration context also has some external\n    /// storage that contains additional declarations that are visible\n    /// in this context.\n    mutable uint64_t ExternalVisibleStorage : 1;\n\n    /// Whether this declaration context has had externally visible\n    /// storage added since the last lookup. In this case, \\c LookupPtr's\n    /// invariant may not hold and needs to be fixed before we perform\n    /// another lookup.\n    mutable uint64_t NeedToReconcileExternalVisibleStorage : 1;\n\n    /// If \\c true, this context may have local lexical declarations\n    /// that are missing from the lookup table.\n    mutable uint64_t HasLazyLocalLexicalLookups : 1;\n\n    /// If \\c true, the external source may have lexical declarations\n    /// that are missing from the lookup table.\n    mutable uint64_t HasLazyExternalLexicalLookups : 1;\n\n    /// If \\c true, lookups should only return identifier from\n    /// DeclContext scope (for example TranslationUnit). Used in\n    /// LookupQualifiedName()\n    mutable uint64_t UseQualifiedLookup : 1;\n  };\n\n  /// Number of bits in DeclContextBitfields.\n  enum { NumDeclContextBits = 13 };\n\n  /// Stores the bits used by TagDecl.\n  /// If modified NumTagDeclBits and the accessor\n  /// methods in TagDecl should be updated appropriately.\n  class TagDeclBitfields {\n    friend class TagDecl;\n    /// For the bits in DeclContextBitfields\n    uint64_t : NumDeclContextBits;\n\n    /// The TagKind enum.\n    uint64_t TagDeclKind : 3;\n\n    /// True if this is a definition (\"struct foo {};\"), false if it is a\n    /// declaration (\"struct foo;\").  It is not considered a definition\n    /// until the definition has been fully processed.\n    uint64_t IsCompleteDefinition : 1;\n\n    /// True if this is currently being defined.\n    uint64_t IsBeingDefined : 1;\n\n    /// True if this tag declaration is \"embedded\" (i.e., defined or declared\n    /// for the very first time) in the syntax of a declarator.\n    uint64_t IsEmbeddedInDeclarator : 1;\n\n    /// True if this tag is free standing, e.g. \"struct foo;\".\n    uint64_t IsFreeStanding : 1;\n\n    /// Indicates whether it is possible for declarations of this kind\n    /// to have an out-of-date definition.\n    ///\n    /// This option is only enabled when modules are enabled.\n    uint64_t MayHaveOutOfDateDef : 1;\n\n    /// Has the full definition of this type been required by a use somewhere in\n    /// the TU.\n    uint64_t IsCompleteDefinitionRequired : 1;\n  };\n\n  /// Number of non-inherited bits in TagDeclBitfields.\n  enum { NumTagDeclBits = 9 };\n\n  /// Stores the bits used by EnumDecl.\n  /// If modified NumEnumDeclBit and the accessor\n  /// methods in EnumDecl should be updated appropriately.\n  class EnumDeclBitfields {\n    friend class EnumDecl;\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n    /// For the bits in TagDeclBitfields.\n    uint64_t : NumTagDeclBits;\n\n    /// Width in bits required to store all the non-negative\n    /// enumerators of this enum.\n    uint64_t NumPositiveBits : 8;\n\n    /// Width in bits required to store all the negative\n    /// enumerators of this enum.\n    uint64_t NumNegativeBits : 8;\n\n    /// True if this tag declaration is a scoped enumeration. Only\n    /// possible in C++11 mode.\n    uint64_t IsScoped : 1;\n\n    /// If this tag declaration is a scoped enum,\n    /// then this is true if the scoped enum was declared using the class\n    /// tag, false if it was declared with the struct tag. No meaning is\n    /// associated if this tag declaration is not a scoped enum.\n    uint64_t IsScopedUsingClassTag : 1;\n\n    /// True if this is an enumeration with fixed underlying type. Only\n    /// possible in C++11, Microsoft extensions, or Objective C mode.\n    uint64_t IsFixed : 1;\n\n    /// True if a valid hash is stored in ODRHash.\n    uint64_t HasODRHash : 1;\n  };\n\n  /// Number of non-inherited bits in EnumDeclBitfields.\n  enum { NumEnumDeclBits = 20 };\n\n  /// Stores the bits used by RecordDecl.\n  /// If modified NumRecordDeclBits and the accessor\n  /// methods in RecordDecl should be updated appropriately.\n  class RecordDeclBitfields {\n    friend class RecordDecl;\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n    /// For the bits in TagDeclBitfields.\n    uint64_t : NumTagDeclBits;\n\n    /// This is true if this struct ends with a flexible\n    /// array member (e.g. int X[]) or if this union contains a struct that does.\n    /// If so, this cannot be contained in arrays or other structs as a member.\n    uint64_t HasFlexibleArrayMember : 1;\n\n    /// Whether this is the type of an anonymous struct or union.\n    uint64_t AnonymousStructOrUnion : 1;\n\n    /// This is true if this struct has at least one member\n    /// containing an Objective-C object pointer type.\n    uint64_t HasObjectMember : 1;\n\n    /// This is true if struct has at least one member of\n    /// 'volatile' type.\n    uint64_t HasVolatileMember : 1;\n\n    /// Whether the field declarations of this record have been loaded\n    /// from external storage. To avoid unnecessary deserialization of\n    /// methods/nested types we allow deserialization of just the fields\n    /// when needed.\n    mutable uint64_t LoadedFieldsFromExternalStorage : 1;\n\n    /// Basic properties of non-trivial C structs.\n    uint64_t NonTrivialToPrimitiveDefaultInitialize : 1;\n    uint64_t NonTrivialToPrimitiveCopy : 1;\n    uint64_t NonTrivialToPrimitiveDestroy : 1;\n\n    /// The following bits indicate whether this is or contains a C union that\n    /// is non-trivial to default-initialize, destruct, or copy. These bits\n    /// imply the associated basic non-triviality predicates declared above.\n    uint64_t HasNonTrivialToPrimitiveDefaultInitializeCUnion : 1;\n    uint64_t HasNonTrivialToPrimitiveDestructCUnion : 1;\n    uint64_t HasNonTrivialToPrimitiveCopyCUnion : 1;\n\n    /// Indicates whether this struct is destroyed in the callee.\n    uint64_t ParamDestroyedInCallee : 1;\n\n    /// Represents the way this type is passed to a function.\n    uint64_t ArgPassingRestrictions : 2;\n  };\n\n  /// Number of non-inherited bits in RecordDeclBitfields.\n  enum { NumRecordDeclBits = 14 };\n\n  /// Stores the bits used by OMPDeclareReductionDecl.\n  /// If modified NumOMPDeclareReductionDeclBits and the accessor\n  /// methods in OMPDeclareReductionDecl should be updated appropriately.\n  class OMPDeclareReductionDeclBitfields {\n    friend class OMPDeclareReductionDecl;\n    /// For the bits in DeclContextBitfields\n    uint64_t : NumDeclContextBits;\n\n    /// Kind of initializer,\n    /// function call or omp_priv<init_expr> initializtion.\n    uint64_t InitializerKind : 2;\n  };\n\n  /// Number of non-inherited bits in OMPDeclareReductionDeclBitfields.\n  enum { NumOMPDeclareReductionDeclBits = 2 };\n\n  /// Stores the bits used by FunctionDecl.\n  /// If modified NumFunctionDeclBits and the accessor\n  /// methods in FunctionDecl and CXXDeductionGuideDecl\n  /// (for IsCopyDeductionCandidate) should be updated appropriately.\n  class FunctionDeclBitfields {\n    friend class FunctionDecl;\n    /// For IsCopyDeductionCandidate\n    friend class CXXDeductionGuideDecl;\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n\n    uint64_t SClass : 3;\n    uint64_t IsInline : 1;\n    uint64_t IsInlineSpecified : 1;\n\n    uint64_t IsVirtualAsWritten : 1;\n    uint64_t IsPure : 1;\n    uint64_t HasInheritedPrototype : 1;\n    uint64_t HasWrittenPrototype : 1;\n    uint64_t IsDeleted : 1;\n    /// Used by CXXMethodDecl\n    uint64_t IsTrivial : 1;\n\n    /// This flag indicates whether this function is trivial for the purpose of\n    /// calls. This is meaningful only when this function is a copy/move\n    /// constructor or a destructor.\n    uint64_t IsTrivialForCall : 1;\n\n    uint64_t IsDefaulted : 1;\n    uint64_t IsExplicitlyDefaulted : 1;\n    uint64_t HasDefaultedFunctionInfo : 1;\n    uint64_t HasImplicitReturnZero : 1;\n    uint64_t IsLateTemplateParsed : 1;\n\n    /// Kind of contexpr specifier as defined by ConstexprSpecKind.\n    uint64_t ConstexprKind : 2;\n    uint64_t InstantiationIsPending : 1;\n\n    /// Indicates if the function uses __try.\n    uint64_t UsesSEHTry : 1;\n\n    /// Indicates if the function was a definition\n    /// but its body was skipped.\n    uint64_t HasSkippedBody : 1;\n\n    /// Indicates if the function declaration will\n    /// have a body, once we're done parsing it.\n    uint64_t WillHaveBody : 1;\n\n    /// Indicates that this function is a multiversioned\n    /// function using attribute 'target'.\n    uint64_t IsMultiVersion : 1;\n\n    /// [C++17] Only used by CXXDeductionGuideDecl. Indicates that\n    /// the Deduction Guide is the implicitly generated 'copy\n    /// deduction candidate' (is used during overload resolution).\n    uint64_t IsCopyDeductionCandidate : 1;\n\n    /// Store the ODRHash after first calculation.\n    uint64_t HasODRHash : 1;\n\n    /// Indicates if the function uses Floating Point Constrained Intrinsics\n    uint64_t UsesFPIntrin : 1;\n  };\n\n  /// Number of non-inherited bits in FunctionDeclBitfields.\n  enum { NumFunctionDeclBits = 27 };\n\n  /// Stores the bits used by CXXConstructorDecl. If modified\n  /// NumCXXConstructorDeclBits and the accessor\n  /// methods in CXXConstructorDecl should be updated appropriately.\n  class CXXConstructorDeclBitfields {\n    friend class CXXConstructorDecl;\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n    /// For the bits in FunctionDeclBitfields.\n    uint64_t : NumFunctionDeclBits;\n\n    /// 24 bits to fit in the remaining available space.\n    /// Note that this makes CXXConstructorDeclBitfields take\n    /// exactly 64 bits and thus the width of NumCtorInitializers\n    /// will need to be shrunk if some bit is added to NumDeclContextBitfields,\n    /// NumFunctionDeclBitfields or CXXConstructorDeclBitfields.\n    uint64_t NumCtorInitializers : 21;\n    uint64_t IsInheritingConstructor : 1;\n\n    /// Whether this constructor has a trail-allocated explicit specifier.\n    uint64_t HasTrailingExplicitSpecifier : 1;\n    /// If this constructor does't have a trail-allocated explicit specifier.\n    /// Whether this constructor is explicit specified.\n    uint64_t IsSimpleExplicit : 1;\n  };\n\n  /// Number of non-inherited bits in CXXConstructorDeclBitfields.\n  enum {\n    NumCXXConstructorDeclBits = 64 - NumDeclContextBits - NumFunctionDeclBits\n  };\n\n  /// Stores the bits used by ObjCMethodDecl.\n  /// If modified NumObjCMethodDeclBits and the accessor\n  /// methods in ObjCMethodDecl should be updated appropriately.\n  class ObjCMethodDeclBitfields {\n    friend class ObjCMethodDecl;\n\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n\n    /// The conventional meaning of this method; an ObjCMethodFamily.\n    /// This is not serialized; instead, it is computed on demand and\n    /// cached.\n    mutable uint64_t Family : ObjCMethodFamilyBitWidth;\n\n    /// instance (true) or class (false) method.\n    uint64_t IsInstance : 1;\n    uint64_t IsVariadic : 1;\n\n    /// True if this method is the getter or setter for an explicit property.\n    uint64_t IsPropertyAccessor : 1;\n\n    /// True if this method is a synthesized property accessor stub.\n    uint64_t IsSynthesizedAccessorStub : 1;\n\n    /// Method has a definition.\n    uint64_t IsDefined : 1;\n\n    /// Method redeclaration in the same interface.\n    uint64_t IsRedeclaration : 1;\n\n    /// Is redeclared in the same interface.\n    mutable uint64_t HasRedeclaration : 1;\n\n    /// \\@required/\\@optional\n    uint64_t DeclImplementation : 2;\n\n    /// in, inout, etc.\n    uint64_t objcDeclQualifier : 7;\n\n    /// Indicates whether this method has a related result type.\n    uint64_t RelatedResultType : 1;\n\n    /// Whether the locations of the selector identifiers are in a\n    /// \"standard\" position, a enum SelectorLocationsKind.\n    uint64_t SelLocsKind : 2;\n\n    /// Whether this method overrides any other in the class hierarchy.\n    ///\n    /// A method is said to override any method in the class's\n    /// base classes, its protocols, or its categories' protocols, that has\n    /// the same selector and is of the same kind (class or instance).\n    /// A method in an implementation is not considered as overriding the same\n    /// method in the interface or its categories.\n    uint64_t IsOverriding : 1;\n\n    /// Indicates if the method was a definition but its body was skipped.\n    uint64_t HasSkippedBody : 1;\n  };\n\n  /// Number of non-inherited bits in ObjCMethodDeclBitfields.\n  enum { NumObjCMethodDeclBits = 24 };\n\n  /// Stores the bits used by ObjCContainerDecl.\n  /// If modified NumObjCContainerDeclBits and the accessor\n  /// methods in ObjCContainerDecl should be updated appropriately.\n  class ObjCContainerDeclBitfields {\n    friend class ObjCContainerDecl;\n    /// For the bits in DeclContextBitfields\n    uint32_t : NumDeclContextBits;\n\n    // Not a bitfield but this saves space.\n    // Note that ObjCContainerDeclBitfields is full.\n    SourceLocation AtStart;\n  };\n\n  /// Number of non-inherited bits in ObjCContainerDeclBitfields.\n  /// Note that here we rely on the fact that SourceLocation is 32 bits\n  /// wide. We check this with the static_assert in the ctor of DeclContext.\n  enum { NumObjCContainerDeclBits = 64 - NumDeclContextBits };\n\n  /// Stores the bits used by LinkageSpecDecl.\n  /// If modified NumLinkageSpecDeclBits and the accessor\n  /// methods in LinkageSpecDecl should be updated appropriately.\n  class LinkageSpecDeclBitfields {\n    friend class LinkageSpecDecl;\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n\n    /// The language for this linkage specification with values\n    /// in the enum LinkageSpecDecl::LanguageIDs.\n    uint64_t Language : 3;\n\n    /// True if this linkage spec has braces.\n    /// This is needed so that hasBraces() returns the correct result while the\n    /// linkage spec body is being parsed.  Once RBraceLoc has been set this is\n    /// not used, so it doesn't need to be serialized.\n    uint64_t HasBraces : 1;\n  };\n\n  /// Number of non-inherited bits in LinkageSpecDeclBitfields.\n  enum { NumLinkageSpecDeclBits = 4 };\n\n  /// Stores the bits used by BlockDecl.\n  /// If modified NumBlockDeclBits and the accessor\n  /// methods in BlockDecl should be updated appropriately.\n  class BlockDeclBitfields {\n    friend class BlockDecl;\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n\n    uint64_t IsVariadic : 1;\n    uint64_t CapturesCXXThis : 1;\n    uint64_t BlockMissingReturnType : 1;\n    uint64_t IsConversionFromLambda : 1;\n\n    /// A bit that indicates this block is passed directly to a function as a\n    /// non-escaping parameter.\n    uint64_t DoesNotEscape : 1;\n\n    /// A bit that indicates whether it's possible to avoid coying this block to\n    /// the heap when it initializes or is assigned to a local variable with\n    /// automatic storage.\n    uint64_t CanAvoidCopyToHeap : 1;\n  };\n\n  /// Number of non-inherited bits in BlockDeclBitfields.\n  enum { NumBlockDeclBits = 5 };\n\n  /// Pointer to the data structure used to lookup declarations\n  /// within this context (or a DependentStoredDeclsMap if this is a\n  /// dependent context). We maintain the invariant that, if the map\n  /// contains an entry for a DeclarationName (and we haven't lazily\n  /// omitted anything), then it contains all relevant entries for that\n  /// name (modulo the hasExternalDecls() flag).\n  mutable StoredDeclsMap *LookupPtr = nullptr;\n\nprotected:\n  /// This anonymous union stores the bits belonging to DeclContext and classes\n  /// deriving from it. The goal is to use otherwise wasted\n  /// space in DeclContext to store data belonging to derived classes.\n  /// The space saved is especially significient when pointers are aligned\n  /// to 8 bytes. In this case due to alignment requirements we have a\n  /// little less than 8 bytes free in DeclContext which we can use.\n  /// We check that none of the classes in this union is larger than\n  /// 8 bytes with static_asserts in the ctor of DeclContext.\n  union {\n    DeclContextBitfields DeclContextBits;\n    TagDeclBitfields TagDeclBits;\n    EnumDeclBitfields EnumDeclBits;\n    RecordDeclBitfields RecordDeclBits;\n    OMPDeclareReductionDeclBitfields OMPDeclareReductionDeclBits;\n    FunctionDeclBitfields FunctionDeclBits;\n    CXXConstructorDeclBitfields CXXConstructorDeclBits;\n    ObjCMethodDeclBitfields ObjCMethodDeclBits;\n    ObjCContainerDeclBitfields ObjCContainerDeclBits;\n    LinkageSpecDeclBitfields LinkageSpecDeclBits;\n    BlockDeclBitfields BlockDeclBits;\n\n    static_assert(sizeof(DeclContextBitfields) <= 8,\n                  \"DeclContextBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(TagDeclBitfields) <= 8,\n                  \"TagDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(EnumDeclBitfields) <= 8,\n                  \"EnumDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(RecordDeclBitfields) <= 8,\n                  \"RecordDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(OMPDeclareReductionDeclBitfields) <= 8,\n                  \"OMPDeclareReductionDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(FunctionDeclBitfields) <= 8,\n                  \"FunctionDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(CXXConstructorDeclBitfields) <= 8,\n                  \"CXXConstructorDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(ObjCMethodDeclBitfields) <= 8,\n                  \"ObjCMethodDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(ObjCContainerDeclBitfields) <= 8,\n                  \"ObjCContainerDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(LinkageSpecDeclBitfields) <= 8,\n                  \"LinkageSpecDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(BlockDeclBitfields) <= 8,\n                  \"BlockDeclBitfields is larger than 8 bytes!\");\n  };\n\n  /// FirstDecl - The first declaration stored within this declaration\n  /// context.\n  mutable Decl *FirstDecl = nullptr;\n\n  /// LastDecl - The last declaration stored within this declaration\n  /// context. FIXME: We could probably cache this value somewhere\n  /// outside of the DeclContext, to reduce the size of DeclContext by\n  /// another pointer.\n  mutable Decl *LastDecl = nullptr;\n\n  /// Build up a chain of declarations.\n  ///\n  /// \\returns the first/last pair of declarations.\n  static std::pair<Decl *, Decl *>\n  BuildDeclChain(ArrayRef<Decl*> Decls, bool FieldsAlreadyLoaded);\n\n  DeclContext(Decl::Kind K);\n\npublic:\n  ~DeclContext();\n\n  Decl::Kind getDeclKind() const {\n    return static_cast<Decl::Kind>(DeclContextBits.DeclKind);\n  }\n\n  const char *getDeclKindName() const;\n\n  /// getParent - Returns the containing DeclContext.\n  DeclContext *getParent() {\n    return cast<Decl>(this)->getDeclContext();\n  }\n  const DeclContext *getParent() const {\n    return const_cast<DeclContext*>(this)->getParent();\n  }\n\n  /// getLexicalParent - Returns the containing lexical DeclContext. May be\n  /// different from getParent, e.g.:\n  ///\n  ///   namespace A {\n  ///      struct S;\n  ///   }\n  ///   struct A::S {}; // getParent() == namespace 'A'\n  ///                   // getLexicalParent() == translation unit\n  ///\n  DeclContext *getLexicalParent() {\n    return cast<Decl>(this)->getLexicalDeclContext();\n  }\n  const DeclContext *getLexicalParent() const {\n    return const_cast<DeclContext*>(this)->getLexicalParent();\n  }\n\n  DeclContext *getLookupParent();\n\n  const DeclContext *getLookupParent() const {\n    return const_cast<DeclContext*>(this)->getLookupParent();\n  }\n\n  ASTContext &getParentASTContext() const {\n    return cast<Decl>(this)->getASTContext();\n  }\n\n  bool isClosure() const { return getDeclKind() == Decl::Block; }\n\n  /// Return this DeclContext if it is a BlockDecl. Otherwise, return the\n  /// innermost enclosing BlockDecl or null if there are no enclosing blocks.\n  const BlockDecl *getInnermostBlockDecl() const;\n\n  bool isObjCContainer() const {\n    switch (getDeclKind()) {\n    case Decl::ObjCCategory:\n    case Decl::ObjCCategoryImpl:\n    case Decl::ObjCImplementation:\n    case Decl::ObjCInterface:\n    case Decl::ObjCProtocol:\n      return true;\n    default:\n      return false;\n    }\n  }\n\n  bool isFunctionOrMethod() const {\n    switch (getDeclKind()) {\n    case Decl::Block:\n    case Decl::Captured:\n    case Decl::ObjCMethod:\n      return true;\n    default:\n      return getDeclKind() >= Decl::firstFunction &&\n             getDeclKind() <= Decl::lastFunction;\n    }\n  }\n\n  /// Test whether the context supports looking up names.\n  bool isLookupContext() const {\n    return !isFunctionOrMethod() && getDeclKind() != Decl::LinkageSpec &&\n           getDeclKind() != Decl::Export;\n  }\n\n  bool isFileContext() const {\n    return getDeclKind() == Decl::TranslationUnit ||\n           getDeclKind() == Decl::Namespace;\n  }\n\n  bool isTranslationUnit() const {\n    return getDeclKind() == Decl::TranslationUnit;\n  }\n\n  bool isRecord() const {\n    return getDeclKind() >= Decl::firstRecord &&\n           getDeclKind() <= Decl::lastRecord;\n  }\n\n  bool isNamespace() const { return getDeclKind() == Decl::Namespace; }\n\n  bool isStdNamespace() const;\n\n  bool isInlineNamespace() const;\n\n  /// Determines whether this context is dependent on a\n  /// template parameter.\n  bool isDependentContext() const;\n\n  /// isTransparentContext - Determines whether this context is a\n  /// \"transparent\" context, meaning that the members declared in this\n  /// context are semantically declared in the nearest enclosing\n  /// non-transparent (opaque) context but are lexically declared in\n  /// this context. For example, consider the enumerators of an\n  /// enumeration type:\n  /// @code\n  /// enum E {\n  ///   Val1\n  /// };\n  /// @endcode\n  /// Here, E is a transparent context, so its enumerator (Val1) will\n  /// appear (semantically) that it is in the same context of E.\n  /// Examples of transparent contexts include: enumerations (except for\n  /// C++0x scoped enums), and C++ linkage specifications.\n  bool isTransparentContext() const;\n\n  /// Determines whether this context or some of its ancestors is a\n  /// linkage specification context that specifies C linkage.\n  bool isExternCContext() const;\n\n  /// Retrieve the nearest enclosing C linkage specification context.\n  const LinkageSpecDecl *getExternCContext() const;\n\n  /// Determines whether this context or some of its ancestors is a\n  /// linkage specification context that specifies C++ linkage.\n  bool isExternCXXContext() const;\n\n  /// Determine whether this declaration context is equivalent\n  /// to the declaration context DC.\n  bool Equals(const DeclContext *DC) const {\n    return DC && this->getPrimaryContext() == DC->getPrimaryContext();\n  }\n\n  /// Determine whether this declaration context encloses the\n  /// declaration context DC.\n  bool Encloses(const DeclContext *DC) const;\n\n  /// Find the nearest non-closure ancestor of this context,\n  /// i.e. the innermost semantic parent of this context which is not\n  /// a closure.  A context may be its own non-closure ancestor.\n  Decl *getNonClosureAncestor();\n  const Decl *getNonClosureAncestor() const {\n    return const_cast<DeclContext*>(this)->getNonClosureAncestor();\n  }\n\n  /// getPrimaryContext - There may be many different\n  /// declarations of the same entity (including forward declarations\n  /// of classes, multiple definitions of namespaces, etc.), each with\n  /// a different set of declarations. This routine returns the\n  /// \"primary\" DeclContext structure, which will contain the\n  /// information needed to perform name lookup into this context.\n  DeclContext *getPrimaryContext();\n  const DeclContext *getPrimaryContext() const {\n    return const_cast<DeclContext*>(this)->getPrimaryContext();\n  }\n\n  /// getRedeclContext - Retrieve the context in which an entity conflicts with\n  /// other entities of the same name, or where it is a redeclaration if the\n  /// two entities are compatible. This skips through transparent contexts.\n  DeclContext *getRedeclContext();\n  const DeclContext *getRedeclContext() const {\n    return const_cast<DeclContext *>(this)->getRedeclContext();\n  }\n\n  /// Retrieve the nearest enclosing namespace context.\n  DeclContext *getEnclosingNamespaceContext();\n  const DeclContext *getEnclosingNamespaceContext() const {\n    return const_cast<DeclContext *>(this)->getEnclosingNamespaceContext();\n  }\n\n  /// Retrieve the outermost lexically enclosing record context.\n  RecordDecl *getOuterLexicalRecordContext();\n  const RecordDecl *getOuterLexicalRecordContext() const {\n    return const_cast<DeclContext *>(this)->getOuterLexicalRecordContext();\n  }\n\n  /// Test if this context is part of the enclosing namespace set of\n  /// the context NS, as defined in C++0x [namespace.def]p9. If either context\n  /// isn't a namespace, this is equivalent to Equals().\n  ///\n  /// The enclosing namespace set of a namespace is the namespace and, if it is\n  /// inline, its enclosing namespace, recursively.\n  bool InEnclosingNamespaceSetOf(const DeclContext *NS) const;\n\n  /// Collects all of the declaration contexts that are semantically\n  /// connected to this declaration context.\n  ///\n  /// For declaration contexts that have multiple semantically connected but\n  /// syntactically distinct contexts, such as C++ namespaces, this routine\n  /// retrieves the complete set of such declaration contexts in source order.\n  /// For example, given:\n  ///\n  /// \\code\n  /// namespace N {\n  ///   int x;\n  /// }\n  /// namespace N {\n  ///   int y;\n  /// }\n  /// \\endcode\n  ///\n  /// The \\c Contexts parameter will contain both definitions of N.\n  ///\n  /// \\param Contexts Will be cleared and set to the set of declaration\n  /// contexts that are semanticaly connected to this declaration context,\n  /// in source order, including this context (which may be the only result,\n  /// for non-namespace contexts).\n  void collectAllContexts(SmallVectorImpl<DeclContext *> &Contexts);\n\n  /// decl_iterator - Iterates through the declarations stored\n  /// within this context.\n  class decl_iterator {\n    /// Current - The current declaration.\n    Decl *Current = nullptr;\n\n  public:\n    using value_type = Decl *;\n    using reference = const value_type &;\n    using pointer = const value_type *;\n    using iterator_category = std::forward_iterator_tag;\n    using difference_type = std::ptrdiff_t;\n\n    decl_iterator() = default;\n    explicit decl_iterator(Decl *C) : Current(C) {}\n\n    reference operator*() const { return Current; }\n\n    // This doesn't meet the iterator requirements, but it's convenient\n    value_type operator->() const { return Current; }\n\n    decl_iterator& operator++() {\n      Current = Current->getNextDeclInContext();\n      return *this;\n    }\n\n    decl_iterator operator++(int) {\n      decl_iterator tmp(*this);\n      ++(*this);\n      return tmp;\n    }\n\n    friend bool operator==(decl_iterator x, decl_iterator y) {\n      return x.Current == y.Current;\n    }\n\n    friend bool operator!=(decl_iterator x, decl_iterator y) {\n      return x.Current != y.Current;\n    }\n  };\n\n  using decl_range = llvm::iterator_range<decl_iterator>;\n\n  /// decls_begin/decls_end - Iterate over the declarations stored in\n  /// this context.\n  decl_range decls() const { return decl_range(decls_begin(), decls_end()); }\n  decl_iterator decls_begin() const;\n  decl_iterator decls_end() const { return decl_iterator(); }\n  bool decls_empty() const;\n\n  /// noload_decls_begin/end - Iterate over the declarations stored in this\n  /// context that are currently loaded; don't attempt to retrieve anything\n  /// from an external source.\n  decl_range noload_decls() const {\n    return decl_range(noload_decls_begin(), noload_decls_end());\n  }\n  decl_iterator noload_decls_begin() const { return decl_iterator(FirstDecl); }\n  decl_iterator noload_decls_end() const { return decl_iterator(); }\n\n  /// specific_decl_iterator - Iterates over a subrange of\n  /// declarations stored in a DeclContext, providing only those that\n  /// are of type SpecificDecl (or a class derived from it). This\n  /// iterator is used, for example, to provide iteration over just\n  /// the fields within a RecordDecl (with SpecificDecl = FieldDecl).\n  template<typename SpecificDecl>\n  class specific_decl_iterator {\n    /// Current - The current, underlying declaration iterator, which\n    /// will either be NULL or will point to a declaration of\n    /// type SpecificDecl.\n    DeclContext::decl_iterator Current;\n\n    /// SkipToNextDecl - Advances the current position up to the next\n    /// declaration of type SpecificDecl that also meets the criteria\n    /// required by Acceptable.\n    void SkipToNextDecl() {\n      while (*Current && !isa<SpecificDecl>(*Current))\n        ++Current;\n    }\n\n  public:\n    using value_type = SpecificDecl *;\n    // TODO: Add reference and pointer types (with some appropriate proxy type)\n    // if we ever have a need for them.\n    using reference = void;\n    using pointer = void;\n    using difference_type =\n        std::iterator_traits<DeclContext::decl_iterator>::difference_type;\n    using iterator_category = std::forward_iterator_tag;\n\n    specific_decl_iterator() = default;\n\n    /// specific_decl_iterator - Construct a new iterator over a\n    /// subset of the declarations the range [C,\n    /// end-of-declarations). If A is non-NULL, it is a pointer to a\n    /// member function of SpecificDecl that should return true for\n    /// all of the SpecificDecl instances that will be in the subset\n    /// of iterators. For example, if you want Objective-C instance\n    /// methods, SpecificDecl will be ObjCMethodDecl and A will be\n    /// &ObjCMethodDecl::isInstanceMethod.\n    explicit specific_decl_iterator(DeclContext::decl_iterator C) : Current(C) {\n      SkipToNextDecl();\n    }\n\n    value_type operator*() const { return cast<SpecificDecl>(*Current); }\n\n    // This doesn't meet the iterator requirements, but it's convenient\n    value_type operator->() const { return **this; }\n\n    specific_decl_iterator& operator++() {\n      ++Current;\n      SkipToNextDecl();\n      return *this;\n    }\n\n    specific_decl_iterator operator++(int) {\n      specific_decl_iterator tmp(*this);\n      ++(*this);\n      return tmp;\n    }\n\n    friend bool operator==(const specific_decl_iterator& x,\n                           const specific_decl_iterator& y) {\n      return x.Current == y.Current;\n    }\n\n    friend bool operator!=(const specific_decl_iterator& x,\n                           const specific_decl_iterator& y) {\n      return x.Current != y.Current;\n    }\n  };\n\n  /// Iterates over a filtered subrange of declarations stored\n  /// in a DeclContext.\n  ///\n  /// This iterator visits only those declarations that are of type\n  /// SpecificDecl (or a class derived from it) and that meet some\n  /// additional run-time criteria. This iterator is used, for\n  /// example, to provide access to the instance methods within an\n  /// Objective-C interface (with SpecificDecl = ObjCMethodDecl and\n  /// Acceptable = ObjCMethodDecl::isInstanceMethod).\n  template<typename SpecificDecl, bool (SpecificDecl::*Acceptable)() const>\n  class filtered_decl_iterator {\n    /// Current - The current, underlying declaration iterator, which\n    /// will either be NULL or will point to a declaration of\n    /// type SpecificDecl.\n    DeclContext::decl_iterator Current;\n\n    /// SkipToNextDecl - Advances the current position up to the next\n    /// declaration of type SpecificDecl that also meets the criteria\n    /// required by Acceptable.\n    void SkipToNextDecl() {\n      while (*Current &&\n             (!isa<SpecificDecl>(*Current) ||\n              (Acceptable && !(cast<SpecificDecl>(*Current)->*Acceptable)())))\n        ++Current;\n    }\n\n  public:\n    using value_type = SpecificDecl *;\n    // TODO: Add reference and pointer types (with some appropriate proxy type)\n    // if we ever have a need for them.\n    using reference = void;\n    using pointer = void;\n    using difference_type =\n        std::iterator_traits<DeclContext::decl_iterator>::difference_type;\n    using iterator_category = std::forward_iterator_tag;\n\n    filtered_decl_iterator() = default;\n\n    /// filtered_decl_iterator - Construct a new iterator over a\n    /// subset of the declarations the range [C,\n    /// end-of-declarations). If A is non-NULL, it is a pointer to a\n    /// member function of SpecificDecl that should return true for\n    /// all of the SpecificDecl instances that will be in the subset\n    /// of iterators. For example, if you want Objective-C instance\n    /// methods, SpecificDecl will be ObjCMethodDecl and A will be\n    /// &ObjCMethodDecl::isInstanceMethod.\n    explicit filtered_decl_iterator(DeclContext::decl_iterator C) : Current(C) {\n      SkipToNextDecl();\n    }\n\n    value_type operator*() const { return cast<SpecificDecl>(*Current); }\n    value_type operator->() const { return cast<SpecificDecl>(*Current); }\n\n    filtered_decl_iterator& operator++() {\n      ++Current;\n      SkipToNextDecl();\n      return *this;\n    }\n\n    filtered_decl_iterator operator++(int) {\n      filtered_decl_iterator tmp(*this);\n      ++(*this);\n      return tmp;\n    }\n\n    friend bool operator==(const filtered_decl_iterator& x,\n                           const filtered_decl_iterator& y) {\n      return x.Current == y.Current;\n    }\n\n    friend bool operator!=(const filtered_decl_iterator& x,\n                           const filtered_decl_iterator& y) {\n      return x.Current != y.Current;\n    }\n  };\n\n  /// Add the declaration D into this context.\n  ///\n  /// This routine should be invoked when the declaration D has first\n  /// been declared, to place D into the context where it was\n  /// (lexically) defined. Every declaration must be added to one\n  /// (and only one!) context, where it can be visited via\n  /// [decls_begin(), decls_end()). Once a declaration has been added\n  /// to its lexical context, the corresponding DeclContext owns the\n  /// declaration.\n  ///\n  /// If D is also a NamedDecl, it will be made visible within its\n  /// semantic context via makeDeclVisibleInContext.\n  void addDecl(Decl *D);\n\n  /// Add the declaration D into this context, but suppress\n  /// searches for external declarations with the same name.\n  ///\n  /// Although analogous in function to addDecl, this removes an\n  /// important check.  This is only useful if the Decl is being\n  /// added in response to an external search; in all other cases,\n  /// addDecl() is the right function to use.\n  /// See the ASTImporter for use cases.\n  void addDeclInternal(Decl *D);\n\n  /// Add the declaration D to this context without modifying\n  /// any lookup tables.\n  ///\n  /// This is useful for some operations in dependent contexts where\n  /// the semantic context might not be dependent;  this basically\n  /// only happens with friends.\n  void addHiddenDecl(Decl *D);\n\n  /// Removes a declaration from this context.\n  void removeDecl(Decl *D);\n\n  /// Checks whether a declaration is in this context.\n  bool containsDecl(Decl *D) const;\n\n  /// Checks whether a declaration is in this context.\n  /// This also loads the Decls from the external source before the check.\n  bool containsDeclAndLoad(Decl *D) const;\n\n  using lookup_result = DeclContextLookupResult;\n  using lookup_iterator = lookup_result::iterator;\n\n  /// lookup - Find the declarations (if any) with the given Name in\n  /// this context. Returns a range of iterators that contains all of\n  /// the declarations with this name, with object, function, member,\n  /// and enumerator names preceding any tag name. Note that this\n  /// routine will not look into parent contexts.\n  lookup_result lookup(DeclarationName Name) const;\n\n  /// Find the declarations with the given name that are visible\n  /// within this context; don't attempt to retrieve anything from an\n  /// external source.\n  lookup_result noload_lookup(DeclarationName Name);\n\n  /// A simplistic name lookup mechanism that performs name lookup\n  /// into this declaration context without consulting the external source.\n  ///\n  /// This function should almost never be used, because it subverts the\n  /// usual relationship between a DeclContext and the external source.\n  /// See the ASTImporter for the (few, but important) use cases.\n  ///\n  /// FIXME: This is very inefficient; replace uses of it with uses of\n  /// noload_lookup.\n  void localUncachedLookup(DeclarationName Name,\n                           SmallVectorImpl<NamedDecl *> &Results);\n\n  /// Makes a declaration visible within this context.\n  ///\n  /// This routine makes the declaration D visible to name lookup\n  /// within this context and, if this is a transparent context,\n  /// within its parent contexts up to the first enclosing\n  /// non-transparent context. Making a declaration visible within a\n  /// context does not transfer ownership of a declaration, and a\n  /// declaration can be visible in many contexts that aren't its\n  /// lexical context.\n  ///\n  /// If D is a redeclaration of an existing declaration that is\n  /// visible from this context, as determined by\n  /// NamedDecl::declarationReplaces, the previous declaration will be\n  /// replaced with D.\n  void makeDeclVisibleInContext(NamedDecl *D);\n\n  /// all_lookups_iterator - An iterator that provides a view over the results\n  /// of looking up every possible name.\n  class all_lookups_iterator;\n\n  using lookups_range = llvm::iterator_range<all_lookups_iterator>;\n\n  lookups_range lookups() const;\n  // Like lookups(), but avoids loading external declarations.\n  // If PreserveInternalState, avoids building lookup data structures too.\n  lookups_range noload_lookups(bool PreserveInternalState) const;\n\n  /// Iterators over all possible lookups within this context.\n  all_lookups_iterator lookups_begin() const;\n  all_lookups_iterator lookups_end() const;\n\n  /// Iterators over all possible lookups within this context that are\n  /// currently loaded; don't attempt to retrieve anything from an external\n  /// source.\n  all_lookups_iterator noload_lookups_begin() const;\n  all_lookups_iterator noload_lookups_end() const;\n\n  struct udir_iterator;\n\n  using udir_iterator_base =\n      llvm::iterator_adaptor_base<udir_iterator, lookup_iterator,\n                                  std::random_access_iterator_tag,\n                                  UsingDirectiveDecl *>;\n\n  struct udir_iterator : udir_iterator_base {\n    udir_iterator(lookup_iterator I) : udir_iterator_base(I) {}\n\n    UsingDirectiveDecl *operator*() const;\n  };\n\n  using udir_range = llvm::iterator_range<udir_iterator>;\n\n  udir_range using_directives() const;\n\n  // These are all defined in DependentDiagnostic.h.\n  class ddiag_iterator;\n\n  using ddiag_range = llvm::iterator_range<DeclContext::ddiag_iterator>;\n\n  inline ddiag_range ddiags() const;\n\n  // Low-level accessors\n\n  /// Mark that there are external lexical declarations that we need\n  /// to include in our lookup table (and that are not available as external\n  /// visible lookups). These extra lookup results will be found by walking\n  /// the lexical declarations of this context. This should be used only if\n  /// setHasExternalLexicalStorage() has been called on any decl context for\n  /// which this is the primary context.\n  void setMustBuildLookupTable() {\n    assert(this == getPrimaryContext() &&\n           \"should only be called on primary context\");\n    DeclContextBits.HasLazyExternalLexicalLookups = true;\n  }\n\n  /// Retrieve the internal representation of the lookup structure.\n  /// This may omit some names if we are lazily building the structure.\n  StoredDeclsMap *getLookupPtr() const { return LookupPtr; }\n\n  /// Ensure the lookup structure is fully-built and return it.\n  StoredDeclsMap *buildLookup();\n\n  /// Whether this DeclContext has external storage containing\n  /// additional declarations that are lexically in this context.\n  bool hasExternalLexicalStorage() const {\n    return DeclContextBits.ExternalLexicalStorage;\n  }\n\n  /// State whether this DeclContext has external storage for\n  /// declarations lexically in this context.\n  void setHasExternalLexicalStorage(bool ES = true) const {\n    DeclContextBits.ExternalLexicalStorage = ES;\n  }\n\n  /// Whether this DeclContext has external storage containing\n  /// additional declarations that are visible in this context.\n  bool hasExternalVisibleStorage() const {\n    return DeclContextBits.ExternalVisibleStorage;\n  }\n\n  /// State whether this DeclContext has external storage for\n  /// declarations visible in this context.\n  void setHasExternalVisibleStorage(bool ES = true) const {\n    DeclContextBits.ExternalVisibleStorage = ES;\n    if (ES && LookupPtr)\n      DeclContextBits.NeedToReconcileExternalVisibleStorage = true;\n  }\n\n  /// Determine whether the given declaration is stored in the list of\n  /// declarations lexically within this context.\n  bool isDeclInLexicalTraversal(const Decl *D) const {\n    return D && (D->NextInContextAndBits.getPointer() || D == FirstDecl ||\n                 D == LastDecl);\n  }\n\n  bool setUseQualifiedLookup(bool use = true) const {\n    bool old_value = DeclContextBits.UseQualifiedLookup;\n    DeclContextBits.UseQualifiedLookup = use;\n    return old_value;\n  }\n\n  bool shouldUseQualifiedLookup() const {\n    return DeclContextBits.UseQualifiedLookup;\n  }\n\n  static bool classof(const Decl *D);\n  static bool classof(const DeclContext *D) { return true; }\n\n  void dumpDeclContext() const;\n  void dumpLookups() const;\n  void dumpLookups(llvm::raw_ostream &OS, bool DumpDecls = false,\n                   bool Deserialize = false) const;\n\nprivate:\n  /// Whether this declaration context has had externally visible\n  /// storage added since the last lookup. In this case, \\c LookupPtr's\n  /// invariant may not hold and needs to be fixed before we perform\n  /// another lookup.\n  bool hasNeedToReconcileExternalVisibleStorage() const {\n    return DeclContextBits.NeedToReconcileExternalVisibleStorage;\n  }\n\n  /// State that this declaration context has had externally visible\n  /// storage added since the last lookup. In this case, \\c LookupPtr's\n  /// invariant may not hold and needs to be fixed before we perform\n  /// another lookup.\n  void setNeedToReconcileExternalVisibleStorage(bool Need = true) const {\n    DeclContextBits.NeedToReconcileExternalVisibleStorage = Need;\n  }\n\n  /// If \\c true, this context may have local lexical declarations\n  /// that are missing from the lookup table.\n  bool hasLazyLocalLexicalLookups() const {\n    return DeclContextBits.HasLazyLocalLexicalLookups;\n  }\n\n  /// If \\c true, this context may have local lexical declarations\n  /// that are missing from the lookup table.\n  void setHasLazyLocalLexicalLookups(bool HasLLLL = true) const {\n    DeclContextBits.HasLazyLocalLexicalLookups = HasLLLL;\n  }\n\n  /// If \\c true, the external source may have lexical declarations\n  /// that are missing from the lookup table.\n  bool hasLazyExternalLexicalLookups() const {\n    return DeclContextBits.HasLazyExternalLexicalLookups;\n  }\n\n  /// If \\c true, the external source may have lexical declarations\n  /// that are missing from the lookup table.\n  void setHasLazyExternalLexicalLookups(bool HasLELL = true) const {\n    DeclContextBits.HasLazyExternalLexicalLookups = HasLELL;\n  }\n\n  void reconcileExternalVisibleStorage() const;\n  bool LoadLexicalDeclsFromExternalStorage() const;\n\n  /// Makes a declaration visible within this context, but\n  /// suppresses searches for external declarations with the same\n  /// name.\n  ///\n  /// Analogous to makeDeclVisibleInContext, but for the exclusive\n  /// use of addDeclInternal().\n  void makeDeclVisibleInContextInternal(NamedDecl *D);\n\n  StoredDeclsMap *CreateStoredDeclsMap(ASTContext &C) const;\n\n  void loadLazyLocalLexicalLookups();\n  void buildLookupImpl(DeclContext *DCtx, bool Internal);\n  void makeDeclVisibleInContextWithFlags(NamedDecl *D, bool Internal,\n                                         bool Rediscoverable);\n  void makeDeclVisibleInContextImpl(NamedDecl *D, bool Internal);\n};\n\ninline bool Decl::isTemplateParameter() const {\n  return getKind() == TemplateTypeParm || getKind() == NonTypeTemplateParm ||\n         getKind() == TemplateTemplateParm;\n}\n\n// Specialization selected when ToTy is not a known subclass of DeclContext.\ntemplate <class ToTy,\n          bool IsKnownSubtype = ::std::is_base_of<DeclContext, ToTy>::value>\nstruct cast_convert_decl_context {\n  static const ToTy *doit(const DeclContext *Val) {\n    return static_cast<const ToTy*>(Decl::castFromDeclContext(Val));\n  }\n\n  static ToTy *doit(DeclContext *Val) {\n    return static_cast<ToTy*>(Decl::castFromDeclContext(Val));\n  }\n};\n\n// Specialization selected when ToTy is a known subclass of DeclContext.\ntemplate <class ToTy>\nstruct cast_convert_decl_context<ToTy, true> {\n  static const ToTy *doit(const DeclContext *Val) {\n    return static_cast<const ToTy*>(Val);\n  }\n\n  static ToTy *doit(DeclContext *Val) {\n    return static_cast<ToTy*>(Val);\n  }\n};\n\n} // namespace clang\n\nnamespace llvm {\n\n/// isa<T>(DeclContext*)\ntemplate <typename To>\nstruct isa_impl<To, ::clang::DeclContext> {\n  static bool doit(const ::clang::DeclContext &Val) {\n    return To::classofKind(Val.getDeclKind());\n  }\n};\n\n/// cast<T>(DeclContext*)\ntemplate<class ToTy>\nstruct cast_convert_val<ToTy,\n                        const ::clang::DeclContext,const ::clang::DeclContext> {\n  static const ToTy &doit(const ::clang::DeclContext &Val) {\n    return *::clang::cast_convert_decl_context<ToTy>::doit(&Val);\n  }\n};\n\ntemplate<class ToTy>\nstruct cast_convert_val<ToTy, ::clang::DeclContext, ::clang::DeclContext> {\n  static ToTy &doit(::clang::DeclContext &Val) {\n    return *::clang::cast_convert_decl_context<ToTy>::doit(&Val);\n  }\n};\n\ntemplate<class ToTy>\nstruct cast_convert_val<ToTy,\n                     const ::clang::DeclContext*, const ::clang::DeclContext*> {\n  static const ToTy *doit(const ::clang::DeclContext *Val) {\n    return ::clang::cast_convert_decl_context<ToTy>::doit(Val);\n  }\n};\n\ntemplate<class ToTy>\nstruct cast_convert_val<ToTy, ::clang::DeclContext*, ::clang::DeclContext*> {\n  static ToTy *doit(::clang::DeclContext *Val) {\n    return ::clang::cast_convert_decl_context<ToTy>::doit(Val);\n  }\n};\n\n/// Implement cast_convert_val for Decl -> DeclContext conversions.\ntemplate<class FromTy>\nstruct cast_convert_val< ::clang::DeclContext, FromTy, FromTy> {\n  static ::clang::DeclContext &doit(const FromTy &Val) {\n    return *FromTy::castToDeclContext(&Val);\n  }\n};\n\ntemplate<class FromTy>\nstruct cast_convert_val< ::clang::DeclContext, FromTy*, FromTy*> {\n  static ::clang::DeclContext *doit(const FromTy *Val) {\n    return FromTy::castToDeclContext(Val);\n  }\n};\n\ntemplate<class FromTy>\nstruct cast_convert_val< const ::clang::DeclContext, FromTy, FromTy> {\n  static const ::clang::DeclContext &doit(const FromTy &Val) {\n    return *FromTy::castToDeclContext(&Val);\n  }\n};\n\ntemplate<class FromTy>\nstruct cast_convert_val< const ::clang::DeclContext, FromTy*, FromTy*> {\n  static const ::clang::DeclContext *doit(const FromTy *Val) {\n    return FromTy::castToDeclContext(Val);\n  }\n};\n\n} // namespace llvm\n\n#endif // LLVM_CLANG_AST_DECLBASE_H\n"}, "5": {"id": 5, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclCXX.h", "content": "//===- DeclCXX.h - Classes for representing C++ declarations --*- C++ -*-=====//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the C++ Decl subclasses, other than those for templates\n/// (found in DeclTemplate.h) and friends (in DeclFriend.h).\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_DECLCXX_H\n#define LLVM_CLANG_AST_DECLCXX_H\n\n#include \"clang/AST/ASTUnresolvedSet.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExternalASTSource.h\"\n#include \"clang/AST/LambdaCapture.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/Redeclarable.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/AST/TypeLoc.h\"\n#include \"clang/AST/UnresolvedSet.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/Lambda.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/OperatorKinds.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/TinyPtrVector.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <memory>\n#include <vector>\n\nnamespace clang {\n\nclass ASTContext;\nclass ClassTemplateDecl;\nclass ConstructorUsingShadowDecl;\nclass CXXBasePath;\nclass CXXBasePaths;\nclass CXXConstructorDecl;\nclass CXXDestructorDecl;\nclass CXXFinalOverriderMap;\nclass CXXIndirectPrimaryBaseSet;\nclass CXXMethodDecl;\nclass DecompositionDecl;\nclass DiagnosticBuilder;\nclass FriendDecl;\nclass FunctionTemplateDecl;\nclass IdentifierInfo;\nclass MemberSpecializationInfo;\nclass TemplateDecl;\nclass TemplateParameterList;\nclass UsingDecl;\n\n/// Represents an access specifier followed by colon ':'.\n///\n/// An objects of this class represents sugar for the syntactic occurrence\n/// of an access specifier followed by a colon in the list of member\n/// specifiers of a C++ class definition.\n///\n/// Note that they do not represent other uses of access specifiers,\n/// such as those occurring in a list of base specifiers.\n/// Also note that this class has nothing to do with so-called\n/// \"access declarations\" (C++98 11.3 [class.access.dcl]).\nclass AccessSpecDecl : public Decl {\n  /// The location of the ':'.\n  SourceLocation ColonLoc;\n\n  AccessSpecDecl(AccessSpecifier AS, DeclContext *DC,\n                 SourceLocation ASLoc, SourceLocation ColonLoc)\n    : Decl(AccessSpec, DC, ASLoc), ColonLoc(ColonLoc) {\n    setAccess(AS);\n  }\n\n  AccessSpecDecl(EmptyShell Empty) : Decl(AccessSpec, Empty) {}\n\n  virtual void anchor();\n\npublic:\n  /// The location of the access specifier.\n  SourceLocation getAccessSpecifierLoc() const { return getLocation(); }\n\n  /// Sets the location of the access specifier.\n  void setAccessSpecifierLoc(SourceLocation ASLoc) { setLocation(ASLoc); }\n\n  /// The location of the colon following the access specifier.\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  /// Sets the location of the colon.\n  void setColonLoc(SourceLocation CLoc) { ColonLoc = CLoc; }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(getAccessSpecifierLoc(), getColonLoc());\n  }\n\n  static AccessSpecDecl *Create(ASTContext &C, AccessSpecifier AS,\n                                DeclContext *DC, SourceLocation ASLoc,\n                                SourceLocation ColonLoc) {\n    return new (C, DC) AccessSpecDecl(AS, DC, ASLoc, ColonLoc);\n  }\n\n  static AccessSpecDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == AccessSpec; }\n};\n\n/// Represents a base class of a C++ class.\n///\n/// Each CXXBaseSpecifier represents a single, direct base class (or\n/// struct) of a C++ class (or struct). It specifies the type of that\n/// base class, whether it is a virtual or non-virtual base, and what\n/// level of access (public, protected, private) is used for the\n/// derivation. For example:\n///\n/// \\code\n///   class A { };\n///   class B { };\n///   class C : public virtual A, protected B { };\n/// \\endcode\n///\n/// In this code, C will have two CXXBaseSpecifiers, one for \"public\n/// virtual A\" and the other for \"protected B\".\nclass CXXBaseSpecifier {\n  /// The source code range that covers the full base\n  /// specifier, including the \"virtual\" (if present) and access\n  /// specifier (if present).\n  SourceRange Range;\n\n  /// The source location of the ellipsis, if this is a pack\n  /// expansion.\n  SourceLocation EllipsisLoc;\n\n  /// Whether this is a virtual base class or not.\n  unsigned Virtual : 1;\n\n  /// Whether this is the base of a class (true) or of a struct (false).\n  ///\n  /// This determines the mapping from the access specifier as written in the\n  /// source code to the access specifier used for semantic analysis.\n  unsigned BaseOfClass : 1;\n\n  /// Access specifier as written in the source code (may be AS_none).\n  ///\n  /// The actual type of data stored here is an AccessSpecifier, but we use\n  /// \"unsigned\" here to work around a VC++ bug.\n  unsigned Access : 2;\n\n  /// Whether the class contains a using declaration\n  /// to inherit the named class's constructors.\n  unsigned InheritConstructors : 1;\n\n  /// The type of the base class.\n  ///\n  /// This will be a class or struct (or a typedef of such). The source code\n  /// range does not include the \\c virtual or the access specifier.\n  TypeSourceInfo *BaseTypeInfo;\n\npublic:\n  CXXBaseSpecifier() = default;\n  CXXBaseSpecifier(SourceRange R, bool V, bool BC, AccessSpecifier A,\n                   TypeSourceInfo *TInfo, SourceLocation EllipsisLoc)\n    : Range(R), EllipsisLoc(EllipsisLoc), Virtual(V), BaseOfClass(BC),\n      Access(A), InheritConstructors(false), BaseTypeInfo(TInfo) {}\n\n  /// Retrieves the source range that contains the entire base specifier.\n  SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n\n  /// Get the location at which the base class type was written.\n  SourceLocation getBaseTypeLoc() const LLVM_READONLY {\n    return BaseTypeInfo->getTypeLoc().getBeginLoc();\n  }\n\n  /// Determines whether the base class is a virtual base class (or not).\n  bool isVirtual() const { return Virtual; }\n\n  /// Determine whether this base class is a base of a class declared\n  /// with the 'class' keyword (vs. one declared with the 'struct' keyword).\n  bool isBaseOfClass() const { return BaseOfClass; }\n\n  /// Determine whether this base specifier is a pack expansion.\n  bool isPackExpansion() const { return EllipsisLoc.isValid(); }\n\n  /// Determine whether this base class's constructors get inherited.\n  bool getInheritConstructors() const { return InheritConstructors; }\n\n  /// Set that this base class's constructors should be inherited.\n  void setInheritConstructors(bool Inherit = true) {\n    InheritConstructors = Inherit;\n  }\n\n  /// For a pack expansion, determine the location of the ellipsis.\n  SourceLocation getEllipsisLoc() const {\n    return EllipsisLoc;\n  }\n\n  /// Returns the access specifier for this base specifier.\n  ///\n  /// This is the actual base specifier as used for semantic analysis, so\n  /// the result can never be AS_none. To retrieve the access specifier as\n  /// written in the source code, use getAccessSpecifierAsWritten().\n  AccessSpecifier getAccessSpecifier() const {\n    if ((AccessSpecifier)Access == AS_none)\n      return BaseOfClass? AS_private : AS_public;\n    else\n      return (AccessSpecifier)Access;\n  }\n\n  /// Retrieves the access specifier as written in the source code\n  /// (which may mean that no access specifier was explicitly written).\n  ///\n  /// Use getAccessSpecifier() to retrieve the access specifier for use in\n  /// semantic analysis.\n  AccessSpecifier getAccessSpecifierAsWritten() const {\n    return (AccessSpecifier)Access;\n  }\n\n  /// Retrieves the type of the base class.\n  ///\n  /// This type will always be an unqualified class type.\n  QualType getType() const {\n    return BaseTypeInfo->getType().getUnqualifiedType();\n  }\n\n  /// Retrieves the type and source location of the base class.\n  TypeSourceInfo *getTypeSourceInfo() const { return BaseTypeInfo; }\n};\n\n/// Represents a C++ struct/union/class.\nclass CXXRecordDecl : public RecordDecl {\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend class ASTNodeImporter;\n  friend class ASTReader;\n  friend class ASTRecordWriter;\n  friend class ASTWriter;\n  friend class DeclContext;\n  friend class LambdaExpr;\n\n  friend void FunctionDecl::setPure(bool);\n  friend void TagDecl::startDefinition();\n\n  /// Values used in DefinitionData fields to represent special members.\n  enum SpecialMemberFlags {\n    SMF_DefaultConstructor = 0x1,\n    SMF_CopyConstructor = 0x2,\n    SMF_MoveConstructor = 0x4,\n    SMF_CopyAssignment = 0x8,\n    SMF_MoveAssignment = 0x10,\n    SMF_Destructor = 0x20,\n    SMF_All = 0x3f\n  };\n\n  struct DefinitionData {\n    #define FIELD(Name, Width, Merge) \\\n    unsigned Name : Width;\n    #include \"CXXRecordDeclDefinitionBits.def\"\n\n    /// Whether this class describes a C++ lambda.\n    unsigned IsLambda : 1;\n\n    /// Whether we are currently parsing base specifiers.\n    unsigned IsParsingBaseSpecifiers : 1;\n\n    /// True when visible conversion functions are already computed\n    /// and are available.\n    unsigned ComputedVisibleConversions : 1;\n\n    unsigned HasODRHash : 1;\n\n    /// A hash of parts of the class to help in ODR checking.\n    unsigned ODRHash = 0;\n\n    /// The number of base class specifiers in Bases.\n    unsigned NumBases = 0;\n\n    /// The number of virtual base class specifiers in VBases.\n    unsigned NumVBases = 0;\n\n    /// Base classes of this class.\n    ///\n    /// FIXME: This is wasted space for a union.\n    LazyCXXBaseSpecifiersPtr Bases;\n\n    /// direct and indirect virtual base classes of this class.\n    LazyCXXBaseSpecifiersPtr VBases;\n\n    /// The conversion functions of this C++ class (but not its\n    /// inherited conversion functions).\n    ///\n    /// Each of the entries in this overload set is a CXXConversionDecl.\n    LazyASTUnresolvedSet Conversions;\n\n    /// The conversion functions of this C++ class and all those\n    /// inherited conversion functions that are visible in this class.\n    ///\n    /// Each of the entries in this overload set is a CXXConversionDecl or a\n    /// FunctionTemplateDecl.\n    LazyASTUnresolvedSet VisibleConversions;\n\n    /// The declaration which defines this record.\n    CXXRecordDecl *Definition;\n\n    /// The first friend declaration in this class, or null if there\n    /// aren't any.\n    ///\n    /// This is actually currently stored in reverse order.\n    LazyDeclPtr FirstFriend;\n\n    DefinitionData(CXXRecordDecl *D);\n\n    /// Retrieve the set of direct base classes.\n    CXXBaseSpecifier *getBases() const {\n      if (!Bases.isOffset())\n        return Bases.get(nullptr);\n      return getBasesSlowCase();\n    }\n\n    /// Retrieve the set of virtual base classes.\n    CXXBaseSpecifier *getVBases() const {\n      if (!VBases.isOffset())\n        return VBases.get(nullptr);\n      return getVBasesSlowCase();\n    }\n\n    ArrayRef<CXXBaseSpecifier> bases() const {\n      return llvm::makeArrayRef(getBases(), NumBases);\n    }\n\n    ArrayRef<CXXBaseSpecifier> vbases() const {\n      return llvm::makeArrayRef(getVBases(), NumVBases);\n    }\n\n  private:\n    CXXBaseSpecifier *getBasesSlowCase() const;\n    CXXBaseSpecifier *getVBasesSlowCase() const;\n  };\n\n  struct DefinitionData *DefinitionData;\n\n  /// Describes a C++ closure type (generated by a lambda expression).\n  struct LambdaDefinitionData : public DefinitionData {\n    using Capture = LambdaCapture;\n\n    /// Whether this lambda is known to be dependent, even if its\n    /// context isn't dependent.\n    ///\n    /// A lambda with a non-dependent context can be dependent if it occurs\n    /// within the default argument of a function template, because the\n    /// lambda will have been created with the enclosing context as its\n    /// declaration context, rather than function. This is an unfortunate\n    /// artifact of having to parse the default arguments before.\n    unsigned Dependent : 1;\n\n    /// Whether this lambda is a generic lambda.\n    unsigned IsGenericLambda : 1;\n\n    /// The Default Capture.\n    unsigned CaptureDefault : 2;\n\n    /// The number of captures in this lambda is limited 2^NumCaptures.\n    unsigned NumCaptures : 15;\n\n    /// The number of explicit captures in this lambda.\n    unsigned NumExplicitCaptures : 13;\n\n    /// Has known `internal` linkage.\n    unsigned HasKnownInternalLinkage : 1;\n\n    /// The number used to indicate this lambda expression for name\n    /// mangling in the Itanium C++ ABI.\n    unsigned ManglingNumber : 31;\n\n    /// The declaration that provides context for this lambda, if the\n    /// actual DeclContext does not suffice. This is used for lambdas that\n    /// occur within default arguments of function parameters within the class\n    /// or within a data member initializer.\n    LazyDeclPtr ContextDecl;\n\n    /// The list of captures, both explicit and implicit, for this\n    /// lambda.\n    Capture *Captures = nullptr;\n\n    /// The type of the call method.\n    TypeSourceInfo *MethodTyInfo;\n\n    LambdaDefinitionData(CXXRecordDecl *D, TypeSourceInfo *Info, bool Dependent,\n                         bool IsGeneric, LambdaCaptureDefault CaptureDefault)\n        : DefinitionData(D), Dependent(Dependent), IsGenericLambda(IsGeneric),\n          CaptureDefault(CaptureDefault), NumCaptures(0),\n          NumExplicitCaptures(0), HasKnownInternalLinkage(0), ManglingNumber(0),\n          MethodTyInfo(Info) {\n      IsLambda = true;\n\n      // C++1z [expr.prim.lambda]p4:\n      //   This class type is not an aggregate type.\n      Aggregate = false;\n      PlainOldData = false;\n    }\n  };\n\n  struct DefinitionData *dataPtr() const {\n    // Complete the redecl chain (if necessary).\n    getMostRecentDecl();\n    return DefinitionData;\n  }\n\n  struct DefinitionData &data() const {\n    auto *DD = dataPtr();\n    assert(DD && \"queried property of class with no definition\");\n    return *DD;\n  }\n\n  struct LambdaDefinitionData &getLambdaData() const {\n    // No update required: a merged definition cannot change any lambda\n    // properties.\n    auto *DD = DefinitionData;\n    assert(DD && DD->IsLambda && \"queried lambda property of non-lambda class\");\n    return static_cast<LambdaDefinitionData&>(*DD);\n  }\n\n  /// The template or declaration that this declaration\n  /// describes or was instantiated from, respectively.\n  ///\n  /// For non-templates, this value will be null. For record\n  /// declarations that describe a class template, this will be a\n  /// pointer to a ClassTemplateDecl. For member\n  /// classes of class template specializations, this will be the\n  /// MemberSpecializationInfo referring to the member class that was\n  /// instantiated or specialized.\n  llvm::PointerUnion<ClassTemplateDecl *, MemberSpecializationInfo *>\n      TemplateOrInstantiation;\n\n  /// Called from setBases and addedMember to notify the class that a\n  /// direct or virtual base class or a member of class type has been added.\n  void addedClassSubobject(CXXRecordDecl *Base);\n\n  /// Notify the class that member has been added.\n  ///\n  /// This routine helps maintain information about the class based on which\n  /// members have been added. It will be invoked by DeclContext::addDecl()\n  /// whenever a member is added to this record.\n  void addedMember(Decl *D);\n\n  void markedVirtualFunctionPure();\n\n  /// Get the head of our list of friend declarations, possibly\n  /// deserializing the friends from an external AST source.\n  FriendDecl *getFirstFriend() const;\n\n  /// Determine whether this class has an empty base class subobject of type X\n  /// or of one of the types that might be at offset 0 within X (per the C++\n  /// \"standard layout\" rules).\n  bool hasSubobjectAtOffsetZeroOfEmptyBaseType(ASTContext &Ctx,\n                                               const CXXRecordDecl *X);\n\nprotected:\n  CXXRecordDecl(Kind K, TagKind TK, const ASTContext &C, DeclContext *DC,\n                SourceLocation StartLoc, SourceLocation IdLoc,\n                IdentifierInfo *Id, CXXRecordDecl *PrevDecl);\n\npublic:\n  /// Iterator that traverses the base classes of a class.\n  using base_class_iterator = CXXBaseSpecifier *;\n\n  /// Iterator that traverses the base classes of a class.\n  using base_class_const_iterator = const CXXBaseSpecifier *;\n\n  CXXRecordDecl *getCanonicalDecl() override {\n    return cast<CXXRecordDecl>(RecordDecl::getCanonicalDecl());\n  }\n\n  const CXXRecordDecl *getCanonicalDecl() const {\n    return const_cast<CXXRecordDecl*>(this)->getCanonicalDecl();\n  }\n\n  CXXRecordDecl *getPreviousDecl() {\n    return cast_or_null<CXXRecordDecl>(\n            static_cast<RecordDecl *>(this)->getPreviousDecl());\n  }\n\n  const CXXRecordDecl *getPreviousDecl() const {\n    return const_cast<CXXRecordDecl*>(this)->getPreviousDecl();\n  }\n\n  CXXRecordDecl *getMostRecentDecl() {\n    return cast<CXXRecordDecl>(\n            static_cast<RecordDecl *>(this)->getMostRecentDecl());\n  }\n\n  const CXXRecordDecl *getMostRecentDecl() const {\n    return const_cast<CXXRecordDecl*>(this)->getMostRecentDecl();\n  }\n\n  CXXRecordDecl *getMostRecentNonInjectedDecl() {\n    CXXRecordDecl *Recent =\n        static_cast<CXXRecordDecl *>(this)->getMostRecentDecl();\n    while (Recent->isInjectedClassName()) {\n      // FIXME: Does injected class name need to be in the redeclarations chain?\n      assert(Recent->getPreviousDecl());\n      Recent = Recent->getPreviousDecl();\n    }\n    return Recent;\n  }\n\n  const CXXRecordDecl *getMostRecentNonInjectedDecl() const {\n    return const_cast<CXXRecordDecl*>(this)->getMostRecentNonInjectedDecl();\n  }\n\n  CXXRecordDecl *getDefinition() const {\n    // We only need an update if we don't already know which\n    // declaration is the definition.\n    auto *DD = DefinitionData ? DefinitionData : dataPtr();\n    return DD ? DD->Definition : nullptr;\n  }\n\n  bool hasDefinition() const { return DefinitionData || dataPtr(); }\n\n  static CXXRecordDecl *Create(const ASTContext &C, TagKind TK, DeclContext *DC,\n                               SourceLocation StartLoc, SourceLocation IdLoc,\n                               IdentifierInfo *Id,\n                               CXXRecordDecl *PrevDecl = nullptr,\n                               bool DelayTypeCreation = false);\n  static CXXRecordDecl *CreateLambda(const ASTContext &C, DeclContext *DC,\n                                     TypeSourceInfo *Info, SourceLocation Loc,\n                                     bool DependentLambda, bool IsGeneric,\n                                     LambdaCaptureDefault CaptureDefault);\n  static CXXRecordDecl *CreateDeserialized(const ASTContext &C, unsigned ID);\n\n  bool isDynamicClass() const {\n    return data().Polymorphic || data().NumVBases != 0;\n  }\n\n  /// @returns true if class is dynamic or might be dynamic because the\n  /// definition is incomplete of dependent.\n  bool mayBeDynamicClass() const {\n    return !hasDefinition() || isDynamicClass() || hasAnyDependentBases();\n  }\n\n  /// @returns true if class is non dynamic or might be non dynamic because the\n  /// definition is incomplete of dependent.\n  bool mayBeNonDynamicClass() const {\n    return !hasDefinition() || !isDynamicClass() || hasAnyDependentBases();\n  }\n\n  void setIsParsingBaseSpecifiers() { data().IsParsingBaseSpecifiers = true; }\n\n  bool isParsingBaseSpecifiers() const {\n    return data().IsParsingBaseSpecifiers;\n  }\n\n  unsigned getODRHash() const;\n\n  /// Sets the base classes of this struct or class.\n  void setBases(CXXBaseSpecifier const * const *Bases, unsigned NumBases);\n\n  /// Retrieves the number of base classes of this class.\n  unsigned getNumBases() const { return data().NumBases; }\n\n  using base_class_range = llvm::iterator_range<base_class_iterator>;\n  using base_class_const_range =\n      llvm::iterator_range<base_class_const_iterator>;\n\n  base_class_range bases() {\n    return base_class_range(bases_begin(), bases_end());\n  }\n  base_class_const_range bases() const {\n    return base_class_const_range(bases_begin(), bases_end());\n  }\n\n  base_class_iterator bases_begin() { return data().getBases(); }\n  base_class_const_iterator bases_begin() const { return data().getBases(); }\n  base_class_iterator bases_end() { return bases_begin() + data().NumBases; }\n  base_class_const_iterator bases_end() const {\n    return bases_begin() + data().NumBases;\n  }\n\n  /// Retrieves the number of virtual base classes of this class.\n  unsigned getNumVBases() const { return data().NumVBases; }\n\n  base_class_range vbases() {\n    return base_class_range(vbases_begin(), vbases_end());\n  }\n  base_class_const_range vbases() const {\n    return base_class_const_range(vbases_begin(), vbases_end());\n  }\n\n  base_class_iterator vbases_begin() { return data().getVBases(); }\n  base_class_const_iterator vbases_begin() const { return data().getVBases(); }\n  base_class_iterator vbases_end() { return vbases_begin() + data().NumVBases; }\n  base_class_const_iterator vbases_end() const {\n    return vbases_begin() + data().NumVBases;\n  }\n\n  /// Determine whether this class has any dependent base classes which\n  /// are not the current instantiation.\n  bool hasAnyDependentBases() const;\n\n  /// Iterator access to method members.  The method iterator visits\n  /// all method members of the class, including non-instance methods,\n  /// special methods, etc.\n  using method_iterator = specific_decl_iterator<CXXMethodDecl>;\n  using method_range =\n      llvm::iterator_range<specific_decl_iterator<CXXMethodDecl>>;\n\n  method_range methods() const {\n    return method_range(method_begin(), method_end());\n  }\n\n  /// Method begin iterator.  Iterates in the order the methods\n  /// were declared.\n  method_iterator method_begin() const {\n    return method_iterator(decls_begin());\n  }\n\n  /// Method past-the-end iterator.\n  method_iterator method_end() const {\n    return method_iterator(decls_end());\n  }\n\n  /// Iterator access to constructor members.\n  using ctor_iterator = specific_decl_iterator<CXXConstructorDecl>;\n  using ctor_range =\n      llvm::iterator_range<specific_decl_iterator<CXXConstructorDecl>>;\n\n  ctor_range ctors() const { return ctor_range(ctor_begin(), ctor_end()); }\n\n  ctor_iterator ctor_begin() const {\n    return ctor_iterator(decls_begin());\n  }\n\n  ctor_iterator ctor_end() const {\n    return ctor_iterator(decls_end());\n  }\n\n  /// An iterator over friend declarations.  All of these are defined\n  /// in DeclFriend.h.\n  class friend_iterator;\n  using friend_range = llvm::iterator_range<friend_iterator>;\n\n  friend_range friends() const;\n  friend_iterator friend_begin() const;\n  friend_iterator friend_end() const;\n  void pushFriendDecl(FriendDecl *FD);\n\n  /// Determines whether this record has any friends.\n  bool hasFriends() const {\n    return data().FirstFriend.isValid();\n  }\n\n  /// \\c true if a defaulted copy constructor for this class would be\n  /// deleted.\n  bool defaultedCopyConstructorIsDeleted() const {\n    assert((!needsOverloadResolutionForCopyConstructor() ||\n            (data().DeclaredSpecialMembers & SMF_CopyConstructor)) &&\n           \"this property has not yet been computed by Sema\");\n    return data().DefaultedCopyConstructorIsDeleted;\n  }\n\n  /// \\c true if a defaulted move constructor for this class would be\n  /// deleted.\n  bool defaultedMoveConstructorIsDeleted() const {\n    assert((!needsOverloadResolutionForMoveConstructor() ||\n            (data().DeclaredSpecialMembers & SMF_MoveConstructor)) &&\n           \"this property has not yet been computed by Sema\");\n    return data().DefaultedMoveConstructorIsDeleted;\n  }\n\n  /// \\c true if a defaulted destructor for this class would be deleted.\n  bool defaultedDestructorIsDeleted() const {\n    assert((!needsOverloadResolutionForDestructor() ||\n            (data().DeclaredSpecialMembers & SMF_Destructor)) &&\n           \"this property has not yet been computed by Sema\");\n    return data().DefaultedDestructorIsDeleted;\n  }\n\n  /// \\c true if we know for sure that this class has a single,\n  /// accessible, unambiguous copy constructor that is not deleted.\n  bool hasSimpleCopyConstructor() const {\n    return !hasUserDeclaredCopyConstructor() &&\n           !data().DefaultedCopyConstructorIsDeleted;\n  }\n\n  /// \\c true if we know for sure that this class has a single,\n  /// accessible, unambiguous move constructor that is not deleted.\n  bool hasSimpleMoveConstructor() const {\n    return !hasUserDeclaredMoveConstructor() && hasMoveConstructor() &&\n           !data().DefaultedMoveConstructorIsDeleted;\n  }\n\n  /// \\c true if we know for sure that this class has a single,\n  /// accessible, unambiguous copy assignment operator that is not deleted.\n  bool hasSimpleCopyAssignment() const {\n    return !hasUserDeclaredCopyAssignment() &&\n           !data().DefaultedCopyAssignmentIsDeleted;\n  }\n\n  /// \\c true if we know for sure that this class has a single,\n  /// accessible, unambiguous move assignment operator that is not deleted.\n  bool hasSimpleMoveAssignment() const {\n    return !hasUserDeclaredMoveAssignment() && hasMoveAssignment() &&\n           !data().DefaultedMoveAssignmentIsDeleted;\n  }\n\n  /// \\c true if we know for sure that this class has an accessible\n  /// destructor that is not deleted.\n  bool hasSimpleDestructor() const {\n    return !hasUserDeclaredDestructor() &&\n           !data().DefaultedDestructorIsDeleted;\n  }\n\n  /// Determine whether this class has any default constructors.\n  bool hasDefaultConstructor() const {\n    return (data().DeclaredSpecialMembers & SMF_DefaultConstructor) ||\n           needsImplicitDefaultConstructor();\n  }\n\n  /// Determine if we need to declare a default constructor for\n  /// this class.\n  ///\n  /// This value is used for lazy creation of default constructors.\n  bool needsImplicitDefaultConstructor() const {\n    return (!data().UserDeclaredConstructor &&\n            !(data().DeclaredSpecialMembers & SMF_DefaultConstructor) &&\n            (!isLambda() || lambdaIsDefaultConstructibleAndAssignable())) ||\n           // FIXME: Proposed fix to core wording issue: if a class inherits\n           // a default constructor and doesn't explicitly declare one, one\n           // is declared implicitly.\n           (data().HasInheritedDefaultConstructor &&\n            !(data().DeclaredSpecialMembers & SMF_DefaultConstructor));\n  }\n\n  /// Determine whether this class has any user-declared constructors.\n  ///\n  /// When true, a default constructor will not be implicitly declared.\n  bool hasUserDeclaredConstructor() const {\n    return data().UserDeclaredConstructor;\n  }\n\n  /// Whether this class has a user-provided default constructor\n  /// per C++11.\n  bool hasUserProvidedDefaultConstructor() const {\n    return data().UserProvidedDefaultConstructor;\n  }\n\n  /// Determine whether this class has a user-declared copy constructor.\n  ///\n  /// When false, a copy constructor will be implicitly declared.\n  bool hasUserDeclaredCopyConstructor() const {\n    return data().UserDeclaredSpecialMembers & SMF_CopyConstructor;\n  }\n\n  /// Determine whether this class needs an implicit copy\n  /// constructor to be lazily declared.\n  bool needsImplicitCopyConstructor() const {\n    return !(data().DeclaredSpecialMembers & SMF_CopyConstructor);\n  }\n\n  /// Determine whether we need to eagerly declare a defaulted copy\n  /// constructor for this class.\n  bool needsOverloadResolutionForCopyConstructor() const {\n    // C++17 [class.copy.ctor]p6:\n    //   If the class definition declares a move constructor or move assignment\n    //   operator, the implicitly declared copy constructor is defined as\n    //   deleted.\n    // In MSVC mode, sometimes a declared move assignment does not delete an\n    // implicit copy constructor, so defer this choice to Sema.\n    if (data().UserDeclaredSpecialMembers &\n        (SMF_MoveConstructor | SMF_MoveAssignment))\n      return true;\n    return data().NeedOverloadResolutionForCopyConstructor;\n  }\n\n  /// Determine whether an implicit copy constructor for this type\n  /// would have a parameter with a const-qualified reference type.\n  bool implicitCopyConstructorHasConstParam() const {\n    return data().ImplicitCopyConstructorCanHaveConstParamForNonVBase &&\n           (isAbstract() ||\n            data().ImplicitCopyConstructorCanHaveConstParamForVBase);\n  }\n\n  /// Determine whether this class has a copy constructor with\n  /// a parameter type which is a reference to a const-qualified type.\n  bool hasCopyConstructorWithConstParam() const {\n    return data().HasDeclaredCopyConstructorWithConstParam ||\n           (needsImplicitCopyConstructor() &&\n            implicitCopyConstructorHasConstParam());\n  }\n\n  /// Whether this class has a user-declared move constructor or\n  /// assignment operator.\n  ///\n  /// When false, a move constructor and assignment operator may be\n  /// implicitly declared.\n  bool hasUserDeclaredMoveOperation() const {\n    return data().UserDeclaredSpecialMembers &\n             (SMF_MoveConstructor | SMF_MoveAssignment);\n  }\n\n  /// Determine whether this class has had a move constructor\n  /// declared by the user.\n  bool hasUserDeclaredMoveConstructor() const {\n    return data().UserDeclaredSpecialMembers & SMF_MoveConstructor;\n  }\n\n  /// Determine whether this class has a move constructor.\n  bool hasMoveConstructor() const {\n    return (data().DeclaredSpecialMembers & SMF_MoveConstructor) ||\n           needsImplicitMoveConstructor();\n  }\n\n  /// Set that we attempted to declare an implicit copy\n  /// constructor, but overload resolution failed so we deleted it.\n  void setImplicitCopyConstructorIsDeleted() {\n    assert((data().DefaultedCopyConstructorIsDeleted ||\n            needsOverloadResolutionForCopyConstructor()) &&\n           \"Copy constructor should not be deleted\");\n    data().DefaultedCopyConstructorIsDeleted = true;\n  }\n\n  /// Set that we attempted to declare an implicit move\n  /// constructor, but overload resolution failed so we deleted it.\n  void setImplicitMoveConstructorIsDeleted() {\n    assert((data().DefaultedMoveConstructorIsDeleted ||\n            needsOverloadResolutionForMoveConstructor()) &&\n           \"move constructor should not be deleted\");\n    data().DefaultedMoveConstructorIsDeleted = true;\n  }\n\n  /// Set that we attempted to declare an implicit destructor,\n  /// but overload resolution failed so we deleted it.\n  void setImplicitDestructorIsDeleted() {\n    assert((data().DefaultedDestructorIsDeleted ||\n            needsOverloadResolutionForDestructor()) &&\n           \"destructor should not be deleted\");\n    data().DefaultedDestructorIsDeleted = true;\n  }\n\n  /// Determine whether this class should get an implicit move\n  /// constructor or if any existing special member function inhibits this.\n  bool needsImplicitMoveConstructor() const {\n    return !(data().DeclaredSpecialMembers & SMF_MoveConstructor) &&\n           !hasUserDeclaredCopyConstructor() &&\n           !hasUserDeclaredCopyAssignment() &&\n           !hasUserDeclaredMoveAssignment() &&\n           !hasUserDeclaredDestructor();\n  }\n\n  /// Determine whether we need to eagerly declare a defaulted move\n  /// constructor for this class.\n  bool needsOverloadResolutionForMoveConstructor() const {\n    return data().NeedOverloadResolutionForMoveConstructor;\n  }\n\n  /// Determine whether this class has a user-declared copy assignment\n  /// operator.\n  ///\n  /// When false, a copy assignment operator will be implicitly declared.\n  bool hasUserDeclaredCopyAssignment() const {\n    return data().UserDeclaredSpecialMembers & SMF_CopyAssignment;\n  }\n\n  /// Set that we attempted to declare an implicit copy assignment\n  /// operator, but overload resolution failed so we deleted it.\n  void setImplicitCopyAssignmentIsDeleted() {\n    assert((data().DefaultedCopyAssignmentIsDeleted ||\n            needsOverloadResolutionForCopyAssignment()) &&\n           \"copy assignment should not be deleted\");\n    data().DefaultedCopyAssignmentIsDeleted = true;\n  }\n\n  /// Determine whether this class needs an implicit copy\n  /// assignment operator to be lazily declared.\n  bool needsImplicitCopyAssignment() const {\n    return !(data().DeclaredSpecialMembers & SMF_CopyAssignment);\n  }\n\n  /// Determine whether we need to eagerly declare a defaulted copy\n  /// assignment operator for this class.\n  bool needsOverloadResolutionForCopyAssignment() const {\n    // C++20 [class.copy.assign]p2:\n    //   If the class definition declares a move constructor or move assignment\n    //   operator, the implicitly declared copy assignment operator is defined\n    //   as deleted.\n    // In MSVC mode, sometimes a declared move constructor does not delete an\n    // implicit copy assignment, so defer this choice to Sema.\n    if (data().UserDeclaredSpecialMembers &\n        (SMF_MoveConstructor | SMF_MoveAssignment))\n      return true;\n    return data().NeedOverloadResolutionForCopyAssignment;\n  }\n\n  /// Determine whether an implicit copy assignment operator for this\n  /// type would have a parameter with a const-qualified reference type.\n  bool implicitCopyAssignmentHasConstParam() const {\n    return data().ImplicitCopyAssignmentHasConstParam;\n  }\n\n  /// Determine whether this class has a copy assignment operator with\n  /// a parameter type which is a reference to a const-qualified type or is not\n  /// a reference.\n  bool hasCopyAssignmentWithConstParam() const {\n    return data().HasDeclaredCopyAssignmentWithConstParam ||\n           (needsImplicitCopyAssignment() &&\n            implicitCopyAssignmentHasConstParam());\n  }\n\n  /// Determine whether this class has had a move assignment\n  /// declared by the user.\n  bool hasUserDeclaredMoveAssignment() const {\n    return data().UserDeclaredSpecialMembers & SMF_MoveAssignment;\n  }\n\n  /// Determine whether this class has a move assignment operator.\n  bool hasMoveAssignment() const {\n    return (data().DeclaredSpecialMembers & SMF_MoveAssignment) ||\n           needsImplicitMoveAssignment();\n  }\n\n  /// Set that we attempted to declare an implicit move assignment\n  /// operator, but overload resolution failed so we deleted it.\n  void setImplicitMoveAssignmentIsDeleted() {\n    assert((data().DefaultedMoveAssignmentIsDeleted ||\n            needsOverloadResolutionForMoveAssignment()) &&\n           \"move assignment should not be deleted\");\n    data().DefaultedMoveAssignmentIsDeleted = true;\n  }\n\n  /// Determine whether this class should get an implicit move\n  /// assignment operator or if any existing special member function inhibits\n  /// this.\n  bool needsImplicitMoveAssignment() const {\n    return !(data().DeclaredSpecialMembers & SMF_MoveAssignment) &&\n           !hasUserDeclaredCopyConstructor() &&\n           !hasUserDeclaredCopyAssignment() &&\n           !hasUserDeclaredMoveConstructor() &&\n           !hasUserDeclaredDestructor() &&\n           (!isLambda() || lambdaIsDefaultConstructibleAndAssignable());\n  }\n\n  /// Determine whether we need to eagerly declare a move assignment\n  /// operator for this class.\n  bool needsOverloadResolutionForMoveAssignment() const {\n    return data().NeedOverloadResolutionForMoveAssignment;\n  }\n\n  /// Determine whether this class has a user-declared destructor.\n  ///\n  /// When false, a destructor will be implicitly declared.\n  bool hasUserDeclaredDestructor() const {\n    return data().UserDeclaredSpecialMembers & SMF_Destructor;\n  }\n\n  /// Determine whether this class needs an implicit destructor to\n  /// be lazily declared.\n  bool needsImplicitDestructor() const {\n    return !(data().DeclaredSpecialMembers & SMF_Destructor);\n  }\n\n  /// Determine whether we need to eagerly declare a destructor for this\n  /// class.\n  bool needsOverloadResolutionForDestructor() const {\n    return data().NeedOverloadResolutionForDestructor;\n  }\n\n  /// Determine whether this class describes a lambda function object.\n  bool isLambda() const {\n    // An update record can't turn a non-lambda into a lambda.\n    auto *DD = DefinitionData;\n    return DD && DD->IsLambda;\n  }\n\n  /// Determine whether this class describes a generic\n  /// lambda function object (i.e. function call operator is\n  /// a template).\n  bool isGenericLambda() const;\n\n  /// Determine whether this lambda should have an implicit default constructor\n  /// and copy and move assignment operators.\n  bool lambdaIsDefaultConstructibleAndAssignable() const;\n\n  /// Retrieve the lambda call operator of the closure type\n  /// if this is a closure type.\n  CXXMethodDecl *getLambdaCallOperator() const;\n\n  /// Retrieve the dependent lambda call operator of the closure type\n  /// if this is a templated closure type.\n  FunctionTemplateDecl *getDependentLambdaCallOperator() const;\n\n  /// Retrieve the lambda static invoker, the address of which\n  /// is returned by the conversion operator, and the body of which\n  /// is forwarded to the lambda call operator. The version that does not\n  /// take a calling convention uses the 'default' calling convention for free\n  /// functions if the Lambda's calling convention was not modified via\n  /// attribute. Otherwise, it will return the calling convention specified for\n  /// the lambda.\n  CXXMethodDecl *getLambdaStaticInvoker() const;\n  CXXMethodDecl *getLambdaStaticInvoker(CallingConv CC) const;\n\n  /// Retrieve the generic lambda's template parameter list.\n  /// Returns null if the class does not represent a lambda or a generic\n  /// lambda.\n  TemplateParameterList *getGenericLambdaTemplateParameterList() const;\n\n  /// Retrieve the lambda template parameters that were specified explicitly.\n  ArrayRef<NamedDecl *> getLambdaExplicitTemplateParameters() const;\n\n  LambdaCaptureDefault getLambdaCaptureDefault() const {\n    assert(isLambda());\n    return static_cast<LambdaCaptureDefault>(getLambdaData().CaptureDefault);\n  }\n\n  /// Set the captures for this lambda closure type.\n  void setCaptures(ASTContext &Context, ArrayRef<LambdaCapture> Captures);\n\n  /// For a closure type, retrieve the mapping from captured\n  /// variables and \\c this to the non-static data members that store the\n  /// values or references of the captures.\n  ///\n  /// \\param Captures Will be populated with the mapping from captured\n  /// variables to the corresponding fields.\n  ///\n  /// \\param ThisCapture Will be set to the field declaration for the\n  /// \\c this capture.\n  ///\n  /// \\note No entries will be added for init-captures, as they do not capture\n  /// variables.\n  void getCaptureFields(llvm::DenseMap<const VarDecl *, FieldDecl *> &Captures,\n                        FieldDecl *&ThisCapture) const;\n\n  using capture_const_iterator = const LambdaCapture *;\n  using capture_const_range = llvm::iterator_range<capture_const_iterator>;\n\n  capture_const_range captures() const {\n    return capture_const_range(captures_begin(), captures_end());\n  }\n\n  capture_const_iterator captures_begin() const {\n    return isLambda() ? getLambdaData().Captures : nullptr;\n  }\n\n  capture_const_iterator captures_end() const {\n    return isLambda() ? captures_begin() + getLambdaData().NumCaptures\n                      : nullptr;\n  }\n\n  unsigned capture_size() const { return getLambdaData().NumCaptures; }\n\n  using conversion_iterator = UnresolvedSetIterator;\n\n  conversion_iterator conversion_begin() const {\n    return data().Conversions.get(getASTContext()).begin();\n  }\n\n  conversion_iterator conversion_end() const {\n    return data().Conversions.get(getASTContext()).end();\n  }\n\n  /// Removes a conversion function from this class.  The conversion\n  /// function must currently be a member of this class.  Furthermore,\n  /// this class must currently be in the process of being defined.\n  void removeConversion(const NamedDecl *Old);\n\n  /// Get all conversion functions visible in current class,\n  /// including conversion function templates.\n  llvm::iterator_range<conversion_iterator>\n  getVisibleConversionFunctions() const;\n\n  /// Determine whether this class is an aggregate (C++ [dcl.init.aggr]),\n  /// which is a class with no user-declared constructors, no private\n  /// or protected non-static data members, no base classes, and no virtual\n  /// functions (C++ [dcl.init.aggr]p1).\n  bool isAggregate() const { return data().Aggregate; }\n\n  /// Whether this class has any in-class initializers\n  /// for non-static data members (including those in anonymous unions or\n  /// structs).\n  bool hasInClassInitializer() const { return data().HasInClassInitializer; }\n\n  /// Whether this class or any of its subobjects has any members of\n  /// reference type which would make value-initialization ill-formed.\n  ///\n  /// Per C++03 [dcl.init]p5:\n  ///  - if T is a non-union class type without a user-declared constructor,\n  ///    then every non-static data member and base-class component of T is\n  ///    value-initialized [...] A program that calls for [...]\n  ///    value-initialization of an entity of reference type is ill-formed.\n  bool hasUninitializedReferenceMember() const {\n    return !isUnion() && !hasUserDeclaredConstructor() &&\n           data().HasUninitializedReferenceMember;\n  }\n\n  /// Whether this class is a POD-type (C++ [class]p4)\n  ///\n  /// For purposes of this function a class is POD if it is an aggregate\n  /// that has no non-static non-POD data members, no reference data\n  /// members, no user-defined copy assignment operator and no\n  /// user-defined destructor.\n  ///\n  /// Note that this is the C++ TR1 definition of POD.\n  bool isPOD() const { return data().PlainOldData; }\n\n  /// True if this class is C-like, without C++-specific features, e.g.\n  /// it contains only public fields, no bases, tag kind is not 'class', etc.\n  bool isCLike() const;\n\n  /// Determine whether this is an empty class in the sense of\n  /// (C++11 [meta.unary.prop]).\n  ///\n  /// The CXXRecordDecl is a class type, but not a union type,\n  /// with no non-static data members other than bit-fields of length 0,\n  /// no virtual member functions, no virtual base classes,\n  /// and no base class B for which is_empty<B>::value is false.\n  ///\n  /// \\note This does NOT include a check for union-ness.\n  bool isEmpty() const { return data().Empty; }\n\n  bool hasPrivateFields() const {\n    return data().HasPrivateFields;\n  }\n\n  bool hasProtectedFields() const {\n    return data().HasProtectedFields;\n  }\n\n  /// Determine whether this class has direct non-static data members.\n  bool hasDirectFields() const {\n    auto &D = data();\n    return D.HasPublicFields || D.HasProtectedFields || D.HasPrivateFields;\n  }\n\n  /// Whether this class is polymorphic (C++ [class.virtual]),\n  /// which means that the class contains or inherits a virtual function.\n  bool isPolymorphic() const { return data().Polymorphic; }\n\n  /// Determine whether this class has a pure virtual function.\n  ///\n  /// The class is is abstract per (C++ [class.abstract]p2) if it declares\n  /// a pure virtual function or inherits a pure virtual function that is\n  /// not overridden.\n  bool isAbstract() const { return data().Abstract; }\n\n  /// Determine whether this class is standard-layout per\n  /// C++ [class]p7.\n  bool isStandardLayout() const { return data().IsStandardLayout; }\n\n  /// Determine whether this class was standard-layout per\n  /// C++11 [class]p7, specifically using the C++11 rules without any DRs.\n  bool isCXX11StandardLayout() const { return data().IsCXX11StandardLayout; }\n\n  /// Determine whether this class, or any of its class subobjects,\n  /// contains a mutable field.\n  bool hasMutableFields() const { return data().HasMutableFields; }\n\n  /// Determine whether this class has any variant members.\n  bool hasVariantMembers() const { return data().HasVariantMembers; }\n\n  /// Determine whether this class has a trivial default constructor\n  /// (C++11 [class.ctor]p5).\n  bool hasTrivialDefaultConstructor() const {\n    return hasDefaultConstructor() &&\n           (data().HasTrivialSpecialMembers & SMF_DefaultConstructor);\n  }\n\n  /// Determine whether this class has a non-trivial default constructor\n  /// (C++11 [class.ctor]p5).\n  bool hasNonTrivialDefaultConstructor() const {\n    return (data().DeclaredNonTrivialSpecialMembers & SMF_DefaultConstructor) ||\n           (needsImplicitDefaultConstructor() &&\n            !(data().HasTrivialSpecialMembers & SMF_DefaultConstructor));\n  }\n\n  /// Determine whether this class has at least one constexpr constructor\n  /// other than the copy or move constructors.\n  bool hasConstexprNonCopyMoveConstructor() const {\n    return data().HasConstexprNonCopyMoveConstructor ||\n           (needsImplicitDefaultConstructor() &&\n            defaultedDefaultConstructorIsConstexpr());\n  }\n\n  /// Determine whether a defaulted default constructor for this class\n  /// would be constexpr.\n  bool defaultedDefaultConstructorIsConstexpr() const {\n    return data().DefaultedDefaultConstructorIsConstexpr &&\n           (!isUnion() || hasInClassInitializer() || !hasVariantMembers() ||\n            getLangOpts().CPlusPlus20);\n  }\n\n  /// Determine whether this class has a constexpr default constructor.\n  bool hasConstexprDefaultConstructor() const {\n    return data().HasConstexprDefaultConstructor ||\n           (needsImplicitDefaultConstructor() &&\n            defaultedDefaultConstructorIsConstexpr());\n  }\n\n  /// Determine whether this class has a trivial copy constructor\n  /// (C++ [class.copy]p6, C++11 [class.copy]p12)\n  bool hasTrivialCopyConstructor() const {\n    return data().HasTrivialSpecialMembers & SMF_CopyConstructor;\n  }\n\n  bool hasTrivialCopyConstructorForCall() const {\n    return data().HasTrivialSpecialMembersForCall & SMF_CopyConstructor;\n  }\n\n  /// Determine whether this class has a non-trivial copy constructor\n  /// (C++ [class.copy]p6, C++11 [class.copy]p12)\n  bool hasNonTrivialCopyConstructor() const {\n    return data().DeclaredNonTrivialSpecialMembers & SMF_CopyConstructor ||\n           !hasTrivialCopyConstructor();\n  }\n\n  bool hasNonTrivialCopyConstructorForCall() const {\n    return (data().DeclaredNonTrivialSpecialMembersForCall &\n            SMF_CopyConstructor) ||\n           !hasTrivialCopyConstructorForCall();\n  }\n\n  /// Determine whether this class has a trivial move constructor\n  /// (C++11 [class.copy]p12)\n  bool hasTrivialMoveConstructor() const {\n    return hasMoveConstructor() &&\n           (data().HasTrivialSpecialMembers & SMF_MoveConstructor);\n  }\n\n  bool hasTrivialMoveConstructorForCall() const {\n    return hasMoveConstructor() &&\n           (data().HasTrivialSpecialMembersForCall & SMF_MoveConstructor);\n  }\n\n  /// Determine whether this class has a non-trivial move constructor\n  /// (C++11 [class.copy]p12)\n  bool hasNonTrivialMoveConstructor() const {\n    return (data().DeclaredNonTrivialSpecialMembers & SMF_MoveConstructor) ||\n           (needsImplicitMoveConstructor() &&\n            !(data().HasTrivialSpecialMembers & SMF_MoveConstructor));\n  }\n\n  bool hasNonTrivialMoveConstructorForCall() const {\n    return (data().DeclaredNonTrivialSpecialMembersForCall &\n            SMF_MoveConstructor) ||\n           (needsImplicitMoveConstructor() &&\n            !(data().HasTrivialSpecialMembersForCall & SMF_MoveConstructor));\n  }\n\n  /// Determine whether this class has a trivial copy assignment operator\n  /// (C++ [class.copy]p11, C++11 [class.copy]p25)\n  bool hasTrivialCopyAssignment() const {\n    return data().HasTrivialSpecialMembers & SMF_CopyAssignment;\n  }\n\n  /// Determine whether this class has a non-trivial copy assignment\n  /// operator (C++ [class.copy]p11, C++11 [class.copy]p25)\n  bool hasNonTrivialCopyAssignment() const {\n    return data().DeclaredNonTrivialSpecialMembers & SMF_CopyAssignment ||\n           !hasTrivialCopyAssignment();\n  }\n\n  /// Determine whether this class has a trivial move assignment operator\n  /// (C++11 [class.copy]p25)\n  bool hasTrivialMoveAssignment() const {\n    return hasMoveAssignment() &&\n           (data().HasTrivialSpecialMembers & SMF_MoveAssignment);\n  }\n\n  /// Determine whether this class has a non-trivial move assignment\n  /// operator (C++11 [class.copy]p25)\n  bool hasNonTrivialMoveAssignment() const {\n    return (data().DeclaredNonTrivialSpecialMembers & SMF_MoveAssignment) ||\n           (needsImplicitMoveAssignment() &&\n            !(data().HasTrivialSpecialMembers & SMF_MoveAssignment));\n  }\n\n  /// Determine whether a defaulted default constructor for this class\n  /// would be constexpr.\n  bool defaultedDestructorIsConstexpr() const {\n    return data().DefaultedDestructorIsConstexpr &&\n           getLangOpts().CPlusPlus20;\n  }\n\n  /// Determine whether this class has a constexpr destructor.\n  bool hasConstexprDestructor() const;\n\n  /// Determine whether this class has a trivial destructor\n  /// (C++ [class.dtor]p3)\n  bool hasTrivialDestructor() const {\n    return data().HasTrivialSpecialMembers & SMF_Destructor;\n  }\n\n  bool hasTrivialDestructorForCall() const {\n    return data().HasTrivialSpecialMembersForCall & SMF_Destructor;\n  }\n\n  /// Determine whether this class has a non-trivial destructor\n  /// (C++ [class.dtor]p3)\n  bool hasNonTrivialDestructor() const {\n    return !(data().HasTrivialSpecialMembers & SMF_Destructor);\n  }\n\n  bool hasNonTrivialDestructorForCall() const {\n    return !(data().HasTrivialSpecialMembersForCall & SMF_Destructor);\n  }\n\n  void setHasTrivialSpecialMemberForCall() {\n    data().HasTrivialSpecialMembersForCall =\n        (SMF_CopyConstructor | SMF_MoveConstructor | SMF_Destructor);\n  }\n\n  /// Determine whether declaring a const variable with this type is ok\n  /// per core issue 253.\n  bool allowConstDefaultInit() const {\n    return !data().HasUninitializedFields ||\n           !(data().HasDefaultedDefaultConstructor ||\n             needsImplicitDefaultConstructor());\n  }\n\n  /// Determine whether this class has a destructor which has no\n  /// semantic effect.\n  ///\n  /// Any such destructor will be trivial, public, defaulted and not deleted,\n  /// and will call only irrelevant destructors.\n  bool hasIrrelevantDestructor() const {\n    return data().HasIrrelevantDestructor;\n  }\n\n  /// Determine whether this class has a non-literal or/ volatile type\n  /// non-static data member or base class.\n  bool hasNonLiteralTypeFieldsOrBases() const {\n    return data().HasNonLiteralTypeFieldsOrBases;\n  }\n\n  /// Determine whether this class has a using-declaration that names\n  /// a user-declared base class constructor.\n  bool hasInheritedConstructor() const {\n    return data().HasInheritedConstructor;\n  }\n\n  /// Determine whether this class has a using-declaration that names\n  /// a base class assignment operator.\n  bool hasInheritedAssignment() const {\n    return data().HasInheritedAssignment;\n  }\n\n  /// Determine whether this class is considered trivially copyable per\n  /// (C++11 [class]p6).\n  bool isTriviallyCopyable() const;\n\n  /// Determine whether this class is considered trivial.\n  ///\n  /// C++11 [class]p6:\n  ///    \"A trivial class is a class that has a trivial default constructor and\n  ///    is trivially copyable.\"\n  bool isTrivial() const {\n    return isTriviallyCopyable() && hasTrivialDefaultConstructor();\n  }\n\n  /// Determine whether this class is a literal type.\n  ///\n  /// C++11 [basic.types]p10:\n  ///   A class type that has all the following properties:\n  ///     - it has a trivial destructor\n  ///     - every constructor call and full-expression in the\n  ///       brace-or-equal-intializers for non-static data members (if any) is\n  ///       a constant expression.\n  ///     - it is an aggregate type or has at least one constexpr constructor\n  ///       or constructor template that is not a copy or move constructor, and\n  ///     - all of its non-static data members and base classes are of literal\n  ///       types\n  ///\n  /// We resolve DR1361 by ignoring the second bullet. We resolve DR1452 by\n  /// treating types with trivial default constructors as literal types.\n  ///\n  /// Only in C++17 and beyond, are lambdas literal types.\n  bool isLiteral() const {\n    const LangOptions &LangOpts = getLangOpts();\n    return (LangOpts.CPlusPlus20 ? hasConstexprDestructor()\n                                          : hasTrivialDestructor()) &&\n           (!isLambda() || LangOpts.CPlusPlus17) &&\n           !hasNonLiteralTypeFieldsOrBases() &&\n           (isAggregate() || isLambda() ||\n            hasConstexprNonCopyMoveConstructor() ||\n            hasTrivialDefaultConstructor());\n  }\n\n  /// Determine whether this is a structural type.\n  bool isStructural() const {\n    return isLiteral() && data().StructuralIfLiteral;\n  }\n\n  /// If this record is an instantiation of a member class,\n  /// retrieves the member class from which it was instantiated.\n  ///\n  /// This routine will return non-null for (non-templated) member\n  /// classes of class templates. For example, given:\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   struct A { };\n  /// };\n  /// \\endcode\n  ///\n  /// The declaration for X<int>::A is a (non-templated) CXXRecordDecl\n  /// whose parent is the class template specialization X<int>. For\n  /// this declaration, getInstantiatedFromMemberClass() will return\n  /// the CXXRecordDecl X<T>::A. When a complete definition of\n  /// X<int>::A is required, it will be instantiated from the\n  /// declaration returned by getInstantiatedFromMemberClass().\n  CXXRecordDecl *getInstantiatedFromMemberClass() const;\n\n  /// If this class is an instantiation of a member class of a\n  /// class template specialization, retrieves the member specialization\n  /// information.\n  MemberSpecializationInfo *getMemberSpecializationInfo() const;\n\n  /// Specify that this record is an instantiation of the\n  /// member class \\p RD.\n  void setInstantiationOfMemberClass(CXXRecordDecl *RD,\n                                     TemplateSpecializationKind TSK);\n\n  /// Retrieves the class template that is described by this\n  /// class declaration.\n  ///\n  /// Every class template is represented as a ClassTemplateDecl and a\n  /// CXXRecordDecl. The former contains template properties (such as\n  /// the template parameter lists) while the latter contains the\n  /// actual description of the template's\n  /// contents. ClassTemplateDecl::getTemplatedDecl() retrieves the\n  /// CXXRecordDecl that from a ClassTemplateDecl, while\n  /// getDescribedClassTemplate() retrieves the ClassTemplateDecl from\n  /// a CXXRecordDecl.\n  ClassTemplateDecl *getDescribedClassTemplate() const;\n\n  void setDescribedClassTemplate(ClassTemplateDecl *Template);\n\n  /// Determine whether this particular class is a specialization or\n  /// instantiation of a class template or member class of a class template,\n  /// and how it was instantiated or specialized.\n  TemplateSpecializationKind getTemplateSpecializationKind() const;\n\n  /// Set the kind of specialization or template instantiation this is.\n  void setTemplateSpecializationKind(TemplateSpecializationKind TSK);\n\n  /// Retrieve the record declaration from which this record could be\n  /// instantiated. Returns null if this class is not a template instantiation.\n  const CXXRecordDecl *getTemplateInstantiationPattern() const;\n\n  CXXRecordDecl *getTemplateInstantiationPattern() {\n    return const_cast<CXXRecordDecl *>(const_cast<const CXXRecordDecl *>(this)\n                                           ->getTemplateInstantiationPattern());\n  }\n\n  /// Returns the destructor decl for this class.\n  CXXDestructorDecl *getDestructor() const;\n\n  /// Returns true if the class destructor, or any implicitly invoked\n  /// destructors are marked noreturn.\n  bool isAnyDestructorNoReturn() const;\n\n  /// If the class is a local class [class.local], returns\n  /// the enclosing function declaration.\n  const FunctionDecl *isLocalClass() const {\n    if (const auto *RD = dyn_cast<CXXRecordDecl>(getDeclContext()))\n      return RD->isLocalClass();\n\n    return dyn_cast<FunctionDecl>(getDeclContext());\n  }\n\n  FunctionDecl *isLocalClass() {\n    return const_cast<FunctionDecl*>(\n        const_cast<const CXXRecordDecl*>(this)->isLocalClass());\n  }\n\n  /// Determine whether this dependent class is a current instantiation,\n  /// when viewed from within the given context.\n  bool isCurrentInstantiation(const DeclContext *CurContext) const;\n\n  /// Determine whether this class is derived from the class \\p Base.\n  ///\n  /// This routine only determines whether this class is derived from \\p Base,\n  /// but does not account for factors that may make a Derived -> Base class\n  /// ill-formed, such as private/protected inheritance or multiple, ambiguous\n  /// base class subobjects.\n  ///\n  /// \\param Base the base class we are searching for.\n  ///\n  /// \\returns true if this class is derived from Base, false otherwise.\n  bool isDerivedFrom(const CXXRecordDecl *Base) const;\n\n  /// Determine whether this class is derived from the type \\p Base.\n  ///\n  /// This routine only determines whether this class is derived from \\p Base,\n  /// but does not account for factors that may make a Derived -> Base class\n  /// ill-formed, such as private/protected inheritance or multiple, ambiguous\n  /// base class subobjects.\n  ///\n  /// \\param Base the base class we are searching for.\n  ///\n  /// \\param Paths will contain the paths taken from the current class to the\n  /// given \\p Base class.\n  ///\n  /// \\returns true if this class is derived from \\p Base, false otherwise.\n  ///\n  /// \\todo add a separate parameter to configure IsDerivedFrom, rather than\n  /// tangling input and output in \\p Paths\n  bool isDerivedFrom(const CXXRecordDecl *Base, CXXBasePaths &Paths) const;\n\n  /// Determine whether this class is virtually derived from\n  /// the class \\p Base.\n  ///\n  /// This routine only determines whether this class is virtually\n  /// derived from \\p Base, but does not account for factors that may\n  /// make a Derived -> Base class ill-formed, such as\n  /// private/protected inheritance or multiple, ambiguous base class\n  /// subobjects.\n  ///\n  /// \\param Base the base class we are searching for.\n  ///\n  /// \\returns true if this class is virtually derived from Base,\n  /// false otherwise.\n  bool isVirtuallyDerivedFrom(const CXXRecordDecl *Base) const;\n\n  /// Determine whether this class is provably not derived from\n  /// the type \\p Base.\n  bool isProvablyNotDerivedFrom(const CXXRecordDecl *Base) const;\n\n  /// Function type used by forallBases() as a callback.\n  ///\n  /// \\param BaseDefinition the definition of the base class\n  ///\n  /// \\returns true if this base matched the search criteria\n  using ForallBasesCallback =\n      llvm::function_ref<bool(const CXXRecordDecl *BaseDefinition)>;\n\n  /// Determines if the given callback holds for all the direct\n  /// or indirect base classes of this type.\n  ///\n  /// The class itself does not count as a base class.  This routine\n  /// returns false if the class has non-computable base classes.\n  ///\n  /// \\param BaseMatches Callback invoked for each (direct or indirect) base\n  /// class of this type until a call returns false.\n  bool forallBases(ForallBasesCallback BaseMatches) const;\n\n  /// Function type used by lookupInBases() to determine whether a\n  /// specific base class subobject matches the lookup criteria.\n  ///\n  /// \\param Specifier the base-class specifier that describes the inheritance\n  /// from the base class we are trying to match.\n  ///\n  /// \\param Path the current path, from the most-derived class down to the\n  /// base named by the \\p Specifier.\n  ///\n  /// \\returns true if this base matched the search criteria, false otherwise.\n  using BaseMatchesCallback =\n      llvm::function_ref<bool(const CXXBaseSpecifier *Specifier,\n                              CXXBasePath &Path)>;\n\n  /// Look for entities within the base classes of this C++ class,\n  /// transitively searching all base class subobjects.\n  ///\n  /// This routine uses the callback function \\p BaseMatches to find base\n  /// classes meeting some search criteria, walking all base class subobjects\n  /// and populating the given \\p Paths structure with the paths through the\n  /// inheritance hierarchy that resulted in a match. On a successful search,\n  /// the \\p Paths structure can be queried to retrieve the matching paths and\n  /// to determine if there were any ambiguities.\n  ///\n  /// \\param BaseMatches callback function used to determine whether a given\n  /// base matches the user-defined search criteria.\n  ///\n  /// \\param Paths used to record the paths from this class to its base class\n  /// subobjects that match the search criteria.\n  ///\n  /// \\param LookupInDependent can be set to true to extend the search to\n  /// dependent base classes.\n  ///\n  /// \\returns true if there exists any path from this class to a base class\n  /// subobject that matches the search criteria.\n  bool lookupInBases(BaseMatchesCallback BaseMatches, CXXBasePaths &Paths,\n                     bool LookupInDependent = false) const;\n\n  /// Base-class lookup callback that determines whether the given\n  /// base class specifier refers to a specific class declaration.\n  ///\n  /// This callback can be used with \\c lookupInBases() to determine whether\n  /// a given derived class has is a base class subobject of a particular type.\n  /// The base record pointer should refer to the canonical CXXRecordDecl of the\n  /// base class that we are searching for.\n  static bool FindBaseClass(const CXXBaseSpecifier *Specifier,\n                            CXXBasePath &Path, const CXXRecordDecl *BaseRecord);\n\n  /// Base-class lookup callback that determines whether the\n  /// given base class specifier refers to a specific class\n  /// declaration and describes virtual derivation.\n  ///\n  /// This callback can be used with \\c lookupInBases() to determine\n  /// whether a given derived class has is a virtual base class\n  /// subobject of a particular type.  The base record pointer should\n  /// refer to the canonical CXXRecordDecl of the base class that we\n  /// are searching for.\n  static bool FindVirtualBaseClass(const CXXBaseSpecifier *Specifier,\n                                   CXXBasePath &Path,\n                                   const CXXRecordDecl *BaseRecord);\n\n  /// Retrieve the final overriders for each virtual member\n  /// function in the class hierarchy where this class is the\n  /// most-derived class in the class hierarchy.\n  void getFinalOverriders(CXXFinalOverriderMap &FinaOverriders) const;\n\n  /// Get the indirect primary bases for this class.\n  void getIndirectPrimaryBases(CXXIndirectPrimaryBaseSet& Bases) const;\n\n  /// Determine whether this class has a member with the given name, possibly\n  /// in a non-dependent base class.\n  ///\n  /// No check for ambiguity is performed, so this should never be used when\n  /// implementing language semantics, but it may be appropriate for warnings,\n  /// static analysis, or similar.\n  bool hasMemberName(DeclarationName N) const;\n\n  /// Performs an imprecise lookup of a dependent name in this class.\n  ///\n  /// This function does not follow strict semantic rules and should be used\n  /// only when lookup rules can be relaxed, e.g. indexing.\n  std::vector<const NamedDecl *>\n  lookupDependentName(DeclarationName Name,\n                      llvm::function_ref<bool(const NamedDecl *ND)> Filter);\n\n  /// Renders and displays an inheritance diagram\n  /// for this C++ class and all of its base classes (transitively) using\n  /// GraphViz.\n  void viewInheritance(ASTContext& Context) const;\n\n  /// Calculates the access of a decl that is reached\n  /// along a path.\n  static AccessSpecifier MergeAccess(AccessSpecifier PathAccess,\n                                     AccessSpecifier DeclAccess) {\n    assert(DeclAccess != AS_none);\n    if (DeclAccess == AS_private) return AS_none;\n    return (PathAccess > DeclAccess ? PathAccess : DeclAccess);\n  }\n\n  /// Indicates that the declaration of a defaulted or deleted special\n  /// member function is now complete.\n  void finishedDefaultedOrDeletedMember(CXXMethodDecl *MD);\n\n  void setTrivialForCallFlags(CXXMethodDecl *MD);\n\n  /// Indicates that the definition of this class is now complete.\n  void completeDefinition() override;\n\n  /// Indicates that the definition of this class is now complete,\n  /// and provides a final overrider map to help determine\n  ///\n  /// \\param FinalOverriders The final overrider map for this class, which can\n  /// be provided as an optimization for abstract-class checking. If NULL,\n  /// final overriders will be computed if they are needed to complete the\n  /// definition.\n  void completeDefinition(CXXFinalOverriderMap *FinalOverriders);\n\n  /// Determine whether this class may end up being abstract, even though\n  /// it is not yet known to be abstract.\n  ///\n  /// \\returns true if this class is not known to be abstract but has any\n  /// base classes that are abstract. In this case, \\c completeDefinition()\n  /// will need to compute final overriders to determine whether the class is\n  /// actually abstract.\n  bool mayBeAbstract() const;\n\n  /// Determine whether it's impossible for a class to be derived from this\n  /// class. This is best-effort, and may conservatively return false.\n  bool isEffectivelyFinal() const;\n\n  /// If this is the closure type of a lambda expression, retrieve the\n  /// number to be used for name mangling in the Itanium C++ ABI.\n  ///\n  /// Zero indicates that this closure type has internal linkage, so the\n  /// mangling number does not matter, while a non-zero value indicates which\n  /// lambda expression this is in this particular context.\n  unsigned getLambdaManglingNumber() const {\n    assert(isLambda() && \"Not a lambda closure type!\");\n    return getLambdaData().ManglingNumber;\n  }\n\n  /// The lambda is known to has internal linkage no matter whether it has name\n  /// mangling number.\n  bool hasKnownLambdaInternalLinkage() const {\n    assert(isLambda() && \"Not a lambda closure type!\");\n    return getLambdaData().HasKnownInternalLinkage;\n  }\n\n  /// Retrieve the declaration that provides additional context for a\n  /// lambda, when the normal declaration context is not specific enough.\n  ///\n  /// Certain contexts (default arguments of in-class function parameters and\n  /// the initializers of data members) have separate name mangling rules for\n  /// lambdas within the Itanium C++ ABI. For these cases, this routine provides\n  /// the declaration in which the lambda occurs, e.g., the function parameter\n  /// or the non-static data member. Otherwise, it returns NULL to imply that\n  /// the declaration context suffices.\n  Decl *getLambdaContextDecl() const;\n\n  /// Set the mangling number and context declaration for a lambda\n  /// class.\n  void setLambdaMangling(unsigned ManglingNumber, Decl *ContextDecl,\n                         bool HasKnownInternalLinkage = false) {\n    assert(isLambda() && \"Not a lambda closure type!\");\n    getLambdaData().ManglingNumber = ManglingNumber;\n    getLambdaData().ContextDecl = ContextDecl;\n    getLambdaData().HasKnownInternalLinkage = HasKnownInternalLinkage;\n  }\n\n  /// Set the device side mangling number.\n  void setDeviceLambdaManglingNumber(unsigned Num) const;\n\n  /// Retrieve the device side mangling number.\n  unsigned getDeviceLambdaManglingNumber() const;\n\n  /// Returns the inheritance model used for this record.\n  MSInheritanceModel getMSInheritanceModel() const;\n\n  /// Calculate what the inheritance model would be for this class.\n  MSInheritanceModel calculateInheritanceModel() const;\n\n  /// In the Microsoft C++ ABI, use zero for the field offset of a null data\n  /// member pointer if we can guarantee that zero is not a valid field offset,\n  /// or if the member pointer has multiple fields.  Polymorphic classes have a\n  /// vfptr at offset zero, so we can use zero for null.  If there are multiple\n  /// fields, we can use zero even if it is a valid field offset because\n  /// null-ness testing will check the other fields.\n  bool nullFieldOffsetIsZero() const;\n\n  /// Controls when vtordisps will be emitted if this record is used as a\n  /// virtual base.\n  MSVtorDispMode getMSVtorDispMode() const;\n\n  /// Determine whether this lambda expression was known to be dependent\n  /// at the time it was created, even if its context does not appear to be\n  /// dependent.\n  ///\n  /// This flag is a workaround for an issue with parsing, where default\n  /// arguments are parsed before their enclosing function declarations have\n  /// been created. This means that any lambda expressions within those\n  /// default arguments will have as their DeclContext the context enclosing\n  /// the function declaration, which may be non-dependent even when the\n  /// function declaration itself is dependent. This flag indicates when we\n  /// know that the lambda is dependent despite that.\n  bool isDependentLambda() const {\n    return isLambda() && getLambdaData().Dependent;\n  }\n\n  TypeSourceInfo *getLambdaTypeInfo() const {\n    return getLambdaData().MethodTyInfo;\n  }\n\n  // Determine whether this type is an Interface Like type for\n  // __interface inheritance purposes.\n  bool isInterfaceLike() const;\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K >= firstCXXRecord && K <= lastCXXRecord;\n  }\n};\n\n/// Store information needed for an explicit specifier.\n/// Used by CXXDeductionGuideDecl, CXXConstructorDecl and CXXConversionDecl.\nclass ExplicitSpecifier {\n  llvm::PointerIntPair<Expr *, 2, ExplicitSpecKind> ExplicitSpec{\n      nullptr, ExplicitSpecKind::ResolvedFalse};\n\npublic:\n  ExplicitSpecifier() = default;\n  ExplicitSpecifier(Expr *Expression, ExplicitSpecKind Kind)\n      : ExplicitSpec(Expression, Kind) {}\n  ExplicitSpecKind getKind() const { return ExplicitSpec.getInt(); }\n  const Expr *getExpr() const { return ExplicitSpec.getPointer(); }\n  Expr *getExpr() { return ExplicitSpec.getPointer(); }\n\n  /// Determine if the declaration had an explicit specifier of any kind.\n  bool isSpecified() const {\n    return ExplicitSpec.getInt() != ExplicitSpecKind::ResolvedFalse ||\n           ExplicitSpec.getPointer();\n  }\n\n  /// Check for equivalence of explicit specifiers.\n  /// \\return true if the explicit specifier are equivalent, false otherwise.\n  bool isEquivalent(const ExplicitSpecifier Other) const;\n  /// Determine whether this specifier is known to correspond to an explicit\n  /// declaration. Returns false if the specifier is absent or has an\n  /// expression that is value-dependent or evaluates to false.\n  bool isExplicit() const {\n    return ExplicitSpec.getInt() == ExplicitSpecKind::ResolvedTrue;\n  }\n  /// Determine if the explicit specifier is invalid.\n  /// This state occurs after a substitution failures.\n  bool isInvalid() const {\n    return ExplicitSpec.getInt() == ExplicitSpecKind::Unresolved &&\n           !ExplicitSpec.getPointer();\n  }\n  void setKind(ExplicitSpecKind Kind) { ExplicitSpec.setInt(Kind); }\n  void setExpr(Expr *E) { ExplicitSpec.setPointer(E); }\n  // Retrieve the explicit specifier in the given declaration, if any.\n  static ExplicitSpecifier getFromDecl(FunctionDecl *Function);\n  static const ExplicitSpecifier getFromDecl(const FunctionDecl *Function) {\n    return getFromDecl(const_cast<FunctionDecl *>(Function));\n  }\n  static ExplicitSpecifier Invalid() {\n    return ExplicitSpecifier(nullptr, ExplicitSpecKind::Unresolved);\n  }\n};\n\n/// Represents a C++ deduction guide declaration.\n///\n/// \\code\n/// template<typename T> struct A { A(); A(T); };\n/// A() -> A<int>;\n/// \\endcode\n///\n/// In this example, there will be an explicit deduction guide from the\n/// second line, and implicit deduction guide templates synthesized from\n/// the constructors of \\c A.\nclass CXXDeductionGuideDecl : public FunctionDecl {\n  void anchor() override;\n\nprivate:\n  CXXDeductionGuideDecl(ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n                        ExplicitSpecifier ES,\n                        const DeclarationNameInfo &NameInfo, QualType T,\n                        TypeSourceInfo *TInfo, SourceLocation EndLocation)\n      : FunctionDecl(CXXDeductionGuide, C, DC, StartLoc, NameInfo, T, TInfo,\n                     SC_None, false, ConstexprSpecKind::Unspecified),\n        ExplicitSpec(ES) {\n    if (EndLocation.isValid())\n      setRangeEnd(EndLocation);\n    setIsCopyDeductionCandidate(false);\n  }\n\n  ExplicitSpecifier ExplicitSpec;\n  void setExplicitSpecifier(ExplicitSpecifier ES) { ExplicitSpec = ES; }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static CXXDeductionGuideDecl *\n  Create(ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n         ExplicitSpecifier ES, const DeclarationNameInfo &NameInfo, QualType T,\n         TypeSourceInfo *TInfo, SourceLocation EndLocation);\n\n  static CXXDeductionGuideDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  ExplicitSpecifier getExplicitSpecifier() { return ExplicitSpec; }\n  const ExplicitSpecifier getExplicitSpecifier() const { return ExplicitSpec; }\n\n  /// Return true if the declartion is already resolved to be explicit.\n  bool isExplicit() const { return ExplicitSpec.isExplicit(); }\n\n  /// Get the template for which this guide performs deduction.\n  TemplateDecl *getDeducedTemplate() const {\n    return getDeclName().getCXXDeductionGuideTemplate();\n  }\n\n  void setIsCopyDeductionCandidate(bool isCDC = true) {\n    FunctionDeclBits.IsCopyDeductionCandidate = isCDC;\n  }\n\n  bool isCopyDeductionCandidate() const {\n    return FunctionDeclBits.IsCopyDeductionCandidate;\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == CXXDeductionGuide; }\n};\n\n/// \\brief Represents the body of a requires-expression.\n///\n/// This decl exists merely to serve as the DeclContext for the local\n/// parameters of the requires expression as well as other declarations inside\n/// it.\n///\n/// \\code\n/// template<typename T> requires requires (T t) { {t++} -> regular; }\n/// \\endcode\n///\n/// In this example, a RequiresExpr object will be generated for the expression,\n/// and a RequiresExprBodyDecl will be created to hold the parameter t and the\n/// template argument list imposed by the compound requirement.\nclass RequiresExprBodyDecl : public Decl, public DeclContext {\n  RequiresExprBodyDecl(ASTContext &C, DeclContext *DC, SourceLocation StartLoc)\n      : Decl(RequiresExprBody, DC, StartLoc), DeclContext(RequiresExprBody) {}\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static RequiresExprBodyDecl *Create(ASTContext &C, DeclContext *DC,\n                                      SourceLocation StartLoc);\n\n  static RequiresExprBodyDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == RequiresExprBody; }\n};\n\n/// Represents a static or instance method of a struct/union/class.\n///\n/// In the terminology of the C++ Standard, these are the (static and\n/// non-static) member functions, whether virtual or not.\nclass CXXMethodDecl : public FunctionDecl {\n  void anchor() override;\n\nprotected:\n  CXXMethodDecl(Kind DK, ASTContext &C, CXXRecordDecl *RD,\n                SourceLocation StartLoc, const DeclarationNameInfo &NameInfo,\n                QualType T, TypeSourceInfo *TInfo, StorageClass SC,\n                bool isInline, ConstexprSpecKind ConstexprKind,\n                SourceLocation EndLocation,\n                Expr *TrailingRequiresClause = nullptr)\n      : FunctionDecl(DK, C, RD, StartLoc, NameInfo, T, TInfo, SC, isInline,\n                     ConstexprKind, TrailingRequiresClause) {\n    if (EndLocation.isValid())\n      setRangeEnd(EndLocation);\n  }\n\npublic:\n  static CXXMethodDecl *Create(ASTContext &C, CXXRecordDecl *RD,\n                               SourceLocation StartLoc,\n                               const DeclarationNameInfo &NameInfo, QualType T,\n                               TypeSourceInfo *TInfo, StorageClass SC,\n                               bool isInline, ConstexprSpecKind ConstexprKind,\n                               SourceLocation EndLocation,\n                               Expr *TrailingRequiresClause = nullptr);\n\n  static CXXMethodDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  bool isStatic() const;\n  bool isInstance() const { return !isStatic(); }\n\n  /// Returns true if the given operator is implicitly static in a record\n  /// context.\n  static bool isStaticOverloadedOperator(OverloadedOperatorKind OOK) {\n    // [class.free]p1:\n    // Any allocation function for a class T is a static member\n    // (even if not explicitly declared static).\n    // [class.free]p6 Any deallocation function for a class X is a static member\n    // (even if not explicitly declared static).\n    return OOK == OO_New || OOK == OO_Array_New || OOK == OO_Delete ||\n           OOK == OO_Array_Delete;\n  }\n\n  bool isConst() const { return getType()->castAs<FunctionType>()->isConst(); }\n  bool isVolatile() const { return getType()->castAs<FunctionType>()->isVolatile(); }\n\n  bool isVirtual() const {\n    CXXMethodDecl *CD = const_cast<CXXMethodDecl*>(this)->getCanonicalDecl();\n\n    // Member function is virtual if it is marked explicitly so, or if it is\n    // declared in __interface -- then it is automatically pure virtual.\n    if (CD->isVirtualAsWritten() || CD->isPure())\n      return true;\n\n    return CD->size_overridden_methods() != 0;\n  }\n\n  /// If it's possible to devirtualize a call to this method, return the called\n  /// function. Otherwise, return null.\n\n  /// \\param Base The object on which this virtual function is called.\n  /// \\param IsAppleKext True if we are compiling for Apple kext.\n  CXXMethodDecl *getDevirtualizedMethod(const Expr *Base, bool IsAppleKext);\n\n  const CXXMethodDecl *getDevirtualizedMethod(const Expr *Base,\n                                              bool IsAppleKext) const {\n    return const_cast<CXXMethodDecl *>(this)->getDevirtualizedMethod(\n        Base, IsAppleKext);\n  }\n\n  /// Determine whether this is a usual deallocation function (C++\n  /// [basic.stc.dynamic.deallocation]p2), which is an overloaded delete or\n  /// delete[] operator with a particular signature. Populates \\p PreventedBy\n  /// with the declarations of the functions of the same kind if they were the\n  /// reason for this function returning false. This is used by\n  /// Sema::isUsualDeallocationFunction to reconsider the answer based on the\n  /// context.\n  bool isUsualDeallocationFunction(\n      SmallVectorImpl<const FunctionDecl *> &PreventedBy) const;\n\n  /// Determine whether this is a copy-assignment operator, regardless\n  /// of whether it was declared implicitly or explicitly.\n  bool isCopyAssignmentOperator() const;\n\n  /// Determine whether this is a move assignment operator.\n  bool isMoveAssignmentOperator() const;\n\n  CXXMethodDecl *getCanonicalDecl() override {\n    return cast<CXXMethodDecl>(FunctionDecl::getCanonicalDecl());\n  }\n  const CXXMethodDecl *getCanonicalDecl() const {\n    return const_cast<CXXMethodDecl*>(this)->getCanonicalDecl();\n  }\n\n  CXXMethodDecl *getMostRecentDecl() {\n    return cast<CXXMethodDecl>(\n            static_cast<FunctionDecl *>(this)->getMostRecentDecl());\n  }\n  const CXXMethodDecl *getMostRecentDecl() const {\n    return const_cast<CXXMethodDecl*>(this)->getMostRecentDecl();\n  }\n\n  void addOverriddenMethod(const CXXMethodDecl *MD);\n\n  using method_iterator = const CXXMethodDecl *const *;\n\n  method_iterator begin_overridden_methods() const;\n  method_iterator end_overridden_methods() const;\n  unsigned size_overridden_methods() const;\n\n  using overridden_method_range = llvm::iterator_range<\n      llvm::TinyPtrVector<const CXXMethodDecl *>::const_iterator>;\n\n  overridden_method_range overridden_methods() const;\n\n  /// Return the parent of this method declaration, which\n  /// is the class in which this method is defined.\n  const CXXRecordDecl *getParent() const {\n    return cast<CXXRecordDecl>(FunctionDecl::getParent());\n  }\n\n  /// Return the parent of this method declaration, which\n  /// is the class in which this method is defined.\n  CXXRecordDecl *getParent() {\n    return const_cast<CXXRecordDecl *>(\n             cast<CXXRecordDecl>(FunctionDecl::getParent()));\n  }\n\n  /// Return the type of the \\c this pointer.\n  ///\n  /// Should only be called for instance (i.e., non-static) methods. Note\n  /// that for the call operator of a lambda closure type, this returns the\n  /// desugared 'this' type (a pointer to the closure type), not the captured\n  /// 'this' type.\n  QualType getThisType() const;\n\n  /// Return the type of the object pointed by \\c this.\n  ///\n  /// See getThisType() for usage restriction.\n  QualType getThisObjectType() const;\n\n  static QualType getThisType(const FunctionProtoType *FPT,\n                              const CXXRecordDecl *Decl);\n\n  static QualType getThisObjectType(const FunctionProtoType *FPT,\n                                    const CXXRecordDecl *Decl);\n\n  Qualifiers getMethodQualifiers() const {\n    return getType()->castAs<FunctionProtoType>()->getMethodQuals();\n  }\n\n  /// Retrieve the ref-qualifier associated with this method.\n  ///\n  /// In the following example, \\c f() has an lvalue ref-qualifier, \\c g()\n  /// has an rvalue ref-qualifier, and \\c h() has no ref-qualifier.\n  /// @code\n  /// struct X {\n  ///   void f() &;\n  ///   void g() &&;\n  ///   void h();\n  /// };\n  /// @endcode\n  RefQualifierKind getRefQualifier() const {\n    return getType()->castAs<FunctionProtoType>()->getRefQualifier();\n  }\n\n  bool hasInlineBody() const;\n\n  /// Determine whether this is a lambda closure type's static member\n  /// function that is used for the result of the lambda's conversion to\n  /// function pointer (for a lambda with no captures).\n  ///\n  /// The function itself, if used, will have a placeholder body that will be\n  /// supplied by IR generation to either forward to the function call operator\n  /// or clone the function call operator.\n  bool isLambdaStaticInvoker() const;\n\n  /// Find the method in \\p RD that corresponds to this one.\n  ///\n  /// Find if \\p RD or one of the classes it inherits from override this method.\n  /// If so, return it. \\p RD is assumed to be a subclass of the class defining\n  /// this method (or be the class itself), unless \\p MayBeBase is set to true.\n  CXXMethodDecl *\n  getCorrespondingMethodInClass(const CXXRecordDecl *RD,\n                                bool MayBeBase = false);\n\n  const CXXMethodDecl *\n  getCorrespondingMethodInClass(const CXXRecordDecl *RD,\n                                bool MayBeBase = false) const {\n    return const_cast<CXXMethodDecl *>(this)\n              ->getCorrespondingMethodInClass(RD, MayBeBase);\n  }\n\n  /// Find if \\p RD declares a function that overrides this function, and if so,\n  /// return it. Does not search base classes.\n  CXXMethodDecl *getCorrespondingMethodDeclaredInClass(const CXXRecordDecl *RD,\n                                                       bool MayBeBase = false);\n  const CXXMethodDecl *\n  getCorrespondingMethodDeclaredInClass(const CXXRecordDecl *RD,\n                                        bool MayBeBase = false) const {\n    return const_cast<CXXMethodDecl *>(this)\n        ->getCorrespondingMethodDeclaredInClass(RD, MayBeBase);\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K >= firstCXXMethod && K <= lastCXXMethod;\n  }\n};\n\n/// Represents a C++ base or member initializer.\n///\n/// This is part of a constructor initializer that\n/// initializes one non-static member variable or one base class. For\n/// example, in the following, both 'A(a)' and 'f(3.14159)' are member\n/// initializers:\n///\n/// \\code\n/// class A { };\n/// class B : public A {\n///   float f;\n/// public:\n///   B(A& a) : A(a), f(3.14159) { }\n/// };\n/// \\endcode\nclass CXXCtorInitializer final {\n  /// Either the base class name/delegating constructor type (stored as\n  /// a TypeSourceInfo*), an normal field (FieldDecl), or an anonymous field\n  /// (IndirectFieldDecl*) being initialized.\n  llvm::PointerUnion<TypeSourceInfo *, FieldDecl *, IndirectFieldDecl *>\n      Initializee;\n\n  /// The argument used to initialize the base or member, which may\n  /// end up constructing an object (when multiple arguments are involved).\n  Stmt *Init;\n\n  /// The source location for the field name or, for a base initializer\n  /// pack expansion, the location of the ellipsis.\n  ///\n  /// In the case of a delegating\n  /// constructor, it will still include the type's source location as the\n  /// Initializee points to the CXXConstructorDecl (to allow loop detection).\n  SourceLocation MemberOrEllipsisLocation;\n\n  /// Location of the left paren of the ctor-initializer.\n  SourceLocation LParenLoc;\n\n  /// Location of the right paren of the ctor-initializer.\n  SourceLocation RParenLoc;\n\n  /// If the initializee is a type, whether that type makes this\n  /// a delegating initialization.\n  unsigned IsDelegating : 1;\n\n  /// If the initializer is a base initializer, this keeps track\n  /// of whether the base is virtual or not.\n  unsigned IsVirtual : 1;\n\n  /// Whether or not the initializer is explicitly written\n  /// in the sources.\n  unsigned IsWritten : 1;\n\n  /// If IsWritten is true, then this number keeps track of the textual order\n  /// of this initializer in the original sources, counting from 0.\n  unsigned SourceOrder : 13;\n\npublic:\n  /// Creates a new base-class initializer.\n  explicit\n  CXXCtorInitializer(ASTContext &Context, TypeSourceInfo *TInfo, bool IsVirtual,\n                     SourceLocation L, Expr *Init, SourceLocation R,\n                     SourceLocation EllipsisLoc);\n\n  /// Creates a new member initializer.\n  explicit\n  CXXCtorInitializer(ASTContext &Context, FieldDecl *Member,\n                     SourceLocation MemberLoc, SourceLocation L, Expr *Init,\n                     SourceLocation R);\n\n  /// Creates a new anonymous field initializer.\n  explicit\n  CXXCtorInitializer(ASTContext &Context, IndirectFieldDecl *Member,\n                     SourceLocation MemberLoc, SourceLocation L, Expr *Init,\n                     SourceLocation R);\n\n  /// Creates a new delegating initializer.\n  explicit\n  CXXCtorInitializer(ASTContext &Context, TypeSourceInfo *TInfo,\n                     SourceLocation L, Expr *Init, SourceLocation R);\n\n  /// \\return Unique reproducible object identifier.\n  int64_t getID(const ASTContext &Context) const;\n\n  /// Determine whether this initializer is initializing a base class.\n  bool isBaseInitializer() const {\n    return Initializee.is<TypeSourceInfo*>() && !IsDelegating;\n  }\n\n  /// Determine whether this initializer is initializing a non-static\n  /// data member.\n  bool isMemberInitializer() const { return Initializee.is<FieldDecl*>(); }\n\n  bool isAnyMemberInitializer() const {\n    return isMemberInitializer() || isIndirectMemberInitializer();\n  }\n\n  bool isIndirectMemberInitializer() const {\n    return Initializee.is<IndirectFieldDecl*>();\n  }\n\n  /// Determine whether this initializer is an implicit initializer\n  /// generated for a field with an initializer defined on the member\n  /// declaration.\n  ///\n  /// In-class member initializers (also known as \"non-static data member\n  /// initializations\", NSDMIs) were introduced in C++11.\n  bool isInClassMemberInitializer() const {\n    return Init->getStmtClass() == Stmt::CXXDefaultInitExprClass;\n  }\n\n  /// Determine whether this initializer is creating a delegating\n  /// constructor.\n  bool isDelegatingInitializer() const {\n    return Initializee.is<TypeSourceInfo*>() && IsDelegating;\n  }\n\n  /// Determine whether this initializer is a pack expansion.\n  bool isPackExpansion() const {\n    return isBaseInitializer() && MemberOrEllipsisLocation.isValid();\n  }\n\n  // For a pack expansion, returns the location of the ellipsis.\n  SourceLocation getEllipsisLoc() const {\n    assert(isPackExpansion() && \"Initializer is not a pack expansion\");\n    return MemberOrEllipsisLocation;\n  }\n\n  /// If this is a base class initializer, returns the type of the\n  /// base class with location information. Otherwise, returns an NULL\n  /// type location.\n  TypeLoc getBaseClassLoc() const;\n\n  /// If this is a base class initializer, returns the type of the base class.\n  /// Otherwise, returns null.\n  const Type *getBaseClass() const;\n\n  /// Returns whether the base is virtual or not.\n  bool isBaseVirtual() const {\n    assert(isBaseInitializer() && \"Must call this on base initializer!\");\n\n    return IsVirtual;\n  }\n\n  /// Returns the declarator information for a base class or delegating\n  /// initializer.\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return Initializee.dyn_cast<TypeSourceInfo *>();\n  }\n\n  /// If this is a member initializer, returns the declaration of the\n  /// non-static data member being initialized. Otherwise, returns null.\n  FieldDecl *getMember() const {\n    if (isMemberInitializer())\n      return Initializee.get<FieldDecl*>();\n    return nullptr;\n  }\n\n  FieldDecl *getAnyMember() const {\n    if (isMemberInitializer())\n      return Initializee.get<FieldDecl*>();\n    if (isIndirectMemberInitializer())\n      return Initializee.get<IndirectFieldDecl*>()->getAnonField();\n    return nullptr;\n  }\n\n  IndirectFieldDecl *getIndirectMember() const {\n    if (isIndirectMemberInitializer())\n      return Initializee.get<IndirectFieldDecl*>();\n    return nullptr;\n  }\n\n  SourceLocation getMemberLocation() const {\n    return MemberOrEllipsisLocation;\n  }\n\n  /// Determine the source location of the initializer.\n  SourceLocation getSourceLocation() const;\n\n  /// Determine the source range covering the entire initializer.\n  SourceRange getSourceRange() const LLVM_READONLY;\n\n  /// Determine whether this initializer is explicitly written\n  /// in the source code.\n  bool isWritten() const { return IsWritten; }\n\n  /// Return the source position of the initializer, counting from 0.\n  /// If the initializer was implicit, -1 is returned.\n  int getSourceOrder() const {\n    return IsWritten ? static_cast<int>(SourceOrder) : -1;\n  }\n\n  /// Set the source order of this initializer.\n  ///\n  /// This can only be called once for each initializer; it cannot be called\n  /// on an initializer having a positive number of (implicit) array indices.\n  ///\n  /// This assumes that the initializer was written in the source code, and\n  /// ensures that isWritten() returns true.\n  void setSourceOrder(int Pos) {\n    assert(!IsWritten &&\n           \"setSourceOrder() used on implicit initializer\");\n    assert(SourceOrder == 0 &&\n           \"calling twice setSourceOrder() on the same initializer\");\n    assert(Pos >= 0 &&\n           \"setSourceOrder() used to make an initializer implicit\");\n    IsWritten = true;\n    SourceOrder = static_cast<unsigned>(Pos);\n  }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n\n  /// Get the initializer.\n  Expr *getInit() const { return static_cast<Expr *>(Init); }\n};\n\n/// Description of a constructor that was inherited from a base class.\nclass InheritedConstructor {\n  ConstructorUsingShadowDecl *Shadow = nullptr;\n  CXXConstructorDecl *BaseCtor = nullptr;\n\npublic:\n  InheritedConstructor() = default;\n  InheritedConstructor(ConstructorUsingShadowDecl *Shadow,\n                       CXXConstructorDecl *BaseCtor)\n      : Shadow(Shadow), BaseCtor(BaseCtor) {}\n\n  explicit operator bool() const { return Shadow; }\n\n  ConstructorUsingShadowDecl *getShadowDecl() const { return Shadow; }\n  CXXConstructorDecl *getConstructor() const { return BaseCtor; }\n};\n\n/// Represents a C++ constructor within a class.\n///\n/// For example:\n///\n/// \\code\n/// class X {\n/// public:\n///   explicit X(int); // represented by a CXXConstructorDecl.\n/// };\n/// \\endcode\nclass CXXConstructorDecl final\n    : public CXXMethodDecl,\n      private llvm::TrailingObjects<CXXConstructorDecl, InheritedConstructor,\n                                    ExplicitSpecifier> {\n  // This class stores some data in DeclContext::CXXConstructorDeclBits\n  // to save some space. Use the provided accessors to access it.\n\n  /// \\name Support for base and member initializers.\n  /// \\{\n  /// The arguments used to initialize the base or member.\n  LazyCXXCtorInitializersPtr CtorInitializers;\n\n  CXXConstructorDecl(ASTContext &C, CXXRecordDecl *RD, SourceLocation StartLoc,\n                     const DeclarationNameInfo &NameInfo, QualType T,\n                     TypeSourceInfo *TInfo, ExplicitSpecifier ES, bool isInline,\n                     bool isImplicitlyDeclared, ConstexprSpecKind ConstexprKind,\n                     InheritedConstructor Inherited,\n                     Expr *TrailingRequiresClause);\n\n  void anchor() override;\n\n  size_t numTrailingObjects(OverloadToken<InheritedConstructor>) const {\n    return CXXConstructorDeclBits.IsInheritingConstructor;\n  }\n  size_t numTrailingObjects(OverloadToken<ExplicitSpecifier>) const {\n    return CXXConstructorDeclBits.HasTrailingExplicitSpecifier;\n  }\n\n  ExplicitSpecifier getExplicitSpecifierInternal() const {\n    if (CXXConstructorDeclBits.HasTrailingExplicitSpecifier)\n      return *getTrailingObjects<ExplicitSpecifier>();\n    return ExplicitSpecifier(\n        nullptr, CXXConstructorDeclBits.IsSimpleExplicit\n                     ? ExplicitSpecKind::ResolvedTrue\n                     : ExplicitSpecKind::ResolvedFalse);\n  }\n\n  enum TraillingAllocKind {\n    TAKInheritsConstructor = 1,\n    TAKHasTailExplicit = 1 << 1,\n  };\n\n  uint64_t getTraillingAllocKind() const {\n    return numTrailingObjects(OverloadToken<InheritedConstructor>()) |\n           (numTrailingObjects(OverloadToken<ExplicitSpecifier>()) << 1);\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend TrailingObjects;\n\n  static CXXConstructorDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                                uint64_t AllocKind);\n  static CXXConstructorDecl *\n  Create(ASTContext &C, CXXRecordDecl *RD, SourceLocation StartLoc,\n         const DeclarationNameInfo &NameInfo, QualType T, TypeSourceInfo *TInfo,\n         ExplicitSpecifier ES, bool isInline, bool isImplicitlyDeclared,\n         ConstexprSpecKind ConstexprKind,\n         InheritedConstructor Inherited = InheritedConstructor(),\n         Expr *TrailingRequiresClause = nullptr);\n\n  void setExplicitSpecifier(ExplicitSpecifier ES) {\n    assert((!ES.getExpr() ||\n            CXXConstructorDeclBits.HasTrailingExplicitSpecifier) &&\n           \"cannot set this explicit specifier. no trail-allocated space for \"\n           \"explicit\");\n    if (ES.getExpr())\n      *getCanonicalDecl()->getTrailingObjects<ExplicitSpecifier>() = ES;\n    else\n      CXXConstructorDeclBits.IsSimpleExplicit = ES.isExplicit();\n  }\n\n  ExplicitSpecifier getExplicitSpecifier() {\n    return getCanonicalDecl()->getExplicitSpecifierInternal();\n  }\n  const ExplicitSpecifier getExplicitSpecifier() const {\n    return getCanonicalDecl()->getExplicitSpecifierInternal();\n  }\n\n  /// Return true if the declartion is already resolved to be explicit.\n  bool isExplicit() const { return getExplicitSpecifier().isExplicit(); }\n\n  /// Iterates through the member/base initializer list.\n  using init_iterator = CXXCtorInitializer **;\n\n  /// Iterates through the member/base initializer list.\n  using init_const_iterator = CXXCtorInitializer *const *;\n\n  using init_range = llvm::iterator_range<init_iterator>;\n  using init_const_range = llvm::iterator_range<init_const_iterator>;\n\n  init_range inits() { return init_range(init_begin(), init_end()); }\n  init_const_range inits() const {\n    return init_const_range(init_begin(), init_end());\n  }\n\n  /// Retrieve an iterator to the first initializer.\n  init_iterator init_begin() {\n    const auto *ConstThis = this;\n    return const_cast<init_iterator>(ConstThis->init_begin());\n  }\n\n  /// Retrieve an iterator to the first initializer.\n  init_const_iterator init_begin() const;\n\n  /// Retrieve an iterator past the last initializer.\n  init_iterator       init_end()       {\n    return init_begin() + getNumCtorInitializers();\n  }\n\n  /// Retrieve an iterator past the last initializer.\n  init_const_iterator init_end() const {\n    return init_begin() + getNumCtorInitializers();\n  }\n\n  using init_reverse_iterator = std::reverse_iterator<init_iterator>;\n  using init_const_reverse_iterator =\n      std::reverse_iterator<init_const_iterator>;\n\n  init_reverse_iterator init_rbegin() {\n    return init_reverse_iterator(init_end());\n  }\n  init_const_reverse_iterator init_rbegin() const {\n    return init_const_reverse_iterator(init_end());\n  }\n\n  init_reverse_iterator init_rend() {\n    return init_reverse_iterator(init_begin());\n  }\n  init_const_reverse_iterator init_rend() const {\n    return init_const_reverse_iterator(init_begin());\n  }\n\n  /// Determine the number of arguments used to initialize the member\n  /// or base.\n  unsigned getNumCtorInitializers() const {\n      return CXXConstructorDeclBits.NumCtorInitializers;\n  }\n\n  void setNumCtorInitializers(unsigned numCtorInitializers) {\n    CXXConstructorDeclBits.NumCtorInitializers = numCtorInitializers;\n    // This assert added because NumCtorInitializers is stored\n    // in CXXConstructorDeclBits as a bitfield and its width has\n    // been shrunk from 32 bits to fit into CXXConstructorDeclBitfields.\n    assert(CXXConstructorDeclBits.NumCtorInitializers ==\n           numCtorInitializers && \"NumCtorInitializers overflow!\");\n  }\n\n  void setCtorInitializers(CXXCtorInitializer **Initializers) {\n    CtorInitializers = Initializers;\n  }\n\n  /// Determine whether this constructor is a delegating constructor.\n  bool isDelegatingConstructor() const {\n    return (getNumCtorInitializers() == 1) &&\n           init_begin()[0]->isDelegatingInitializer();\n  }\n\n  /// When this constructor delegates to another, retrieve the target.\n  CXXConstructorDecl *getTargetConstructor() const;\n\n  /// Whether this constructor is a default\n  /// constructor (C++ [class.ctor]p5), which can be used to\n  /// default-initialize a class of this type.\n  bool isDefaultConstructor() const;\n\n  /// Whether this constructor is a copy constructor (C++ [class.copy]p2,\n  /// which can be used to copy the class.\n  ///\n  /// \\p TypeQuals will be set to the qualifiers on the\n  /// argument type. For example, \\p TypeQuals would be set to \\c\n  /// Qualifiers::Const for the following copy constructor:\n  ///\n  /// \\code\n  /// class X {\n  /// public:\n  ///   X(const X&);\n  /// };\n  /// \\endcode\n  bool isCopyConstructor(unsigned &TypeQuals) const;\n\n  /// Whether this constructor is a copy\n  /// constructor (C++ [class.copy]p2, which can be used to copy the\n  /// class.\n  bool isCopyConstructor() const {\n    unsigned TypeQuals = 0;\n    return isCopyConstructor(TypeQuals);\n  }\n\n  /// Determine whether this constructor is a move constructor\n  /// (C++11 [class.copy]p3), which can be used to move values of the class.\n  ///\n  /// \\param TypeQuals If this constructor is a move constructor, will be set\n  /// to the type qualifiers on the referent of the first parameter's type.\n  bool isMoveConstructor(unsigned &TypeQuals) const;\n\n  /// Determine whether this constructor is a move constructor\n  /// (C++11 [class.copy]p3), which can be used to move values of the class.\n  bool isMoveConstructor() const {\n    unsigned TypeQuals = 0;\n    return isMoveConstructor(TypeQuals);\n  }\n\n  /// Determine whether this is a copy or move constructor.\n  ///\n  /// \\param TypeQuals Will be set to the type qualifiers on the reference\n  /// parameter, if in fact this is a copy or move constructor.\n  bool isCopyOrMoveConstructor(unsigned &TypeQuals) const;\n\n  /// Determine whether this a copy or move constructor.\n  bool isCopyOrMoveConstructor() const {\n    unsigned Quals;\n    return isCopyOrMoveConstructor(Quals);\n  }\n\n  /// Whether this constructor is a\n  /// converting constructor (C++ [class.conv.ctor]), which can be\n  /// used for user-defined conversions.\n  bool isConvertingConstructor(bool AllowExplicit) const;\n\n  /// Determine whether this is a member template specialization that\n  /// would copy the object to itself. Such constructors are never used to copy\n  /// an object.\n  bool isSpecializationCopyingObject() const;\n\n  /// Determine whether this is an implicit constructor synthesized to\n  /// model a call to a constructor inherited from a base class.\n  bool isInheritingConstructor() const {\n    return CXXConstructorDeclBits.IsInheritingConstructor;\n  }\n\n  /// State that this is an implicit constructor synthesized to\n  /// model a call to a constructor inherited from a base class.\n  void setInheritingConstructor(bool isIC = true) {\n    CXXConstructorDeclBits.IsInheritingConstructor = isIC;\n  }\n\n  /// Get the constructor that this inheriting constructor is based on.\n  InheritedConstructor getInheritedConstructor() const {\n    return isInheritingConstructor() ?\n      *getTrailingObjects<InheritedConstructor>() : InheritedConstructor();\n  }\n\n  CXXConstructorDecl *getCanonicalDecl() override {\n    return cast<CXXConstructorDecl>(FunctionDecl::getCanonicalDecl());\n  }\n  const CXXConstructorDecl *getCanonicalDecl() const {\n    return const_cast<CXXConstructorDecl*>(this)->getCanonicalDecl();\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == CXXConstructor; }\n};\n\n/// Represents a C++ destructor within a class.\n///\n/// For example:\n///\n/// \\code\n/// class X {\n/// public:\n///   ~X(); // represented by a CXXDestructorDecl.\n/// };\n/// \\endcode\nclass CXXDestructorDecl : public CXXMethodDecl {\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  // FIXME: Don't allocate storage for these except in the first declaration\n  // of a virtual destructor.\n  FunctionDecl *OperatorDelete = nullptr;\n  Expr *OperatorDeleteThisArg = nullptr;\n\n  CXXDestructorDecl(ASTContext &C, CXXRecordDecl *RD, SourceLocation StartLoc,\n                    const DeclarationNameInfo &NameInfo, QualType T,\n                    TypeSourceInfo *TInfo, bool isInline,\n                    bool isImplicitlyDeclared, ConstexprSpecKind ConstexprKind,\n                    Expr *TrailingRequiresClause = nullptr)\n      : CXXMethodDecl(CXXDestructor, C, RD, StartLoc, NameInfo, T, TInfo,\n                      SC_None, isInline, ConstexprKind, SourceLocation(),\n                      TrailingRequiresClause) {\n    setImplicit(isImplicitlyDeclared);\n  }\n\n  void anchor() override;\n\npublic:\n  static CXXDestructorDecl *Create(ASTContext &C, CXXRecordDecl *RD,\n                                   SourceLocation StartLoc,\n                                   const DeclarationNameInfo &NameInfo,\n                                   QualType T, TypeSourceInfo *TInfo,\n                                   bool isInline, bool isImplicitlyDeclared,\n                                   ConstexprSpecKind ConstexprKind,\n                                   Expr *TrailingRequiresClause = nullptr);\n  static CXXDestructorDecl *CreateDeserialized(ASTContext & C, unsigned ID);\n\n  void setOperatorDelete(FunctionDecl *OD, Expr *ThisArg);\n\n  const FunctionDecl *getOperatorDelete() const {\n    return getCanonicalDecl()->OperatorDelete;\n  }\n\n  Expr *getOperatorDeleteThisArg() const {\n    return getCanonicalDecl()->OperatorDeleteThisArg;\n  }\n\n  CXXDestructorDecl *getCanonicalDecl() override {\n    return cast<CXXDestructorDecl>(FunctionDecl::getCanonicalDecl());\n  }\n  const CXXDestructorDecl *getCanonicalDecl() const {\n    return const_cast<CXXDestructorDecl*>(this)->getCanonicalDecl();\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == CXXDestructor; }\n};\n\n/// Represents a C++ conversion function within a class.\n///\n/// For example:\n///\n/// \\code\n/// class X {\n/// public:\n///   operator bool();\n/// };\n/// \\endcode\nclass CXXConversionDecl : public CXXMethodDecl {\n  CXXConversionDecl(ASTContext &C, CXXRecordDecl *RD, SourceLocation StartLoc,\n                    const DeclarationNameInfo &NameInfo, QualType T,\n                    TypeSourceInfo *TInfo, bool isInline, ExplicitSpecifier ES,\n                    ConstexprSpecKind ConstexprKind, SourceLocation EndLocation,\n                    Expr *TrailingRequiresClause = nullptr)\n      : CXXMethodDecl(CXXConversion, C, RD, StartLoc, NameInfo, T, TInfo,\n                      SC_None, isInline, ConstexprKind, EndLocation,\n                      TrailingRequiresClause),\n        ExplicitSpec(ES) {}\n  void anchor() override;\n\n  ExplicitSpecifier ExplicitSpec;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static CXXConversionDecl *\n  Create(ASTContext &C, CXXRecordDecl *RD, SourceLocation StartLoc,\n         const DeclarationNameInfo &NameInfo, QualType T, TypeSourceInfo *TInfo,\n         bool isInline, ExplicitSpecifier ES, ConstexprSpecKind ConstexprKind,\n         SourceLocation EndLocation, Expr *TrailingRequiresClause = nullptr);\n  static CXXConversionDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  ExplicitSpecifier getExplicitSpecifier() {\n    return getCanonicalDecl()->ExplicitSpec;\n  }\n\n  const ExplicitSpecifier getExplicitSpecifier() const {\n    return getCanonicalDecl()->ExplicitSpec;\n  }\n\n  /// Return true if the declartion is already resolved to be explicit.\n  bool isExplicit() const { return getExplicitSpecifier().isExplicit(); }\n  void setExplicitSpecifier(ExplicitSpecifier ES) { ExplicitSpec = ES; }\n\n  /// Returns the type that this conversion function is converting to.\n  QualType getConversionType() const {\n    return getType()->castAs<FunctionType>()->getReturnType();\n  }\n\n  /// Determine whether this conversion function is a conversion from\n  /// a lambda closure type to a block pointer.\n  bool isLambdaToBlockPointerConversion() const;\n\n  CXXConversionDecl *getCanonicalDecl() override {\n    return cast<CXXConversionDecl>(FunctionDecl::getCanonicalDecl());\n  }\n  const CXXConversionDecl *getCanonicalDecl() const {\n    return const_cast<CXXConversionDecl*>(this)->getCanonicalDecl();\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == CXXConversion; }\n};\n\n/// Represents a linkage specification.\n///\n/// For example:\n/// \\code\n///   extern \"C\" void foo();\n/// \\endcode\nclass LinkageSpecDecl : public Decl, public DeclContext {\n  virtual void anchor();\n  // This class stores some data in DeclContext::LinkageSpecDeclBits to save\n  // some space. Use the provided accessors to access it.\npublic:\n  /// Represents the language in a linkage specification.\n  ///\n  /// The values are part of the serialization ABI for\n  /// ASTs and cannot be changed without altering that ABI.\n  enum LanguageIDs { lang_c = 1, lang_cxx = 2 };\n\nprivate:\n  /// The source location for the extern keyword.\n  SourceLocation ExternLoc;\n\n  /// The source location for the right brace (if valid).\n  SourceLocation RBraceLoc;\n\n  LinkageSpecDecl(DeclContext *DC, SourceLocation ExternLoc,\n                  SourceLocation LangLoc, LanguageIDs lang, bool HasBraces);\n\npublic:\n  static LinkageSpecDecl *Create(ASTContext &C, DeclContext *DC,\n                                 SourceLocation ExternLoc,\n                                 SourceLocation LangLoc, LanguageIDs Lang,\n                                 bool HasBraces);\n  static LinkageSpecDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// Return the language specified by this linkage specification.\n  LanguageIDs getLanguage() const {\n    return static_cast<LanguageIDs>(LinkageSpecDeclBits.Language);\n  }\n\n  /// Set the language specified by this linkage specification.\n  void setLanguage(LanguageIDs L) { LinkageSpecDeclBits.Language = L; }\n\n  /// Determines whether this linkage specification had braces in\n  /// its syntactic form.\n  bool hasBraces() const {\n    assert(!RBraceLoc.isValid() || LinkageSpecDeclBits.HasBraces);\n    return LinkageSpecDeclBits.HasBraces;\n  }\n\n  SourceLocation getExternLoc() const { return ExternLoc; }\n  SourceLocation getRBraceLoc() const { return RBraceLoc; }\n  void setExternLoc(SourceLocation L) { ExternLoc = L; }\n  void setRBraceLoc(SourceLocation L) {\n    RBraceLoc = L;\n    LinkageSpecDeclBits.HasBraces = RBraceLoc.isValid();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    if (hasBraces())\n      return getRBraceLoc();\n    // No braces: get the end location of the (only) declaration in context\n    // (if present).\n    return decls_empty() ? getLocation() : decls_begin()->getEndLoc();\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(ExternLoc, getEndLoc());\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == LinkageSpec; }\n\n  static DeclContext *castToDeclContext(const LinkageSpecDecl *D) {\n    return static_cast<DeclContext *>(const_cast<LinkageSpecDecl*>(D));\n  }\n\n  static LinkageSpecDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<LinkageSpecDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Represents C++ using-directive.\n///\n/// For example:\n/// \\code\n///    using namespace std;\n/// \\endcode\n///\n/// \\note UsingDirectiveDecl should be Decl not NamedDecl, but we provide\n/// artificial names for all using-directives in order to store\n/// them in DeclContext effectively.\nclass UsingDirectiveDecl : public NamedDecl {\n  /// The location of the \\c using keyword.\n  SourceLocation UsingLoc;\n\n  /// The location of the \\c namespace keyword.\n  SourceLocation NamespaceLoc;\n\n  /// The nested-name-specifier that precedes the namespace.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// The namespace nominated by this using-directive.\n  NamedDecl *NominatedNamespace;\n\n  /// Enclosing context containing both using-directive and nominated\n  /// namespace.\n  DeclContext *CommonAncestor;\n\n  UsingDirectiveDecl(DeclContext *DC, SourceLocation UsingLoc,\n                     SourceLocation NamespcLoc,\n                     NestedNameSpecifierLoc QualifierLoc,\n                     SourceLocation IdentLoc,\n                     NamedDecl *Nominated,\n                     DeclContext *CommonAncestor)\n      : NamedDecl(UsingDirective, DC, IdentLoc, getName()), UsingLoc(UsingLoc),\n        NamespaceLoc(NamespcLoc), QualifierLoc(QualifierLoc),\n        NominatedNamespace(Nominated), CommonAncestor(CommonAncestor) {}\n\n  /// Returns special DeclarationName used by using-directives.\n  ///\n  /// This is only used by DeclContext for storing UsingDirectiveDecls in\n  /// its lookup structure.\n  static DeclarationName getName() {\n    return DeclarationName::getUsingDirectiveName();\n  }\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n\n  // Friend for getUsingDirectiveName.\n  friend class DeclContext;\n\n  /// Retrieve the nested-name-specifier that qualifies the\n  /// name of the namespace, with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the nested-name-specifier that qualifies the\n  /// name of the namespace.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  NamedDecl *getNominatedNamespaceAsWritten() { return NominatedNamespace; }\n  const NamedDecl *getNominatedNamespaceAsWritten() const {\n    return NominatedNamespace;\n  }\n\n  /// Returns the namespace nominated by this using-directive.\n  NamespaceDecl *getNominatedNamespace();\n\n  const NamespaceDecl *getNominatedNamespace() const {\n    return const_cast<UsingDirectiveDecl*>(this)->getNominatedNamespace();\n  }\n\n  /// Returns the common ancestor context of this using-directive and\n  /// its nominated namespace.\n  DeclContext *getCommonAncestor() { return CommonAncestor; }\n  const DeclContext *getCommonAncestor() const { return CommonAncestor; }\n\n  /// Return the location of the \\c using keyword.\n  SourceLocation getUsingLoc() const { return UsingLoc; }\n\n  // FIXME: Could omit 'Key' in name.\n  /// Returns the location of the \\c namespace keyword.\n  SourceLocation getNamespaceKeyLocation() const { return NamespaceLoc; }\n\n  /// Returns the location of this using declaration's identifier.\n  SourceLocation getIdentLocation() const { return getLocation(); }\n\n  static UsingDirectiveDecl *Create(ASTContext &C, DeclContext *DC,\n                                    SourceLocation UsingLoc,\n                                    SourceLocation NamespaceLoc,\n                                    NestedNameSpecifierLoc QualifierLoc,\n                                    SourceLocation IdentLoc,\n                                    NamedDecl *Nominated,\n                                    DeclContext *CommonAncestor);\n  static UsingDirectiveDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(UsingLoc, getLocation());\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == UsingDirective; }\n};\n\n/// Represents a C++ namespace alias.\n///\n/// For example:\n///\n/// \\code\n/// namespace Foo = Bar;\n/// \\endcode\nclass NamespaceAliasDecl : public NamedDecl,\n                           public Redeclarable<NamespaceAliasDecl> {\n  friend class ASTDeclReader;\n\n  /// The location of the \\c namespace keyword.\n  SourceLocation NamespaceLoc;\n\n  /// The location of the namespace's identifier.\n  ///\n  /// This is accessed by TargetNameLoc.\n  SourceLocation IdentLoc;\n\n  /// The nested-name-specifier that precedes the namespace.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// The Decl that this alias points to, either a NamespaceDecl or\n  /// a NamespaceAliasDecl.\n  NamedDecl *Namespace;\n\n  NamespaceAliasDecl(ASTContext &C, DeclContext *DC,\n                     SourceLocation NamespaceLoc, SourceLocation AliasLoc,\n                     IdentifierInfo *Alias, NestedNameSpecifierLoc QualifierLoc,\n                     SourceLocation IdentLoc, NamedDecl *Namespace)\n      : NamedDecl(NamespaceAlias, DC, AliasLoc, Alias), redeclarable_base(C),\n        NamespaceLoc(NamespaceLoc), IdentLoc(IdentLoc),\n        QualifierLoc(QualifierLoc), Namespace(Namespace) {}\n\n  void anchor() override;\n\n  using redeclarable_base = Redeclarable<NamespaceAliasDecl>;\n\n  NamespaceAliasDecl *getNextRedeclarationImpl() override;\n  NamespaceAliasDecl *getPreviousDeclImpl() override;\n  NamespaceAliasDecl *getMostRecentDeclImpl() override;\n\npublic:\n  static NamespaceAliasDecl *Create(ASTContext &C, DeclContext *DC,\n                                    SourceLocation NamespaceLoc,\n                                    SourceLocation AliasLoc,\n                                    IdentifierInfo *Alias,\n                                    NestedNameSpecifierLoc QualifierLoc,\n                                    SourceLocation IdentLoc,\n                                    NamedDecl *Namespace);\n\n  static NamespaceAliasDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n\n  NamespaceAliasDecl *getCanonicalDecl() override {\n    return getFirstDecl();\n  }\n  const NamespaceAliasDecl *getCanonicalDecl() const {\n    return getFirstDecl();\n  }\n\n  /// Retrieve the nested-name-specifier that qualifies the\n  /// name of the namespace, with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the nested-name-specifier that qualifies the\n  /// name of the namespace.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  /// Retrieve the namespace declaration aliased by this directive.\n  NamespaceDecl *getNamespace() {\n    if (auto *AD = dyn_cast<NamespaceAliasDecl>(Namespace))\n      return AD->getNamespace();\n\n    return cast<NamespaceDecl>(Namespace);\n  }\n\n  const NamespaceDecl *getNamespace() const {\n    return const_cast<NamespaceAliasDecl *>(this)->getNamespace();\n  }\n\n  /// Returns the location of the alias name, i.e. 'foo' in\n  /// \"namespace foo = ns::bar;\".\n  SourceLocation getAliasLoc() const { return getLocation(); }\n\n  /// Returns the location of the \\c namespace keyword.\n  SourceLocation getNamespaceLoc() const { return NamespaceLoc; }\n\n  /// Returns the location of the identifier in the named namespace.\n  SourceLocation getTargetNameLoc() const { return IdentLoc; }\n\n  /// Retrieve the namespace that this alias refers to, which\n  /// may either be a NamespaceDecl or a NamespaceAliasDecl.\n  NamedDecl *getAliasedNamespace() const { return Namespace; }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(NamespaceLoc, IdentLoc);\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == NamespaceAlias; }\n};\n\n/// Implicit declaration of a temporary that was materialized by\n/// a MaterializeTemporaryExpr and lifetime-extended by a declaration\nclass LifetimeExtendedTemporaryDecl final\n    : public Decl,\n      public Mergeable<LifetimeExtendedTemporaryDecl> {\n  friend class MaterializeTemporaryExpr;\n  friend class ASTDeclReader;\n\n  Stmt *ExprWithTemporary = nullptr;\n\n  /// The declaration which lifetime-extended this reference, if any.\n  /// Either a VarDecl, or (for a ctor-initializer) a FieldDecl.\n  ValueDecl *ExtendingDecl = nullptr;\n  unsigned ManglingNumber;\n\n  mutable APValue *Value = nullptr;\n\n  virtual void anchor();\n\n  LifetimeExtendedTemporaryDecl(Expr *Temp, ValueDecl *EDecl, unsigned Mangling)\n      : Decl(Decl::LifetimeExtendedTemporary, EDecl->getDeclContext(),\n             EDecl->getLocation()),\n        ExprWithTemporary(Temp), ExtendingDecl(EDecl),\n        ManglingNumber(Mangling) {}\n\n  LifetimeExtendedTemporaryDecl(EmptyShell)\n      : Decl(Decl::LifetimeExtendedTemporary, EmptyShell{}) {}\n\npublic:\n  static LifetimeExtendedTemporaryDecl *Create(Expr *Temp, ValueDecl *EDec,\n                                               unsigned Mangling) {\n    return new (EDec->getASTContext(), EDec->getDeclContext())\n        LifetimeExtendedTemporaryDecl(Temp, EDec, Mangling);\n  }\n  static LifetimeExtendedTemporaryDecl *CreateDeserialized(ASTContext &C,\n                                                           unsigned ID) {\n    return new (C, ID) LifetimeExtendedTemporaryDecl(EmptyShell{});\n  }\n\n  ValueDecl *getExtendingDecl() { return ExtendingDecl; }\n  const ValueDecl *getExtendingDecl() const { return ExtendingDecl; }\n\n  /// Retrieve the storage duration for the materialized temporary.\n  StorageDuration getStorageDuration() const;\n\n  /// Retrieve the expression to which the temporary materialization conversion\n  /// was applied. This isn't necessarily the initializer of the temporary due\n  /// to the C++98 delayed materialization rules, but\n  /// skipRValueSubobjectAdjustments can be used to find said initializer within\n  /// the subexpression.\n  Expr *getTemporaryExpr() { return cast<Expr>(ExprWithTemporary); }\n  const Expr *getTemporaryExpr() const { return cast<Expr>(ExprWithTemporary); }\n\n  unsigned getManglingNumber() const { return ManglingNumber; }\n\n  /// Get the storage for the constant value of a materialized temporary\n  /// of static storage duration.\n  APValue *getOrCreateValue(bool MayCreate) const;\n\n  APValue *getValue() const { return Value; }\n\n  // Iterators\n  Stmt::child_range childrenExpr() {\n    return Stmt::child_range(&ExprWithTemporary, &ExprWithTemporary + 1);\n  }\n\n  Stmt::const_child_range childrenExpr() const {\n    return Stmt::const_child_range(&ExprWithTemporary, &ExprWithTemporary + 1);\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K == Decl::LifetimeExtendedTemporary;\n  }\n};\n\n/// Represents a shadow declaration introduced into a scope by a\n/// (resolved) using declaration.\n///\n/// For example,\n/// \\code\n/// namespace A {\n///   void foo();\n/// }\n/// namespace B {\n///   using A::foo; // <- a UsingDecl\n///                 // Also creates a UsingShadowDecl for A::foo() in B\n/// }\n/// \\endcode\nclass UsingShadowDecl : public NamedDecl, public Redeclarable<UsingShadowDecl> {\n  friend class UsingDecl;\n\n  /// The referenced declaration.\n  NamedDecl *Underlying = nullptr;\n\n  /// The using declaration which introduced this decl or the next using\n  /// shadow declaration contained in the aforementioned using declaration.\n  NamedDecl *UsingOrNextShadow = nullptr;\n\n  void anchor() override;\n\n  using redeclarable_base = Redeclarable<UsingShadowDecl>;\n\n  UsingShadowDecl *getNextRedeclarationImpl() override {\n    return getNextRedeclaration();\n  }\n\n  UsingShadowDecl *getPreviousDeclImpl() override {\n    return getPreviousDecl();\n  }\n\n  UsingShadowDecl *getMostRecentDeclImpl() override {\n    return getMostRecentDecl();\n  }\n\nprotected:\n  UsingShadowDecl(Kind K, ASTContext &C, DeclContext *DC, SourceLocation Loc,\n                  UsingDecl *Using, NamedDecl *Target);\n  UsingShadowDecl(Kind K, ASTContext &C, EmptyShell);\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static UsingShadowDecl *Create(ASTContext &C, DeclContext *DC,\n                                 SourceLocation Loc, UsingDecl *Using,\n                                 NamedDecl *Target) {\n    return new (C, DC) UsingShadowDecl(UsingShadow, C, DC, Loc, Using, Target);\n  }\n\n  static UsingShadowDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  UsingShadowDecl *getCanonicalDecl() override {\n    return getFirstDecl();\n  }\n  const UsingShadowDecl *getCanonicalDecl() const {\n    return getFirstDecl();\n  }\n\n  /// Gets the underlying declaration which has been brought into the\n  /// local scope.\n  NamedDecl *getTargetDecl() const { return Underlying; }\n\n  /// Sets the underlying declaration which has been brought into the\n  /// local scope.\n  void setTargetDecl(NamedDecl *ND) {\n    assert(ND && \"Target decl is null!\");\n    Underlying = ND;\n    // A UsingShadowDecl is never a friend or local extern declaration, even\n    // if it is a shadow declaration for one.\n    IdentifierNamespace =\n        ND->getIdentifierNamespace() &\n        ~(IDNS_OrdinaryFriend | IDNS_TagFriend | IDNS_LocalExtern);\n  }\n\n  /// Gets the using declaration to which this declaration is tied.\n  UsingDecl *getUsingDecl() const;\n\n  /// The next using shadow declaration contained in the shadow decl\n  /// chain of the using declaration which introduced this decl.\n  UsingShadowDecl *getNextUsingShadowDecl() const {\n    return dyn_cast_or_null<UsingShadowDecl>(UsingOrNextShadow);\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K == Decl::UsingShadow || K == Decl::ConstructorUsingShadow;\n  }\n};\n\n/// Represents a shadow constructor declaration introduced into a\n/// class by a C++11 using-declaration that names a constructor.\n///\n/// For example:\n/// \\code\n/// struct Base { Base(int); };\n/// struct Derived {\n///    using Base::Base; // creates a UsingDecl and a ConstructorUsingShadowDecl\n/// };\n/// \\endcode\nclass ConstructorUsingShadowDecl final : public UsingShadowDecl {\n  /// If this constructor using declaration inherted the constructor\n  /// from an indirect base class, this is the ConstructorUsingShadowDecl\n  /// in the named direct base class from which the declaration was inherited.\n  ConstructorUsingShadowDecl *NominatedBaseClassShadowDecl = nullptr;\n\n  /// If this constructor using declaration inherted the constructor\n  /// from an indirect base class, this is the ConstructorUsingShadowDecl\n  /// that will be used to construct the unique direct or virtual base class\n  /// that receives the constructor arguments.\n  ConstructorUsingShadowDecl *ConstructedBaseClassShadowDecl = nullptr;\n\n  /// \\c true if the constructor ultimately named by this using shadow\n  /// declaration is within a virtual base class subobject of the class that\n  /// contains this declaration.\n  unsigned IsVirtual : 1;\n\n  ConstructorUsingShadowDecl(ASTContext &C, DeclContext *DC, SourceLocation Loc,\n                             UsingDecl *Using, NamedDecl *Target,\n                             bool TargetInVirtualBase)\n      : UsingShadowDecl(ConstructorUsingShadow, C, DC, Loc, Using,\n                        Target->getUnderlyingDecl()),\n        NominatedBaseClassShadowDecl(\n            dyn_cast<ConstructorUsingShadowDecl>(Target)),\n        ConstructedBaseClassShadowDecl(NominatedBaseClassShadowDecl),\n        IsVirtual(TargetInVirtualBase) {\n    // If we found a constructor that chains to a constructor for a virtual\n    // base, we should directly call that virtual base constructor instead.\n    // FIXME: This logic belongs in Sema.\n    if (NominatedBaseClassShadowDecl &&\n        NominatedBaseClassShadowDecl->constructsVirtualBase()) {\n      ConstructedBaseClassShadowDecl =\n          NominatedBaseClassShadowDecl->ConstructedBaseClassShadowDecl;\n      IsVirtual = true;\n    }\n  }\n\n  ConstructorUsingShadowDecl(ASTContext &C, EmptyShell Empty)\n      : UsingShadowDecl(ConstructorUsingShadow, C, Empty), IsVirtual(false) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static ConstructorUsingShadowDecl *Create(ASTContext &C, DeclContext *DC,\n                                            SourceLocation Loc,\n                                            UsingDecl *Using, NamedDecl *Target,\n                                            bool IsVirtual);\n  static ConstructorUsingShadowDecl *CreateDeserialized(ASTContext &C,\n                                                        unsigned ID);\n\n  /// Returns the parent of this using shadow declaration, which\n  /// is the class in which this is declared.\n  //@{\n  const CXXRecordDecl *getParent() const {\n    return cast<CXXRecordDecl>(getDeclContext());\n  }\n  CXXRecordDecl *getParent() {\n    return cast<CXXRecordDecl>(getDeclContext());\n  }\n  //@}\n\n  /// Get the inheriting constructor declaration for the direct base\n  /// class from which this using shadow declaration was inherited, if there is\n  /// one. This can be different for each redeclaration of the same shadow decl.\n  ConstructorUsingShadowDecl *getNominatedBaseClassShadowDecl() const {\n    return NominatedBaseClassShadowDecl;\n  }\n\n  /// Get the inheriting constructor declaration for the base class\n  /// for which we don't have an explicit initializer, if there is one.\n  ConstructorUsingShadowDecl *getConstructedBaseClassShadowDecl() const {\n    return ConstructedBaseClassShadowDecl;\n  }\n\n  /// Get the base class that was named in the using declaration. This\n  /// can be different for each redeclaration of this same shadow decl.\n  CXXRecordDecl *getNominatedBaseClass() const;\n\n  /// Get the base class whose constructor or constructor shadow\n  /// declaration is passed the constructor arguments.\n  CXXRecordDecl *getConstructedBaseClass() const {\n    return cast<CXXRecordDecl>((ConstructedBaseClassShadowDecl\n                                    ? ConstructedBaseClassShadowDecl\n                                    : getTargetDecl())\n                                   ->getDeclContext());\n  }\n\n  /// Returns \\c true if the constructed base class is a virtual base\n  /// class subobject of this declaration's class.\n  bool constructsVirtualBase() const {\n    return IsVirtual;\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ConstructorUsingShadow; }\n};\n\n/// Represents a C++ using-declaration.\n///\n/// For example:\n/// \\code\n///    using someNameSpace::someIdentifier;\n/// \\endcode\nclass UsingDecl : public NamedDecl, public Mergeable<UsingDecl> {\n  /// The source location of the 'using' keyword itself.\n  SourceLocation UsingLocation;\n\n  /// The nested-name-specifier that precedes the name.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// Provides source/type location info for the declaration name\n  /// embedded in the ValueDecl base class.\n  DeclarationNameLoc DNLoc;\n\n  /// The first shadow declaration of the shadow decl chain associated\n  /// with this using declaration.\n  ///\n  /// The bool member of the pair store whether this decl has the \\c typename\n  /// keyword.\n  llvm::PointerIntPair<UsingShadowDecl *, 1, bool> FirstUsingShadow;\n\n  UsingDecl(DeclContext *DC, SourceLocation UL,\n            NestedNameSpecifierLoc QualifierLoc,\n            const DeclarationNameInfo &NameInfo, bool HasTypenameKeyword)\n    : NamedDecl(Using, DC, NameInfo.getLoc(), NameInfo.getName()),\n      UsingLocation(UL), QualifierLoc(QualifierLoc),\n      DNLoc(NameInfo.getInfo()), FirstUsingShadow(nullptr, HasTypenameKeyword) {\n  }\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Return the source location of the 'using' keyword.\n  SourceLocation getUsingLoc() const { return UsingLocation; }\n\n  /// Set the source location of the 'using' keyword.\n  void setUsingLoc(SourceLocation L) { UsingLocation = L; }\n\n  /// Retrieve the nested-name-specifier that qualifies the name,\n  /// with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the nested-name-specifier that qualifies the name.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  DeclarationNameInfo getNameInfo() const {\n    return DeclarationNameInfo(getDeclName(), getLocation(), DNLoc);\n  }\n\n  /// Return true if it is a C++03 access declaration (no 'using').\n  bool isAccessDeclaration() const { return UsingLocation.isInvalid(); }\n\n  /// Return true if the using declaration has 'typename'.\n  bool hasTypename() const { return FirstUsingShadow.getInt(); }\n\n  /// Sets whether the using declaration has 'typename'.\n  void setTypename(bool TN) { FirstUsingShadow.setInt(TN); }\n\n  /// Iterates through the using shadow declarations associated with\n  /// this using declaration.\n  class shadow_iterator {\n    /// The current using shadow declaration.\n    UsingShadowDecl *Current = nullptr;\n\n  public:\n    using value_type = UsingShadowDecl *;\n    using reference = UsingShadowDecl *;\n    using pointer = UsingShadowDecl *;\n    using iterator_category = std::forward_iterator_tag;\n    using difference_type = std::ptrdiff_t;\n\n    shadow_iterator() = default;\n    explicit shadow_iterator(UsingShadowDecl *C) : Current(C) {}\n\n    reference operator*() const { return Current; }\n    pointer operator->() const { return Current; }\n\n    shadow_iterator& operator++() {\n      Current = Current->getNextUsingShadowDecl();\n      return *this;\n    }\n\n    shadow_iterator operator++(int) {\n      shadow_iterator tmp(*this);\n      ++(*this);\n      return tmp;\n    }\n\n    friend bool operator==(shadow_iterator x, shadow_iterator y) {\n      return x.Current == y.Current;\n    }\n    friend bool operator!=(shadow_iterator x, shadow_iterator y) {\n      return x.Current != y.Current;\n    }\n  };\n\n  using shadow_range = llvm::iterator_range<shadow_iterator>;\n\n  shadow_range shadows() const {\n    return shadow_range(shadow_begin(), shadow_end());\n  }\n\n  shadow_iterator shadow_begin() const {\n    return shadow_iterator(FirstUsingShadow.getPointer());\n  }\n\n  shadow_iterator shadow_end() const { return shadow_iterator(); }\n\n  /// Return the number of shadowed declarations associated with this\n  /// using declaration.\n  unsigned shadow_size() const {\n    return std::distance(shadow_begin(), shadow_end());\n  }\n\n  void addShadowDecl(UsingShadowDecl *S);\n  void removeShadowDecl(UsingShadowDecl *S);\n\n  static UsingDecl *Create(ASTContext &C, DeclContext *DC,\n                           SourceLocation UsingL,\n                           NestedNameSpecifierLoc QualifierLoc,\n                           const DeclarationNameInfo &NameInfo,\n                           bool HasTypenameKeyword);\n\n  static UsingDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  /// Retrieves the canonical declaration of this declaration.\n  UsingDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const UsingDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Using; }\n};\n\n/// Represents a pack of using declarations that a single\n/// using-declarator pack-expanded into.\n///\n/// \\code\n/// template<typename ...T> struct X : T... {\n///   using T::operator()...;\n///   using T::operator T...;\n/// };\n/// \\endcode\n///\n/// In the second case above, the UsingPackDecl will have the name\n/// 'operator T' (which contains an unexpanded pack), but the individual\n/// UsingDecls and UsingShadowDecls will have more reasonable names.\nclass UsingPackDecl final\n    : public NamedDecl, public Mergeable<UsingPackDecl>,\n      private llvm::TrailingObjects<UsingPackDecl, NamedDecl *> {\n  /// The UnresolvedUsingValueDecl or UnresolvedUsingTypenameDecl from\n  /// which this waas instantiated.\n  NamedDecl *InstantiatedFrom;\n\n  /// The number of using-declarations created by this pack expansion.\n  unsigned NumExpansions;\n\n  UsingPackDecl(DeclContext *DC, NamedDecl *InstantiatedFrom,\n                ArrayRef<NamedDecl *> UsingDecls)\n      : NamedDecl(UsingPack, DC,\n                  InstantiatedFrom ? InstantiatedFrom->getLocation()\n                                   : SourceLocation(),\n                  InstantiatedFrom ? InstantiatedFrom->getDeclName()\n                                   : DeclarationName()),\n        InstantiatedFrom(InstantiatedFrom), NumExpansions(UsingDecls.size()) {\n    std::uninitialized_copy(UsingDecls.begin(), UsingDecls.end(),\n                            getTrailingObjects<NamedDecl *>());\n  }\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend TrailingObjects;\n\n  /// Get the using declaration from which this was instantiated. This will\n  /// always be an UnresolvedUsingValueDecl or an UnresolvedUsingTypenameDecl\n  /// that is a pack expansion.\n  NamedDecl *getInstantiatedFromUsingDecl() const { return InstantiatedFrom; }\n\n  /// Get the set of using declarations that this pack expanded into. Note that\n  /// some of these may still be unresolved.\n  ArrayRef<NamedDecl *> expansions() const {\n    return llvm::makeArrayRef(getTrailingObjects<NamedDecl *>(), NumExpansions);\n  }\n\n  static UsingPackDecl *Create(ASTContext &C, DeclContext *DC,\n                               NamedDecl *InstantiatedFrom,\n                               ArrayRef<NamedDecl *> UsingDecls);\n\n  static UsingPackDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                           unsigned NumExpansions);\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return InstantiatedFrom->getSourceRange();\n  }\n\n  UsingPackDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const UsingPackDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == UsingPack; }\n};\n\n/// Represents a dependent using declaration which was not marked with\n/// \\c typename.\n///\n/// Unlike non-dependent using declarations, these *only* bring through\n/// non-types; otherwise they would break two-phase lookup.\n///\n/// \\code\n/// template \\<class T> class A : public Base<T> {\n///   using Base<T>::foo;\n/// };\n/// \\endcode\nclass UnresolvedUsingValueDecl : public ValueDecl,\n                                 public Mergeable<UnresolvedUsingValueDecl> {\n  /// The source location of the 'using' keyword\n  SourceLocation UsingLocation;\n\n  /// If this is a pack expansion, the location of the '...'.\n  SourceLocation EllipsisLoc;\n\n  /// The nested-name-specifier that precedes the name.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// Provides source/type location info for the declaration name\n  /// embedded in the ValueDecl base class.\n  DeclarationNameLoc DNLoc;\n\n  UnresolvedUsingValueDecl(DeclContext *DC, QualType Ty,\n                           SourceLocation UsingLoc,\n                           NestedNameSpecifierLoc QualifierLoc,\n                           const DeclarationNameInfo &NameInfo,\n                           SourceLocation EllipsisLoc)\n      : ValueDecl(UnresolvedUsingValue, DC,\n                  NameInfo.getLoc(), NameInfo.getName(), Ty),\n        UsingLocation(UsingLoc), EllipsisLoc(EllipsisLoc),\n        QualifierLoc(QualifierLoc), DNLoc(NameInfo.getInfo()) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Returns the source location of the 'using' keyword.\n  SourceLocation getUsingLoc() const { return UsingLocation; }\n\n  /// Set the source location of the 'using' keyword.\n  void setUsingLoc(SourceLocation L) { UsingLocation = L; }\n\n  /// Return true if it is a C++03 access declaration (no 'using').\n  bool isAccessDeclaration() const { return UsingLocation.isInvalid(); }\n\n  /// Retrieve the nested-name-specifier that qualifies the name,\n  /// with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the nested-name-specifier that qualifies the name.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  DeclarationNameInfo getNameInfo() const {\n    return DeclarationNameInfo(getDeclName(), getLocation(), DNLoc);\n  }\n\n  /// Determine whether this is a pack expansion.\n  bool isPackExpansion() const {\n    return EllipsisLoc.isValid();\n  }\n\n  /// Get the location of the ellipsis if this is a pack expansion.\n  SourceLocation getEllipsisLoc() const {\n    return EllipsisLoc;\n  }\n\n  static UnresolvedUsingValueDecl *\n    Create(ASTContext &C, DeclContext *DC, SourceLocation UsingLoc,\n           NestedNameSpecifierLoc QualifierLoc,\n           const DeclarationNameInfo &NameInfo, SourceLocation EllipsisLoc);\n\n  static UnresolvedUsingValueDecl *\n  CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  /// Retrieves the canonical declaration of this declaration.\n  UnresolvedUsingValueDecl *getCanonicalDecl() override {\n    return getFirstDecl();\n  }\n  const UnresolvedUsingValueDecl *getCanonicalDecl() const {\n    return getFirstDecl();\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == UnresolvedUsingValue; }\n};\n\n/// Represents a dependent using declaration which was marked with\n/// \\c typename.\n///\n/// \\code\n/// template \\<class T> class A : public Base<T> {\n///   using typename Base<T>::foo;\n/// };\n/// \\endcode\n///\n/// The type associated with an unresolved using typename decl is\n/// currently always a typename type.\nclass UnresolvedUsingTypenameDecl\n    : public TypeDecl,\n      public Mergeable<UnresolvedUsingTypenameDecl> {\n  friend class ASTDeclReader;\n\n  /// The source location of the 'typename' keyword\n  SourceLocation TypenameLocation;\n\n  /// If this is a pack expansion, the location of the '...'.\n  SourceLocation EllipsisLoc;\n\n  /// The nested-name-specifier that precedes the name.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  UnresolvedUsingTypenameDecl(DeclContext *DC, SourceLocation UsingLoc,\n                              SourceLocation TypenameLoc,\n                              NestedNameSpecifierLoc QualifierLoc,\n                              SourceLocation TargetNameLoc,\n                              IdentifierInfo *TargetName,\n                              SourceLocation EllipsisLoc)\n    : TypeDecl(UnresolvedUsingTypename, DC, TargetNameLoc, TargetName,\n               UsingLoc),\n      TypenameLocation(TypenameLoc), EllipsisLoc(EllipsisLoc),\n      QualifierLoc(QualifierLoc) {}\n\n  void anchor() override;\n\npublic:\n  /// Returns the source location of the 'using' keyword.\n  SourceLocation getUsingLoc() const { return getBeginLoc(); }\n\n  /// Returns the source location of the 'typename' keyword.\n  SourceLocation getTypenameLoc() const { return TypenameLocation; }\n\n  /// Retrieve the nested-name-specifier that qualifies the name,\n  /// with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the nested-name-specifier that qualifies the name.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  DeclarationNameInfo getNameInfo() const {\n    return DeclarationNameInfo(getDeclName(), getLocation());\n  }\n\n  /// Determine whether this is a pack expansion.\n  bool isPackExpansion() const {\n    return EllipsisLoc.isValid();\n  }\n\n  /// Get the location of the ellipsis if this is a pack expansion.\n  SourceLocation getEllipsisLoc() const {\n    return EllipsisLoc;\n  }\n\n  static UnresolvedUsingTypenameDecl *\n    Create(ASTContext &C, DeclContext *DC, SourceLocation UsingLoc,\n           SourceLocation TypenameLoc, NestedNameSpecifierLoc QualifierLoc,\n           SourceLocation TargetNameLoc, DeclarationName TargetName,\n           SourceLocation EllipsisLoc);\n\n  static UnresolvedUsingTypenameDecl *\n  CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// Retrieves the canonical declaration of this declaration.\n  UnresolvedUsingTypenameDecl *getCanonicalDecl() override {\n    return getFirstDecl();\n  }\n  const UnresolvedUsingTypenameDecl *getCanonicalDecl() const {\n    return getFirstDecl();\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == UnresolvedUsingTypename; }\n};\n\n/// Represents a C++11 static_assert declaration.\nclass StaticAssertDecl : public Decl {\n  llvm::PointerIntPair<Expr *, 1, bool> AssertExprAndFailed;\n  StringLiteral *Message;\n  SourceLocation RParenLoc;\n\n  StaticAssertDecl(DeclContext *DC, SourceLocation StaticAssertLoc,\n                   Expr *AssertExpr, StringLiteral *Message,\n                   SourceLocation RParenLoc, bool Failed)\n      : Decl(StaticAssert, DC, StaticAssertLoc),\n        AssertExprAndFailed(AssertExpr, Failed), Message(Message),\n        RParenLoc(RParenLoc) {}\n\n  virtual void anchor();\n\npublic:\n  friend class ASTDeclReader;\n\n  static StaticAssertDecl *Create(ASTContext &C, DeclContext *DC,\n                                  SourceLocation StaticAssertLoc,\n                                  Expr *AssertExpr, StringLiteral *Message,\n                                  SourceLocation RParenLoc, bool Failed);\n  static StaticAssertDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  Expr *getAssertExpr() { return AssertExprAndFailed.getPointer(); }\n  const Expr *getAssertExpr() const { return AssertExprAndFailed.getPointer(); }\n\n  StringLiteral *getMessage() { return Message; }\n  const StringLiteral *getMessage() const { return Message; }\n\n  bool isFailed() const { return AssertExprAndFailed.getInt(); }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(getLocation(), getRParenLoc());\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == StaticAssert; }\n};\n\n/// A binding in a decomposition declaration. For instance, given:\n///\n///   int n[3];\n///   auto &[a, b, c] = n;\n///\n/// a, b, and c are BindingDecls, whose bindings are the expressions\n/// x[0], x[1], and x[2] respectively, where x is the implicit\n/// DecompositionDecl of type 'int (&)[3]'.\nclass BindingDecl : public ValueDecl {\n  /// The declaration that this binding binds to part of.\n  LazyDeclPtr Decomp;\n  /// The binding represented by this declaration. References to this\n  /// declaration are effectively equivalent to this expression (except\n  /// that it is only evaluated once at the point of declaration of the\n  /// binding).\n  Expr *Binding = nullptr;\n\n  BindingDecl(DeclContext *DC, SourceLocation IdLoc, IdentifierInfo *Id)\n      : ValueDecl(Decl::Binding, DC, IdLoc, Id, QualType()) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n\n  static BindingDecl *Create(ASTContext &C, DeclContext *DC,\n                             SourceLocation IdLoc, IdentifierInfo *Id);\n  static BindingDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// Get the expression to which this declaration is bound. This may be null\n  /// in two different cases: while parsing the initializer for the\n  /// decomposition declaration, and when the initializer is type-dependent.\n  Expr *getBinding() const { return Binding; }\n\n  /// Get the decomposition declaration that this binding represents a\n  /// decomposition of.\n  ValueDecl *getDecomposedDecl() const;\n\n  /// Get the variable (if any) that holds the value of evaluating the binding.\n  /// Only present for user-defined bindings for tuple-like types.\n  VarDecl *getHoldingVar() const;\n\n  /// Set the binding for this BindingDecl, along with its declared type (which\n  /// should be a possibly-cv-qualified form of the type of the binding, or a\n  /// reference to such a type).\n  void setBinding(QualType DeclaredType, Expr *Binding) {\n    setType(DeclaredType);\n    this->Binding = Binding;\n  }\n\n  /// Set the decomposed variable for this BindingDecl.\n  void setDecomposedDecl(ValueDecl *Decomposed) { Decomp = Decomposed; }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Decl::Binding; }\n};\n\n/// A decomposition declaration. For instance, given:\n///\n///   int n[3];\n///   auto &[a, b, c] = n;\n///\n/// the second line declares a DecompositionDecl of type 'int (&)[3]', and\n/// three BindingDecls (named a, b, and c). An instance of this class is always\n/// unnamed, but behaves in almost all other respects like a VarDecl.\nclass DecompositionDecl final\n    : public VarDecl,\n      private llvm::TrailingObjects<DecompositionDecl, BindingDecl *> {\n  /// The number of BindingDecl*s following this object.\n  unsigned NumBindings;\n\n  DecompositionDecl(ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n                    SourceLocation LSquareLoc, QualType T,\n                    TypeSourceInfo *TInfo, StorageClass SC,\n                    ArrayRef<BindingDecl *> Bindings)\n      : VarDecl(Decomposition, C, DC, StartLoc, LSquareLoc, nullptr, T, TInfo,\n                SC),\n        NumBindings(Bindings.size()) {\n    std::uninitialized_copy(Bindings.begin(), Bindings.end(),\n                            getTrailingObjects<BindingDecl *>());\n    for (auto *B : Bindings)\n      B->setDecomposedDecl(this);\n  }\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend TrailingObjects;\n\n  static DecompositionDecl *Create(ASTContext &C, DeclContext *DC,\n                                   SourceLocation StartLoc,\n                                   SourceLocation LSquareLoc,\n                                   QualType T, TypeSourceInfo *TInfo,\n                                   StorageClass S,\n                                   ArrayRef<BindingDecl *> Bindings);\n  static DecompositionDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                               unsigned NumBindings);\n\n  ArrayRef<BindingDecl *> bindings() const {\n    return llvm::makeArrayRef(getTrailingObjects<BindingDecl *>(), NumBindings);\n  }\n\n  void printName(raw_ostream &os) const override;\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Decomposition; }\n};\n\n/// An instance of this class represents the declaration of a property\n/// member.  This is a Microsoft extension to C++, first introduced in\n/// Visual Studio .NET 2003 as a parallel to similar features in C#\n/// and Managed C++.\n///\n/// A property must always be a non-static class member.\n///\n/// A property member superficially resembles a non-static data\n/// member, except preceded by a property attribute:\n///   __declspec(property(get=GetX, put=PutX)) int x;\n/// Either (but not both) of the 'get' and 'put' names may be omitted.\n///\n/// A reference to a property is always an lvalue.  If the lvalue\n/// undergoes lvalue-to-rvalue conversion, then a getter name is\n/// required, and that member is called with no arguments.\n/// If the lvalue is assigned into, then a setter name is required,\n/// and that member is called with one argument, the value assigned.\n/// Both operations are potentially overloaded.  Compound assignments\n/// are permitted, as are the increment and decrement operators.\n///\n/// The getter and putter methods are permitted to be overloaded,\n/// although their return and parameter types are subject to certain\n/// restrictions according to the type of the property.\n///\n/// A property declared using an incomplete array type may\n/// additionally be subscripted, adding extra parameters to the getter\n/// and putter methods.\nclass MSPropertyDecl : public DeclaratorDecl {\n  IdentifierInfo *GetterId, *SetterId;\n\n  MSPropertyDecl(DeclContext *DC, SourceLocation L, DeclarationName N,\n                 QualType T, TypeSourceInfo *TInfo, SourceLocation StartL,\n                 IdentifierInfo *Getter, IdentifierInfo *Setter)\n      : DeclaratorDecl(MSProperty, DC, L, N, T, TInfo, StartL),\n        GetterId(Getter), SetterId(Setter) {}\n\n  void anchor() override;\npublic:\n  friend class ASTDeclReader;\n\n  static MSPropertyDecl *Create(ASTContext &C, DeclContext *DC,\n                                SourceLocation L, DeclarationName N, QualType T,\n                                TypeSourceInfo *TInfo, SourceLocation StartL,\n                                IdentifierInfo *Getter, IdentifierInfo *Setter);\n  static MSPropertyDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  static bool classof(const Decl *D) { return D->getKind() == MSProperty; }\n\n  bool hasGetter() const { return GetterId != nullptr; }\n  IdentifierInfo* getGetterId() const { return GetterId; }\n  bool hasSetter() const { return SetterId != nullptr; }\n  IdentifierInfo* getSetterId() const { return SetterId; }\n};\n\n/// Parts of a decomposed MSGuidDecl. Factored out to avoid unnecessary\n/// dependencies on DeclCXX.h.\nstruct MSGuidDeclParts {\n  /// {01234567-...\n  uint32_t Part1;\n  /// ...-89ab-...\n  uint16_t Part2;\n  /// ...-cdef-...\n  uint16_t Part3;\n  /// ...-0123-456789abcdef}\n  uint8_t Part4And5[8];\n\n  uint64_t getPart4And5AsUint64() const {\n    uint64_t Val;\n    memcpy(&Val, &Part4And5, sizeof(Part4And5));\n    return Val;\n  }\n};\n\n/// A global _GUID constant. These are implicitly created by UuidAttrs.\n///\n///   struct _declspec(uuid(\"01234567-89ab-cdef-0123-456789abcdef\")) X{};\n///\n/// X is a CXXRecordDecl that contains a UuidAttr that references the (unique)\n/// MSGuidDecl for the specified UUID.\nclass MSGuidDecl : public ValueDecl,\n                   public Mergeable<MSGuidDecl>,\n                   public llvm::FoldingSetNode {\npublic:\n  using Parts = MSGuidDeclParts;\n\nprivate:\n  /// The decomposed form of the UUID.\n  Parts PartVal;\n\n  /// The resolved value of the UUID as an APValue. Computed on demand and\n  /// cached.\n  mutable APValue APVal;\n\n  void anchor() override;\n\n  MSGuidDecl(DeclContext *DC, QualType T, Parts P);\n\n  static MSGuidDecl *Create(const ASTContext &C, QualType T, Parts P);\n  static MSGuidDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  // Only ASTContext::getMSGuidDecl and deserialization create these.\n  friend class ASTContext;\n  friend class ASTReader;\n  friend class ASTDeclReader;\n\npublic:\n  /// Print this UUID in a human-readable format.\n  void printName(llvm::raw_ostream &OS) const override;\n\n  /// Get the decomposed parts of this declaration.\n  Parts getParts() const { return PartVal; }\n\n  /// Get the value of this MSGuidDecl as an APValue. This may fail and return\n  /// an absent APValue if the type of the declaration is not of the expected\n  /// shape.\n  APValue &getAsAPValue() const;\n\n  static void Profile(llvm::FoldingSetNodeID &ID, Parts P) {\n    ID.AddInteger(P.Part1);\n    ID.AddInteger(P.Part2);\n    ID.AddInteger(P.Part3);\n    ID.AddInteger(P.getPart4And5AsUint64());\n  }\n  void Profile(llvm::FoldingSetNodeID &ID) { Profile(ID, PartVal); }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Decl::MSGuid; }\n};\n\n/// Insertion operator for diagnostics.  This allows sending an AccessSpecifier\n/// into a diagnostic with <<.\nconst StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                      AccessSpecifier AS);\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_DECLCXX_H\n"}, "6": {"id": 6, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclObjC.h", "content": "//===- DeclObjC.h - Classes for representing declarations -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the DeclObjC interface and subclasses.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_DECLOBJC_H\n#define LLVM_CLANG_AST_DECLOBJC_H\n\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclObjCCommon.h\"\n#include \"clang/AST/ExternalASTSource.h\"\n#include \"clang/AST/Redeclarable.h\"\n#include \"clang/AST/SelectorLocationsKind.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <string>\n#include <utility>\n\nnamespace clang {\n\nclass ASTContext;\nclass CompoundStmt;\nclass CXXCtorInitializer;\nclass Expr;\nclass ObjCCategoryDecl;\nclass ObjCCategoryImplDecl;\nclass ObjCImplementationDecl;\nclass ObjCInterfaceDecl;\nclass ObjCIvarDecl;\nclass ObjCPropertyDecl;\nclass ObjCPropertyImplDecl;\nclass ObjCProtocolDecl;\nclass Stmt;\n\nclass ObjCListBase {\nprotected:\n  /// List is an array of pointers to objects that are not owned by this object.\n  void **List = nullptr;\n  unsigned NumElts = 0;\n\npublic:\n  ObjCListBase() = default;\n  ObjCListBase(const ObjCListBase &) = delete;\n  ObjCListBase &operator=(const ObjCListBase &) = delete;\n\n  unsigned size() const { return NumElts; }\n  bool empty() const { return NumElts == 0; }\n\nprotected:\n  void set(void *const* InList, unsigned Elts, ASTContext &Ctx);\n};\n\n/// ObjCList - This is a simple template class used to hold various lists of\n/// decls etc, which is heavily used by the ObjC front-end.  This only use case\n/// this supports is setting the list all at once and then reading elements out\n/// of it.\ntemplate <typename T>\nclass ObjCList : public ObjCListBase {\npublic:\n  void set(T* const* InList, unsigned Elts, ASTContext &Ctx) {\n    ObjCListBase::set(reinterpret_cast<void*const*>(InList), Elts, Ctx);\n  }\n\n  using iterator = T* const *;\n\n  iterator begin() const { return (iterator)List; }\n  iterator end() const { return (iterator)List+NumElts; }\n\n  T* operator[](unsigned Idx) const {\n    assert(Idx < NumElts && \"Invalid access\");\n    return (T*)List[Idx];\n  }\n};\n\n/// A list of Objective-C protocols, along with the source\n/// locations at which they were referenced.\nclass ObjCProtocolList : public ObjCList<ObjCProtocolDecl> {\n  SourceLocation *Locations = nullptr;\n\n  using ObjCList<ObjCProtocolDecl>::set;\n\npublic:\n  ObjCProtocolList() = default;\n\n  using loc_iterator = const SourceLocation *;\n\n  loc_iterator loc_begin() const { return Locations; }\n  loc_iterator loc_end() const { return Locations + size(); }\n\n  void set(ObjCProtocolDecl* const* InList, unsigned Elts,\n           const SourceLocation *Locs, ASTContext &Ctx);\n};\n\n/// ObjCMethodDecl - Represents an instance or class method declaration.\n/// ObjC methods can be declared within 4 contexts: class interfaces,\n/// categories, protocols, and class implementations. While C++ member\n/// functions leverage C syntax, Objective-C method syntax is modeled after\n/// Smalltalk (using colons to specify argument types/expressions).\n/// Here are some brief examples:\n///\n/// Setter/getter instance methods:\n/// - (void)setMenu:(NSMenu *)menu;\n/// - (NSMenu *)menu;\n///\n/// Instance method that takes 2 NSView arguments:\n/// - (void)replaceSubview:(NSView *)oldView with:(NSView *)newView;\n///\n/// Getter class method:\n/// + (NSMenu *)defaultMenu;\n///\n/// A selector represents a unique name for a method. The selector names for\n/// the above methods are setMenu:, menu, replaceSubview:with:, and defaultMenu.\n///\nclass ObjCMethodDecl : public NamedDecl, public DeclContext {\n  // This class stores some data in DeclContext::ObjCMethodDeclBits\n  // to save some space. Use the provided accessors to access it.\n\npublic:\n  enum ImplementationControl { None, Required, Optional };\n\nprivate:\n  /// Return type of this method.\n  QualType MethodDeclType;\n\n  /// Type source information for the return type.\n  TypeSourceInfo *ReturnTInfo;\n\n  /// Array of ParmVarDecls for the formal parameters of this method\n  /// and optionally followed by selector locations.\n  void *ParamsAndSelLocs = nullptr;\n  unsigned NumParams = 0;\n\n  /// List of attributes for this method declaration.\n  SourceLocation DeclEndLoc; // the location of the ';' or '{'.\n\n  /// The following are only used for method definitions, null otherwise.\n  LazyDeclStmtPtr Body;\n\n  /// SelfDecl - Decl for the implicit self parameter. This is lazily\n  /// constructed by createImplicitParams.\n  ImplicitParamDecl *SelfDecl = nullptr;\n\n  /// CmdDecl - Decl for the implicit _cmd parameter. This is lazily\n  /// constructed by createImplicitParams.\n  ImplicitParamDecl *CmdDecl = nullptr;\n\n  ObjCMethodDecl(SourceLocation beginLoc, SourceLocation endLoc,\n                 Selector SelInfo, QualType T, TypeSourceInfo *ReturnTInfo,\n                 DeclContext *contextDecl, bool isInstance = true,\n                 bool isVariadic = false, bool isPropertyAccessor = false,\n                 bool isSynthesizedAccessorStub = false, \n                 bool isImplicitlyDeclared = false, bool isDefined = false,\n                 ImplementationControl impControl = None,\n                 bool HasRelatedResultType = false);\n\n  SelectorLocationsKind getSelLocsKind() const {\n    return static_cast<SelectorLocationsKind>(ObjCMethodDeclBits.SelLocsKind);\n  }\n\n  void setSelLocsKind(SelectorLocationsKind Kind) {\n    ObjCMethodDeclBits.SelLocsKind = Kind;\n  }\n\n  bool hasStandardSelLocs() const {\n    return getSelLocsKind() != SelLoc_NonStandard;\n  }\n\n  /// Get a pointer to the stored selector identifiers locations array.\n  /// No locations will be stored if HasStandardSelLocs is true.\n  SourceLocation *getStoredSelLocs() {\n    return reinterpret_cast<SourceLocation *>(getParams() + NumParams);\n  }\n  const SourceLocation *getStoredSelLocs() const {\n    return reinterpret_cast<const SourceLocation *>(getParams() + NumParams);\n  }\n\n  /// Get a pointer to the stored selector identifiers locations array.\n  /// No locations will be stored if HasStandardSelLocs is true.\n  ParmVarDecl **getParams() {\n    return reinterpret_cast<ParmVarDecl **>(ParamsAndSelLocs);\n  }\n  const ParmVarDecl *const *getParams() const {\n    return reinterpret_cast<const ParmVarDecl *const *>(ParamsAndSelLocs);\n  }\n\n  /// Get the number of stored selector identifiers locations.\n  /// No locations will be stored if HasStandardSelLocs is true.\n  unsigned getNumStoredSelLocs() const {\n    if (hasStandardSelLocs())\n      return 0;\n    return getNumSelectorLocs();\n  }\n\n  void setParamsAndSelLocs(ASTContext &C,\n                           ArrayRef<ParmVarDecl*> Params,\n                           ArrayRef<SourceLocation> SelLocs);\n\n  /// A definition will return its interface declaration.\n  /// An interface declaration will return its definition.\n  /// Otherwise it will return itself.\n  ObjCMethodDecl *getNextRedeclarationImpl() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static ObjCMethodDecl *\n  Create(ASTContext &C, SourceLocation beginLoc, SourceLocation endLoc,\n         Selector SelInfo, QualType T, TypeSourceInfo *ReturnTInfo,\n         DeclContext *contextDecl, bool isInstance = true,\n         bool isVariadic = false, bool isPropertyAccessor = false,\n         bool isSynthesizedAccessorStub = false,\n         bool isImplicitlyDeclared = false, bool isDefined = false,\n         ImplementationControl impControl = None,\n         bool HasRelatedResultType = false);\n\n  static ObjCMethodDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  ObjCMethodDecl *getCanonicalDecl() override;\n  const ObjCMethodDecl *getCanonicalDecl() const {\n    return const_cast<ObjCMethodDecl*>(this)->getCanonicalDecl();\n  }\n\n  ObjCDeclQualifier getObjCDeclQualifier() const {\n    return static_cast<ObjCDeclQualifier>(ObjCMethodDeclBits.objcDeclQualifier);\n  }\n\n  void setObjCDeclQualifier(ObjCDeclQualifier QV) {\n    ObjCMethodDeclBits.objcDeclQualifier = QV;\n  }\n\n  /// Determine whether this method has a result type that is related\n  /// to the message receiver's type.\n  bool hasRelatedResultType() const {\n    return ObjCMethodDeclBits.RelatedResultType;\n  }\n\n  /// Note whether this method has a related result type.\n  void setRelatedResultType(bool RRT = true) {\n    ObjCMethodDeclBits.RelatedResultType = RRT;\n  }\n\n  /// True if this is a method redeclaration in the same interface.\n  bool isRedeclaration() const { return ObjCMethodDeclBits.IsRedeclaration; }\n  void setIsRedeclaration(bool RD) { ObjCMethodDeclBits.IsRedeclaration = RD; }\n  void setAsRedeclaration(const ObjCMethodDecl *PrevMethod);\n\n  /// True if redeclared in the same interface.\n  bool hasRedeclaration() const { return ObjCMethodDeclBits.HasRedeclaration; }\n  void setHasRedeclaration(bool HRD) const {\n    ObjCMethodDeclBits.HasRedeclaration = HRD;\n  }\n\n  /// Returns the location where the declarator ends. It will be\n  /// the location of ';' for a method declaration and the location of '{'\n  /// for a method definition.\n  SourceLocation getDeclaratorEndLoc() const { return DeclEndLoc; }\n\n  // Location information, modeled after the Stmt API.\n  SourceLocation getBeginLoc() const LLVM_READONLY { return getLocation(); }\n  SourceLocation getEndLoc() const LLVM_READONLY;\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(getLocation(), getEndLoc());\n  }\n\n  SourceLocation getSelectorStartLoc() const {\n    if (isImplicit())\n      return getBeginLoc();\n    return getSelectorLoc(0);\n  }\n\n  SourceLocation getSelectorLoc(unsigned Index) const {\n    assert(Index < getNumSelectorLocs() && \"Index out of range!\");\n    if (hasStandardSelLocs())\n      return getStandardSelectorLoc(Index, getSelector(),\n                                   getSelLocsKind() == SelLoc_StandardWithSpace,\n                                    parameters(),\n                                   DeclEndLoc);\n    return getStoredSelLocs()[Index];\n  }\n\n  void getSelectorLocs(SmallVectorImpl<SourceLocation> &SelLocs) const;\n\n  unsigned getNumSelectorLocs() const {\n    if (isImplicit())\n      return 0;\n    Selector Sel = getSelector();\n    if (Sel.isUnarySelector())\n      return 1;\n    return Sel.getNumArgs();\n  }\n\n  ObjCInterfaceDecl *getClassInterface();\n  const ObjCInterfaceDecl *getClassInterface() const {\n    return const_cast<ObjCMethodDecl*>(this)->getClassInterface();\n  }\n\n  /// If this method is declared or implemented in a category, return\n  /// that category.\n  ObjCCategoryDecl *getCategory();\n  const ObjCCategoryDecl *getCategory() const {\n    return const_cast<ObjCMethodDecl*>(this)->getCategory();\n  }\n\n  Selector getSelector() const { return getDeclName().getObjCSelector(); }\n\n  QualType getReturnType() const { return MethodDeclType; }\n  void setReturnType(QualType T) { MethodDeclType = T; }\n  SourceRange getReturnTypeSourceRange() const;\n\n  /// Determine the type of an expression that sends a message to this\n  /// function. This replaces the type parameters with the types they would\n  /// get if the receiver was parameterless (e.g. it may replace the type\n  /// parameter with 'id').\n  QualType getSendResultType() const;\n\n  /// Determine the type of an expression that sends a message to this\n  /// function with the given receiver type.\n  QualType getSendResultType(QualType receiverType) const;\n\n  TypeSourceInfo *getReturnTypeSourceInfo() const { return ReturnTInfo; }\n  void setReturnTypeSourceInfo(TypeSourceInfo *TInfo) { ReturnTInfo = TInfo; }\n\n  // Iterator access to formal parameters.\n  unsigned param_size() const { return NumParams; }\n\n  using param_const_iterator = const ParmVarDecl *const *;\n  using param_iterator = ParmVarDecl *const *;\n  using param_range = llvm::iterator_range<param_iterator>;\n  using param_const_range = llvm::iterator_range<param_const_iterator>;\n\n  param_const_iterator param_begin() const {\n    return param_const_iterator(getParams());\n  }\n\n  param_const_iterator param_end() const {\n    return param_const_iterator(getParams() + NumParams);\n  }\n\n  param_iterator param_begin() { return param_iterator(getParams()); }\n  param_iterator param_end() { return param_iterator(getParams() + NumParams); }\n\n  // This method returns and of the parameters which are part of the selector\n  // name mangling requirements.\n  param_const_iterator sel_param_end() const {\n    return param_begin() + getSelector().getNumArgs();\n  }\n\n  // ArrayRef access to formal parameters.  This should eventually\n  // replace the iterator interface above.\n  ArrayRef<ParmVarDecl*> parameters() const {\n    return llvm::makeArrayRef(const_cast<ParmVarDecl**>(getParams()),\n                              NumParams);\n  }\n\n  ParmVarDecl *getParamDecl(unsigned Idx) {\n    assert(Idx < NumParams && \"Index out of bounds!\");\n    return getParams()[Idx];\n  }\n  const ParmVarDecl *getParamDecl(unsigned Idx) const {\n    return const_cast<ObjCMethodDecl *>(this)->getParamDecl(Idx);\n  }\n\n  /// Sets the method's parameters and selector source locations.\n  /// If the method is implicit (not coming from source) \\p SelLocs is\n  /// ignored.\n  void setMethodParams(ASTContext &C,\n                       ArrayRef<ParmVarDecl*> Params,\n                       ArrayRef<SourceLocation> SelLocs = llvm::None);\n\n  // Iterator access to parameter types.\n  struct GetTypeFn {\n    QualType operator()(const ParmVarDecl *PD) const { return PD->getType(); }\n  };\n\n  using param_type_iterator =\n      llvm::mapped_iterator<param_const_iterator, GetTypeFn>;\n\n  param_type_iterator param_type_begin() const {\n    return llvm::map_iterator(param_begin(), GetTypeFn());\n  }\n\n  param_type_iterator param_type_end() const {\n    return llvm::map_iterator(param_end(), GetTypeFn());\n  }\n\n  /// createImplicitParams - Used to lazily create the self and cmd\n  /// implicit parameters. This must be called prior to using getSelfDecl()\n  /// or getCmdDecl(). The call is ignored if the implicit parameters\n  /// have already been created.\n  void createImplicitParams(ASTContext &Context, const ObjCInterfaceDecl *ID);\n\n  /// \\return the type for \\c self and set \\arg selfIsPseudoStrong and\n  /// \\arg selfIsConsumed accordingly.\n  QualType getSelfType(ASTContext &Context, const ObjCInterfaceDecl *OID,\n                       bool &selfIsPseudoStrong, bool &selfIsConsumed) const;\n\n  ImplicitParamDecl * getSelfDecl() const { return SelfDecl; }\n  void setSelfDecl(ImplicitParamDecl *SD) { SelfDecl = SD; }\n  ImplicitParamDecl * getCmdDecl() const { return CmdDecl; }\n  void setCmdDecl(ImplicitParamDecl *CD) { CmdDecl = CD; }\n\n  /// Determines the family of this method.\n  ObjCMethodFamily getMethodFamily() const;\n\n  bool isInstanceMethod() const { return ObjCMethodDeclBits.IsInstance; }\n  void setInstanceMethod(bool isInst) {\n    ObjCMethodDeclBits.IsInstance = isInst;\n  }\n\n  bool isVariadic() const { return ObjCMethodDeclBits.IsVariadic; }\n  void setVariadic(bool isVar) { ObjCMethodDeclBits.IsVariadic = isVar; }\n\n  bool isClassMethod() const { return !isInstanceMethod(); }\n\n  bool isPropertyAccessor() const {\n    return ObjCMethodDeclBits.IsPropertyAccessor;\n  }\n\n  void setPropertyAccessor(bool isAccessor) {\n    ObjCMethodDeclBits.IsPropertyAccessor = isAccessor;\n  }\n\n  bool isSynthesizedAccessorStub() const {\n    return ObjCMethodDeclBits.IsSynthesizedAccessorStub;\n  }\n\n  void setSynthesizedAccessorStub(bool isSynthesizedAccessorStub) {\n    ObjCMethodDeclBits.IsSynthesizedAccessorStub = isSynthesizedAccessorStub;\n  }\n\n  bool isDefined() const { return ObjCMethodDeclBits.IsDefined; }\n  void setDefined(bool isDefined) { ObjCMethodDeclBits.IsDefined = isDefined; }\n\n  /// Whether this method overrides any other in the class hierarchy.\n  ///\n  /// A method is said to override any method in the class's\n  /// base classes, its protocols, or its categories' protocols, that has\n  /// the same selector and is of the same kind (class or instance).\n  /// A method in an implementation is not considered as overriding the same\n  /// method in the interface or its categories.\n  bool isOverriding() const { return ObjCMethodDeclBits.IsOverriding; }\n  void setOverriding(bool IsOver) { ObjCMethodDeclBits.IsOverriding = IsOver; }\n\n  /// Return overridden methods for the given \\p Method.\n  ///\n  /// An ObjC method is considered to override any method in the class's\n  /// base classes (and base's categories), its protocols, or its categories'\n  /// protocols, that has\n  /// the same selector and is of the same kind (class or instance).\n  /// A method in an implementation is not considered as overriding the same\n  /// method in the interface or its categories.\n  void getOverriddenMethods(\n                     SmallVectorImpl<const ObjCMethodDecl *> &Overridden) const;\n\n  /// True if the method was a definition but its body was skipped.\n  bool hasSkippedBody() const { return ObjCMethodDeclBits.HasSkippedBody; }\n  void setHasSkippedBody(bool Skipped = true) {\n    ObjCMethodDeclBits.HasSkippedBody = Skipped;\n  }\n\n  /// True if the method is tagged as objc_direct\n  bool isDirectMethod() const;\n\n  /// Returns the property associated with this method's selector.\n  ///\n  /// Note that even if this particular method is not marked as a property\n  /// accessor, it is still possible for it to match a property declared in a\n  /// superclass. Pass \\c false if you only want to check the current class.\n  const ObjCPropertyDecl *findPropertyDecl(bool CheckOverrides = true) const;\n\n  // Related to protocols declared in  \\@protocol\n  void setDeclImplementation(ImplementationControl ic) {\n    ObjCMethodDeclBits.DeclImplementation = ic;\n  }\n\n  ImplementationControl getImplementationControl() const {\n    return ImplementationControl(ObjCMethodDeclBits.DeclImplementation);\n  }\n\n  bool isOptional() const {\n    return getImplementationControl() == Optional;\n  }\n\n  /// Returns true if this specific method declaration is marked with the\n  /// designated initializer attribute.\n  bool isThisDeclarationADesignatedInitializer() const;\n\n  /// Returns true if the method selector resolves to a designated initializer\n  /// in the class's interface.\n  ///\n  /// \\param InitMethod if non-null and the function returns true, it receives\n  /// the method declaration that was marked with the designated initializer\n  /// attribute.\n  bool isDesignatedInitializerForTheInterface(\n      const ObjCMethodDecl **InitMethod = nullptr) const;\n\n  /// Determine whether this method has a body.\n  bool hasBody() const override { return Body.isValid(); }\n\n  /// Retrieve the body of this method, if it has one.\n  Stmt *getBody() const override;\n\n  void setLazyBody(uint64_t Offset) { Body = Offset; }\n\n  CompoundStmt *getCompoundBody() { return (CompoundStmt*)getBody(); }\n  void setBody(Stmt *B) { Body = B; }\n\n  /// Returns whether this specific method is a definition.\n  bool isThisDeclarationADefinition() const { return hasBody(); }\n\n  /// Is this method defined in the NSObject base class?\n  bool definedInNSObject(const ASTContext &) const;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCMethod; }\n\n  static DeclContext *castToDeclContext(const ObjCMethodDecl *D) {\n    return static_cast<DeclContext *>(const_cast<ObjCMethodDecl*>(D));\n  }\n\n  static ObjCMethodDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<ObjCMethodDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Describes the variance of a given generic parameter.\nenum class ObjCTypeParamVariance : uint8_t {\n  /// The parameter is invariant: must match exactly.\n  Invariant,\n\n  /// The parameter is covariant, e.g., X<T> is a subtype of X<U> when\n  /// the type parameter is covariant and T is a subtype of U.\n  Covariant,\n\n  /// The parameter is contravariant, e.g., X<T> is a subtype of X<U>\n  /// when the type parameter is covariant and U is a subtype of T.\n  Contravariant,\n};\n\n/// Represents the declaration of an Objective-C type parameter.\n///\n/// \\code\n/// @interface NSDictionary<Key : id<NSCopying>, Value>\n/// @end\n/// \\endcode\n///\n/// In the example above, both \\c Key and \\c Value are represented by\n/// \\c ObjCTypeParamDecl. \\c Key has an explicit bound of \\c id<NSCopying>,\n/// while \\c Value gets an implicit bound of \\c id.\n///\n/// Objective-C type parameters are typedef-names in the grammar,\nclass ObjCTypeParamDecl : public TypedefNameDecl {\n  /// Index of this type parameter in the type parameter list.\n  unsigned Index : 14;\n\n  /// The variance of the type parameter.\n  unsigned Variance : 2;\n\n  /// The location of the variance, if any.\n  SourceLocation VarianceLoc;\n\n  /// The location of the ':', which will be valid when the bound was\n  /// explicitly specified.\n  SourceLocation ColonLoc;\n\n  ObjCTypeParamDecl(ASTContext &ctx, DeclContext *dc,\n                    ObjCTypeParamVariance variance, SourceLocation varianceLoc,\n                    unsigned index,\n                    SourceLocation nameLoc, IdentifierInfo *name,\n                    SourceLocation colonLoc, TypeSourceInfo *boundInfo)\n      : TypedefNameDecl(ObjCTypeParam, ctx, dc, nameLoc, nameLoc, name,\n                        boundInfo),\n        Index(index), Variance(static_cast<unsigned>(variance)),\n        VarianceLoc(varianceLoc), ColonLoc(colonLoc) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static ObjCTypeParamDecl *Create(ASTContext &ctx, DeclContext *dc,\n                                   ObjCTypeParamVariance variance,\n                                   SourceLocation varianceLoc,\n                                   unsigned index,\n                                   SourceLocation nameLoc,\n                                   IdentifierInfo *name,\n                                   SourceLocation colonLoc,\n                                   TypeSourceInfo *boundInfo);\n  static ObjCTypeParamDecl *CreateDeserialized(ASTContext &ctx, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  /// Determine the variance of this type parameter.\n  ObjCTypeParamVariance getVariance() const {\n    return static_cast<ObjCTypeParamVariance>(Variance);\n  }\n\n  /// Set the variance of this type parameter.\n  void setVariance(ObjCTypeParamVariance variance) {\n    Variance = static_cast<unsigned>(variance);\n  }\n\n  /// Retrieve the location of the variance keyword.\n  SourceLocation getVarianceLoc() const { return VarianceLoc; }\n\n  /// Retrieve the index into its type parameter list.\n  unsigned getIndex() const { return Index; }\n\n  /// Whether this type parameter has an explicitly-written type bound, e.g.,\n  /// \"T : NSView\".\n  bool hasExplicitBound() const { return ColonLoc.isValid(); }\n\n  /// Retrieve the location of the ':' separating the type parameter name\n  /// from the explicitly-specified bound.\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCTypeParam; }\n};\n\n/// Stores a list of Objective-C type parameters for a parameterized class\n/// or a category/extension thereof.\n///\n/// \\code\n/// @interface NSArray<T> // stores the <T>\n/// @end\n/// \\endcode\nclass ObjCTypeParamList final\n    : private llvm::TrailingObjects<ObjCTypeParamList, ObjCTypeParamDecl *> {\n  /// Location of the left and right angle brackets.\n  SourceRange Brackets;\n  /// The number of parameters in the list, which are tail-allocated.\n  unsigned NumParams;\n\n  ObjCTypeParamList(SourceLocation lAngleLoc,\n                    ArrayRef<ObjCTypeParamDecl *> typeParams,\n                    SourceLocation rAngleLoc);\n\npublic:\n  friend TrailingObjects;\n\n  /// Create a new Objective-C type parameter list.\n  static ObjCTypeParamList *create(ASTContext &ctx,\n                                   SourceLocation lAngleLoc,\n                                   ArrayRef<ObjCTypeParamDecl *> typeParams,\n                                   SourceLocation rAngleLoc);\n\n  /// Iterate through the type parameters in the list.\n  using iterator = ObjCTypeParamDecl **;\n\n  iterator begin() { return getTrailingObjects<ObjCTypeParamDecl *>(); }\n\n  iterator end() { return begin() + size(); }\n\n  /// Determine the number of type parameters in this list.\n  unsigned size() const { return NumParams; }\n\n  // Iterate through the type parameters in the list.\n  using const_iterator = ObjCTypeParamDecl * const *;\n\n  const_iterator begin() const {\n    return getTrailingObjects<ObjCTypeParamDecl *>();\n  }\n\n  const_iterator end() const {\n    return begin() + size();\n  }\n\n  ObjCTypeParamDecl *front() const {\n    assert(size() > 0 && \"empty Objective-C type parameter list\");\n    return *begin();\n  }\n\n  ObjCTypeParamDecl *back() const {\n    assert(size() > 0 && \"empty Objective-C type parameter list\");\n    return *(end() - 1);\n  }\n\n  SourceLocation getLAngleLoc() const { return Brackets.getBegin(); }\n  SourceLocation getRAngleLoc() const { return Brackets.getEnd(); }\n  SourceRange getSourceRange() const { return Brackets; }\n\n  /// Gather the default set of type arguments to be substituted for\n  /// these type parameters when dealing with an unspecialized type.\n  void gatherDefaultTypeArgs(SmallVectorImpl<QualType> &typeArgs) const;\n};\n\nenum class ObjCPropertyQueryKind : uint8_t {\n  OBJC_PR_query_unknown = 0x00,\n  OBJC_PR_query_instance,\n  OBJC_PR_query_class\n};\n\n/// Represents one property declaration in an Objective-C interface.\n///\n/// For example:\n/// \\code{.mm}\n/// \\@property (assign, readwrite) int MyProperty;\n/// \\endcode\nclass ObjCPropertyDecl : public NamedDecl {\n  void anchor() override;\n\npublic:\n  enum SetterKind { Assign, Retain, Copy, Weak };\n  enum PropertyControl { None, Required, Optional };\n\nprivate:\n  // location of \\@property\n  SourceLocation AtLoc;\n\n  // location of '(' starting attribute list or null.\n  SourceLocation LParenLoc;\n\n  QualType DeclType;\n  TypeSourceInfo *DeclTypeSourceInfo;\n  unsigned PropertyAttributes : NumObjCPropertyAttrsBits;\n  unsigned PropertyAttributesAsWritten : NumObjCPropertyAttrsBits;\n\n  // \\@required/\\@optional\n  unsigned PropertyImplementation : 2;\n\n  // getter name of NULL if no getter\n  Selector GetterName;\n\n  // setter name of NULL if no setter\n  Selector SetterName;\n\n  // location of the getter attribute's value\n  SourceLocation GetterNameLoc;\n\n  // location of the setter attribute's value\n  SourceLocation SetterNameLoc;\n\n  // Declaration of getter instance method\n  ObjCMethodDecl *GetterMethodDecl = nullptr;\n\n  // Declaration of setter instance method\n  ObjCMethodDecl *SetterMethodDecl = nullptr;\n\n  // Synthesize ivar for this property\n  ObjCIvarDecl *PropertyIvarDecl = nullptr;\n\n  ObjCPropertyDecl(DeclContext *DC, SourceLocation L, IdentifierInfo *Id,\n                   SourceLocation AtLocation, SourceLocation LParenLocation,\n                   QualType T, TypeSourceInfo *TSI, PropertyControl propControl)\n      : NamedDecl(ObjCProperty, DC, L, Id), AtLoc(AtLocation),\n        LParenLoc(LParenLocation), DeclType(T), DeclTypeSourceInfo(TSI),\n        PropertyAttributes(ObjCPropertyAttribute::kind_noattr),\n        PropertyAttributesAsWritten(ObjCPropertyAttribute::kind_noattr),\n        PropertyImplementation(propControl), GetterName(Selector()),\n        SetterName(Selector()) {}\n\npublic:\n  static ObjCPropertyDecl *Create(ASTContext &C, DeclContext *DC,\n                                  SourceLocation L,\n                                  IdentifierInfo *Id, SourceLocation AtLocation,\n                                  SourceLocation LParenLocation,\n                                  QualType T,\n                                  TypeSourceInfo *TSI,\n                                  PropertyControl propControl = None);\n\n  static ObjCPropertyDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceLocation getAtLoc() const { return AtLoc; }\n  void setAtLoc(SourceLocation L) { AtLoc = L; }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  void setLParenLoc(SourceLocation L) { LParenLoc = L; }\n\n  TypeSourceInfo *getTypeSourceInfo() const { return DeclTypeSourceInfo; }\n\n  QualType getType() const { return DeclType; }\n\n  void setType(QualType T, TypeSourceInfo *TSI) {\n    DeclType = T;\n    DeclTypeSourceInfo = TSI;\n  }\n\n  /// Retrieve the type when this property is used with a specific base object\n  /// type.\n  QualType getUsageType(QualType objectType) const;\n\n  ObjCPropertyAttribute::Kind getPropertyAttributes() const {\n    return ObjCPropertyAttribute::Kind(PropertyAttributes);\n  }\n\n  void setPropertyAttributes(ObjCPropertyAttribute::Kind PRVal) {\n    PropertyAttributes |= PRVal;\n  }\n\n  void overwritePropertyAttributes(unsigned PRVal) {\n    PropertyAttributes = PRVal;\n  }\n\n  ObjCPropertyAttribute::Kind getPropertyAttributesAsWritten() const {\n    return ObjCPropertyAttribute::Kind(PropertyAttributesAsWritten);\n  }\n\n  void setPropertyAttributesAsWritten(ObjCPropertyAttribute::Kind PRVal) {\n    PropertyAttributesAsWritten = PRVal;\n  }\n\n  // Helper methods for accessing attributes.\n\n  /// isReadOnly - Return true iff the property has a setter.\n  bool isReadOnly() const {\n    return (PropertyAttributes & ObjCPropertyAttribute::kind_readonly);\n  }\n\n  /// isAtomic - Return true if the property is atomic.\n  bool isAtomic() const {\n    return (PropertyAttributes & ObjCPropertyAttribute::kind_atomic);\n  }\n\n  /// isRetaining - Return true if the property retains its value.\n  bool isRetaining() const {\n    return (PropertyAttributes & (ObjCPropertyAttribute::kind_retain |\n                                  ObjCPropertyAttribute::kind_strong |\n                                  ObjCPropertyAttribute::kind_copy));\n  }\n\n  bool isInstanceProperty() const { return !isClassProperty(); }\n  bool isClassProperty() const {\n    return PropertyAttributes & ObjCPropertyAttribute::kind_class;\n  }\n  bool isDirectProperty() const {\n    return PropertyAttributes & ObjCPropertyAttribute::kind_direct;\n  }\n\n  ObjCPropertyQueryKind getQueryKind() const {\n    return isClassProperty() ? ObjCPropertyQueryKind::OBJC_PR_query_class :\n                               ObjCPropertyQueryKind::OBJC_PR_query_instance;\n  }\n\n  static ObjCPropertyQueryKind getQueryKind(bool isClassProperty) {\n    return isClassProperty ? ObjCPropertyQueryKind::OBJC_PR_query_class :\n                             ObjCPropertyQueryKind::OBJC_PR_query_instance;\n  }\n\n  /// getSetterKind - Return the method used for doing assignment in\n  /// the property setter. This is only valid if the property has been\n  /// defined to have a setter.\n  SetterKind getSetterKind() const {\n    if (PropertyAttributes & ObjCPropertyAttribute::kind_strong)\n      return getType()->isBlockPointerType() ? Copy : Retain;\n    if (PropertyAttributes & ObjCPropertyAttribute::kind_retain)\n      return Retain;\n    if (PropertyAttributes & ObjCPropertyAttribute::kind_copy)\n      return Copy;\n    if (PropertyAttributes & ObjCPropertyAttribute::kind_weak)\n      return Weak;\n    return Assign;\n  }\n\n  Selector getGetterName() const { return GetterName; }\n  SourceLocation getGetterNameLoc() const { return GetterNameLoc; }\n\n  void setGetterName(Selector Sel, SourceLocation Loc = SourceLocation()) {\n    GetterName = Sel;\n    GetterNameLoc = Loc;\n  }\n\n  Selector getSetterName() const { return SetterName; }\n  SourceLocation getSetterNameLoc() const { return SetterNameLoc; }\n\n  void setSetterName(Selector Sel, SourceLocation Loc = SourceLocation()) {\n    SetterName = Sel;\n    SetterNameLoc = Loc;\n  }\n\n  ObjCMethodDecl *getGetterMethodDecl() const { return GetterMethodDecl; }\n  void setGetterMethodDecl(ObjCMethodDecl *gDecl) { GetterMethodDecl = gDecl; }\n\n  ObjCMethodDecl *getSetterMethodDecl() const { return SetterMethodDecl; }\n  void setSetterMethodDecl(ObjCMethodDecl *gDecl) { SetterMethodDecl = gDecl; }\n\n  // Related to \\@optional/\\@required declared in \\@protocol\n  void setPropertyImplementation(PropertyControl pc) {\n    PropertyImplementation = pc;\n  }\n\n  PropertyControl getPropertyImplementation() const {\n    return PropertyControl(PropertyImplementation);\n  }\n\n  bool isOptional() const {\n    return getPropertyImplementation() == PropertyControl::Optional;\n  }\n\n  void setPropertyIvarDecl(ObjCIvarDecl *Ivar) {\n    PropertyIvarDecl = Ivar;\n  }\n\n  ObjCIvarDecl *getPropertyIvarDecl() const {\n    return PropertyIvarDecl;\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(AtLoc, getLocation());\n  }\n\n  /// Get the default name of the synthesized ivar.\n  IdentifierInfo *getDefaultSynthIvarName(ASTContext &Ctx) const;\n\n  /// Lookup a property by name in the specified DeclContext.\n  static ObjCPropertyDecl *findPropertyDecl(const DeclContext *DC,\n                                            const IdentifierInfo *propertyID,\n                                            ObjCPropertyQueryKind queryKind);\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCProperty; }\n};\n\n/// ObjCContainerDecl - Represents a container for method declarations.\n/// Current sub-classes are ObjCInterfaceDecl, ObjCCategoryDecl,\n/// ObjCProtocolDecl, and ObjCImplDecl.\n///\nclass ObjCContainerDecl : public NamedDecl, public DeclContext {\n  // This class stores some data in DeclContext::ObjCContainerDeclBits\n  // to save some space. Use the provided accessors to access it.\n\n  // These two locations in the range mark the end of the method container.\n  // The first points to the '@' token, and the second to the 'end' token.\n  SourceRange AtEnd;\n\n  void anchor() override;\n\npublic:\n  ObjCContainerDecl(Kind DK, DeclContext *DC, IdentifierInfo *Id,\n                    SourceLocation nameLoc, SourceLocation atStartLoc);\n\n  // Iterator access to instance/class properties.\n  using prop_iterator = specific_decl_iterator<ObjCPropertyDecl>;\n  using prop_range =\n      llvm::iterator_range<specific_decl_iterator<ObjCPropertyDecl>>;\n\n  prop_range properties() const { return prop_range(prop_begin(), prop_end()); }\n\n  prop_iterator prop_begin() const {\n    return prop_iterator(decls_begin());\n  }\n\n  prop_iterator prop_end() const {\n    return prop_iterator(decls_end());\n  }\n\n  using instprop_iterator =\n      filtered_decl_iterator<ObjCPropertyDecl,\n                             &ObjCPropertyDecl::isInstanceProperty>;\n  using instprop_range = llvm::iterator_range<instprop_iterator>;\n\n  instprop_range instance_properties() const {\n    return instprop_range(instprop_begin(), instprop_end());\n  }\n\n  instprop_iterator instprop_begin() const {\n    return instprop_iterator(decls_begin());\n  }\n\n  instprop_iterator instprop_end() const {\n    return instprop_iterator(decls_end());\n  }\n\n  using classprop_iterator =\n      filtered_decl_iterator<ObjCPropertyDecl,\n                             &ObjCPropertyDecl::isClassProperty>;\n  using classprop_range = llvm::iterator_range<classprop_iterator>;\n\n  classprop_range class_properties() const {\n    return classprop_range(classprop_begin(), classprop_end());\n  }\n\n  classprop_iterator classprop_begin() const {\n    return classprop_iterator(decls_begin());\n  }\n\n  classprop_iterator classprop_end() const {\n    return classprop_iterator(decls_end());\n  }\n\n  // Iterator access to instance/class methods.\n  using method_iterator = specific_decl_iterator<ObjCMethodDecl>;\n  using method_range =\n      llvm::iterator_range<specific_decl_iterator<ObjCMethodDecl>>;\n\n  method_range methods() const {\n    return method_range(meth_begin(), meth_end());\n  }\n\n  method_iterator meth_begin() const {\n    return method_iterator(decls_begin());\n  }\n\n  method_iterator meth_end() const {\n    return method_iterator(decls_end());\n  }\n\n  using instmeth_iterator =\n      filtered_decl_iterator<ObjCMethodDecl,\n                             &ObjCMethodDecl::isInstanceMethod>;\n  using instmeth_range = llvm::iterator_range<instmeth_iterator>;\n\n  instmeth_range instance_methods() const {\n    return instmeth_range(instmeth_begin(), instmeth_end());\n  }\n\n  instmeth_iterator instmeth_begin() const {\n    return instmeth_iterator(decls_begin());\n  }\n\n  instmeth_iterator instmeth_end() const {\n    return instmeth_iterator(decls_end());\n  }\n\n  using classmeth_iterator =\n      filtered_decl_iterator<ObjCMethodDecl,\n                             &ObjCMethodDecl::isClassMethod>;\n  using classmeth_range = llvm::iterator_range<classmeth_iterator>;\n\n  classmeth_range class_methods() const {\n    return classmeth_range(classmeth_begin(), classmeth_end());\n  }\n\n  classmeth_iterator classmeth_begin() const {\n    return classmeth_iterator(decls_begin());\n  }\n\n  classmeth_iterator classmeth_end() const {\n    return classmeth_iterator(decls_end());\n  }\n\n  // Get the local instance/class method declared in this interface.\n  ObjCMethodDecl *getMethod(Selector Sel, bool isInstance,\n                            bool AllowHidden = false) const;\n\n  ObjCMethodDecl *getInstanceMethod(Selector Sel,\n                                    bool AllowHidden = false) const {\n    return getMethod(Sel, true/*isInstance*/, AllowHidden);\n  }\n\n  ObjCMethodDecl *getClassMethod(Selector Sel, bool AllowHidden = false) const {\n    return getMethod(Sel, false/*isInstance*/, AllowHidden);\n  }\n\n  bool HasUserDeclaredSetterMethod(const ObjCPropertyDecl *P) const;\n  ObjCIvarDecl *getIvarDecl(IdentifierInfo *Id) const;\n\n  ObjCPropertyDecl *\n  FindPropertyDeclaration(const IdentifierInfo *PropertyId,\n                          ObjCPropertyQueryKind QueryKind) const;\n\n  using PropertyMap =\n      llvm::DenseMap<std::pair<IdentifierInfo *, unsigned/*isClassProperty*/>,\n                     ObjCPropertyDecl *>;\n  using ProtocolPropertySet = llvm::SmallDenseSet<const ObjCProtocolDecl *, 8>;\n  using PropertyDeclOrder = llvm::SmallVector<ObjCPropertyDecl *, 8>;\n\n  /// This routine collects list of properties to be implemented in the class.\n  /// This includes, class's and its conforming protocols' properties.\n  /// Note, the superclass's properties are not included in the list.\n  virtual void collectPropertiesToImplement(PropertyMap &PM,\n                                            PropertyDeclOrder &PO) const {}\n\n  SourceLocation getAtStartLoc() const { return ObjCContainerDeclBits.AtStart; }\n\n  void setAtStartLoc(SourceLocation Loc) {\n    ObjCContainerDeclBits.AtStart = Loc;\n  }\n\n  // Marks the end of the container.\n  SourceRange getAtEndRange() const { return AtEnd; }\n\n  void setAtEndRange(SourceRange atEnd) { AtEnd = atEnd; }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(getAtStartLoc(), getAtEndRange().getEnd());\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K >= firstObjCContainer &&\n           K <= lastObjCContainer;\n  }\n\n  static DeclContext *castToDeclContext(const ObjCContainerDecl *D) {\n    return static_cast<DeclContext *>(const_cast<ObjCContainerDecl*>(D));\n  }\n\n  static ObjCContainerDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<ObjCContainerDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Represents an ObjC class declaration.\n///\n/// For example:\n///\n/// \\code\n///   // MostPrimitive declares no super class (not particularly useful).\n///   \\@interface MostPrimitive\n///     // no instance variables or methods.\n///   \\@end\n///\n///   // NSResponder inherits from NSObject & implements NSCoding (a protocol).\n///   \\@interface NSResponder : NSObject \\<NSCoding>\n///   { // instance variables are represented by ObjCIvarDecl.\n///     id nextResponder; // nextResponder instance variable.\n///   }\n///   - (NSResponder *)nextResponder; // return a pointer to NSResponder.\n///   - (void)mouseMoved:(NSEvent *)theEvent; // return void, takes a pointer\n///   \\@end                                    // to an NSEvent.\n/// \\endcode\n///\n///   Unlike C/C++, forward class declarations are accomplished with \\@class.\n///   Unlike C/C++, \\@class allows for a list of classes to be forward declared.\n///   Unlike C++, ObjC is a single-rooted class model. In Cocoa, classes\n///   typically inherit from NSObject (an exception is NSProxy).\n///\nclass ObjCInterfaceDecl : public ObjCContainerDecl\n                        , public Redeclarable<ObjCInterfaceDecl> {\n  friend class ASTContext;\n\n  /// TypeForDecl - This indicates the Type object that represents this\n  /// TypeDecl.  It is a cache maintained by ASTContext::getObjCInterfaceType\n  mutable const Type *TypeForDecl = nullptr;\n\n  struct DefinitionData {\n    /// The definition of this class, for quick access from any\n    /// declaration.\n    ObjCInterfaceDecl *Definition = nullptr;\n\n    /// When non-null, this is always an ObjCObjectType.\n    TypeSourceInfo *SuperClassTInfo = nullptr;\n\n    /// Protocols referenced in the \\@interface  declaration\n    ObjCProtocolList ReferencedProtocols;\n\n    /// Protocols reference in both the \\@interface and class extensions.\n    ObjCList<ObjCProtocolDecl> AllReferencedProtocols;\n\n    /// List of categories and class extensions defined for this class.\n    ///\n    /// Categories are stored as a linked list in the AST, since the categories\n    /// and class extensions come long after the initial interface declaration,\n    /// and we avoid dynamically-resized arrays in the AST wherever possible.\n    ObjCCategoryDecl *CategoryList = nullptr;\n\n    /// IvarList - List of all ivars defined by this class; including class\n    /// extensions and implementation. This list is built lazily.\n    ObjCIvarDecl *IvarList = nullptr;\n\n    /// Indicates that the contents of this Objective-C class will be\n    /// completed by the external AST source when required.\n    mutable unsigned ExternallyCompleted : 1;\n\n    /// Indicates that the ivar cache does not yet include ivars\n    /// declared in the implementation.\n    mutable unsigned IvarListMissingImplementation : 1;\n\n    /// Indicates that this interface decl contains at least one initializer\n    /// marked with the 'objc_designated_initializer' attribute.\n    unsigned HasDesignatedInitializers : 1;\n\n    enum InheritedDesignatedInitializersState {\n      /// We didn't calculate whether the designated initializers should be\n      /// inherited or not.\n      IDI_Unknown = 0,\n\n      /// Designated initializers are inherited for the super class.\n      IDI_Inherited = 1,\n\n      /// The class does not inherit designated initializers.\n      IDI_NotInherited = 2\n    };\n\n    /// One of the \\c InheritedDesignatedInitializersState enumeratos.\n    mutable unsigned InheritedDesignatedInitializers : 2;\n\n    /// The location of the last location in this declaration, before\n    /// the properties/methods. For example, this will be the '>', '}', or\n    /// identifier,\n    SourceLocation EndLoc;\n\n    DefinitionData()\n        : ExternallyCompleted(false), IvarListMissingImplementation(true),\n          HasDesignatedInitializers(false),\n          InheritedDesignatedInitializers(IDI_Unknown) {}\n  };\n\n  /// The type parameters associated with this class, if any.\n  ObjCTypeParamList *TypeParamList = nullptr;\n\n  /// Contains a pointer to the data associated with this class,\n  /// which will be NULL if this class has not yet been defined.\n  ///\n  /// The bit indicates when we don't need to check for out-of-date\n  /// declarations. It will be set unless modules are enabled.\n  llvm::PointerIntPair<DefinitionData *, 1, bool> Data;\n\n  ObjCInterfaceDecl(const ASTContext &C, DeclContext *DC, SourceLocation AtLoc,\n                    IdentifierInfo *Id, ObjCTypeParamList *typeParamList,\n                    SourceLocation CLoc, ObjCInterfaceDecl *PrevDecl,\n                    bool IsInternal);\n\n  void anchor() override;\n\n  void LoadExternalDefinition() const;\n\n  DefinitionData &data() const {\n    assert(Data.getPointer() && \"Declaration has no definition!\");\n    return *Data.getPointer();\n  }\n\n  /// Allocate the definition data for this class.\n  void allocateDefinitionData();\n\n  using redeclarable_base = Redeclarable<ObjCInterfaceDecl>;\n\n  ObjCInterfaceDecl *getNextRedeclarationImpl() override {\n    return getNextRedeclaration();\n  }\n\n  ObjCInterfaceDecl *getPreviousDeclImpl() override {\n    return getPreviousDecl();\n  }\n\n  ObjCInterfaceDecl *getMostRecentDeclImpl() override {\n    return getMostRecentDecl();\n  }\n\npublic:\n  static ObjCInterfaceDecl *Create(const ASTContext &C, DeclContext *DC,\n                                   SourceLocation atLoc,\n                                   IdentifierInfo *Id,\n                                   ObjCTypeParamList *typeParamList,\n                                   ObjCInterfaceDecl *PrevDecl,\n                                   SourceLocation ClassLoc = SourceLocation(),\n                                   bool isInternal = false);\n\n  static ObjCInterfaceDecl *CreateDeserialized(const ASTContext &C, unsigned ID);\n\n  /// Retrieve the type parameters of this class.\n  ///\n  /// This function looks for a type parameter list for the given\n  /// class; if the class has been declared (with \\c \\@class) but not\n  /// defined (with \\c \\@interface), it will search for a declaration that\n  /// has type parameters, skipping any declarations that do not.\n  ObjCTypeParamList *getTypeParamList() const;\n\n  /// Set the type parameters of this class.\n  ///\n  /// This function is used by the AST importer, which must import the type\n  /// parameters after creating their DeclContext to avoid loops.\n  void setTypeParamList(ObjCTypeParamList *TPL);\n\n  /// Retrieve the type parameters written on this particular declaration of\n  /// the class.\n  ObjCTypeParamList *getTypeParamListAsWritten() const {\n    return TypeParamList;\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    if (isThisDeclarationADefinition())\n      return ObjCContainerDecl::getSourceRange();\n\n    return SourceRange(getAtStartLoc(), getLocation());\n  }\n\n  /// Indicate that this Objective-C class is complete, but that\n  /// the external AST source will be responsible for filling in its contents\n  /// when a complete class is required.\n  void setExternallyCompleted();\n\n  /// Indicate that this interface decl contains at least one initializer\n  /// marked with the 'objc_designated_initializer' attribute.\n  void setHasDesignatedInitializers();\n\n  /// Returns true if this interface decl contains at least one initializer\n  /// marked with the 'objc_designated_initializer' attribute.\n  bool hasDesignatedInitializers() const;\n\n  /// Returns true if this interface decl declares a designated initializer\n  /// or it inherites one from its super class.\n  bool declaresOrInheritsDesignatedInitializers() const {\n    return hasDesignatedInitializers() || inheritsDesignatedInitializers();\n  }\n\n  const ObjCProtocolList &getReferencedProtocols() const {\n    assert(hasDefinition() && \"Caller did not check for forward reference!\");\n    if (data().ExternallyCompleted)\n      LoadExternalDefinition();\n\n    return data().ReferencedProtocols;\n  }\n\n  ObjCImplementationDecl *getImplementation() const;\n  void setImplementation(ObjCImplementationDecl *ImplD);\n\n  ObjCCategoryDecl *FindCategoryDeclaration(IdentifierInfo *CategoryId) const;\n\n  // Get the local instance/class method declared in a category.\n  ObjCMethodDecl *getCategoryInstanceMethod(Selector Sel) const;\n  ObjCMethodDecl *getCategoryClassMethod(Selector Sel) const;\n\n  ObjCMethodDecl *getCategoryMethod(Selector Sel, bool isInstance) const {\n    return isInstance ? getCategoryInstanceMethod(Sel)\n                      : getCategoryClassMethod(Sel);\n  }\n\n  using protocol_iterator = ObjCProtocolList::iterator;\n  using protocol_range = llvm::iterator_range<protocol_iterator>;\n\n  protocol_range protocols() const {\n    return protocol_range(protocol_begin(), protocol_end());\n  }\n\n  protocol_iterator protocol_begin() const {\n    // FIXME: Should make sure no callers ever do this.\n    if (!hasDefinition())\n      return protocol_iterator();\n\n    if (data().ExternallyCompleted)\n      LoadExternalDefinition();\n\n    return data().ReferencedProtocols.begin();\n  }\n\n  protocol_iterator protocol_end() const {\n    // FIXME: Should make sure no callers ever do this.\n    if (!hasDefinition())\n      return protocol_iterator();\n\n    if (data().ExternallyCompleted)\n      LoadExternalDefinition();\n\n    return data().ReferencedProtocols.end();\n  }\n\n  using protocol_loc_iterator = ObjCProtocolList::loc_iterator;\n  using protocol_loc_range = llvm::iterator_range<protocol_loc_iterator>;\n\n  protocol_loc_range protocol_locs() const {\n    return protocol_loc_range(protocol_loc_begin(), protocol_loc_end());\n  }\n\n  protocol_loc_iterator protocol_loc_begin() const {\n    // FIXME: Should make sure no callers ever do this.\n    if (!hasDefinition())\n      return protocol_loc_iterator();\n\n    if (data().ExternallyCompleted)\n      LoadExternalDefinition();\n\n    return data().ReferencedProtocols.loc_begin();\n  }\n\n  protocol_loc_iterator protocol_loc_end() const {\n    // FIXME: Should make sure no callers ever do this.\n    if (!hasDefinition())\n      return protocol_loc_iterator();\n\n    if (data().ExternallyCompleted)\n      LoadExternalDefinition();\n\n    return data().ReferencedProtocols.loc_end();\n  }\n\n  using all_protocol_iterator = ObjCList<ObjCProtocolDecl>::iterator;\n  using all_protocol_range = llvm::iterator_range<all_protocol_iterator>;\n\n  all_protocol_range all_referenced_protocols() const {\n    return all_protocol_range(all_referenced_protocol_begin(),\n                              all_referenced_protocol_end());\n  }\n\n  all_protocol_iterator all_referenced_protocol_begin() const {\n    // FIXME: Should make sure no callers ever do this.\n    if (!hasDefinition())\n      return all_protocol_iterator();\n\n    if (data().ExternallyCompleted)\n      LoadExternalDefinition();\n\n    return data().AllReferencedProtocols.empty()\n             ? protocol_begin()\n             : data().AllReferencedProtocols.begin();\n  }\n\n  all_protocol_iterator all_referenced_protocol_end() const {\n    // FIXME: Should make sure no callers ever do this.\n    if (!hasDefinition())\n      return all_protocol_iterator();\n\n    if (data().ExternallyCompleted)\n      LoadExternalDefinition();\n\n    return data().AllReferencedProtocols.empty()\n             ? protocol_end()\n             : data().AllReferencedProtocols.end();\n  }\n\n  using ivar_iterator = specific_decl_iterator<ObjCIvarDecl>;\n  using ivar_range = llvm::iterator_range<specific_decl_iterator<ObjCIvarDecl>>;\n\n  ivar_range ivars() const { return ivar_range(ivar_begin(), ivar_end()); }\n\n  ivar_iterator ivar_begin() const {\n    if (const ObjCInterfaceDecl *Def = getDefinition())\n      return ivar_iterator(Def->decls_begin());\n\n    // FIXME: Should make sure no callers ever do this.\n    return ivar_iterator();\n  }\n\n  ivar_iterator ivar_end() const {\n    if (const ObjCInterfaceDecl *Def = getDefinition())\n      return ivar_iterator(Def->decls_end());\n\n    // FIXME: Should make sure no callers ever do this.\n    return ivar_iterator();\n  }\n\n  unsigned ivar_size() const {\n    return std::distance(ivar_begin(), ivar_end());\n  }\n\n  bool ivar_empty() const { return ivar_begin() == ivar_end(); }\n\n  ObjCIvarDecl *all_declared_ivar_begin();\n  const ObjCIvarDecl *all_declared_ivar_begin() const {\n    // Even though this modifies IvarList, it's conceptually const:\n    // the ivar chain is essentially a cached property of ObjCInterfaceDecl.\n    return const_cast<ObjCInterfaceDecl *>(this)->all_declared_ivar_begin();\n  }\n  void setIvarList(ObjCIvarDecl *ivar) { data().IvarList = ivar; }\n\n  /// setProtocolList - Set the list of protocols that this interface\n  /// implements.\n  void setProtocolList(ObjCProtocolDecl *const* List, unsigned Num,\n                       const SourceLocation *Locs, ASTContext &C) {\n    data().ReferencedProtocols.set(List, Num, Locs, C);\n  }\n\n  /// mergeClassExtensionProtocolList - Merge class extension's protocol list\n  /// into the protocol list for this class.\n  void mergeClassExtensionProtocolList(ObjCProtocolDecl *const* List,\n                                       unsigned Num,\n                                       ASTContext &C);\n\n  /// Produce a name to be used for class's metadata. It comes either via\n  /// objc_runtime_name attribute or class name.\n  StringRef getObjCRuntimeNameAsString() const;\n\n  /// Returns the designated initializers for the interface.\n  ///\n  /// If this declaration does not have methods marked as designated\n  /// initializers then the interface inherits the designated initializers of\n  /// its super class.\n  void getDesignatedInitializers(\n                  llvm::SmallVectorImpl<const ObjCMethodDecl *> &Methods) const;\n\n  /// Returns true if the given selector is a designated initializer for the\n  /// interface.\n  ///\n  /// If this declaration does not have methods marked as designated\n  /// initializers then the interface inherits the designated initializers of\n  /// its super class.\n  ///\n  /// \\param InitMethod if non-null and the function returns true, it receives\n  /// the method that was marked as a designated initializer.\n  bool\n  isDesignatedInitializer(Selector Sel,\n                          const ObjCMethodDecl **InitMethod = nullptr) const;\n\n  /// Determine whether this particular declaration of this class is\n  /// actually also a definition.\n  bool isThisDeclarationADefinition() const {\n    return getDefinition() == this;\n  }\n\n  /// Determine whether this class has been defined.\n  bool hasDefinition() const {\n    // If the name of this class is out-of-date, bring it up-to-date, which\n    // might bring in a definition.\n    // Note: a null value indicates that we don't have a definition and that\n    // modules are enabled.\n    if (!Data.getOpaqueValue())\n      getMostRecentDecl();\n\n    return Data.getPointer();\n  }\n\n  /// Retrieve the definition of this class, or NULL if this class\n  /// has been forward-declared (with \\@class) but not yet defined (with\n  /// \\@interface).\n  ObjCInterfaceDecl *getDefinition() {\n    return hasDefinition()? Data.getPointer()->Definition : nullptr;\n  }\n\n  /// Retrieve the definition of this class, or NULL if this class\n  /// has been forward-declared (with \\@class) but not yet defined (with\n  /// \\@interface).\n  const ObjCInterfaceDecl *getDefinition() const {\n    return hasDefinition()? Data.getPointer()->Definition : nullptr;\n  }\n\n  /// Starts the definition of this Objective-C class, taking it from\n  /// a forward declaration (\\@class) to a definition (\\@interface).\n  void startDefinition();\n\n  /// Retrieve the superclass type.\n  const ObjCObjectType *getSuperClassType() const {\n    if (TypeSourceInfo *TInfo = getSuperClassTInfo())\n      return TInfo->getType()->castAs<ObjCObjectType>();\n\n    return nullptr;\n  }\n\n  // Retrieve the type source information for the superclass.\n  TypeSourceInfo *getSuperClassTInfo() const {\n    // FIXME: Should make sure no callers ever do this.\n    if (!hasDefinition())\n      return nullptr;\n\n    if (data().ExternallyCompleted)\n      LoadExternalDefinition();\n\n    return data().SuperClassTInfo;\n  }\n\n  // Retrieve the declaration for the superclass of this class, which\n  // does not include any type arguments that apply to the superclass.\n  ObjCInterfaceDecl *getSuperClass() const;\n\n  void setSuperClass(TypeSourceInfo *superClass) {\n    data().SuperClassTInfo = superClass;\n  }\n\n  /// Iterator that walks over the list of categories, filtering out\n  /// those that do not meet specific criteria.\n  ///\n  /// This class template is used for the various permutations of category\n  /// and extension iterators.\n  template<bool (*Filter)(ObjCCategoryDecl *)>\n  class filtered_category_iterator {\n    ObjCCategoryDecl *Current = nullptr;\n\n    void findAcceptableCategory();\n\n  public:\n    using value_type = ObjCCategoryDecl *;\n    using reference = value_type;\n    using pointer = value_type;\n    using difference_type = std::ptrdiff_t;\n    using iterator_category = std::input_iterator_tag;\n\n    filtered_category_iterator() = default;\n    explicit filtered_category_iterator(ObjCCategoryDecl *Current)\n        : Current(Current) {\n      findAcceptableCategory();\n    }\n\n    reference operator*() const { return Current; }\n    pointer operator->() const { return Current; }\n\n    filtered_category_iterator &operator++();\n\n    filtered_category_iterator operator++(int) {\n      filtered_category_iterator Tmp = *this;\n      ++(*this);\n      return Tmp;\n    }\n\n    friend bool operator==(filtered_category_iterator X,\n                           filtered_category_iterator Y) {\n      return X.Current == Y.Current;\n    }\n\n    friend bool operator!=(filtered_category_iterator X,\n                           filtered_category_iterator Y) {\n      return X.Current != Y.Current;\n    }\n  };\n\nprivate:\n  /// Test whether the given category is visible.\n  ///\n  /// Used in the \\c visible_categories_iterator.\n  static bool isVisibleCategory(ObjCCategoryDecl *Cat);\n\npublic:\n  /// Iterator that walks over the list of categories and extensions\n  /// that are visible, i.e., not hidden in a non-imported submodule.\n  using visible_categories_iterator =\n      filtered_category_iterator<isVisibleCategory>;\n\n  using visible_categories_range =\n      llvm::iterator_range<visible_categories_iterator>;\n\n  visible_categories_range visible_categories() const {\n    return visible_categories_range(visible_categories_begin(),\n                                    visible_categories_end());\n  }\n\n  /// Retrieve an iterator to the beginning of the visible-categories\n  /// list.\n  visible_categories_iterator visible_categories_begin() const {\n    return visible_categories_iterator(getCategoryListRaw());\n  }\n\n  /// Retrieve an iterator to the end of the visible-categories list.\n  visible_categories_iterator visible_categories_end() const {\n    return visible_categories_iterator();\n  }\n\n  /// Determine whether the visible-categories list is empty.\n  bool visible_categories_empty() const {\n    return visible_categories_begin() == visible_categories_end();\n  }\n\nprivate:\n  /// Test whether the given category... is a category.\n  ///\n  /// Used in the \\c known_categories_iterator.\n  static bool isKnownCategory(ObjCCategoryDecl *) { return true; }\n\npublic:\n  /// Iterator that walks over all of the known categories and\n  /// extensions, including those that are hidden.\n  using known_categories_iterator = filtered_category_iterator<isKnownCategory>;\n  using known_categories_range =\n     llvm::iterator_range<known_categories_iterator>;\n\n  known_categories_range known_categories() const {\n    return known_categories_range(known_categories_begin(),\n                                  known_categories_end());\n  }\n\n  /// Retrieve an iterator to the beginning of the known-categories\n  /// list.\n  known_categories_iterator known_categories_begin() const {\n    return known_categories_iterator(getCategoryListRaw());\n  }\n\n  /// Retrieve an iterator to the end of the known-categories list.\n  known_categories_iterator known_categories_end() const {\n    return known_categories_iterator();\n  }\n\n  /// Determine whether the known-categories list is empty.\n  bool known_categories_empty() const {\n    return known_categories_begin() == known_categories_end();\n  }\n\nprivate:\n  /// Test whether the given category is a visible extension.\n  ///\n  /// Used in the \\c visible_extensions_iterator.\n  static bool isVisibleExtension(ObjCCategoryDecl *Cat);\n\npublic:\n  /// Iterator that walks over all of the visible extensions, skipping\n  /// any that are known but hidden.\n  using visible_extensions_iterator =\n      filtered_category_iterator<isVisibleExtension>;\n\n  using visible_extensions_range =\n      llvm::iterator_range<visible_extensions_iterator>;\n\n  visible_extensions_range visible_extensions() const {\n    return visible_extensions_range(visible_extensions_begin(),\n                                    visible_extensions_end());\n  }\n\n  /// Retrieve an iterator to the beginning of the visible-extensions\n  /// list.\n  visible_extensions_iterator visible_extensions_begin() const {\n    return visible_extensions_iterator(getCategoryListRaw());\n  }\n\n  /// Retrieve an iterator to the end of the visible-extensions list.\n  visible_extensions_iterator visible_extensions_end() const {\n    return visible_extensions_iterator();\n  }\n\n  /// Determine whether the visible-extensions list is empty.\n  bool visible_extensions_empty() const {\n    return visible_extensions_begin() == visible_extensions_end();\n  }\n\nprivate:\n  /// Test whether the given category is an extension.\n  ///\n  /// Used in the \\c known_extensions_iterator.\n  static bool isKnownExtension(ObjCCategoryDecl *Cat);\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend class ASTReader;\n\n  /// Iterator that walks over all of the known extensions.\n  using known_extensions_iterator =\n      filtered_category_iterator<isKnownExtension>;\n  using known_extensions_range =\n      llvm::iterator_range<known_extensions_iterator>;\n\n  known_extensions_range known_extensions() const {\n    return known_extensions_range(known_extensions_begin(),\n                                  known_extensions_end());\n  }\n\n  /// Retrieve an iterator to the beginning of the known-extensions\n  /// list.\n  known_extensions_iterator known_extensions_begin() const {\n    return known_extensions_iterator(getCategoryListRaw());\n  }\n\n  /// Retrieve an iterator to the end of the known-extensions list.\n  known_extensions_iterator known_extensions_end() const {\n    return known_extensions_iterator();\n  }\n\n  /// Determine whether the known-extensions list is empty.\n  bool known_extensions_empty() const {\n    return known_extensions_begin() == known_extensions_end();\n  }\n\n  /// Retrieve the raw pointer to the start of the category/extension\n  /// list.\n  ObjCCategoryDecl* getCategoryListRaw() const {\n    // FIXME: Should make sure no callers ever do this.\n    if (!hasDefinition())\n      return nullptr;\n\n    if (data().ExternallyCompleted)\n      LoadExternalDefinition();\n\n    return data().CategoryList;\n  }\n\n  /// Set the raw pointer to the start of the category/extension\n  /// list.\n  void setCategoryListRaw(ObjCCategoryDecl *category) {\n    data().CategoryList = category;\n  }\n\n  ObjCPropertyDecl\n    *FindPropertyVisibleInPrimaryClass(IdentifierInfo *PropertyId,\n                                       ObjCPropertyQueryKind QueryKind) const;\n\n  void collectPropertiesToImplement(PropertyMap &PM,\n                                    PropertyDeclOrder &PO) const override;\n\n  /// isSuperClassOf - Return true if this class is the specified class or is a\n  /// super class of the specified interface class.\n  bool isSuperClassOf(const ObjCInterfaceDecl *I) const {\n    // If RHS is derived from LHS it is OK; else it is not OK.\n    while (I != nullptr) {\n      if (declaresSameEntity(this, I))\n        return true;\n\n      I = I->getSuperClass();\n    }\n    return false;\n  }\n\n  /// isArcWeakrefUnavailable - Checks for a class or one of its super classes\n  /// to be incompatible with __weak references. Returns true if it is.\n  bool isArcWeakrefUnavailable() const;\n\n  /// isObjCRequiresPropertyDefs - Checks that a class or one of its super\n  /// classes must not be auto-synthesized. Returns class decl. if it must not\n  /// be; 0, otherwise.\n  const ObjCInterfaceDecl *isObjCRequiresPropertyDefs() const;\n\n  ObjCIvarDecl *lookupInstanceVariable(IdentifierInfo *IVarName,\n                                       ObjCInterfaceDecl *&ClassDeclared);\n  ObjCIvarDecl *lookupInstanceVariable(IdentifierInfo *IVarName) {\n    ObjCInterfaceDecl *ClassDeclared;\n    return lookupInstanceVariable(IVarName, ClassDeclared);\n  }\n\n  ObjCProtocolDecl *lookupNestedProtocol(IdentifierInfo *Name);\n\n  // Lookup a method. First, we search locally. If a method isn't\n  // found, we search referenced protocols and class categories.\n  ObjCMethodDecl *lookupMethod(Selector Sel, bool isInstance,\n                               bool shallowCategoryLookup = false,\n                               bool followSuper = true,\n                               const ObjCCategoryDecl *C = nullptr) const;\n\n  /// Lookup an instance method for a given selector.\n  ObjCMethodDecl *lookupInstanceMethod(Selector Sel) const {\n    return lookupMethod(Sel, true/*isInstance*/);\n  }\n\n  /// Lookup a class method for a given selector.\n  ObjCMethodDecl *lookupClassMethod(Selector Sel) const {\n    return lookupMethod(Sel, false/*isInstance*/);\n  }\n\n  ObjCInterfaceDecl *lookupInheritedClass(const IdentifierInfo *ICName);\n\n  /// Lookup a method in the classes implementation hierarchy.\n  ObjCMethodDecl *lookupPrivateMethod(const Selector &Sel,\n                                      bool Instance=true) const;\n\n  ObjCMethodDecl *lookupPrivateClassMethod(const Selector &Sel) {\n    return lookupPrivateMethod(Sel, false);\n  }\n\n  /// Lookup a setter or getter in the class hierarchy,\n  /// including in all categories except for category passed\n  /// as argument.\n  ObjCMethodDecl *lookupPropertyAccessor(const Selector Sel,\n                                         const ObjCCategoryDecl *Cat,\n                                         bool IsClassProperty) const {\n    return lookupMethod(Sel, !IsClassProperty/*isInstance*/,\n                        false/*shallowCategoryLookup*/,\n                        true /* followsSuper */,\n                        Cat);\n  }\n\n  SourceLocation getEndOfDefinitionLoc() const {\n    if (!hasDefinition())\n      return getLocation();\n\n    return data().EndLoc;\n  }\n\n  void setEndOfDefinitionLoc(SourceLocation LE) { data().EndLoc = LE; }\n\n  /// Retrieve the starting location of the superclass.\n  SourceLocation getSuperClassLoc() const;\n\n  /// isImplicitInterfaceDecl - check that this is an implicitly declared\n  /// ObjCInterfaceDecl node. This is for legacy objective-c \\@implementation\n  /// declaration without an \\@interface declaration.\n  bool isImplicitInterfaceDecl() const {\n    return hasDefinition() ? data().Definition->isImplicit() : isImplicit();\n  }\n\n  /// ClassImplementsProtocol - Checks that 'lProto' protocol\n  /// has been implemented in IDecl class, its super class or categories (if\n  /// lookupCategory is true).\n  bool ClassImplementsProtocol(ObjCProtocolDecl *lProto,\n                               bool lookupCategory,\n                               bool RHSIsQualifiedID = false);\n\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  /// Retrieves the canonical declaration of this Objective-C class.\n  ObjCInterfaceDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const ObjCInterfaceDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  // Low-level accessor\n  const Type *getTypeForDecl() const { return TypeForDecl; }\n  void setTypeForDecl(const Type *TD) const { TypeForDecl = TD; }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCInterface; }\n\nprivate:\n  const ObjCInterfaceDecl *findInterfaceWithDesignatedInitializers() const;\n  bool inheritsDesignatedInitializers() const;\n};\n\n/// ObjCIvarDecl - Represents an ObjC instance variable. In general, ObjC\n/// instance variables are identical to C. The only exception is Objective-C\n/// supports C++ style access control. For example:\n///\n///   \\@interface IvarExample : NSObject\n///   {\n///     id defaultToProtected;\n///   \\@public:\n///     id canBePublic; // same as C++.\n///   \\@protected:\n///     id canBeProtected; // same as C++.\n///   \\@package:\n///     id canBePackage; // framework visibility (not available in C++).\n///   }\n///\nclass ObjCIvarDecl : public FieldDecl {\n  void anchor() override;\n\npublic:\n  enum AccessControl {\n    None, Private, Protected, Public, Package\n  };\n\nprivate:\n  ObjCIvarDecl(ObjCContainerDecl *DC, SourceLocation StartLoc,\n               SourceLocation IdLoc, IdentifierInfo *Id,\n               QualType T, TypeSourceInfo *TInfo, AccessControl ac, Expr *BW,\n               bool synthesized)\n      : FieldDecl(ObjCIvar, DC, StartLoc, IdLoc, Id, T, TInfo, BW,\n                  /*Mutable=*/false, /*HasInit=*/ICIS_NoInit),\n        DeclAccess(ac), Synthesized(synthesized) {}\n\npublic:\n  static ObjCIvarDecl *Create(ASTContext &C, ObjCContainerDecl *DC,\n                              SourceLocation StartLoc, SourceLocation IdLoc,\n                              IdentifierInfo *Id, QualType T,\n                              TypeSourceInfo *TInfo,\n                              AccessControl ac, Expr *BW = nullptr,\n                              bool synthesized=false);\n\n  static ObjCIvarDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// Return the class interface that this ivar is logically contained\n  /// in; this is either the interface where the ivar was declared, or the\n  /// interface the ivar is conceptually a part of in the case of synthesized\n  /// ivars.\n  const ObjCInterfaceDecl *getContainingInterface() const;\n\n  ObjCIvarDecl *getNextIvar() { return NextIvar; }\n  const ObjCIvarDecl *getNextIvar() const { return NextIvar; }\n  void setNextIvar(ObjCIvarDecl *ivar) { NextIvar = ivar; }\n\n  void setAccessControl(AccessControl ac) { DeclAccess = ac; }\n\n  AccessControl getAccessControl() const { return AccessControl(DeclAccess); }\n\n  AccessControl getCanonicalAccessControl() const {\n    return DeclAccess == None ? Protected : AccessControl(DeclAccess);\n  }\n\n  void setSynthesize(bool synth) { Synthesized = synth; }\n  bool getSynthesize() const { return Synthesized; }\n\n  /// Retrieve the type of this instance variable when viewed as a member of a\n  /// specific object type.\n  QualType getUsageType(QualType objectType) const;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCIvar; }\n\nprivate:\n  /// NextIvar - Next Ivar in the list of ivars declared in class; class's\n  /// extensions and class's implementation\n  ObjCIvarDecl *NextIvar = nullptr;\n\n  // NOTE: VC++ treats enums as signed, avoid using the AccessControl enum\n  unsigned DeclAccess : 3;\n  unsigned Synthesized : 1;\n};\n\n/// Represents a field declaration created by an \\@defs(...).\nclass ObjCAtDefsFieldDecl : public FieldDecl {\n  ObjCAtDefsFieldDecl(DeclContext *DC, SourceLocation StartLoc,\n                      SourceLocation IdLoc, IdentifierInfo *Id,\n                      QualType T, Expr *BW)\n      : FieldDecl(ObjCAtDefsField, DC, StartLoc, IdLoc, Id, T,\n                  /*TInfo=*/nullptr, // FIXME: Do ObjCAtDefs have declarators ?\n                  BW, /*Mutable=*/false, /*HasInit=*/ICIS_NoInit) {}\n\n  void anchor() override;\n\npublic:\n  static ObjCAtDefsFieldDecl *Create(ASTContext &C, DeclContext *DC,\n                                     SourceLocation StartLoc,\n                                     SourceLocation IdLoc, IdentifierInfo *Id,\n                                     QualType T, Expr *BW);\n\n  static ObjCAtDefsFieldDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCAtDefsField; }\n};\n\n/// Represents an Objective-C protocol declaration.\n///\n/// Objective-C protocols declare a pure abstract type (i.e., no instance\n/// variables are permitted).  Protocols originally drew inspiration from\n/// C++ pure virtual functions (a C++ feature with nice semantics and lousy\n/// syntax:-). Here is an example:\n///\n/// \\code\n/// \\@protocol NSDraggingInfo <refproto1, refproto2>\n/// - (NSWindow *)draggingDestinationWindow;\n/// - (NSImage *)draggedImage;\n/// \\@end\n/// \\endcode\n///\n/// This says that NSDraggingInfo requires two methods and requires everything\n/// that the two \"referenced protocols\" 'refproto1' and 'refproto2' require as\n/// well.\n///\n/// \\code\n/// \\@interface ImplementsNSDraggingInfo : NSObject \\<NSDraggingInfo>\n/// \\@end\n/// \\endcode\n///\n/// ObjC protocols inspired Java interfaces. Unlike Java, ObjC classes and\n/// protocols are in distinct namespaces. For example, Cocoa defines both\n/// an NSObject protocol and class (which isn't allowed in Java). As a result,\n/// protocols are referenced using angle brackets as follows:\n///\n/// id \\<NSDraggingInfo> anyObjectThatImplementsNSDraggingInfo;\nclass ObjCProtocolDecl : public ObjCContainerDecl,\n                         public Redeclarable<ObjCProtocolDecl> {\n  struct DefinitionData {\n    // The declaration that defines this protocol.\n    ObjCProtocolDecl *Definition;\n\n    /// Referenced protocols\n    ObjCProtocolList ReferencedProtocols;\n  };\n\n  /// Contains a pointer to the data associated with this class,\n  /// which will be NULL if this class has not yet been defined.\n  ///\n  /// The bit indicates when we don't need to check for out-of-date\n  /// declarations. It will be set unless modules are enabled.\n  llvm::PointerIntPair<DefinitionData *, 1, bool> Data;\n\n  ObjCProtocolDecl(ASTContext &C, DeclContext *DC, IdentifierInfo *Id,\n                   SourceLocation nameLoc, SourceLocation atStartLoc,\n                   ObjCProtocolDecl *PrevDecl);\n\n  void anchor() override;\n\n  DefinitionData &data() const {\n    assert(Data.getPointer() && \"Objective-C protocol has no definition!\");\n    return *Data.getPointer();\n  }\n\n  void allocateDefinitionData();\n\n  using redeclarable_base = Redeclarable<ObjCProtocolDecl>;\n\n  ObjCProtocolDecl *getNextRedeclarationImpl() override {\n    return getNextRedeclaration();\n  }\n\n  ObjCProtocolDecl *getPreviousDeclImpl() override {\n    return getPreviousDecl();\n  }\n\n  ObjCProtocolDecl *getMostRecentDeclImpl() override {\n    return getMostRecentDecl();\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend class ASTReader;\n\n  static ObjCProtocolDecl *Create(ASTContext &C, DeclContext *DC,\n                                  IdentifierInfo *Id,\n                                  SourceLocation nameLoc,\n                                  SourceLocation atStartLoc,\n                                  ObjCProtocolDecl *PrevDecl);\n\n  static ObjCProtocolDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  const ObjCProtocolList &getReferencedProtocols() const {\n    assert(hasDefinition() && \"No definition available!\");\n    return data().ReferencedProtocols;\n  }\n\n  using protocol_iterator = ObjCProtocolList::iterator;\n  using protocol_range = llvm::iterator_range<protocol_iterator>;\n\n  protocol_range protocols() const {\n    return protocol_range(protocol_begin(), protocol_end());\n  }\n\n  protocol_iterator protocol_begin() const {\n    if (!hasDefinition())\n      return protocol_iterator();\n\n    return data().ReferencedProtocols.begin();\n  }\n\n  protocol_iterator protocol_end() const {\n    if (!hasDefinition())\n      return protocol_iterator();\n\n    return data().ReferencedProtocols.end();\n  }\n\n  using protocol_loc_iterator = ObjCProtocolList::loc_iterator;\n  using protocol_loc_range = llvm::iterator_range<protocol_loc_iterator>;\n\n  protocol_loc_range protocol_locs() const {\n    return protocol_loc_range(protocol_loc_begin(), protocol_loc_end());\n  }\n\n  protocol_loc_iterator protocol_loc_begin() const {\n    if (!hasDefinition())\n      return protocol_loc_iterator();\n\n    return data().ReferencedProtocols.loc_begin();\n  }\n\n  protocol_loc_iterator protocol_loc_end() const {\n    if (!hasDefinition())\n      return protocol_loc_iterator();\n\n    return data().ReferencedProtocols.loc_end();\n  }\n\n  unsigned protocol_size() const {\n    if (!hasDefinition())\n      return 0;\n\n    return data().ReferencedProtocols.size();\n  }\n\n  /// setProtocolList - Set the list of protocols that this interface\n  /// implements.\n  void setProtocolList(ObjCProtocolDecl *const*List, unsigned Num,\n                       const SourceLocation *Locs, ASTContext &C) {\n    assert(hasDefinition() && \"Protocol is not defined\");\n    data().ReferencedProtocols.set(List, Num, Locs, C);\n  }\n\n  /// This is true iff the protocol is tagged with the\n  /// `objc_non_runtime_protocol` attribute.\n  bool isNonRuntimeProtocol() const;\n\n  /// Get the set of all protocols implied by this protocols inheritance\n  /// hierarchy.\n  void getImpliedProtocols(llvm::DenseSet<const ObjCProtocolDecl *> &IPs) const;\n\n  ObjCProtocolDecl *lookupProtocolNamed(IdentifierInfo *PName);\n\n  // Lookup a method. First, we search locally. If a method isn't\n  // found, we search referenced protocols and class categories.\n  ObjCMethodDecl *lookupMethod(Selector Sel, bool isInstance) const;\n\n  ObjCMethodDecl *lookupInstanceMethod(Selector Sel) const {\n    return lookupMethod(Sel, true/*isInstance*/);\n  }\n\n  ObjCMethodDecl *lookupClassMethod(Selector Sel) const {\n    return lookupMethod(Sel, false/*isInstance*/);\n  }\n\n  /// Determine whether this protocol has a definition.\n  bool hasDefinition() const {\n    // If the name of this protocol is out-of-date, bring it up-to-date, which\n    // might bring in a definition.\n    // Note: a null value indicates that we don't have a definition and that\n    // modules are enabled.\n    if (!Data.getOpaqueValue())\n      getMostRecentDecl();\n\n    return Data.getPointer();\n  }\n\n  /// Retrieve the definition of this protocol, if any.\n  ObjCProtocolDecl *getDefinition() {\n    return hasDefinition()? Data.getPointer()->Definition : nullptr;\n  }\n\n  /// Retrieve the definition of this protocol, if any.\n  const ObjCProtocolDecl *getDefinition() const {\n    return hasDefinition()? Data.getPointer()->Definition : nullptr;\n  }\n\n  /// Determine whether this particular declaration is also the\n  /// definition.\n  bool isThisDeclarationADefinition() const {\n    return getDefinition() == this;\n  }\n\n  /// Starts the definition of this Objective-C protocol.\n  void startDefinition();\n\n  /// Produce a name to be used for protocol's metadata. It comes either via\n  /// objc_runtime_name attribute or protocol name.\n  StringRef getObjCRuntimeNameAsString() const;\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    if (isThisDeclarationADefinition())\n      return ObjCContainerDecl::getSourceRange();\n\n    return SourceRange(getAtStartLoc(), getLocation());\n  }\n\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  /// Retrieves the canonical declaration of this Objective-C protocol.\n  ObjCProtocolDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const ObjCProtocolDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  void collectPropertiesToImplement(PropertyMap &PM,\n                                    PropertyDeclOrder &PO) const override;\n\n  void collectInheritedProtocolProperties(const ObjCPropertyDecl *Property,\n                                          ProtocolPropertySet &PS,\n                                          PropertyDeclOrder &PO) const;\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCProtocol; }\n};\n\n/// ObjCCategoryDecl - Represents a category declaration. A category allows\n/// you to add methods to an existing class (without subclassing or modifying\n/// the original class interface or implementation:-). Categories don't allow\n/// you to add instance data. The following example adds \"myMethod\" to all\n/// NSView's within a process:\n///\n/// \\@interface NSView (MyViewMethods)\n/// - myMethod;\n/// \\@end\n///\n/// Categories also allow you to split the implementation of a class across\n/// several files (a feature more naturally supported in C++).\n///\n/// Categories were originally inspired by dynamic languages such as Common\n/// Lisp and Smalltalk.  More traditional class-based languages (C++, Java)\n/// don't support this level of dynamism, which is both powerful and dangerous.\nclass ObjCCategoryDecl : public ObjCContainerDecl {\n  /// Interface belonging to this category\n  ObjCInterfaceDecl *ClassInterface;\n\n  /// The type parameters associated with this category, if any.\n  ObjCTypeParamList *TypeParamList = nullptr;\n\n  /// referenced protocols in this category.\n  ObjCProtocolList ReferencedProtocols;\n\n  /// Next category belonging to this class.\n  /// FIXME: this should not be a singly-linked list.  Move storage elsewhere.\n  ObjCCategoryDecl *NextClassCategory = nullptr;\n\n  /// The location of the category name in this declaration.\n  SourceLocation CategoryNameLoc;\n\n  /// class extension may have private ivars.\n  SourceLocation IvarLBraceLoc;\n  SourceLocation IvarRBraceLoc;\n\n  ObjCCategoryDecl(DeclContext *DC, SourceLocation AtLoc,\n                   SourceLocation ClassNameLoc, SourceLocation CategoryNameLoc,\n                   IdentifierInfo *Id, ObjCInterfaceDecl *IDecl,\n                   ObjCTypeParamList *typeParamList,\n                   SourceLocation IvarLBraceLoc = SourceLocation(),\n                   SourceLocation IvarRBraceLoc = SourceLocation());\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static ObjCCategoryDecl *Create(ASTContext &C, DeclContext *DC,\n                                  SourceLocation AtLoc,\n                                  SourceLocation ClassNameLoc,\n                                  SourceLocation CategoryNameLoc,\n                                  IdentifierInfo *Id,\n                                  ObjCInterfaceDecl *IDecl,\n                                  ObjCTypeParamList *typeParamList,\n                                  SourceLocation IvarLBraceLoc=SourceLocation(),\n                                  SourceLocation IvarRBraceLoc=SourceLocation());\n  static ObjCCategoryDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  ObjCInterfaceDecl *getClassInterface() { return ClassInterface; }\n  const ObjCInterfaceDecl *getClassInterface() const { return ClassInterface; }\n\n  /// Retrieve the type parameter list associated with this category or\n  /// extension.\n  ObjCTypeParamList *getTypeParamList() const { return TypeParamList; }\n\n  /// Set the type parameters of this category.\n  ///\n  /// This function is used by the AST importer, which must import the type\n  /// parameters after creating their DeclContext to avoid loops.\n  void setTypeParamList(ObjCTypeParamList *TPL);\n\n\n  ObjCCategoryImplDecl *getImplementation() const;\n  void setImplementation(ObjCCategoryImplDecl *ImplD);\n\n  /// setProtocolList - Set the list of protocols that this interface\n  /// implements.\n  void setProtocolList(ObjCProtocolDecl *const*List, unsigned Num,\n                       const SourceLocation *Locs, ASTContext &C) {\n    ReferencedProtocols.set(List, Num, Locs, C);\n  }\n\n  const ObjCProtocolList &getReferencedProtocols() const {\n    return ReferencedProtocols;\n  }\n\n  using protocol_iterator = ObjCProtocolList::iterator;\n  using protocol_range = llvm::iterator_range<protocol_iterator>;\n\n  protocol_range protocols() const {\n    return protocol_range(protocol_begin(), protocol_end());\n  }\n\n  protocol_iterator protocol_begin() const {\n    return ReferencedProtocols.begin();\n  }\n\n  protocol_iterator protocol_end() const { return ReferencedProtocols.end(); }\n  unsigned protocol_size() const { return ReferencedProtocols.size(); }\n\n  using protocol_loc_iterator = ObjCProtocolList::loc_iterator;\n  using protocol_loc_range = llvm::iterator_range<protocol_loc_iterator>;\n\n  protocol_loc_range protocol_locs() const {\n    return protocol_loc_range(protocol_loc_begin(), protocol_loc_end());\n  }\n\n  protocol_loc_iterator protocol_loc_begin() const {\n    return ReferencedProtocols.loc_begin();\n  }\n\n  protocol_loc_iterator protocol_loc_end() const {\n    return ReferencedProtocols.loc_end();\n  }\n\n  ObjCCategoryDecl *getNextClassCategory() const { return NextClassCategory; }\n\n  /// Retrieve the pointer to the next stored category (or extension),\n  /// which may be hidden.\n  ObjCCategoryDecl *getNextClassCategoryRaw() const {\n    return NextClassCategory;\n  }\n\n  bool IsClassExtension() const { return getIdentifier() == nullptr; }\n\n  using ivar_iterator = specific_decl_iterator<ObjCIvarDecl>;\n  using ivar_range = llvm::iterator_range<specific_decl_iterator<ObjCIvarDecl>>;\n\n  ivar_range ivars() const { return ivar_range(ivar_begin(), ivar_end()); }\n\n  ivar_iterator ivar_begin() const {\n    return ivar_iterator(decls_begin());\n  }\n\n  ivar_iterator ivar_end() const {\n    return ivar_iterator(decls_end());\n  }\n\n  unsigned ivar_size() const {\n    return std::distance(ivar_begin(), ivar_end());\n  }\n\n  bool ivar_empty() const {\n    return ivar_begin() == ivar_end();\n  }\n\n  SourceLocation getCategoryNameLoc() const { return CategoryNameLoc; }\n  void setCategoryNameLoc(SourceLocation Loc) { CategoryNameLoc = Loc; }\n\n  void setIvarLBraceLoc(SourceLocation Loc) { IvarLBraceLoc = Loc; }\n  SourceLocation getIvarLBraceLoc() const { return IvarLBraceLoc; }\n  void setIvarRBraceLoc(SourceLocation Loc) { IvarRBraceLoc = Loc; }\n  SourceLocation getIvarRBraceLoc() const { return IvarRBraceLoc; }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCCategory; }\n};\n\nclass ObjCImplDecl : public ObjCContainerDecl {\n  /// Class interface for this class/category implementation\n  ObjCInterfaceDecl *ClassInterface;\n\n  void anchor() override;\n\nprotected:\n  ObjCImplDecl(Kind DK, DeclContext *DC,\n               ObjCInterfaceDecl *classInterface,\n               IdentifierInfo *Id,\n               SourceLocation nameLoc, SourceLocation atStartLoc)\n      : ObjCContainerDecl(DK, DC, Id, nameLoc, atStartLoc),\n        ClassInterface(classInterface) {}\n\npublic:\n  const ObjCInterfaceDecl *getClassInterface() const { return ClassInterface; }\n  ObjCInterfaceDecl *getClassInterface() { return ClassInterface; }\n  void setClassInterface(ObjCInterfaceDecl *IFace);\n\n  void addInstanceMethod(ObjCMethodDecl *method) {\n    // FIXME: Context should be set correctly before we get here.\n    method->setLexicalDeclContext(this);\n    addDecl(method);\n  }\n\n  void addClassMethod(ObjCMethodDecl *method) {\n    // FIXME: Context should be set correctly before we get here.\n    method->setLexicalDeclContext(this);\n    addDecl(method);\n  }\n\n  void addPropertyImplementation(ObjCPropertyImplDecl *property);\n\n  ObjCPropertyImplDecl *FindPropertyImplDecl(IdentifierInfo *propertyId,\n                            ObjCPropertyQueryKind queryKind) const;\n  ObjCPropertyImplDecl *FindPropertyImplIvarDecl(IdentifierInfo *ivarId) const;\n\n  // Iterator access to properties.\n  using propimpl_iterator = specific_decl_iterator<ObjCPropertyImplDecl>;\n  using propimpl_range =\n      llvm::iterator_range<specific_decl_iterator<ObjCPropertyImplDecl>>;\n\n  propimpl_range property_impls() const {\n    return propimpl_range(propimpl_begin(), propimpl_end());\n  }\n\n  propimpl_iterator propimpl_begin() const {\n    return propimpl_iterator(decls_begin());\n  }\n\n  propimpl_iterator propimpl_end() const {\n    return propimpl_iterator(decls_end());\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K >= firstObjCImpl && K <= lastObjCImpl;\n  }\n};\n\n/// ObjCCategoryImplDecl - An object of this class encapsulates a category\n/// \\@implementation declaration. If a category class has declaration of a\n/// property, its implementation must be specified in the category's\n/// \\@implementation declaration. Example:\n/// \\@interface I \\@end\n/// \\@interface I(CATEGORY)\n///    \\@property int p1, d1;\n/// \\@end\n/// \\@implementation I(CATEGORY)\n///  \\@dynamic p1,d1;\n/// \\@end\n///\n/// ObjCCategoryImplDecl\nclass ObjCCategoryImplDecl : public ObjCImplDecl {\n  // Category name location\n  SourceLocation CategoryNameLoc;\n\n  ObjCCategoryImplDecl(DeclContext *DC, IdentifierInfo *Id,\n                       ObjCInterfaceDecl *classInterface,\n                       SourceLocation nameLoc, SourceLocation atStartLoc,\n                       SourceLocation CategoryNameLoc)\n      : ObjCImplDecl(ObjCCategoryImpl, DC, classInterface, Id,\n                     nameLoc, atStartLoc),\n        CategoryNameLoc(CategoryNameLoc) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static ObjCCategoryImplDecl *Create(ASTContext &C, DeclContext *DC,\n                                      IdentifierInfo *Id,\n                                      ObjCInterfaceDecl *classInterface,\n                                      SourceLocation nameLoc,\n                                      SourceLocation atStartLoc,\n                                      SourceLocation CategoryNameLoc);\n  static ObjCCategoryImplDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  ObjCCategoryDecl *getCategoryDecl() const;\n\n  SourceLocation getCategoryNameLoc() const { return CategoryNameLoc; }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCCategoryImpl;}\n};\n\nraw_ostream &operator<<(raw_ostream &OS, const ObjCCategoryImplDecl &CID);\n\n/// ObjCImplementationDecl - Represents a class definition - this is where\n/// method definitions are specified. For example:\n///\n/// @code\n/// \\@implementation MyClass\n/// - (void)myMethod { /* do something */ }\n/// \\@end\n/// @endcode\n///\n/// In a non-fragile runtime, instance variables can appear in the class\n/// interface, class extensions (nameless categories), and in the implementation\n/// itself, as well as being synthesized as backing storage for properties.\n///\n/// In a fragile runtime, instance variables are specified in the class\n/// interface, \\em not in the implementation. Nevertheless (for legacy reasons),\n/// we allow instance variables to be specified in the implementation. When\n/// specified, they need to be \\em identical to the interface.\nclass ObjCImplementationDecl : public ObjCImplDecl {\n  /// Implementation Class's super class.\n  ObjCInterfaceDecl *SuperClass;\n  SourceLocation SuperLoc;\n\n  /// \\@implementation may have private ivars.\n  SourceLocation IvarLBraceLoc;\n  SourceLocation IvarRBraceLoc;\n\n  /// Support for ivar initialization.\n  /// The arguments used to initialize the ivars\n  LazyCXXCtorInitializersPtr IvarInitializers;\n  unsigned NumIvarInitializers = 0;\n\n  /// Do the ivars of this class require initialization other than\n  /// zero-initialization?\n  bool HasNonZeroConstructors : 1;\n\n  /// Do the ivars of this class require non-trivial destruction?\n  bool HasDestructors : 1;\n\n  ObjCImplementationDecl(DeclContext *DC,\n                         ObjCInterfaceDecl *classInterface,\n                         ObjCInterfaceDecl *superDecl,\n                         SourceLocation nameLoc, SourceLocation atStartLoc,\n                         SourceLocation superLoc = SourceLocation(),\n                         SourceLocation IvarLBraceLoc=SourceLocation(),\n                         SourceLocation IvarRBraceLoc=SourceLocation())\n      : ObjCImplDecl(ObjCImplementation, DC, classInterface,\n                     classInterface ? classInterface->getIdentifier()\n                                    : nullptr,\n                     nameLoc, atStartLoc),\n         SuperClass(superDecl), SuperLoc(superLoc),\n         IvarLBraceLoc(IvarLBraceLoc), IvarRBraceLoc(IvarRBraceLoc),\n         HasNonZeroConstructors(false), HasDestructors(false) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static ObjCImplementationDecl *Create(ASTContext &C, DeclContext *DC,\n                                        ObjCInterfaceDecl *classInterface,\n                                        ObjCInterfaceDecl *superDecl,\n                                        SourceLocation nameLoc,\n                                        SourceLocation atStartLoc,\n                                     SourceLocation superLoc = SourceLocation(),\n                                        SourceLocation IvarLBraceLoc=SourceLocation(),\n                                        SourceLocation IvarRBraceLoc=SourceLocation());\n\n  static ObjCImplementationDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// init_iterator - Iterates through the ivar initializer list.\n  using init_iterator = CXXCtorInitializer **;\n\n  /// init_const_iterator - Iterates through the ivar initializer list.\n  using init_const_iterator = CXXCtorInitializer * const *;\n\n  using init_range = llvm::iterator_range<init_iterator>;\n  using init_const_range = llvm::iterator_range<init_const_iterator>;\n\n  init_range inits() { return init_range(init_begin(), init_end()); }\n\n  init_const_range inits() const {\n    return init_const_range(init_begin(), init_end());\n  }\n\n  /// init_begin() - Retrieve an iterator to the first initializer.\n  init_iterator init_begin() {\n    const auto *ConstThis = this;\n    return const_cast<init_iterator>(ConstThis->init_begin());\n  }\n\n  /// begin() - Retrieve an iterator to the first initializer.\n  init_const_iterator init_begin() const;\n\n  /// init_end() - Retrieve an iterator past the last initializer.\n  init_iterator       init_end()       {\n    return init_begin() + NumIvarInitializers;\n  }\n\n  /// end() - Retrieve an iterator past the last initializer.\n  init_const_iterator init_end() const {\n    return init_begin() + NumIvarInitializers;\n  }\n\n  /// getNumArgs - Number of ivars which must be initialized.\n  unsigned getNumIvarInitializers() const {\n    return NumIvarInitializers;\n  }\n\n  void setNumIvarInitializers(unsigned numNumIvarInitializers) {\n    NumIvarInitializers = numNumIvarInitializers;\n  }\n\n  void setIvarInitializers(ASTContext &C,\n                           CXXCtorInitializer ** initializers,\n                           unsigned numInitializers);\n\n  /// Do any of the ivars of this class (not counting its base classes)\n  /// require construction other than zero-initialization?\n  bool hasNonZeroConstructors() const { return HasNonZeroConstructors; }\n  void setHasNonZeroConstructors(bool val) { HasNonZeroConstructors = val; }\n\n  /// Do any of the ivars of this class (not counting its base classes)\n  /// require non-trivial destruction?\n  bool hasDestructors() const { return HasDestructors; }\n  void setHasDestructors(bool val) { HasDestructors = val; }\n\n  /// getIdentifier - Get the identifier that names the class\n  /// interface associated with this implementation.\n  IdentifierInfo *getIdentifier() const {\n    return getClassInterface()->getIdentifier();\n  }\n\n  /// getName - Get the name of identifier for the class interface associated\n  /// with this implementation as a StringRef.\n  //\n  // FIXME: This is a bad API, we are hiding NamedDecl::getName with a different\n  // meaning.\n  StringRef getName() const {\n    assert(getIdentifier() && \"Name is not a simple identifier\");\n    return getIdentifier()->getName();\n  }\n\n  /// Get the name of the class associated with this interface.\n  //\n  // FIXME: Move to StringRef API.\n  std::string getNameAsString() const { return std::string(getName()); }\n\n  /// Produce a name to be used for class's metadata. It comes either via\n  /// class's objc_runtime_name attribute or class name.\n  StringRef getObjCRuntimeNameAsString() const;\n\n  const ObjCInterfaceDecl *getSuperClass() const { return SuperClass; }\n  ObjCInterfaceDecl *getSuperClass() { return SuperClass; }\n  SourceLocation getSuperClassLoc() const { return SuperLoc; }\n\n  void setSuperClass(ObjCInterfaceDecl * superCls) { SuperClass = superCls; }\n\n  void setIvarLBraceLoc(SourceLocation Loc) { IvarLBraceLoc = Loc; }\n  SourceLocation getIvarLBraceLoc() const { return IvarLBraceLoc; }\n  void setIvarRBraceLoc(SourceLocation Loc) { IvarRBraceLoc = Loc; }\n  SourceLocation getIvarRBraceLoc() const { return IvarRBraceLoc; }\n\n  using ivar_iterator = specific_decl_iterator<ObjCIvarDecl>;\n  using ivar_range = llvm::iterator_range<specific_decl_iterator<ObjCIvarDecl>>;\n\n  ivar_range ivars() const { return ivar_range(ivar_begin(), ivar_end()); }\n\n  ivar_iterator ivar_begin() const {\n    return ivar_iterator(decls_begin());\n  }\n\n  ivar_iterator ivar_end() const {\n    return ivar_iterator(decls_end());\n  }\n\n  unsigned ivar_size() const {\n    return std::distance(ivar_begin(), ivar_end());\n  }\n\n  bool ivar_empty() const {\n    return ivar_begin() == ivar_end();\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCImplementation; }\n};\n\nraw_ostream &operator<<(raw_ostream &OS, const ObjCImplementationDecl &ID);\n\n/// ObjCCompatibleAliasDecl - Represents alias of a class. This alias is\n/// declared as \\@compatibility_alias alias class.\nclass ObjCCompatibleAliasDecl : public NamedDecl {\n  /// Class that this is an alias of.\n  ObjCInterfaceDecl *AliasedClass;\n\n  ObjCCompatibleAliasDecl(DeclContext *DC, SourceLocation L, IdentifierInfo *Id,\n                          ObjCInterfaceDecl* aliasedClass)\n      : NamedDecl(ObjCCompatibleAlias, DC, L, Id), AliasedClass(aliasedClass) {}\n\n  void anchor() override;\n\npublic:\n  static ObjCCompatibleAliasDecl *Create(ASTContext &C, DeclContext *DC,\n                                         SourceLocation L, IdentifierInfo *Id,\n                                         ObjCInterfaceDecl* aliasedClass);\n\n  static ObjCCompatibleAliasDecl *CreateDeserialized(ASTContext &C,\n                                                     unsigned ID);\n\n  const ObjCInterfaceDecl *getClassInterface() const { return AliasedClass; }\n  ObjCInterfaceDecl *getClassInterface() { return AliasedClass; }\n  void setClassInterface(ObjCInterfaceDecl *D) { AliasedClass = D; }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCCompatibleAlias; }\n};\n\n/// ObjCPropertyImplDecl - Represents implementation declaration of a property\n/// in a class or category implementation block. For example:\n/// \\@synthesize prop1 = ivar1;\n///\nclass ObjCPropertyImplDecl : public Decl {\npublic:\n  enum Kind {\n    Synthesize,\n    Dynamic\n  };\n\nprivate:\n  SourceLocation AtLoc;   // location of \\@synthesize or \\@dynamic\n\n  /// For \\@synthesize, the location of the ivar, if it was written in\n  /// the source code.\n  ///\n  /// \\code\n  /// \\@synthesize int a = b\n  /// \\endcode\n  SourceLocation IvarLoc;\n\n  /// Property declaration being implemented\n  ObjCPropertyDecl *PropertyDecl;\n\n  /// Null for \\@dynamic. Required for \\@synthesize.\n  ObjCIvarDecl *PropertyIvarDecl;\n\n  /// The getter's definition, which has an empty body if synthesized.\n  ObjCMethodDecl *GetterMethodDecl = nullptr;\n  /// The getter's definition, which has an empty body if synthesized.\n  ObjCMethodDecl *SetterMethodDecl = nullptr;\n\n  /// Null for \\@dynamic. Non-null if property must be copy-constructed in\n  /// getter.\n  Expr *GetterCXXConstructor = nullptr;\n\n  /// Null for \\@dynamic. Non-null if property has assignment operator to call\n  /// in Setter synthesis.\n  Expr *SetterCXXAssignment = nullptr;\n\n  ObjCPropertyImplDecl(DeclContext *DC, SourceLocation atLoc, SourceLocation L,\n                       ObjCPropertyDecl *property,\n                       Kind PK,\n                       ObjCIvarDecl *ivarDecl,\n                       SourceLocation ivarLoc)\n      : Decl(ObjCPropertyImpl, DC, L), AtLoc(atLoc),\n        IvarLoc(ivarLoc), PropertyDecl(property), PropertyIvarDecl(ivarDecl) {\n    assert(PK == Dynamic || PropertyIvarDecl);\n  }\n\npublic:\n  friend class ASTDeclReader;\n\n  static ObjCPropertyImplDecl *Create(ASTContext &C, DeclContext *DC,\n                                      SourceLocation atLoc, SourceLocation L,\n                                      ObjCPropertyDecl *property,\n                                      Kind PK,\n                                      ObjCIvarDecl *ivarDecl,\n                                      SourceLocation ivarLoc);\n\n  static ObjCPropertyImplDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AtLoc; }\n  void setAtLoc(SourceLocation Loc) { AtLoc = Loc; }\n\n  ObjCPropertyDecl *getPropertyDecl() const {\n    return PropertyDecl;\n  }\n  void setPropertyDecl(ObjCPropertyDecl *Prop) { PropertyDecl = Prop; }\n\n  Kind getPropertyImplementation() const {\n    return PropertyIvarDecl ? Synthesize : Dynamic;\n  }\n\n  ObjCIvarDecl *getPropertyIvarDecl() const {\n    return PropertyIvarDecl;\n  }\n  SourceLocation getPropertyIvarDeclLoc() const { return IvarLoc; }\n\n  void setPropertyIvarDecl(ObjCIvarDecl *Ivar,\n                           SourceLocation IvarLoc) {\n    PropertyIvarDecl = Ivar;\n    this->IvarLoc = IvarLoc;\n  }\n\n  /// For \\@synthesize, returns true if an ivar name was explicitly\n  /// specified.\n  ///\n  /// \\code\n  /// \\@synthesize int a = b; // true\n  /// \\@synthesize int a; // false\n  /// \\endcode\n  bool isIvarNameSpecified() const {\n    return IvarLoc.isValid() && IvarLoc != getLocation();\n  }\n\n  ObjCMethodDecl *getGetterMethodDecl() const { return GetterMethodDecl; }\n  void setGetterMethodDecl(ObjCMethodDecl *MD) { GetterMethodDecl = MD; }\n\n  ObjCMethodDecl *getSetterMethodDecl() const { return SetterMethodDecl; }\n  void setSetterMethodDecl(ObjCMethodDecl *MD) { SetterMethodDecl = MD; }\n\n  Expr *getGetterCXXConstructor() const {\n    return GetterCXXConstructor;\n  }\n\n  void setGetterCXXConstructor(Expr *getterCXXConstructor) {\n    GetterCXXConstructor = getterCXXConstructor;\n  }\n\n  Expr *getSetterCXXAssignment() const {\n    return SetterCXXAssignment;\n  }\n\n  void setSetterCXXAssignment(Expr *setterCXXAssignment) {\n    SetterCXXAssignment = setterCXXAssignment;\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Decl::Kind K) { return K == ObjCPropertyImpl; }\n};\n\ntemplate<bool (*Filter)(ObjCCategoryDecl *)>\nvoid\nObjCInterfaceDecl::filtered_category_iterator<Filter>::\nfindAcceptableCategory() {\n  while (Current && !Filter(Current))\n    Current = Current->getNextClassCategoryRaw();\n}\n\ntemplate<bool (*Filter)(ObjCCategoryDecl *)>\ninline ObjCInterfaceDecl::filtered_category_iterator<Filter> &\nObjCInterfaceDecl::filtered_category_iterator<Filter>::operator++() {\n  Current = Current->getNextClassCategoryRaw();\n  findAcceptableCategory();\n  return *this;\n}\n\ninline bool ObjCInterfaceDecl::isVisibleCategory(ObjCCategoryDecl *Cat) {\n  return Cat->isUnconditionallyVisible();\n}\n\ninline bool ObjCInterfaceDecl::isVisibleExtension(ObjCCategoryDecl *Cat) {\n  return Cat->IsClassExtension() && Cat->isUnconditionallyVisible();\n}\n\ninline bool ObjCInterfaceDecl::isKnownExtension(ObjCCategoryDecl *Cat) {\n  return Cat->IsClassExtension();\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_DECLOBJC_H\n"}, "7": {"id": 7, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclTemplate.h", "content": "//===- DeclTemplate.h - Classes for representing C++ templates --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the C++ template declaration subclasses.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_DECLTEMPLATE_H\n#define LLVM_CLANG_AST_DECLTEMPLATE_H\n\n#include \"clang/AST/ASTConcept.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/Redeclarable.h\"\n#include \"clang/AST/TemplateBase.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <utility>\n\nnamespace clang {\n\nenum BuiltinTemplateKind : int;\nclass ClassTemplateDecl;\nclass ClassTemplatePartialSpecializationDecl;\nclass Expr;\nclass FunctionTemplateDecl;\nclass IdentifierInfo;\nclass NonTypeTemplateParmDecl;\nclass TemplateDecl;\nclass TemplateTemplateParmDecl;\nclass TemplateTypeParmDecl;\nclass ConceptDecl;\nclass UnresolvedSetImpl;\nclass VarTemplateDecl;\nclass VarTemplatePartialSpecializationDecl;\n\n/// Stores a template parameter of any kind.\nusing TemplateParameter =\n    llvm::PointerUnion<TemplateTypeParmDecl *, NonTypeTemplateParmDecl *,\n                       TemplateTemplateParmDecl *>;\n\nNamedDecl *getAsNamedDecl(TemplateParameter P);\n\n/// Stores a list of template parameters for a TemplateDecl and its\n/// derived classes.\nclass TemplateParameterList final\n    : private llvm::TrailingObjects<TemplateParameterList, NamedDecl *,\n                                    Expr *> {\n  /// The location of the 'template' keyword.\n  SourceLocation TemplateLoc;\n\n  /// The locations of the '<' and '>' angle brackets.\n  SourceLocation LAngleLoc, RAngleLoc;\n\n  /// The number of template parameters in this template\n  /// parameter list.\n  unsigned NumParams : 29;\n\n  /// Whether this template parameter list contains an unexpanded parameter\n  /// pack.\n  unsigned ContainsUnexpandedParameterPack : 1;\n\n  /// Whether this template parameter list has a requires clause.\n  unsigned HasRequiresClause : 1;\n\n  /// Whether any of the template parameters has constrained-parameter\n  /// constraint-expression.\n  unsigned HasConstrainedParameters : 1;\n\nprotected:\n  TemplateParameterList(const ASTContext& C, SourceLocation TemplateLoc,\n                        SourceLocation LAngleLoc, ArrayRef<NamedDecl *> Params,\n                        SourceLocation RAngleLoc, Expr *RequiresClause);\n\n  size_t numTrailingObjects(OverloadToken<NamedDecl *>) const {\n    return NumParams;\n  }\n\n  size_t numTrailingObjects(OverloadToken<Expr *>) const {\n    return HasRequiresClause ? 1 : 0;\n  }\n\npublic:\n  template <size_t N, bool HasRequiresClause>\n  friend class FixedSizeTemplateParameterListStorage;\n  friend TrailingObjects;\n\n  static TemplateParameterList *Create(const ASTContext &C,\n                                       SourceLocation TemplateLoc,\n                                       SourceLocation LAngleLoc,\n                                       ArrayRef<NamedDecl *> Params,\n                                       SourceLocation RAngleLoc,\n                                       Expr *RequiresClause);\n\n  /// Iterates through the template parameters in this list.\n  using iterator = NamedDecl **;\n\n  /// Iterates through the template parameters in this list.\n  using const_iterator = NamedDecl * const *;\n\n  iterator begin() { return getTrailingObjects<NamedDecl *>(); }\n  const_iterator begin() const { return getTrailingObjects<NamedDecl *>(); }\n  iterator end() { return begin() + NumParams; }\n  const_iterator end() const { return begin() + NumParams; }\n\n  unsigned size() const { return NumParams; }\n\n  ArrayRef<NamedDecl*> asArray() {\n    return llvm::makeArrayRef(begin(), end());\n  }\n  ArrayRef<const NamedDecl*> asArray() const {\n    return llvm::makeArrayRef(begin(), size());\n  }\n\n  NamedDecl* getParam(unsigned Idx) {\n    assert(Idx < size() && \"Template parameter index out-of-range\");\n    return begin()[Idx];\n  }\n  const NamedDecl* getParam(unsigned Idx) const {\n    assert(Idx < size() && \"Template parameter index out-of-range\");\n    return begin()[Idx];\n  }\n\n  /// Returns the minimum number of arguments needed to form a\n  /// template specialization.\n  ///\n  /// This may be fewer than the number of template parameters, if some of\n  /// the parameters have default arguments or if there is a parameter pack.\n  unsigned getMinRequiredArguments() const;\n\n  /// Get the depth of this template parameter list in the set of\n  /// template parameter lists.\n  ///\n  /// The first template parameter list in a declaration will have depth 0,\n  /// the second template parameter list will have depth 1, etc.\n  unsigned getDepth() const;\n\n  /// Determine whether this template parameter list contains an\n  /// unexpanded parameter pack.\n  bool containsUnexpandedParameterPack() const {\n    return ContainsUnexpandedParameterPack;\n  }\n\n  /// Determine whether this template parameter list contains a parameter pack.\n  bool hasParameterPack() const {\n    for (const NamedDecl *P : asArray())\n      if (P->isParameterPack())\n        return true;\n    return false;\n  }\n\n  /// The constraint-expression of the associated requires-clause.\n  Expr *getRequiresClause() {\n    return HasRequiresClause ? getTrailingObjects<Expr *>()[0] : nullptr;\n  }\n\n  /// The constraint-expression of the associated requires-clause.\n  const Expr *getRequiresClause() const {\n    return HasRequiresClause ? getTrailingObjects<Expr *>()[0] : nullptr;\n  }\n\n  /// \\brief All associated constraints derived from this template parameter\n  /// list, including the requires clause and any constraints derived from\n  /// constrained-parameters.\n  ///\n  /// The constraints in the resulting list are to be treated as if in a\n  /// conjunction (\"and\").\n  void getAssociatedConstraints(llvm::SmallVectorImpl<const Expr *> &AC) const;\n\n  bool hasAssociatedConstraints() const;\n\n  SourceLocation getTemplateLoc() const { return TemplateLoc; }\n  SourceLocation getLAngleLoc() const { return LAngleLoc; }\n  SourceLocation getRAngleLoc() const { return RAngleLoc; }\n\n  SourceRange getSourceRange() const LLVM_READONLY {\n    return SourceRange(TemplateLoc, RAngleLoc);\n  }\n\n  void print(raw_ostream &Out, const ASTContext &Context,\n             bool OmitTemplateKW = false) const;\n  void print(raw_ostream &Out, const ASTContext &Context,\n             const PrintingPolicy &Policy, bool OmitTemplateKW = false) const;\n};\n\n/// Stores a list of template parameters and the associated\n/// requires-clause (if any) for a TemplateDecl and its derived classes.\n/// Suitable for creating on the stack.\ntemplate <size_t N, bool HasRequiresClause>\nclass FixedSizeTemplateParameterListStorage\n    : public TemplateParameterList::FixedSizeStorageOwner {\n  typename TemplateParameterList::FixedSizeStorage<\n      NamedDecl *, Expr *>::with_counts<\n      N, HasRequiresClause ? 1u : 0u\n      >::type storage;\n\npublic:\n  FixedSizeTemplateParameterListStorage(const ASTContext &C,\n                                        SourceLocation TemplateLoc,\n                                        SourceLocation LAngleLoc,\n                                        ArrayRef<NamedDecl *> Params,\n                                        SourceLocation RAngleLoc,\n                                        Expr *RequiresClause)\n      : FixedSizeStorageOwner(\n            (assert(N == Params.size()),\n             assert(HasRequiresClause == (RequiresClause != nullptr)),\n             new (static_cast<void *>(&storage)) TemplateParameterList(C,\n                 TemplateLoc, LAngleLoc, Params, RAngleLoc, RequiresClause))) {}\n};\n\n/// A template argument list.\nclass TemplateArgumentList final\n    : private llvm::TrailingObjects<TemplateArgumentList, TemplateArgument> {\n  /// The template argument list.\n  const TemplateArgument *Arguments;\n\n  /// The number of template arguments in this template\n  /// argument list.\n  unsigned NumArguments;\n\n  // Constructs an instance with an internal Argument list, containing\n  // a copy of the Args array. (Called by CreateCopy)\n  TemplateArgumentList(ArrayRef<TemplateArgument> Args);\n\npublic:\n  friend TrailingObjects;\n\n  TemplateArgumentList(const TemplateArgumentList &) = delete;\n  TemplateArgumentList &operator=(const TemplateArgumentList &) = delete;\n\n  /// Type used to indicate that the template argument list itself is a\n  /// stack object. It does not own its template arguments.\n  enum OnStackType { OnStack };\n\n  /// Create a new template argument list that copies the given set of\n  /// template arguments.\n  static TemplateArgumentList *CreateCopy(ASTContext &Context,\n                                          ArrayRef<TemplateArgument> Args);\n\n  /// Construct a new, temporary template argument list on the stack.\n  ///\n  /// The template argument list does not own the template arguments\n  /// provided.\n  explicit TemplateArgumentList(OnStackType, ArrayRef<TemplateArgument> Args)\n      : Arguments(Args.data()), NumArguments(Args.size()) {}\n\n  /// Produces a shallow copy of the given template argument list.\n  ///\n  /// This operation assumes that the input argument list outlives it.\n  /// This takes the list as a pointer to avoid looking like a copy\n  /// constructor, since this really really isn't safe to use that\n  /// way.\n  explicit TemplateArgumentList(const TemplateArgumentList *Other)\n      : Arguments(Other->data()), NumArguments(Other->size()) {}\n\n  /// Retrieve the template argument at a given index.\n  const TemplateArgument &get(unsigned Idx) const {\n    assert(Idx < NumArguments && \"Invalid template argument index\");\n    return data()[Idx];\n  }\n\n  /// Retrieve the template argument at a given index.\n  const TemplateArgument &operator[](unsigned Idx) const { return get(Idx); }\n\n  /// Produce this as an array ref.\n  ArrayRef<TemplateArgument> asArray() const {\n    return llvm::makeArrayRef(data(), size());\n  }\n\n  /// Retrieve the number of template arguments in this\n  /// template argument list.\n  unsigned size() const { return NumArguments; }\n\n  /// Retrieve a pointer to the template argument list.\n  const TemplateArgument *data() const { return Arguments; }\n};\n\nvoid *allocateDefaultArgStorageChain(const ASTContext &C);\n\n/// Storage for a default argument. This is conceptually either empty, or an\n/// argument value, or a pointer to a previous declaration that had a default\n/// argument.\n///\n/// However, this is complicated by modules: while we require all the default\n/// arguments for a template to be equivalent, there may be more than one, and\n/// we need to track all the originating parameters to determine if the default\n/// argument is visible.\ntemplate<typename ParmDecl, typename ArgType>\nclass DefaultArgStorage {\n  /// Storage for both the value *and* another parameter from which we inherit\n  /// the default argument. This is used when multiple default arguments for a\n  /// parameter are merged together from different modules.\n  struct Chain {\n    ParmDecl *PrevDeclWithDefaultArg;\n    ArgType Value;\n  };\n  static_assert(sizeof(Chain) == sizeof(void *) * 2,\n                \"non-pointer argument type?\");\n\n  llvm::PointerUnion<ArgType, ParmDecl*, Chain*> ValueOrInherited;\n\n  static ParmDecl *getParmOwningDefaultArg(ParmDecl *Parm) {\n    const DefaultArgStorage &Storage = Parm->getDefaultArgStorage();\n    if (auto *Prev = Storage.ValueOrInherited.template dyn_cast<ParmDecl *>())\n      Parm = Prev;\n    assert(!Parm->getDefaultArgStorage()\n                .ValueOrInherited.template is<ParmDecl *>() &&\n           \"should only be one level of indirection\");\n    return Parm;\n  }\n\npublic:\n  DefaultArgStorage() : ValueOrInherited(ArgType()) {}\n\n  /// Determine whether there is a default argument for this parameter.\n  bool isSet() const { return !ValueOrInherited.isNull(); }\n\n  /// Determine whether the default argument for this parameter was inherited\n  /// from a previous declaration of the same entity.\n  bool isInherited() const { return ValueOrInherited.template is<ParmDecl*>(); }\n\n  /// Get the default argument's value. This does not consider whether the\n  /// default argument is visible.\n  ArgType get() const {\n    const DefaultArgStorage *Storage = this;\n    if (const auto *Prev = ValueOrInherited.template dyn_cast<ParmDecl *>())\n      Storage = &Prev->getDefaultArgStorage();\n    if (const auto *C = Storage->ValueOrInherited.template dyn_cast<Chain *>())\n      return C->Value;\n    return Storage->ValueOrInherited.template get<ArgType>();\n  }\n\n  /// Get the parameter from which we inherit the default argument, if any.\n  /// This is the parameter on which the default argument was actually written.\n  const ParmDecl *getInheritedFrom() const {\n    if (const auto *D = ValueOrInherited.template dyn_cast<ParmDecl *>())\n      return D;\n    if (const auto *C = ValueOrInherited.template dyn_cast<Chain *>())\n      return C->PrevDeclWithDefaultArg;\n    return nullptr;\n  }\n\n  /// Set the default argument.\n  void set(ArgType Arg) {\n    assert(!isSet() && \"default argument already set\");\n    ValueOrInherited = Arg;\n  }\n\n  /// Set that the default argument was inherited from another parameter.\n  void setInherited(const ASTContext &C, ParmDecl *InheritedFrom) {\n    assert(!isInherited() && \"default argument already inherited\");\n    InheritedFrom = getParmOwningDefaultArg(InheritedFrom);\n    if (!isSet())\n      ValueOrInherited = InheritedFrom;\n    else\n      ValueOrInherited = new (allocateDefaultArgStorageChain(C))\n          Chain{InheritedFrom, ValueOrInherited.template get<ArgType>()};\n  }\n\n  /// Remove the default argument, even if it was inherited.\n  void clear() {\n    ValueOrInherited = ArgType();\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Kinds of Templates\n//===----------------------------------------------------------------------===//\n\n/// \\brief The base class of all kinds of template declarations (e.g.,\n/// class, function, etc.).\n///\n/// The TemplateDecl class stores the list of template parameters and a\n/// reference to the templated scoped declaration: the underlying AST node.\nclass TemplateDecl : public NamedDecl {\n  void anchor() override;\n\nprotected:\n  // Construct a template decl with name, parameters, and templated element.\n  TemplateDecl(Kind DK, DeclContext *DC, SourceLocation L, DeclarationName Name,\n               TemplateParameterList *Params, NamedDecl *Decl);\n\n  // Construct a template decl with the given name and parameters.\n  // Used when there is no templated element (e.g., for tt-params).\n  TemplateDecl(Kind DK, DeclContext *DC, SourceLocation L, DeclarationName Name,\n               TemplateParameterList *Params)\n      : TemplateDecl(DK, DC, L, Name, Params, nullptr) {}\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Get the list of template parameters\n  TemplateParameterList *getTemplateParameters() const {\n    return TemplateParams;\n  }\n\n  /// \\brief Get the total constraint-expression associated with this template,\n  /// including constraint-expressions derived from the requires-clause,\n  /// trailing requires-clause (for functions and methods) and constrained\n  /// template parameters.\n  void getAssociatedConstraints(llvm::SmallVectorImpl<const Expr *> &AC) const;\n\n  bool hasAssociatedConstraints() const;\n\n  /// Get the underlying, templated declaration.\n  NamedDecl *getTemplatedDecl() const { return TemplatedDecl; }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K >= firstTemplate && K <= lastTemplate;\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(getTemplateParameters()->getTemplateLoc(),\n                       TemplatedDecl->getSourceRange().getEnd());\n  }\n\nprotected:\n  NamedDecl *TemplatedDecl;\n  TemplateParameterList *TemplateParams;\n\n  void setTemplateParameters(TemplateParameterList *TParams) {\n    TemplateParams = TParams;\n  }\n\npublic:\n  /// Initialize the underlying templated declaration and\n  /// template parameters.\n  void init(NamedDecl *templatedDecl, TemplateParameterList* templateParams) {\n    assert(!TemplatedDecl && \"TemplatedDecl already set!\");\n    assert(!TemplateParams && \"TemplateParams already set!\");\n    TemplatedDecl = templatedDecl;\n    TemplateParams = templateParams;\n  }\n};\n\n/// Provides information about a function template specialization,\n/// which is a FunctionDecl that has been explicitly specialization or\n/// instantiated from a function template.\nclass FunctionTemplateSpecializationInfo final\n    : public llvm::FoldingSetNode,\n      private llvm::TrailingObjects<FunctionTemplateSpecializationInfo,\n                                    MemberSpecializationInfo *> {\n  /// The function template specialization that this structure describes and a\n  /// flag indicating if the function is a member specialization.\n  llvm::PointerIntPair<FunctionDecl *, 1, bool> Function;\n\n  /// The function template from which this function template\n  /// specialization was generated.\n  ///\n  /// The two bits contain the top 4 values of TemplateSpecializationKind.\n  llvm::PointerIntPair<FunctionTemplateDecl *, 2> Template;\n\npublic:\n  /// The template arguments used to produce the function template\n  /// specialization from the function template.\n  const TemplateArgumentList *TemplateArguments;\n\n  /// The template arguments as written in the sources, if provided.\n  /// FIXME: Normally null; tail-allocate this.\n  const ASTTemplateArgumentListInfo *TemplateArgumentsAsWritten;\n\n  /// The point at which this function template specialization was\n  /// first instantiated.\n  SourceLocation PointOfInstantiation;\n\nprivate:\n  FunctionTemplateSpecializationInfo(\n      FunctionDecl *FD, FunctionTemplateDecl *Template,\n      TemplateSpecializationKind TSK, const TemplateArgumentList *TemplateArgs,\n      const ASTTemplateArgumentListInfo *TemplateArgsAsWritten,\n      SourceLocation POI, MemberSpecializationInfo *MSInfo)\n      : Function(FD, MSInfo ? 1 : 0), Template(Template, TSK - 1),\n        TemplateArguments(TemplateArgs),\n        TemplateArgumentsAsWritten(TemplateArgsAsWritten),\n        PointOfInstantiation(POI) {\n    if (MSInfo)\n      getTrailingObjects<MemberSpecializationInfo *>()[0] = MSInfo;\n  }\n\n  size_t numTrailingObjects(OverloadToken<MemberSpecializationInfo*>) const {\n    return Function.getInt();\n  }\n\npublic:\n  friend TrailingObjects;\n\n  static FunctionTemplateSpecializationInfo *\n  Create(ASTContext &C, FunctionDecl *FD, FunctionTemplateDecl *Template,\n         TemplateSpecializationKind TSK,\n         const TemplateArgumentList *TemplateArgs,\n         const TemplateArgumentListInfo *TemplateArgsAsWritten,\n         SourceLocation POI, MemberSpecializationInfo *MSInfo);\n\n  /// Retrieve the declaration of the function template specialization.\n  FunctionDecl *getFunction() const { return Function.getPointer(); }\n\n  /// Retrieve the template from which this function was specialized.\n  FunctionTemplateDecl *getTemplate() const { return Template.getPointer(); }\n\n  /// Determine what kind of template specialization this is.\n  TemplateSpecializationKind getTemplateSpecializationKind() const {\n    return (TemplateSpecializationKind)(Template.getInt() + 1);\n  }\n\n  bool isExplicitSpecialization() const {\n    return getTemplateSpecializationKind() == TSK_ExplicitSpecialization;\n  }\n\n  /// True if this declaration is an explicit specialization,\n  /// explicit instantiation declaration, or explicit instantiation\n  /// definition.\n  bool isExplicitInstantiationOrSpecialization() const {\n    return isTemplateExplicitInstantiationOrSpecialization(\n        getTemplateSpecializationKind());\n  }\n\n  /// Set the template specialization kind.\n  void setTemplateSpecializationKind(TemplateSpecializationKind TSK) {\n    assert(TSK != TSK_Undeclared &&\n         \"Cannot encode TSK_Undeclared for a function template specialization\");\n    Template.setInt(TSK - 1);\n  }\n\n  /// Retrieve the first point of instantiation of this function\n  /// template specialization.\n  ///\n  /// The point of instantiation may be an invalid source location if this\n  /// function has yet to be instantiated.\n  SourceLocation getPointOfInstantiation() const {\n    return PointOfInstantiation;\n  }\n\n  /// Set the (first) point of instantiation of this function template\n  /// specialization.\n  void setPointOfInstantiation(SourceLocation POI) {\n    PointOfInstantiation = POI;\n  }\n\n  /// Get the specialization info if this function template specialization is\n  /// also a member specialization:\n  ///\n  /// \\code\n  /// template<typename> struct A {\n  ///   template<typename> void f();\n  ///   template<> void f<int>(); // ClassScopeFunctionSpecializationDecl\n  /// };\n  /// \\endcode\n  ///\n  /// Here, A<int>::f<int> is a function template specialization that is\n  /// an explicit specialization of A<int>::f, but it's also a member\n  /// specialization (an implicit instantiation in this case) of A::f<int>.\n  /// Further:\n  ///\n  /// \\code\n  /// template<> template<> void A<int>::f<int>() {}\n  /// \\endcode\n  ///\n  /// ... declares a function template specialization that is an explicit\n  /// specialization of A<int>::f, and is also an explicit member\n  /// specialization of A::f<int>.\n  ///\n  /// Note that the TemplateSpecializationKind of the MemberSpecializationInfo\n  /// need not be the same as that returned by getTemplateSpecializationKind(),\n  /// and represents the relationship between the function and the class-scope\n  /// explicit specialization in the original templated class -- whereas our\n  /// TemplateSpecializationKind represents the relationship between the\n  /// function and the function template, and should always be\n  /// TSK_ExplicitSpecialization whenever we have MemberSpecializationInfo.\n  MemberSpecializationInfo *getMemberSpecializationInfo() const {\n    return numTrailingObjects(OverloadToken<MemberSpecializationInfo *>())\n               ? getTrailingObjects<MemberSpecializationInfo *>()[0]\n               : nullptr;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, TemplateArguments->asArray(), getFunction()->getASTContext());\n  }\n\n  static void\n  Profile(llvm::FoldingSetNodeID &ID, ArrayRef<TemplateArgument> TemplateArgs,\n          ASTContext &Context) {\n    ID.AddInteger(TemplateArgs.size());\n    for (const TemplateArgument &TemplateArg : TemplateArgs)\n      TemplateArg.Profile(ID, Context);\n  }\n};\n\n/// Provides information a specialization of a member of a class\n/// template, which may be a member function, static data member,\n/// member class or member enumeration.\nclass MemberSpecializationInfo {\n  // The member declaration from which this member was instantiated, and the\n  // manner in which the instantiation occurred (in the lower two bits).\n  llvm::PointerIntPair<NamedDecl *, 2> MemberAndTSK;\n\n  // The point at which this member was first instantiated.\n  SourceLocation PointOfInstantiation;\n\npublic:\n  explicit\n  MemberSpecializationInfo(NamedDecl *IF, TemplateSpecializationKind TSK,\n                           SourceLocation POI = SourceLocation())\n      : MemberAndTSK(IF, TSK - 1), PointOfInstantiation(POI) {\n    assert(TSK != TSK_Undeclared &&\n           \"Cannot encode undeclared template specializations for members\");\n  }\n\n  /// Retrieve the member declaration from which this member was\n  /// instantiated.\n  NamedDecl *getInstantiatedFrom() const { return MemberAndTSK.getPointer(); }\n\n  /// Determine what kind of template specialization this is.\n  TemplateSpecializationKind getTemplateSpecializationKind() const {\n    return (TemplateSpecializationKind)(MemberAndTSK.getInt() + 1);\n  }\n\n  bool isExplicitSpecialization() const {\n    return getTemplateSpecializationKind() == TSK_ExplicitSpecialization;\n  }\n\n  /// Set the template specialization kind.\n  void setTemplateSpecializationKind(TemplateSpecializationKind TSK) {\n    assert(TSK != TSK_Undeclared &&\n           \"Cannot encode undeclared template specializations for members\");\n    MemberAndTSK.setInt(TSK - 1);\n  }\n\n  /// Retrieve the first point of instantiation of this member.\n  /// If the point of instantiation is an invalid location, then this member\n  /// has not yet been instantiated.\n  SourceLocation getPointOfInstantiation() const {\n    return PointOfInstantiation;\n  }\n\n  /// Set the first point of instantiation.\n  void setPointOfInstantiation(SourceLocation POI) {\n    PointOfInstantiation = POI;\n  }\n};\n\n/// Provides information about a dependent function-template\n/// specialization declaration.\n///\n/// Since explicit function template specialization and instantiation\n/// declarations can only appear in namespace scope, and you can only\n/// specialize a member of a fully-specialized class, the only way to\n/// get one of these is in a friend declaration like the following:\n///\n/// \\code\n///   template \\<class T> void foo(T);\n///   template \\<class T> class A {\n///     friend void foo<>(T);\n///   };\n/// \\endcode\nclass DependentFunctionTemplateSpecializationInfo final\n    : private llvm::TrailingObjects<DependentFunctionTemplateSpecializationInfo,\n                                    TemplateArgumentLoc,\n                                    FunctionTemplateDecl *> {\n  /// The number of potential template candidates.\n  unsigned NumTemplates;\n\n  /// The number of template arguments.\n  unsigned NumArgs;\n\n  /// The locations of the left and right angle brackets.\n  SourceRange AngleLocs;\n\n  size_t numTrailingObjects(OverloadToken<TemplateArgumentLoc>) const {\n    return NumArgs;\n  }\n  size_t numTrailingObjects(OverloadToken<FunctionTemplateDecl *>) const {\n    return NumTemplates;\n  }\n\n  DependentFunctionTemplateSpecializationInfo(\n                                 const UnresolvedSetImpl &Templates,\n                                 const TemplateArgumentListInfo &TemplateArgs);\n\npublic:\n  friend TrailingObjects;\n\n  static DependentFunctionTemplateSpecializationInfo *\n  Create(ASTContext &Context, const UnresolvedSetImpl &Templates,\n         const TemplateArgumentListInfo &TemplateArgs);\n\n  /// Returns the number of function templates that this might\n  /// be a specialization of.\n  unsigned getNumTemplates() const { return NumTemplates; }\n\n  /// Returns the i'th template candidate.\n  FunctionTemplateDecl *getTemplate(unsigned I) const {\n    assert(I < getNumTemplates() && \"template index out of range\");\n    return getTrailingObjects<FunctionTemplateDecl *>()[I];\n  }\n\n  /// Returns the explicit template arguments that were given.\n  const TemplateArgumentLoc *getTemplateArgs() const {\n    return getTrailingObjects<TemplateArgumentLoc>();\n  }\n\n  /// Returns the number of explicit template arguments that were given.\n  unsigned getNumTemplateArgs() const { return NumArgs; }\n\n  /// Returns the nth template argument.\n  const TemplateArgumentLoc &getTemplateArg(unsigned I) const {\n    assert(I < getNumTemplateArgs() && \"template arg index out of range\");\n    return getTemplateArgs()[I];\n  }\n\n  SourceLocation getLAngleLoc() const {\n    return AngleLocs.getBegin();\n  }\n\n  SourceLocation getRAngleLoc() const {\n    return AngleLocs.getEnd();\n  }\n};\n\n/// Declaration of a redeclarable template.\nclass RedeclarableTemplateDecl : public TemplateDecl,\n                                 public Redeclarable<RedeclarableTemplateDecl>\n{\n  using redeclarable_base = Redeclarable<RedeclarableTemplateDecl>;\n\n  RedeclarableTemplateDecl *getNextRedeclarationImpl() override {\n    return getNextRedeclaration();\n  }\n\n  RedeclarableTemplateDecl *getPreviousDeclImpl() override {\n    return getPreviousDecl();\n  }\n\n  RedeclarableTemplateDecl *getMostRecentDeclImpl() override {\n    return getMostRecentDecl();\n  }\n\n  void anchor() override;\nprotected:\n  template <typename EntryType> struct SpecEntryTraits {\n    using DeclType = EntryType;\n\n    static DeclType *getDecl(EntryType *D) {\n      return D;\n    }\n\n    static ArrayRef<TemplateArgument> getTemplateArgs(EntryType *D) {\n      return D->getTemplateArgs().asArray();\n    }\n  };\n\n  template <typename EntryType, typename SETraits = SpecEntryTraits<EntryType>,\n            typename DeclType = typename SETraits::DeclType>\n  struct SpecIterator\n      : llvm::iterator_adaptor_base<\n            SpecIterator<EntryType, SETraits, DeclType>,\n            typename llvm::FoldingSetVector<EntryType>::iterator,\n            typename std::iterator_traits<typename llvm::FoldingSetVector<\n                EntryType>::iterator>::iterator_category,\n            DeclType *, ptrdiff_t, DeclType *, DeclType *> {\n    SpecIterator() = default;\n    explicit SpecIterator(\n        typename llvm::FoldingSetVector<EntryType>::iterator SetIter)\n        : SpecIterator::iterator_adaptor_base(std::move(SetIter)) {}\n\n    DeclType *operator*() const {\n      return SETraits::getDecl(&*this->I)->getMostRecentDecl();\n    }\n\n    DeclType *operator->() const { return **this; }\n  };\n\n  template <typename EntryType>\n  static SpecIterator<EntryType>\n  makeSpecIterator(llvm::FoldingSetVector<EntryType> &Specs, bool isEnd) {\n    return SpecIterator<EntryType>(isEnd ? Specs.end() : Specs.begin());\n  }\n\n  void loadLazySpecializationsImpl() const;\n\n  template <class EntryType, typename ...ProfileArguments>\n  typename SpecEntryTraits<EntryType>::DeclType*\n  findSpecializationImpl(llvm::FoldingSetVector<EntryType> &Specs,\n                         void *&InsertPos, ProfileArguments &&...ProfileArgs);\n\n  template <class Derived, class EntryType>\n  void addSpecializationImpl(llvm::FoldingSetVector<EntryType> &Specs,\n                             EntryType *Entry, void *InsertPos);\n\n  struct CommonBase {\n    CommonBase() : InstantiatedFromMember(nullptr, false) {}\n\n    /// The template from which this was most\n    /// directly instantiated (or null).\n    ///\n    /// The boolean value indicates whether this template\n    /// was explicitly specialized.\n    llvm::PointerIntPair<RedeclarableTemplateDecl*, 1, bool>\n      InstantiatedFromMember;\n\n    /// If non-null, points to an array of specializations (including\n    /// partial specializations) known only by their external declaration IDs.\n    ///\n    /// The first value in the array is the number of specializations/partial\n    /// specializations that follow.\n    uint32_t *LazySpecializations = nullptr;\n  };\n\n  /// Pointer to the common data shared by all declarations of this\n  /// template.\n  mutable CommonBase *Common = nullptr;\n\n  /// Retrieves the \"common\" pointer shared by all (re-)declarations of\n  /// the same template. Calling this routine may implicitly allocate memory\n  /// for the common pointer.\n  CommonBase *getCommonPtr() const;\n\n  virtual CommonBase *newCommon(ASTContext &C) const = 0;\n\n  // Construct a template decl with name, parameters, and templated element.\n  RedeclarableTemplateDecl(Kind DK, ASTContext &C, DeclContext *DC,\n                           SourceLocation L, DeclarationName Name,\n                           TemplateParameterList *Params, NamedDecl *Decl)\n      : TemplateDecl(DK, DC, L, Name, Params, Decl), redeclarable_base(C) {}\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend class ASTReader;\n  template <class decl_type> friend class RedeclarableTemplate;\n\n  /// Retrieves the canonical declaration of this template.\n  RedeclarableTemplateDecl *getCanonicalDecl() override {\n    return getFirstDecl();\n  }\n  const RedeclarableTemplateDecl *getCanonicalDecl() const {\n    return getFirstDecl();\n  }\n\n  /// Determines whether this template was a specialization of a\n  /// member template.\n  ///\n  /// In the following example, the function template \\c X<int>::f and the\n  /// member template \\c X<int>::Inner are member specializations.\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   template<typename U> void f(T, U);\n  ///   template<typename U> struct Inner;\n  /// };\n  ///\n  /// template<> template<typename T>\n  /// void X<int>::f(int, T);\n  /// template<> template<typename T>\n  /// struct X<int>::Inner { /* ... */ };\n  /// \\endcode\n  bool isMemberSpecialization() const {\n    return getCommonPtr()->InstantiatedFromMember.getInt();\n  }\n\n  /// Note that this member template is a specialization.\n  void setMemberSpecialization() {\n    assert(getCommonPtr()->InstantiatedFromMember.getPointer() &&\n           \"Only member templates can be member template specializations\");\n    getCommonPtr()->InstantiatedFromMember.setInt(true);\n  }\n\n  /// Retrieve the member template from which this template was\n  /// instantiated, or nullptr if this template was not instantiated from a\n  /// member template.\n  ///\n  /// A template is instantiated from a member template when the member\n  /// template itself is part of a class template (or member thereof). For\n  /// example, given\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   template<typename U> void f(T, U);\n  /// };\n  ///\n  /// void test(X<int> x) {\n  ///   x.f(1, 'a');\n  /// };\n  /// \\endcode\n  ///\n  /// \\c X<int>::f is a FunctionTemplateDecl that describes the function\n  /// template\n  ///\n  /// \\code\n  /// template<typename U> void X<int>::f(int, U);\n  /// \\endcode\n  ///\n  /// which was itself created during the instantiation of \\c X<int>. Calling\n  /// getInstantiatedFromMemberTemplate() on this FunctionTemplateDecl will\n  /// retrieve the FunctionTemplateDecl for the original template \\c f within\n  /// the class template \\c X<T>, i.e.,\n  ///\n  /// \\code\n  /// template<typename T>\n  /// template<typename U>\n  /// void X<T>::f(T, U);\n  /// \\endcode\n  RedeclarableTemplateDecl *getInstantiatedFromMemberTemplate() const {\n    return getCommonPtr()->InstantiatedFromMember.getPointer();\n  }\n\n  void setInstantiatedFromMemberTemplate(RedeclarableTemplateDecl *TD) {\n    assert(!getCommonPtr()->InstantiatedFromMember.getPointer());\n    getCommonPtr()->InstantiatedFromMember.setPointer(TD);\n  }\n\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K >= firstRedeclarableTemplate && K <= lastRedeclarableTemplate;\n  }\n};\n\ntemplate <> struct RedeclarableTemplateDecl::\nSpecEntryTraits<FunctionTemplateSpecializationInfo> {\n  using DeclType = FunctionDecl;\n\n  static DeclType *getDecl(FunctionTemplateSpecializationInfo *I) {\n    return I->getFunction();\n  }\n\n  static ArrayRef<TemplateArgument>\n  getTemplateArgs(FunctionTemplateSpecializationInfo *I) {\n    return I->TemplateArguments->asArray();\n  }\n};\n\n/// Declaration of a template function.\nclass FunctionTemplateDecl : public RedeclarableTemplateDecl {\nprotected:\n  friend class FunctionDecl;\n\n  /// Data that is common to all of the declarations of a given\n  /// function template.\n  struct Common : CommonBase {\n    /// The function template specializations for this function\n    /// template, including explicit specializations and instantiations.\n    llvm::FoldingSetVector<FunctionTemplateSpecializationInfo> Specializations;\n\n    /// The set of \"injected\" template arguments used within this\n    /// function template.\n    ///\n    /// This pointer refers to the template arguments (there are as\n    /// many template arguments as template parameaters) for the function\n    /// template, and is allocated lazily, since most function templates do not\n    /// require the use of this information.\n    TemplateArgument *InjectedArgs = nullptr;\n\n    Common() = default;\n  };\n\n  FunctionTemplateDecl(ASTContext &C, DeclContext *DC, SourceLocation L,\n                       DeclarationName Name, TemplateParameterList *Params,\n                       NamedDecl *Decl)\n      : RedeclarableTemplateDecl(FunctionTemplate, C, DC, L, Name, Params,\n                                 Decl) {}\n\n  CommonBase *newCommon(ASTContext &C) const override;\n\n  Common *getCommonPtr() const {\n    return static_cast<Common *>(RedeclarableTemplateDecl::getCommonPtr());\n  }\n\n  /// Retrieve the set of function template specializations of this\n  /// function template.\n  llvm::FoldingSetVector<FunctionTemplateSpecializationInfo> &\n  getSpecializations() const;\n\n  /// Add a specialization of this function template.\n  ///\n  /// \\param InsertPos Insert position in the FoldingSetVector, must have been\n  ///        retrieved by an earlier call to findSpecialization().\n  void addSpecialization(FunctionTemplateSpecializationInfo* Info,\n                         void *InsertPos);\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Load any lazily-loaded specializations from the external source.\n  void LoadLazySpecializations() const;\n\n  /// Get the underlying function declaration of the template.\n  FunctionDecl *getTemplatedDecl() const {\n    return static_cast<FunctionDecl *>(TemplatedDecl);\n  }\n\n  /// Returns whether this template declaration defines the primary\n  /// pattern.\n  bool isThisDeclarationADefinition() const {\n    return getTemplatedDecl()->isThisDeclarationADefinition();\n  }\n\n  /// Return the specialization with the provided arguments if it exists,\n  /// otherwise return the insertion point.\n  FunctionDecl *findSpecialization(ArrayRef<TemplateArgument> Args,\n                                   void *&InsertPos);\n\n  FunctionTemplateDecl *getCanonicalDecl() override {\n    return cast<FunctionTemplateDecl>(\n             RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n  const FunctionTemplateDecl *getCanonicalDecl() const {\n    return cast<FunctionTemplateDecl>(\n             RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n\n  /// Retrieve the previous declaration of this function template, or\n  /// nullptr if no such declaration exists.\n  FunctionTemplateDecl *getPreviousDecl() {\n    return cast_or_null<FunctionTemplateDecl>(\n             static_cast<RedeclarableTemplateDecl *>(this)->getPreviousDecl());\n  }\n  const FunctionTemplateDecl *getPreviousDecl() const {\n    return cast_or_null<FunctionTemplateDecl>(\n       static_cast<const RedeclarableTemplateDecl *>(this)->getPreviousDecl());\n  }\n\n  FunctionTemplateDecl *getMostRecentDecl() {\n    return cast<FunctionTemplateDecl>(\n        static_cast<RedeclarableTemplateDecl *>(this)\n            ->getMostRecentDecl());\n  }\n  const FunctionTemplateDecl *getMostRecentDecl() const {\n    return const_cast<FunctionTemplateDecl*>(this)->getMostRecentDecl();\n  }\n\n  FunctionTemplateDecl *getInstantiatedFromMemberTemplate() const {\n    return cast_or_null<FunctionTemplateDecl>(\n             RedeclarableTemplateDecl::getInstantiatedFromMemberTemplate());\n  }\n\n  using spec_iterator = SpecIterator<FunctionTemplateSpecializationInfo>;\n  using spec_range = llvm::iterator_range<spec_iterator>;\n\n  spec_range specializations() const {\n    return spec_range(spec_begin(), spec_end());\n  }\n\n  spec_iterator spec_begin() const {\n    return makeSpecIterator(getSpecializations(), false);\n  }\n\n  spec_iterator spec_end() const {\n    return makeSpecIterator(getSpecializations(), true);\n  }\n\n  /// Retrieve the \"injected\" template arguments that correspond to the\n  /// template parameters of this function template.\n  ///\n  /// Although the C++ standard has no notion of the \"injected\" template\n  /// arguments for a function template, the notion is convenient when\n  /// we need to perform substitutions inside the definition of a function\n  /// template.\n  ArrayRef<TemplateArgument> getInjectedTemplateArgs();\n\n  /// Return whether this function template is an abbreviated function template,\n  /// e.g. `void foo(auto x)` or `template<typename T> void foo(auto x)`\n  bool isAbbreviated() const {\n    // Since the invented template parameters generated from 'auto' parameters\n    // are either appended to the end of the explicit template parameter list or\n    // form a new template paramter list, we can simply observe the last\n    // parameter to determine if such a thing happened.\n    const TemplateParameterList *TPL = getTemplateParameters();\n    return TPL->getParam(TPL->size() - 1)->isImplicit();\n  }\n\n  /// Merge \\p Prev with our RedeclarableTemplateDecl::Common.\n  void mergePrevDecl(FunctionTemplateDecl *Prev);\n\n  /// Create a function template node.\n  static FunctionTemplateDecl *Create(ASTContext &C, DeclContext *DC,\n                                      SourceLocation L,\n                                      DeclarationName Name,\n                                      TemplateParameterList *Params,\n                                      NamedDecl *Decl);\n\n  /// Create an empty function template node.\n  static FunctionTemplateDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  // Implement isa/cast/dyncast support\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == FunctionTemplate; }\n};\n\n//===----------------------------------------------------------------------===//\n// Kinds of Template Parameters\n//===----------------------------------------------------------------------===//\n\n/// Defines the position of a template parameter within a template\n/// parameter list.\n///\n/// Because template parameter can be listed\n/// sequentially for out-of-line template members, each template parameter is\n/// given a Depth - the nesting of template parameter scopes - and a Position -\n/// the occurrence within the parameter list.\n/// This class is inheritedly privately by different kinds of template\n/// parameters and is not part of the Decl hierarchy. Just a facility.\nclass TemplateParmPosition {\nprotected:\n  // FIXME: These probably don't need to be ints. int:5 for depth, int:8 for\n  // position? Maybe?\n  unsigned Depth;\n  unsigned Position;\n\n  TemplateParmPosition(unsigned D, unsigned P) : Depth(D), Position(P) {}\n\npublic:\n  TemplateParmPosition() = delete;\n\n  /// Get the nesting depth of the template parameter.\n  unsigned getDepth() const { return Depth; }\n  void setDepth(unsigned D) { Depth = D; }\n\n  /// Get the position of the template parameter within its parameter list.\n  unsigned getPosition() const { return Position; }\n  void setPosition(unsigned P) { Position = P; }\n\n  /// Get the index of the template parameter within its parameter list.\n  unsigned getIndex() const { return Position; }\n};\n\n/// Declaration of a template type parameter.\n///\n/// For example, \"T\" in\n/// \\code\n/// template<typename T> class vector;\n/// \\endcode\nclass TemplateTypeParmDecl final : public TypeDecl,\n    private llvm::TrailingObjects<TemplateTypeParmDecl, TypeConstraint> {\n  /// Sema creates these on the stack during auto type deduction.\n  friend class Sema;\n  friend TrailingObjects;\n  friend class ASTDeclReader;\n\n  /// Whether this template type parameter was declaration with\n  /// the 'typename' keyword.\n  ///\n  /// If false, it was declared with the 'class' keyword.\n  bool Typename : 1;\n\n  /// Whether this template type parameter has a type-constraint construct.\n  bool HasTypeConstraint : 1;\n\n  /// Whether the type constraint has been initialized. This can be false if the\n  /// constraint was not initialized yet or if there was an error forming the\n  /// type constriant.\n  bool TypeConstraintInitialized : 1;\n\n  /// Whether this non-type template parameter is an \"expanded\"\n  /// parameter pack, meaning that its type is a pack expansion and we\n  /// already know the set of types that expansion expands to.\n  bool ExpandedParameterPack : 1;\n\n  /// The number of type parameters in an expanded parameter pack.\n  unsigned NumExpanded = 0;\n\n  /// The default template argument, if any.\n  using DefArgStorage =\n      DefaultArgStorage<TemplateTypeParmDecl, TypeSourceInfo *>;\n  DefArgStorage DefaultArgument;\n\n  TemplateTypeParmDecl(DeclContext *DC, SourceLocation KeyLoc,\n                       SourceLocation IdLoc, IdentifierInfo *Id,\n                       bool Typename, bool HasTypeConstraint,\n                       Optional<unsigned> NumExpanded)\n      : TypeDecl(TemplateTypeParm, DC, IdLoc, Id, KeyLoc), Typename(Typename),\n      HasTypeConstraint(HasTypeConstraint), TypeConstraintInitialized(false),\n      ExpandedParameterPack(NumExpanded),\n      NumExpanded(NumExpanded ? *NumExpanded : 0) {}\n\npublic:\n  static TemplateTypeParmDecl *Create(const ASTContext &C, DeclContext *DC,\n                                      SourceLocation KeyLoc,\n                                      SourceLocation NameLoc,\n                                      unsigned D, unsigned P,\n                                      IdentifierInfo *Id, bool Typename,\n                                      bool ParameterPack,\n                                      bool HasTypeConstraint = false,\n                                      Optional<unsigned> NumExpanded = None);\n  static TemplateTypeParmDecl *CreateDeserialized(const ASTContext &C,\n                                                  unsigned ID);\n  static TemplateTypeParmDecl *CreateDeserialized(const ASTContext &C,\n                                                  unsigned ID,\n                                                  bool HasTypeConstraint);\n\n  /// Whether this template type parameter was declared with\n  /// the 'typename' keyword.\n  ///\n  /// If not, it was either declared with the 'class' keyword or with a\n  /// type-constraint (see hasTypeConstraint()).\n  bool wasDeclaredWithTypename() const {\n    return Typename && !HasTypeConstraint;\n  }\n\n  const DefArgStorage &getDefaultArgStorage() const { return DefaultArgument; }\n\n  /// Determine whether this template parameter has a default\n  /// argument.\n  bool hasDefaultArgument() const { return DefaultArgument.isSet(); }\n\n  /// Retrieve the default argument, if any.\n  QualType getDefaultArgument() const {\n    return DefaultArgument.get()->getType();\n  }\n\n  /// Retrieves the default argument's source information, if any.\n  TypeSourceInfo *getDefaultArgumentInfo() const {\n    return DefaultArgument.get();\n  }\n\n  /// Retrieves the location of the default argument declaration.\n  SourceLocation getDefaultArgumentLoc() const;\n\n  /// Determines whether the default argument was inherited\n  /// from a previous declaration of this template.\n  bool defaultArgumentWasInherited() const {\n    return DefaultArgument.isInherited();\n  }\n\n  /// Set the default argument for this template parameter.\n  void setDefaultArgument(TypeSourceInfo *DefArg) {\n    DefaultArgument.set(DefArg);\n  }\n\n  /// Set that this default argument was inherited from another\n  /// parameter.\n  void setInheritedDefaultArgument(const ASTContext &C,\n                                   TemplateTypeParmDecl *Prev) {\n    DefaultArgument.setInherited(C, Prev);\n  }\n\n  /// Removes the default argument of this template parameter.\n  void removeDefaultArgument() {\n    DefaultArgument.clear();\n  }\n\n  /// Set whether this template type parameter was declared with\n  /// the 'typename' or 'class' keyword.\n  void setDeclaredWithTypename(bool withTypename) { Typename = withTypename; }\n\n  /// Retrieve the depth of the template parameter.\n  unsigned getDepth() const;\n\n  /// Retrieve the index of the template parameter.\n  unsigned getIndex() const;\n\n  /// Returns whether this is a parameter pack.\n  bool isParameterPack() const;\n\n  /// Whether this parameter pack is a pack expansion.\n  ///\n  /// A template type template parameter pack can be a pack expansion if its\n  /// type-constraint contains an unexpanded parameter pack.\n  bool isPackExpansion() const {\n    if (!isParameterPack())\n      return false;\n    if (const TypeConstraint *TC = getTypeConstraint())\n      if (TC->hasExplicitTemplateArgs())\n        for (const auto &ArgLoc : TC->getTemplateArgsAsWritten()->arguments())\n          if (ArgLoc.getArgument().containsUnexpandedParameterPack())\n            return true;\n    return false;\n  }\n\n  /// Whether this parameter is a template type parameter pack that has a known\n  /// list of different type-constraints at different positions.\n  ///\n  /// A parameter pack is an expanded parameter pack when the original\n  /// parameter pack's type-constraint was itself a pack expansion, and that\n  /// expansion has already been expanded. For example, given:\n  ///\n  /// \\code\n  /// template<typename ...Types>\n  /// struct X {\n  ///   template<convertible_to<Types> ...Convertibles>\n  ///   struct Y { /* ... */ };\n  /// };\n  /// \\endcode\n  ///\n  /// The parameter pack \\c Convertibles has (convertible_to<Types> && ...) as\n  /// its type-constraint. When \\c Types is supplied with template arguments by\n  /// instantiating \\c X, the instantiation of \\c Convertibles becomes an\n  /// expanded parameter pack. For example, instantiating\n  /// \\c X<int, unsigned int> results in \\c Convertibles being an expanded\n  /// parameter pack of size 2 (use getNumExpansionTypes() to get this number).\n  bool isExpandedParameterPack() const { return ExpandedParameterPack; }\n\n  /// Retrieves the number of parameters in an expanded parameter pack.\n  unsigned getNumExpansionParameters() const {\n    assert(ExpandedParameterPack && \"Not an expansion parameter pack\");\n    return NumExpanded;\n  }\n\n  /// Returns the type constraint associated with this template parameter (if\n  /// any).\n  const TypeConstraint *getTypeConstraint() const {\n    return TypeConstraintInitialized ? getTrailingObjects<TypeConstraint>() :\n         nullptr;\n  }\n\n  void setTypeConstraint(NestedNameSpecifierLoc NNS,\n                         DeclarationNameInfo NameInfo, NamedDecl *FoundDecl,\n                         ConceptDecl *CD,\n                         const ASTTemplateArgumentListInfo *ArgsAsWritten,\n                         Expr *ImmediatelyDeclaredConstraint);\n\n  /// Determine whether this template parameter has a type-constraint.\n  bool hasTypeConstraint() const {\n    return HasTypeConstraint;\n  }\n\n  /// \\brief Get the associated-constraints of this template parameter.\n  /// This will either be the immediately-introduced constraint or empty.\n  ///\n  /// Use this instead of getConstraintExpression for concepts APIs that\n  /// accept an ArrayRef of constraint expressions.\n  void getAssociatedConstraints(llvm::SmallVectorImpl<const Expr *> &AC) const {\n    if (HasTypeConstraint)\n      AC.push_back(getTypeConstraint()->getImmediatelyDeclaredConstraint());\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == TemplateTypeParm; }\n};\n\n/// NonTypeTemplateParmDecl - Declares a non-type template parameter,\n/// e.g., \"Size\" in\n/// @code\n/// template<int Size> class array { };\n/// @endcode\nclass NonTypeTemplateParmDecl final\n    : public DeclaratorDecl,\n      protected TemplateParmPosition,\n      private llvm::TrailingObjects<NonTypeTemplateParmDecl,\n                                    std::pair<QualType, TypeSourceInfo *>,\n                                    Expr *> {\n  friend class ASTDeclReader;\n  friend TrailingObjects;\n\n  /// The default template argument, if any, and whether or not\n  /// it was inherited.\n  using DefArgStorage = DefaultArgStorage<NonTypeTemplateParmDecl, Expr *>;\n  DefArgStorage DefaultArgument;\n\n  // FIXME: Collapse this into TemplateParamPosition; or, just move depth/index\n  // down here to save memory.\n\n  /// Whether this non-type template parameter is a parameter pack.\n  bool ParameterPack;\n\n  /// Whether this non-type template parameter is an \"expanded\"\n  /// parameter pack, meaning that its type is a pack expansion and we\n  /// already know the set of types that expansion expands to.\n  bool ExpandedParameterPack = false;\n\n  /// The number of types in an expanded parameter pack.\n  unsigned NumExpandedTypes = 0;\n\n  size_t numTrailingObjects(\n      OverloadToken<std::pair<QualType, TypeSourceInfo *>>) const {\n    return NumExpandedTypes;\n  }\n\n  NonTypeTemplateParmDecl(DeclContext *DC, SourceLocation StartLoc,\n                          SourceLocation IdLoc, unsigned D, unsigned P,\n                          IdentifierInfo *Id, QualType T,\n                          bool ParameterPack, TypeSourceInfo *TInfo)\n      : DeclaratorDecl(NonTypeTemplateParm, DC, IdLoc, Id, T, TInfo, StartLoc),\n        TemplateParmPosition(D, P), ParameterPack(ParameterPack) {}\n\n  NonTypeTemplateParmDecl(DeclContext *DC, SourceLocation StartLoc,\n                          SourceLocation IdLoc, unsigned D, unsigned P,\n                          IdentifierInfo *Id, QualType T,\n                          TypeSourceInfo *TInfo,\n                          ArrayRef<QualType> ExpandedTypes,\n                          ArrayRef<TypeSourceInfo *> ExpandedTInfos);\n\npublic:\n  static NonTypeTemplateParmDecl *\n  Create(const ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n         SourceLocation IdLoc, unsigned D, unsigned P, IdentifierInfo *Id,\n         QualType T, bool ParameterPack, TypeSourceInfo *TInfo);\n\n  static NonTypeTemplateParmDecl *\n  Create(const ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n         SourceLocation IdLoc, unsigned D, unsigned P, IdentifierInfo *Id,\n         QualType T, TypeSourceInfo *TInfo, ArrayRef<QualType> ExpandedTypes,\n         ArrayRef<TypeSourceInfo *> ExpandedTInfos);\n\n  static NonTypeTemplateParmDecl *CreateDeserialized(ASTContext &C,\n                                                     unsigned ID,\n                                                     bool HasTypeConstraint);\n  static NonTypeTemplateParmDecl *CreateDeserialized(ASTContext &C,\n                                                     unsigned ID,\n                                                     unsigned NumExpandedTypes,\n                                                     bool HasTypeConstraint);\n\n  using TemplateParmPosition::getDepth;\n  using TemplateParmPosition::setDepth;\n  using TemplateParmPosition::getPosition;\n  using TemplateParmPosition::setPosition;\n  using TemplateParmPosition::getIndex;\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  const DefArgStorage &getDefaultArgStorage() const { return DefaultArgument; }\n\n  /// Determine whether this template parameter has a default\n  /// argument.\n  bool hasDefaultArgument() const { return DefaultArgument.isSet(); }\n\n  /// Retrieve the default argument, if any.\n  Expr *getDefaultArgument() const { return DefaultArgument.get(); }\n\n  /// Retrieve the location of the default argument, if any.\n  SourceLocation getDefaultArgumentLoc() const;\n\n  /// Determines whether the default argument was inherited\n  /// from a previous declaration of this template.\n  bool defaultArgumentWasInherited() const {\n    return DefaultArgument.isInherited();\n  }\n\n  /// Set the default argument for this template parameter, and\n  /// whether that default argument was inherited from another\n  /// declaration.\n  void setDefaultArgument(Expr *DefArg) { DefaultArgument.set(DefArg); }\n  void setInheritedDefaultArgument(const ASTContext &C,\n                                   NonTypeTemplateParmDecl *Parm) {\n    DefaultArgument.setInherited(C, Parm);\n  }\n\n  /// Removes the default argument of this template parameter.\n  void removeDefaultArgument() { DefaultArgument.clear(); }\n\n  /// Whether this parameter is a non-type template parameter pack.\n  ///\n  /// If the parameter is a parameter pack, the type may be a\n  /// \\c PackExpansionType. In the following example, the \\c Dims parameter\n  /// is a parameter pack (whose type is 'unsigned').\n  ///\n  /// \\code\n  /// template<typename T, unsigned ...Dims> struct multi_array;\n  /// \\endcode\n  bool isParameterPack() const { return ParameterPack; }\n\n  /// Whether this parameter pack is a pack expansion.\n  ///\n  /// A non-type template parameter pack is a pack expansion if its type\n  /// contains an unexpanded parameter pack. In this case, we will have\n  /// built a PackExpansionType wrapping the type.\n  bool isPackExpansion() const {\n    return ParameterPack && getType()->getAs<PackExpansionType>();\n  }\n\n  /// Whether this parameter is a non-type template parameter pack\n  /// that has a known list of different types at different positions.\n  ///\n  /// A parameter pack is an expanded parameter pack when the original\n  /// parameter pack's type was itself a pack expansion, and that expansion\n  /// has already been expanded. For example, given:\n  ///\n  /// \\code\n  /// template<typename ...Types>\n  /// struct X {\n  ///   template<Types ...Values>\n  ///   struct Y { /* ... */ };\n  /// };\n  /// \\endcode\n  ///\n  /// The parameter pack \\c Values has a \\c PackExpansionType as its type,\n  /// which expands \\c Types. When \\c Types is supplied with template arguments\n  /// by instantiating \\c X, the instantiation of \\c Values becomes an\n  /// expanded parameter pack. For example, instantiating\n  /// \\c X<int, unsigned int> results in \\c Values being an expanded parameter\n  /// pack with expansion types \\c int and \\c unsigned int.\n  ///\n  /// The \\c getExpansionType() and \\c getExpansionTypeSourceInfo() functions\n  /// return the expansion types.\n  bool isExpandedParameterPack() const { return ExpandedParameterPack; }\n\n  /// Retrieves the number of expansion types in an expanded parameter\n  /// pack.\n  unsigned getNumExpansionTypes() const {\n    assert(ExpandedParameterPack && \"Not an expansion parameter pack\");\n    return NumExpandedTypes;\n  }\n\n  /// Retrieve a particular expansion type within an expanded parameter\n  /// pack.\n  QualType getExpansionType(unsigned I) const {\n    assert(I < NumExpandedTypes && \"Out-of-range expansion type index\");\n    auto TypesAndInfos =\n        getTrailingObjects<std::pair<QualType, TypeSourceInfo *>>();\n    return TypesAndInfos[I].first;\n  }\n\n  /// Retrieve a particular expansion type source info within an\n  /// expanded parameter pack.\n  TypeSourceInfo *getExpansionTypeSourceInfo(unsigned I) const {\n    assert(I < NumExpandedTypes && \"Out-of-range expansion type index\");\n    auto TypesAndInfos =\n        getTrailingObjects<std::pair<QualType, TypeSourceInfo *>>();\n    return TypesAndInfos[I].second;\n  }\n\n  /// Return the constraint introduced by the placeholder type of this non-type\n  /// template parameter (if any).\n  Expr *getPlaceholderTypeConstraint() const {\n    return hasPlaceholderTypeConstraint() ? *getTrailingObjects<Expr *>() :\n        nullptr;\n  }\n\n  void setPlaceholderTypeConstraint(Expr *E) {\n    *getTrailingObjects<Expr *>() = E;\n  }\n\n  /// Determine whether this non-type template parameter's type has a\n  /// placeholder with a type-constraint.\n  bool hasPlaceholderTypeConstraint() const {\n    auto *AT = getType()->getContainedAutoType();\n    return AT && AT->isConstrained();\n  }\n\n  /// \\brief Get the associated-constraints of this template parameter.\n  /// This will either be a vector of size 1 containing the immediately-declared\n  /// constraint introduced by the placeholder type, or an empty vector.\n  ///\n  /// Use this instead of getPlaceholderImmediatelyDeclaredConstraint for\n  /// concepts APIs that accept an ArrayRef of constraint expressions.\n  void getAssociatedConstraints(llvm::SmallVectorImpl<const Expr *> &AC) const {\n    if (Expr *E = getPlaceholderTypeConstraint())\n      AC.push_back(E);\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == NonTypeTemplateParm; }\n};\n\n/// TemplateTemplateParmDecl - Declares a template template parameter,\n/// e.g., \"T\" in\n/// @code\n/// template <template <typename> class T> class container { };\n/// @endcode\n/// A template template parameter is a TemplateDecl because it defines the\n/// name of a template and the template parameters allowable for substitution.\nclass TemplateTemplateParmDecl final\n    : public TemplateDecl,\n      protected TemplateParmPosition,\n      private llvm::TrailingObjects<TemplateTemplateParmDecl,\n                                    TemplateParameterList *> {\n  /// The default template argument, if any.\n  using DefArgStorage =\n      DefaultArgStorage<TemplateTemplateParmDecl, TemplateArgumentLoc *>;\n  DefArgStorage DefaultArgument;\n\n  /// Whether this parameter is a parameter pack.\n  bool ParameterPack;\n\n  /// Whether this template template parameter is an \"expanded\"\n  /// parameter pack, meaning that it is a pack expansion and we\n  /// already know the set of template parameters that expansion expands to.\n  bool ExpandedParameterPack = false;\n\n  /// The number of parameters in an expanded parameter pack.\n  unsigned NumExpandedParams = 0;\n\n  TemplateTemplateParmDecl(DeclContext *DC, SourceLocation L,\n                           unsigned D, unsigned P, bool ParameterPack,\n                           IdentifierInfo *Id, TemplateParameterList *Params)\n      : TemplateDecl(TemplateTemplateParm, DC, L, Id, Params),\n        TemplateParmPosition(D, P), ParameterPack(ParameterPack) {}\n\n  TemplateTemplateParmDecl(DeclContext *DC, SourceLocation L,\n                           unsigned D, unsigned P,\n                           IdentifierInfo *Id, TemplateParameterList *Params,\n                           ArrayRef<TemplateParameterList *> Expansions);\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend TrailingObjects;\n\n  static TemplateTemplateParmDecl *Create(const ASTContext &C, DeclContext *DC,\n                                          SourceLocation L, unsigned D,\n                                          unsigned P, bool ParameterPack,\n                                          IdentifierInfo *Id,\n                                          TemplateParameterList *Params);\n  static TemplateTemplateParmDecl *Create(const ASTContext &C, DeclContext *DC,\n                                          SourceLocation L, unsigned D,\n                                          unsigned P,\n                                          IdentifierInfo *Id,\n                                          TemplateParameterList *Params,\n                                 ArrayRef<TemplateParameterList *> Expansions);\n\n  static TemplateTemplateParmDecl *CreateDeserialized(ASTContext &C,\n                                                      unsigned ID);\n  static TemplateTemplateParmDecl *CreateDeserialized(ASTContext &C,\n                                                      unsigned ID,\n                                                      unsigned NumExpansions);\n\n  using TemplateParmPosition::getDepth;\n  using TemplateParmPosition::setDepth;\n  using TemplateParmPosition::getPosition;\n  using TemplateParmPosition::setPosition;\n  using TemplateParmPosition::getIndex;\n\n  /// Whether this template template parameter is a template\n  /// parameter pack.\n  ///\n  /// \\code\n  /// template<template <class T> ...MetaFunctions> struct Apply;\n  /// \\endcode\n  bool isParameterPack() const { return ParameterPack; }\n\n  /// Whether this parameter pack is a pack expansion.\n  ///\n  /// A template template parameter pack is a pack expansion if its template\n  /// parameter list contains an unexpanded parameter pack.\n  bool isPackExpansion() const {\n    return ParameterPack &&\n           getTemplateParameters()->containsUnexpandedParameterPack();\n  }\n\n  /// Whether this parameter is a template template parameter pack that\n  /// has a known list of different template parameter lists at different\n  /// positions.\n  ///\n  /// A parameter pack is an expanded parameter pack when the original parameter\n  /// pack's template parameter list was itself a pack expansion, and that\n  /// expansion has already been expanded. For exampe, given:\n  ///\n  /// \\code\n  /// template<typename...Types> struct Outer {\n  ///   template<template<Types> class...Templates> struct Inner;\n  /// };\n  /// \\endcode\n  ///\n  /// The parameter pack \\c Templates is a pack expansion, which expands the\n  /// pack \\c Types. When \\c Types is supplied with template arguments by\n  /// instantiating \\c Outer, the instantiation of \\c Templates is an expanded\n  /// parameter pack.\n  bool isExpandedParameterPack() const { return ExpandedParameterPack; }\n\n  /// Retrieves the number of expansion template parameters in\n  /// an expanded parameter pack.\n  unsigned getNumExpansionTemplateParameters() const {\n    assert(ExpandedParameterPack && \"Not an expansion parameter pack\");\n    return NumExpandedParams;\n  }\n\n  /// Retrieve a particular expansion type within an expanded parameter\n  /// pack.\n  TemplateParameterList *getExpansionTemplateParameters(unsigned I) const {\n    assert(I < NumExpandedParams && \"Out-of-range expansion type index\");\n    return getTrailingObjects<TemplateParameterList *>()[I];\n  }\n\n  const DefArgStorage &getDefaultArgStorage() const { return DefaultArgument; }\n\n  /// Determine whether this template parameter has a default\n  /// argument.\n  bool hasDefaultArgument() const { return DefaultArgument.isSet(); }\n\n  /// Retrieve the default argument, if any.\n  const TemplateArgumentLoc &getDefaultArgument() const {\n    static const TemplateArgumentLoc NoneLoc;\n    return DefaultArgument.isSet() ? *DefaultArgument.get() : NoneLoc;\n  }\n\n  /// Retrieve the location of the default argument, if any.\n  SourceLocation getDefaultArgumentLoc() const;\n\n  /// Determines whether the default argument was inherited\n  /// from a previous declaration of this template.\n  bool defaultArgumentWasInherited() const {\n    return DefaultArgument.isInherited();\n  }\n\n  /// Set the default argument for this template parameter, and\n  /// whether that default argument was inherited from another\n  /// declaration.\n  void setDefaultArgument(const ASTContext &C,\n                          const TemplateArgumentLoc &DefArg);\n  void setInheritedDefaultArgument(const ASTContext &C,\n                                   TemplateTemplateParmDecl *Prev) {\n    DefaultArgument.setInherited(C, Prev);\n  }\n\n  /// Removes the default argument of this template parameter.\n  void removeDefaultArgument() { DefaultArgument.clear(); }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    SourceLocation End = getLocation();\n    if (hasDefaultArgument() && !defaultArgumentWasInherited())\n      End = getDefaultArgument().getSourceRange().getEnd();\n    return SourceRange(getTemplateParameters()->getTemplateLoc(), End);\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == TemplateTemplateParm; }\n};\n\n/// Represents the builtin template declaration which is used to\n/// implement __make_integer_seq and other builtin templates.  It serves\n/// no real purpose beyond existing as a place to hold template parameters.\nclass BuiltinTemplateDecl : public TemplateDecl {\n  BuiltinTemplateKind BTK;\n\n  BuiltinTemplateDecl(const ASTContext &C, DeclContext *DC,\n                      DeclarationName Name, BuiltinTemplateKind BTK);\n\n  void anchor() override;\n\npublic:\n  // Implement isa/cast/dyncast support\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == BuiltinTemplate; }\n\n  static BuiltinTemplateDecl *Create(const ASTContext &C, DeclContext *DC,\n                                     DeclarationName Name,\n                                     BuiltinTemplateKind BTK) {\n    return new (C, DC) BuiltinTemplateDecl(C, DC, Name, BTK);\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return {};\n  }\n\n  BuiltinTemplateKind getBuiltinTemplateKind() const { return BTK; }\n};\n\n/// Represents a class template specialization, which refers to\n/// a class template with a given set of template arguments.\n///\n/// Class template specializations represent both explicit\n/// specialization of class templates, as in the example below, and\n/// implicit instantiations of class templates.\n///\n/// \\code\n/// template<typename T> class array;\n///\n/// template<>\n/// class array<bool> { }; // class template specialization array<bool>\n/// \\endcode\nclass ClassTemplateSpecializationDecl\n  : public CXXRecordDecl, public llvm::FoldingSetNode {\n  /// Structure that stores information about a class template\n  /// specialization that was instantiated from a class template partial\n  /// specialization.\n  struct SpecializedPartialSpecialization {\n    /// The class template partial specialization from which this\n    /// class template specialization was instantiated.\n    ClassTemplatePartialSpecializationDecl *PartialSpecialization;\n\n    /// The template argument list deduced for the class template\n    /// partial specialization itself.\n    const TemplateArgumentList *TemplateArgs;\n  };\n\n  /// The template that this specialization specializes\n  llvm::PointerUnion<ClassTemplateDecl *, SpecializedPartialSpecialization *>\n    SpecializedTemplate;\n\n  /// Further info for explicit template specialization/instantiation.\n  struct ExplicitSpecializationInfo {\n    /// The type-as-written.\n    TypeSourceInfo *TypeAsWritten = nullptr;\n\n    /// The location of the extern keyword.\n    SourceLocation ExternLoc;\n\n    /// The location of the template keyword.\n    SourceLocation TemplateKeywordLoc;\n\n    ExplicitSpecializationInfo() = default;\n  };\n\n  /// Further info for explicit template specialization/instantiation.\n  /// Does not apply to implicit specializations.\n  ExplicitSpecializationInfo *ExplicitInfo = nullptr;\n\n  /// The template arguments used to describe this specialization.\n  const TemplateArgumentList *TemplateArgs;\n\n  /// The point where this template was instantiated (if any)\n  SourceLocation PointOfInstantiation;\n\n  /// The kind of specialization this declaration refers to.\n  /// Really a value of type TemplateSpecializationKind.\n  unsigned SpecializationKind : 3;\n\nprotected:\n  ClassTemplateSpecializationDecl(ASTContext &Context, Kind DK, TagKind TK,\n                                  DeclContext *DC, SourceLocation StartLoc,\n                                  SourceLocation IdLoc,\n                                  ClassTemplateDecl *SpecializedTemplate,\n                                  ArrayRef<TemplateArgument> Args,\n                                  ClassTemplateSpecializationDecl *PrevDecl);\n\n  explicit ClassTemplateSpecializationDecl(ASTContext &C, Kind DK);\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static ClassTemplateSpecializationDecl *\n  Create(ASTContext &Context, TagKind TK, DeclContext *DC,\n         SourceLocation StartLoc, SourceLocation IdLoc,\n         ClassTemplateDecl *SpecializedTemplate,\n         ArrayRef<TemplateArgument> Args,\n         ClassTemplateSpecializationDecl *PrevDecl);\n  static ClassTemplateSpecializationDecl *\n  CreateDeserialized(ASTContext &C, unsigned ID);\n\n  void getNameForDiagnostic(raw_ostream &OS, const PrintingPolicy &Policy,\n                            bool Qualified) const override;\n\n  // FIXME: This is broken. CXXRecordDecl::getMostRecentDecl() returns a\n  // different \"most recent\" declaration from this function for the same\n  // declaration, because we don't override getMostRecentDeclImpl(). But\n  // it's not clear that we should override that, because the most recent\n  // declaration as a CXXRecordDecl sometimes is the injected-class-name.\n  ClassTemplateSpecializationDecl *getMostRecentDecl() {\n    return cast<ClassTemplateSpecializationDecl>(\n        getMostRecentNonInjectedDecl());\n  }\n\n  /// Retrieve the template that this specialization specializes.\n  ClassTemplateDecl *getSpecializedTemplate() const;\n\n  /// Retrieve the template arguments of the class template\n  /// specialization.\n  const TemplateArgumentList &getTemplateArgs() const {\n    return *TemplateArgs;\n  }\n\n  void setTemplateArgs(TemplateArgumentList *Args) {\n    TemplateArgs = Args;\n  }\n\n  /// Determine the kind of specialization that this\n  /// declaration represents.\n  TemplateSpecializationKind getSpecializationKind() const {\n    return static_cast<TemplateSpecializationKind>(SpecializationKind);\n  }\n\n  bool isExplicitSpecialization() const {\n    return getSpecializationKind() == TSK_ExplicitSpecialization;\n  }\n\n  /// Is this an explicit specialization at class scope (within the class that\n  /// owns the primary template)? For example:\n  ///\n  /// \\code\n  /// template<typename T> struct Outer {\n  ///   template<typename U> struct Inner;\n  ///   template<> struct Inner; // class-scope explicit specialization\n  /// };\n  /// \\endcode\n  bool isClassScopeExplicitSpecialization() const {\n    return isExplicitSpecialization() &&\n           isa<CXXRecordDecl>(getLexicalDeclContext());\n  }\n\n  /// True if this declaration is an explicit specialization,\n  /// explicit instantiation declaration, or explicit instantiation\n  /// definition.\n  bool isExplicitInstantiationOrSpecialization() const {\n    return isTemplateExplicitInstantiationOrSpecialization(\n        getTemplateSpecializationKind());\n  }\n\n  void setSpecializedTemplate(ClassTemplateDecl *Specialized) {\n    SpecializedTemplate = Specialized;\n  }\n\n  void setSpecializationKind(TemplateSpecializationKind TSK) {\n    SpecializationKind = TSK;\n  }\n\n  /// Get the point of instantiation (if any), or null if none.\n  SourceLocation getPointOfInstantiation() const {\n    return PointOfInstantiation;\n  }\n\n  void setPointOfInstantiation(SourceLocation Loc) {\n    assert(Loc.isValid() && \"point of instantiation must be valid!\");\n    PointOfInstantiation = Loc;\n  }\n\n  /// If this class template specialization is an instantiation of\n  /// a template (rather than an explicit specialization), return the\n  /// class template or class template partial specialization from which it\n  /// was instantiated.\n  llvm::PointerUnion<ClassTemplateDecl *,\n                     ClassTemplatePartialSpecializationDecl *>\n  getInstantiatedFrom() const {\n    if (!isTemplateInstantiation(getSpecializationKind()))\n      return llvm::PointerUnion<ClassTemplateDecl *,\n                                ClassTemplatePartialSpecializationDecl *>();\n\n    return getSpecializedTemplateOrPartial();\n  }\n\n  /// Retrieve the class template or class template partial\n  /// specialization which was specialized by this.\n  llvm::PointerUnion<ClassTemplateDecl *,\n                     ClassTemplatePartialSpecializationDecl *>\n  getSpecializedTemplateOrPartial() const {\n    if (const auto *PartialSpec =\n            SpecializedTemplate.dyn_cast<SpecializedPartialSpecialization *>())\n      return PartialSpec->PartialSpecialization;\n\n    return SpecializedTemplate.get<ClassTemplateDecl*>();\n  }\n\n  /// Retrieve the set of template arguments that should be used\n  /// to instantiate members of the class template or class template partial\n  /// specialization from which this class template specialization was\n  /// instantiated.\n  ///\n  /// \\returns For a class template specialization instantiated from the primary\n  /// template, this function will return the same template arguments as\n  /// getTemplateArgs(). For a class template specialization instantiated from\n  /// a class template partial specialization, this function will return the\n  /// deduced template arguments for the class template partial specialization\n  /// itself.\n  const TemplateArgumentList &getTemplateInstantiationArgs() const {\n    if (const auto *PartialSpec =\n            SpecializedTemplate.dyn_cast<SpecializedPartialSpecialization *>())\n      return *PartialSpec->TemplateArgs;\n\n    return getTemplateArgs();\n  }\n\n  /// Note that this class template specialization is actually an\n  /// instantiation of the given class template partial specialization whose\n  /// template arguments have been deduced.\n  void setInstantiationOf(ClassTemplatePartialSpecializationDecl *PartialSpec,\n                          const TemplateArgumentList *TemplateArgs) {\n    assert(!SpecializedTemplate.is<SpecializedPartialSpecialization*>() &&\n           \"Already set to a class template partial specialization!\");\n    auto *PS = new (getASTContext()) SpecializedPartialSpecialization();\n    PS->PartialSpecialization = PartialSpec;\n    PS->TemplateArgs = TemplateArgs;\n    SpecializedTemplate = PS;\n  }\n\n  /// Note that this class template specialization is an instantiation\n  /// of the given class template.\n  void setInstantiationOf(ClassTemplateDecl *TemplDecl) {\n    assert(!SpecializedTemplate.is<SpecializedPartialSpecialization*>() &&\n           \"Previously set to a class template partial specialization!\");\n    SpecializedTemplate = TemplDecl;\n  }\n\n  /// Sets the type of this specialization as it was written by\n  /// the user. This will be a class template specialization type.\n  void setTypeAsWritten(TypeSourceInfo *T) {\n    if (!ExplicitInfo)\n      ExplicitInfo = new (getASTContext()) ExplicitSpecializationInfo;\n    ExplicitInfo->TypeAsWritten = T;\n  }\n\n  /// Gets the type of this specialization as it was written by\n  /// the user, if it was so written.\n  TypeSourceInfo *getTypeAsWritten() const {\n    return ExplicitInfo ? ExplicitInfo->TypeAsWritten : nullptr;\n  }\n\n  /// Gets the location of the extern keyword, if present.\n  SourceLocation getExternLoc() const {\n    return ExplicitInfo ? ExplicitInfo->ExternLoc : SourceLocation();\n  }\n\n  /// Sets the location of the extern keyword.\n  void setExternLoc(SourceLocation Loc) {\n    if (!ExplicitInfo)\n      ExplicitInfo = new (getASTContext()) ExplicitSpecializationInfo;\n    ExplicitInfo->ExternLoc = Loc;\n  }\n\n  /// Sets the location of the template keyword.\n  void setTemplateKeywordLoc(SourceLocation Loc) {\n    if (!ExplicitInfo)\n      ExplicitInfo = new (getASTContext()) ExplicitSpecializationInfo;\n    ExplicitInfo->TemplateKeywordLoc = Loc;\n  }\n\n  /// Gets the location of the template keyword, if present.\n  SourceLocation getTemplateKeywordLoc() const {\n    return ExplicitInfo ? ExplicitInfo->TemplateKeywordLoc : SourceLocation();\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    Profile(ID, TemplateArgs->asArray(), getASTContext());\n  }\n\n  static void\n  Profile(llvm::FoldingSetNodeID &ID, ArrayRef<TemplateArgument> TemplateArgs,\n          ASTContext &Context) {\n    ID.AddInteger(TemplateArgs.size());\n    for (const TemplateArgument &TemplateArg : TemplateArgs)\n      TemplateArg.Profile(ID, Context);\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K >= firstClassTemplateSpecialization &&\n           K <= lastClassTemplateSpecialization;\n  }\n};\n\nclass ClassTemplatePartialSpecializationDecl\n  : public ClassTemplateSpecializationDecl {\n  /// The list of template parameters\n  TemplateParameterList* TemplateParams = nullptr;\n\n  /// The source info for the template arguments as written.\n  /// FIXME: redundant with TypeAsWritten?\n  const ASTTemplateArgumentListInfo *ArgsAsWritten = nullptr;\n\n  /// The class template partial specialization from which this\n  /// class template partial specialization was instantiated.\n  ///\n  /// The boolean value will be true to indicate that this class template\n  /// partial specialization was specialized at this level.\n  llvm::PointerIntPair<ClassTemplatePartialSpecializationDecl *, 1, bool>\n      InstantiatedFromMember;\n\n  ClassTemplatePartialSpecializationDecl(ASTContext &Context, TagKind TK,\n                                         DeclContext *DC,\n                                         SourceLocation StartLoc,\n                                         SourceLocation IdLoc,\n                                         TemplateParameterList *Params,\n                                         ClassTemplateDecl *SpecializedTemplate,\n                                         ArrayRef<TemplateArgument> Args,\n                               const ASTTemplateArgumentListInfo *ArgsAsWritten,\n                               ClassTemplatePartialSpecializationDecl *PrevDecl);\n\n  ClassTemplatePartialSpecializationDecl(ASTContext &C)\n    : ClassTemplateSpecializationDecl(C, ClassTemplatePartialSpecialization),\n      InstantiatedFromMember(nullptr, false) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static ClassTemplatePartialSpecializationDecl *\n  Create(ASTContext &Context, TagKind TK, DeclContext *DC,\n         SourceLocation StartLoc, SourceLocation IdLoc,\n         TemplateParameterList *Params,\n         ClassTemplateDecl *SpecializedTemplate,\n         ArrayRef<TemplateArgument> Args,\n         const TemplateArgumentListInfo &ArgInfos,\n         QualType CanonInjectedType,\n         ClassTemplatePartialSpecializationDecl *PrevDecl);\n\n  static ClassTemplatePartialSpecializationDecl *\n  CreateDeserialized(ASTContext &C, unsigned ID);\n\n  ClassTemplatePartialSpecializationDecl *getMostRecentDecl() {\n    return cast<ClassTemplatePartialSpecializationDecl>(\n             static_cast<ClassTemplateSpecializationDecl *>(\n               this)->getMostRecentDecl());\n  }\n\n  /// Get the list of template parameters\n  TemplateParameterList *getTemplateParameters() const {\n    return TemplateParams;\n  }\n\n  /// \\brief All associated constraints of this partial specialization,\n  /// including the requires clause and any constraints derived from\n  /// constrained-parameters.\n  ///\n  /// The constraints in the resulting list are to be treated as if in a\n  /// conjunction (\"and\").\n  void getAssociatedConstraints(llvm::SmallVectorImpl<const Expr *> &AC) const {\n    TemplateParams->getAssociatedConstraints(AC);\n  }\n\n  bool hasAssociatedConstraints() const {\n    return TemplateParams->hasAssociatedConstraints();\n  }\n\n  /// Get the template arguments as written.\n  const ASTTemplateArgumentListInfo *getTemplateArgsAsWritten() const {\n    return ArgsAsWritten;\n  }\n\n  /// Retrieve the member class template partial specialization from\n  /// which this particular class template partial specialization was\n  /// instantiated.\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct Outer {\n  ///   template<typename U> struct Inner;\n  ///   template<typename U> struct Inner<U*> { }; // #1\n  /// };\n  ///\n  /// Outer<float>::Inner<int*> ii;\n  /// \\endcode\n  ///\n  /// In this example, the instantiation of \\c Outer<float>::Inner<int*> will\n  /// end up instantiating the partial specialization\n  /// \\c Outer<float>::Inner<U*>, which itself was instantiated from the class\n  /// template partial specialization \\c Outer<T>::Inner<U*>. Given\n  /// \\c Outer<float>::Inner<U*>, this function would return\n  /// \\c Outer<T>::Inner<U*>.\n  ClassTemplatePartialSpecializationDecl *getInstantiatedFromMember() const {\n    const auto *First =\n        cast<ClassTemplatePartialSpecializationDecl>(getFirstDecl());\n    return First->InstantiatedFromMember.getPointer();\n  }\n  ClassTemplatePartialSpecializationDecl *\n  getInstantiatedFromMemberTemplate() const {\n    return getInstantiatedFromMember();\n  }\n\n  void setInstantiatedFromMember(\n                          ClassTemplatePartialSpecializationDecl *PartialSpec) {\n    auto *First = cast<ClassTemplatePartialSpecializationDecl>(getFirstDecl());\n    First->InstantiatedFromMember.setPointer(PartialSpec);\n  }\n\n  /// Determines whether this class template partial specialization\n  /// template was a specialization of a member partial specialization.\n  ///\n  /// In the following example, the member template partial specialization\n  /// \\c X<int>::Inner<T*> is a member specialization.\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   template<typename U> struct Inner;\n  ///   template<typename U> struct Inner<U*>;\n  /// };\n  ///\n  /// template<> template<typename T>\n  /// struct X<int>::Inner<T*> { /* ... */ };\n  /// \\endcode\n  bool isMemberSpecialization() {\n    const auto *First =\n        cast<ClassTemplatePartialSpecializationDecl>(getFirstDecl());\n    return First->InstantiatedFromMember.getInt();\n  }\n\n  /// Note that this member template is a specialization.\n  void setMemberSpecialization() {\n    auto *First = cast<ClassTemplatePartialSpecializationDecl>(getFirstDecl());\n    assert(First->InstantiatedFromMember.getPointer() &&\n           \"Only member templates can be member template specializations\");\n    return First->InstantiatedFromMember.setInt(true);\n  }\n\n  /// Retrieves the injected specialization type for this partial\n  /// specialization.  This is not the same as the type-decl-type for\n  /// this partial specialization, which is an InjectedClassNameType.\n  QualType getInjectedSpecializationType() const {\n    assert(getTypeForDecl() && \"partial specialization has no type set!\");\n    return cast<InjectedClassNameType>(getTypeForDecl())\n             ->getInjectedSpecializationType();\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    Profile(ID, getTemplateArgs().asArray(), getTemplateParameters(),\n            getASTContext());\n  }\n\n  static void\n  Profile(llvm::FoldingSetNodeID &ID, ArrayRef<TemplateArgument> TemplateArgs,\n          TemplateParameterList *TPL, ASTContext &Context);\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K == ClassTemplatePartialSpecialization;\n  }\n};\n\n/// Declaration of a class template.\nclass ClassTemplateDecl : public RedeclarableTemplateDecl {\nprotected:\n  /// Data that is common to all of the declarations of a given\n  /// class template.\n  struct Common : CommonBase {\n    /// The class template specializations for this class\n    /// template, including explicit specializations and instantiations.\n    llvm::FoldingSetVector<ClassTemplateSpecializationDecl> Specializations;\n\n    /// The class template partial specializations for this class\n    /// template.\n    llvm::FoldingSetVector<ClassTemplatePartialSpecializationDecl>\n      PartialSpecializations;\n\n    /// The injected-class-name type for this class template.\n    QualType InjectedClassNameType;\n\n    Common() = default;\n  };\n\n  /// Retrieve the set of specializations of this class template.\n  llvm::FoldingSetVector<ClassTemplateSpecializationDecl> &\n  getSpecializations() const;\n\n  /// Retrieve the set of partial specializations of this class\n  /// template.\n  llvm::FoldingSetVector<ClassTemplatePartialSpecializationDecl> &\n  getPartialSpecializations() const;\n\n  ClassTemplateDecl(ASTContext &C, DeclContext *DC, SourceLocation L,\n                    DeclarationName Name, TemplateParameterList *Params,\n                    NamedDecl *Decl)\n      : RedeclarableTemplateDecl(ClassTemplate, C, DC, L, Name, Params, Decl) {}\n\n  CommonBase *newCommon(ASTContext &C) const override;\n\n  Common *getCommonPtr() const {\n    return static_cast<Common *>(RedeclarableTemplateDecl::getCommonPtr());\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Load any lazily-loaded specializations from the external source.\n  void LoadLazySpecializations() const;\n\n  /// Get the underlying class declarations of the template.\n  CXXRecordDecl *getTemplatedDecl() const {\n    return static_cast<CXXRecordDecl *>(TemplatedDecl);\n  }\n\n  /// Returns whether this template declaration defines the primary\n  /// class pattern.\n  bool isThisDeclarationADefinition() const {\n    return getTemplatedDecl()->isThisDeclarationADefinition();\n  }\n\n  /// \\brief Create a class template node.\n  static ClassTemplateDecl *Create(ASTContext &C, DeclContext *DC,\n                                   SourceLocation L,\n                                   DeclarationName Name,\n                                   TemplateParameterList *Params,\n                                   NamedDecl *Decl);\n\n  /// Create an empty class template node.\n  static ClassTemplateDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// Return the specialization with the provided arguments if it exists,\n  /// otherwise return the insertion point.\n  ClassTemplateSpecializationDecl *\n  findSpecialization(ArrayRef<TemplateArgument> Args, void *&InsertPos);\n\n  /// Insert the specified specialization knowing that it is not already\n  /// in. InsertPos must be obtained from findSpecialization.\n  void AddSpecialization(ClassTemplateSpecializationDecl *D, void *InsertPos);\n\n  ClassTemplateDecl *getCanonicalDecl() override {\n    return cast<ClassTemplateDecl>(\n             RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n  const ClassTemplateDecl *getCanonicalDecl() const {\n    return cast<ClassTemplateDecl>(\n             RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n\n  /// Retrieve the previous declaration of this class template, or\n  /// nullptr if no such declaration exists.\n  ClassTemplateDecl *getPreviousDecl() {\n    return cast_or_null<ClassTemplateDecl>(\n             static_cast<RedeclarableTemplateDecl *>(this)->getPreviousDecl());\n  }\n  const ClassTemplateDecl *getPreviousDecl() const {\n    return cast_or_null<ClassTemplateDecl>(\n             static_cast<const RedeclarableTemplateDecl *>(\n               this)->getPreviousDecl());\n  }\n\n  ClassTemplateDecl *getMostRecentDecl() {\n    return cast<ClassTemplateDecl>(\n        static_cast<RedeclarableTemplateDecl *>(this)->getMostRecentDecl());\n  }\n  const ClassTemplateDecl *getMostRecentDecl() const {\n    return const_cast<ClassTemplateDecl*>(this)->getMostRecentDecl();\n  }\n\n  ClassTemplateDecl *getInstantiatedFromMemberTemplate() const {\n    return cast_or_null<ClassTemplateDecl>(\n             RedeclarableTemplateDecl::getInstantiatedFromMemberTemplate());\n  }\n\n  /// Return the partial specialization with the provided arguments if it\n  /// exists, otherwise return the insertion point.\n  ClassTemplatePartialSpecializationDecl *\n  findPartialSpecialization(ArrayRef<TemplateArgument> Args,\n                            TemplateParameterList *TPL, void *&InsertPos);\n\n  /// Insert the specified partial specialization knowing that it is not\n  /// already in. InsertPos must be obtained from findPartialSpecialization.\n  void AddPartialSpecialization(ClassTemplatePartialSpecializationDecl *D,\n                                void *InsertPos);\n\n  /// Retrieve the partial specializations as an ordered list.\n  void getPartialSpecializations(\n      SmallVectorImpl<ClassTemplatePartialSpecializationDecl *> &PS) const;\n\n  /// Find a class template partial specialization with the given\n  /// type T.\n  ///\n  /// \\param T a dependent type that names a specialization of this class\n  /// template.\n  ///\n  /// \\returns the class template partial specialization that exactly matches\n  /// the type \\p T, or nullptr if no such partial specialization exists.\n  ClassTemplatePartialSpecializationDecl *findPartialSpecialization(QualType T);\n\n  /// Find a class template partial specialization which was instantiated\n  /// from the given member partial specialization.\n  ///\n  /// \\param D a member class template partial specialization.\n  ///\n  /// \\returns the class template partial specialization which was instantiated\n  /// from the given member partial specialization, or nullptr if no such\n  /// partial specialization exists.\n  ClassTemplatePartialSpecializationDecl *\n  findPartialSpecInstantiatedFromMember(\n                                     ClassTemplatePartialSpecializationDecl *D);\n\n  /// Retrieve the template specialization type of the\n  /// injected-class-name for this class template.\n  ///\n  /// The injected-class-name for a class template \\c X is \\c\n  /// X<template-args>, where \\c template-args is formed from the\n  /// template arguments that correspond to the template parameters of\n  /// \\c X. For example:\n  ///\n  /// \\code\n  /// template<typename T, int N>\n  /// struct array {\n  ///   typedef array this_type; // \"array\" is equivalent to \"array<T, N>\"\n  /// };\n  /// \\endcode\n  QualType getInjectedClassNameSpecialization();\n\n  using spec_iterator = SpecIterator<ClassTemplateSpecializationDecl>;\n  using spec_range = llvm::iterator_range<spec_iterator>;\n\n  spec_range specializations() const {\n    return spec_range(spec_begin(), spec_end());\n  }\n\n  spec_iterator spec_begin() const {\n    return makeSpecIterator(getSpecializations(), false);\n  }\n\n  spec_iterator spec_end() const {\n    return makeSpecIterator(getSpecializations(), true);\n  }\n\n  // Implement isa/cast/dyncast support\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ClassTemplate; }\n};\n\n/// Declaration of a friend template.\n///\n/// For example:\n/// \\code\n/// template \\<typename T> class A {\n///   friend class MyVector<T>; // not a friend template\n///   template \\<typename U> friend class B; // not a friend template\n///   template \\<typename U> friend class Foo<T>::Nested; // friend template\n/// };\n/// \\endcode\n///\n/// \\note This class is not currently in use.  All of the above\n/// will yield a FriendDecl, not a FriendTemplateDecl.\nclass FriendTemplateDecl : public Decl {\n  virtual void anchor();\n\npublic:\n  using FriendUnion = llvm::PointerUnion<NamedDecl *,TypeSourceInfo *>;\n\nprivate:\n  // The number of template parameters;  always non-zero.\n  unsigned NumParams = 0;\n\n  // The parameter list.\n  TemplateParameterList **Params = nullptr;\n\n  // The declaration that's a friend of this class.\n  FriendUnion Friend;\n\n  // Location of the 'friend' specifier.\n  SourceLocation FriendLoc;\n\n  FriendTemplateDecl(DeclContext *DC, SourceLocation Loc,\n                     MutableArrayRef<TemplateParameterList *> Params,\n                     FriendUnion Friend, SourceLocation FriendLoc)\n      : Decl(Decl::FriendTemplate, DC, Loc), NumParams(Params.size()),\n        Params(Params.data()), Friend(Friend), FriendLoc(FriendLoc) {}\n\n  FriendTemplateDecl(EmptyShell Empty) : Decl(Decl::FriendTemplate, Empty) {}\n\npublic:\n  friend class ASTDeclReader;\n\n  static FriendTemplateDecl *\n  Create(ASTContext &Context, DeclContext *DC, SourceLocation Loc,\n         MutableArrayRef<TemplateParameterList *> Params, FriendUnion Friend,\n         SourceLocation FriendLoc);\n\n  static FriendTemplateDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// If this friend declaration names a templated type (or\n  /// a dependent member type of a templated type), return that\n  /// type;  otherwise return null.\n  TypeSourceInfo *getFriendType() const {\n    return Friend.dyn_cast<TypeSourceInfo*>();\n  }\n\n  /// If this friend declaration names a templated function (or\n  /// a member function of a templated type), return that type;\n  /// otherwise return null.\n  NamedDecl *getFriendDecl() const {\n    return Friend.dyn_cast<NamedDecl*>();\n  }\n\n  /// Retrieves the location of the 'friend' keyword.\n  SourceLocation getFriendLoc() const {\n    return FriendLoc;\n  }\n\n  TemplateParameterList *getTemplateParameterList(unsigned i) const {\n    assert(i <= NumParams);\n    return Params[i];\n  }\n\n  unsigned getNumTemplateParameters() const {\n    return NumParams;\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Decl::FriendTemplate; }\n};\n\n/// Declaration of an alias template.\n///\n/// For example:\n/// \\code\n/// template \\<typename T> using V = std::map<T*, int, MyCompare<T>>;\n/// \\endcode\nclass TypeAliasTemplateDecl : public RedeclarableTemplateDecl {\nprotected:\n  using Common = CommonBase;\n\n  TypeAliasTemplateDecl(ASTContext &C, DeclContext *DC, SourceLocation L,\n                        DeclarationName Name, TemplateParameterList *Params,\n                        NamedDecl *Decl)\n      : RedeclarableTemplateDecl(TypeAliasTemplate, C, DC, L, Name, Params,\n                                 Decl) {}\n\n  CommonBase *newCommon(ASTContext &C) const override;\n\n  Common *getCommonPtr() {\n    return static_cast<Common *>(RedeclarableTemplateDecl::getCommonPtr());\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Get the underlying function declaration of the template.\n  TypeAliasDecl *getTemplatedDecl() const {\n    return static_cast<TypeAliasDecl *>(TemplatedDecl);\n  }\n\n\n  TypeAliasTemplateDecl *getCanonicalDecl() override {\n    return cast<TypeAliasTemplateDecl>(\n             RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n  const TypeAliasTemplateDecl *getCanonicalDecl() const {\n    return cast<TypeAliasTemplateDecl>(\n             RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n\n  /// Retrieve the previous declaration of this function template, or\n  /// nullptr if no such declaration exists.\n  TypeAliasTemplateDecl *getPreviousDecl() {\n    return cast_or_null<TypeAliasTemplateDecl>(\n             static_cast<RedeclarableTemplateDecl *>(this)->getPreviousDecl());\n  }\n  const TypeAliasTemplateDecl *getPreviousDecl() const {\n    return cast_or_null<TypeAliasTemplateDecl>(\n             static_cast<const RedeclarableTemplateDecl *>(\n               this)->getPreviousDecl());\n  }\n\n  TypeAliasTemplateDecl *getInstantiatedFromMemberTemplate() const {\n    return cast_or_null<TypeAliasTemplateDecl>(\n             RedeclarableTemplateDecl::getInstantiatedFromMemberTemplate());\n  }\n\n  /// Create a function template node.\n  static TypeAliasTemplateDecl *Create(ASTContext &C, DeclContext *DC,\n                                       SourceLocation L,\n                                       DeclarationName Name,\n                                       TemplateParameterList *Params,\n                                       NamedDecl *Decl);\n\n  /// Create an empty alias template node.\n  static TypeAliasTemplateDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  // Implement isa/cast/dyncast support\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == TypeAliasTemplate; }\n};\n\n/// Declaration of a function specialization at template class scope.\n///\n/// For example:\n/// \\code\n/// template <class T>\n/// class A {\n///    template <class U> void foo(U a) { }\n///    template<> void foo(int a) { }\n/// }\n/// \\endcode\n///\n/// \"template<> foo(int a)\" will be saved in Specialization as a normal\n/// CXXMethodDecl. Then during an instantiation of class A, it will be\n/// transformed into an actual function specialization.\n///\n/// FIXME: This is redundant; we could store the same information directly on\n/// the CXXMethodDecl as a DependentFunctionTemplateSpecializationInfo.\nclass ClassScopeFunctionSpecializationDecl : public Decl {\n  CXXMethodDecl *Specialization;\n  const ASTTemplateArgumentListInfo *TemplateArgs;\n\n  ClassScopeFunctionSpecializationDecl(\n      DeclContext *DC, SourceLocation Loc, CXXMethodDecl *FD,\n      const ASTTemplateArgumentListInfo *TemplArgs)\n      : Decl(Decl::ClassScopeFunctionSpecialization, DC, Loc),\n        Specialization(FD), TemplateArgs(TemplArgs) {}\n\n  ClassScopeFunctionSpecializationDecl(EmptyShell Empty)\n      : Decl(Decl::ClassScopeFunctionSpecialization, Empty) {}\n\n  virtual void anchor();\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  CXXMethodDecl *getSpecialization() const { return Specialization; }\n  bool hasExplicitTemplateArgs() const { return TemplateArgs; }\n  const ASTTemplateArgumentListInfo *getTemplateArgsAsWritten() const {\n    return TemplateArgs;\n  }\n\n  static ClassScopeFunctionSpecializationDecl *\n  Create(ASTContext &C, DeclContext *DC, SourceLocation Loc, CXXMethodDecl *FD,\n         bool HasExplicitTemplateArgs,\n         const TemplateArgumentListInfo &TemplateArgs) {\n    return new (C, DC) ClassScopeFunctionSpecializationDecl(\n        DC, Loc, FD,\n        HasExplicitTemplateArgs\n            ? ASTTemplateArgumentListInfo::Create(C, TemplateArgs)\n            : nullptr);\n  }\n\n  static ClassScopeFunctionSpecializationDecl *\n  CreateDeserialized(ASTContext &Context, unsigned ID);\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K == Decl::ClassScopeFunctionSpecialization;\n  }\n};\n\n/// Represents a variable template specialization, which refers to\n/// a variable template with a given set of template arguments.\n///\n/// Variable template specializations represent both explicit\n/// specializations of variable templates, as in the example below, and\n/// implicit instantiations of variable templates.\n///\n/// \\code\n/// template<typename T> constexpr T pi = T(3.1415926535897932385);\n///\n/// template<>\n/// constexpr float pi<float>; // variable template specialization pi<float>\n/// \\endcode\nclass VarTemplateSpecializationDecl : public VarDecl,\n                                      public llvm::FoldingSetNode {\n\n  /// Structure that stores information about a variable template\n  /// specialization that was instantiated from a variable template partial\n  /// specialization.\n  struct SpecializedPartialSpecialization {\n    /// The variable template partial specialization from which this\n    /// variable template specialization was instantiated.\n    VarTemplatePartialSpecializationDecl *PartialSpecialization;\n\n    /// The template argument list deduced for the variable template\n    /// partial specialization itself.\n    const TemplateArgumentList *TemplateArgs;\n  };\n\n  /// The template that this specialization specializes.\n  llvm::PointerUnion<VarTemplateDecl *, SpecializedPartialSpecialization *>\n  SpecializedTemplate;\n\n  /// Further info for explicit template specialization/instantiation.\n  struct ExplicitSpecializationInfo {\n    /// The type-as-written.\n    TypeSourceInfo *TypeAsWritten = nullptr;\n\n    /// The location of the extern keyword.\n    SourceLocation ExternLoc;\n\n    /// The location of the template keyword.\n    SourceLocation TemplateKeywordLoc;\n\n    ExplicitSpecializationInfo() = default;\n  };\n\n  /// Further info for explicit template specialization/instantiation.\n  /// Does not apply to implicit specializations.\n  ExplicitSpecializationInfo *ExplicitInfo = nullptr;\n\n  /// The template arguments used to describe this specialization.\n  const TemplateArgumentList *TemplateArgs;\n  TemplateArgumentListInfo TemplateArgsInfo;\n\n  /// The point where this template was instantiated (if any).\n  SourceLocation PointOfInstantiation;\n\n  /// The kind of specialization this declaration refers to.\n  /// Really a value of type TemplateSpecializationKind.\n  unsigned SpecializationKind : 3;\n\n  /// Whether this declaration is a complete definition of the\n  /// variable template specialization. We can't otherwise tell apart\n  /// an instantiated declaration from an instantiated definition with\n  /// no initializer.\n  unsigned IsCompleteDefinition : 1;\n\nprotected:\n  VarTemplateSpecializationDecl(Kind DK, ASTContext &Context, DeclContext *DC,\n                                SourceLocation StartLoc, SourceLocation IdLoc,\n                                VarTemplateDecl *SpecializedTemplate,\n                                QualType T, TypeSourceInfo *TInfo,\n                                StorageClass S,\n                                ArrayRef<TemplateArgument> Args);\n\n  explicit VarTemplateSpecializationDecl(Kind DK, ASTContext &Context);\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend class VarDecl;\n\n  static VarTemplateSpecializationDecl *\n  Create(ASTContext &Context, DeclContext *DC, SourceLocation StartLoc,\n         SourceLocation IdLoc, VarTemplateDecl *SpecializedTemplate, QualType T,\n         TypeSourceInfo *TInfo, StorageClass S,\n         ArrayRef<TemplateArgument> Args);\n  static VarTemplateSpecializationDecl *CreateDeserialized(ASTContext &C,\n                                                           unsigned ID);\n\n  void getNameForDiagnostic(raw_ostream &OS, const PrintingPolicy &Policy,\n                            bool Qualified) const override;\n\n  VarTemplateSpecializationDecl *getMostRecentDecl() {\n    VarDecl *Recent = static_cast<VarDecl *>(this)->getMostRecentDecl();\n    return cast<VarTemplateSpecializationDecl>(Recent);\n  }\n\n  /// Retrieve the template that this specialization specializes.\n  VarTemplateDecl *getSpecializedTemplate() const;\n\n  /// Retrieve the template arguments of the variable template\n  /// specialization.\n  const TemplateArgumentList &getTemplateArgs() const { return *TemplateArgs; }\n\n  // TODO: Always set this when creating the new specialization?\n  void setTemplateArgsInfo(const TemplateArgumentListInfo &ArgsInfo);\n\n  const TemplateArgumentListInfo &getTemplateArgsInfo() const {\n    return TemplateArgsInfo;\n  }\n\n  /// Determine the kind of specialization that this\n  /// declaration represents.\n  TemplateSpecializationKind getSpecializationKind() const {\n    return static_cast<TemplateSpecializationKind>(SpecializationKind);\n  }\n\n  bool isExplicitSpecialization() const {\n    return getSpecializationKind() == TSK_ExplicitSpecialization;\n  }\n\n  bool isClassScopeExplicitSpecialization() const {\n    return isExplicitSpecialization() &&\n           isa<CXXRecordDecl>(getLexicalDeclContext());\n  }\n\n  /// True if this declaration is an explicit specialization,\n  /// explicit instantiation declaration, or explicit instantiation\n  /// definition.\n  bool isExplicitInstantiationOrSpecialization() const {\n    return isTemplateExplicitInstantiationOrSpecialization(\n        getTemplateSpecializationKind());\n  }\n\n  void setSpecializationKind(TemplateSpecializationKind TSK) {\n    SpecializationKind = TSK;\n  }\n\n  /// Get the point of instantiation (if any), or null if none.\n  SourceLocation getPointOfInstantiation() const {\n    return PointOfInstantiation;\n  }\n\n  void setPointOfInstantiation(SourceLocation Loc) {\n    assert(Loc.isValid() && \"point of instantiation must be valid!\");\n    PointOfInstantiation = Loc;\n  }\n\n  void setCompleteDefinition() { IsCompleteDefinition = true; }\n\n  /// If this variable template specialization is an instantiation of\n  /// a template (rather than an explicit specialization), return the\n  /// variable template or variable template partial specialization from which\n  /// it was instantiated.\n  llvm::PointerUnion<VarTemplateDecl *, VarTemplatePartialSpecializationDecl *>\n  getInstantiatedFrom() const {\n    if (!isTemplateInstantiation(getSpecializationKind()))\n      return llvm::PointerUnion<VarTemplateDecl *,\n                                VarTemplatePartialSpecializationDecl *>();\n\n    return getSpecializedTemplateOrPartial();\n  }\n\n  /// Retrieve the variable template or variable template partial\n  /// specialization which was specialized by this.\n  llvm::PointerUnion<VarTemplateDecl *, VarTemplatePartialSpecializationDecl *>\n  getSpecializedTemplateOrPartial() const {\n    if (const auto *PartialSpec =\n            SpecializedTemplate.dyn_cast<SpecializedPartialSpecialization *>())\n      return PartialSpec->PartialSpecialization;\n\n    return SpecializedTemplate.get<VarTemplateDecl *>();\n  }\n\n  /// Retrieve the set of template arguments that should be used\n  /// to instantiate the initializer of the variable template or variable\n  /// template partial specialization from which this variable template\n  /// specialization was instantiated.\n  ///\n  /// \\returns For a variable template specialization instantiated from the\n  /// primary template, this function will return the same template arguments\n  /// as getTemplateArgs(). For a variable template specialization instantiated\n  /// from a variable template partial specialization, this function will the\n  /// return deduced template arguments for the variable template partial\n  /// specialization itself.\n  const TemplateArgumentList &getTemplateInstantiationArgs() const {\n    if (const auto *PartialSpec =\n            SpecializedTemplate.dyn_cast<SpecializedPartialSpecialization *>())\n      return *PartialSpec->TemplateArgs;\n\n    return getTemplateArgs();\n  }\n\n  /// Note that this variable template specialization is actually an\n  /// instantiation of the given variable template partial specialization whose\n  /// template arguments have been deduced.\n  void setInstantiationOf(VarTemplatePartialSpecializationDecl *PartialSpec,\n                          const TemplateArgumentList *TemplateArgs) {\n    assert(!SpecializedTemplate.is<SpecializedPartialSpecialization *>() &&\n           \"Already set to a variable template partial specialization!\");\n    auto *PS = new (getASTContext()) SpecializedPartialSpecialization();\n    PS->PartialSpecialization = PartialSpec;\n    PS->TemplateArgs = TemplateArgs;\n    SpecializedTemplate = PS;\n  }\n\n  /// Note that this variable template specialization is an instantiation\n  /// of the given variable template.\n  void setInstantiationOf(VarTemplateDecl *TemplDecl) {\n    assert(!SpecializedTemplate.is<SpecializedPartialSpecialization *>() &&\n           \"Previously set to a variable template partial specialization!\");\n    SpecializedTemplate = TemplDecl;\n  }\n\n  /// Sets the type of this specialization as it was written by\n  /// the user.\n  void setTypeAsWritten(TypeSourceInfo *T) {\n    if (!ExplicitInfo)\n      ExplicitInfo = new (getASTContext()) ExplicitSpecializationInfo;\n    ExplicitInfo->TypeAsWritten = T;\n  }\n\n  /// Gets the type of this specialization as it was written by\n  /// the user, if it was so written.\n  TypeSourceInfo *getTypeAsWritten() const {\n    return ExplicitInfo ? ExplicitInfo->TypeAsWritten : nullptr;\n  }\n\n  /// Gets the location of the extern keyword, if present.\n  SourceLocation getExternLoc() const {\n    return ExplicitInfo ? ExplicitInfo->ExternLoc : SourceLocation();\n  }\n\n  /// Sets the location of the extern keyword.\n  void setExternLoc(SourceLocation Loc) {\n    if (!ExplicitInfo)\n      ExplicitInfo = new (getASTContext()) ExplicitSpecializationInfo;\n    ExplicitInfo->ExternLoc = Loc;\n  }\n\n  /// Sets the location of the template keyword.\n  void setTemplateKeywordLoc(SourceLocation Loc) {\n    if (!ExplicitInfo)\n      ExplicitInfo = new (getASTContext()) ExplicitSpecializationInfo;\n    ExplicitInfo->TemplateKeywordLoc = Loc;\n  }\n\n  /// Gets the location of the template keyword, if present.\n  SourceLocation getTemplateKeywordLoc() const {\n    return ExplicitInfo ? ExplicitInfo->TemplateKeywordLoc : SourceLocation();\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    Profile(ID, TemplateArgs->asArray(), getASTContext());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      ArrayRef<TemplateArgument> TemplateArgs,\n                      ASTContext &Context) {\n    ID.AddInteger(TemplateArgs.size());\n    for (const TemplateArgument &TemplateArg : TemplateArgs)\n      TemplateArg.Profile(ID, Context);\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K >= firstVarTemplateSpecialization &&\n           K <= lastVarTemplateSpecialization;\n  }\n};\n\nclass VarTemplatePartialSpecializationDecl\n    : public VarTemplateSpecializationDecl {\n  /// The list of template parameters\n  TemplateParameterList *TemplateParams = nullptr;\n\n  /// The source info for the template arguments as written.\n  /// FIXME: redundant with TypeAsWritten?\n  const ASTTemplateArgumentListInfo *ArgsAsWritten = nullptr;\n\n  /// The variable template partial specialization from which this\n  /// variable template partial specialization was instantiated.\n  ///\n  /// The boolean value will be true to indicate that this variable template\n  /// partial specialization was specialized at this level.\n  llvm::PointerIntPair<VarTemplatePartialSpecializationDecl *, 1, bool>\n  InstantiatedFromMember;\n\n  VarTemplatePartialSpecializationDecl(\n      ASTContext &Context, DeclContext *DC, SourceLocation StartLoc,\n      SourceLocation IdLoc, TemplateParameterList *Params,\n      VarTemplateDecl *SpecializedTemplate, QualType T, TypeSourceInfo *TInfo,\n      StorageClass S, ArrayRef<TemplateArgument> Args,\n      const ASTTemplateArgumentListInfo *ArgInfos);\n\n  VarTemplatePartialSpecializationDecl(ASTContext &Context)\n      : VarTemplateSpecializationDecl(VarTemplatePartialSpecialization,\n                                      Context),\n        InstantiatedFromMember(nullptr, false) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static VarTemplatePartialSpecializationDecl *\n  Create(ASTContext &Context, DeclContext *DC, SourceLocation StartLoc,\n         SourceLocation IdLoc, TemplateParameterList *Params,\n         VarTemplateDecl *SpecializedTemplate, QualType T,\n         TypeSourceInfo *TInfo, StorageClass S, ArrayRef<TemplateArgument> Args,\n         const TemplateArgumentListInfo &ArgInfos);\n\n  static VarTemplatePartialSpecializationDecl *CreateDeserialized(ASTContext &C,\n                                                                  unsigned ID);\n\n  VarTemplatePartialSpecializationDecl *getMostRecentDecl() {\n    return cast<VarTemplatePartialSpecializationDecl>(\n             static_cast<VarTemplateSpecializationDecl *>(\n               this)->getMostRecentDecl());\n  }\n\n  /// Get the list of template parameters\n  TemplateParameterList *getTemplateParameters() const {\n    return TemplateParams;\n  }\n\n  /// Get the template arguments as written.\n  const ASTTemplateArgumentListInfo *getTemplateArgsAsWritten() const {\n    return ArgsAsWritten;\n  }\n\n  /// \\brief All associated constraints of this partial specialization,\n  /// including the requires clause and any constraints derived from\n  /// constrained-parameters.\n  ///\n  /// The constraints in the resulting list are to be treated as if in a\n  /// conjunction (\"and\").\n  void getAssociatedConstraints(llvm::SmallVectorImpl<const Expr *> &AC) const {\n    TemplateParams->getAssociatedConstraints(AC);\n  }\n\n  bool hasAssociatedConstraints() const {\n    return TemplateParams->hasAssociatedConstraints();\n  }\n\n  /// \\brief Retrieve the member variable template partial specialization from\n  /// which this particular variable template partial specialization was\n  /// instantiated.\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct Outer {\n  ///   template<typename U> U Inner;\n  ///   template<typename U> U* Inner<U*> = (U*)(0); // #1\n  /// };\n  ///\n  /// template int* Outer<float>::Inner<int*>;\n  /// \\endcode\n  ///\n  /// In this example, the instantiation of \\c Outer<float>::Inner<int*> will\n  /// end up instantiating the partial specialization\n  /// \\c Outer<float>::Inner<U*>, which itself was instantiated from the\n  /// variable template partial specialization \\c Outer<T>::Inner<U*>. Given\n  /// \\c Outer<float>::Inner<U*>, this function would return\n  /// \\c Outer<T>::Inner<U*>.\n  VarTemplatePartialSpecializationDecl *getInstantiatedFromMember() const {\n    const auto *First =\n        cast<VarTemplatePartialSpecializationDecl>(getFirstDecl());\n    return First->InstantiatedFromMember.getPointer();\n  }\n\n  void\n  setInstantiatedFromMember(VarTemplatePartialSpecializationDecl *PartialSpec) {\n    auto *First = cast<VarTemplatePartialSpecializationDecl>(getFirstDecl());\n    First->InstantiatedFromMember.setPointer(PartialSpec);\n  }\n\n  /// Determines whether this variable template partial specialization\n  /// was a specialization of a member partial specialization.\n  ///\n  /// In the following example, the member template partial specialization\n  /// \\c X<int>::Inner<T*> is a member specialization.\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   template<typename U> U Inner;\n  ///   template<typename U> U* Inner<U*> = (U*)(0);\n  /// };\n  ///\n  /// template<> template<typename T>\n  /// U* X<int>::Inner<T*> = (T*)(0) + 1;\n  /// \\endcode\n  bool isMemberSpecialization() {\n    const auto *First =\n        cast<VarTemplatePartialSpecializationDecl>(getFirstDecl());\n    return First->InstantiatedFromMember.getInt();\n  }\n\n  /// Note that this member template is a specialization.\n  void setMemberSpecialization() {\n    auto *First = cast<VarTemplatePartialSpecializationDecl>(getFirstDecl());\n    assert(First->InstantiatedFromMember.getPointer() &&\n           \"Only member templates can be member template specializations\");\n    return First->InstantiatedFromMember.setInt(true);\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    Profile(ID, getTemplateArgs().asArray(), getTemplateParameters(),\n            getASTContext());\n  }\n\n  static void\n  Profile(llvm::FoldingSetNodeID &ID, ArrayRef<TemplateArgument> TemplateArgs,\n          TemplateParameterList *TPL, ASTContext &Context);\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K == VarTemplatePartialSpecialization;\n  }\n};\n\n/// Declaration of a variable template.\nclass VarTemplateDecl : public RedeclarableTemplateDecl {\nprotected:\n  /// Data that is common to all of the declarations of a given\n  /// variable template.\n  struct Common : CommonBase {\n    /// The variable template specializations for this variable\n    /// template, including explicit specializations and instantiations.\n    llvm::FoldingSetVector<VarTemplateSpecializationDecl> Specializations;\n\n    /// The variable template partial specializations for this variable\n    /// template.\n    llvm::FoldingSetVector<VarTemplatePartialSpecializationDecl>\n    PartialSpecializations;\n\n    Common() = default;\n  };\n\n  /// Retrieve the set of specializations of this variable template.\n  llvm::FoldingSetVector<VarTemplateSpecializationDecl> &\n  getSpecializations() const;\n\n  /// Retrieve the set of partial specializations of this class\n  /// template.\n  llvm::FoldingSetVector<VarTemplatePartialSpecializationDecl> &\n  getPartialSpecializations() const;\n\n  VarTemplateDecl(ASTContext &C, DeclContext *DC, SourceLocation L,\n                  DeclarationName Name, TemplateParameterList *Params,\n                  NamedDecl *Decl)\n      : RedeclarableTemplateDecl(VarTemplate, C, DC, L, Name, Params, Decl) {}\n\n  CommonBase *newCommon(ASTContext &C) const override;\n\n  Common *getCommonPtr() const {\n    return static_cast<Common *>(RedeclarableTemplateDecl::getCommonPtr());\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Load any lazily-loaded specializations from the external source.\n  void LoadLazySpecializations() const;\n\n  /// Get the underlying variable declarations of the template.\n  VarDecl *getTemplatedDecl() const {\n    return static_cast<VarDecl *>(TemplatedDecl);\n  }\n\n  /// Returns whether this template declaration defines the primary\n  /// variable pattern.\n  bool isThisDeclarationADefinition() const {\n    return getTemplatedDecl()->isThisDeclarationADefinition();\n  }\n\n  VarTemplateDecl *getDefinition();\n\n  /// Create a variable template node.\n  static VarTemplateDecl *Create(ASTContext &C, DeclContext *DC,\n                                 SourceLocation L, DeclarationName Name,\n                                 TemplateParameterList *Params,\n                                 VarDecl *Decl);\n\n  /// Create an empty variable template node.\n  static VarTemplateDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// Return the specialization with the provided arguments if it exists,\n  /// otherwise return the insertion point.\n  VarTemplateSpecializationDecl *\n  findSpecialization(ArrayRef<TemplateArgument> Args, void *&InsertPos);\n\n  /// Insert the specified specialization knowing that it is not already\n  /// in. InsertPos must be obtained from findSpecialization.\n  void AddSpecialization(VarTemplateSpecializationDecl *D, void *InsertPos);\n\n  VarTemplateDecl *getCanonicalDecl() override {\n    return cast<VarTemplateDecl>(RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n  const VarTemplateDecl *getCanonicalDecl() const {\n    return cast<VarTemplateDecl>(RedeclarableTemplateDecl::getCanonicalDecl());\n  }\n\n  /// Retrieve the previous declaration of this variable template, or\n  /// nullptr if no such declaration exists.\n  VarTemplateDecl *getPreviousDecl() {\n    return cast_or_null<VarTemplateDecl>(\n        static_cast<RedeclarableTemplateDecl *>(this)->getPreviousDecl());\n  }\n  const VarTemplateDecl *getPreviousDecl() const {\n    return cast_or_null<VarTemplateDecl>(\n            static_cast<const RedeclarableTemplateDecl *>(\n              this)->getPreviousDecl());\n  }\n\n  VarTemplateDecl *getMostRecentDecl() {\n    return cast<VarTemplateDecl>(\n        static_cast<RedeclarableTemplateDecl *>(this)->getMostRecentDecl());\n  }\n  const VarTemplateDecl *getMostRecentDecl() const {\n    return const_cast<VarTemplateDecl *>(this)->getMostRecentDecl();\n  }\n\n  VarTemplateDecl *getInstantiatedFromMemberTemplate() const {\n    return cast_or_null<VarTemplateDecl>(\n        RedeclarableTemplateDecl::getInstantiatedFromMemberTemplate());\n  }\n\n  /// Return the partial specialization with the provided arguments if it\n  /// exists, otherwise return the insertion point.\n  VarTemplatePartialSpecializationDecl *\n  findPartialSpecialization(ArrayRef<TemplateArgument> Args,\n                            TemplateParameterList *TPL, void *&InsertPos);\n\n  /// Insert the specified partial specialization knowing that it is not\n  /// already in. InsertPos must be obtained from findPartialSpecialization.\n  void AddPartialSpecialization(VarTemplatePartialSpecializationDecl *D,\n                                void *InsertPos);\n\n  /// Retrieve the partial specializations as an ordered list.\n  void getPartialSpecializations(\n      SmallVectorImpl<VarTemplatePartialSpecializationDecl *> &PS) const;\n\n  /// Find a variable template partial specialization which was\n  /// instantiated\n  /// from the given member partial specialization.\n  ///\n  /// \\param D a member variable template partial specialization.\n  ///\n  /// \\returns the variable template partial specialization which was\n  /// instantiated\n  /// from the given member partial specialization, or nullptr if no such\n  /// partial specialization exists.\n  VarTemplatePartialSpecializationDecl *findPartialSpecInstantiatedFromMember(\n      VarTemplatePartialSpecializationDecl *D);\n\n  using spec_iterator = SpecIterator<VarTemplateSpecializationDecl>;\n  using spec_range = llvm::iterator_range<spec_iterator>;\n\n  spec_range specializations() const {\n    return spec_range(spec_begin(), spec_end());\n  }\n\n  spec_iterator spec_begin() const {\n    return makeSpecIterator(getSpecializations(), false);\n  }\n\n  spec_iterator spec_end() const {\n    return makeSpecIterator(getSpecializations(), true);\n  }\n\n  // Implement isa/cast/dyncast support\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == VarTemplate; }\n};\n\n/// Declaration of a C++2a concept.\nclass ConceptDecl : public TemplateDecl, public Mergeable<ConceptDecl> {\nprotected:\n  Expr *ConstraintExpr;\n\n  ConceptDecl(DeclContext *DC, SourceLocation L, DeclarationName Name,\n              TemplateParameterList *Params, Expr *ConstraintExpr)\n      : TemplateDecl(Concept, DC, L, Name, Params),\n        ConstraintExpr(ConstraintExpr) {};\npublic:\n  static ConceptDecl *Create(ASTContext &C, DeclContext *DC,\n                             SourceLocation L, DeclarationName Name,\n                             TemplateParameterList *Params,\n                             Expr *ConstraintExpr);\n  static ConceptDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  Expr *getConstraintExpr() const {\n    return ConstraintExpr;\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(getTemplateParameters()->getTemplateLoc(),\n                       ConstraintExpr->getEndLoc());\n  }\n\n  bool isTypeConcept() const {\n    return isa<TemplateTypeParmDecl>(getTemplateParameters()->getParam(0));\n  }\n\n  ConceptDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const ConceptDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Concept; }\n\n  friend class ASTReader;\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n};\n\n/// A template parameter object.\n///\n/// Template parameter objects represent values of class type used as template\n/// arguments. There is one template parameter object for each such distinct\n/// value used as a template argument across the program.\n///\n/// \\code\n/// struct A { int x, y; };\n/// template<A> struct S;\n/// S<A{1, 2}> s1;\n/// S<A{1, 2}> s2; // same type, argument is same TemplateParamObjectDecl.\n/// \\endcode\nclass TemplateParamObjectDecl : public ValueDecl,\n                                public Mergeable<TemplateParamObjectDecl>,\n                                public llvm::FoldingSetNode {\nprivate:\n  /// The value of this template parameter object.\n  APValue Value;\n\n  TemplateParamObjectDecl(DeclContext *DC, QualType T, const APValue &V)\n      : ValueDecl(TemplateParamObject, DC, SourceLocation(), DeclarationName(),\n                  T),\n        Value(V) {}\n\n  static TemplateParamObjectDecl *Create(const ASTContext &C, QualType T,\n                                         const APValue &V);\n  static TemplateParamObjectDecl *CreateDeserialized(ASTContext &C,\n                                                     unsigned ID);\n\n  /// Only ASTContext::getTemplateParamObjectDecl and deserialization\n  /// create these.\n  friend class ASTContext;\n  friend class ASTReader;\n  friend class ASTDeclReader;\n\npublic:\n  /// Print this template parameter object in a human-readable format.\n  void printName(llvm::raw_ostream &OS) const override;\n\n  /// Print this object as an equivalent expression.\n  void printAsExpr(llvm::raw_ostream &OS) const;\n\n  /// Print this object as an initializer suitable for a variable of the\n  /// object's type.\n  void printAsInit(llvm::raw_ostream &OS) const;\n\n  const APValue &getValue() const { return Value; }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType T,\n                      const APValue &V) {\n    ID.AddPointer(T.getCanonicalType().getAsOpaquePtr());\n    V.Profile(ID);\n  }\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getType(), getValue());\n  }\n\n  TemplateParamObjectDecl *getCanonicalDecl() override {\n    return getFirstDecl();\n  }\n  const TemplateParamObjectDecl *getCanonicalDecl() const {\n    return getFirstDecl();\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == TemplateParamObject; }\n};\n\ninline NamedDecl *getAsNamedDecl(TemplateParameter P) {\n  if (auto *PD = P.dyn_cast<TemplateTypeParmDecl *>())\n    return PD;\n  if (auto *PD = P.dyn_cast<NonTypeTemplateParmDecl *>())\n    return PD;\n  return P.get<TemplateTemplateParmDecl *>();\n}\n\ninline TemplateDecl *getAsTypeTemplateDecl(Decl *D) {\n  auto *TD = dyn_cast<TemplateDecl>(D);\n  return TD && (isa<ClassTemplateDecl>(TD) ||\n                isa<ClassTemplatePartialSpecializationDecl>(TD) ||\n                isa<TypeAliasTemplateDecl>(TD) ||\n                isa<TemplateTemplateParmDecl>(TD))\n             ? TD\n             : nullptr;\n}\n\n/// Check whether the template parameter is a pack expansion, and if so,\n/// determine the number of parameters produced by that expansion. For instance:\n///\n/// \\code\n/// template<typename ...Ts> struct A {\n///   template<Ts ...NTs, template<Ts> class ...TTs, typename ...Us> struct B;\n/// };\n/// \\endcode\n///\n/// In \\c A<int,int>::B, \\c NTs and \\c TTs have expanded pack size 2, and \\c Us\n/// is not a pack expansion, so returns an empty Optional.\ninline Optional<unsigned> getExpandedPackSize(const NamedDecl *Param) {\n  if (const auto *TTP = dyn_cast<TemplateTypeParmDecl>(Param)) {\n    if (TTP->isExpandedParameterPack())\n      return TTP->getNumExpansionParameters();\n  }\n\n  if (const auto *NTTP = dyn_cast<NonTypeTemplateParmDecl>(Param)) {\n    if (NTTP->isExpandedParameterPack())\n      return NTTP->getNumExpansionTypes();\n  }\n\n  if (const auto *TTP = dyn_cast<TemplateTemplateParmDecl>(Param)) {\n    if (TTP->isExpandedParameterPack())\n      return TTP->getNumExpansionTemplateParameters();\n  }\n\n  return None;\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_DECLTEMPLATE_H\n"}, "8": {"id": 8, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclarationName.h", "content": "//===- DeclarationName.h - Representation of declaration names --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the DeclarationName and DeclarationNameTable classes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_DECLARATIONNAME_H\n#define LLVM_CLANG_AST_DECLARATIONNAME_H\n\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/OperatorKinds.h\"\n#include \"clang/Basic/PartialDiagnostic.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <cassert>\n#include <cstdint>\n#include <cstring>\n#include <string>\n\nnamespace clang {\n\nclass ASTContext;\ntemplate <typename> class CanQual;\nclass DeclarationName;\nclass DeclarationNameTable;\nclass MultiKeywordSelector;\nstruct PrintingPolicy;\nclass TemplateDecl;\nclass TypeSourceInfo;\nclass UsingDirectiveDecl;\n\nusing CanQualType = CanQual<Type>;\n\nnamespace detail {\n\n/// CXXSpecialNameExtra records the type associated with one of the \"special\"\n/// kinds of declaration names in C++, e.g., constructors, destructors, and\n/// conversion functions. Note that CXXSpecialName is used for C++ constructor,\n/// destructor and conversion functions, but the actual kind is not stored in\n/// CXXSpecialName. Instead we use three different FoldingSet<CXXSpecialName>\n/// in DeclarationNameTable.\nclass alignas(IdentifierInfoAlignment) CXXSpecialNameExtra\n    : public llvm::FoldingSetNode {\n  friend class clang::DeclarationName;\n  friend class clang::DeclarationNameTable;\n\n  /// The type associated with this declaration name.\n  QualType Type;\n\n  /// Extra information associated with this declaration name that\n  /// can be used by the front end. All bits are really needed\n  /// so it is not possible to stash something in the low order bits.\n  void *FETokenInfo;\n\n  CXXSpecialNameExtra(QualType QT) : Type(QT), FETokenInfo(nullptr) {}\n\npublic:\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    ID.AddPointer(Type.getAsOpaquePtr());\n  }\n};\n\n/// Contains extra information for the name of a C++ deduction guide.\nclass alignas(IdentifierInfoAlignment) CXXDeductionGuideNameExtra\n    : public detail::DeclarationNameExtra,\n      public llvm::FoldingSetNode {\n  friend class clang::DeclarationName;\n  friend class clang::DeclarationNameTable;\n\n  /// The template named by the deduction guide.\n  TemplateDecl *Template;\n\n  /// Extra information associated with this operator name that\n  /// can be used by the front end. All bits are really needed\n  /// so it is not possible to stash something in the low order bits.\n  void *FETokenInfo;\n\n  CXXDeductionGuideNameExtra(TemplateDecl *TD)\n      : DeclarationNameExtra(CXXDeductionGuideName), Template(TD),\n        FETokenInfo(nullptr) {}\n\npublic:\n  void Profile(llvm::FoldingSetNodeID &ID) { ID.AddPointer(Template); }\n};\n\n/// Contains extra information for the name of an overloaded operator\n/// in C++, such as \"operator+. This do not includes literal or conversion\n/// operators. For literal operators see CXXLiteralOperatorIdName and for\n/// conversion operators see CXXSpecialNameExtra.\nclass alignas(IdentifierInfoAlignment) CXXOperatorIdName {\n  friend class clang::DeclarationName;\n  friend class clang::DeclarationNameTable;\n\n  /// The kind of this operator.\n  OverloadedOperatorKind Kind = OO_None;\n\n  /// Extra information associated with this operator name that\n  /// can be used by the front end. All bits are really needed\n  /// so it is not possible to stash something in the low order bits.\n  void *FETokenInfo = nullptr;\n};\n\n/// Contains the actual identifier that makes up the\n/// name of a C++ literal operator.\nclass alignas(IdentifierInfoAlignment) CXXLiteralOperatorIdName\n    : public detail::DeclarationNameExtra,\n      public llvm::FoldingSetNode {\n  friend class clang::DeclarationName;\n  friend class clang::DeclarationNameTable;\n\n  IdentifierInfo *ID;\n\n  /// Extra information associated with this operator name that\n  /// can be used by the front end. All bits are really needed\n  /// so it is not possible to stash something in the low order bits.\n  void *FETokenInfo;\n\n  CXXLiteralOperatorIdName(IdentifierInfo *II)\n      : DeclarationNameExtra(CXXLiteralOperatorName), ID(II),\n        FETokenInfo(nullptr) {}\n\npublic:\n  void Profile(llvm::FoldingSetNodeID &FSID) { FSID.AddPointer(ID); }\n};\n\n} // namespace detail\n\n/// The name of a declaration. In the common case, this just stores\n/// an IdentifierInfo pointer to a normal name. However, it also provides\n/// encodings for Objective-C selectors (optimizing zero- and one-argument\n/// selectors, which make up 78% percent of all selectors in Cocoa.h),\n/// special C++ names for constructors, destructors, and conversion functions,\n/// and C++ overloaded operators.\nclass DeclarationName {\n  friend class DeclarationNameTable;\n  friend class NamedDecl;\n\n  /// StoredNameKind represent the kind of name that is actually stored in the\n  /// upper bits of the Ptr field. This is only used internally.\n  ///\n  /// NameKind, StoredNameKind, and DeclarationNameExtra::ExtraKind\n  /// must satisfy the following properties. These properties enable\n  /// efficient conversion between the various kinds.\n  ///\n  /// * The first seven enumerators of StoredNameKind must have the same\n  ///   numerical value as the first seven enumerators of NameKind.\n  ///   This enable efficient conversion between the two enumerations\n  ///   in the usual case.\n  ///\n  /// * The enumerations values of DeclarationNameExtra::ExtraKind must start\n  ///   at zero, and correspond to the numerical value of the first non-inline\n  ///   enumeration values of NameKind minus an offset. This makes conversion\n  ///   between DeclarationNameExtra::ExtraKind and NameKind possible with\n  ///   a single addition/substraction.\n  ///\n  /// * The enumeration values of Selector::IdentifierInfoFlag must correspond\n  ///   to the relevant enumeration values of StoredNameKind.\n  ///   More specifically:\n  ///    * ZeroArg == StoredObjCZeroArgSelector,\n  ///    * OneArg == StoredObjCOneArgSelector,\n  ///    * MultiArg == StoredDeclarationNameExtra\n  ///\n  /// * PtrMask must mask the low 3 bits of Ptr.\n  enum StoredNameKind {\n    StoredIdentifier = 0,\n    StoredObjCZeroArgSelector = Selector::ZeroArg,\n    StoredObjCOneArgSelector = Selector::OneArg,\n    StoredCXXConstructorName = 3,\n    StoredCXXDestructorName = 4,\n    StoredCXXConversionFunctionName = 5,\n    StoredCXXOperatorName = 6,\n    StoredDeclarationNameExtra = Selector::MultiArg,\n    PtrMask = 7,\n    UncommonNameKindOffset = 8\n  };\n\n  static_assert(alignof(IdentifierInfo) >= 8 &&\n                    alignof(detail::DeclarationNameExtra) >= 8 &&\n                    alignof(detail::CXXSpecialNameExtra) >= 8 &&\n                    alignof(detail::CXXOperatorIdName) >= 8 &&\n                    alignof(detail::CXXDeductionGuideNameExtra) >= 8 &&\n                    alignof(detail::CXXLiteralOperatorIdName) >= 8,\n                \"The various classes that DeclarationName::Ptr can point to\"\n                \" must be at least aligned to 8 bytes!\");\n\npublic:\n  /// The kind of the name stored in this DeclarationName.\n  /// The first 7 enumeration values are stored inline and correspond\n  /// to frequently used kinds. The rest is stored in DeclarationNameExtra\n  /// and correspond to infrequently used kinds.\n  enum NameKind {\n    Identifier = StoredIdentifier,\n    ObjCZeroArgSelector = StoredObjCZeroArgSelector,\n    ObjCOneArgSelector = StoredObjCOneArgSelector,\n    CXXConstructorName = StoredCXXConstructorName,\n    CXXDestructorName = StoredCXXDestructorName,\n    CXXConversionFunctionName = StoredCXXConversionFunctionName,\n    CXXOperatorName = StoredCXXOperatorName,\n    CXXDeductionGuideName = UncommonNameKindOffset +\n                            detail::DeclarationNameExtra::CXXDeductionGuideName,\n    CXXLiteralOperatorName =\n        UncommonNameKindOffset +\n        detail::DeclarationNameExtra::CXXLiteralOperatorName,\n    CXXUsingDirective = UncommonNameKindOffset +\n                        detail::DeclarationNameExtra::CXXUsingDirective,\n    ObjCMultiArgSelector = UncommonNameKindOffset +\n                           detail::DeclarationNameExtra::ObjCMultiArgSelector\n  };\n\nprivate:\n  /// The lowest three bits of Ptr are used to express what kind of name\n  /// we're actually storing, using the values of StoredNameKind. Depending\n  /// on the kind of name this is, the upper bits of Ptr may have one\n  /// of several different meanings:\n  ///\n  ///   StoredIdentifier - The name is a normal identifier, and Ptr is\n  ///   a normal IdentifierInfo pointer.\n  ///\n  ///   StoredObjCZeroArgSelector - The name is an Objective-C\n  ///   selector with zero arguments, and Ptr is an IdentifierInfo\n  ///   pointer pointing to the selector name.\n  ///\n  ///   StoredObjCOneArgSelector - The name is an Objective-C selector\n  ///   with one argument, and Ptr is an IdentifierInfo pointer\n  ///   pointing to the selector name.\n  ///\n  ///   StoredCXXConstructorName - The name of a C++ constructor,\n  ///   Ptr points to a CXXSpecialNameExtra.\n  ///\n  ///   StoredCXXDestructorName - The name of a C++ destructor,\n  ///   Ptr points to a CXXSpecialNameExtra.\n  ///\n  ///   StoredCXXConversionFunctionName - The name of a C++ conversion function,\n  ///   Ptr points to a CXXSpecialNameExtra.\n  ///\n  ///   StoredCXXOperatorName - The name of an overloaded C++ operator,\n  ///   Ptr points to a CXXOperatorIdName.\n  ///\n  ///   StoredDeclarationNameExtra - Ptr is actually a pointer to a\n  ///   DeclarationNameExtra structure, whose first value will tell us\n  ///   whether this is an Objective-C selector, C++ deduction guide,\n  ///   C++ literal operator, or C++ using directive.\n  uintptr_t Ptr = 0;\n\n  StoredNameKind getStoredNameKind() const {\n    return static_cast<StoredNameKind>(Ptr & PtrMask);\n  }\n\n  void *getPtr() const { return reinterpret_cast<void *>(Ptr & ~PtrMask); }\n\n  void setPtrAndKind(const void *P, StoredNameKind Kind) {\n    uintptr_t PAsInteger = reinterpret_cast<uintptr_t>(P);\n    assert((Kind & ~PtrMask) == 0 &&\n           \"Invalid StoredNameKind in setPtrAndKind!\");\n    assert((PAsInteger & PtrMask) == 0 &&\n           \"Improperly aligned pointer in setPtrAndKind!\");\n    Ptr = PAsInteger | Kind;\n  }\n\n  /// Construct a declaration name from a DeclarationNameExtra.\n  DeclarationName(detail::DeclarationNameExtra *Name) {\n    setPtrAndKind(Name, StoredDeclarationNameExtra);\n  }\n\n  /// Construct a declaration name from a CXXSpecialNameExtra.\n  DeclarationName(detail::CXXSpecialNameExtra *Name,\n                  StoredNameKind StoredKind) {\n    assert((StoredKind == StoredCXXConstructorName ||\n           StoredKind == StoredCXXDestructorName ||\n           StoredKind == StoredCXXConversionFunctionName) &&\n               \"Invalid StoredNameKind when constructing a DeclarationName\"\n               \" from a CXXSpecialNameExtra!\");\n    setPtrAndKind(Name, StoredKind);\n  }\n\n  /// Construct a DeclarationName from a CXXOperatorIdName.\n  DeclarationName(detail::CXXOperatorIdName *Name) {\n    setPtrAndKind(Name, StoredCXXOperatorName);\n  }\n\n  /// Assert that the stored pointer points to an IdentifierInfo and return it.\n  IdentifierInfo *castAsIdentifierInfo() const {\n    assert((getStoredNameKind() == StoredIdentifier) &&\n           \"DeclarationName does not store an IdentifierInfo!\");\n    return static_cast<IdentifierInfo *>(getPtr());\n  }\n\n  /// Assert that the stored pointer points to a DeclarationNameExtra\n  /// and return it.\n  detail::DeclarationNameExtra *castAsExtra() const {\n    assert((getStoredNameKind() == StoredDeclarationNameExtra) &&\n           \"DeclarationName does not store an Extra structure!\");\n    return static_cast<detail::DeclarationNameExtra *>(getPtr());\n  }\n\n  /// Assert that the stored pointer points to a CXXSpecialNameExtra\n  /// and return it.\n  detail::CXXSpecialNameExtra *castAsCXXSpecialNameExtra() const {\n    assert((getStoredNameKind() == StoredCXXConstructorName ||\n           getStoredNameKind() == StoredCXXDestructorName ||\n           getStoredNameKind() == StoredCXXConversionFunctionName) &&\n               \"DeclarationName does not store a CXXSpecialNameExtra!\");\n    return static_cast<detail::CXXSpecialNameExtra *>(getPtr());\n  }\n\n  /// Assert that the stored pointer points to a CXXOperatorIdName\n  /// and return it.\n  detail::CXXOperatorIdName *castAsCXXOperatorIdName() const {\n    assert((getStoredNameKind() == StoredCXXOperatorName) &&\n           \"DeclarationName does not store a CXXOperatorIdName!\");\n    return static_cast<detail::CXXOperatorIdName *>(getPtr());\n  }\n\n  /// Assert that the stored pointer points to a CXXDeductionGuideNameExtra\n  /// and return it.\n  detail::CXXDeductionGuideNameExtra *castAsCXXDeductionGuideNameExtra() const {\n    assert(getNameKind() == CXXDeductionGuideName &&\n           \"DeclarationName does not store a CXXDeductionGuideNameExtra!\");\n    return static_cast<detail::CXXDeductionGuideNameExtra *>(getPtr());\n  }\n\n  /// Assert that the stored pointer points to a CXXLiteralOperatorIdName\n  /// and return it.\n  detail::CXXLiteralOperatorIdName *castAsCXXLiteralOperatorIdName() const {\n    assert(getNameKind() == CXXLiteralOperatorName &&\n           \"DeclarationName does not store a CXXLiteralOperatorIdName!\");\n    return static_cast<detail::CXXLiteralOperatorIdName *>(getPtr());\n  }\n\n  /// Get and set the FETokenInfo in the less common cases where the\n  /// declaration name do not point to an identifier.\n  void *getFETokenInfoSlow() const;\n  void setFETokenInfoSlow(void *T);\n\npublic:\n  /// Construct an empty declaration name.\n  DeclarationName() { setPtrAndKind(nullptr, StoredIdentifier); }\n\n  /// Construct a declaration name from an IdentifierInfo *.\n  DeclarationName(const IdentifierInfo *II) {\n    setPtrAndKind(II, StoredIdentifier);\n  }\n\n  /// Construct a declaration name from an Objective-C selector.\n  DeclarationName(Selector Sel) : Ptr(Sel.InfoPtr) {}\n\n  /// Returns the name for all C++ using-directives.\n  static DeclarationName getUsingDirectiveName() {\n    // Single instance of DeclarationNameExtra for using-directive\n    static detail::DeclarationNameExtra UDirExtra(\n        detail::DeclarationNameExtra::CXXUsingDirective);\n    return DeclarationName(&UDirExtra);\n  }\n\n  /// Evaluates true when this declaration name is non-empty.\n  explicit operator bool() const {\n    return getPtr() || (getStoredNameKind() != StoredIdentifier);\n  }\n\n  /// Evaluates true when this declaration name is empty.\n  bool isEmpty() const { return !*this; }\n\n  /// Predicate functions for querying what type of name this is.\n  bool isIdentifier() const { return getStoredNameKind() == StoredIdentifier; }\n  bool isObjCZeroArgSelector() const {\n    return getStoredNameKind() == StoredObjCZeroArgSelector;\n  }\n  bool isObjCOneArgSelector() const {\n    return getStoredNameKind() == StoredObjCOneArgSelector;\n  }\n\n  /// Determine what kind of name this is.\n  NameKind getNameKind() const {\n    // We rely on the fact that the first 7 NameKind and StoredNameKind\n    // have the same numerical value. This makes the usual case efficient.\n    StoredNameKind StoredKind = getStoredNameKind();\n    if (StoredKind != StoredDeclarationNameExtra)\n      return static_cast<NameKind>(StoredKind);\n    // We have to consult DeclarationNameExtra. We rely on the fact that the\n    // enumeration values of ExtraKind correspond to the enumeration values of\n    // NameKind minus an offset of UncommonNameKindOffset.\n    unsigned ExtraKind = castAsExtra()->getKind();\n    return static_cast<NameKind>(UncommonNameKindOffset + ExtraKind);\n  }\n\n  /// Determines whether the name itself is dependent, e.g., because it\n  /// involves a C++ type that is itself dependent.\n  ///\n  /// Note that this does not capture all of the notions of \"dependent name\",\n  /// because an identifier can be a dependent name if it is used as the\n  /// callee in a call expression with dependent arguments.\n  bool isDependentName() const;\n\n  /// Retrieve the human-readable string for this name.\n  std::string getAsString() const;\n\n  /// Retrieve the IdentifierInfo * stored in this declaration name,\n  /// or null if this declaration name isn't a simple identifier.\n  IdentifierInfo *getAsIdentifierInfo() const {\n    if (isIdentifier())\n      return castAsIdentifierInfo();\n    return nullptr;\n  }\n\n  /// Get the representation of this declaration name as an opaque integer.\n  uintptr_t getAsOpaqueInteger() const { return Ptr; }\n\n  /// Get the representation of this declaration name as an opaque pointer.\n  void *getAsOpaquePtr() const { return reinterpret_cast<void *>(Ptr); }\n\n  /// Get a declaration name from an opaque pointer returned by getAsOpaquePtr.\n  static DeclarationName getFromOpaquePtr(void *P) {\n    DeclarationName N;\n    N.Ptr = reinterpret_cast<uintptr_t>(P);\n    return N;\n  }\n\n  /// Get a declaration name from an opaque integer\n  /// returned by getAsOpaqueInteger.\n  static DeclarationName getFromOpaqueInteger(uintptr_t P) {\n    DeclarationName N;\n    N.Ptr = P;\n    return N;\n  }\n\n  /// If this name is one of the C++ names (of a constructor, destructor,\n  /// or conversion function), return the type associated with that name.\n  QualType getCXXNameType() const {\n    if (getStoredNameKind() == StoredCXXConstructorName ||\n        getStoredNameKind() == StoredCXXDestructorName ||\n        getStoredNameKind() == StoredCXXConversionFunctionName) {\n      assert(getPtr() && \"getCXXNameType on a null DeclarationName!\");\n      return castAsCXXSpecialNameExtra()->Type;\n    }\n    return QualType();\n  }\n\n  /// If this name is the name of a C++ deduction guide, return the\n  /// template associated with that name.\n  TemplateDecl *getCXXDeductionGuideTemplate() const {\n    if (getNameKind() == CXXDeductionGuideName) {\n      assert(getPtr() &&\n             \"getCXXDeductionGuideTemplate on a null DeclarationName!\");\n      return castAsCXXDeductionGuideNameExtra()->Template;\n    }\n    return nullptr;\n  }\n\n  /// If this name is the name of an overloadable operator in C++\n  /// (e.g., @c operator+), retrieve the kind of overloaded operator.\n  OverloadedOperatorKind getCXXOverloadedOperator() const {\n    if (getStoredNameKind() == StoredCXXOperatorName) {\n      assert(getPtr() && \"getCXXOverloadedOperator on a null DeclarationName!\");\n      return castAsCXXOperatorIdName()->Kind;\n    }\n    return OO_None;\n  }\n\n  /// If this name is the name of a literal operator,\n  /// retrieve the identifier associated with it.\n  IdentifierInfo *getCXXLiteralIdentifier() const {\n    if (getNameKind() == CXXLiteralOperatorName) {\n      assert(getPtr() && \"getCXXLiteralIdentifier on a null DeclarationName!\");\n      return castAsCXXLiteralOperatorIdName()->ID;\n    }\n    return nullptr;\n  }\n\n  /// Get the Objective-C selector stored in this declaration name.\n  Selector getObjCSelector() const {\n    assert((getNameKind() == ObjCZeroArgSelector ||\n            getNameKind() == ObjCOneArgSelector ||\n            getNameKind() == ObjCMultiArgSelector || !getPtr()) &&\n           \"Not a selector!\");\n    return Selector(Ptr);\n  }\n\n  /// Get and set FETokenInfo. The language front-end is allowed to associate\n  /// arbitrary metadata with some kinds of declaration names, including normal\n  /// identifiers and C++ constructors, destructors, and conversion functions.\n  void *getFETokenInfo() const {\n    assert(getPtr() && \"getFETokenInfo on an empty DeclarationName!\");\n    if (getStoredNameKind() == StoredIdentifier)\n      return castAsIdentifierInfo()->getFETokenInfo();\n    return getFETokenInfoSlow();\n  }\n\n  void setFETokenInfo(void *T) {\n    assert(getPtr() && \"setFETokenInfo on an empty DeclarationName!\");\n    if (getStoredNameKind() == StoredIdentifier)\n      castAsIdentifierInfo()->setFETokenInfo(T);\n    else\n      setFETokenInfoSlow(T);\n  }\n\n  /// Determine whether the specified names are identical.\n  friend bool operator==(DeclarationName LHS, DeclarationName RHS) {\n    return LHS.Ptr == RHS.Ptr;\n  }\n\n  /// Determine whether the specified names are different.\n  friend bool operator!=(DeclarationName LHS, DeclarationName RHS) {\n    return LHS.Ptr != RHS.Ptr;\n  }\n\n  static DeclarationName getEmptyMarker() {\n    DeclarationName Name;\n    Name.Ptr = uintptr_t(-1);\n    return Name;\n  }\n\n  static DeclarationName getTombstoneMarker() {\n    DeclarationName Name;\n    Name.Ptr = uintptr_t(-2);\n    return Name;\n  }\n\n  static int compare(DeclarationName LHS, DeclarationName RHS);\n\n  void print(raw_ostream &OS, const PrintingPolicy &Policy) const;\n\n  void dump() const;\n};\n\nraw_ostream &operator<<(raw_ostream &OS, DeclarationName N);\n\n/// Ordering on two declaration names. If both names are identifiers,\n/// this provides a lexicographical ordering.\ninline bool operator<(DeclarationName LHS, DeclarationName RHS) {\n  return DeclarationName::compare(LHS, RHS) < 0;\n}\n\n/// Ordering on two declaration names. If both names are identifiers,\n/// this provides a lexicographical ordering.\ninline bool operator>(DeclarationName LHS, DeclarationName RHS) {\n  return DeclarationName::compare(LHS, RHS) > 0;\n}\n\n/// Ordering on two declaration names. If both names are identifiers,\n/// this provides a lexicographical ordering.\ninline bool operator<=(DeclarationName LHS, DeclarationName RHS) {\n  return DeclarationName::compare(LHS, RHS) <= 0;\n}\n\n/// Ordering on two declaration names. If both names are identifiers,\n/// this provides a lexicographical ordering.\ninline bool operator>=(DeclarationName LHS, DeclarationName RHS) {\n  return DeclarationName::compare(LHS, RHS) >= 0;\n}\n\n/// DeclarationNameTable is used to store and retrieve DeclarationName\n/// instances for the various kinds of declaration names, e.g., normal\n/// identifiers, C++ constructor names, etc. This class contains\n/// uniqued versions of each of the C++ special names, which can be\n/// retrieved using its member functions (e.g., getCXXConstructorName).\nclass DeclarationNameTable {\n  /// Used to allocate elements in the FoldingSets below.\n  const ASTContext &Ctx;\n\n  /// Manage the uniqued CXXSpecialNameExtra representing C++ constructors.\n  /// getCXXConstructorName and getCXXSpecialName can be used to obtain\n  /// a DeclarationName from the corresponding type of the constructor.\n  llvm::FoldingSet<detail::CXXSpecialNameExtra> CXXConstructorNames;\n\n  /// Manage the uniqued CXXSpecialNameExtra representing C++ destructors.\n  /// getCXXDestructorName and getCXXSpecialName can be used to obtain\n  /// a DeclarationName from the corresponding type of the destructor.\n  llvm::FoldingSet<detail::CXXSpecialNameExtra> CXXDestructorNames;\n\n  /// Manage the uniqued CXXSpecialNameExtra representing C++ conversion\n  /// functions. getCXXConversionFunctionName and getCXXSpecialName can be\n  /// used to obtain a DeclarationName from the corresponding type of the\n  /// conversion function.\n  llvm::FoldingSet<detail::CXXSpecialNameExtra> CXXConversionFunctionNames;\n\n  /// Manage the uniqued CXXOperatorIdName, which contain extra information\n  /// for the name of overloaded C++ operators. getCXXOperatorName\n  /// can be used to obtain a DeclarationName from the operator kind.\n  detail::CXXOperatorIdName CXXOperatorNames[NUM_OVERLOADED_OPERATORS];\n\n  /// Manage the uniqued CXXLiteralOperatorIdName, which contain extra\n  /// information for the name of C++ literal operators.\n  /// getCXXLiteralOperatorName can be used to obtain a DeclarationName\n  /// from the corresponding IdentifierInfo.\n  llvm::FoldingSet<detail::CXXLiteralOperatorIdName> CXXLiteralOperatorNames;\n\n  /// Manage the uniqued CXXDeductionGuideNameExtra, which contain\n  /// extra information for the name of a C++ deduction guide.\n  /// getCXXDeductionGuideName can be used to obtain a DeclarationName\n  /// from the corresponding template declaration.\n  llvm::FoldingSet<detail::CXXDeductionGuideNameExtra> CXXDeductionGuideNames;\n\npublic:\n  DeclarationNameTable(const ASTContext &C);\n  DeclarationNameTable(const DeclarationNameTable &) = delete;\n  DeclarationNameTable &operator=(const DeclarationNameTable &) = delete;\n  DeclarationNameTable(DeclarationNameTable &&) = delete;\n  DeclarationNameTable &operator=(DeclarationNameTable &&) = delete;\n  ~DeclarationNameTable() = default;\n\n  /// Create a declaration name that is a simple identifier.\n  DeclarationName getIdentifier(const IdentifierInfo *ID) {\n    return DeclarationName(ID);\n  }\n\n  /// Returns the name of a C++ constructor for the given Type.\n  DeclarationName getCXXConstructorName(CanQualType Ty);\n\n  /// Returns the name of a C++ destructor for the given Type.\n  DeclarationName getCXXDestructorName(CanQualType Ty);\n\n  /// Returns the name of a C++ deduction guide for the given template.\n  DeclarationName getCXXDeductionGuideName(TemplateDecl *TD);\n\n  /// Returns the name of a C++ conversion function for the given Type.\n  DeclarationName getCXXConversionFunctionName(CanQualType Ty);\n\n  /// Returns a declaration name for special kind of C++ name,\n  /// e.g., for a constructor, destructor, or conversion function.\n  /// Kind must be one of:\n  ///   * DeclarationName::CXXConstructorName,\n  ///   * DeclarationName::CXXDestructorName or\n  ///   * DeclarationName::CXXConversionFunctionName\n  DeclarationName getCXXSpecialName(DeclarationName::NameKind Kind,\n                                    CanQualType Ty);\n\n  /// Get the name of the overloadable C++ operator corresponding to Op.\n  DeclarationName getCXXOperatorName(OverloadedOperatorKind Op) {\n    return DeclarationName(&CXXOperatorNames[Op]);\n  }\n\n  /// Get the name of the literal operator function with II as the identifier.\n  DeclarationName getCXXLiteralOperatorName(IdentifierInfo *II);\n};\n\n/// DeclarationNameLoc - Additional source/type location info\n/// for a declaration name. Needs a DeclarationName in order\n/// to be interpreted correctly.\nclass DeclarationNameLoc {\n  // The source location for identifier stored elsewhere.\n  // struct {} Identifier;\n\n  // Type info for constructors, destructors and conversion functions.\n  // Locations (if any) for the tilde (destructor) or operator keyword\n  // (conversion) are stored elsewhere.\n  struct NT {\n    TypeSourceInfo *TInfo;\n  };\n\n  // The location (if any) of the operator keyword is stored elsewhere.\n  struct CXXOpName {\n    unsigned BeginOpNameLoc;\n    unsigned EndOpNameLoc;\n  };\n\n  // The location (if any) of the operator keyword is stored elsewhere.\n  struct CXXLitOpName {\n    unsigned OpNameLoc;\n  };\n\n  // struct {} CXXUsingDirective;\n  // struct {} ObjCZeroArgSelector;\n  // struct {} ObjCOneArgSelector;\n  // struct {} ObjCMultiArgSelector;\n  union {\n    struct NT NamedType;\n    struct CXXOpName CXXOperatorName;\n    struct CXXLitOpName CXXLiteralOperatorName;\n  };\n\n  void setNamedTypeLoc(TypeSourceInfo *TInfo) { NamedType.TInfo = TInfo; }\n\n  void setCXXOperatorNameRange(SourceRange Range) {\n    CXXOperatorName.BeginOpNameLoc = Range.getBegin().getRawEncoding();\n    CXXOperatorName.EndOpNameLoc = Range.getEnd().getRawEncoding();\n  }\n\n  void setCXXLiteralOperatorNameLoc(SourceLocation Loc) {\n    CXXLiteralOperatorName.OpNameLoc = Loc.getRawEncoding();\n  }\n\npublic:\n  DeclarationNameLoc(DeclarationName Name);\n  // FIXME: this should go away once all DNLocs are properly initialized.\n  DeclarationNameLoc() { memset((void*) this, 0, sizeof(*this)); }\n\n  /// Returns the source type info. Assumes that the object stores location\n  /// information of a constructor, destructor or conversion operator.\n  TypeSourceInfo *getNamedTypeInfo() const { return NamedType.TInfo; }\n\n  /// Return the beginning location of the getCXXOperatorNameRange() range.\n  SourceLocation getCXXOperatorNameBeginLoc() const {\n    return SourceLocation::getFromRawEncoding(CXXOperatorName.BeginOpNameLoc);\n  }\n\n  /// Return the end location of the getCXXOperatorNameRange() range.\n  SourceLocation getCXXOperatorNameEndLoc() const {\n    return SourceLocation::getFromRawEncoding(CXXOperatorName.EndOpNameLoc);\n  }\n\n  /// Return the range of the operator name (without the operator keyword).\n  /// Assumes that the object stores location information of a (non-literal)\n  /// operator.\n  SourceRange getCXXOperatorNameRange() const {\n    return SourceRange(getCXXOperatorNameBeginLoc(),\n                       getCXXOperatorNameEndLoc());\n  }\n\n  /// Return the location of the literal operator name (without the operator\n  /// keyword). Assumes that the object stores location information of a literal\n  /// operator.\n  SourceLocation getCXXLiteralOperatorNameLoc() const {\n    return SourceLocation::getFromRawEncoding(CXXLiteralOperatorName.OpNameLoc);\n  }\n\n  /// Construct location information for a constructor, destructor or conversion\n  /// operator.\n  static DeclarationNameLoc makeNamedTypeLoc(TypeSourceInfo *TInfo) {\n    DeclarationNameLoc DNL;\n    DNL.setNamedTypeLoc(TInfo);\n    return DNL;\n  }\n\n  /// Construct location information for a non-literal C++ operator.\n  static DeclarationNameLoc makeCXXOperatorNameLoc(SourceLocation BeginLoc,\n                                                   SourceLocation EndLoc) {\n    return makeCXXOperatorNameLoc(SourceRange(BeginLoc, EndLoc));\n  }\n\n  /// Construct location information for a non-literal C++ operator.\n  static DeclarationNameLoc makeCXXOperatorNameLoc(SourceRange Range) {\n    DeclarationNameLoc DNL;\n    DNL.setCXXOperatorNameRange(Range);\n    return DNL;\n  }\n\n  /// Construct location information for a literal C++ operator.\n  static DeclarationNameLoc makeCXXLiteralOperatorNameLoc(SourceLocation Loc) {\n    DeclarationNameLoc DNL;\n    DNL.setCXXLiteralOperatorNameLoc(Loc);\n    return DNL;\n  }\n};\n\n/// DeclarationNameInfo - A collector data type for bundling together\n/// a DeclarationName and the correspnding source/type location info.\nstruct DeclarationNameInfo {\nprivate:\n  /// Name - The declaration name, also encoding name kind.\n  DeclarationName Name;\n\n  /// Loc - The main source location for the declaration name.\n  SourceLocation NameLoc;\n\n  /// Info - Further source/type location info for special kinds of names.\n  DeclarationNameLoc LocInfo;\n\npublic:\n  // FIXME: remove it.\n  DeclarationNameInfo() = default;\n\n  DeclarationNameInfo(DeclarationName Name, SourceLocation NameLoc)\n      : Name(Name), NameLoc(NameLoc), LocInfo(Name) {}\n\n  DeclarationNameInfo(DeclarationName Name, SourceLocation NameLoc,\n                      DeclarationNameLoc LocInfo)\n      : Name(Name), NameLoc(NameLoc), LocInfo(LocInfo) {}\n\n  /// getName - Returns the embedded declaration name.\n  DeclarationName getName() const { return Name; }\n\n  /// setName - Sets the embedded declaration name.\n  void setName(DeclarationName N) { Name = N; }\n\n  /// getLoc - Returns the main location of the declaration name.\n  SourceLocation getLoc() const { return NameLoc; }\n\n  /// setLoc - Sets the main location of the declaration name.\n  void setLoc(SourceLocation L) { NameLoc = L; }\n\n  const DeclarationNameLoc &getInfo() const { return LocInfo; }\n  void setInfo(const DeclarationNameLoc &Info) { LocInfo = Info; }\n\n  /// getNamedTypeInfo - Returns the source type info associated to\n  /// the name. Assumes it is a constructor, destructor or conversion.\n  TypeSourceInfo *getNamedTypeInfo() const {\n    if (Name.getNameKind() != DeclarationName::CXXConstructorName &&\n        Name.getNameKind() != DeclarationName::CXXDestructorName &&\n        Name.getNameKind() != DeclarationName::CXXConversionFunctionName)\n      return nullptr;\n    return LocInfo.getNamedTypeInfo();\n  }\n\n  /// setNamedTypeInfo - Sets the source type info associated to\n  /// the name. Assumes it is a constructor, destructor or conversion.\n  void setNamedTypeInfo(TypeSourceInfo *TInfo) {\n    assert(Name.getNameKind() == DeclarationName::CXXConstructorName ||\n           Name.getNameKind() == DeclarationName::CXXDestructorName ||\n           Name.getNameKind() == DeclarationName::CXXConversionFunctionName);\n    LocInfo = DeclarationNameLoc::makeNamedTypeLoc(TInfo);\n  }\n\n  /// getCXXOperatorNameRange - Gets the range of the operator name\n  /// (without the operator keyword). Assumes it is a (non-literal) operator.\n  SourceRange getCXXOperatorNameRange() const {\n    if (Name.getNameKind() != DeclarationName::CXXOperatorName)\n      return SourceRange();\n    return LocInfo.getCXXOperatorNameRange();\n  }\n\n  /// setCXXOperatorNameRange - Sets the range of the operator name\n  /// (without the operator keyword). Assumes it is a C++ operator.\n  void setCXXOperatorNameRange(SourceRange R) {\n    assert(Name.getNameKind() == DeclarationName::CXXOperatorName);\n    LocInfo = DeclarationNameLoc::makeCXXOperatorNameLoc(R);\n  }\n\n  /// getCXXLiteralOperatorNameLoc - Returns the location of the literal\n  /// operator name (not the operator keyword).\n  /// Assumes it is a literal operator.\n  SourceLocation getCXXLiteralOperatorNameLoc() const {\n    if (Name.getNameKind() != DeclarationName::CXXLiteralOperatorName)\n      return SourceLocation();\n    return LocInfo.getCXXLiteralOperatorNameLoc();\n  }\n\n  /// setCXXLiteralOperatorNameLoc - Sets the location of the literal\n  /// operator name (not the operator keyword).\n  /// Assumes it is a literal operator.\n  void setCXXLiteralOperatorNameLoc(SourceLocation Loc) {\n    assert(Name.getNameKind() == DeclarationName::CXXLiteralOperatorName);\n    LocInfo = DeclarationNameLoc::makeCXXLiteralOperatorNameLoc(Loc);\n  }\n\n  /// Determine whether this name involves a template parameter.\n  bool isInstantiationDependent() const;\n\n  /// Determine whether this name contains an unexpanded\n  /// parameter pack.\n  bool containsUnexpandedParameterPack() const;\n\n  /// getAsString - Retrieve the human-readable string for this name.\n  std::string getAsString() const;\n\n  /// printName - Print the human-readable name to a stream.\n  void printName(raw_ostream &OS, PrintingPolicy Policy) const;\n\n  /// getBeginLoc - Retrieve the location of the first token.\n  SourceLocation getBeginLoc() const { return NameLoc; }\n\n  /// getSourceRange - The range of the declaration name.\n  SourceRange getSourceRange() const LLVM_READONLY {\n    return SourceRange(getBeginLoc(), getEndLoc());\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    SourceLocation EndLoc = getEndLocPrivate();\n    return EndLoc.isValid() ? EndLoc : getBeginLoc();\n  }\n\nprivate:\n  SourceLocation getEndLocPrivate() const;\n};\n\n/// Insertion operator for partial diagnostics.  This allows binding\n/// DeclarationName's into a partial diagnostic with <<.\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &PD,\n                                             DeclarationName N) {\n  PD.AddTaggedVal(N.getAsOpaqueInteger(),\n                  DiagnosticsEngine::ak_declarationname);\n  return PD;\n}\n\nraw_ostream &operator<<(raw_ostream &OS, DeclarationNameInfo DNInfo);\n\n} // namespace clang\n\nnamespace llvm {\n\n/// Define DenseMapInfo so that DeclarationNames can be used as keys\n/// in DenseMap and DenseSets.\ntemplate<>\nstruct DenseMapInfo<clang::DeclarationName> {\n  static inline clang::DeclarationName getEmptyKey() {\n    return clang::DeclarationName::getEmptyMarker();\n  }\n\n  static inline clang::DeclarationName getTombstoneKey() {\n    return clang::DeclarationName::getTombstoneMarker();\n  }\n\n  static unsigned getHashValue(clang::DeclarationName Name) {\n    return DenseMapInfo<void*>::getHashValue(Name.getAsOpaquePtr());\n  }\n\n  static inline bool\n  isEqual(clang::DeclarationName LHS, clang::DeclarationName RHS) {\n    return LHS == RHS;\n  }\n};\n\ntemplate <> struct PointerLikeTypeTraits<clang::DeclarationName> {\n  static inline void *getAsVoidPointer(clang::DeclarationName P) {\n    return P.getAsOpaquePtr();\n  }\n  static inline clang::DeclarationName getFromVoidPointer(void *P) {\n    return clang::DeclarationName::getFromOpaquePtr(P);\n  }\n  static constexpr int NumLowBitsAvailable = 0;\n};\n\n} // namespace llvm\n\n// The definition of AssumedTemplateStorage is factored out of TemplateName to\n// resolve a cyclic dependency between it and DeclarationName (via Type).\nnamespace clang {\n\n/// A structure for storing the information associated with a name that has\n/// been assumed to be a template name (despite finding no TemplateDecls).\nclass AssumedTemplateStorage : public UncommonTemplateNameStorage {\n  friend class ASTContext;\n\n  AssumedTemplateStorage(DeclarationName Name)\n      : UncommonTemplateNameStorage(Assumed, 0), Name(Name) {}\n  DeclarationName Name;\n\npublic:\n  /// Get the name of the template.\n  DeclarationName getDeclName() const { return Name; }\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_DECLARATIONNAME_H\n"}, "9": {"id": 9, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "content": "//===--- Expr.h - Classes for representing expressions ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the Expr interface and subclasses.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_EXPR_H\n#define LLVM_CLANG_AST_EXPR_H\n\n#include \"clang/AST/APValue.h\"\n#include \"clang/AST/ASTVector.h\"\n#include \"clang/AST/ComputeDependence.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclAccessPair.h\"\n#include \"clang/AST/DependenceFlags.h\"\n#include \"clang/AST/OperationKinds.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/TemplateBase.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/CharInfo.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/SyncScope.h\"\n#include \"clang/Basic/TypeTraits.h\"\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/AtomicOrdering.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n\nnamespace clang {\n  class APValue;\n  class ASTContext;\n  class BlockDecl;\n  class CXXBaseSpecifier;\n  class CXXMemberCallExpr;\n  class CXXOperatorCallExpr;\n  class CastExpr;\n  class Decl;\n  class IdentifierInfo;\n  class MaterializeTemporaryExpr;\n  class NamedDecl;\n  class ObjCPropertyRefExpr;\n  class OpaqueValueExpr;\n  class ParmVarDecl;\n  class StringLiteral;\n  class TargetInfo;\n  class ValueDecl;\n\n/// A simple array of base specifiers.\ntypedef SmallVector<CXXBaseSpecifier*, 4> CXXCastPath;\n\n/// An adjustment to be made to the temporary created when emitting a\n/// reference binding, which accesses a particular subobject of that temporary.\nstruct SubobjectAdjustment {\n  enum {\n    DerivedToBaseAdjustment,\n    FieldAdjustment,\n    MemberPointerAdjustment\n  } Kind;\n\n  struct DTB {\n    const CastExpr *BasePath;\n    const CXXRecordDecl *DerivedClass;\n  };\n\n  struct P {\n    const MemberPointerType *MPT;\n    Expr *RHS;\n  };\n\n  union {\n    struct DTB DerivedToBase;\n    FieldDecl *Field;\n    struct P Ptr;\n  };\n\n  SubobjectAdjustment(const CastExpr *BasePath,\n                      const CXXRecordDecl *DerivedClass)\n    : Kind(DerivedToBaseAdjustment) {\n    DerivedToBase.BasePath = BasePath;\n    DerivedToBase.DerivedClass = DerivedClass;\n  }\n\n  SubobjectAdjustment(FieldDecl *Field)\n    : Kind(FieldAdjustment) {\n    this->Field = Field;\n  }\n\n  SubobjectAdjustment(const MemberPointerType *MPT, Expr *RHS)\n    : Kind(MemberPointerAdjustment) {\n    this->Ptr.MPT = MPT;\n    this->Ptr.RHS = RHS;\n  }\n};\n\n/// This represents one expression.  Note that Expr's are subclasses of Stmt.\n/// This allows an expression to be transparently used any place a Stmt is\n/// required.\nclass Expr : public ValueStmt {\n  QualType TR;\n\npublic:\n  Expr() = delete;\n  Expr(const Expr&) = delete;\n  Expr(Expr &&) = delete;\n  Expr &operator=(const Expr&) = delete;\n  Expr &operator=(Expr&&) = delete;\n\nprotected:\n  Expr(StmtClass SC, QualType T, ExprValueKind VK, ExprObjectKind OK)\n      : ValueStmt(SC) {\n    ExprBits.Dependent = 0;\n    ExprBits.ValueKind = VK;\n    ExprBits.ObjectKind = OK;\n    assert(ExprBits.ObjectKind == OK && \"truncated kind\");\n    setType(T);\n  }\n\n  /// Construct an empty expression.\n  explicit Expr(StmtClass SC, EmptyShell) : ValueStmt(SC) { }\n\n  /// Each concrete expr subclass is expected to compute its dependence and call\n  /// this in the constructor.\n  void setDependence(ExprDependence Deps) {\n    ExprBits.Dependent = static_cast<unsigned>(Deps);\n  }\n  friend class ASTImporter; // Sets dependence dircetly.\n  friend class ASTStmtReader; // Sets dependence dircetly.\n\npublic:\n  QualType getType() const { return TR; }\n  void setType(QualType t) {\n    // In C++, the type of an expression is always adjusted so that it\n    // will not have reference type (C++ [expr]p6). Use\n    // QualType::getNonReferenceType() to retrieve the non-reference\n    // type. Additionally, inspect Expr::isLvalue to determine whether\n    // an expression that is adjusted in this manner should be\n    // considered an lvalue.\n    assert((t.isNull() || !t->isReferenceType()) &&\n           \"Expressions can't have reference type\");\n\n    TR = t;\n  }\n\n  ExprDependence getDependence() const {\n    return static_cast<ExprDependence>(ExprBits.Dependent);\n  }\n\n  /// Determines whether the value of this expression depends on\n  ///   - a template parameter (C++ [temp.dep.constexpr])\n  ///   - or an error, whose resolution is unknown\n  ///\n  /// For example, the array bound of \"Chars\" in the following example is\n  /// value-dependent.\n  /// @code\n  /// template<int Size, char (&Chars)[Size]> struct meta_string;\n  /// @endcode\n  bool isValueDependent() const {\n    return static_cast<bool>(getDependence() & ExprDependence::Value);\n  }\n\n  /// Determines whether the type of this expression depends on\n  ///   - a template paramter (C++ [temp.dep.expr], which means that its type\n  ///     could change from one template instantiation to the next)\n  ///   - or an error\n  ///\n  /// For example, the expressions \"x\" and \"x + y\" are type-dependent in\n  /// the following code, but \"y\" is not type-dependent:\n  /// @code\n  /// template<typename T>\n  /// void add(T x, int y) {\n  ///   x + y;\n  /// }\n  /// @endcode\n  bool isTypeDependent() const {\n    return static_cast<bool>(getDependence() & ExprDependence::Type);\n  }\n\n  /// Whether this expression is instantiation-dependent, meaning that\n  /// it depends in some way on\n  ///    - a template parameter (even if neither its type nor (constant) value\n  ///      can change due to the template instantiation)\n  ///    - or an error\n  ///\n  /// In the following example, the expression \\c sizeof(sizeof(T() + T())) is\n  /// instantiation-dependent (since it involves a template parameter \\c T), but\n  /// is neither type- nor value-dependent, since the type of the inner\n  /// \\c sizeof is known (\\c std::size_t) and therefore the size of the outer\n  /// \\c sizeof is known.\n  ///\n  /// \\code\n  /// template<typename T>\n  /// void f(T x, T y) {\n  ///   sizeof(sizeof(T() + T());\n  /// }\n  /// \\endcode\n  ///\n  /// \\code\n  /// void func(int) {\n  ///   func(); // the expression is instantiation-dependent, because it depends\n  ///           // on an error.\n  /// }\n  /// \\endcode\n  bool isInstantiationDependent() const {\n    return static_cast<bool>(getDependence() & ExprDependence::Instantiation);\n  }\n\n  /// Whether this expression contains an unexpanded parameter\n  /// pack (for C++11 variadic templates).\n  ///\n  /// Given the following function template:\n  ///\n  /// \\code\n  /// template<typename F, typename ...Types>\n  /// void forward(const F &f, Types &&...args) {\n  ///   f(static_cast<Types&&>(args)...);\n  /// }\n  /// \\endcode\n  ///\n  /// The expressions \\c args and \\c static_cast<Types&&>(args) both\n  /// contain parameter packs.\n  bool containsUnexpandedParameterPack() const {\n    return static_cast<bool>(getDependence() & ExprDependence::UnexpandedPack);\n  }\n\n  /// Whether this expression contains subexpressions which had errors, e.g. a\n  /// TypoExpr.\n  bool containsErrors() const {\n    return static_cast<bool>(getDependence() & ExprDependence::Error);\n  }\n\n  /// getExprLoc - Return the preferred location for the arrow when diagnosing\n  /// a problem with a generic expression.\n  SourceLocation getExprLoc() const LLVM_READONLY;\n\n  /// Determine whether an lvalue-to-rvalue conversion should implicitly be\n  /// applied to this expression if it appears as a discarded-value expression\n  /// in C++11 onwards. This applies to certain forms of volatile glvalues.\n  bool isReadIfDiscardedInCPlusPlus11() const;\n\n  /// isUnusedResultAWarning - Return true if this immediate expression should\n  /// be warned about if the result is unused.  If so, fill in expr, location,\n  /// and ranges with expr to warn on and source locations/ranges appropriate\n  /// for a warning.\n  bool isUnusedResultAWarning(const Expr *&WarnExpr, SourceLocation &Loc,\n                              SourceRange &R1, SourceRange &R2,\n                              ASTContext &Ctx) const;\n\n  /// isLValue - True if this expression is an \"l-value\" according to\n  /// the rules of the current language.  C and C++ give somewhat\n  /// different rules for this concept, but in general, the result of\n  /// an l-value expression identifies a specific object whereas the\n  /// result of an r-value expression is a value detached from any\n  /// specific storage.\n  ///\n  /// C++11 divides the concept of \"r-value\" into pure r-values\n  /// (\"pr-values\") and so-called expiring values (\"x-values\"), which\n  /// identify specific objects that can be safely cannibalized for\n  /// their resources.  This is an unfortunate abuse of terminology on\n  /// the part of the C++ committee.  In Clang, when we say \"r-value\",\n  /// we generally mean a pr-value.\n  bool isLValue() const { return getValueKind() == VK_LValue; }\n  bool isRValue() const { return getValueKind() == VK_RValue; }\n  bool isXValue() const { return getValueKind() == VK_XValue; }\n  bool isGLValue() const { return getValueKind() != VK_RValue; }\n\n  enum LValueClassification {\n    LV_Valid,\n    LV_NotObjectType,\n    LV_IncompleteVoidType,\n    LV_DuplicateVectorComponents,\n    LV_InvalidExpression,\n    LV_InvalidMessageExpression,\n    LV_MemberFunction,\n    LV_SubObjCPropertySetting,\n    LV_ClassTemporary,\n    LV_ArrayTemporary\n  };\n  /// Reasons why an expression might not be an l-value.\n  LValueClassification ClassifyLValue(ASTContext &Ctx) const;\n\n  enum isModifiableLvalueResult {\n    MLV_Valid,\n    MLV_NotObjectType,\n    MLV_IncompleteVoidType,\n    MLV_DuplicateVectorComponents,\n    MLV_InvalidExpression,\n    MLV_LValueCast,           // Specialized form of MLV_InvalidExpression.\n    MLV_IncompleteType,\n    MLV_ConstQualified,\n    MLV_ConstQualifiedField,\n    MLV_ConstAddrSpace,\n    MLV_ArrayType,\n    MLV_NoSetterProperty,\n    MLV_MemberFunction,\n    MLV_SubObjCPropertySetting,\n    MLV_InvalidMessageExpression,\n    MLV_ClassTemporary,\n    MLV_ArrayTemporary\n  };\n  /// isModifiableLvalue - C99 6.3.2.1: an lvalue that does not have array type,\n  /// does not have an incomplete type, does not have a const-qualified type,\n  /// and if it is a structure or union, does not have any member (including,\n  /// recursively, any member or element of all contained aggregates or unions)\n  /// with a const-qualified type.\n  ///\n  /// \\param Loc [in,out] - A source location which *may* be filled\n  /// in with the location of the expression making this a\n  /// non-modifiable lvalue, if specified.\n  isModifiableLvalueResult\n  isModifiableLvalue(ASTContext &Ctx, SourceLocation *Loc = nullptr) const;\n\n  /// The return type of classify(). Represents the C++11 expression\n  ///        taxonomy.\n  class Classification {\n  public:\n    /// The various classification results. Most of these mean prvalue.\n    enum Kinds {\n      CL_LValue,\n      CL_XValue,\n      CL_Function, // Functions cannot be lvalues in C.\n      CL_Void, // Void cannot be an lvalue in C.\n      CL_AddressableVoid, // Void expression whose address can be taken in C.\n      CL_DuplicateVectorComponents, // A vector shuffle with dupes.\n      CL_MemberFunction, // An expression referring to a member function\n      CL_SubObjCPropertySetting,\n      CL_ClassTemporary, // A temporary of class type, or subobject thereof.\n      CL_ArrayTemporary, // A temporary of array type.\n      CL_ObjCMessageRValue, // ObjC message is an rvalue\n      CL_PRValue // A prvalue for any other reason, of any other type\n    };\n    /// The results of modification testing.\n    enum ModifiableType {\n      CM_Untested, // testModifiable was false.\n      CM_Modifiable,\n      CM_RValue, // Not modifiable because it's an rvalue\n      CM_Function, // Not modifiable because it's a function; C++ only\n      CM_LValueCast, // Same as CM_RValue, but indicates GCC cast-as-lvalue ext\n      CM_NoSetterProperty,// Implicit assignment to ObjC property without setter\n      CM_ConstQualified,\n      CM_ConstQualifiedField,\n      CM_ConstAddrSpace,\n      CM_ArrayType,\n      CM_IncompleteType\n    };\n\n  private:\n    friend class Expr;\n\n    unsigned short Kind;\n    unsigned short Modifiable;\n\n    explicit Classification(Kinds k, ModifiableType m)\n      : Kind(k), Modifiable(m)\n    {}\n\n  public:\n    Classification() {}\n\n    Kinds getKind() const { return static_cast<Kinds>(Kind); }\n    ModifiableType getModifiable() const {\n      assert(Modifiable != CM_Untested && \"Did not test for modifiability.\");\n      return static_cast<ModifiableType>(Modifiable);\n    }\n    bool isLValue() const { return Kind == CL_LValue; }\n    bool isXValue() const { return Kind == CL_XValue; }\n    bool isGLValue() const { return Kind <= CL_XValue; }\n    bool isPRValue() const { return Kind >= CL_Function; }\n    bool isRValue() const { return Kind >= CL_XValue; }\n    bool isModifiable() const { return getModifiable() == CM_Modifiable; }\n\n    /// Create a simple, modifiably lvalue\n    static Classification makeSimpleLValue() {\n      return Classification(CL_LValue, CM_Modifiable);\n    }\n\n  };\n  /// Classify - Classify this expression according to the C++11\n  ///        expression taxonomy.\n  ///\n  /// C++11 defines ([basic.lval]) a new taxonomy of expressions to replace the\n  /// old lvalue vs rvalue. This function determines the type of expression this\n  /// is. There are three expression types:\n  /// - lvalues are classical lvalues as in C++03.\n  /// - prvalues are equivalent to rvalues in C++03.\n  /// - xvalues are expressions yielding unnamed rvalue references, e.g. a\n  ///   function returning an rvalue reference.\n  /// lvalues and xvalues are collectively referred to as glvalues, while\n  /// prvalues and xvalues together form rvalues.\n  Classification Classify(ASTContext &Ctx) const {\n    return ClassifyImpl(Ctx, nullptr);\n  }\n\n  /// ClassifyModifiable - Classify this expression according to the\n  ///        C++11 expression taxonomy, and see if it is valid on the left side\n  ///        of an assignment.\n  ///\n  /// This function extends classify in that it also tests whether the\n  /// expression is modifiable (C99 6.3.2.1p1).\n  /// \\param Loc A source location that might be filled with a relevant location\n  ///            if the expression is not modifiable.\n  Classification ClassifyModifiable(ASTContext &Ctx, SourceLocation &Loc) const{\n    return ClassifyImpl(Ctx, &Loc);\n  }\n\n  /// Returns the set of floating point options that apply to this expression.\n  /// Only meaningful for operations on floating point values.\n  FPOptions getFPFeaturesInEffect(const LangOptions &LO) const;\n\n  /// getValueKindForType - Given a formal return or parameter type,\n  /// give its value kind.\n  static ExprValueKind getValueKindForType(QualType T) {\n    if (const ReferenceType *RT = T->getAs<ReferenceType>())\n      return (isa<LValueReferenceType>(RT)\n                ? VK_LValue\n                : (RT->getPointeeType()->isFunctionType()\n                     ? VK_LValue : VK_XValue));\n    return VK_RValue;\n  }\n\n  /// getValueKind - The value kind that this expression produces.\n  ExprValueKind getValueKind() const {\n    return static_cast<ExprValueKind>(ExprBits.ValueKind);\n  }\n\n  /// getObjectKind - The object kind that this expression produces.\n  /// Object kinds are meaningful only for expressions that yield an\n  /// l-value or x-value.\n  ExprObjectKind getObjectKind() const {\n    return static_cast<ExprObjectKind>(ExprBits.ObjectKind);\n  }\n\n  bool isOrdinaryOrBitFieldObject() const {\n    ExprObjectKind OK = getObjectKind();\n    return (OK == OK_Ordinary || OK == OK_BitField);\n  }\n\n  /// setValueKind - Set the value kind produced by this expression.\n  void setValueKind(ExprValueKind Cat) { ExprBits.ValueKind = Cat; }\n\n  /// setObjectKind - Set the object kind produced by this expression.\n  void setObjectKind(ExprObjectKind Cat) { ExprBits.ObjectKind = Cat; }\n\nprivate:\n  Classification ClassifyImpl(ASTContext &Ctx, SourceLocation *Loc) const;\n\npublic:\n\n  /// Returns true if this expression is a gl-value that\n  /// potentially refers to a bit-field.\n  ///\n  /// In C++, whether a gl-value refers to a bitfield is essentially\n  /// an aspect of the value-kind type system.\n  bool refersToBitField() const { return getObjectKind() == OK_BitField; }\n\n  /// If this expression refers to a bit-field, retrieve the\n  /// declaration of that bit-field.\n  ///\n  /// Note that this returns a non-null pointer in subtly different\n  /// places than refersToBitField returns true.  In particular, this can\n  /// return a non-null pointer even for r-values loaded from\n  /// bit-fields, but it will return null for a conditional bit-field.\n  FieldDecl *getSourceBitField();\n\n  const FieldDecl *getSourceBitField() const {\n    return const_cast<Expr*>(this)->getSourceBitField();\n  }\n\n  Decl *getReferencedDeclOfCallee();\n  const Decl *getReferencedDeclOfCallee() const {\n    return const_cast<Expr*>(this)->getReferencedDeclOfCallee();\n  }\n\n  /// If this expression is an l-value for an Objective C\n  /// property, find the underlying property reference expression.\n  const ObjCPropertyRefExpr *getObjCProperty() const;\n\n  /// Check if this expression is the ObjC 'self' implicit parameter.\n  bool isObjCSelfExpr() const;\n\n  /// Returns whether this expression refers to a vector element.\n  bool refersToVectorElement() const;\n\n  /// Returns whether this expression refers to a matrix element.\n  bool refersToMatrixElement() const {\n    return getObjectKind() == OK_MatrixComponent;\n  }\n\n  /// Returns whether this expression refers to a global register\n  /// variable.\n  bool refersToGlobalRegisterVar() const;\n\n  /// Returns whether this expression has a placeholder type.\n  bool hasPlaceholderType() const {\n    return getType()->isPlaceholderType();\n  }\n\n  /// Returns whether this expression has a specific placeholder type.\n  bool hasPlaceholderType(BuiltinType::Kind K) const {\n    assert(BuiltinType::isPlaceholderTypeKind(K));\n    if (const BuiltinType *BT = dyn_cast<BuiltinType>(getType()))\n      return BT->getKind() == K;\n    return false;\n  }\n\n  /// isKnownToHaveBooleanValue - Return true if this is an integer expression\n  /// that is known to return 0 or 1.  This happens for _Bool/bool expressions\n  /// but also int expressions which are produced by things like comparisons in\n  /// C.\n  ///\n  /// \\param Semantic If true, only return true for expressions that are known\n  /// to be semantically boolean, which might not be true even for expressions\n  /// that are known to evaluate to 0/1. For instance, reading an unsigned\n  /// bit-field with width '1' will evaluate to 0/1, but doesn't necessarily\n  /// semantically correspond to a bool.\n  bool isKnownToHaveBooleanValue(bool Semantic = true) const;\n\n  /// isIntegerConstantExpr - Return the value if this expression is a valid\n  /// integer constant expression.  If not a valid i-c-e, return None and fill\n  /// in Loc (if specified) with the location of the invalid expression.\n  ///\n  /// Note: This does not perform the implicit conversions required by C++11\n  /// [expr.const]p5.\n  Optional<llvm::APSInt> getIntegerConstantExpr(const ASTContext &Ctx,\n                                                SourceLocation *Loc = nullptr,\n                                                bool isEvaluated = true) const;\n  bool isIntegerConstantExpr(const ASTContext &Ctx,\n                             SourceLocation *Loc = nullptr) const;\n\n  /// isCXX98IntegralConstantExpr - Return true if this expression is an\n  /// integral constant expression in C++98. Can only be used in C++.\n  bool isCXX98IntegralConstantExpr(const ASTContext &Ctx) const;\n\n  /// isCXX11ConstantExpr - Return true if this expression is a constant\n  /// expression in C++11. Can only be used in C++.\n  ///\n  /// Note: This does not perform the implicit conversions required by C++11\n  /// [expr.const]p5.\n  bool isCXX11ConstantExpr(const ASTContext &Ctx, APValue *Result = nullptr,\n                           SourceLocation *Loc = nullptr) const;\n\n  /// isPotentialConstantExpr - Return true if this function's definition\n  /// might be usable in a constant expression in C++11, if it were marked\n  /// constexpr. Return false if the function can never produce a constant\n  /// expression, along with diagnostics describing why not.\n  static bool isPotentialConstantExpr(const FunctionDecl *FD,\n                                      SmallVectorImpl<\n                                        PartialDiagnosticAt> &Diags);\n\n  /// isPotentialConstantExprUnevaluted - Return true if this expression might\n  /// be usable in a constant expression in C++11 in an unevaluated context, if\n  /// it were in function FD marked constexpr. Return false if the function can\n  /// never produce a constant expression, along with diagnostics describing\n  /// why not.\n  static bool isPotentialConstantExprUnevaluated(Expr *E,\n                                                 const FunctionDecl *FD,\n                                                 SmallVectorImpl<\n                                                   PartialDiagnosticAt> &Diags);\n\n  /// isConstantInitializer - Returns true if this expression can be emitted to\n  /// IR as a constant, and thus can be used as a constant initializer in C.\n  /// If this expression is not constant and Culprit is non-null,\n  /// it is used to store the address of first non constant expr.\n  bool isConstantInitializer(ASTContext &Ctx, bool ForRef,\n                             const Expr **Culprit = nullptr) const;\n\n  /// EvalStatus is a struct with detailed info about an evaluation in progress.\n  struct EvalStatus {\n    /// Whether the evaluated expression has side effects.\n    /// For example, (f() && 0) can be folded, but it still has side effects.\n    bool HasSideEffects;\n\n    /// Whether the evaluation hit undefined behavior.\n    /// For example, 1.0 / 0.0 can be folded to Inf, but has undefined behavior.\n    /// Likewise, INT_MAX + 1 can be folded to INT_MIN, but has UB.\n    bool HasUndefinedBehavior;\n\n    /// Diag - If this is non-null, it will be filled in with a stack of notes\n    /// indicating why evaluation failed (or why it failed to produce a constant\n    /// expression).\n    /// If the expression is unfoldable, the notes will indicate why it's not\n    /// foldable. If the expression is foldable, but not a constant expression,\n    /// the notes will describes why it isn't a constant expression. If the\n    /// expression *is* a constant expression, no notes will be produced.\n    SmallVectorImpl<PartialDiagnosticAt> *Diag;\n\n    EvalStatus()\n        : HasSideEffects(false), HasUndefinedBehavior(false), Diag(nullptr) {}\n\n    // hasSideEffects - Return true if the evaluated expression has\n    // side effects.\n    bool hasSideEffects() const {\n      return HasSideEffects;\n    }\n  };\n\n  /// EvalResult is a struct with detailed info about an evaluated expression.\n  struct EvalResult : EvalStatus {\n    /// Val - This is the value the expression can be folded to.\n    APValue Val;\n\n    // isGlobalLValue - Return true if the evaluated lvalue expression\n    // is global.\n    bool isGlobalLValue() const;\n  };\n\n  /// EvaluateAsRValue - Return true if this is a constant which we can fold to\n  /// an rvalue using any crazy technique (that has nothing to do with language\n  /// standards) that we want to, even if the expression has side-effects. If\n  /// this function returns true, it returns the folded constant in Result. If\n  /// the expression is a glvalue, an lvalue-to-rvalue conversion will be\n  /// applied.\n  bool EvaluateAsRValue(EvalResult &Result, const ASTContext &Ctx,\n                        bool InConstantContext = false) const;\n\n  /// EvaluateAsBooleanCondition - Return true if this is a constant\n  /// which we can fold and convert to a boolean condition using\n  /// any crazy technique that we want to, even if the expression has\n  /// side-effects.\n  bool EvaluateAsBooleanCondition(bool &Result, const ASTContext &Ctx,\n                                  bool InConstantContext = false) const;\n\n  enum SideEffectsKind {\n    SE_NoSideEffects,          ///< Strictly evaluate the expression.\n    SE_AllowUndefinedBehavior, ///< Allow UB that we can give a value, but not\n                               ///< arbitrary unmodeled side effects.\n    SE_AllowSideEffects        ///< Allow any unmodeled side effect.\n  };\n\n  /// EvaluateAsInt - Return true if this is a constant which we can fold and\n  /// convert to an integer, using any crazy technique that we want to.\n  bool EvaluateAsInt(EvalResult &Result, const ASTContext &Ctx,\n                     SideEffectsKind AllowSideEffects = SE_NoSideEffects,\n                     bool InConstantContext = false) const;\n\n  /// EvaluateAsFloat - Return true if this is a constant which we can fold and\n  /// convert to a floating point value, using any crazy technique that we\n  /// want to.\n  bool EvaluateAsFloat(llvm::APFloat &Result, const ASTContext &Ctx,\n                       SideEffectsKind AllowSideEffects = SE_NoSideEffects,\n                       bool InConstantContext = false) const;\n\n  /// EvaluateAsFloat - Return true if this is a constant which we can fold and\n  /// convert to a fixed point value.\n  bool EvaluateAsFixedPoint(EvalResult &Result, const ASTContext &Ctx,\n                            SideEffectsKind AllowSideEffects = SE_NoSideEffects,\n                            bool InConstantContext = false) const;\n\n  /// isEvaluatable - Call EvaluateAsRValue to see if this expression can be\n  /// constant folded without side-effects, but discard the result.\n  bool isEvaluatable(const ASTContext &Ctx,\n                     SideEffectsKind AllowSideEffects = SE_NoSideEffects) const;\n\n  /// HasSideEffects - This routine returns true for all those expressions\n  /// which have any effect other than producing a value. Example is a function\n  /// call, volatile variable read, or throwing an exception. If\n  /// IncludePossibleEffects is false, this call treats certain expressions with\n  /// potential side effects (such as function call-like expressions,\n  /// instantiation-dependent expressions, or invocations from a macro) as not\n  /// having side effects.\n  bool HasSideEffects(const ASTContext &Ctx,\n                      bool IncludePossibleEffects = true) const;\n\n  /// Determine whether this expression involves a call to any function\n  /// that is not trivial.\n  bool hasNonTrivialCall(const ASTContext &Ctx) const;\n\n  /// EvaluateKnownConstInt - Call EvaluateAsRValue and return the folded\n  /// integer. This must be called on an expression that constant folds to an\n  /// integer.\n  llvm::APSInt EvaluateKnownConstInt(\n      const ASTContext &Ctx,\n      SmallVectorImpl<PartialDiagnosticAt> *Diag = nullptr) const;\n\n  llvm::APSInt EvaluateKnownConstIntCheckOverflow(\n      const ASTContext &Ctx,\n      SmallVectorImpl<PartialDiagnosticAt> *Diag = nullptr) const;\n\n  void EvaluateForOverflow(const ASTContext &Ctx) const;\n\n  /// EvaluateAsLValue - Evaluate an expression to see if we can fold it to an\n  /// lvalue with link time known address, with no side-effects.\n  bool EvaluateAsLValue(EvalResult &Result, const ASTContext &Ctx,\n                        bool InConstantContext = false) const;\n\n  /// EvaluateAsInitializer - Evaluate an expression as if it were the\n  /// initializer of the given declaration. Returns true if the initializer\n  /// can be folded to a constant, and produces any relevant notes. In C++11,\n  /// notes will be produced if the expression is not a constant expression.\n  bool EvaluateAsInitializer(APValue &Result, const ASTContext &Ctx,\n                             const VarDecl *VD,\n                             SmallVectorImpl<PartialDiagnosticAt> &Notes,\n                             bool IsConstantInitializer) const;\n\n  /// EvaluateWithSubstitution - Evaluate an expression as if from the context\n  /// of a call to the given function with the given arguments, inside an\n  /// unevaluated context. Returns true if the expression could be folded to a\n  /// constant.\n  bool EvaluateWithSubstitution(APValue &Value, ASTContext &Ctx,\n                                const FunctionDecl *Callee,\n                                ArrayRef<const Expr*> Args,\n                                const Expr *This = nullptr) const;\n\n  enum class ConstantExprKind {\n    /// An integer constant expression (an array bound, enumerator, case value,\n    /// bit-field width, or similar) or similar.\n    Normal,\n    /// A non-class template argument. Such a value is only used for mangling,\n    /// not for code generation, so can refer to dllimported functions.\n    NonClassTemplateArgument,\n    /// A class template argument. Such a value is used for code generation.\n    ClassTemplateArgument,\n    /// An immediate invocation. The destruction of the end result of this\n    /// evaluation is not part of the evaluation, but all other temporaries\n    /// are destroyed.\n    ImmediateInvocation,\n  };\n\n  /// Evaluate an expression that is required to be a constant expression. Does\n  /// not check the syntactic constraints for C and C++98 constant expressions.\n  bool EvaluateAsConstantExpr(\n      EvalResult &Result, const ASTContext &Ctx,\n      ConstantExprKind Kind = ConstantExprKind::Normal) const;\n\n  /// If the current Expr is a pointer, this will try to statically\n  /// determine the number of bytes available where the pointer is pointing.\n  /// Returns true if all of the above holds and we were able to figure out the\n  /// size, false otherwise.\n  ///\n  /// \\param Type - How to evaluate the size of the Expr, as defined by the\n  /// \"type\" parameter of __builtin_object_size\n  bool tryEvaluateObjectSize(uint64_t &Result, ASTContext &Ctx,\n                             unsigned Type) const;\n\n  /// Enumeration used to describe the kind of Null pointer constant\n  /// returned from \\c isNullPointerConstant().\n  enum NullPointerConstantKind {\n    /// Expression is not a Null pointer constant.\n    NPCK_NotNull = 0,\n\n    /// Expression is a Null pointer constant built from a zero integer\n    /// expression that is not a simple, possibly parenthesized, zero literal.\n    /// C++ Core Issue 903 will classify these expressions as \"not pointers\"\n    /// once it is adopted.\n    /// http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#903\n    NPCK_ZeroExpression,\n\n    /// Expression is a Null pointer constant built from a literal zero.\n    NPCK_ZeroLiteral,\n\n    /// Expression is a C++11 nullptr.\n    NPCK_CXX11_nullptr,\n\n    /// Expression is a GNU-style __null constant.\n    NPCK_GNUNull\n  };\n\n  /// Enumeration used to describe how \\c isNullPointerConstant()\n  /// should cope with value-dependent expressions.\n  enum NullPointerConstantValueDependence {\n    /// Specifies that the expression should never be value-dependent.\n    NPC_NeverValueDependent = 0,\n\n    /// Specifies that a value-dependent expression of integral or\n    /// dependent type should be considered a null pointer constant.\n    NPC_ValueDependentIsNull,\n\n    /// Specifies that a value-dependent expression should be considered\n    /// to never be a null pointer constant.\n    NPC_ValueDependentIsNotNull\n  };\n\n  /// isNullPointerConstant - C99 6.3.2.3p3 - Test if this reduces down to\n  /// a Null pointer constant. The return value can further distinguish the\n  /// kind of NULL pointer constant that was detected.\n  NullPointerConstantKind isNullPointerConstant(\n      ASTContext &Ctx,\n      NullPointerConstantValueDependence NPC) const;\n\n  /// isOBJCGCCandidate - Return true if this expression may be used in a read/\n  /// write barrier.\n  bool isOBJCGCCandidate(ASTContext &Ctx) const;\n\n  /// Returns true if this expression is a bound member function.\n  bool isBoundMemberFunction(ASTContext &Ctx) const;\n\n  /// Given an expression of bound-member type, find the type\n  /// of the member.  Returns null if this is an *overloaded* bound\n  /// member expression.\n  static QualType findBoundMemberType(const Expr *expr);\n\n  /// Skip past any invisble AST nodes which might surround this\n  /// statement, such as ExprWithCleanups or ImplicitCastExpr nodes,\n  /// but also injected CXXMemberExpr and CXXConstructExpr which represent\n  /// implicit conversions.\n  Expr *IgnoreUnlessSpelledInSource();\n  const Expr *IgnoreUnlessSpelledInSource() const {\n    return const_cast<Expr *>(this)->IgnoreUnlessSpelledInSource();\n  }\n\n  /// Skip past any implicit casts which might surround this expression until\n  /// reaching a fixed point. Skips:\n  /// * ImplicitCastExpr\n  /// * FullExpr\n  Expr *IgnoreImpCasts() LLVM_READONLY;\n  const Expr *IgnoreImpCasts() const {\n    return const_cast<Expr *>(this)->IgnoreImpCasts();\n  }\n\n  /// Skip past any casts which might surround this expression until reaching\n  /// a fixed point. Skips:\n  /// * CastExpr\n  /// * FullExpr\n  /// * MaterializeTemporaryExpr\n  /// * SubstNonTypeTemplateParmExpr\n  Expr *IgnoreCasts() LLVM_READONLY;\n  const Expr *IgnoreCasts() const {\n    return const_cast<Expr *>(this)->IgnoreCasts();\n  }\n\n  /// Skip past any implicit AST nodes which might surround this expression\n  /// until reaching a fixed point. Skips:\n  /// * What IgnoreImpCasts() skips\n  /// * MaterializeTemporaryExpr\n  /// * CXXBindTemporaryExpr\n  Expr *IgnoreImplicit() LLVM_READONLY;\n  const Expr *IgnoreImplicit() const {\n    return const_cast<Expr *>(this)->IgnoreImplicit();\n  }\n\n  /// Skip past any implicit AST nodes which might surround this expression\n  /// until reaching a fixed point. Same as IgnoreImplicit, except that it\n  /// also skips over implicit calls to constructors and conversion functions.\n  ///\n  /// FIXME: Should IgnoreImplicit do this?\n  Expr *IgnoreImplicitAsWritten() LLVM_READONLY;\n  const Expr *IgnoreImplicitAsWritten() const {\n    return const_cast<Expr *>(this)->IgnoreImplicitAsWritten();\n  }\n\n  /// Skip past any parentheses which might surround this expression until\n  /// reaching a fixed point. Skips:\n  /// * ParenExpr\n  /// * UnaryOperator if `UO_Extension`\n  /// * GenericSelectionExpr if `!isResultDependent()`\n  /// * ChooseExpr if `!isConditionDependent()`\n  /// * ConstantExpr\n  Expr *IgnoreParens() LLVM_READONLY;\n  const Expr *IgnoreParens() const {\n    return const_cast<Expr *>(this)->IgnoreParens();\n  }\n\n  /// Skip past any parentheses and implicit casts which might surround this\n  /// expression until reaching a fixed point.\n  /// FIXME: IgnoreParenImpCasts really ought to be equivalent to\n  /// IgnoreParens() + IgnoreImpCasts() until reaching a fixed point. However\n  /// this is currently not the case. Instead IgnoreParenImpCasts() skips:\n  /// * What IgnoreParens() skips\n  /// * What IgnoreImpCasts() skips\n  /// * MaterializeTemporaryExpr\n  /// * SubstNonTypeTemplateParmExpr\n  Expr *IgnoreParenImpCasts() LLVM_READONLY;\n  const Expr *IgnoreParenImpCasts() const {\n    return const_cast<Expr *>(this)->IgnoreParenImpCasts();\n  }\n\n  /// Skip past any parentheses and casts which might surround this expression\n  /// until reaching a fixed point. Skips:\n  /// * What IgnoreParens() skips\n  /// * What IgnoreCasts() skips\n  Expr *IgnoreParenCasts() LLVM_READONLY;\n  const Expr *IgnoreParenCasts() const {\n    return const_cast<Expr *>(this)->IgnoreParenCasts();\n  }\n\n  /// Skip conversion operators. If this Expr is a call to a conversion\n  /// operator, return the argument.\n  Expr *IgnoreConversionOperatorSingleStep() LLVM_READONLY;\n  const Expr *IgnoreConversionOperatorSingleStep() const {\n    return const_cast<Expr *>(this)->IgnoreConversionOperatorSingleStep();\n  }\n\n  /// Skip past any parentheses and lvalue casts which might surround this\n  /// expression until reaching a fixed point. Skips:\n  /// * What IgnoreParens() skips\n  /// * What IgnoreCasts() skips, except that only lvalue-to-rvalue\n  ///   casts are skipped\n  /// FIXME: This is intended purely as a temporary workaround for code\n  /// that hasn't yet been rewritten to do the right thing about those\n  /// casts, and may disappear along with the last internal use.\n  Expr *IgnoreParenLValueCasts() LLVM_READONLY;\n  const Expr *IgnoreParenLValueCasts() const {\n    return const_cast<Expr *>(this)->IgnoreParenLValueCasts();\n  }\n\n  /// Skip past any parenthese and casts which do not change the value\n  /// (including ptr->int casts of the same size) until reaching a fixed point.\n  /// Skips:\n  /// * What IgnoreParens() skips\n  /// * CastExpr which do not change the value\n  /// * SubstNonTypeTemplateParmExpr\n  Expr *IgnoreParenNoopCasts(const ASTContext &Ctx) LLVM_READONLY;\n  const Expr *IgnoreParenNoopCasts(const ASTContext &Ctx) const {\n    return const_cast<Expr *>(this)->IgnoreParenNoopCasts(Ctx);\n  }\n\n  /// Skip past any parentheses and derived-to-base casts until reaching a\n  /// fixed point. Skips:\n  /// * What IgnoreParens() skips\n  /// * CastExpr which represent a derived-to-base cast (CK_DerivedToBase,\n  ///   CK_UncheckedDerivedToBase and CK_NoOp)\n  Expr *IgnoreParenBaseCasts() LLVM_READONLY;\n  const Expr *IgnoreParenBaseCasts() const {\n    return const_cast<Expr *>(this)->IgnoreParenBaseCasts();\n  }\n\n  /// Determine whether this expression is a default function argument.\n  ///\n  /// Default arguments are implicitly generated in the abstract syntax tree\n  /// by semantic analysis for function calls, object constructions, etc. in\n  /// C++. Default arguments are represented by \\c CXXDefaultArgExpr nodes;\n  /// this routine also looks through any implicit casts to determine whether\n  /// the expression is a default argument.\n  bool isDefaultArgument() const;\n\n  /// Determine whether the result of this expression is a\n  /// temporary object of the given class type.\n  bool isTemporaryObject(ASTContext &Ctx, const CXXRecordDecl *TempTy) const;\n\n  /// Whether this expression is an implicit reference to 'this' in C++.\n  bool isImplicitCXXThis() const;\n\n  static bool hasAnyTypeDependentArguments(ArrayRef<Expr *> Exprs);\n\n  /// For an expression of class type or pointer to class type,\n  /// return the most derived class decl the expression is known to refer to.\n  ///\n  /// If this expression is a cast, this method looks through it to find the\n  /// most derived decl that can be inferred from the expression.\n  /// This is valid because derived-to-base conversions have undefined\n  /// behavior if the object isn't dynamically of the derived type.\n  const CXXRecordDecl *getBestDynamicClassType() const;\n\n  /// Get the inner expression that determines the best dynamic class.\n  /// If this is a prvalue, we guarantee that it is of the most-derived type\n  /// for the object itself.\n  const Expr *getBestDynamicClassTypeExpr() const;\n\n  /// Walk outwards from an expression we want to bind a reference to and\n  /// find the expression whose lifetime needs to be extended. Record\n  /// the LHSs of comma expressions and adjustments needed along the path.\n  const Expr *skipRValueSubobjectAdjustments(\n      SmallVectorImpl<const Expr *> &CommaLHS,\n      SmallVectorImpl<SubobjectAdjustment> &Adjustments) const;\n  const Expr *skipRValueSubobjectAdjustments() const {\n    SmallVector<const Expr *, 8> CommaLHSs;\n    SmallVector<SubobjectAdjustment, 8> Adjustments;\n    return skipRValueSubobjectAdjustments(CommaLHSs, Adjustments);\n  }\n\n  /// Checks that the two Expr's will refer to the same value as a comparison\n  /// operand.  The caller must ensure that the values referenced by the Expr's\n  /// are not modified between E1 and E2 or the result my be invalid.\n  static bool isSameComparisonOperand(const Expr* E1, const Expr* E2);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() >= firstExprConstant &&\n           T->getStmtClass() <= lastExprConstant;\n  }\n};\n// PointerLikeTypeTraits is specialized so it can be used with a forward-decl of\n// Expr. Verify that we got it right.\nstatic_assert(llvm::PointerLikeTypeTraits<Expr *>::NumLowBitsAvailable <=\n                  llvm::detail::ConstantLog2<alignof(Expr)>::value,\n              \"PointerLikeTypeTraits<Expr*> assumes too much alignment.\");\n\nusing ConstantExprKind = Expr::ConstantExprKind;\n\n//===----------------------------------------------------------------------===//\n// Wrapper Expressions.\n//===----------------------------------------------------------------------===//\n\n/// FullExpr - Represents a \"full-expression\" node.\nclass FullExpr : public Expr {\nprotected:\n Stmt *SubExpr;\n\n FullExpr(StmtClass SC, Expr *subexpr)\n     : Expr(SC, subexpr->getType(), subexpr->getValueKind(),\n            subexpr->getObjectKind()),\n       SubExpr(subexpr) {\n   setDependence(computeDependence(this));\n }\n  FullExpr(StmtClass SC, EmptyShell Empty)\n    : Expr(SC, Empty) {}\npublic:\n  const Expr *getSubExpr() const { return cast<Expr>(SubExpr); }\n  Expr *getSubExpr() { return cast<Expr>(SubExpr); }\n\n  /// As with any mutator of the AST, be very careful when modifying an\n  /// existing AST to preserve its invariants.\n  void setSubExpr(Expr *E) { SubExpr = E; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() >= firstFullExprConstant &&\n           T->getStmtClass() <= lastFullExprConstant;\n  }\n};\n\n/// ConstantExpr - An expression that occurs in a constant context and\n/// optionally the result of evaluating the expression.\nclass ConstantExpr final\n    : public FullExpr,\n      private llvm::TrailingObjects<ConstantExpr, APValue, uint64_t> {\n  static_assert(std::is_same<uint64_t, llvm::APInt::WordType>::value,\n                \"ConstantExpr assumes that llvm::APInt::WordType is uint64_t \"\n                \"for tail-allocated storage\");\n  friend TrailingObjects;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\npublic:\n  /// Describes the kind of result that can be tail-allocated.\n  enum ResultStorageKind { RSK_None, RSK_Int64, RSK_APValue };\n\nprivate:\n  size_t numTrailingObjects(OverloadToken<APValue>) const {\n    return ConstantExprBits.ResultKind == ConstantExpr::RSK_APValue;\n  }\n  size_t numTrailingObjects(OverloadToken<uint64_t>) const {\n    return ConstantExprBits.ResultKind == ConstantExpr::RSK_Int64;\n  }\n\n  uint64_t &Int64Result() {\n    assert(ConstantExprBits.ResultKind == ConstantExpr::RSK_Int64 &&\n           \"invalid accessor\");\n    return *getTrailingObjects<uint64_t>();\n  }\n  const uint64_t &Int64Result() const {\n    return const_cast<ConstantExpr *>(this)->Int64Result();\n  }\n  APValue &APValueResult() {\n    assert(ConstantExprBits.ResultKind == ConstantExpr::RSK_APValue &&\n           \"invalid accessor\");\n    return *getTrailingObjects<APValue>();\n  }\n  APValue &APValueResult() const {\n    return const_cast<ConstantExpr *>(this)->APValueResult();\n  }\n\n  ConstantExpr(Expr *SubExpr, ResultStorageKind StorageKind,\n               bool IsImmediateInvocation);\n  ConstantExpr(EmptyShell Empty, ResultStorageKind StorageKind);\n\npublic:\n  static ConstantExpr *Create(const ASTContext &Context, Expr *E,\n                              const APValue &Result);\n  static ConstantExpr *Create(const ASTContext &Context, Expr *E,\n                              ResultStorageKind Storage = RSK_None,\n                              bool IsImmediateInvocation = false);\n  static ConstantExpr *CreateEmpty(const ASTContext &Context,\n                                   ResultStorageKind StorageKind);\n\n  static ResultStorageKind getStorageKind(const APValue &Value);\n  static ResultStorageKind getStorageKind(const Type *T,\n                                          const ASTContext &Context);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return SubExpr->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return SubExpr->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ConstantExprClass;\n  }\n\n  void SetResult(APValue Value, const ASTContext &Context) {\n    MoveIntoResult(Value, Context);\n  }\n  void MoveIntoResult(APValue &Value, const ASTContext &Context);\n\n  APValue::ValueKind getResultAPValueKind() const {\n    return static_cast<APValue::ValueKind>(ConstantExprBits.APValueKind);\n  }\n  ResultStorageKind getResultStorageKind() const {\n    return static_cast<ResultStorageKind>(ConstantExprBits.ResultKind);\n  }\n  bool isImmediateInvocation() const {\n    return ConstantExprBits.IsImmediateInvocation;\n  }\n  bool hasAPValueResult() const {\n    return ConstantExprBits.APValueKind != APValue::None;\n  }\n  APValue getAPValueResult() const;\n  APValue &getResultAsAPValue() const { return APValueResult(); }\n  llvm::APSInt getResultAsAPSInt() const;\n  // Iterators\n  child_range children() { return child_range(&SubExpr, &SubExpr+1); }\n  const_child_range children() const {\n    return const_child_range(&SubExpr, &SubExpr + 1);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Primary Expressions.\n//===----------------------------------------------------------------------===//\n\n/// OpaqueValueExpr - An expression referring to an opaque object of a\n/// fixed type and value class.  These don't correspond to concrete\n/// syntax; instead they're used to express operations (usually copy\n/// operations) on values whose source is generally obvious from\n/// context.\nclass OpaqueValueExpr : public Expr {\n  friend class ASTStmtReader;\n  Expr *SourceExpr;\n\npublic:\n  OpaqueValueExpr(SourceLocation Loc, QualType T, ExprValueKind VK,\n                  ExprObjectKind OK = OK_Ordinary, Expr *SourceExpr = nullptr)\n      : Expr(OpaqueValueExprClass, T, VK, OK), SourceExpr(SourceExpr) {\n    setIsUnique(false);\n    OpaqueValueExprBits.Loc = Loc;\n    setDependence(computeDependence(this));\n  }\n\n  /// Given an expression which invokes a copy constructor --- i.e.  a\n  /// CXXConstructExpr, possibly wrapped in an ExprWithCleanups ---\n  /// find the OpaqueValueExpr that's the source of the construction.\n  static const OpaqueValueExpr *findInCopyConstruct(const Expr *expr);\n\n  explicit OpaqueValueExpr(EmptyShell Empty)\n    : Expr(OpaqueValueExprClass, Empty) {}\n\n  /// Retrieve the location of this expression.\n  SourceLocation getLocation() const { return OpaqueValueExprBits.Loc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return SourceExpr ? SourceExpr->getBeginLoc() : getLocation();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return SourceExpr ? SourceExpr->getEndLoc() : getLocation();\n  }\n  SourceLocation getExprLoc() const LLVM_READONLY {\n    return SourceExpr ? SourceExpr->getExprLoc() : getLocation();\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  /// The source expression of an opaque value expression is the\n  /// expression which originally generated the value.  This is\n  /// provided as a convenience for analyses that don't wish to\n  /// precisely model the execution behavior of the program.\n  ///\n  /// The source expression is typically set when building the\n  /// expression which binds the opaque value expression in the first\n  /// place.\n  Expr *getSourceExpr() const { return SourceExpr; }\n\n  void setIsUnique(bool V) {\n    assert((!V || SourceExpr) &&\n           \"unique OVEs are expected to have source expressions\");\n    OpaqueValueExprBits.IsUnique = V;\n  }\n\n  bool isUnique() const { return OpaqueValueExprBits.IsUnique; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OpaqueValueExprClass;\n  }\n};\n\n/// A reference to a declared variable, function, enum, etc.\n/// [C99 6.5.1p2]\n///\n/// This encodes all the information about how a declaration is referenced\n/// within an expression.\n///\n/// There are several optional constructs attached to DeclRefExprs only when\n/// they apply in order to conserve memory. These are laid out past the end of\n/// the object, and flags in the DeclRefExprBitfield track whether they exist:\n///\n///   DeclRefExprBits.HasQualifier:\n///       Specifies when this declaration reference expression has a C++\n///       nested-name-specifier.\n///   DeclRefExprBits.HasFoundDecl:\n///       Specifies when this declaration reference expression has a record of\n///       a NamedDecl (different from the referenced ValueDecl) which was found\n///       during name lookup and/or overload resolution.\n///   DeclRefExprBits.HasTemplateKWAndArgsInfo:\n///       Specifies when this declaration reference expression has an explicit\n///       C++ template keyword and/or template argument list.\n///   DeclRefExprBits.RefersToEnclosingVariableOrCapture\n///       Specifies when this declaration reference expression (validly)\n///       refers to an enclosed local or a captured variable.\nclass DeclRefExpr final\n    : public Expr,\n      private llvm::TrailingObjects<DeclRefExpr, NestedNameSpecifierLoc,\n                                    NamedDecl *, ASTTemplateKWAndArgsInfo,\n                                    TemplateArgumentLoc> {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// The declaration that we are referencing.\n  ValueDecl *D;\n\n  /// Provides source/type location info for the declaration name\n  /// embedded in D.\n  DeclarationNameLoc DNLoc;\n\n  size_t numTrailingObjects(OverloadToken<NestedNameSpecifierLoc>) const {\n    return hasQualifier();\n  }\n\n  size_t numTrailingObjects(OverloadToken<NamedDecl *>) const {\n    return hasFoundDecl();\n  }\n\n  size_t numTrailingObjects(OverloadToken<ASTTemplateKWAndArgsInfo>) const {\n    return hasTemplateKWAndArgsInfo();\n  }\n\n  /// Test whether there is a distinct FoundDecl attached to the end of\n  /// this DRE.\n  bool hasFoundDecl() const { return DeclRefExprBits.HasFoundDecl; }\n\n  DeclRefExpr(const ASTContext &Ctx, NestedNameSpecifierLoc QualifierLoc,\n              SourceLocation TemplateKWLoc, ValueDecl *D,\n              bool RefersToEnlosingVariableOrCapture,\n              const DeclarationNameInfo &NameInfo, NamedDecl *FoundD,\n              const TemplateArgumentListInfo *TemplateArgs, QualType T,\n              ExprValueKind VK, NonOdrUseReason NOUR);\n\n  /// Construct an empty declaration reference expression.\n  explicit DeclRefExpr(EmptyShell Empty) : Expr(DeclRefExprClass, Empty) {}\n\npublic:\n  DeclRefExpr(const ASTContext &Ctx, ValueDecl *D,\n              bool RefersToEnclosingVariableOrCapture, QualType T,\n              ExprValueKind VK, SourceLocation L,\n              const DeclarationNameLoc &LocInfo = DeclarationNameLoc(),\n              NonOdrUseReason NOUR = NOUR_None);\n\n  static DeclRefExpr *\n  Create(const ASTContext &Context, NestedNameSpecifierLoc QualifierLoc,\n         SourceLocation TemplateKWLoc, ValueDecl *D,\n         bool RefersToEnclosingVariableOrCapture, SourceLocation NameLoc,\n         QualType T, ExprValueKind VK, NamedDecl *FoundD = nullptr,\n         const TemplateArgumentListInfo *TemplateArgs = nullptr,\n         NonOdrUseReason NOUR = NOUR_None);\n\n  static DeclRefExpr *\n  Create(const ASTContext &Context, NestedNameSpecifierLoc QualifierLoc,\n         SourceLocation TemplateKWLoc, ValueDecl *D,\n         bool RefersToEnclosingVariableOrCapture,\n         const DeclarationNameInfo &NameInfo, QualType T, ExprValueKind VK,\n         NamedDecl *FoundD = nullptr,\n         const TemplateArgumentListInfo *TemplateArgs = nullptr,\n         NonOdrUseReason NOUR = NOUR_None);\n\n  /// Construct an empty declaration reference expression.\n  static DeclRefExpr *CreateEmpty(const ASTContext &Context, bool HasQualifier,\n                                  bool HasFoundDecl,\n                                  bool HasTemplateKWAndArgsInfo,\n                                  unsigned NumTemplateArgs);\n\n  ValueDecl *getDecl() { return D; }\n  const ValueDecl *getDecl() const { return D; }\n  void setDecl(ValueDecl *NewD);\n\n  DeclarationNameInfo getNameInfo() const {\n    return DeclarationNameInfo(getDecl()->getDeclName(), getLocation(), DNLoc);\n  }\n\n  SourceLocation getLocation() const { return DeclRefExprBits.Loc; }\n  void setLocation(SourceLocation L) { DeclRefExprBits.Loc = L; }\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  /// Determine whether this declaration reference was preceded by a\n  /// C++ nested-name-specifier, e.g., \\c N::foo.\n  bool hasQualifier() const { return DeclRefExprBits.HasQualifier; }\n\n  /// If the name was qualified, retrieves the nested-name-specifier\n  /// that precedes the name, with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const {\n    if (!hasQualifier())\n      return NestedNameSpecifierLoc();\n    return *getTrailingObjects<NestedNameSpecifierLoc>();\n  }\n\n  /// If the name was qualified, retrieves the nested-name-specifier\n  /// that precedes the name. Otherwise, returns NULL.\n  NestedNameSpecifier *getQualifier() const {\n    return getQualifierLoc().getNestedNameSpecifier();\n  }\n\n  /// Get the NamedDecl through which this reference occurred.\n  ///\n  /// This Decl may be different from the ValueDecl actually referred to in the\n  /// presence of using declarations, etc. It always returns non-NULL, and may\n  /// simple return the ValueDecl when appropriate.\n\n  NamedDecl *getFoundDecl() {\n    return hasFoundDecl() ? *getTrailingObjects<NamedDecl *>() : D;\n  }\n\n  /// Get the NamedDecl through which this reference occurred.\n  /// See non-const variant.\n  const NamedDecl *getFoundDecl() const {\n    return hasFoundDecl() ? *getTrailingObjects<NamedDecl *>() : D;\n  }\n\n  bool hasTemplateKWAndArgsInfo() const {\n    return DeclRefExprBits.HasTemplateKWAndArgsInfo;\n  }\n\n  /// Retrieve the location of the template keyword preceding\n  /// this name, if any.\n  SourceLocation getTemplateKeywordLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->TemplateKWLoc;\n  }\n\n  /// Retrieve the location of the left angle bracket starting the\n  /// explicit template argument list following the name, if any.\n  SourceLocation getLAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->LAngleLoc;\n  }\n\n  /// Retrieve the location of the right angle bracket ending the\n  /// explicit template argument list following the name, if any.\n  SourceLocation getRAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->RAngleLoc;\n  }\n\n  /// Determines whether the name in this declaration reference\n  /// was preceded by the template keyword.\n  bool hasTemplateKeyword() const { return getTemplateKeywordLoc().isValid(); }\n\n  /// Determines whether this declaration reference was followed by an\n  /// explicit template argument list.\n  bool hasExplicitTemplateArgs() const { return getLAngleLoc().isValid(); }\n\n  /// Copies the template arguments (if present) into the given\n  /// structure.\n  void copyTemplateArgumentsInto(TemplateArgumentListInfo &List) const {\n    if (hasExplicitTemplateArgs())\n      getTrailingObjects<ASTTemplateKWAndArgsInfo>()->copyInto(\n          getTrailingObjects<TemplateArgumentLoc>(), List);\n  }\n\n  /// Retrieve the template arguments provided as part of this\n  /// template-id.\n  const TemplateArgumentLoc *getTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return nullptr;\n    return getTrailingObjects<TemplateArgumentLoc>();\n  }\n\n  /// Retrieve the number of template arguments provided as part of this\n  /// template-id.\n  unsigned getNumTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return 0;\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->NumTemplateArgs;\n  }\n\n  ArrayRef<TemplateArgumentLoc> template_arguments() const {\n    return {getTemplateArgs(), getNumTemplateArgs()};\n  }\n\n  /// Returns true if this expression refers to a function that\n  /// was resolved from an overloaded set having size greater than 1.\n  bool hadMultipleCandidates() const {\n    return DeclRefExprBits.HadMultipleCandidates;\n  }\n  /// Sets the flag telling whether this expression refers to\n  /// a function that was resolved from an overloaded set having size\n  /// greater than 1.\n  void setHadMultipleCandidates(bool V = true) {\n    DeclRefExprBits.HadMultipleCandidates = V;\n  }\n\n  /// Is this expression a non-odr-use reference, and if so, why?\n  NonOdrUseReason isNonOdrUse() const {\n    return static_cast<NonOdrUseReason>(DeclRefExprBits.NonOdrUseReason);\n  }\n\n  /// Does this DeclRefExpr refer to an enclosing local or a captured\n  /// variable?\n  bool refersToEnclosingVariableOrCapture() const {\n    return DeclRefExprBits.RefersToEnclosingVariableOrCapture;\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == DeclRefExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Used by IntegerLiteral/FloatingLiteral to store the numeric without\n/// leaking memory.\n///\n/// For large floats/integers, APFloat/APInt will allocate memory from the heap\n/// to represent these numbers.  Unfortunately, when we use a BumpPtrAllocator\n/// to allocate IntegerLiteral/FloatingLiteral nodes the memory associated with\n/// the APFloat/APInt values will never get freed. APNumericStorage uses\n/// ASTContext's allocator for memory allocation.\nclass APNumericStorage {\n  union {\n    uint64_t VAL;    ///< Used to store the <= 64 bits integer value.\n    uint64_t *pVal;  ///< Used to store the >64 bits integer value.\n  };\n  unsigned BitWidth;\n\n  bool hasAllocation() const { return llvm::APInt::getNumWords(BitWidth) > 1; }\n\n  APNumericStorage(const APNumericStorage &) = delete;\n  void operator=(const APNumericStorage &) = delete;\n\nprotected:\n  APNumericStorage() : VAL(0), BitWidth(0) { }\n\n  llvm::APInt getIntValue() const {\n    unsigned NumWords = llvm::APInt::getNumWords(BitWidth);\n    if (NumWords > 1)\n      return llvm::APInt(BitWidth, NumWords, pVal);\n    else\n      return llvm::APInt(BitWidth, VAL);\n  }\n  void setIntValue(const ASTContext &C, const llvm::APInt &Val);\n};\n\nclass APIntStorage : private APNumericStorage {\npublic:\n  llvm::APInt getValue() const { return getIntValue(); }\n  void setValue(const ASTContext &C, const llvm::APInt &Val) {\n    setIntValue(C, Val);\n  }\n};\n\nclass APFloatStorage : private APNumericStorage {\npublic:\n  llvm::APFloat getValue(const llvm::fltSemantics &Semantics) const {\n    return llvm::APFloat(Semantics, getIntValue());\n  }\n  void setValue(const ASTContext &C, const llvm::APFloat &Val) {\n    setIntValue(C, Val.bitcastToAPInt());\n  }\n};\n\nclass IntegerLiteral : public Expr, public APIntStorage {\n  SourceLocation Loc;\n\n  /// Construct an empty integer literal.\n  explicit IntegerLiteral(EmptyShell Empty)\n    : Expr(IntegerLiteralClass, Empty) { }\n\npublic:\n  // type should be IntTy, LongTy, LongLongTy, UnsignedIntTy, UnsignedLongTy,\n  // or UnsignedLongLongTy\n  IntegerLiteral(const ASTContext &C, const llvm::APInt &V, QualType type,\n                 SourceLocation l);\n\n  /// Returns a new integer literal with value 'V' and type 'type'.\n  /// \\param type - either IntTy, LongTy, LongLongTy, UnsignedIntTy,\n  /// UnsignedLongTy, or UnsignedLongLongTy which should match the size of V\n  /// \\param V - the value that the returned integer literal contains.\n  static IntegerLiteral *Create(const ASTContext &C, const llvm::APInt &V,\n                                QualType type, SourceLocation l);\n  /// Returns a new empty integer literal.\n  static IntegerLiteral *Create(const ASTContext &C, EmptyShell Empty);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Loc; }\n\n  /// Retrieve the location of the literal.\n  SourceLocation getLocation() const { return Loc; }\n\n  void setLocation(SourceLocation Location) { Loc = Location; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == IntegerLiteralClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\nclass FixedPointLiteral : public Expr, public APIntStorage {\n  SourceLocation Loc;\n  unsigned Scale;\n\n  /// \\brief Construct an empty fixed-point literal.\n  explicit FixedPointLiteral(EmptyShell Empty)\n      : Expr(FixedPointLiteralClass, Empty) {}\n\n public:\n  FixedPointLiteral(const ASTContext &C, const llvm::APInt &V, QualType type,\n                    SourceLocation l, unsigned Scale);\n\n  // Store the int as is without any bit shifting.\n  static FixedPointLiteral *CreateFromRawInt(const ASTContext &C,\n                                             const llvm::APInt &V,\n                                             QualType type, SourceLocation l,\n                                             unsigned Scale);\n\n  /// Returns an empty fixed-point literal.\n  static FixedPointLiteral *Create(const ASTContext &C, EmptyShell Empty);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Loc; }\n\n  /// \\brief Retrieve the location of the literal.\n  SourceLocation getLocation() const { return Loc; }\n\n  void setLocation(SourceLocation Location) { Loc = Location; }\n\n  unsigned getScale() const { return Scale; }\n  void setScale(unsigned S) { Scale = S; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == FixedPointLiteralClass;\n  }\n\n  std::string getValueAsString(unsigned Radix) const;\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\nclass CharacterLiteral : public Expr {\npublic:\n  enum CharacterKind {\n    Ascii,\n    Wide,\n    UTF8,\n    UTF16,\n    UTF32\n  };\n\nprivate:\n  unsigned Value;\n  SourceLocation Loc;\npublic:\n  // type should be IntTy\n  CharacterLiteral(unsigned value, CharacterKind kind, QualType type,\n                   SourceLocation l)\n      : Expr(CharacterLiteralClass, type, VK_RValue, OK_Ordinary), Value(value),\n        Loc(l) {\n    CharacterLiteralBits.Kind = kind;\n    setDependence(ExprDependence::None);\n  }\n\n  /// Construct an empty character literal.\n  CharacterLiteral(EmptyShell Empty) : Expr(CharacterLiteralClass, Empty) { }\n\n  SourceLocation getLocation() const { return Loc; }\n  CharacterKind getKind() const {\n    return static_cast<CharacterKind>(CharacterLiteralBits.Kind);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Loc; }\n\n  unsigned getValue() const { return Value; }\n\n  void setLocation(SourceLocation Location) { Loc = Location; }\n  void setKind(CharacterKind kind) { CharacterLiteralBits.Kind = kind; }\n  void setValue(unsigned Val) { Value = Val; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CharacterLiteralClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\nclass FloatingLiteral : public Expr, private APFloatStorage {\n  SourceLocation Loc;\n\n  FloatingLiteral(const ASTContext &C, const llvm::APFloat &V, bool isexact,\n                  QualType Type, SourceLocation L);\n\n  /// Construct an empty floating-point literal.\n  explicit FloatingLiteral(const ASTContext &C, EmptyShell Empty);\n\npublic:\n  static FloatingLiteral *Create(const ASTContext &C, const llvm::APFloat &V,\n                                 bool isexact, QualType Type, SourceLocation L);\n  static FloatingLiteral *Create(const ASTContext &C, EmptyShell Empty);\n\n  llvm::APFloat getValue() const {\n    return APFloatStorage::getValue(getSemantics());\n  }\n  void setValue(const ASTContext &C, const llvm::APFloat &Val) {\n    assert(&getSemantics() == &Val.getSemantics() && \"Inconsistent semantics\");\n    APFloatStorage::setValue(C, Val);\n  }\n\n  /// Get a raw enumeration value representing the floating-point semantics of\n  /// this literal (32-bit IEEE, x87, ...), suitable for serialisation.\n  llvm::APFloatBase::Semantics getRawSemantics() const {\n    return static_cast<llvm::APFloatBase::Semantics>(\n        FloatingLiteralBits.Semantics);\n  }\n\n  /// Set the raw enumeration value representing the floating-point semantics of\n  /// this literal (32-bit IEEE, x87, ...), suitable for serialisation.\n  void setRawSemantics(llvm::APFloatBase::Semantics Sem) {\n    FloatingLiteralBits.Semantics = Sem;\n  }\n\n  /// Return the APFloat semantics this literal uses.\n  const llvm::fltSemantics &getSemantics() const {\n    return llvm::APFloatBase::EnumToSemantics(\n        static_cast<llvm::APFloatBase::Semantics>(\n            FloatingLiteralBits.Semantics));\n  }\n\n  /// Set the APFloat semantics this literal uses.\n  void setSemantics(const llvm::fltSemantics &Sem) {\n    FloatingLiteralBits.Semantics = llvm::APFloatBase::SemanticsToEnum(Sem);\n  }\n\n  bool isExact() const { return FloatingLiteralBits.IsExact; }\n  void setExact(bool E) { FloatingLiteralBits.IsExact = E; }\n\n  /// getValueAsApproximateDouble - This returns the value as an inaccurate\n  /// double.  Note that this may cause loss of precision, but is useful for\n  /// debugging dumps, etc.\n  double getValueAsApproximateDouble() const;\n\n  SourceLocation getLocation() const { return Loc; }\n  void setLocation(SourceLocation L) { Loc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Loc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == FloatingLiteralClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// ImaginaryLiteral - We support imaginary integer and floating point literals,\n/// like \"1.0i\".  We represent these as a wrapper around FloatingLiteral and\n/// IntegerLiteral classes.  Instances of this class always have a Complex type\n/// whose element type matches the subexpression.\n///\nclass ImaginaryLiteral : public Expr {\n  Stmt *Val;\npublic:\n  ImaginaryLiteral(Expr *val, QualType Ty)\n      : Expr(ImaginaryLiteralClass, Ty, VK_RValue, OK_Ordinary), Val(val) {\n    setDependence(ExprDependence::None);\n  }\n\n  /// Build an empty imaginary literal.\n  explicit ImaginaryLiteral(EmptyShell Empty)\n    : Expr(ImaginaryLiteralClass, Empty) { }\n\n  const Expr *getSubExpr() const { return cast<Expr>(Val); }\n  Expr *getSubExpr() { return cast<Expr>(Val); }\n  void setSubExpr(Expr *E) { Val = E; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return Val->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Val->getEndLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ImaginaryLiteralClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Val, &Val+1); }\n  const_child_range children() const {\n    return const_child_range(&Val, &Val + 1);\n  }\n};\n\n/// StringLiteral - This represents a string literal expression, e.g. \"foo\"\n/// or L\"bar\" (wide strings). The actual string data can be obtained with\n/// getBytes() and is NOT null-terminated. The length of the string data is\n/// determined by calling getByteLength().\n///\n/// The C type for a string is always a ConstantArrayType. In C++, the char\n/// type is const qualified, in C it is not.\n///\n/// Note that strings in C can be formed by concatenation of multiple string\n/// literal pptokens in translation phase #6. This keeps track of the locations\n/// of each of these pieces.\n///\n/// Strings in C can also be truncated and extended by assigning into arrays,\n/// e.g. with constructs like:\n///   char X[2] = \"foobar\";\n/// In this case, getByteLength() will return 6, but the string literal will\n/// have type \"char[2]\".\nclass StringLiteral final\n    : public Expr,\n      private llvm::TrailingObjects<StringLiteral, unsigned, SourceLocation,\n                                    char> {\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  /// StringLiteral is followed by several trailing objects. They are in order:\n  ///\n  /// * A single unsigned storing the length in characters of this string. The\n  ///   length in bytes is this length times the width of a single character.\n  ///   Always present and stored as a trailing objects because storing it in\n  ///   StringLiteral would increase the size of StringLiteral by sizeof(void *)\n  ///   due to alignment requirements. If you add some data to StringLiteral,\n  ///   consider moving it inside StringLiteral.\n  ///\n  /// * An array of getNumConcatenated() SourceLocation, one for each of the\n  ///   token this string is made of.\n  ///\n  /// * An array of getByteLength() char used to store the string data.\n\npublic:\n  enum StringKind { Ascii, Wide, UTF8, UTF16, UTF32 };\n\nprivate:\n  unsigned numTrailingObjects(OverloadToken<unsigned>) const { return 1; }\n  unsigned numTrailingObjects(OverloadToken<SourceLocation>) const {\n    return getNumConcatenated();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<char>) const {\n    return getByteLength();\n  }\n\n  char *getStrDataAsChar() { return getTrailingObjects<char>(); }\n  const char *getStrDataAsChar() const { return getTrailingObjects<char>(); }\n\n  const uint16_t *getStrDataAsUInt16() const {\n    return reinterpret_cast<const uint16_t *>(getTrailingObjects<char>());\n  }\n\n  const uint32_t *getStrDataAsUInt32() const {\n    return reinterpret_cast<const uint32_t *>(getTrailingObjects<char>());\n  }\n\n  /// Build a string literal.\n  StringLiteral(const ASTContext &Ctx, StringRef Str, StringKind Kind,\n                bool Pascal, QualType Ty, const SourceLocation *Loc,\n                unsigned NumConcatenated);\n\n  /// Build an empty string literal.\n  StringLiteral(EmptyShell Empty, unsigned NumConcatenated, unsigned Length,\n                unsigned CharByteWidth);\n\n  /// Map a target and string kind to the appropriate character width.\n  static unsigned mapCharByteWidth(TargetInfo const &Target, StringKind SK);\n\n  /// Set one of the string literal token.\n  void setStrTokenLoc(unsigned TokNum, SourceLocation L) {\n    assert(TokNum < getNumConcatenated() && \"Invalid tok number\");\n    getTrailingObjects<SourceLocation>()[TokNum] = L;\n  }\n\npublic:\n  /// This is the \"fully general\" constructor that allows representation of\n  /// strings formed from multiple concatenated tokens.\n  static StringLiteral *Create(const ASTContext &Ctx, StringRef Str,\n                               StringKind Kind, bool Pascal, QualType Ty,\n                               const SourceLocation *Loc,\n                               unsigned NumConcatenated);\n\n  /// Simple constructor for string literals made from one token.\n  static StringLiteral *Create(const ASTContext &Ctx, StringRef Str,\n                               StringKind Kind, bool Pascal, QualType Ty,\n                               SourceLocation Loc) {\n    return Create(Ctx, Str, Kind, Pascal, Ty, &Loc, 1);\n  }\n\n  /// Construct an empty string literal.\n  static StringLiteral *CreateEmpty(const ASTContext &Ctx,\n                                    unsigned NumConcatenated, unsigned Length,\n                                    unsigned CharByteWidth);\n\n  StringRef getString() const {\n    assert(getCharByteWidth() == 1 &&\n           \"This function is used in places that assume strings use char\");\n    return StringRef(getStrDataAsChar(), getByteLength());\n  }\n\n  /// Allow access to clients that need the byte representation, such as\n  /// ASTWriterStmt::VisitStringLiteral().\n  StringRef getBytes() const {\n    // FIXME: StringRef may not be the right type to use as a result for this.\n    return StringRef(getStrDataAsChar(), getByteLength());\n  }\n\n  void outputString(raw_ostream &OS) const;\n\n  uint32_t getCodeUnit(size_t i) const {\n    assert(i < getLength() && \"out of bounds access\");\n    switch (getCharByteWidth()) {\n    case 1:\n      return static_cast<unsigned char>(getStrDataAsChar()[i]);\n    case 2:\n      return getStrDataAsUInt16()[i];\n    case 4:\n      return getStrDataAsUInt32()[i];\n    }\n    llvm_unreachable(\"Unsupported character width!\");\n  }\n\n  unsigned getByteLength() const { return getCharByteWidth() * getLength(); }\n  unsigned getLength() const { return *getTrailingObjects<unsigned>(); }\n  unsigned getCharByteWidth() const { return StringLiteralBits.CharByteWidth; }\n\n  StringKind getKind() const {\n    return static_cast<StringKind>(StringLiteralBits.Kind);\n  }\n\n  bool isAscii() const { return getKind() == Ascii; }\n  bool isWide() const { return getKind() == Wide; }\n  bool isUTF8() const { return getKind() == UTF8; }\n  bool isUTF16() const { return getKind() == UTF16; }\n  bool isUTF32() const { return getKind() == UTF32; }\n  bool isPascal() const { return StringLiteralBits.IsPascal; }\n\n  bool containsNonAscii() const {\n    for (auto c : getString())\n      if (!isASCII(c))\n        return true;\n    return false;\n  }\n\n  bool containsNonAsciiOrNull() const {\n    for (auto c : getString())\n      if (!isASCII(c) || !c)\n        return true;\n    return false;\n  }\n\n  /// getNumConcatenated - Get the number of string literal tokens that were\n  /// concatenated in translation phase #6 to form this string literal.\n  unsigned getNumConcatenated() const {\n    return StringLiteralBits.NumConcatenated;\n  }\n\n  /// Get one of the string literal token.\n  SourceLocation getStrTokenLoc(unsigned TokNum) const {\n    assert(TokNum < getNumConcatenated() && \"Invalid tok number\");\n    return getTrailingObjects<SourceLocation>()[TokNum];\n  }\n\n  /// getLocationOfByte - Return a source location that points to the specified\n  /// byte of this string literal.\n  ///\n  /// Strings are amazingly complex.  They can be formed from multiple tokens\n  /// and can have escape sequences in them in addition to the usual trigraph\n  /// and escaped newline business.  This routine handles this complexity.\n  ///\n  SourceLocation\n  getLocationOfByte(unsigned ByteNo, const SourceManager &SM,\n                    const LangOptions &Features, const TargetInfo &Target,\n                    unsigned *StartToken = nullptr,\n                    unsigned *StartTokenByteOffset = nullptr) const;\n\n  typedef const SourceLocation *tokloc_iterator;\n\n  tokloc_iterator tokloc_begin() const {\n    return getTrailingObjects<SourceLocation>();\n  }\n\n  tokloc_iterator tokloc_end() const {\n    return getTrailingObjects<SourceLocation>() + getNumConcatenated();\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return *tokloc_begin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return *(tokloc_end() - 1); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == StringLiteralClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// [C99 6.4.2.2] - A predefined identifier such as __func__.\nclass PredefinedExpr final\n    : public Expr,\n      private llvm::TrailingObjects<PredefinedExpr, Stmt *> {\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  // PredefinedExpr is optionally followed by a single trailing\n  // \"Stmt *\" for the predefined identifier. It is present if and only if\n  // hasFunctionName() is true and is always a \"StringLiteral *\".\n\npublic:\n  enum IdentKind {\n    Func,\n    Function,\n    LFunction, // Same as Function, but as wide string.\n    FuncDName,\n    FuncSig,\n    LFuncSig, // Same as FuncSig, but as as wide string\n    PrettyFunction,\n    /// The same as PrettyFunction, except that the\n    /// 'virtual' keyword is omitted for virtual member functions.\n    PrettyFunctionNoVirtual\n  };\n\nprivate:\n  PredefinedExpr(SourceLocation L, QualType FNTy, IdentKind IK,\n                 StringLiteral *SL);\n\n  explicit PredefinedExpr(EmptyShell Empty, bool HasFunctionName);\n\n  /// True if this PredefinedExpr has storage for a function name.\n  bool hasFunctionName() const { return PredefinedExprBits.HasFunctionName; }\n\n  void setFunctionName(StringLiteral *SL) {\n    assert(hasFunctionName() &&\n           \"This PredefinedExpr has no storage for a function name!\");\n    *getTrailingObjects<Stmt *>() = SL;\n  }\n\npublic:\n  /// Create a PredefinedExpr.\n  static PredefinedExpr *Create(const ASTContext &Ctx, SourceLocation L,\n                                QualType FNTy, IdentKind IK, StringLiteral *SL);\n\n  /// Create an empty PredefinedExpr.\n  static PredefinedExpr *CreateEmpty(const ASTContext &Ctx,\n                                     bool HasFunctionName);\n\n  IdentKind getIdentKind() const {\n    return static_cast<IdentKind>(PredefinedExprBits.Kind);\n  }\n\n  SourceLocation getLocation() const { return PredefinedExprBits.Loc; }\n  void setLocation(SourceLocation L) { PredefinedExprBits.Loc = L; }\n\n  StringLiteral *getFunctionName() {\n    return hasFunctionName()\n               ? static_cast<StringLiteral *>(*getTrailingObjects<Stmt *>())\n               : nullptr;\n  }\n\n  const StringLiteral *getFunctionName() const {\n    return hasFunctionName()\n               ? static_cast<StringLiteral *>(*getTrailingObjects<Stmt *>())\n               : nullptr;\n  }\n\n  static StringRef getIdentKindName(IdentKind IK);\n  StringRef getIdentKindName() const {\n    return getIdentKindName(getIdentKind());\n  }\n\n  static std::string ComputeName(IdentKind IK, const Decl *CurrentDecl);\n\n  SourceLocation getBeginLoc() const { return getLocation(); }\n  SourceLocation getEndLoc() const { return getLocation(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == PredefinedExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(getTrailingObjects<Stmt *>(),\n                       getTrailingObjects<Stmt *>() + hasFunctionName());\n  }\n\n  const_child_range children() const {\n    return const_child_range(getTrailingObjects<Stmt *>(),\n                             getTrailingObjects<Stmt *>() + hasFunctionName());\n  }\n};\n\n/// ParenExpr - This represents a parethesized expression, e.g. \"(1)\".  This\n/// AST node is only formed if full location information is requested.\nclass ParenExpr : public Expr {\n  SourceLocation L, R;\n  Stmt *Val;\npublic:\n  ParenExpr(SourceLocation l, SourceLocation r, Expr *val)\n      : Expr(ParenExprClass, val->getType(), val->getValueKind(),\n             val->getObjectKind()),\n        L(l), R(r), Val(val) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Construct an empty parenthesized expression.\n  explicit ParenExpr(EmptyShell Empty)\n    : Expr(ParenExprClass, Empty) { }\n\n  const Expr *getSubExpr() const { return cast<Expr>(Val); }\n  Expr *getSubExpr() { return cast<Expr>(Val); }\n  void setSubExpr(Expr *E) { Val = E; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return L; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return R; }\n\n  /// Get the location of the left parentheses '('.\n  SourceLocation getLParen() const { return L; }\n  void setLParen(SourceLocation Loc) { L = Loc; }\n\n  /// Get the location of the right parentheses ')'.\n  SourceLocation getRParen() const { return R; }\n  void setRParen(SourceLocation Loc) { R = Loc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ParenExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Val, &Val+1); }\n  const_child_range children() const {\n    return const_child_range(&Val, &Val + 1);\n  }\n};\n\n/// UnaryOperator - This represents the unary-expression's (except sizeof and\n/// alignof), the postinc/postdec operators from postfix-expression, and various\n/// extensions.\n///\n/// Notes on various nodes:\n///\n/// Real/Imag - These return the real/imag part of a complex operand.  If\n///   applied to a non-complex value, the former returns its operand and the\n///   later returns zero in the type of the operand.\n///\nclass UnaryOperator final\n    : public Expr,\n      private llvm::TrailingObjects<UnaryOperator, FPOptionsOverride> {\n  Stmt *Val;\n\n  size_t numTrailingObjects(OverloadToken<FPOptionsOverride>) const {\n    return UnaryOperatorBits.HasFPFeatures ? 1 : 0;\n  }\n\n  FPOptionsOverride &getTrailingFPFeatures() {\n    assert(UnaryOperatorBits.HasFPFeatures);\n    return *getTrailingObjects<FPOptionsOverride>();\n  }\n\n  const FPOptionsOverride &getTrailingFPFeatures() const {\n    assert(UnaryOperatorBits.HasFPFeatures);\n    return *getTrailingObjects<FPOptionsOverride>();\n  }\n\npublic:\n  typedef UnaryOperatorKind Opcode;\n\nprotected:\n  UnaryOperator(const ASTContext &Ctx, Expr *input, Opcode opc, QualType type,\n                ExprValueKind VK, ExprObjectKind OK, SourceLocation l,\n                bool CanOverflow, FPOptionsOverride FPFeatures);\n\n  /// Build an empty unary operator.\n  explicit UnaryOperator(bool HasFPFeatures, EmptyShell Empty)\n      : Expr(UnaryOperatorClass, Empty) {\n    UnaryOperatorBits.Opc = UO_AddrOf;\n    UnaryOperatorBits.HasFPFeatures = HasFPFeatures;\n  }\n\npublic:\n  static UnaryOperator *CreateEmpty(const ASTContext &C, bool hasFPFeatures);\n\n  static UnaryOperator *Create(const ASTContext &C, Expr *input, Opcode opc,\n                               QualType type, ExprValueKind VK,\n                               ExprObjectKind OK, SourceLocation l,\n                               bool CanOverflow, FPOptionsOverride FPFeatures);\n\n  Opcode getOpcode() const {\n    return static_cast<Opcode>(UnaryOperatorBits.Opc);\n  }\n  void setOpcode(Opcode Opc) { UnaryOperatorBits.Opc = Opc; }\n\n  Expr *getSubExpr() const { return cast<Expr>(Val); }\n  void setSubExpr(Expr *E) { Val = E; }\n\n  /// getOperatorLoc - Return the location of the operator.\n  SourceLocation getOperatorLoc() const { return UnaryOperatorBits.Loc; }\n  void setOperatorLoc(SourceLocation L) { UnaryOperatorBits.Loc = L; }\n\n  /// Returns true if the unary operator can cause an overflow. For instance,\n  ///   signed int i = INT_MAX; i++;\n  ///   signed char c = CHAR_MAX; c++;\n  /// Due to integer promotions, c++ is promoted to an int before the postfix\n  /// increment, and the result is an int that cannot overflow. However, i++\n  /// can overflow.\n  bool canOverflow() const { return UnaryOperatorBits.CanOverflow; }\n  void setCanOverflow(bool C) { UnaryOperatorBits.CanOverflow = C; }\n\n  // Get the FP contractability status of this operator. Only meaningful for\n  // operations on floating point types.\n  bool isFPContractableWithinStatement(const LangOptions &LO) const {\n    return getFPFeaturesInEffect(LO).allowFPContractWithinStatement();\n  }\n\n  // Get the FENV_ACCESS status of this operator. Only meaningful for\n  // operations on floating point types.\n  bool isFEnvAccessOn(const LangOptions &LO) const {\n    return getFPFeaturesInEffect(LO).getAllowFEnvAccess();\n  }\n\n  /// isPostfix - Return true if this is a postfix operation, like x++.\n  static bool isPostfix(Opcode Op) {\n    return Op == UO_PostInc || Op == UO_PostDec;\n  }\n\n  /// isPrefix - Return true if this is a prefix operation, like --x.\n  static bool isPrefix(Opcode Op) {\n    return Op == UO_PreInc || Op == UO_PreDec;\n  }\n\n  bool isPrefix() const { return isPrefix(getOpcode()); }\n  bool isPostfix() const { return isPostfix(getOpcode()); }\n\n  static bool isIncrementOp(Opcode Op) {\n    return Op == UO_PreInc || Op == UO_PostInc;\n  }\n  bool isIncrementOp() const {\n    return isIncrementOp(getOpcode());\n  }\n\n  static bool isDecrementOp(Opcode Op) {\n    return Op == UO_PreDec || Op == UO_PostDec;\n  }\n  bool isDecrementOp() const {\n    return isDecrementOp(getOpcode());\n  }\n\n  static bool isIncrementDecrementOp(Opcode Op) { return Op <= UO_PreDec; }\n  bool isIncrementDecrementOp() const {\n    return isIncrementDecrementOp(getOpcode());\n  }\n\n  static bool isArithmeticOp(Opcode Op) {\n    return Op >= UO_Plus && Op <= UO_LNot;\n  }\n  bool isArithmeticOp() const { return isArithmeticOp(getOpcode()); }\n\n  /// getOpcodeStr - Turn an Opcode enum value into the punctuation char it\n  /// corresponds to, e.g. \"sizeof\" or \"[pre]++\"\n  static StringRef getOpcodeStr(Opcode Op);\n\n  /// Retrieve the unary opcode that corresponds to the given\n  /// overloaded operator.\n  static Opcode getOverloadedOpcode(OverloadedOperatorKind OO, bool Postfix);\n\n  /// Retrieve the overloaded operator kind that corresponds to\n  /// the given unary opcode.\n  static OverloadedOperatorKind getOverloadedOperator(Opcode Opc);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return isPostfix() ? Val->getBeginLoc() : getOperatorLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return isPostfix() ? getOperatorLoc() : Val->getEndLoc();\n  }\n  SourceLocation getExprLoc() const { return getOperatorLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == UnaryOperatorClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Val, &Val+1); }\n  const_child_range children() const {\n    return const_child_range(&Val, &Val + 1);\n  }\n\n  /// Is FPFeatures in Trailing Storage?\n  bool hasStoredFPFeatures() const { return UnaryOperatorBits.HasFPFeatures; }\n\n  /// Get FPFeatures from trailing storage.\n  FPOptionsOverride getStoredFPFeatures() const {\n    return getTrailingFPFeatures();\n  }\n\nprotected:\n  /// Set FPFeatures in trailing storage, used only by Serialization\n  void setStoredFPFeatures(FPOptionsOverride F) { getTrailingFPFeatures() = F; }\n\npublic:\n  // Get the FP features status of this operator. Only meaningful for\n  // operations on floating point types.\n  FPOptions getFPFeaturesInEffect(const LangOptions &LO) const {\n    if (UnaryOperatorBits.HasFPFeatures)\n      return getStoredFPFeatures().applyOverrides(LO);\n    return FPOptions::defaultWithoutTrailingStorage(LO);\n  }\n  FPOptionsOverride getFPOptionsOverride() const {\n    if (UnaryOperatorBits.HasFPFeatures)\n      return getStoredFPFeatures();\n    return FPOptionsOverride();\n  }\n\n  friend TrailingObjects;\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n};\n\n/// Helper class for OffsetOfExpr.\n\n// __builtin_offsetof(type, identifier(.identifier|[expr])*)\nclass OffsetOfNode {\npublic:\n  /// The kind of offsetof node we have.\n  enum Kind {\n    /// An index into an array.\n    Array = 0x00,\n    /// A field.\n    Field = 0x01,\n    /// A field in a dependent type, known only by its name.\n    Identifier = 0x02,\n    /// An implicit indirection through a C++ base class, when the\n    /// field found is in a base class.\n    Base = 0x03\n  };\n\nprivate:\n  enum { MaskBits = 2, Mask = 0x03 };\n\n  /// The source range that covers this part of the designator.\n  SourceRange Range;\n\n  /// The data describing the designator, which comes in three\n  /// different forms, depending on the lower two bits.\n  ///   - An unsigned index into the array of Expr*'s stored after this node\n  ///     in memory, for [constant-expression] designators.\n  ///   - A FieldDecl*, for references to a known field.\n  ///   - An IdentifierInfo*, for references to a field with a given name\n  ///     when the class type is dependent.\n  ///   - A CXXBaseSpecifier*, for references that look at a field in a\n  ///     base class.\n  uintptr_t Data;\n\npublic:\n  /// Create an offsetof node that refers to an array element.\n  OffsetOfNode(SourceLocation LBracketLoc, unsigned Index,\n               SourceLocation RBracketLoc)\n      : Range(LBracketLoc, RBracketLoc), Data((Index << 2) | Array) {}\n\n  /// Create an offsetof node that refers to a field.\n  OffsetOfNode(SourceLocation DotLoc, FieldDecl *Field, SourceLocation NameLoc)\n      : Range(DotLoc.isValid() ? DotLoc : NameLoc, NameLoc),\n        Data(reinterpret_cast<uintptr_t>(Field) | OffsetOfNode::Field) {}\n\n  /// Create an offsetof node that refers to an identifier.\n  OffsetOfNode(SourceLocation DotLoc, IdentifierInfo *Name,\n               SourceLocation NameLoc)\n      : Range(DotLoc.isValid() ? DotLoc : NameLoc, NameLoc),\n        Data(reinterpret_cast<uintptr_t>(Name) | Identifier) {}\n\n  /// Create an offsetof node that refers into a C++ base class.\n  explicit OffsetOfNode(const CXXBaseSpecifier *Base)\n      : Range(), Data(reinterpret_cast<uintptr_t>(Base) | OffsetOfNode::Base) {}\n\n  /// Determine what kind of offsetof node this is.\n  Kind getKind() const { return static_cast<Kind>(Data & Mask); }\n\n  /// For an array element node, returns the index into the array\n  /// of expressions.\n  unsigned getArrayExprIndex() const {\n    assert(getKind() == Array);\n    return Data >> 2;\n  }\n\n  /// For a field offsetof node, returns the field.\n  FieldDecl *getField() const {\n    assert(getKind() == Field);\n    return reinterpret_cast<FieldDecl *>(Data & ~(uintptr_t)Mask);\n  }\n\n  /// For a field or identifier offsetof node, returns the name of\n  /// the field.\n  IdentifierInfo *getFieldName() const;\n\n  /// For a base class node, returns the base specifier.\n  CXXBaseSpecifier *getBase() const {\n    assert(getKind() == Base);\n    return reinterpret_cast<CXXBaseSpecifier *>(Data & ~(uintptr_t)Mask);\n  }\n\n  /// Retrieve the source range that covers this offsetof node.\n  ///\n  /// For an array element node, the source range contains the locations of\n  /// the square brackets. For a field or identifier node, the source range\n  /// contains the location of the period (if there is one) and the\n  /// identifier.\n  SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n};\n\n/// OffsetOfExpr - [C99 7.17] - This represents an expression of the form\n/// offsetof(record-type, member-designator). For example, given:\n/// @code\n/// struct S {\n///   float f;\n///   double d;\n/// };\n/// struct T {\n///   int i;\n///   struct S s[10];\n/// };\n/// @endcode\n/// we can represent and evaluate the expression @c offsetof(struct T, s[2].d).\n\nclass OffsetOfExpr final\n    : public Expr,\n      private llvm::TrailingObjects<OffsetOfExpr, OffsetOfNode, Expr *> {\n  SourceLocation OperatorLoc, RParenLoc;\n  // Base type;\n  TypeSourceInfo *TSInfo;\n  // Number of sub-components (i.e. instances of OffsetOfNode).\n  unsigned NumComps;\n  // Number of sub-expressions (i.e. array subscript expressions).\n  unsigned NumExprs;\n\n  size_t numTrailingObjects(OverloadToken<OffsetOfNode>) const {\n    return NumComps;\n  }\n\n  OffsetOfExpr(const ASTContext &C, QualType type,\n               SourceLocation OperatorLoc, TypeSourceInfo *tsi,\n               ArrayRef<OffsetOfNode> comps, ArrayRef<Expr*> exprs,\n               SourceLocation RParenLoc);\n\n  explicit OffsetOfExpr(unsigned numComps, unsigned numExprs)\n    : Expr(OffsetOfExprClass, EmptyShell()),\n      TSInfo(nullptr), NumComps(numComps), NumExprs(numExprs) {}\n\npublic:\n\n  static OffsetOfExpr *Create(const ASTContext &C, QualType type,\n                              SourceLocation OperatorLoc, TypeSourceInfo *tsi,\n                              ArrayRef<OffsetOfNode> comps,\n                              ArrayRef<Expr*> exprs, SourceLocation RParenLoc);\n\n  static OffsetOfExpr *CreateEmpty(const ASTContext &C,\n                                   unsigned NumComps, unsigned NumExprs);\n\n  /// getOperatorLoc - Return the location of the operator.\n  SourceLocation getOperatorLoc() const { return OperatorLoc; }\n  void setOperatorLoc(SourceLocation L) { OperatorLoc = L; }\n\n  /// Return the location of the right parentheses.\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation R) { RParenLoc = R; }\n\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return TSInfo;\n  }\n  void setTypeSourceInfo(TypeSourceInfo *tsi) {\n    TSInfo = tsi;\n  }\n\n  const OffsetOfNode &getComponent(unsigned Idx) const {\n    assert(Idx < NumComps && \"Subscript out of range\");\n    return getTrailingObjects<OffsetOfNode>()[Idx];\n  }\n\n  void setComponent(unsigned Idx, OffsetOfNode ON) {\n    assert(Idx < NumComps && \"Subscript out of range\");\n    getTrailingObjects<OffsetOfNode>()[Idx] = ON;\n  }\n\n  unsigned getNumComponents() const {\n    return NumComps;\n  }\n\n  Expr* getIndexExpr(unsigned Idx) {\n    assert(Idx < NumExprs && \"Subscript out of range\");\n    return getTrailingObjects<Expr *>()[Idx];\n  }\n\n  const Expr *getIndexExpr(unsigned Idx) const {\n    assert(Idx < NumExprs && \"Subscript out of range\");\n    return getTrailingObjects<Expr *>()[Idx];\n  }\n\n  void setIndexExpr(unsigned Idx, Expr* E) {\n    assert(Idx < NumComps && \"Subscript out of range\");\n    getTrailingObjects<Expr *>()[Idx] = E;\n  }\n\n  unsigned getNumExpressions() const {\n    return NumExprs;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return OperatorLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OffsetOfExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    Stmt **begin = reinterpret_cast<Stmt **>(getTrailingObjects<Expr *>());\n    return child_range(begin, begin + NumExprs);\n  }\n  const_child_range children() const {\n    Stmt *const *begin =\n        reinterpret_cast<Stmt *const *>(getTrailingObjects<Expr *>());\n    return const_child_range(begin, begin + NumExprs);\n  }\n  friend TrailingObjects;\n};\n\n/// UnaryExprOrTypeTraitExpr - expression with either a type or (unevaluated)\n/// expression operand.  Used for sizeof/alignof (C99 6.5.3.4) and\n/// vec_step (OpenCL 1.1 6.11.12).\nclass UnaryExprOrTypeTraitExpr : public Expr {\n  union {\n    TypeSourceInfo *Ty;\n    Stmt *Ex;\n  } Argument;\n  SourceLocation OpLoc, RParenLoc;\n\npublic:\n  UnaryExprOrTypeTraitExpr(UnaryExprOrTypeTrait ExprKind, TypeSourceInfo *TInfo,\n                           QualType resultType, SourceLocation op,\n                           SourceLocation rp)\n      : Expr(UnaryExprOrTypeTraitExprClass, resultType, VK_RValue, OK_Ordinary),\n        OpLoc(op), RParenLoc(rp) {\n    assert(ExprKind <= UETT_Last && \"invalid enum value!\");\n    UnaryExprOrTypeTraitExprBits.Kind = ExprKind;\n    assert(static_cast<unsigned>(ExprKind) ==\n               UnaryExprOrTypeTraitExprBits.Kind &&\n           \"UnaryExprOrTypeTraitExprBits.Kind overflow!\");\n    UnaryExprOrTypeTraitExprBits.IsType = true;\n    Argument.Ty = TInfo;\n    setDependence(computeDependence(this));\n  }\n\n  UnaryExprOrTypeTraitExpr(UnaryExprOrTypeTrait ExprKind, Expr *E,\n                           QualType resultType, SourceLocation op,\n                           SourceLocation rp);\n\n  /// Construct an empty sizeof/alignof expression.\n  explicit UnaryExprOrTypeTraitExpr(EmptyShell Empty)\n    : Expr(UnaryExprOrTypeTraitExprClass, Empty) { }\n\n  UnaryExprOrTypeTrait getKind() const {\n    return static_cast<UnaryExprOrTypeTrait>(UnaryExprOrTypeTraitExprBits.Kind);\n  }\n  void setKind(UnaryExprOrTypeTrait K) {\n    assert(K <= UETT_Last && \"invalid enum value!\");\n    UnaryExprOrTypeTraitExprBits.Kind = K;\n    assert(static_cast<unsigned>(K) == UnaryExprOrTypeTraitExprBits.Kind &&\n           \"UnaryExprOrTypeTraitExprBits.Kind overflow!\");\n  }\n\n  bool isArgumentType() const { return UnaryExprOrTypeTraitExprBits.IsType; }\n  QualType getArgumentType() const {\n    return getArgumentTypeInfo()->getType();\n  }\n  TypeSourceInfo *getArgumentTypeInfo() const {\n    assert(isArgumentType() && \"calling getArgumentType() when arg is expr\");\n    return Argument.Ty;\n  }\n  Expr *getArgumentExpr() {\n    assert(!isArgumentType() && \"calling getArgumentExpr() when arg is type\");\n    return static_cast<Expr*>(Argument.Ex);\n  }\n  const Expr *getArgumentExpr() const {\n    return const_cast<UnaryExprOrTypeTraitExpr*>(this)->getArgumentExpr();\n  }\n\n  void setArgument(Expr *E) {\n    Argument.Ex = E;\n    UnaryExprOrTypeTraitExprBits.IsType = false;\n  }\n  void setArgument(TypeSourceInfo *TInfo) {\n    Argument.Ty = TInfo;\n    UnaryExprOrTypeTraitExprBits.IsType = true;\n  }\n\n  /// Gets the argument type, or the type of the argument expression, whichever\n  /// is appropriate.\n  QualType getTypeOfArgument() const {\n    return isArgumentType() ? getArgumentType() : getArgumentExpr()->getType();\n  }\n\n  SourceLocation getOperatorLoc() const { return OpLoc; }\n  void setOperatorLoc(SourceLocation L) { OpLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return OpLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == UnaryExprOrTypeTraitExprClass;\n  }\n\n  // Iterators\n  child_range children();\n  const_child_range children() const;\n};\n\n//===----------------------------------------------------------------------===//\n// Postfix Operators.\n//===----------------------------------------------------------------------===//\n\n/// ArraySubscriptExpr - [C99 6.5.2.1] Array Subscripting.\nclass ArraySubscriptExpr : public Expr {\n  enum { LHS, RHS, END_EXPR };\n  Stmt *SubExprs[END_EXPR];\n\n  bool lhsIsBase() const { return getRHS()->getType()->isIntegerType(); }\n\npublic:\n  ArraySubscriptExpr(Expr *lhs, Expr *rhs, QualType t, ExprValueKind VK,\n                     ExprObjectKind OK, SourceLocation rbracketloc)\n      : Expr(ArraySubscriptExprClass, t, VK, OK) {\n    SubExprs[LHS] = lhs;\n    SubExprs[RHS] = rhs;\n    ArrayOrMatrixSubscriptExprBits.RBracketLoc = rbracketloc;\n    setDependence(computeDependence(this));\n  }\n\n  /// Create an empty array subscript expression.\n  explicit ArraySubscriptExpr(EmptyShell Shell)\n    : Expr(ArraySubscriptExprClass, Shell) { }\n\n  /// An array access can be written A[4] or 4[A] (both are equivalent).\n  /// - getBase() and getIdx() always present the normalized view: A[4].\n  ///    In this case getBase() returns \"A\" and getIdx() returns \"4\".\n  /// - getLHS() and getRHS() present the syntactic view. e.g. for\n  ///    4[A] getLHS() returns \"4\".\n  /// Note: Because vector element access is also written A[4] we must\n  /// predicate the format conversion in getBase and getIdx only on the\n  /// the type of the RHS, as it is possible for the LHS to be a vector of\n  /// integer type\n  Expr *getLHS() { return cast<Expr>(SubExprs[LHS]); }\n  const Expr *getLHS() const { return cast<Expr>(SubExprs[LHS]); }\n  void setLHS(Expr *E) { SubExprs[LHS] = E; }\n\n  Expr *getRHS() { return cast<Expr>(SubExprs[RHS]); }\n  const Expr *getRHS() const { return cast<Expr>(SubExprs[RHS]); }\n  void setRHS(Expr *E) { SubExprs[RHS] = E; }\n\n  Expr *getBase() { return lhsIsBase() ? getLHS() : getRHS(); }\n  const Expr *getBase() const { return lhsIsBase() ? getLHS() : getRHS(); }\n\n  Expr *getIdx() { return lhsIsBase() ? getRHS() : getLHS(); }\n  const Expr *getIdx() const { return lhsIsBase() ? getRHS() : getLHS(); }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getLHS()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const { return getRBracketLoc(); }\n\n  SourceLocation getRBracketLoc() const {\n    return ArrayOrMatrixSubscriptExprBits.RBracketLoc;\n  }\n  void setRBracketLoc(SourceLocation L) {\n    ArrayOrMatrixSubscriptExprBits.RBracketLoc = L;\n  }\n\n  SourceLocation getExprLoc() const LLVM_READONLY {\n    return getBase()->getExprLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ArraySubscriptExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0]+END_EXPR);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n};\n\n/// MatrixSubscriptExpr - Matrix subscript expression for the MatrixType\n/// extension.\n/// MatrixSubscriptExpr can be either incomplete (only Base and RowIdx are set\n/// so far, the type is IncompleteMatrixIdx) or complete (Base, RowIdx and\n/// ColumnIdx refer to valid expressions). Incomplete matrix expressions only\n/// exist during the initial construction of the AST.\nclass MatrixSubscriptExpr : public Expr {\n  enum { BASE, ROW_IDX, COLUMN_IDX, END_EXPR };\n  Stmt *SubExprs[END_EXPR];\n\npublic:\n  MatrixSubscriptExpr(Expr *Base, Expr *RowIdx, Expr *ColumnIdx, QualType T,\n                      SourceLocation RBracketLoc)\n      : Expr(MatrixSubscriptExprClass, T, Base->getValueKind(),\n             OK_MatrixComponent) {\n    SubExprs[BASE] = Base;\n    SubExprs[ROW_IDX] = RowIdx;\n    SubExprs[COLUMN_IDX] = ColumnIdx;\n    ArrayOrMatrixSubscriptExprBits.RBracketLoc = RBracketLoc;\n    setDependence(computeDependence(this));\n  }\n\n  /// Create an empty matrix subscript expression.\n  explicit MatrixSubscriptExpr(EmptyShell Shell)\n      : Expr(MatrixSubscriptExprClass, Shell) {}\n\n  bool isIncomplete() const {\n    bool IsIncomplete = hasPlaceholderType(BuiltinType::IncompleteMatrixIdx);\n    assert((SubExprs[COLUMN_IDX] || IsIncomplete) &&\n           \"expressions without column index must be marked as incomplete\");\n    return IsIncomplete;\n  }\n  Expr *getBase() { return cast<Expr>(SubExprs[BASE]); }\n  const Expr *getBase() const { return cast<Expr>(SubExprs[BASE]); }\n  void setBase(Expr *E) { SubExprs[BASE] = E; }\n\n  Expr *getRowIdx() { return cast<Expr>(SubExprs[ROW_IDX]); }\n  const Expr *getRowIdx() const { return cast<Expr>(SubExprs[ROW_IDX]); }\n  void setRowIdx(Expr *E) { SubExprs[ROW_IDX] = E; }\n\n  Expr *getColumnIdx() { return cast_or_null<Expr>(SubExprs[COLUMN_IDX]); }\n  const Expr *getColumnIdx() const {\n    assert(!isIncomplete() &&\n           \"cannot get the column index of an incomplete expression\");\n    return cast<Expr>(SubExprs[COLUMN_IDX]);\n  }\n  void setColumnIdx(Expr *E) { SubExprs[COLUMN_IDX] = E; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getBase()->getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const { return getRBracketLoc(); }\n\n  SourceLocation getExprLoc() const LLVM_READONLY {\n    return getBase()->getExprLoc();\n  }\n\n  SourceLocation getRBracketLoc() const {\n    return ArrayOrMatrixSubscriptExprBits.RBracketLoc;\n  }\n  void setRBracketLoc(SourceLocation L) {\n    ArrayOrMatrixSubscriptExprBits.RBracketLoc = L;\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == MatrixSubscriptExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n};\n\n/// CallExpr - Represents a function call (C99 6.5.2.2, C++ [expr.call]).\n/// CallExpr itself represents a normal function call, e.g., \"f(x, 2)\",\n/// while its subclasses may represent alternative syntax that (semantically)\n/// results in a function call. For example, CXXOperatorCallExpr is\n/// a subclass for overloaded operator calls that use operator syntax, e.g.,\n/// \"str1 + str2\" to resolve to a function call.\nclass CallExpr : public Expr {\n  enum { FN = 0, PREARGS_START = 1 };\n\n  /// The number of arguments in the call expression.\n  unsigned NumArgs;\n\n  /// The location of the right parenthese. This has a different meaning for\n  /// the derived classes of CallExpr.\n  SourceLocation RParenLoc;\n\n  // CallExpr store some data in trailing objects. However since CallExpr\n  // is used a base of other expression classes we cannot use\n  // llvm::TrailingObjects. Instead we manually perform the pointer arithmetic\n  // and casts.\n  //\n  // The trailing objects are in order:\n  //\n  // * A single \"Stmt *\" for the callee expression.\n  //\n  // * An array of getNumPreArgs() \"Stmt *\" for the pre-argument expressions.\n  //\n  // * An array of getNumArgs() \"Stmt *\" for the argument expressions.\n  //\n  // * An optional of type FPOptionsOverride.\n  //\n  // Note that we store the offset in bytes from the this pointer to the start\n  // of the trailing objects. It would be perfectly possible to compute it\n  // based on the dynamic kind of the CallExpr. However 1.) we have plenty of\n  // space in the bit-fields of Stmt. 2.) It was benchmarked to be faster to\n  // compute this once and then load the offset from the bit-fields of Stmt,\n  // instead of re-computing the offset each time the trailing objects are\n  // accessed.\n\n  /// Return a pointer to the start of the trailing array of \"Stmt *\".\n  Stmt **getTrailingStmts() {\n    return reinterpret_cast<Stmt **>(reinterpret_cast<char *>(this) +\n                                     CallExprBits.OffsetToTrailingObjects);\n  }\n  Stmt *const *getTrailingStmts() const {\n    return const_cast<CallExpr *>(this)->getTrailingStmts();\n  }\n\n  /// Map a statement class to the appropriate offset in bytes from the\n  /// this pointer to the trailing objects.\n  static unsigned offsetToTrailingObjects(StmtClass SC);\n\n  unsigned getSizeOfTrailingStmts() const {\n    return (1 + getNumPreArgs() + getNumArgs()) * sizeof(Stmt *);\n  }\n\n  size_t getOffsetOfTrailingFPFeatures() const {\n    assert(hasStoredFPFeatures());\n    return CallExprBits.OffsetToTrailingObjects + getSizeOfTrailingStmts();\n  }\n\npublic:\n  enum class ADLCallKind : bool { NotADL, UsesADL };\n  static constexpr ADLCallKind NotADL = ADLCallKind::NotADL;\n  static constexpr ADLCallKind UsesADL = ADLCallKind::UsesADL;\n\nprotected:\n  /// Build a call expression, assuming that appropriate storage has been\n  /// allocated for the trailing objects.\n  CallExpr(StmtClass SC, Expr *Fn, ArrayRef<Expr *> PreArgs,\n           ArrayRef<Expr *> Args, QualType Ty, ExprValueKind VK,\n           SourceLocation RParenLoc, FPOptionsOverride FPFeatures,\n           unsigned MinNumArgs, ADLCallKind UsesADL);\n\n  /// Build an empty call expression, for deserialization.\n  CallExpr(StmtClass SC, unsigned NumPreArgs, unsigned NumArgs,\n           bool hasFPFeatures, EmptyShell Empty);\n\n  /// Return the size in bytes needed for the trailing objects.\n  /// Used by the derived classes to allocate the right amount of storage.\n  static unsigned sizeOfTrailingObjects(unsigned NumPreArgs, unsigned NumArgs,\n                                        bool HasFPFeatures) {\n    return (1 + NumPreArgs + NumArgs) * sizeof(Stmt *) +\n           HasFPFeatures * sizeof(FPOptionsOverride);\n  }\n\n  Stmt *getPreArg(unsigned I) {\n    assert(I < getNumPreArgs() && \"Prearg access out of range!\");\n    return getTrailingStmts()[PREARGS_START + I];\n  }\n  const Stmt *getPreArg(unsigned I) const {\n    assert(I < getNumPreArgs() && \"Prearg access out of range!\");\n    return getTrailingStmts()[PREARGS_START + I];\n  }\n  void setPreArg(unsigned I, Stmt *PreArg) {\n    assert(I < getNumPreArgs() && \"Prearg access out of range!\");\n    getTrailingStmts()[PREARGS_START + I] = PreArg;\n  }\n\n  unsigned getNumPreArgs() const { return CallExprBits.NumPreArgs; }\n\n  /// Return a pointer to the trailing FPOptions\n  FPOptionsOverride *getTrailingFPFeatures() {\n    assert(hasStoredFPFeatures());\n    return reinterpret_cast<FPOptionsOverride *>(\n        reinterpret_cast<char *>(this) + CallExprBits.OffsetToTrailingObjects +\n        getSizeOfTrailingStmts());\n  }\n  const FPOptionsOverride *getTrailingFPFeatures() const {\n    assert(hasStoredFPFeatures());\n    return reinterpret_cast<const FPOptionsOverride *>(\n        reinterpret_cast<const char *>(this) +\n        CallExprBits.OffsetToTrailingObjects + getSizeOfTrailingStmts());\n  }\n\npublic:\n  /// Create a call expression.\n  /// \\param Fn     The callee expression,\n  /// \\param Args   The argument array,\n  /// \\param Ty     The type of the call expression (which is *not* the return\n  ///               type in general),\n  /// \\param VK     The value kind of the call expression (lvalue, rvalue, ...),\n  /// \\param RParenLoc  The location of the right parenthesis in the call\n  ///                   expression.\n  /// \\param FPFeatures Floating-point features associated with the call,\n  /// \\param MinNumArgs Specifies the minimum number of arguments. The actual\n  ///                   number of arguments will be the greater of Args.size()\n  ///                   and MinNumArgs. This is used in a few places to allocate\n  ///                   enough storage for the default arguments.\n  /// \\param UsesADL    Specifies whether the callee was found through\n  ///                   argument-dependent lookup.\n  ///\n  /// Note that you can use CreateTemporary if you need a temporary call\n  /// expression on the stack.\n  static CallExpr *Create(const ASTContext &Ctx, Expr *Fn,\n                          ArrayRef<Expr *> Args, QualType Ty, ExprValueKind VK,\n                          SourceLocation RParenLoc,\n                          FPOptionsOverride FPFeatures, unsigned MinNumArgs = 0,\n                          ADLCallKind UsesADL = NotADL);\n\n  /// Create a temporary call expression with no arguments in the memory\n  /// pointed to by Mem. Mem must points to at least sizeof(CallExpr)\n  /// + sizeof(Stmt *) bytes of storage, aligned to alignof(CallExpr):\n  ///\n  /// \\code{.cpp}\n  ///   alignas(CallExpr) char Buffer[sizeof(CallExpr) + sizeof(Stmt *)];\n  ///   CallExpr *TheCall = CallExpr::CreateTemporary(Buffer, etc);\n  /// \\endcode\n  static CallExpr *CreateTemporary(void *Mem, Expr *Fn, QualType Ty,\n                                   ExprValueKind VK, SourceLocation RParenLoc,\n                                   ADLCallKind UsesADL = NotADL);\n\n  /// Create an empty call expression, for deserialization.\n  static CallExpr *CreateEmpty(const ASTContext &Ctx, unsigned NumArgs,\n                               bool HasFPFeatures, EmptyShell Empty);\n\n  Expr *getCallee() { return cast<Expr>(getTrailingStmts()[FN]); }\n  const Expr *getCallee() const { return cast<Expr>(getTrailingStmts()[FN]); }\n  void setCallee(Expr *F) { getTrailingStmts()[FN] = F; }\n\n  ADLCallKind getADLCallKind() const {\n    return static_cast<ADLCallKind>(CallExprBits.UsesADL);\n  }\n  void setADLCallKind(ADLCallKind V = UsesADL) {\n    CallExprBits.UsesADL = static_cast<bool>(V);\n  }\n  bool usesADL() const { return getADLCallKind() == UsesADL; }\n\n  bool hasStoredFPFeatures() const { return CallExprBits.HasFPFeatures; }\n\n  Decl *getCalleeDecl() { return getCallee()->getReferencedDeclOfCallee(); }\n  const Decl *getCalleeDecl() const {\n    return getCallee()->getReferencedDeclOfCallee();\n  }\n\n  /// If the callee is a FunctionDecl, return it. Otherwise return null.\n  FunctionDecl *getDirectCallee() {\n    return dyn_cast_or_null<FunctionDecl>(getCalleeDecl());\n  }\n  const FunctionDecl *getDirectCallee() const {\n    return dyn_cast_or_null<FunctionDecl>(getCalleeDecl());\n  }\n\n  /// getNumArgs - Return the number of actual arguments to this call.\n  unsigned getNumArgs() const { return NumArgs; }\n\n  /// Retrieve the call arguments.\n  Expr **getArgs() {\n    return reinterpret_cast<Expr **>(getTrailingStmts() + PREARGS_START +\n                                     getNumPreArgs());\n  }\n  const Expr *const *getArgs() const {\n    return reinterpret_cast<const Expr *const *>(\n        getTrailingStmts() + PREARGS_START + getNumPreArgs());\n  }\n\n  /// getArg - Return the specified argument.\n  Expr *getArg(unsigned Arg) {\n    assert(Arg < getNumArgs() && \"Arg access out of range!\");\n    return getArgs()[Arg];\n  }\n  const Expr *getArg(unsigned Arg) const {\n    assert(Arg < getNumArgs() && \"Arg access out of range!\");\n    return getArgs()[Arg];\n  }\n\n  /// setArg - Set the specified argument.\n  void setArg(unsigned Arg, Expr *ArgExpr) {\n    assert(Arg < getNumArgs() && \"Arg access out of range!\");\n    getArgs()[Arg] = ArgExpr;\n  }\n\n  /// Reduce the number of arguments in this call expression. This is used for\n  /// example during error recovery to drop extra arguments. There is no way\n  /// to perform the opposite because: 1.) We don't track how much storage\n  /// we have for the argument array 2.) This would potentially require growing\n  /// the argument array, something we cannot support since the arguments are\n  /// stored in a trailing array.\n  void shrinkNumArgs(unsigned NewNumArgs) {\n    assert((NewNumArgs <= getNumArgs()) &&\n           \"shrinkNumArgs cannot increase the number of arguments!\");\n    NumArgs = NewNumArgs;\n  }\n\n  /// Bluntly set a new number of arguments without doing any checks whatsoever.\n  /// Only used during construction of a CallExpr in a few places in Sema.\n  /// FIXME: Find a way to remove it.\n  void setNumArgsUnsafe(unsigned NewNumArgs) { NumArgs = NewNumArgs; }\n\n  typedef ExprIterator arg_iterator;\n  typedef ConstExprIterator const_arg_iterator;\n  typedef llvm::iterator_range<arg_iterator> arg_range;\n  typedef llvm::iterator_range<const_arg_iterator> const_arg_range;\n\n  arg_range arguments() { return arg_range(arg_begin(), arg_end()); }\n  const_arg_range arguments() const {\n    return const_arg_range(arg_begin(), arg_end());\n  }\n\n  arg_iterator arg_begin() {\n    return getTrailingStmts() + PREARGS_START + getNumPreArgs();\n  }\n  arg_iterator arg_end() { return arg_begin() + getNumArgs(); }\n\n  const_arg_iterator arg_begin() const {\n    return getTrailingStmts() + PREARGS_START + getNumPreArgs();\n  }\n  const_arg_iterator arg_end() const { return arg_begin() + getNumArgs(); }\n\n  /// This method provides fast access to all the subexpressions of\n  /// a CallExpr without going through the slower virtual child_iterator\n  /// interface.  This provides efficient reverse iteration of the\n  /// subexpressions.  This is currently used for CFG construction.\n  ArrayRef<Stmt *> getRawSubExprs() {\n    return llvm::makeArrayRef(getTrailingStmts(),\n                              PREARGS_START + getNumPreArgs() + getNumArgs());\n  }\n\n  /// getNumCommas - Return the number of commas that must have been present in\n  /// this function call.\n  unsigned getNumCommas() const { return getNumArgs() ? getNumArgs() - 1 : 0; }\n\n  /// Get FPOptionsOverride from trailing storage.\n  FPOptionsOverride getStoredFPFeatures() const {\n    assert(hasStoredFPFeatures());\n    return *getTrailingFPFeatures();\n  }\n  /// Set FPOptionsOverride in trailing storage. Used only by Serialization.\n  void setStoredFPFeatures(FPOptionsOverride F) {\n    assert(hasStoredFPFeatures());\n    *getTrailingFPFeatures() = F;\n  }\n\n  // Get the FP features status of this operator. Only meaningful for\n  // operations on floating point types.\n  FPOptions getFPFeaturesInEffect(const LangOptions &LO) const {\n    if (hasStoredFPFeatures())\n      return getStoredFPFeatures().applyOverrides(LO);\n    return FPOptions::defaultWithoutTrailingStorage(LO);\n  }\n\n  FPOptionsOverride getFPFeatures() const {\n    if (hasStoredFPFeatures())\n      return getStoredFPFeatures();\n    return FPOptionsOverride();\n  }\n\n  /// getBuiltinCallee - If this is a call to a builtin, return the builtin ID\n  /// of the callee. If not, return 0.\n  unsigned getBuiltinCallee() const;\n\n  /// Returns \\c true if this is a call to a builtin which does not\n  /// evaluate side-effects within its arguments.\n  bool isUnevaluatedBuiltinCall(const ASTContext &Ctx) const;\n\n  /// getCallReturnType - Get the return type of the call expr. This is not\n  /// always the type of the expr itself, if the return type is a reference\n  /// type.\n  QualType getCallReturnType(const ASTContext &Ctx) const;\n\n  /// Returns the WarnUnusedResultAttr that is either declared on the called\n  /// function, or its return type declaration.\n  const Attr *getUnusedResultAttr(const ASTContext &Ctx) const;\n\n  /// Returns true if this call expression should warn on unused results.\n  bool hasUnusedResultAttr(const ASTContext &Ctx) const {\n    return getUnusedResultAttr(Ctx) != nullptr;\n  }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  /// Return true if this is a call to __assume() or __builtin_assume() with\n  /// a non-value-dependent constant parameter evaluating as false.\n  bool isBuiltinAssumeFalse(const ASTContext &Ctx) const;\n\n  /// Used by Sema to implement MSVC-compatible delayed name lookup.\n  /// (Usually Exprs themselves should set dependence).\n  void markDependentForPostponedNameLookup() {\n    setDependence(getDependence() | ExprDependence::TypeValueInstantiation);\n  }\n\n  bool isCallToStdMove() const {\n    const FunctionDecl *FD = getDirectCallee();\n    return getNumArgs() == 1 && FD && FD->isInStdNamespace() &&\n           FD->getIdentifier() && FD->getIdentifier()->isStr(\"move\");\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() >= firstCallExprConstant &&\n           T->getStmtClass() <= lastCallExprConstant;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(getTrailingStmts(), getTrailingStmts() + PREARGS_START +\n                                               getNumPreArgs() + getNumArgs());\n  }\n\n  const_child_range children() const {\n    return const_child_range(getTrailingStmts(),\n                             getTrailingStmts() + PREARGS_START +\n                                 getNumPreArgs() + getNumArgs());\n  }\n};\n\n/// Extra data stored in some MemberExpr objects.\nstruct MemberExprNameQualifier {\n  /// The nested-name-specifier that qualifies the name, including\n  /// source-location information.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// The DeclAccessPair through which the MemberDecl was found due to\n  /// name qualifiers.\n  DeclAccessPair FoundDecl;\n};\n\n/// MemberExpr - [C99 6.5.2.3] Structure and Union Members.  X->F and X.F.\n///\nclass MemberExpr final\n    : public Expr,\n      private llvm::TrailingObjects<MemberExpr, MemberExprNameQualifier,\n                                    ASTTemplateKWAndArgsInfo,\n                                    TemplateArgumentLoc> {\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// Base - the expression for the base pointer or structure references.  In\n  /// X.F, this is \"X\".\n  Stmt *Base;\n\n  /// MemberDecl - This is the decl being referenced by the field/member name.\n  /// In X.F, this is the decl referenced by F.\n  ValueDecl *MemberDecl;\n\n  /// MemberDNLoc - Provides source/type location info for the\n  /// declaration name embedded in MemberDecl.\n  DeclarationNameLoc MemberDNLoc;\n\n  /// MemberLoc - This is the location of the member name.\n  SourceLocation MemberLoc;\n\n  size_t numTrailingObjects(OverloadToken<MemberExprNameQualifier>) const {\n    return hasQualifierOrFoundDecl();\n  }\n\n  size_t numTrailingObjects(OverloadToken<ASTTemplateKWAndArgsInfo>) const {\n    return hasTemplateKWAndArgsInfo();\n  }\n\n  bool hasQualifierOrFoundDecl() const {\n    return MemberExprBits.HasQualifierOrFoundDecl;\n  }\n\n  bool hasTemplateKWAndArgsInfo() const {\n    return MemberExprBits.HasTemplateKWAndArgsInfo;\n  }\n\n  MemberExpr(Expr *Base, bool IsArrow, SourceLocation OperatorLoc,\n             ValueDecl *MemberDecl, const DeclarationNameInfo &NameInfo,\n             QualType T, ExprValueKind VK, ExprObjectKind OK,\n             NonOdrUseReason NOUR);\n  MemberExpr(EmptyShell Empty)\n      : Expr(MemberExprClass, Empty), Base(), MemberDecl() {}\n\npublic:\n  static MemberExpr *Create(const ASTContext &C, Expr *Base, bool IsArrow,\n                            SourceLocation OperatorLoc,\n                            NestedNameSpecifierLoc QualifierLoc,\n                            SourceLocation TemplateKWLoc, ValueDecl *MemberDecl,\n                            DeclAccessPair FoundDecl,\n                            DeclarationNameInfo MemberNameInfo,\n                            const TemplateArgumentListInfo *TemplateArgs,\n                            QualType T, ExprValueKind VK, ExprObjectKind OK,\n                            NonOdrUseReason NOUR);\n\n  /// Create an implicit MemberExpr, with no location, qualifier, template\n  /// arguments, and so on. Suitable only for non-static member access.\n  static MemberExpr *CreateImplicit(const ASTContext &C, Expr *Base,\n                                    bool IsArrow, ValueDecl *MemberDecl,\n                                    QualType T, ExprValueKind VK,\n                                    ExprObjectKind OK) {\n    return Create(C, Base, IsArrow, SourceLocation(), NestedNameSpecifierLoc(),\n                  SourceLocation(), MemberDecl,\n                  DeclAccessPair::make(MemberDecl, MemberDecl->getAccess()),\n                  DeclarationNameInfo(), nullptr, T, VK, OK, NOUR_None);\n  }\n\n  static MemberExpr *CreateEmpty(const ASTContext &Context, bool HasQualifier,\n                                 bool HasFoundDecl,\n                                 bool HasTemplateKWAndArgsInfo,\n                                 unsigned NumTemplateArgs);\n\n  void setBase(Expr *E) { Base = E; }\n  Expr *getBase() const { return cast<Expr>(Base); }\n\n  /// Retrieve the member declaration to which this expression refers.\n  ///\n  /// The returned declaration will be a FieldDecl or (in C++) a VarDecl (for\n  /// static data members), a CXXMethodDecl, or an EnumConstantDecl.\n  ValueDecl *getMemberDecl() const { return MemberDecl; }\n  void setMemberDecl(ValueDecl *D);\n\n  /// Retrieves the declaration found by lookup.\n  DeclAccessPair getFoundDecl() const {\n    if (!hasQualifierOrFoundDecl())\n      return DeclAccessPair::make(getMemberDecl(),\n                                  getMemberDecl()->getAccess());\n    return getTrailingObjects<MemberExprNameQualifier>()->FoundDecl;\n  }\n\n  /// Determines whether this member expression actually had\n  /// a C++ nested-name-specifier prior to the name of the member, e.g.,\n  /// x->Base::foo.\n  bool hasQualifier() const { return getQualifier() != nullptr; }\n\n  /// If the member name was qualified, retrieves the\n  /// nested-name-specifier that precedes the member name, with source-location\n  /// information.\n  NestedNameSpecifierLoc getQualifierLoc() const {\n    if (!hasQualifierOrFoundDecl())\n      return NestedNameSpecifierLoc();\n    return getTrailingObjects<MemberExprNameQualifier>()->QualifierLoc;\n  }\n\n  /// If the member name was qualified, retrieves the\n  /// nested-name-specifier that precedes the member name. Otherwise, returns\n  /// NULL.\n  NestedNameSpecifier *getQualifier() const {\n    return getQualifierLoc().getNestedNameSpecifier();\n  }\n\n  /// Retrieve the location of the template keyword preceding\n  /// the member name, if any.\n  SourceLocation getTemplateKeywordLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->TemplateKWLoc;\n  }\n\n  /// Retrieve the location of the left angle bracket starting the\n  /// explicit template argument list following the member name, if any.\n  SourceLocation getLAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->LAngleLoc;\n  }\n\n  /// Retrieve the location of the right angle bracket ending the\n  /// explicit template argument list following the member name, if any.\n  SourceLocation getRAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->RAngleLoc;\n  }\n\n  /// Determines whether the member name was preceded by the template keyword.\n  bool hasTemplateKeyword() const { return getTemplateKeywordLoc().isValid(); }\n\n  /// Determines whether the member name was followed by an\n  /// explicit template argument list.\n  bool hasExplicitTemplateArgs() const { return getLAngleLoc().isValid(); }\n\n  /// Copies the template arguments (if present) into the given\n  /// structure.\n  void copyTemplateArgumentsInto(TemplateArgumentListInfo &List) const {\n    if (hasExplicitTemplateArgs())\n      getTrailingObjects<ASTTemplateKWAndArgsInfo>()->copyInto(\n          getTrailingObjects<TemplateArgumentLoc>(), List);\n  }\n\n  /// Retrieve the template arguments provided as part of this\n  /// template-id.\n  const TemplateArgumentLoc *getTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return nullptr;\n\n    return getTrailingObjects<TemplateArgumentLoc>();\n  }\n\n  /// Retrieve the number of template arguments provided as part of this\n  /// template-id.\n  unsigned getNumTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return 0;\n\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->NumTemplateArgs;\n  }\n\n  ArrayRef<TemplateArgumentLoc> template_arguments() const {\n    return {getTemplateArgs(), getNumTemplateArgs()};\n  }\n\n  /// Retrieve the member declaration name info.\n  DeclarationNameInfo getMemberNameInfo() const {\n    return DeclarationNameInfo(MemberDecl->getDeclName(),\n                               MemberLoc, MemberDNLoc);\n  }\n\n  SourceLocation getOperatorLoc() const { return MemberExprBits.OperatorLoc; }\n\n  bool isArrow() const { return MemberExprBits.IsArrow; }\n  void setArrow(bool A) { MemberExprBits.IsArrow = A; }\n\n  /// getMemberLoc - Return the location of the \"member\", in X->F, it is the\n  /// location of 'F'.\n  SourceLocation getMemberLoc() const { return MemberLoc; }\n  void setMemberLoc(SourceLocation L) { MemberLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  SourceLocation getExprLoc() const LLVM_READONLY { return MemberLoc; }\n\n  /// Determine whether the base of this explicit is implicit.\n  bool isImplicitAccess() const {\n    return getBase() && getBase()->isImplicitCXXThis();\n  }\n\n  /// Returns true if this member expression refers to a method that\n  /// was resolved from an overloaded set having size greater than 1.\n  bool hadMultipleCandidates() const {\n    return MemberExprBits.HadMultipleCandidates;\n  }\n  /// Sets the flag telling whether this expression refers to\n  /// a method that was resolved from an overloaded set having size\n  /// greater than 1.\n  void setHadMultipleCandidates(bool V = true) {\n    MemberExprBits.HadMultipleCandidates = V;\n  }\n\n  /// Returns true if virtual dispatch is performed.\n  /// If the member access is fully qualified, (i.e. X::f()), virtual\n  /// dispatching is not performed. In -fapple-kext mode qualified\n  /// calls to virtual method will still go through the vtable.\n  bool performsVirtualDispatch(const LangOptions &LO) const {\n    return LO.AppleKext || !hasQualifier();\n  }\n\n  /// Is this expression a non-odr-use reference, and if so, why?\n  /// This is only meaningful if the named member is a static member.\n  NonOdrUseReason isNonOdrUse() const {\n    return static_cast<NonOdrUseReason>(MemberExprBits.NonOdrUseReason);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == MemberExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Base, &Base+1); }\n  const_child_range children() const {\n    return const_child_range(&Base, &Base + 1);\n  }\n};\n\n/// CompoundLiteralExpr - [C99 6.5.2.5]\n///\nclass CompoundLiteralExpr : public Expr {\n  /// LParenLoc - If non-null, this is the location of the left paren in a\n  /// compound literal like \"(int){4}\".  This can be null if this is a\n  /// synthesized compound expression.\n  SourceLocation LParenLoc;\n\n  /// The type as written.  This can be an incomplete array type, in\n  /// which case the actual expression type will be different.\n  /// The int part of the pair stores whether this expr is file scope.\n  llvm::PointerIntPair<TypeSourceInfo *, 1, bool> TInfoAndScope;\n  Stmt *Init;\npublic:\n  CompoundLiteralExpr(SourceLocation lparenloc, TypeSourceInfo *tinfo,\n                      QualType T, ExprValueKind VK, Expr *init, bool fileScope)\n      : Expr(CompoundLiteralExprClass, T, VK, OK_Ordinary),\n        LParenLoc(lparenloc), TInfoAndScope(tinfo, fileScope), Init(init) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Construct an empty compound literal.\n  explicit CompoundLiteralExpr(EmptyShell Empty)\n    : Expr(CompoundLiteralExprClass, Empty) { }\n\n  const Expr *getInitializer() const { return cast<Expr>(Init); }\n  Expr *getInitializer() { return cast<Expr>(Init); }\n  void setInitializer(Expr *E) { Init = E; }\n\n  bool isFileScope() const { return TInfoAndScope.getInt(); }\n  void setFileScope(bool FS) { TInfoAndScope.setInt(FS); }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  void setLParenLoc(SourceLocation L) { LParenLoc = L; }\n\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return TInfoAndScope.getPointer();\n  }\n  void setTypeSourceInfo(TypeSourceInfo *tinfo) {\n    TInfoAndScope.setPointer(tinfo);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    // FIXME: Init should never be null.\n    if (!Init)\n      return SourceLocation();\n    if (LParenLoc.isInvalid())\n      return Init->getBeginLoc();\n    return LParenLoc;\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    // FIXME: Init should never be null.\n    if (!Init)\n      return SourceLocation();\n    return Init->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CompoundLiteralExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Init, &Init+1); }\n  const_child_range children() const {\n    return const_child_range(&Init, &Init + 1);\n  }\n};\n\n/// CastExpr - Base class for type casts, including both implicit\n/// casts (ImplicitCastExpr) and explicit casts that have some\n/// representation in the source code (ExplicitCastExpr's derived\n/// classes).\nclass CastExpr : public Expr {\n  Stmt *Op;\n\n  bool CastConsistency() const;\n\n  const CXXBaseSpecifier * const *path_buffer() const {\n    return const_cast<CastExpr*>(this)->path_buffer();\n  }\n  CXXBaseSpecifier **path_buffer();\n\n  friend class ASTStmtReader;\n\nprotected:\n  CastExpr(StmtClass SC, QualType ty, ExprValueKind VK, const CastKind kind,\n           Expr *op, unsigned BasePathSize, bool HasFPFeatures)\n      : Expr(SC, ty, VK, OK_Ordinary), Op(op) {\n    CastExprBits.Kind = kind;\n    CastExprBits.PartOfExplicitCast = false;\n    CastExprBits.BasePathSize = BasePathSize;\n    assert((CastExprBits.BasePathSize == BasePathSize) &&\n           \"BasePathSize overflow!\");\n    setDependence(computeDependence(this));\n    assert(CastConsistency());\n    CastExprBits.HasFPFeatures = HasFPFeatures;\n  }\n\n  /// Construct an empty cast.\n  CastExpr(StmtClass SC, EmptyShell Empty, unsigned BasePathSize,\n           bool HasFPFeatures)\n      : Expr(SC, Empty) {\n    CastExprBits.PartOfExplicitCast = false;\n    CastExprBits.BasePathSize = BasePathSize;\n    CastExprBits.HasFPFeatures = HasFPFeatures;\n    assert((CastExprBits.BasePathSize == BasePathSize) &&\n           \"BasePathSize overflow!\");\n  }\n\n  /// Return a pointer to the trailing FPOptions.\n  /// \\pre hasStoredFPFeatures() == true\n  FPOptionsOverride *getTrailingFPFeatures();\n  const FPOptionsOverride *getTrailingFPFeatures() const {\n    return const_cast<CastExpr *>(this)->getTrailingFPFeatures();\n  }\n\npublic:\n  CastKind getCastKind() const { return (CastKind) CastExprBits.Kind; }\n  void setCastKind(CastKind K) { CastExprBits.Kind = K; }\n\n  static const char *getCastKindName(CastKind CK);\n  const char *getCastKindName() const { return getCastKindName(getCastKind()); }\n\n  Expr *getSubExpr() { return cast<Expr>(Op); }\n  const Expr *getSubExpr() const { return cast<Expr>(Op); }\n  void setSubExpr(Expr *E) { Op = E; }\n\n  /// Retrieve the cast subexpression as it was written in the source\n  /// code, looking through any implicit casts or other intermediate nodes\n  /// introduced by semantic analysis.\n  Expr *getSubExprAsWritten();\n  const Expr *getSubExprAsWritten() const {\n    return const_cast<CastExpr *>(this)->getSubExprAsWritten();\n  }\n\n  /// If this cast applies a user-defined conversion, retrieve the conversion\n  /// function that it invokes.\n  NamedDecl *getConversionFunction() const;\n\n  typedef CXXBaseSpecifier **path_iterator;\n  typedef const CXXBaseSpecifier *const *path_const_iterator;\n  bool path_empty() const { return path_size() == 0; }\n  unsigned path_size() const { return CastExprBits.BasePathSize; }\n  path_iterator path_begin() { return path_buffer(); }\n  path_iterator path_end() { return path_buffer() + path_size(); }\n  path_const_iterator path_begin() const { return path_buffer(); }\n  path_const_iterator path_end() const { return path_buffer() + path_size(); }\n\n  llvm::iterator_range<path_iterator> path() {\n    return llvm::make_range(path_begin(), path_end());\n  }\n  llvm::iterator_range<path_const_iterator> path() const {\n    return llvm::make_range(path_begin(), path_end());\n  }\n\n  const FieldDecl *getTargetUnionField() const {\n    assert(getCastKind() == CK_ToUnion);\n    return getTargetFieldForToUnionCast(getType(), getSubExpr()->getType());\n  }\n\n  bool hasStoredFPFeatures() const { return CastExprBits.HasFPFeatures; }\n\n  /// Get FPOptionsOverride from trailing storage.\n  FPOptionsOverride getStoredFPFeatures() const {\n    assert(hasStoredFPFeatures());\n    return *getTrailingFPFeatures();\n  }\n\n  // Get the FP features status of this operation. Only meaningful for\n  // operations on floating point types.\n  FPOptions getFPFeaturesInEffect(const LangOptions &LO) const {\n    if (hasStoredFPFeatures())\n      return getStoredFPFeatures().applyOverrides(LO);\n    return FPOptions::defaultWithoutTrailingStorage(LO);\n  }\n\n  FPOptionsOverride getFPFeatures() const {\n    if (hasStoredFPFeatures())\n      return getStoredFPFeatures();\n    return FPOptionsOverride();\n  }\n\n  static const FieldDecl *getTargetFieldForToUnionCast(QualType unionType,\n                                                       QualType opType);\n  static const FieldDecl *getTargetFieldForToUnionCast(const RecordDecl *RD,\n                                                       QualType opType);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() >= firstCastExprConstant &&\n           T->getStmtClass() <= lastCastExprConstant;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Op, &Op+1); }\n  const_child_range children() const { return const_child_range(&Op, &Op + 1); }\n};\n\n/// ImplicitCastExpr - Allows us to explicitly represent implicit type\n/// conversions, which have no direct representation in the original\n/// source code. For example: converting T[]->T*, void f()->void\n/// (*f)(), float->double, short->int, etc.\n///\n/// In C, implicit casts always produce rvalues. However, in C++, an\n/// implicit cast whose result is being bound to a reference will be\n/// an lvalue or xvalue. For example:\n///\n/// @code\n/// class Base { };\n/// class Derived : public Base { };\n/// Derived &&ref();\n/// void f(Derived d) {\n///   Base& b = d; // initializer is an ImplicitCastExpr\n///                // to an lvalue of type Base\n///   Base&& r = ref(); // initializer is an ImplicitCastExpr\n///                     // to an xvalue of type Base\n/// }\n/// @endcode\nclass ImplicitCastExpr final\n    : public CastExpr,\n      private llvm::TrailingObjects<ImplicitCastExpr, CXXBaseSpecifier *,\n                                    FPOptionsOverride> {\n\n  ImplicitCastExpr(QualType ty, CastKind kind, Expr *op,\n                   unsigned BasePathLength, FPOptionsOverride FPO,\n                   ExprValueKind VK)\n      : CastExpr(ImplicitCastExprClass, ty, VK, kind, op, BasePathLength,\n                 FPO.requiresTrailingStorage()) {\n    if (hasStoredFPFeatures())\n      *getTrailingFPFeatures() = FPO;\n  }\n\n  /// Construct an empty implicit cast.\n  explicit ImplicitCastExpr(EmptyShell Shell, unsigned PathSize,\n                            bool HasFPFeatures)\n      : CastExpr(ImplicitCastExprClass, Shell, PathSize, HasFPFeatures) {}\n\n  unsigned numTrailingObjects(OverloadToken<CXXBaseSpecifier *>) const {\n    return path_size();\n  }\n\npublic:\n  enum OnStack_t { OnStack };\n  ImplicitCastExpr(OnStack_t _, QualType ty, CastKind kind, Expr *op,\n                   ExprValueKind VK, FPOptionsOverride FPO)\n      : CastExpr(ImplicitCastExprClass, ty, VK, kind, op, 0,\n                 FPO.requiresTrailingStorage()) {\n    if (hasStoredFPFeatures())\n      *getTrailingFPFeatures() = FPO;\n  }\n\n  bool isPartOfExplicitCast() const { return CastExprBits.PartOfExplicitCast; }\n  void setIsPartOfExplicitCast(bool PartOfExplicitCast) {\n    CastExprBits.PartOfExplicitCast = PartOfExplicitCast;\n  }\n\n  static ImplicitCastExpr *Create(const ASTContext &Context, QualType T,\n                                  CastKind Kind, Expr *Operand,\n                                  const CXXCastPath *BasePath,\n                                  ExprValueKind Cat, FPOptionsOverride FPO);\n\n  static ImplicitCastExpr *CreateEmpty(const ASTContext &Context,\n                                       unsigned PathSize, bool HasFPFeatures);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getSubExpr()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getSubExpr()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ImplicitCastExprClass;\n  }\n\n  friend TrailingObjects;\n  friend class CastExpr;\n};\n\n/// ExplicitCastExpr - An explicit cast written in the source\n/// code.\n///\n/// This class is effectively an abstract class, because it provides\n/// the basic representation of an explicitly-written cast without\n/// specifying which kind of cast (C cast, functional cast, static\n/// cast, etc.) was written; specific derived classes represent the\n/// particular style of cast and its location information.\n///\n/// Unlike implicit casts, explicit cast nodes have two different\n/// types: the type that was written into the source code, and the\n/// actual type of the expression as determined by semantic\n/// analysis. These types may differ slightly. For example, in C++ one\n/// can cast to a reference type, which indicates that the resulting\n/// expression will be an lvalue or xvalue. The reference type, however,\n/// will not be used as the type of the expression.\nclass ExplicitCastExpr : public CastExpr {\n  /// TInfo - Source type info for the (written) type\n  /// this expression is casting to.\n  TypeSourceInfo *TInfo;\n\nprotected:\n  ExplicitCastExpr(StmtClass SC, QualType exprTy, ExprValueKind VK,\n                   CastKind kind, Expr *op, unsigned PathSize,\n                   bool HasFPFeatures, TypeSourceInfo *writtenTy)\n      : CastExpr(SC, exprTy, VK, kind, op, PathSize, HasFPFeatures),\n        TInfo(writtenTy) {}\n\n  /// Construct an empty explicit cast.\n  ExplicitCastExpr(StmtClass SC, EmptyShell Shell, unsigned PathSize,\n                   bool HasFPFeatures)\n      : CastExpr(SC, Shell, PathSize, HasFPFeatures) {}\n\npublic:\n  /// getTypeInfoAsWritten - Returns the type source info for the type\n  /// that this expression is casting to.\n  TypeSourceInfo *getTypeInfoAsWritten() const { return TInfo; }\n  void setTypeInfoAsWritten(TypeSourceInfo *writtenTy) { TInfo = writtenTy; }\n\n  /// getTypeAsWritten - Returns the type that this expression is\n  /// casting to, as written in the source code.\n  QualType getTypeAsWritten() const { return TInfo->getType(); }\n\n  static bool classof(const Stmt *T) {\n     return T->getStmtClass() >= firstExplicitCastExprConstant &&\n            T->getStmtClass() <= lastExplicitCastExprConstant;\n  }\n};\n\n/// CStyleCastExpr - An explicit cast in C (C99 6.5.4) or a C-style\n/// cast in C++ (C++ [expr.cast]), which uses the syntax\n/// (Type)expr. For example: @c (int)f.\nclass CStyleCastExpr final\n    : public ExplicitCastExpr,\n      private llvm::TrailingObjects<CStyleCastExpr, CXXBaseSpecifier *,\n                                    FPOptionsOverride> {\n  SourceLocation LPLoc; // the location of the left paren\n  SourceLocation RPLoc; // the location of the right paren\n\n  CStyleCastExpr(QualType exprTy, ExprValueKind vk, CastKind kind, Expr *op,\n                 unsigned PathSize, FPOptionsOverride FPO,\n                 TypeSourceInfo *writtenTy, SourceLocation l, SourceLocation r)\n      : ExplicitCastExpr(CStyleCastExprClass, exprTy, vk, kind, op, PathSize,\n                         FPO.requiresTrailingStorage(), writtenTy),\n        LPLoc(l), RPLoc(r) {\n    if (hasStoredFPFeatures())\n      *getTrailingFPFeatures() = FPO;\n  }\n\n  /// Construct an empty C-style explicit cast.\n  explicit CStyleCastExpr(EmptyShell Shell, unsigned PathSize,\n                          bool HasFPFeatures)\n      : ExplicitCastExpr(CStyleCastExprClass, Shell, PathSize, HasFPFeatures) {}\n\n  unsigned numTrailingObjects(OverloadToken<CXXBaseSpecifier *>) const {\n    return path_size();\n  }\n\npublic:\n  static CStyleCastExpr *\n  Create(const ASTContext &Context, QualType T, ExprValueKind VK, CastKind K,\n         Expr *Op, const CXXCastPath *BasePath, FPOptionsOverride FPO,\n         TypeSourceInfo *WrittenTy, SourceLocation L, SourceLocation R);\n\n  static CStyleCastExpr *CreateEmpty(const ASTContext &Context,\n                                     unsigned PathSize, bool HasFPFeatures);\n\n  SourceLocation getLParenLoc() const { return LPLoc; }\n  void setLParenLoc(SourceLocation L) { LPLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RPLoc; }\n  void setRParenLoc(SourceLocation L) { RPLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return LPLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getSubExpr()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CStyleCastExprClass;\n  }\n\n  friend TrailingObjects;\n  friend class CastExpr;\n};\n\n/// A builtin binary operation expression such as \"x + y\" or \"x <= y\".\n///\n/// This expression node kind describes a builtin binary operation,\n/// such as \"x + y\" for integer values \"x\" and \"y\". The operands will\n/// already have been converted to appropriate types (e.g., by\n/// performing promotions or conversions).\n///\n/// In C++, where operators may be overloaded, a different kind of\n/// expression node (CXXOperatorCallExpr) is used to express the\n/// invocation of an overloaded operator with operator syntax. Within\n/// a C++ template, whether BinaryOperator or CXXOperatorCallExpr is\n/// used to store an expression \"x + y\" depends on the subexpressions\n/// for x and y. If neither x or y is type-dependent, and the \"+\"\n/// operator resolves to a built-in operation, BinaryOperator will be\n/// used to express the computation (x and y may still be\n/// value-dependent). If either x or y is type-dependent, or if the\n/// \"+\" resolves to an overloaded operator, CXXOperatorCallExpr will\n/// be used to express the computation.\nclass BinaryOperator : public Expr {\n  enum { LHS, RHS, END_EXPR };\n  Stmt *SubExprs[END_EXPR];\n\npublic:\n  typedef BinaryOperatorKind Opcode;\n\nprotected:\n  size_t offsetOfTrailingStorage() const;\n\n  /// Return a pointer to the trailing FPOptions\n  FPOptionsOverride *getTrailingFPFeatures() {\n    assert(BinaryOperatorBits.HasFPFeatures);\n    return reinterpret_cast<FPOptionsOverride *>(\n        reinterpret_cast<char *>(this) + offsetOfTrailingStorage());\n  }\n  const FPOptionsOverride *getTrailingFPFeatures() const {\n    assert(BinaryOperatorBits.HasFPFeatures);\n    return reinterpret_cast<const FPOptionsOverride *>(\n        reinterpret_cast<const char *>(this) + offsetOfTrailingStorage());\n  }\n\n  /// Build a binary operator, assuming that appropriate storage has been\n  /// allocated for the trailing objects when needed.\n  BinaryOperator(const ASTContext &Ctx, Expr *lhs, Expr *rhs, Opcode opc,\n                 QualType ResTy, ExprValueKind VK, ExprObjectKind OK,\n                 SourceLocation opLoc, FPOptionsOverride FPFeatures);\n\n  /// Construct an empty binary operator.\n  explicit BinaryOperator(EmptyShell Empty) : Expr(BinaryOperatorClass, Empty) {\n    BinaryOperatorBits.Opc = BO_Comma;\n  }\n\npublic:\n  static BinaryOperator *CreateEmpty(const ASTContext &C, bool hasFPFeatures);\n\n  static BinaryOperator *Create(const ASTContext &C, Expr *lhs, Expr *rhs,\n                                Opcode opc, QualType ResTy, ExprValueKind VK,\n                                ExprObjectKind OK, SourceLocation opLoc,\n                                FPOptionsOverride FPFeatures);\n  SourceLocation getExprLoc() const { return getOperatorLoc(); }\n  SourceLocation getOperatorLoc() const { return BinaryOperatorBits.OpLoc; }\n  void setOperatorLoc(SourceLocation L) { BinaryOperatorBits.OpLoc = L; }\n\n  Opcode getOpcode() const {\n    return static_cast<Opcode>(BinaryOperatorBits.Opc);\n  }\n  void setOpcode(Opcode Opc) { BinaryOperatorBits.Opc = Opc; }\n\n  Expr *getLHS() const { return cast<Expr>(SubExprs[LHS]); }\n  void setLHS(Expr *E) { SubExprs[LHS] = E; }\n  Expr *getRHS() const { return cast<Expr>(SubExprs[RHS]); }\n  void setRHS(Expr *E) { SubExprs[RHS] = E; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getLHS()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getRHS()->getEndLoc();\n  }\n\n  /// getOpcodeStr - Turn an Opcode enum value into the punctuation char it\n  /// corresponds to, e.g. \"<<=\".\n  static StringRef getOpcodeStr(Opcode Op);\n\n  StringRef getOpcodeStr() const { return getOpcodeStr(getOpcode()); }\n\n  /// Retrieve the binary opcode that corresponds to the given\n  /// overloaded operator.\n  static Opcode getOverloadedOpcode(OverloadedOperatorKind OO);\n\n  /// Retrieve the overloaded operator kind that corresponds to\n  /// the given binary opcode.\n  static OverloadedOperatorKind getOverloadedOperator(Opcode Opc);\n\n  /// predicates to categorize the respective opcodes.\n  static bool isPtrMemOp(Opcode Opc) {\n    return Opc == BO_PtrMemD || Opc == BO_PtrMemI;\n  }\n  bool isPtrMemOp() const { return isPtrMemOp(getOpcode()); }\n\n  static bool isMultiplicativeOp(Opcode Opc) {\n    return Opc >= BO_Mul && Opc <= BO_Rem;\n  }\n  bool isMultiplicativeOp() const { return isMultiplicativeOp(getOpcode()); }\n  static bool isAdditiveOp(Opcode Opc) { return Opc == BO_Add || Opc==BO_Sub; }\n  bool isAdditiveOp() const { return isAdditiveOp(getOpcode()); }\n  static bool isShiftOp(Opcode Opc) { return Opc == BO_Shl || Opc == BO_Shr; }\n  bool isShiftOp() const { return isShiftOp(getOpcode()); }\n\n  static bool isBitwiseOp(Opcode Opc) { return Opc >= BO_And && Opc <= BO_Or; }\n  bool isBitwiseOp() const { return isBitwiseOp(getOpcode()); }\n\n  static bool isRelationalOp(Opcode Opc) { return Opc >= BO_LT && Opc<=BO_GE; }\n  bool isRelationalOp() const { return isRelationalOp(getOpcode()); }\n\n  static bool isEqualityOp(Opcode Opc) { return Opc == BO_EQ || Opc == BO_NE; }\n  bool isEqualityOp() const { return isEqualityOp(getOpcode()); }\n\n  static bool isComparisonOp(Opcode Opc) { return Opc >= BO_Cmp && Opc<=BO_NE; }\n  bool isComparisonOp() const { return isComparisonOp(getOpcode()); }\n\n  static bool isCommaOp(Opcode Opc) { return Opc == BO_Comma; }\n  bool isCommaOp() const { return isCommaOp(getOpcode()); }\n\n  static Opcode negateComparisonOp(Opcode Opc) {\n    switch (Opc) {\n    default:\n      llvm_unreachable(\"Not a comparison operator.\");\n    case BO_LT: return BO_GE;\n    case BO_GT: return BO_LE;\n    case BO_LE: return BO_GT;\n    case BO_GE: return BO_LT;\n    case BO_EQ: return BO_NE;\n    case BO_NE: return BO_EQ;\n    }\n  }\n\n  static Opcode reverseComparisonOp(Opcode Opc) {\n    switch (Opc) {\n    default:\n      llvm_unreachable(\"Not a comparison operator.\");\n    case BO_LT: return BO_GT;\n    case BO_GT: return BO_LT;\n    case BO_LE: return BO_GE;\n    case BO_GE: return BO_LE;\n    case BO_EQ:\n    case BO_NE:\n      return Opc;\n    }\n  }\n\n  static bool isLogicalOp(Opcode Opc) { return Opc == BO_LAnd || Opc==BO_LOr; }\n  bool isLogicalOp() const { return isLogicalOp(getOpcode()); }\n\n  static bool isAssignmentOp(Opcode Opc) {\n    return Opc >= BO_Assign && Opc <= BO_OrAssign;\n  }\n  bool isAssignmentOp() const { return isAssignmentOp(getOpcode()); }\n\n  static bool isCompoundAssignmentOp(Opcode Opc) {\n    return Opc > BO_Assign && Opc <= BO_OrAssign;\n  }\n  bool isCompoundAssignmentOp() const {\n    return isCompoundAssignmentOp(getOpcode());\n  }\n  static Opcode getOpForCompoundAssignment(Opcode Opc) {\n    assert(isCompoundAssignmentOp(Opc));\n    if (Opc >= BO_AndAssign)\n      return Opcode(unsigned(Opc) - BO_AndAssign + BO_And);\n    else\n      return Opcode(unsigned(Opc) - BO_MulAssign + BO_Mul);\n  }\n\n  static bool isShiftAssignOp(Opcode Opc) {\n    return Opc == BO_ShlAssign || Opc == BO_ShrAssign;\n  }\n  bool isShiftAssignOp() const {\n    return isShiftAssignOp(getOpcode());\n  }\n\n  // Return true if a binary operator using the specified opcode and operands\n  // would match the 'p = (i8*)nullptr + n' idiom for casting a pointer-sized\n  // integer to a pointer.\n  static bool isNullPointerArithmeticExtension(ASTContext &Ctx, Opcode Opc,\n                                               Expr *LHS, Expr *RHS);\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() >= firstBinaryOperatorConstant &&\n           S->getStmtClass() <= lastBinaryOperatorConstant;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0]+END_EXPR);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n\n  /// Set and fetch the bit that shows whether FPFeatures needs to be\n  /// allocated in Trailing Storage\n  void setHasStoredFPFeatures(bool B) { BinaryOperatorBits.HasFPFeatures = B; }\n  bool hasStoredFPFeatures() const { return BinaryOperatorBits.HasFPFeatures; }\n\n  /// Get FPFeatures from trailing storage\n  FPOptionsOverride getStoredFPFeatures() const {\n    assert(hasStoredFPFeatures());\n    return *getTrailingFPFeatures();\n  }\n  /// Set FPFeatures in trailing storage, used only by Serialization\n  void setStoredFPFeatures(FPOptionsOverride F) {\n    assert(BinaryOperatorBits.HasFPFeatures);\n    *getTrailingFPFeatures() = F;\n  }\n\n  // Get the FP features status of this operator. Only meaningful for\n  // operations on floating point types.\n  FPOptions getFPFeaturesInEffect(const LangOptions &LO) const {\n    if (BinaryOperatorBits.HasFPFeatures)\n      return getStoredFPFeatures().applyOverrides(LO);\n    return FPOptions::defaultWithoutTrailingStorage(LO);\n  }\n\n  // This is used in ASTImporter\n  FPOptionsOverride getFPFeatures(const LangOptions &LO) const {\n    if (BinaryOperatorBits.HasFPFeatures)\n      return getStoredFPFeatures();\n    return FPOptionsOverride();\n  }\n\n  // Get the FP contractability status of this operator. Only meaningful for\n  // operations on floating point types.\n  bool isFPContractableWithinStatement(const LangOptions &LO) const {\n    return getFPFeaturesInEffect(LO).allowFPContractWithinStatement();\n  }\n\n  // Get the FENV_ACCESS status of this operator. Only meaningful for\n  // operations on floating point types.\n  bool isFEnvAccessOn(const LangOptions &LO) const {\n    return getFPFeaturesInEffect(LO).getAllowFEnvAccess();\n  }\n\nprotected:\n  BinaryOperator(const ASTContext &Ctx, Expr *lhs, Expr *rhs, Opcode opc,\n                 QualType ResTy, ExprValueKind VK, ExprObjectKind OK,\n                 SourceLocation opLoc, FPOptionsOverride FPFeatures,\n                 bool dead2);\n\n  /// Construct an empty BinaryOperator, SC is CompoundAssignOperator.\n  BinaryOperator(StmtClass SC, EmptyShell Empty) : Expr(SC, Empty) {\n    BinaryOperatorBits.Opc = BO_MulAssign;\n  }\n\n  /// Return the size in bytes needed for the trailing objects.\n  /// Used to allocate the right amount of storage.\n  static unsigned sizeOfTrailingObjects(bool HasFPFeatures) {\n    return HasFPFeatures * sizeof(FPOptionsOverride);\n  }\n};\n\n/// CompoundAssignOperator - For compound assignments (e.g. +=), we keep\n/// track of the type the operation is performed in.  Due to the semantics of\n/// these operators, the operands are promoted, the arithmetic performed, an\n/// implicit conversion back to the result type done, then the assignment takes\n/// place.  This captures the intermediate type which the computation is done\n/// in.\nclass CompoundAssignOperator : public BinaryOperator {\n  QualType ComputationLHSType;\n  QualType ComputationResultType;\n\n  /// Construct an empty CompoundAssignOperator.\n  explicit CompoundAssignOperator(const ASTContext &C, EmptyShell Empty,\n                                  bool hasFPFeatures)\n      : BinaryOperator(CompoundAssignOperatorClass, Empty) {}\n\nprotected:\n  CompoundAssignOperator(const ASTContext &C, Expr *lhs, Expr *rhs, Opcode opc,\n                         QualType ResType, ExprValueKind VK, ExprObjectKind OK,\n                         SourceLocation OpLoc, FPOptionsOverride FPFeatures,\n                         QualType CompLHSType, QualType CompResultType)\n      : BinaryOperator(C, lhs, rhs, opc, ResType, VK, OK, OpLoc, FPFeatures,\n                       true),\n        ComputationLHSType(CompLHSType), ComputationResultType(CompResultType) {\n    assert(isCompoundAssignmentOp() &&\n           \"Only should be used for compound assignments\");\n  }\n\npublic:\n  static CompoundAssignOperator *CreateEmpty(const ASTContext &C,\n                                             bool hasFPFeatures);\n\n  static CompoundAssignOperator *\n  Create(const ASTContext &C, Expr *lhs, Expr *rhs, Opcode opc, QualType ResTy,\n         ExprValueKind VK, ExprObjectKind OK, SourceLocation opLoc,\n         FPOptionsOverride FPFeatures, QualType CompLHSType = QualType(),\n         QualType CompResultType = QualType());\n\n  // The two computation types are the type the LHS is converted\n  // to for the computation and the type of the result; the two are\n  // distinct in a few cases (specifically, int+=ptr and ptr-=ptr).\n  QualType getComputationLHSType() const { return ComputationLHSType; }\n  void setComputationLHSType(QualType T) { ComputationLHSType = T; }\n\n  QualType getComputationResultType() const { return ComputationResultType; }\n  void setComputationResultType(QualType T) { ComputationResultType = T; }\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() == CompoundAssignOperatorClass;\n  }\n};\n\ninline size_t BinaryOperator::offsetOfTrailingStorage() const {\n  assert(BinaryOperatorBits.HasFPFeatures);\n  return isa<CompoundAssignOperator>(this) ? sizeof(CompoundAssignOperator)\n                                           : sizeof(BinaryOperator);\n}\n\n/// AbstractConditionalOperator - An abstract base class for\n/// ConditionalOperator and BinaryConditionalOperator.\nclass AbstractConditionalOperator : public Expr {\n  SourceLocation QuestionLoc, ColonLoc;\n  friend class ASTStmtReader;\n\nprotected:\n  AbstractConditionalOperator(StmtClass SC, QualType T, ExprValueKind VK,\n                              ExprObjectKind OK, SourceLocation qloc,\n                              SourceLocation cloc)\n      : Expr(SC, T, VK, OK), QuestionLoc(qloc), ColonLoc(cloc) {}\n\n  AbstractConditionalOperator(StmtClass SC, EmptyShell Empty)\n    : Expr(SC, Empty) { }\n\npublic:\n  // getCond - Return the expression representing the condition for\n  //   the ?: operator.\n  Expr *getCond() const;\n\n  // getTrueExpr - Return the subexpression representing the value of\n  //   the expression if the condition evaluates to true.\n  Expr *getTrueExpr() const;\n\n  // getFalseExpr - Return the subexpression representing the value of\n  //   the expression if the condition evaluates to false.  This is\n  //   the same as getRHS.\n  Expr *getFalseExpr() const;\n\n  SourceLocation getQuestionLoc() const { return QuestionLoc; }\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ConditionalOperatorClass ||\n           T->getStmtClass() == BinaryConditionalOperatorClass;\n  }\n};\n\n/// ConditionalOperator - The ?: ternary operator.  The GNU \"missing\n/// middle\" extension is a BinaryConditionalOperator.\nclass ConditionalOperator : public AbstractConditionalOperator {\n  enum { COND, LHS, RHS, END_EXPR };\n  Stmt* SubExprs[END_EXPR]; // Left/Middle/Right hand sides.\n\n  friend class ASTStmtReader;\npublic:\n  ConditionalOperator(Expr *cond, SourceLocation QLoc, Expr *lhs,\n                      SourceLocation CLoc, Expr *rhs, QualType t,\n                      ExprValueKind VK, ExprObjectKind OK)\n      : AbstractConditionalOperator(ConditionalOperatorClass, t, VK, OK, QLoc,\n                                    CLoc) {\n    SubExprs[COND] = cond;\n    SubExprs[LHS] = lhs;\n    SubExprs[RHS] = rhs;\n    setDependence(computeDependence(this));\n  }\n\n  /// Build an empty conditional operator.\n  explicit ConditionalOperator(EmptyShell Empty)\n    : AbstractConditionalOperator(ConditionalOperatorClass, Empty) { }\n\n  // getCond - Return the expression representing the condition for\n  //   the ?: operator.\n  Expr *getCond() const { return cast<Expr>(SubExprs[COND]); }\n\n  // getTrueExpr - Return the subexpression representing the value of\n  //   the expression if the condition evaluates to true.\n  Expr *getTrueExpr() const { return cast<Expr>(SubExprs[LHS]); }\n\n  // getFalseExpr - Return the subexpression representing the value of\n  //   the expression if the condition evaluates to false.  This is\n  //   the same as getRHS.\n  Expr *getFalseExpr() const { return cast<Expr>(SubExprs[RHS]); }\n\n  Expr *getLHS() const { return cast<Expr>(SubExprs[LHS]); }\n  Expr *getRHS() const { return cast<Expr>(SubExprs[RHS]); }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getCond()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getRHS()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ConditionalOperatorClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0]+END_EXPR);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n};\n\n/// BinaryConditionalOperator - The GNU extension to the conditional\n/// operator which allows the middle operand to be omitted.\n///\n/// This is a different expression kind on the assumption that almost\n/// every client ends up needing to know that these are different.\nclass BinaryConditionalOperator : public AbstractConditionalOperator {\n  enum { COMMON, COND, LHS, RHS, NUM_SUBEXPRS };\n\n  /// - the common condition/left-hand-side expression, which will be\n  ///   evaluated as the opaque value\n  /// - the condition, expressed in terms of the opaque value\n  /// - the left-hand-side, expressed in terms of the opaque value\n  /// - the right-hand-side\n  Stmt *SubExprs[NUM_SUBEXPRS];\n  OpaqueValueExpr *OpaqueValue;\n\n  friend class ASTStmtReader;\npublic:\n  BinaryConditionalOperator(Expr *common, OpaqueValueExpr *opaqueValue,\n                            Expr *cond, Expr *lhs, Expr *rhs,\n                            SourceLocation qloc, SourceLocation cloc,\n                            QualType t, ExprValueKind VK, ExprObjectKind OK)\n      : AbstractConditionalOperator(BinaryConditionalOperatorClass, t, VK, OK,\n                                    qloc, cloc),\n        OpaqueValue(opaqueValue) {\n    SubExprs[COMMON] = common;\n    SubExprs[COND] = cond;\n    SubExprs[LHS] = lhs;\n    SubExprs[RHS] = rhs;\n    assert(OpaqueValue->getSourceExpr() == common && \"Wrong opaque value\");\n    setDependence(computeDependence(this));\n  }\n\n  /// Build an empty conditional operator.\n  explicit BinaryConditionalOperator(EmptyShell Empty)\n    : AbstractConditionalOperator(BinaryConditionalOperatorClass, Empty) { }\n\n  /// getCommon - Return the common expression, written to the\n  ///   left of the condition.  The opaque value will be bound to the\n  ///   result of this expression.\n  Expr *getCommon() const { return cast<Expr>(SubExprs[COMMON]); }\n\n  /// getOpaqueValue - Return the opaque value placeholder.\n  OpaqueValueExpr *getOpaqueValue() const { return OpaqueValue; }\n\n  /// getCond - Return the condition expression; this is defined\n  ///   in terms of the opaque value.\n  Expr *getCond() const { return cast<Expr>(SubExprs[COND]); }\n\n  /// getTrueExpr - Return the subexpression which will be\n  ///   evaluated if the condition evaluates to true;  this is defined\n  ///   in terms of the opaque value.\n  Expr *getTrueExpr() const {\n    return cast<Expr>(SubExprs[LHS]);\n  }\n\n  /// getFalseExpr - Return the subexpression which will be\n  ///   evaluated if the condnition evaluates to false; this is\n  ///   defined in terms of the opaque value.\n  Expr *getFalseExpr() const {\n    return cast<Expr>(SubExprs[RHS]);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getCommon()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getFalseExpr()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == BinaryConditionalOperatorClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(SubExprs, SubExprs + NUM_SUBEXPRS);\n  }\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + NUM_SUBEXPRS);\n  }\n};\n\ninline Expr *AbstractConditionalOperator::getCond() const {\n  if (const ConditionalOperator *co = dyn_cast<ConditionalOperator>(this))\n    return co->getCond();\n  return cast<BinaryConditionalOperator>(this)->getCond();\n}\n\ninline Expr *AbstractConditionalOperator::getTrueExpr() const {\n  if (const ConditionalOperator *co = dyn_cast<ConditionalOperator>(this))\n    return co->getTrueExpr();\n  return cast<BinaryConditionalOperator>(this)->getTrueExpr();\n}\n\ninline Expr *AbstractConditionalOperator::getFalseExpr() const {\n  if (const ConditionalOperator *co = dyn_cast<ConditionalOperator>(this))\n    return co->getFalseExpr();\n  return cast<BinaryConditionalOperator>(this)->getFalseExpr();\n}\n\n/// AddrLabelExpr - The GNU address of label extension, representing &&label.\nclass AddrLabelExpr : public Expr {\n  SourceLocation AmpAmpLoc, LabelLoc;\n  LabelDecl *Label;\npublic:\n  AddrLabelExpr(SourceLocation AALoc, SourceLocation LLoc, LabelDecl *L,\n                QualType t)\n      : Expr(AddrLabelExprClass, t, VK_RValue, OK_Ordinary), AmpAmpLoc(AALoc),\n        LabelLoc(LLoc), Label(L) {\n    setDependence(ExprDependence::None);\n  }\n\n  /// Build an empty address of a label expression.\n  explicit AddrLabelExpr(EmptyShell Empty)\n    : Expr(AddrLabelExprClass, Empty) { }\n\n  SourceLocation getAmpAmpLoc() const { return AmpAmpLoc; }\n  void setAmpAmpLoc(SourceLocation L) { AmpAmpLoc = L; }\n  SourceLocation getLabelLoc() const { return LabelLoc; }\n  void setLabelLoc(SourceLocation L) { LabelLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AmpAmpLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return LabelLoc; }\n\n  LabelDecl *getLabel() const { return Label; }\n  void setLabel(LabelDecl *L) { Label = L; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == AddrLabelExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// StmtExpr - This is the GNU Statement Expression extension: ({int X=4; X;}).\n/// The StmtExpr contains a single CompoundStmt node, which it evaluates and\n/// takes the value of the last subexpression.\n///\n/// A StmtExpr is always an r-value; values \"returned\" out of a\n/// StmtExpr will be copied.\nclass StmtExpr : public Expr {\n  Stmt *SubStmt;\n  SourceLocation LParenLoc, RParenLoc;\npublic:\n  StmtExpr(CompoundStmt *SubStmt, QualType T, SourceLocation LParenLoc,\n           SourceLocation RParenLoc, unsigned TemplateDepth)\n      : Expr(StmtExprClass, T, VK_RValue, OK_Ordinary), SubStmt(SubStmt),\n        LParenLoc(LParenLoc), RParenLoc(RParenLoc) {\n    setDependence(computeDependence(this, TemplateDepth));\n    // FIXME: A templated statement expression should have an associated\n    // DeclContext so that nested declarations always have a dependent context.\n    StmtExprBits.TemplateDepth = TemplateDepth;\n  }\n\n  /// Build an empty statement expression.\n  explicit StmtExpr(EmptyShell Empty) : Expr(StmtExprClass, Empty) { }\n\n  CompoundStmt *getSubStmt() { return cast<CompoundStmt>(SubStmt); }\n  const CompoundStmt *getSubStmt() const { return cast<CompoundStmt>(SubStmt); }\n  void setSubStmt(CompoundStmt *S) { SubStmt = S; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return LParenLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  void setLParenLoc(SourceLocation L) { LParenLoc = L; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  unsigned getTemplateDepth() const { return StmtExprBits.TemplateDepth; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == StmtExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&SubStmt, &SubStmt+1); }\n  const_child_range children() const {\n    return const_child_range(&SubStmt, &SubStmt + 1);\n  }\n};\n\n/// ShuffleVectorExpr - clang-specific builtin-in function\n/// __builtin_shufflevector.\n/// This AST node represents a operator that does a constant\n/// shuffle, similar to LLVM's shufflevector instruction. It takes\n/// two vectors and a variable number of constant indices,\n/// and returns the appropriately shuffled vector.\nclass ShuffleVectorExpr : public Expr {\n  SourceLocation BuiltinLoc, RParenLoc;\n\n  // SubExprs - the list of values passed to the __builtin_shufflevector\n  // function. The first two are vectors, and the rest are constant\n  // indices.  The number of values in this list is always\n  // 2+the number of indices in the vector type.\n  Stmt **SubExprs;\n  unsigned NumExprs;\n\npublic:\n  ShuffleVectorExpr(const ASTContext &C, ArrayRef<Expr*> args, QualType Type,\n                    SourceLocation BLoc, SourceLocation RP);\n\n  /// Build an empty vector-shuffle expression.\n  explicit ShuffleVectorExpr(EmptyShell Empty)\n    : Expr(ShuffleVectorExprClass, Empty), SubExprs(nullptr) { }\n\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n  void setBuiltinLoc(SourceLocation L) { BuiltinLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ShuffleVectorExprClass;\n  }\n\n  /// getNumSubExprs - Return the size of the SubExprs array.  This includes the\n  /// constant expression, the actual arguments passed in, and the function\n  /// pointers.\n  unsigned getNumSubExprs() const { return NumExprs; }\n\n  /// Retrieve the array of expressions.\n  Expr **getSubExprs() { return reinterpret_cast<Expr **>(SubExprs); }\n\n  /// getExpr - Return the Expr at the specified index.\n  Expr *getExpr(unsigned Index) {\n    assert((Index < NumExprs) && \"Arg access out of range!\");\n    return cast<Expr>(SubExprs[Index]);\n  }\n  const Expr *getExpr(unsigned Index) const {\n    assert((Index < NumExprs) && \"Arg access out of range!\");\n    return cast<Expr>(SubExprs[Index]);\n  }\n\n  void setExprs(const ASTContext &C, ArrayRef<Expr *> Exprs);\n\n  llvm::APSInt getShuffleMaskIdx(const ASTContext &Ctx, unsigned N) const {\n    assert((N < NumExprs - 2) && \"Shuffle idx out of range!\");\n    return getExpr(N+2)->EvaluateKnownConstInt(Ctx);\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0]+NumExprs);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + NumExprs);\n  }\n};\n\n/// ConvertVectorExpr - Clang builtin function __builtin_convertvector\n/// This AST node provides support for converting a vector type to another\n/// vector type of the same arity.\nclass ConvertVectorExpr : public Expr {\nprivate:\n  Stmt *SrcExpr;\n  TypeSourceInfo *TInfo;\n  SourceLocation BuiltinLoc, RParenLoc;\n\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  explicit ConvertVectorExpr(EmptyShell Empty) : Expr(ConvertVectorExprClass, Empty) {}\n\npublic:\n  ConvertVectorExpr(Expr *SrcExpr, TypeSourceInfo *TI, QualType DstType,\n                    ExprValueKind VK, ExprObjectKind OK,\n                    SourceLocation BuiltinLoc, SourceLocation RParenLoc)\n      : Expr(ConvertVectorExprClass, DstType, VK, OK), SrcExpr(SrcExpr),\n        TInfo(TI), BuiltinLoc(BuiltinLoc), RParenLoc(RParenLoc) {\n    setDependence(computeDependence(this));\n  }\n\n  /// getSrcExpr - Return the Expr to be converted.\n  Expr *getSrcExpr() const { return cast<Expr>(SrcExpr); }\n\n  /// getTypeSourceInfo - Return the destination type.\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return TInfo;\n  }\n  void setTypeSourceInfo(TypeSourceInfo *ti) {\n    TInfo = ti;\n  }\n\n  /// getBuiltinLoc - Return the location of the __builtin_convertvector token.\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n\n  /// getRParenLoc - Return the location of final right parenthesis.\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ConvertVectorExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&SrcExpr, &SrcExpr+1); }\n  const_child_range children() const {\n    return const_child_range(&SrcExpr, &SrcExpr + 1);\n  }\n};\n\n/// ChooseExpr - GNU builtin-in function __builtin_choose_expr.\n/// This AST node is similar to the conditional operator (?:) in C, with\n/// the following exceptions:\n/// - the test expression must be a integer constant expression.\n/// - the expression returned acts like the chosen subexpression in every\n///   visible way: the type is the same as that of the chosen subexpression,\n///   and all predicates (whether it's an l-value, whether it's an integer\n///   constant expression, etc.) return the same result as for the chosen\n///   sub-expression.\nclass ChooseExpr : public Expr {\n  enum { COND, LHS, RHS, END_EXPR };\n  Stmt* SubExprs[END_EXPR]; // Left/Middle/Right hand sides.\n  SourceLocation BuiltinLoc, RParenLoc;\n  bool CondIsTrue;\npublic:\n  ChooseExpr(SourceLocation BLoc, Expr *cond, Expr *lhs, Expr *rhs, QualType t,\n             ExprValueKind VK, ExprObjectKind OK, SourceLocation RP,\n             bool condIsTrue)\n      : Expr(ChooseExprClass, t, VK, OK), BuiltinLoc(BLoc), RParenLoc(RP),\n        CondIsTrue(condIsTrue) {\n    SubExprs[COND] = cond;\n    SubExprs[LHS] = lhs;\n    SubExprs[RHS] = rhs;\n\n    setDependence(computeDependence(this));\n  }\n\n  /// Build an empty __builtin_choose_expr.\n  explicit ChooseExpr(EmptyShell Empty) : Expr(ChooseExprClass, Empty) { }\n\n  /// isConditionTrue - Return whether the condition is true (i.e. not\n  /// equal to zero).\n  bool isConditionTrue() const {\n    assert(!isConditionDependent() &&\n           \"Dependent condition isn't true or false\");\n    return CondIsTrue;\n  }\n  void setIsConditionTrue(bool isTrue) { CondIsTrue = isTrue; }\n\n  bool isConditionDependent() const {\n    return getCond()->isTypeDependent() || getCond()->isValueDependent();\n  }\n\n  /// getChosenSubExpr - Return the subexpression chosen according to the\n  /// condition.\n  Expr *getChosenSubExpr() const {\n    return isConditionTrue() ? getLHS() : getRHS();\n  }\n\n  Expr *getCond() const { return cast<Expr>(SubExprs[COND]); }\n  void setCond(Expr *E) { SubExprs[COND] = E; }\n  Expr *getLHS() const { return cast<Expr>(SubExprs[LHS]); }\n  void setLHS(Expr *E) { SubExprs[LHS] = E; }\n  Expr *getRHS() const { return cast<Expr>(SubExprs[RHS]); }\n  void setRHS(Expr *E) { SubExprs[RHS] = E; }\n\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n  void setBuiltinLoc(SourceLocation L) { BuiltinLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ChooseExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0]+END_EXPR);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n};\n\n/// GNUNullExpr - Implements the GNU __null extension, which is a name\n/// for a null pointer constant that has integral type (e.g., int or\n/// long) and is the same size and alignment as a pointer. The __null\n/// extension is typically only used by system headers, which define\n/// NULL as __null in C++ rather than using 0 (which is an integer\n/// that may not match the size of a pointer).\nclass GNUNullExpr : public Expr {\n  /// TokenLoc - The location of the __null keyword.\n  SourceLocation TokenLoc;\n\npublic:\n  GNUNullExpr(QualType Ty, SourceLocation Loc)\n      : Expr(GNUNullExprClass, Ty, VK_RValue, OK_Ordinary), TokenLoc(Loc) {\n    setDependence(ExprDependence::None);\n  }\n\n  /// Build an empty GNU __null expression.\n  explicit GNUNullExpr(EmptyShell Empty) : Expr(GNUNullExprClass, Empty) { }\n\n  /// getTokenLocation - The location of the __null token.\n  SourceLocation getTokenLocation() const { return TokenLoc; }\n  void setTokenLocation(SourceLocation L) { TokenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return TokenLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return TokenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == GNUNullExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Represents a call to the builtin function \\c __builtin_va_arg.\nclass VAArgExpr : public Expr {\n  Stmt *Val;\n  llvm::PointerIntPair<TypeSourceInfo *, 1, bool> TInfo;\n  SourceLocation BuiltinLoc, RParenLoc;\npublic:\n  VAArgExpr(SourceLocation BLoc, Expr *e, TypeSourceInfo *TInfo,\n            SourceLocation RPLoc, QualType t, bool IsMS)\n      : Expr(VAArgExprClass, t, VK_RValue, OK_Ordinary), Val(e),\n        TInfo(TInfo, IsMS), BuiltinLoc(BLoc), RParenLoc(RPLoc) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Create an empty __builtin_va_arg expression.\n  explicit VAArgExpr(EmptyShell Empty)\n      : Expr(VAArgExprClass, Empty), Val(nullptr), TInfo(nullptr, false) {}\n\n  const Expr *getSubExpr() const { return cast<Expr>(Val); }\n  Expr *getSubExpr() { return cast<Expr>(Val); }\n  void setSubExpr(Expr *E) { Val = E; }\n\n  /// Returns whether this is really a Win64 ABI va_arg expression.\n  bool isMicrosoftABI() const { return TInfo.getInt(); }\n  void setIsMicrosoftABI(bool IsMS) { TInfo.setInt(IsMS); }\n\n  TypeSourceInfo *getWrittenTypeInfo() const { return TInfo.getPointer(); }\n  void setWrittenTypeInfo(TypeSourceInfo *TI) { TInfo.setPointer(TI); }\n\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n  void setBuiltinLoc(SourceLocation L) { BuiltinLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == VAArgExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Val, &Val+1); }\n  const_child_range children() const {\n    return const_child_range(&Val, &Val + 1);\n  }\n};\n\n/// Represents a function call to one of __builtin_LINE(), __builtin_COLUMN(),\n/// __builtin_FUNCTION(), or __builtin_FILE().\nclass SourceLocExpr final : public Expr {\n  SourceLocation BuiltinLoc, RParenLoc;\n  DeclContext *ParentContext;\n\npublic:\n  enum IdentKind { Function, File, Line, Column };\n\n  SourceLocExpr(const ASTContext &Ctx, IdentKind Type, SourceLocation BLoc,\n                SourceLocation RParenLoc, DeclContext *Context);\n\n  /// Build an empty call expression.\n  explicit SourceLocExpr(EmptyShell Empty) : Expr(SourceLocExprClass, Empty) {}\n\n  /// Return the result of evaluating this SourceLocExpr in the specified\n  /// (and possibly null) default argument or initialization context.\n  APValue EvaluateInContext(const ASTContext &Ctx,\n                            const Expr *DefaultExpr) const;\n\n  /// Return a string representing the name of the specific builtin function.\n  StringRef getBuiltinStr() const;\n\n  IdentKind getIdentKind() const {\n    return static_cast<IdentKind>(SourceLocExprBits.Kind);\n  }\n\n  bool isStringType() const {\n    switch (getIdentKind()) {\n    case File:\n    case Function:\n      return true;\n    case Line:\n    case Column:\n      return false;\n    }\n    llvm_unreachable(\"unknown source location expression kind\");\n  }\n  bool isIntType() const LLVM_READONLY { return !isStringType(); }\n\n  /// If the SourceLocExpr has been resolved return the subexpression\n  /// representing the resolved value. Otherwise return null.\n  const DeclContext *getParentContext() const { return ParentContext; }\n  DeclContext *getParentContext() { return ParentContext; }\n\n  SourceLocation getLocation() const { return BuiltinLoc; }\n  SourceLocation getBeginLoc() const { return BuiltinLoc; }\n  SourceLocation getEndLoc() const { return RParenLoc; }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(child_iterator(), child_iterator());\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == SourceLocExprClass;\n  }\n\nprivate:\n  friend class ASTStmtReader;\n};\n\n/// Describes an C or C++ initializer list.\n///\n/// InitListExpr describes an initializer list, which can be used to\n/// initialize objects of different types, including\n/// struct/class/union types, arrays, and vectors. For example:\n///\n/// @code\n/// struct foo x = { 1, { 2, 3 } };\n/// @endcode\n///\n/// Prior to semantic analysis, an initializer list will represent the\n/// initializer list as written by the user, but will have the\n/// placeholder type \"void\". This initializer list is called the\n/// syntactic form of the initializer, and may contain C99 designated\n/// initializers (represented as DesignatedInitExprs), initializations\n/// of subobject members without explicit braces, and so on. Clients\n/// interested in the original syntax of the initializer list should\n/// use the syntactic form of the initializer list.\n///\n/// After semantic analysis, the initializer list will represent the\n/// semantic form of the initializer, where the initializations of all\n/// subobjects are made explicit with nested InitListExpr nodes and\n/// C99 designators have been eliminated by placing the designated\n/// initializations into the subobject they initialize. Additionally,\n/// any \"holes\" in the initialization, where no initializer has been\n/// specified for a particular subobject, will be replaced with\n/// implicitly-generated ImplicitValueInitExpr expressions that\n/// value-initialize the subobjects. Note, however, that the\n/// initializer lists may still have fewer initializers than there are\n/// elements to initialize within the object.\n///\n/// After semantic analysis has completed, given an initializer list,\n/// method isSemanticForm() returns true if and only if this is the\n/// semantic form of the initializer list (note: the same AST node\n/// may at the same time be the syntactic form).\n/// Given the semantic form of the initializer list, one can retrieve\n/// the syntactic form of that initializer list (when different)\n/// using method getSyntacticForm(); the method returns null if applied\n/// to a initializer list which is already in syntactic form.\n/// Similarly, given the syntactic form (i.e., an initializer list such\n/// that isSemanticForm() returns false), one can retrieve the semantic\n/// form using method getSemanticForm().\n/// Since many initializer lists have the same syntactic and semantic forms,\n/// getSyntacticForm() may return NULL, indicating that the current\n/// semantic initializer list also serves as its syntactic form.\nclass InitListExpr : public Expr {\n  // FIXME: Eliminate this vector in favor of ASTContext allocation\n  typedef ASTVector<Stmt *> InitExprsTy;\n  InitExprsTy InitExprs;\n  SourceLocation LBraceLoc, RBraceLoc;\n\n  /// The alternative form of the initializer list (if it exists).\n  /// The int part of the pair stores whether this initializer list is\n  /// in semantic form. If not null, the pointer points to:\n  ///   - the syntactic form, if this is in semantic form;\n  ///   - the semantic form, if this is in syntactic form.\n  llvm::PointerIntPair<InitListExpr *, 1, bool> AltForm;\n\n  /// Either:\n  ///  If this initializer list initializes an array with more elements than\n  ///  there are initializers in the list, specifies an expression to be used\n  ///  for value initialization of the rest of the elements.\n  /// Or\n  ///  If this initializer list initializes a union, specifies which\n  ///  field within the union will be initialized.\n  llvm::PointerUnion<Expr *, FieldDecl *> ArrayFillerOrUnionFieldInit;\n\npublic:\n  InitListExpr(const ASTContext &C, SourceLocation lbraceloc,\n               ArrayRef<Expr*> initExprs, SourceLocation rbraceloc);\n\n  /// Build an empty initializer list.\n  explicit InitListExpr(EmptyShell Empty)\n    : Expr(InitListExprClass, Empty), AltForm(nullptr, true) { }\n\n  unsigned getNumInits() const { return InitExprs.size(); }\n\n  /// Retrieve the set of initializers.\n  Expr **getInits() { return reinterpret_cast<Expr **>(InitExprs.data()); }\n\n  /// Retrieve the set of initializers.\n  Expr * const *getInits() const {\n    return reinterpret_cast<Expr * const *>(InitExprs.data());\n  }\n\n  ArrayRef<Expr *> inits() {\n    return llvm::makeArrayRef(getInits(), getNumInits());\n  }\n\n  ArrayRef<Expr *> inits() const {\n    return llvm::makeArrayRef(getInits(), getNumInits());\n  }\n\n  const Expr *getInit(unsigned Init) const {\n    assert(Init < getNumInits() && \"Initializer access out of range!\");\n    return cast_or_null<Expr>(InitExprs[Init]);\n  }\n\n  Expr *getInit(unsigned Init) {\n    assert(Init < getNumInits() && \"Initializer access out of range!\");\n    return cast_or_null<Expr>(InitExprs[Init]);\n  }\n\n  void setInit(unsigned Init, Expr *expr) {\n    assert(Init < getNumInits() && \"Initializer access out of range!\");\n    InitExprs[Init] = expr;\n\n    if (expr)\n      setDependence(getDependence() | expr->getDependence());\n  }\n\n  /// Mark the semantic form of the InitListExpr as error when the semantic\n  /// analysis fails.\n  void markError() {\n    assert(isSemanticForm());\n    setDependence(getDependence() | ExprDependence::ErrorDependent);\n  }\n\n  /// Reserve space for some number of initializers.\n  void reserveInits(const ASTContext &C, unsigned NumInits);\n\n  /// Specify the number of initializers\n  ///\n  /// If there are more than @p NumInits initializers, the remaining\n  /// initializers will be destroyed. If there are fewer than @p\n  /// NumInits initializers, NULL expressions will be added for the\n  /// unknown initializers.\n  void resizeInits(const ASTContext &Context, unsigned NumInits);\n\n  /// Updates the initializer at index @p Init with the new\n  /// expression @p expr, and returns the old expression at that\n  /// location.\n  ///\n  /// When @p Init is out of range for this initializer list, the\n  /// initializer list will be extended with NULL expressions to\n  /// accommodate the new entry.\n  Expr *updateInit(const ASTContext &C, unsigned Init, Expr *expr);\n\n  /// If this initializer list initializes an array with more elements\n  /// than there are initializers in the list, specifies an expression to be\n  /// used for value initialization of the rest of the elements.\n  Expr *getArrayFiller() {\n    return ArrayFillerOrUnionFieldInit.dyn_cast<Expr *>();\n  }\n  const Expr *getArrayFiller() const {\n    return const_cast<InitListExpr *>(this)->getArrayFiller();\n  }\n  void setArrayFiller(Expr *filler);\n\n  /// Return true if this is an array initializer and its array \"filler\"\n  /// has been set.\n  bool hasArrayFiller() const { return getArrayFiller(); }\n\n  /// If this initializes a union, specifies which field in the\n  /// union to initialize.\n  ///\n  /// Typically, this field is the first named field within the\n  /// union. However, a designated initializer can specify the\n  /// initialization of a different field within the union.\n  FieldDecl *getInitializedFieldInUnion() {\n    return ArrayFillerOrUnionFieldInit.dyn_cast<FieldDecl *>();\n  }\n  const FieldDecl *getInitializedFieldInUnion() const {\n    return const_cast<InitListExpr *>(this)->getInitializedFieldInUnion();\n  }\n  void setInitializedFieldInUnion(FieldDecl *FD) {\n    assert((FD == nullptr\n            || getInitializedFieldInUnion() == nullptr\n            || getInitializedFieldInUnion() == FD)\n           && \"Only one field of a union may be initialized at a time!\");\n    ArrayFillerOrUnionFieldInit = FD;\n  }\n\n  // Explicit InitListExpr's originate from source code (and have valid source\n  // locations). Implicit InitListExpr's are created by the semantic analyzer.\n  // FIXME: This is wrong; InitListExprs created by semantic analysis have\n  // valid source locations too!\n  bool isExplicit() const {\n    return LBraceLoc.isValid() && RBraceLoc.isValid();\n  }\n\n  // Is this an initializer for an array of characters, initialized by a string\n  // literal or an @encode?\n  bool isStringLiteralInit() const;\n\n  /// Is this a transparent initializer list (that is, an InitListExpr that is\n  /// purely syntactic, and whose semantics are that of the sole contained\n  /// initializer)?\n  bool isTransparent() const;\n\n  /// Is this the zero initializer {0} in a language which considers it\n  /// idiomatic?\n  bool isIdiomaticZeroInitializer(const LangOptions &LangOpts) const;\n\n  SourceLocation getLBraceLoc() const { return LBraceLoc; }\n  void setLBraceLoc(SourceLocation Loc) { LBraceLoc = Loc; }\n  SourceLocation getRBraceLoc() const { return RBraceLoc; }\n  void setRBraceLoc(SourceLocation Loc) { RBraceLoc = Loc; }\n\n  bool isSemanticForm() const { return AltForm.getInt(); }\n  InitListExpr *getSemanticForm() const {\n    return isSemanticForm() ? nullptr : AltForm.getPointer();\n  }\n  bool isSyntacticForm() const {\n    return !AltForm.getInt() || !AltForm.getPointer();\n  }\n  InitListExpr *getSyntacticForm() const {\n    return isSemanticForm() ? AltForm.getPointer() : nullptr;\n  }\n\n  void setSyntacticForm(InitListExpr *Init) {\n    AltForm.setPointer(Init);\n    AltForm.setInt(true);\n    Init->AltForm.setPointer(this);\n    Init->AltForm.setInt(false);\n  }\n\n  bool hadArrayRangeDesignator() const {\n    return InitListExprBits.HadArrayRangeDesignator != 0;\n  }\n  void sawArrayRangeDesignator(bool ARD = true) {\n    InitListExprBits.HadArrayRangeDesignator = ARD;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == InitListExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    const_child_range CCR = const_cast<const InitListExpr *>(this)->children();\n    return child_range(cast_away_const(CCR.begin()),\n                       cast_away_const(CCR.end()));\n  }\n\n  const_child_range children() const {\n    // FIXME: This does not include the array filler expression.\n    if (InitExprs.empty())\n      return const_child_range(const_child_iterator(), const_child_iterator());\n    return const_child_range(&InitExprs[0], &InitExprs[0] + InitExprs.size());\n  }\n\n  typedef InitExprsTy::iterator iterator;\n  typedef InitExprsTy::const_iterator const_iterator;\n  typedef InitExprsTy::reverse_iterator reverse_iterator;\n  typedef InitExprsTy::const_reverse_iterator const_reverse_iterator;\n\n  iterator begin() { return InitExprs.begin(); }\n  const_iterator begin() const { return InitExprs.begin(); }\n  iterator end() { return InitExprs.end(); }\n  const_iterator end() const { return InitExprs.end(); }\n  reverse_iterator rbegin() { return InitExprs.rbegin(); }\n  const_reverse_iterator rbegin() const { return InitExprs.rbegin(); }\n  reverse_iterator rend() { return InitExprs.rend(); }\n  const_reverse_iterator rend() const { return InitExprs.rend(); }\n\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n};\n\n/// Represents a C99 designated initializer expression.\n///\n/// A designated initializer expression (C99 6.7.8) contains one or\n/// more designators (which can be field designators, array\n/// designators, or GNU array-range designators) followed by an\n/// expression that initializes the field or element(s) that the\n/// designators refer to. For example, given:\n///\n/// @code\n/// struct point {\n///   double x;\n///   double y;\n/// };\n/// struct point ptarray[10] = { [2].y = 1.0, [2].x = 2.0, [0].x = 1.0 };\n/// @endcode\n///\n/// The InitListExpr contains three DesignatedInitExprs, the first of\n/// which covers @c [2].y=1.0. This DesignatedInitExpr will have two\n/// designators, one array designator for @c [2] followed by one field\n/// designator for @c .y. The initialization expression will be 1.0.\nclass DesignatedInitExpr final\n    : public Expr,\n      private llvm::TrailingObjects<DesignatedInitExpr, Stmt *> {\npublic:\n  /// Forward declaration of the Designator class.\n  class Designator;\n\nprivate:\n  /// The location of the '=' or ':' prior to the actual initializer\n  /// expression.\n  SourceLocation EqualOrColonLoc;\n\n  /// Whether this designated initializer used the GNU deprecated\n  /// syntax rather than the C99 '=' syntax.\n  unsigned GNUSyntax : 1;\n\n  /// The number of designators in this initializer expression.\n  unsigned NumDesignators : 15;\n\n  /// The number of subexpressions of this initializer expression,\n  /// which contains both the initializer and any additional\n  /// expressions used by array and array-range designators.\n  unsigned NumSubExprs : 16;\n\n  /// The designators in this designated initialization\n  /// expression.\n  Designator *Designators;\n\n  DesignatedInitExpr(const ASTContext &C, QualType Ty,\n                     llvm::ArrayRef<Designator> Designators,\n                     SourceLocation EqualOrColonLoc, bool GNUSyntax,\n                     ArrayRef<Expr *> IndexExprs, Expr *Init);\n\n  explicit DesignatedInitExpr(unsigned NumSubExprs)\n    : Expr(DesignatedInitExprClass, EmptyShell()),\n      NumDesignators(0), NumSubExprs(NumSubExprs), Designators(nullptr) { }\n\npublic:\n  /// A field designator, e.g., \".x\".\n  struct FieldDesignator {\n    /// Refers to the field that is being initialized. The low bit\n    /// of this field determines whether this is actually a pointer\n    /// to an IdentifierInfo (if 1) or a FieldDecl (if 0). When\n    /// initially constructed, a field designator will store an\n    /// IdentifierInfo*. After semantic analysis has resolved that\n    /// name, the field designator will instead store a FieldDecl*.\n    uintptr_t NameOrField;\n\n    /// The location of the '.' in the designated initializer.\n    SourceLocation DotLoc;\n\n    /// The location of the field name in the designated initializer.\n    SourceLocation FieldLoc;\n  };\n\n  /// An array or GNU array-range designator, e.g., \"[9]\" or \"[10..15]\".\n  struct ArrayOrRangeDesignator {\n    /// Location of the first index expression within the designated\n    /// initializer expression's list of subexpressions.\n    unsigned Index;\n    /// The location of the '[' starting the array range designator.\n    SourceLocation LBracketLoc;\n    /// The location of the ellipsis separating the start and end\n    /// indices. Only valid for GNU array-range designators.\n    SourceLocation EllipsisLoc;\n    /// The location of the ']' terminating the array range designator.\n    SourceLocation RBracketLoc;\n  };\n\n  /// Represents a single C99 designator.\n  ///\n  /// @todo This class is infuriatingly similar to clang::Designator,\n  /// but minor differences (storing indices vs. storing pointers)\n  /// keep us from reusing it. Try harder, later, to rectify these\n  /// differences.\n  class Designator {\n    /// The kind of designator this describes.\n    enum {\n      FieldDesignator,\n      ArrayDesignator,\n      ArrayRangeDesignator\n    } Kind;\n\n    union {\n      /// A field designator, e.g., \".x\".\n      struct FieldDesignator Field;\n      /// An array or GNU array-range designator, e.g., \"[9]\" or \"[10..15]\".\n      struct ArrayOrRangeDesignator ArrayOrRange;\n    };\n    friend class DesignatedInitExpr;\n\n  public:\n    Designator() {}\n\n    /// Initializes a field designator.\n    Designator(const IdentifierInfo *FieldName, SourceLocation DotLoc,\n               SourceLocation FieldLoc)\n      : Kind(FieldDesignator) {\n      new (&Field) DesignatedInitExpr::FieldDesignator;\n      Field.NameOrField = reinterpret_cast<uintptr_t>(FieldName) | 0x01;\n      Field.DotLoc = DotLoc;\n      Field.FieldLoc = FieldLoc;\n    }\n\n    /// Initializes an array designator.\n    Designator(unsigned Index, SourceLocation LBracketLoc,\n               SourceLocation RBracketLoc)\n      : Kind(ArrayDesignator) {\n      new (&ArrayOrRange) DesignatedInitExpr::ArrayOrRangeDesignator;\n      ArrayOrRange.Index = Index;\n      ArrayOrRange.LBracketLoc = LBracketLoc;\n      ArrayOrRange.EllipsisLoc = SourceLocation();\n      ArrayOrRange.RBracketLoc = RBracketLoc;\n    }\n\n    /// Initializes a GNU array-range designator.\n    Designator(unsigned Index, SourceLocation LBracketLoc,\n               SourceLocation EllipsisLoc, SourceLocation RBracketLoc)\n      : Kind(ArrayRangeDesignator) {\n      new (&ArrayOrRange) DesignatedInitExpr::ArrayOrRangeDesignator;\n      ArrayOrRange.Index = Index;\n      ArrayOrRange.LBracketLoc = LBracketLoc;\n      ArrayOrRange.EllipsisLoc = EllipsisLoc;\n      ArrayOrRange.RBracketLoc = RBracketLoc;\n    }\n\n    bool isFieldDesignator() const { return Kind == FieldDesignator; }\n    bool isArrayDesignator() const { return Kind == ArrayDesignator; }\n    bool isArrayRangeDesignator() const { return Kind == ArrayRangeDesignator; }\n\n    IdentifierInfo *getFieldName() const;\n\n    FieldDecl *getField() const {\n      assert(Kind == FieldDesignator && \"Only valid on a field designator\");\n      if (Field.NameOrField & 0x01)\n        return nullptr;\n      else\n        return reinterpret_cast<FieldDecl *>(Field.NameOrField);\n    }\n\n    void setField(FieldDecl *FD) {\n      assert(Kind == FieldDesignator && \"Only valid on a field designator\");\n      Field.NameOrField = reinterpret_cast<uintptr_t>(FD);\n    }\n\n    SourceLocation getDotLoc() const {\n      assert(Kind == FieldDesignator && \"Only valid on a field designator\");\n      return Field.DotLoc;\n    }\n\n    SourceLocation getFieldLoc() const {\n      assert(Kind == FieldDesignator && \"Only valid on a field designator\");\n      return Field.FieldLoc;\n    }\n\n    SourceLocation getLBracketLoc() const {\n      assert((Kind == ArrayDesignator || Kind == ArrayRangeDesignator) &&\n             \"Only valid on an array or array-range designator\");\n      return ArrayOrRange.LBracketLoc;\n    }\n\n    SourceLocation getRBracketLoc() const {\n      assert((Kind == ArrayDesignator || Kind == ArrayRangeDesignator) &&\n             \"Only valid on an array or array-range designator\");\n      return ArrayOrRange.RBracketLoc;\n    }\n\n    SourceLocation getEllipsisLoc() const {\n      assert(Kind == ArrayRangeDesignator &&\n             \"Only valid on an array-range designator\");\n      return ArrayOrRange.EllipsisLoc;\n    }\n\n    unsigned getFirstExprIndex() const {\n      assert((Kind == ArrayDesignator || Kind == ArrayRangeDesignator) &&\n             \"Only valid on an array or array-range designator\");\n      return ArrayOrRange.Index;\n    }\n\n    SourceLocation getBeginLoc() const LLVM_READONLY {\n      if (Kind == FieldDesignator)\n        return getDotLoc().isInvalid()? getFieldLoc() : getDotLoc();\n      else\n        return getLBracketLoc();\n    }\n    SourceLocation getEndLoc() const LLVM_READONLY {\n      return Kind == FieldDesignator ? getFieldLoc() : getRBracketLoc();\n    }\n    SourceRange getSourceRange() const LLVM_READONLY {\n      return SourceRange(getBeginLoc(), getEndLoc());\n    }\n  };\n\n  static DesignatedInitExpr *Create(const ASTContext &C,\n                                    llvm::ArrayRef<Designator> Designators,\n                                    ArrayRef<Expr*> IndexExprs,\n                                    SourceLocation EqualOrColonLoc,\n                                    bool GNUSyntax, Expr *Init);\n\n  static DesignatedInitExpr *CreateEmpty(const ASTContext &C,\n                                         unsigned NumIndexExprs);\n\n  /// Returns the number of designators in this initializer.\n  unsigned size() const { return NumDesignators; }\n\n  // Iterator access to the designators.\n  llvm::MutableArrayRef<Designator> designators() {\n    return {Designators, NumDesignators};\n  }\n\n  llvm::ArrayRef<Designator> designators() const {\n    return {Designators, NumDesignators};\n  }\n\n  Designator *getDesignator(unsigned Idx) { return &designators()[Idx]; }\n  const Designator *getDesignator(unsigned Idx) const {\n    return &designators()[Idx];\n  }\n\n  void setDesignators(const ASTContext &C, const Designator *Desigs,\n                      unsigned NumDesigs);\n\n  Expr *getArrayIndex(const Designator &D) const;\n  Expr *getArrayRangeStart(const Designator &D) const;\n  Expr *getArrayRangeEnd(const Designator &D) const;\n\n  /// Retrieve the location of the '=' that precedes the\n  /// initializer value itself, if present.\n  SourceLocation getEqualOrColonLoc() const { return EqualOrColonLoc; }\n  void setEqualOrColonLoc(SourceLocation L) { EqualOrColonLoc = L; }\n\n  /// Whether this designated initializer should result in direct-initialization\n  /// of the designated subobject (eg, '{.foo{1, 2, 3}}').\n  bool isDirectInit() const { return EqualOrColonLoc.isInvalid(); }\n\n  /// Determines whether this designated initializer used the\n  /// deprecated GNU syntax for designated initializers.\n  bool usesGNUSyntax() const { return GNUSyntax; }\n  void setGNUSyntax(bool GNU) { GNUSyntax = GNU; }\n\n  /// Retrieve the initializer value.\n  Expr *getInit() const {\n    return cast<Expr>(*const_cast<DesignatedInitExpr*>(this)->child_begin());\n  }\n\n  void setInit(Expr *init) {\n    *child_begin() = init;\n  }\n\n  /// Retrieve the total number of subexpressions in this\n  /// designated initializer expression, including the actual\n  /// initialized value and any expressions that occur within array\n  /// and array-range designators.\n  unsigned getNumSubExprs() const { return NumSubExprs; }\n\n  Expr *getSubExpr(unsigned Idx) const {\n    assert(Idx < NumSubExprs && \"Subscript out of range\");\n    return cast<Expr>(getTrailingObjects<Stmt *>()[Idx]);\n  }\n\n  void setSubExpr(unsigned Idx, Expr *E) {\n    assert(Idx < NumSubExprs && \"Subscript out of range\");\n    getTrailingObjects<Stmt *>()[Idx] = E;\n  }\n\n  /// Replaces the designator at index @p Idx with the series\n  /// of designators in [First, Last).\n  void ExpandDesignator(const ASTContext &C, unsigned Idx,\n                        const Designator *First, const Designator *Last);\n\n  SourceRange getDesignatorsSourceRange() const;\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == DesignatedInitExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    Stmt **begin = getTrailingObjects<Stmt *>();\n    return child_range(begin, begin + NumSubExprs);\n  }\n  const_child_range children() const {\n    Stmt * const *begin = getTrailingObjects<Stmt *>();\n    return const_child_range(begin, begin + NumSubExprs);\n  }\n\n  friend TrailingObjects;\n};\n\n/// Represents a place-holder for an object not to be initialized by\n/// anything.\n///\n/// This only makes sense when it appears as part of an updater of a\n/// DesignatedInitUpdateExpr (see below). The base expression of a DIUE\n/// initializes a big object, and the NoInitExpr's mark the spots within the\n/// big object not to be overwritten by the updater.\n///\n/// \\see DesignatedInitUpdateExpr\nclass NoInitExpr : public Expr {\npublic:\n  explicit NoInitExpr(QualType ty)\n      : Expr(NoInitExprClass, ty, VK_RValue, OK_Ordinary) {\n    setDependence(computeDependence(this));\n  }\n\n  explicit NoInitExpr(EmptyShell Empty)\n    : Expr(NoInitExprClass, Empty) { }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == NoInitExprClass;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return SourceLocation(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return SourceLocation(); }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n// In cases like:\n//   struct Q { int a, b, c; };\n//   Q *getQ();\n//   void foo() {\n//     struct A { Q q; } a = { *getQ(), .q.b = 3 };\n//   }\n//\n// We will have an InitListExpr for a, with type A, and then a\n// DesignatedInitUpdateExpr for \"a.q\" with type Q. The \"base\" for this DIUE\n// is the call expression *getQ(); the \"updater\" for the DIUE is \".q.b = 3\"\n//\nclass DesignatedInitUpdateExpr : public Expr {\n  // BaseAndUpdaterExprs[0] is the base expression;\n  // BaseAndUpdaterExprs[1] is an InitListExpr overwriting part of the base.\n  Stmt *BaseAndUpdaterExprs[2];\n\npublic:\n  DesignatedInitUpdateExpr(const ASTContext &C, SourceLocation lBraceLoc,\n                           Expr *baseExprs, SourceLocation rBraceLoc);\n\n  explicit DesignatedInitUpdateExpr(EmptyShell Empty)\n    : Expr(DesignatedInitUpdateExprClass, Empty) { }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == DesignatedInitUpdateExprClass;\n  }\n\n  Expr *getBase() const { return cast<Expr>(BaseAndUpdaterExprs[0]); }\n  void setBase(Expr *Base) { BaseAndUpdaterExprs[0] = Base; }\n\n  InitListExpr *getUpdater() const {\n    return cast<InitListExpr>(BaseAndUpdaterExprs[1]);\n  }\n  void setUpdater(Expr *Updater) { BaseAndUpdaterExprs[1] = Updater; }\n\n  // Iterators\n  // children = the base and the updater\n  child_range children() {\n    return child_range(&BaseAndUpdaterExprs[0], &BaseAndUpdaterExprs[0] + 2);\n  }\n  const_child_range children() const {\n    return const_child_range(&BaseAndUpdaterExprs[0],\n                             &BaseAndUpdaterExprs[0] + 2);\n  }\n};\n\n/// Represents a loop initializing the elements of an array.\n///\n/// The need to initialize the elements of an array occurs in a number of\n/// contexts:\n///\n///  * in the implicit copy/move constructor for a class with an array member\n///  * when a lambda-expression captures an array by value\n///  * when a decomposition declaration decomposes an array\n///\n/// There are two subexpressions: a common expression (the source array)\n/// that is evaluated once up-front, and a per-element initializer that\n/// runs once for each array element.\n///\n/// Within the per-element initializer, the common expression may be referenced\n/// via an OpaqueValueExpr, and the current index may be obtained via an\n/// ArrayInitIndexExpr.\nclass ArrayInitLoopExpr : public Expr {\n  Stmt *SubExprs[2];\n\n  explicit ArrayInitLoopExpr(EmptyShell Empty)\n      : Expr(ArrayInitLoopExprClass, Empty), SubExprs{} {}\n\npublic:\n  explicit ArrayInitLoopExpr(QualType T, Expr *CommonInit, Expr *ElementInit)\n      : Expr(ArrayInitLoopExprClass, T, VK_RValue, OK_Ordinary),\n        SubExprs{CommonInit, ElementInit} {\n    setDependence(computeDependence(this));\n  }\n\n  /// Get the common subexpression shared by all initializations (the source\n  /// array).\n  OpaqueValueExpr *getCommonExpr() const {\n    return cast<OpaqueValueExpr>(SubExprs[0]);\n  }\n\n  /// Get the initializer to use for each array element.\n  Expr *getSubExpr() const { return cast<Expr>(SubExprs[1]); }\n\n  llvm::APInt getArraySize() const {\n    return cast<ConstantArrayType>(getType()->castAsArrayTypeUnsafe())\n        ->getSize();\n  }\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() == ArrayInitLoopExprClass;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getCommonExpr()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getCommonExpr()->getEndLoc();\n  }\n\n  child_range children() {\n    return child_range(SubExprs, SubExprs + 2);\n  }\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + 2);\n  }\n\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n};\n\n/// Represents the index of the current element of an array being\n/// initialized by an ArrayInitLoopExpr. This can only appear within the\n/// subexpression of an ArrayInitLoopExpr.\nclass ArrayInitIndexExpr : public Expr {\n  explicit ArrayInitIndexExpr(EmptyShell Empty)\n      : Expr(ArrayInitIndexExprClass, Empty) {}\n\npublic:\n  explicit ArrayInitIndexExpr(QualType T)\n      : Expr(ArrayInitIndexExprClass, T, VK_RValue, OK_Ordinary) {\n    setDependence(ExprDependence::None);\n  }\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() == ArrayInitIndexExprClass;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return SourceLocation(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return SourceLocation(); }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  friend class ASTReader;\n  friend class ASTStmtReader;\n};\n\n/// Represents an implicitly-generated value initialization of\n/// an object of a given type.\n///\n/// Implicit value initializations occur within semantic initializer\n/// list expressions (InitListExpr) as placeholders for subobject\n/// initializations not explicitly specified by the user.\n///\n/// \\see InitListExpr\nclass ImplicitValueInitExpr : public Expr {\npublic:\n  explicit ImplicitValueInitExpr(QualType ty)\n      : Expr(ImplicitValueInitExprClass, ty, VK_RValue, OK_Ordinary) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Construct an empty implicit value initialization.\n  explicit ImplicitValueInitExpr(EmptyShell Empty)\n    : Expr(ImplicitValueInitExprClass, Empty) { }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ImplicitValueInitExprClass;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return SourceLocation(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return SourceLocation(); }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\nclass ParenListExpr final\n    : public Expr,\n      private llvm::TrailingObjects<ParenListExpr, Stmt *> {\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  /// The location of the left and right parentheses.\n  SourceLocation LParenLoc, RParenLoc;\n\n  /// Build a paren list.\n  ParenListExpr(SourceLocation LParenLoc, ArrayRef<Expr *> Exprs,\n                SourceLocation RParenLoc);\n\n  /// Build an empty paren list.\n  ParenListExpr(EmptyShell Empty, unsigned NumExprs);\n\npublic:\n  /// Create a paren list.\n  static ParenListExpr *Create(const ASTContext &Ctx, SourceLocation LParenLoc,\n                               ArrayRef<Expr *> Exprs,\n                               SourceLocation RParenLoc);\n\n  /// Create an empty paren list.\n  static ParenListExpr *CreateEmpty(const ASTContext &Ctx, unsigned NumExprs);\n\n  /// Return the number of expressions in this paren list.\n  unsigned getNumExprs() const { return ParenListExprBits.NumExprs; }\n\n  Expr *getExpr(unsigned Init) {\n    assert(Init < getNumExprs() && \"Initializer access out of range!\");\n    return getExprs()[Init];\n  }\n\n  const Expr *getExpr(unsigned Init) const {\n    return const_cast<ParenListExpr *>(this)->getExpr(Init);\n  }\n\n  Expr **getExprs() {\n    return reinterpret_cast<Expr **>(getTrailingObjects<Stmt *>());\n  }\n\n  ArrayRef<Expr *> exprs() {\n    return llvm::makeArrayRef(getExprs(), getNumExprs());\n  }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  SourceLocation getBeginLoc() const { return getLParenLoc(); }\n  SourceLocation getEndLoc() const { return getRParenLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ParenListExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(getTrailingObjects<Stmt *>(),\n                       getTrailingObjects<Stmt *>() + getNumExprs());\n  }\n  const_child_range children() const {\n    return const_child_range(getTrailingObjects<Stmt *>(),\n                             getTrailingObjects<Stmt *>() + getNumExprs());\n  }\n};\n\n/// Represents a C11 generic selection.\n///\n/// A generic selection (C11 6.5.1.1) contains an unevaluated controlling\n/// expression, followed by one or more generic associations.  Each generic\n/// association specifies a type name and an expression, or \"default\" and an\n/// expression (in which case it is known as a default generic association).\n/// The type and value of the generic selection are identical to those of its\n/// result expression, which is defined as the expression in the generic\n/// association with a type name that is compatible with the type of the\n/// controlling expression, or the expression in the default generic association\n/// if no types are compatible.  For example:\n///\n/// @code\n/// _Generic(X, double: 1, float: 2, default: 3)\n/// @endcode\n///\n/// The above expression evaluates to 1 if 1.0 is substituted for X, 2 if 1.0f\n/// or 3 if \"hello\".\n///\n/// As an extension, generic selections are allowed in C++, where the following\n/// additional semantics apply:\n///\n/// Any generic selection whose controlling expression is type-dependent or\n/// which names a dependent type in its association list is result-dependent,\n/// which means that the choice of result expression is dependent.\n/// Result-dependent generic associations are both type- and value-dependent.\nclass GenericSelectionExpr final\n    : public Expr,\n      private llvm::TrailingObjects<GenericSelectionExpr, Stmt *,\n                                    TypeSourceInfo *> {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// The number of association expressions and the index of the result\n  /// expression in the case where the generic selection expression is not\n  /// result-dependent. The result index is equal to ResultDependentIndex\n  /// if and only if the generic selection expression is result-dependent.\n  unsigned NumAssocs, ResultIndex;\n  enum : unsigned {\n    ResultDependentIndex = std::numeric_limits<unsigned>::max(),\n    ControllingIndex = 0,\n    AssocExprStartIndex = 1\n  };\n\n  /// The location of the \"default\" and of the right parenthesis.\n  SourceLocation DefaultLoc, RParenLoc;\n\n  // GenericSelectionExpr is followed by several trailing objects.\n  // They are (in order):\n  //\n  // * A single Stmt * for the controlling expression.\n  // * An array of getNumAssocs() Stmt * for the association expressions.\n  // * An array of getNumAssocs() TypeSourceInfo *, one for each of the\n  //   association expressions.\n  unsigned numTrailingObjects(OverloadToken<Stmt *>) const {\n    // Add one to account for the controlling expression; the remainder\n    // are the associated expressions.\n    return 1 + getNumAssocs();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<TypeSourceInfo *>) const {\n    return getNumAssocs();\n  }\n\n  template <bool Const> class AssociationIteratorTy;\n  /// Bundle together an association expression and its TypeSourceInfo.\n  /// The Const template parameter is for the const and non-const versions\n  /// of AssociationTy.\n  template <bool Const> class AssociationTy {\n    friend class GenericSelectionExpr;\n    template <bool OtherConst> friend class AssociationIteratorTy;\n    using ExprPtrTy = std::conditional_t<Const, const Expr *, Expr *>;\n    using TSIPtrTy =\n        std::conditional_t<Const, const TypeSourceInfo *, TypeSourceInfo *>;\n    ExprPtrTy E;\n    TSIPtrTy TSI;\n    bool Selected;\n    AssociationTy(ExprPtrTy E, TSIPtrTy TSI, bool Selected)\n        : E(E), TSI(TSI), Selected(Selected) {}\n\n  public:\n    ExprPtrTy getAssociationExpr() const { return E; }\n    TSIPtrTy getTypeSourceInfo() const { return TSI; }\n    QualType getType() const { return TSI ? TSI->getType() : QualType(); }\n    bool isSelected() const { return Selected; }\n    AssociationTy *operator->() { return this; }\n    const AssociationTy *operator->() const { return this; }\n  }; // class AssociationTy\n\n  /// Iterator over const and non-const Association objects. The Association\n  /// objects are created on the fly when the iterator is dereferenced.\n  /// This abstract over how exactly the association expressions and the\n  /// corresponding TypeSourceInfo * are stored.\n  template <bool Const>\n  class AssociationIteratorTy\n      : public llvm::iterator_facade_base<\n            AssociationIteratorTy<Const>, std::input_iterator_tag,\n            AssociationTy<Const>, std::ptrdiff_t, AssociationTy<Const>,\n            AssociationTy<Const>> {\n    friend class GenericSelectionExpr;\n    // FIXME: This iterator could conceptually be a random access iterator, and\n    // it would be nice if we could strengthen the iterator category someday.\n    // However this iterator does not satisfy two requirements of forward\n    // iterators:\n    // a) reference = T& or reference = const T&\n    // b) If It1 and It2 are both dereferenceable, then It1 == It2 if and only\n    //    if *It1 and *It2 are bound to the same objects.\n    // An alternative design approach was discussed during review;\n    // store an Association object inside the iterator, and return a reference\n    // to it when dereferenced. This idea was discarded beacuse of nasty\n    // lifetime issues:\n    //    AssociationIterator It = ...;\n    //    const Association &Assoc = *It++; // Oops, Assoc is dangling.\n    using BaseTy = typename AssociationIteratorTy::iterator_facade_base;\n    using StmtPtrPtrTy =\n        std::conditional_t<Const, const Stmt *const *, Stmt **>;\n    using TSIPtrPtrTy = std::conditional_t<Const, const TypeSourceInfo *const *,\n                                           TypeSourceInfo **>;\n    StmtPtrPtrTy E; // = nullptr; FIXME: Once support for gcc 4.8 is dropped.\n    TSIPtrPtrTy TSI; // Kept in sync with E.\n    unsigned Offset = 0, SelectedOffset = 0;\n    AssociationIteratorTy(StmtPtrPtrTy E, TSIPtrPtrTy TSI, unsigned Offset,\n                          unsigned SelectedOffset)\n        : E(E), TSI(TSI), Offset(Offset), SelectedOffset(SelectedOffset) {}\n\n  public:\n    AssociationIteratorTy() : E(nullptr), TSI(nullptr) {}\n    typename BaseTy::reference operator*() const {\n      return AssociationTy<Const>(cast<Expr>(*E), *TSI,\n                                  Offset == SelectedOffset);\n    }\n    typename BaseTy::pointer operator->() const { return **this; }\n    using BaseTy::operator++;\n    AssociationIteratorTy &operator++() {\n      ++E;\n      ++TSI;\n      ++Offset;\n      return *this;\n    }\n    bool operator==(AssociationIteratorTy Other) const { return E == Other.E; }\n  }; // class AssociationIterator\n\n  /// Build a non-result-dependent generic selection expression.\n  GenericSelectionExpr(const ASTContext &Context, SourceLocation GenericLoc,\n                       Expr *ControllingExpr,\n                       ArrayRef<TypeSourceInfo *> AssocTypes,\n                       ArrayRef<Expr *> AssocExprs, SourceLocation DefaultLoc,\n                       SourceLocation RParenLoc,\n                       bool ContainsUnexpandedParameterPack,\n                       unsigned ResultIndex);\n\n  /// Build a result-dependent generic selection expression.\n  GenericSelectionExpr(const ASTContext &Context, SourceLocation GenericLoc,\n                       Expr *ControllingExpr,\n                       ArrayRef<TypeSourceInfo *> AssocTypes,\n                       ArrayRef<Expr *> AssocExprs, SourceLocation DefaultLoc,\n                       SourceLocation RParenLoc,\n                       bool ContainsUnexpandedParameterPack);\n\n  /// Build an empty generic selection expression for deserialization.\n  explicit GenericSelectionExpr(EmptyShell Empty, unsigned NumAssocs);\n\npublic:\n  /// Create a non-result-dependent generic selection expression.\n  static GenericSelectionExpr *\n  Create(const ASTContext &Context, SourceLocation GenericLoc,\n         Expr *ControllingExpr, ArrayRef<TypeSourceInfo *> AssocTypes,\n         ArrayRef<Expr *> AssocExprs, SourceLocation DefaultLoc,\n         SourceLocation RParenLoc, bool ContainsUnexpandedParameterPack,\n         unsigned ResultIndex);\n\n  /// Create a result-dependent generic selection expression.\n  static GenericSelectionExpr *\n  Create(const ASTContext &Context, SourceLocation GenericLoc,\n         Expr *ControllingExpr, ArrayRef<TypeSourceInfo *> AssocTypes,\n         ArrayRef<Expr *> AssocExprs, SourceLocation DefaultLoc,\n         SourceLocation RParenLoc, bool ContainsUnexpandedParameterPack);\n\n  /// Create an empty generic selection expression for deserialization.\n  static GenericSelectionExpr *CreateEmpty(const ASTContext &Context,\n                                           unsigned NumAssocs);\n\n  using Association = AssociationTy<false>;\n  using ConstAssociation = AssociationTy<true>;\n  using AssociationIterator = AssociationIteratorTy<false>;\n  using ConstAssociationIterator = AssociationIteratorTy<true>;\n  using association_range = llvm::iterator_range<AssociationIterator>;\n  using const_association_range =\n      llvm::iterator_range<ConstAssociationIterator>;\n\n  /// The number of association expressions.\n  unsigned getNumAssocs() const { return NumAssocs; }\n\n  /// The zero-based index of the result expression's generic association in\n  /// the generic selection's association list.  Defined only if the\n  /// generic selection is not result-dependent.\n  unsigned getResultIndex() const {\n    assert(!isResultDependent() &&\n           \"Generic selection is result-dependent but getResultIndex called!\");\n    return ResultIndex;\n  }\n\n  /// Whether this generic selection is result-dependent.\n  bool isResultDependent() const { return ResultIndex == ResultDependentIndex; }\n\n  /// Return the controlling expression of this generic selection expression.\n  Expr *getControllingExpr() {\n    return cast<Expr>(getTrailingObjects<Stmt *>()[ControllingIndex]);\n  }\n  const Expr *getControllingExpr() const {\n    return cast<Expr>(getTrailingObjects<Stmt *>()[ControllingIndex]);\n  }\n\n  /// Return the result expression of this controlling expression. Defined if\n  /// and only if the generic selection expression is not result-dependent.\n  Expr *getResultExpr() {\n    return cast<Expr>(\n        getTrailingObjects<Stmt *>()[AssocExprStartIndex + getResultIndex()]);\n  }\n  const Expr *getResultExpr() const {\n    return cast<Expr>(\n        getTrailingObjects<Stmt *>()[AssocExprStartIndex + getResultIndex()]);\n  }\n\n  ArrayRef<Expr *> getAssocExprs() const {\n    return {reinterpret_cast<Expr *const *>(getTrailingObjects<Stmt *>() +\n                                            AssocExprStartIndex),\n            NumAssocs};\n  }\n  ArrayRef<TypeSourceInfo *> getAssocTypeSourceInfos() const {\n    return {getTrailingObjects<TypeSourceInfo *>(), NumAssocs};\n  }\n\n  /// Return the Ith association expression with its TypeSourceInfo,\n  /// bundled together in GenericSelectionExpr::(Const)Association.\n  Association getAssociation(unsigned I) {\n    assert(I < getNumAssocs() &&\n           \"Out-of-range index in GenericSelectionExpr::getAssociation!\");\n    return Association(\n        cast<Expr>(getTrailingObjects<Stmt *>()[AssocExprStartIndex + I]),\n        getTrailingObjects<TypeSourceInfo *>()[I],\n        !isResultDependent() && (getResultIndex() == I));\n  }\n  ConstAssociation getAssociation(unsigned I) const {\n    assert(I < getNumAssocs() &&\n           \"Out-of-range index in GenericSelectionExpr::getAssociation!\");\n    return ConstAssociation(\n        cast<Expr>(getTrailingObjects<Stmt *>()[AssocExprStartIndex + I]),\n        getTrailingObjects<TypeSourceInfo *>()[I],\n        !isResultDependent() && (getResultIndex() == I));\n  }\n\n  association_range associations() {\n    AssociationIterator Begin(getTrailingObjects<Stmt *>() +\n                                  AssocExprStartIndex,\n                              getTrailingObjects<TypeSourceInfo *>(),\n                              /*Offset=*/0, ResultIndex);\n    AssociationIterator End(Begin.E + NumAssocs, Begin.TSI + NumAssocs,\n                            /*Offset=*/NumAssocs, ResultIndex);\n    return llvm::make_range(Begin, End);\n  }\n\n  const_association_range associations() const {\n    ConstAssociationIterator Begin(getTrailingObjects<Stmt *>() +\n                                       AssocExprStartIndex,\n                                   getTrailingObjects<TypeSourceInfo *>(),\n                                   /*Offset=*/0, ResultIndex);\n    ConstAssociationIterator End(Begin.E + NumAssocs, Begin.TSI + NumAssocs,\n                                 /*Offset=*/NumAssocs, ResultIndex);\n    return llvm::make_range(Begin, End);\n  }\n\n  SourceLocation getGenericLoc() const {\n    return GenericSelectionExprBits.GenericLoc;\n  }\n  SourceLocation getDefaultLoc() const { return DefaultLoc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  SourceLocation getBeginLoc() const { return getGenericLoc(); }\n  SourceLocation getEndLoc() const { return getRParenLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == GenericSelectionExprClass;\n  }\n\n  child_range children() {\n    return child_range(getTrailingObjects<Stmt *>(),\n                       getTrailingObjects<Stmt *>() +\n                           numTrailingObjects(OverloadToken<Stmt *>()));\n  }\n  const_child_range children() const {\n    return const_child_range(getTrailingObjects<Stmt *>(),\n                             getTrailingObjects<Stmt *>() +\n                                 numTrailingObjects(OverloadToken<Stmt *>()));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Clang Extensions\n//===----------------------------------------------------------------------===//\n\n/// ExtVectorElementExpr - This represents access to specific elements of a\n/// vector, and may occur on the left hand side or right hand side.  For example\n/// the following is legal:  \"V.xy = V.zw\" if V is a 4 element extended vector.\n///\n/// Note that the base may have either vector or pointer to vector type, just\n/// like a struct field reference.\n///\nclass ExtVectorElementExpr : public Expr {\n  Stmt *Base;\n  IdentifierInfo *Accessor;\n  SourceLocation AccessorLoc;\npublic:\n  ExtVectorElementExpr(QualType ty, ExprValueKind VK, Expr *base,\n                       IdentifierInfo &accessor, SourceLocation loc)\n      : Expr(ExtVectorElementExprClass, ty, VK,\n             (VK == VK_RValue ? OK_Ordinary : OK_VectorComponent)),\n        Base(base), Accessor(&accessor), AccessorLoc(loc) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Build an empty vector element expression.\n  explicit ExtVectorElementExpr(EmptyShell Empty)\n    : Expr(ExtVectorElementExprClass, Empty) { }\n\n  const Expr *getBase() const { return cast<Expr>(Base); }\n  Expr *getBase() { return cast<Expr>(Base); }\n  void setBase(Expr *E) { Base = E; }\n\n  IdentifierInfo &getAccessor() const { return *Accessor; }\n  void setAccessor(IdentifierInfo *II) { Accessor = II; }\n\n  SourceLocation getAccessorLoc() const { return AccessorLoc; }\n  void setAccessorLoc(SourceLocation L) { AccessorLoc = L; }\n\n  /// getNumElements - Get the number of components being selected.\n  unsigned getNumElements() const;\n\n  /// containsDuplicateElements - Return true if any element access is\n  /// repeated.\n  bool containsDuplicateElements() const;\n\n  /// getEncodedElementAccess - Encode the elements accessed into an llvm\n  /// aggregate Constant of ConstantInt(s).\n  void getEncodedElementAccess(SmallVectorImpl<uint32_t> &Elts) const;\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getBase()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY { return AccessorLoc; }\n\n  /// isArrow - Return true if the base expression is a pointer to vector,\n  /// return false if the base expression is a vector.\n  bool isArrow() const;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ExtVectorElementExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Base, &Base+1); }\n  const_child_range children() const {\n    return const_child_range(&Base, &Base + 1);\n  }\n};\n\n/// BlockExpr - Adaptor class for mixing a BlockDecl with expressions.\n/// ^{ statement-body }   or   ^(int arg1, float arg2){ statement-body }\nclass BlockExpr : public Expr {\nprotected:\n  BlockDecl *TheBlock;\npublic:\n  BlockExpr(BlockDecl *BD, QualType ty)\n      : Expr(BlockExprClass, ty, VK_RValue, OK_Ordinary), TheBlock(BD) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Build an empty block expression.\n  explicit BlockExpr(EmptyShell Empty) : Expr(BlockExprClass, Empty) { }\n\n  const BlockDecl *getBlockDecl() const { return TheBlock; }\n  BlockDecl *getBlockDecl() { return TheBlock; }\n  void setBlockDecl(BlockDecl *BD) { TheBlock = BD; }\n\n  // Convenience functions for probing the underlying BlockDecl.\n  SourceLocation getCaretLocation() const;\n  const Stmt *getBody() const;\n  Stmt *getBody();\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getCaretLocation();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getBody()->getEndLoc();\n  }\n\n  /// getFunctionType - Return the underlying function type for this block.\n  const FunctionProtoType *getFunctionType() const;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == BlockExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Copy initialization expr of a __block variable and a boolean flag that\n/// indicates whether the expression can throw.\nstruct BlockVarCopyInit {\n  BlockVarCopyInit() = default;\n  BlockVarCopyInit(Expr *CopyExpr, bool CanThrow)\n      : ExprAndFlag(CopyExpr, CanThrow) {}\n  void setExprAndFlag(Expr *CopyExpr, bool CanThrow) {\n    ExprAndFlag.setPointerAndInt(CopyExpr, CanThrow);\n  }\n  Expr *getCopyExpr() const { return ExprAndFlag.getPointer(); }\n  bool canThrow() const { return ExprAndFlag.getInt(); }\n  llvm::PointerIntPair<Expr *, 1, bool> ExprAndFlag;\n};\n\n/// AsTypeExpr - Clang builtin function __builtin_astype [OpenCL 6.2.4.2]\n/// This AST node provides support for reinterpreting a type to another\n/// type of the same size.\nclass AsTypeExpr : public Expr {\nprivate:\n  Stmt *SrcExpr;\n  SourceLocation BuiltinLoc, RParenLoc;\n\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  explicit AsTypeExpr(EmptyShell Empty) : Expr(AsTypeExprClass, Empty) {}\n\npublic:\n  AsTypeExpr(Expr *SrcExpr, QualType DstType, ExprValueKind VK,\n             ExprObjectKind OK, SourceLocation BuiltinLoc,\n             SourceLocation RParenLoc)\n      : Expr(AsTypeExprClass, DstType, VK, OK), SrcExpr(SrcExpr),\n        BuiltinLoc(BuiltinLoc), RParenLoc(RParenLoc) {\n    setDependence(computeDependence(this));\n  }\n\n  /// getSrcExpr - Return the Expr to be converted.\n  Expr *getSrcExpr() const { return cast<Expr>(SrcExpr); }\n\n  /// getBuiltinLoc - Return the location of the __builtin_astype token.\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n\n  /// getRParenLoc - Return the location of final right parenthesis.\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == AsTypeExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&SrcExpr, &SrcExpr+1); }\n  const_child_range children() const {\n    return const_child_range(&SrcExpr, &SrcExpr + 1);\n  }\n};\n\n/// PseudoObjectExpr - An expression which accesses a pseudo-object\n/// l-value.  A pseudo-object is an abstract object, accesses to which\n/// are translated to calls.  The pseudo-object expression has a\n/// syntactic form, which shows how the expression was actually\n/// written in the source code, and a semantic form, which is a series\n/// of expressions to be executed in order which detail how the\n/// operation is actually evaluated.  Optionally, one of the semantic\n/// forms may also provide a result value for the expression.\n///\n/// If any of the semantic-form expressions is an OpaqueValueExpr,\n/// that OVE is required to have a source expression, and it is bound\n/// to the result of that source expression.  Such OVEs may appear\n/// only in subsequent semantic-form expressions and as\n/// sub-expressions of the syntactic form.\n///\n/// PseudoObjectExpr should be used only when an operation can be\n/// usefully described in terms of fairly simple rewrite rules on\n/// objects and functions that are meant to be used by end-developers.\n/// For example, under the Itanium ABI, dynamic casts are implemented\n/// as a call to a runtime function called __dynamic_cast; using this\n/// class to describe that would be inappropriate because that call is\n/// not really part of the user-visible semantics, and instead the\n/// cast is properly reflected in the AST and IR-generation has been\n/// taught to generate the call as necessary.  In contrast, an\n/// Objective-C property access is semantically defined to be\n/// equivalent to a particular message send, and this is very much\n/// part of the user model.  The name of this class encourages this\n/// modelling design.\nclass PseudoObjectExpr final\n    : public Expr,\n      private llvm::TrailingObjects<PseudoObjectExpr, Expr *> {\n  // PseudoObjectExprBits.NumSubExprs - The number of sub-expressions.\n  // Always at least two, because the first sub-expression is the\n  // syntactic form.\n\n  // PseudoObjectExprBits.ResultIndex - The index of the\n  // sub-expression holding the result.  0 means the result is void,\n  // which is unambiguous because it's the index of the syntactic\n  // form.  Note that this is therefore 1 higher than the value passed\n  // in to Create, which is an index within the semantic forms.\n  // Note also that ASTStmtWriter assumes this encoding.\n\n  Expr **getSubExprsBuffer() { return getTrailingObjects<Expr *>(); }\n  const Expr * const *getSubExprsBuffer() const {\n    return getTrailingObjects<Expr *>();\n  }\n\n  PseudoObjectExpr(QualType type, ExprValueKind VK,\n                   Expr *syntactic, ArrayRef<Expr*> semantic,\n                   unsigned resultIndex);\n\n  PseudoObjectExpr(EmptyShell shell, unsigned numSemanticExprs);\n\n  unsigned getNumSubExprs() const {\n    return PseudoObjectExprBits.NumSubExprs;\n  }\n\npublic:\n  /// NoResult - A value for the result index indicating that there is\n  /// no semantic result.\n  enum : unsigned { NoResult = ~0U };\n\n  static PseudoObjectExpr *Create(const ASTContext &Context, Expr *syntactic,\n                                  ArrayRef<Expr*> semantic,\n                                  unsigned resultIndex);\n\n  static PseudoObjectExpr *Create(const ASTContext &Context, EmptyShell shell,\n                                  unsigned numSemanticExprs);\n\n  /// Return the syntactic form of this expression, i.e. the\n  /// expression it actually looks like.  Likely to be expressed in\n  /// terms of OpaqueValueExprs bound in the semantic form.\n  Expr *getSyntacticForm() { return getSubExprsBuffer()[0]; }\n  const Expr *getSyntacticForm() const { return getSubExprsBuffer()[0]; }\n\n  /// Return the index of the result-bearing expression into the semantics\n  /// expressions, or PseudoObjectExpr::NoResult if there is none.\n  unsigned getResultExprIndex() const {\n    if (PseudoObjectExprBits.ResultIndex == 0) return NoResult;\n    return PseudoObjectExprBits.ResultIndex - 1;\n  }\n\n  /// Return the result-bearing expression, or null if there is none.\n  Expr *getResultExpr() {\n    if (PseudoObjectExprBits.ResultIndex == 0)\n      return nullptr;\n    return getSubExprsBuffer()[PseudoObjectExprBits.ResultIndex];\n  }\n  const Expr *getResultExpr() const {\n    return const_cast<PseudoObjectExpr*>(this)->getResultExpr();\n  }\n\n  unsigned getNumSemanticExprs() const { return getNumSubExprs() - 1; }\n\n  typedef Expr * const *semantics_iterator;\n  typedef const Expr * const *const_semantics_iterator;\n  semantics_iterator semantics_begin() {\n    return getSubExprsBuffer() + 1;\n  }\n  const_semantics_iterator semantics_begin() const {\n    return getSubExprsBuffer() + 1;\n  }\n  semantics_iterator semantics_end() {\n    return getSubExprsBuffer() + getNumSubExprs();\n  }\n  const_semantics_iterator semantics_end() const {\n    return getSubExprsBuffer() + getNumSubExprs();\n  }\n\n  llvm::iterator_range<semantics_iterator> semantics() {\n    return llvm::make_range(semantics_begin(), semantics_end());\n  }\n  llvm::iterator_range<const_semantics_iterator> semantics() const {\n    return llvm::make_range(semantics_begin(), semantics_end());\n  }\n\n  Expr *getSemanticExpr(unsigned index) {\n    assert(index + 1 < getNumSubExprs());\n    return getSubExprsBuffer()[index + 1];\n  }\n  const Expr *getSemanticExpr(unsigned index) const {\n    return const_cast<PseudoObjectExpr*>(this)->getSemanticExpr(index);\n  }\n\n  SourceLocation getExprLoc() const LLVM_READONLY {\n    return getSyntacticForm()->getExprLoc();\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getSyntacticForm()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getSyntacticForm()->getEndLoc();\n  }\n\n  child_range children() {\n    const_child_range CCR =\n        const_cast<const PseudoObjectExpr *>(this)->children();\n    return child_range(cast_away_const(CCR.begin()),\n                       cast_away_const(CCR.end()));\n  }\n  const_child_range children() const {\n    Stmt *const *cs = const_cast<Stmt *const *>(\n        reinterpret_cast<const Stmt *const *>(getSubExprsBuffer()));\n    return const_child_range(cs, cs + getNumSubExprs());\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == PseudoObjectExprClass;\n  }\n\n  friend TrailingObjects;\n  friend class ASTStmtReader;\n};\n\n/// AtomicExpr - Variadic atomic builtins: __atomic_exchange, __atomic_fetch_*,\n/// __atomic_load, __atomic_store, and __atomic_compare_exchange_*, for the\n/// similarly-named C++11 instructions, and __c11 variants for <stdatomic.h>,\n/// and corresponding __opencl_atomic_* for OpenCL 2.0.\n/// All of these instructions take one primary pointer, at least one memory\n/// order. The instructions for which getScopeModel returns non-null value\n/// take one synch scope.\nclass AtomicExpr : public Expr {\npublic:\n  enum AtomicOp {\n#define BUILTIN(ID, TYPE, ATTRS)\n#define ATOMIC_BUILTIN(ID, TYPE, ATTRS) AO ## ID,\n#include \"clang/Basic/Builtins.def\"\n    // Avoid trailing comma\n    BI_First = 0\n  };\n\nprivate:\n  /// Location of sub-expressions.\n  /// The location of Scope sub-expression is NumSubExprs - 1, which is\n  /// not fixed, therefore is not defined in enum.\n  enum { PTR, ORDER, VAL1, ORDER_FAIL, VAL2, WEAK, END_EXPR };\n  Stmt *SubExprs[END_EXPR + 1];\n  unsigned NumSubExprs;\n  SourceLocation BuiltinLoc, RParenLoc;\n  AtomicOp Op;\n\n  friend class ASTStmtReader;\npublic:\n  AtomicExpr(SourceLocation BLoc, ArrayRef<Expr*> args, QualType t,\n             AtomicOp op, SourceLocation RP);\n\n  /// Determine the number of arguments the specified atomic builtin\n  /// should have.\n  static unsigned getNumSubExprs(AtomicOp Op);\n\n  /// Build an empty AtomicExpr.\n  explicit AtomicExpr(EmptyShell Empty) : Expr(AtomicExprClass, Empty) { }\n\n  Expr *getPtr() const {\n    return cast<Expr>(SubExprs[PTR]);\n  }\n  Expr *getOrder() const {\n    return cast<Expr>(SubExprs[ORDER]);\n  }\n  Expr *getScope() const {\n    assert(getScopeModel() && \"No scope\");\n    return cast<Expr>(SubExprs[NumSubExprs - 1]);\n  }\n  Expr *getVal1() const {\n    if (Op == AO__c11_atomic_init || Op == AO__opencl_atomic_init)\n      return cast<Expr>(SubExprs[ORDER]);\n    assert(NumSubExprs > VAL1);\n    return cast<Expr>(SubExprs[VAL1]);\n  }\n  Expr *getOrderFail() const {\n    assert(NumSubExprs > ORDER_FAIL);\n    return cast<Expr>(SubExprs[ORDER_FAIL]);\n  }\n  Expr *getVal2() const {\n    if (Op == AO__atomic_exchange)\n      return cast<Expr>(SubExprs[ORDER_FAIL]);\n    assert(NumSubExprs > VAL2);\n    return cast<Expr>(SubExprs[VAL2]);\n  }\n  Expr *getWeak() const {\n    assert(NumSubExprs > WEAK);\n    return cast<Expr>(SubExprs[WEAK]);\n  }\n  QualType getValueType() const;\n\n  AtomicOp getOp() const { return Op; }\n  unsigned getNumSubExprs() const { return NumSubExprs; }\n\n  Expr **getSubExprs() { return reinterpret_cast<Expr **>(SubExprs); }\n  const Expr * const *getSubExprs() const {\n    return reinterpret_cast<Expr * const *>(SubExprs);\n  }\n\n  bool isVolatile() const {\n    return getPtr()->getType()->getPointeeType().isVolatileQualified();\n  }\n\n  bool isCmpXChg() const {\n    return getOp() == AO__c11_atomic_compare_exchange_strong ||\n           getOp() == AO__c11_atomic_compare_exchange_weak ||\n           getOp() == AO__opencl_atomic_compare_exchange_strong ||\n           getOp() == AO__opencl_atomic_compare_exchange_weak ||\n           getOp() == AO__atomic_compare_exchange ||\n           getOp() == AO__atomic_compare_exchange_n;\n  }\n\n  bool isOpenCL() const {\n    return getOp() >= AO__opencl_atomic_init &&\n           getOp() <= AO__opencl_atomic_fetch_max;\n  }\n\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == AtomicExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(SubExprs, SubExprs+NumSubExprs);\n  }\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + NumSubExprs);\n  }\n\n  /// Get atomic scope model for the atomic op code.\n  /// \\return empty atomic scope model if the atomic op code does not have\n  ///   scope operand.\n  static std::unique_ptr<AtomicScopeModel> getScopeModel(AtomicOp Op) {\n    auto Kind =\n        (Op >= AO__opencl_atomic_load && Op <= AO__opencl_atomic_fetch_max)\n            ? AtomicScopeModelKind::OpenCL\n            : AtomicScopeModelKind::None;\n    return AtomicScopeModel::create(Kind);\n  }\n\n  /// Get atomic scope model.\n  /// \\return empty atomic scope model if this atomic expression does not have\n  ///   scope operand.\n  std::unique_ptr<AtomicScopeModel> getScopeModel() const {\n    return getScopeModel(getOp());\n  }\n};\n\n/// TypoExpr - Internal placeholder for expressions where typo correction\n/// still needs to be performed and/or an error diagnostic emitted.\nclass TypoExpr : public Expr {\n  // The location for the typo name.\n  SourceLocation TypoLoc;\n\npublic:\n  TypoExpr(QualType T, SourceLocation TypoLoc)\n      : Expr(TypoExprClass, T, VK_LValue, OK_Ordinary), TypoLoc(TypoLoc) {\n    assert(T->isDependentType() && \"TypoExpr given a non-dependent type\");\n    setDependence(ExprDependence::TypeValueInstantiation |\n                  ExprDependence::Error);\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return TypoLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return TypoLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == TypoExprClass;\n  }\n\n};\n\n/// Frontend produces RecoveryExprs on semantic errors that prevent creating\n/// other well-formed expressions. E.g. when type-checking of a binary operator\n/// fails, we cannot produce a BinaryOperator expression. Instead, we can choose\n/// to produce a recovery expression storing left and right operands.\n///\n/// RecoveryExpr does not have any semantic meaning in C++, it is only useful to\n/// preserve expressions in AST that would otherwise be dropped. It captures\n/// subexpressions of some expression that we could not construct and source\n/// range covered by the expression.\n///\n/// By default, RecoveryExpr uses dependence-bits to take advantage of existing\n/// machinery to deal with dependent code in C++, e.g. RecoveryExpr is preserved\n/// in `decltype(<broken-expr>)` as part of the `DependentDecltypeType`. In\n/// addition to that, clang does not report most errors on dependent\n/// expressions, so we get rid of bogus errors for free. However, note that\n/// unlike other dependent expressions, RecoveryExpr can be produced in\n/// non-template contexts.\n///\n/// We will preserve the type in RecoveryExpr when the type is known, e.g.\n/// preserving the return type for a broken non-overloaded function call, a\n/// overloaded call where all candidates have the same return type. In this\n/// case, the expression is not type-dependent (unless the known type is itself\n/// dependent)\n///\n/// One can also reliably suppress all bogus errors on expressions containing\n/// recovery expressions by examining results of Expr::containsErrors().\nclass RecoveryExpr final : public Expr,\n                           private llvm::TrailingObjects<RecoveryExpr, Expr *> {\npublic:\n  static RecoveryExpr *Create(ASTContext &Ctx, QualType T,\n                              SourceLocation BeginLoc, SourceLocation EndLoc,\n                              ArrayRef<Expr *> SubExprs);\n  static RecoveryExpr *CreateEmpty(ASTContext &Ctx, unsigned NumSubExprs);\n\n  ArrayRef<Expr *> subExpressions() {\n    auto *B = getTrailingObjects<Expr *>();\n    return llvm::makeArrayRef(B, B + NumExprs);\n  }\n\n  ArrayRef<const Expr *> subExpressions() const {\n    return const_cast<RecoveryExpr *>(this)->subExpressions();\n  }\n\n  child_range children() {\n    Stmt **B = reinterpret_cast<Stmt **>(getTrailingObjects<Expr *>());\n    return child_range(B, B + NumExprs);\n  }\n\n  SourceLocation getBeginLoc() const { return BeginLoc; }\n  SourceLocation getEndLoc() const { return EndLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == RecoveryExprClass;\n  }\n\nprivate:\n  RecoveryExpr(ASTContext &Ctx, QualType T, SourceLocation BeginLoc,\n               SourceLocation EndLoc, ArrayRef<Expr *> SubExprs);\n  RecoveryExpr(EmptyShell Empty, unsigned NumSubExprs)\n      : Expr(RecoveryExprClass, Empty), NumExprs(NumSubExprs) {}\n\n  size_t numTrailingObjects(OverloadToken<Stmt *>) const { return NumExprs; }\n\n  SourceLocation BeginLoc, EndLoc;\n  unsigned NumExprs;\n  friend TrailingObjects;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n};\n\n} // end namespace clang\n\n#endif // LLVM_CLANG_AST_EXPR_H\n"}, "10": {"id": 10, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "content": "//===- ExprCXX.h - Classes for representing expressions ---------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the clang::Expr interface and subclasses for C++ expressions.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_EXPRCXX_H\n#define LLVM_CLANG_AST_EXPRCXX_H\n\n#include \"clang/AST/ASTConcept.h\"\n#include \"clang/AST/ComputeDependence.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclTemplate.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/DependenceFlags.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/OperationKinds.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/StmtCXX.h\"\n#include \"clang/AST/TemplateBase.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/AST/UnresolvedSet.h\"\n#include \"clang/Basic/ExceptionSpecificationType.h\"\n#include \"clang/Basic/ExpressionTraits.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/Lambda.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/OperatorKinds.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Basic/TypeTraits.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <memory>\n\nnamespace clang {\n\nclass ASTContext;\nclass DeclAccessPair;\nclass IdentifierInfo;\nclass LambdaCapture;\nclass NonTypeTemplateParmDecl;\nclass TemplateParameterList;\n\n//===--------------------------------------------------------------------===//\n// C++ Expressions.\n//===--------------------------------------------------------------------===//\n\n/// A call to an overloaded operator written using operator\n/// syntax.\n///\n/// Represents a call to an overloaded operator written using operator\n/// syntax, e.g., \"x + y\" or \"*p\". While semantically equivalent to a\n/// normal call, this AST node provides better information about the\n/// syntactic representation of the call.\n///\n/// In a C++ template, this expression node kind will be used whenever\n/// any of the arguments are type-dependent. In this case, the\n/// function itself will be a (possibly empty) set of functions and\n/// function templates that were found by name lookup at template\n/// definition time.\nclass CXXOperatorCallExpr final : public CallExpr {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  SourceRange Range;\n\n  // CXXOperatorCallExpr has some trailing objects belonging\n  // to CallExpr. See CallExpr for the details.\n\n  SourceRange getSourceRangeImpl() const LLVM_READONLY;\n\n  CXXOperatorCallExpr(OverloadedOperatorKind OpKind, Expr *Fn,\n                      ArrayRef<Expr *> Args, QualType Ty, ExprValueKind VK,\n                      SourceLocation OperatorLoc, FPOptionsOverride FPFeatures,\n                      ADLCallKind UsesADL);\n\n  CXXOperatorCallExpr(unsigned NumArgs, bool HasFPFeatures, EmptyShell Empty);\n\npublic:\n  static CXXOperatorCallExpr *\n  Create(const ASTContext &Ctx, OverloadedOperatorKind OpKind, Expr *Fn,\n         ArrayRef<Expr *> Args, QualType Ty, ExprValueKind VK,\n         SourceLocation OperatorLoc, FPOptionsOverride FPFeatures,\n         ADLCallKind UsesADL = NotADL);\n\n  static CXXOperatorCallExpr *CreateEmpty(const ASTContext &Ctx,\n                                          unsigned NumArgs, bool HasFPFeatures,\n                                          EmptyShell Empty);\n\n  /// Returns the kind of overloaded operator that this expression refers to.\n  OverloadedOperatorKind getOperator() const {\n    return static_cast<OverloadedOperatorKind>(\n        CXXOperatorCallExprBits.OperatorKind);\n  }\n\n  static bool isAssignmentOp(OverloadedOperatorKind Opc) {\n    return Opc == OO_Equal || Opc == OO_StarEqual || Opc == OO_SlashEqual ||\n           Opc == OO_PercentEqual || Opc == OO_PlusEqual ||\n           Opc == OO_MinusEqual || Opc == OO_LessLessEqual ||\n           Opc == OO_GreaterGreaterEqual || Opc == OO_AmpEqual ||\n           Opc == OO_CaretEqual || Opc == OO_PipeEqual;\n  }\n  bool isAssignmentOp() const { return isAssignmentOp(getOperator()); }\n\n  static bool isComparisonOp(OverloadedOperatorKind Opc) {\n    switch (Opc) {\n    case OO_EqualEqual:\n    case OO_ExclaimEqual:\n    case OO_Greater:\n    case OO_GreaterEqual:\n    case OO_Less:\n    case OO_LessEqual:\n    case OO_Spaceship:\n      return true;\n    default:\n      return false;\n    }\n  }\n  bool isComparisonOp() const { return isComparisonOp(getOperator()); }\n\n  /// Is this written as an infix binary operator?\n  bool isInfixBinaryOp() const;\n\n  /// Returns the location of the operator symbol in the expression.\n  ///\n  /// When \\c getOperator()==OO_Call, this is the location of the right\n  /// parentheses; when \\c getOperator()==OO_Subscript, this is the location\n  /// of the right bracket.\n  SourceLocation getOperatorLoc() const { return getRParenLoc(); }\n\n  SourceLocation getExprLoc() const LLVM_READONLY {\n    OverloadedOperatorKind Operator = getOperator();\n    return (Operator < OO_Plus || Operator >= OO_Arrow ||\n            Operator == OO_PlusPlus || Operator == OO_MinusMinus)\n               ? getBeginLoc()\n               : getOperatorLoc();\n  }\n\n  SourceLocation getBeginLoc() const { return Range.getBegin(); }\n  SourceLocation getEndLoc() const { return Range.getEnd(); }\n  SourceRange getSourceRange() const { return Range; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXOperatorCallExprClass;\n  }\n};\n\n/// Represents a call to a member function that\n/// may be written either with member call syntax (e.g., \"obj.func()\"\n/// or \"objptr->func()\") or with normal function-call syntax\n/// (\"func()\") within a member function that ends up calling a member\n/// function. The callee in either case is a MemberExpr that contains\n/// both the object argument and the member function, while the\n/// arguments are the arguments within the parentheses (not including\n/// the object argument).\nclass CXXMemberCallExpr final : public CallExpr {\n  // CXXMemberCallExpr has some trailing objects belonging\n  // to CallExpr. See CallExpr for the details.\n\n  CXXMemberCallExpr(Expr *Fn, ArrayRef<Expr *> Args, QualType Ty,\n                    ExprValueKind VK, SourceLocation RP,\n                    FPOptionsOverride FPOptions, unsigned MinNumArgs);\n\n  CXXMemberCallExpr(unsigned NumArgs, bool HasFPFeatures, EmptyShell Empty);\n\npublic:\n  static CXXMemberCallExpr *Create(const ASTContext &Ctx, Expr *Fn,\n                                   ArrayRef<Expr *> Args, QualType Ty,\n                                   ExprValueKind VK, SourceLocation RP,\n                                   FPOptionsOverride FPFeatures,\n                                   unsigned MinNumArgs = 0);\n\n  static CXXMemberCallExpr *CreateEmpty(const ASTContext &Ctx, unsigned NumArgs,\n                                        bool HasFPFeatures, EmptyShell Empty);\n\n  /// Retrieve the implicit object argument for the member call.\n  ///\n  /// For example, in \"x.f(5)\", this returns the sub-expression \"x\".\n  Expr *getImplicitObjectArgument() const;\n\n  /// Retrieve the type of the object argument.\n  ///\n  /// Note that this always returns a non-pointer type.\n  QualType getObjectType() const;\n\n  /// Retrieve the declaration of the called method.\n  CXXMethodDecl *getMethodDecl() const;\n\n  /// Retrieve the CXXRecordDecl for the underlying type of\n  /// the implicit object argument.\n  ///\n  /// Note that this is may not be the same declaration as that of the class\n  /// context of the CXXMethodDecl which this function is calling.\n  /// FIXME: Returns 0 for member pointer call exprs.\n  CXXRecordDecl *getRecordDecl() const;\n\n  SourceLocation getExprLoc() const LLVM_READONLY {\n    SourceLocation CLoc = getCallee()->getExprLoc();\n    if (CLoc.isValid())\n      return CLoc;\n\n    return getBeginLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXMemberCallExprClass;\n  }\n};\n\n/// Represents a call to a CUDA kernel function.\nclass CUDAKernelCallExpr final : public CallExpr {\n  friend class ASTStmtReader;\n\n  enum { CONFIG, END_PREARG };\n\n  // CUDAKernelCallExpr has some trailing objects belonging\n  // to CallExpr. See CallExpr for the details.\n\n  CUDAKernelCallExpr(Expr *Fn, CallExpr *Config, ArrayRef<Expr *> Args,\n                     QualType Ty, ExprValueKind VK, SourceLocation RP,\n                     FPOptionsOverride FPFeatures, unsigned MinNumArgs);\n\n  CUDAKernelCallExpr(unsigned NumArgs, bool HasFPFeatures, EmptyShell Empty);\n\npublic:\n  static CUDAKernelCallExpr *Create(const ASTContext &Ctx, Expr *Fn,\n                                    CallExpr *Config, ArrayRef<Expr *> Args,\n                                    QualType Ty, ExprValueKind VK,\n                                    SourceLocation RP,\n                                    FPOptionsOverride FPFeatures,\n                                    unsigned MinNumArgs = 0);\n\n  static CUDAKernelCallExpr *CreateEmpty(const ASTContext &Ctx,\n                                         unsigned NumArgs, bool HasFPFeatures,\n                                         EmptyShell Empty);\n\n  const CallExpr *getConfig() const {\n    return cast_or_null<CallExpr>(getPreArg(CONFIG));\n  }\n  CallExpr *getConfig() { return cast_or_null<CallExpr>(getPreArg(CONFIG)); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CUDAKernelCallExprClass;\n  }\n};\n\n/// A rewritten comparison expression that was originally written using\n/// operator syntax.\n///\n/// In C++20, the following rewrites are performed:\n/// - <tt>a == b</tt> -> <tt>b == a</tt>\n/// - <tt>a != b</tt> -> <tt>!(a == b)</tt>\n/// - <tt>a != b</tt> -> <tt>!(b == a)</tt>\n/// - For \\c \\@ in \\c <, \\c <=, \\c >, \\c >=, \\c <=>:\n///   - <tt>a @ b</tt> -> <tt>(a <=> b) @ 0</tt>\n///   - <tt>a @ b</tt> -> <tt>0 @ (b <=> a)</tt>\n///\n/// This expression provides access to both the original syntax and the\n/// rewritten expression.\n///\n/// Note that the rewritten calls to \\c ==, \\c <=>, and \\c \\@ are typically\n/// \\c CXXOperatorCallExprs, but could theoretically be \\c BinaryOperators.\nclass CXXRewrittenBinaryOperator : public Expr {\n  friend class ASTStmtReader;\n\n  /// The rewritten semantic form.\n  Stmt *SemanticForm;\n\npublic:\n  CXXRewrittenBinaryOperator(Expr *SemanticForm, bool IsReversed)\n      : Expr(CXXRewrittenBinaryOperatorClass, SemanticForm->getType(),\n             SemanticForm->getValueKind(), SemanticForm->getObjectKind()),\n        SemanticForm(SemanticForm) {\n    CXXRewrittenBinaryOperatorBits.IsReversed = IsReversed;\n    setDependence(computeDependence(this));\n  }\n  CXXRewrittenBinaryOperator(EmptyShell Empty)\n      : Expr(CXXRewrittenBinaryOperatorClass, Empty), SemanticForm() {}\n\n  /// Get an equivalent semantic form for this expression.\n  Expr *getSemanticForm() { return cast<Expr>(SemanticForm); }\n  const Expr *getSemanticForm() const { return cast<Expr>(SemanticForm); }\n\n  struct DecomposedForm {\n    /// The original opcode, prior to rewriting.\n    BinaryOperatorKind Opcode;\n    /// The original left-hand side.\n    const Expr *LHS;\n    /// The original right-hand side.\n    const Expr *RHS;\n    /// The inner \\c == or \\c <=> operator expression.\n    const Expr *InnerBinOp;\n  };\n\n  /// Decompose this operator into its syntactic form.\n  DecomposedForm getDecomposedForm() const LLVM_READONLY;\n\n  /// Determine whether this expression was rewritten in reverse form.\n  bool isReversed() const { return CXXRewrittenBinaryOperatorBits.IsReversed; }\n\n  BinaryOperatorKind getOperator() const { return getDecomposedForm().Opcode; }\n  BinaryOperatorKind getOpcode() const { return getOperator(); }\n  static StringRef getOpcodeStr(BinaryOperatorKind Op) {\n    return BinaryOperator::getOpcodeStr(Op);\n  }\n  StringRef getOpcodeStr() const {\n    return BinaryOperator::getOpcodeStr(getOpcode());\n  }\n  bool isComparisonOp() const { return true; }\n  bool isAssignmentOp() const { return false; }\n\n  const Expr *getLHS() const { return getDecomposedForm().LHS; }\n  const Expr *getRHS() const { return getDecomposedForm().RHS; }\n\n  SourceLocation getOperatorLoc() const LLVM_READONLY {\n    return getDecomposedForm().InnerBinOp->getExprLoc();\n  }\n  SourceLocation getExprLoc() const LLVM_READONLY { return getOperatorLoc(); }\n\n  /// Compute the begin and end locations from the decomposed form.\n  /// The locations of the semantic form are not reliable if this is\n  /// a reversed expression.\n  //@{\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getDecomposedForm().LHS->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getDecomposedForm().RHS->getEndLoc();\n  }\n  SourceRange getSourceRange() const LLVM_READONLY {\n    DecomposedForm DF = getDecomposedForm();\n    return SourceRange(DF.LHS->getBeginLoc(), DF.RHS->getEndLoc());\n  }\n  //@}\n\n  child_range children() {\n    return child_range(&SemanticForm, &SemanticForm + 1);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXRewrittenBinaryOperatorClass;\n  }\n};\n\n/// Abstract class common to all of the C++ \"named\"/\"keyword\" casts.\n///\n/// This abstract class is inherited by all of the classes\n/// representing \"named\" casts: CXXStaticCastExpr for \\c static_cast,\n/// CXXDynamicCastExpr for \\c dynamic_cast, CXXReinterpretCastExpr for\n/// reinterpret_cast, CXXConstCastExpr for \\c const_cast and\n/// CXXAddrspaceCastExpr for addrspace_cast (in OpenCL).\nclass CXXNamedCastExpr : public ExplicitCastExpr {\nprivate:\n  // the location of the casting op\n  SourceLocation Loc;\n\n  // the location of the right parenthesis\n  SourceLocation RParenLoc;\n\n  // range for '<' '>'\n  SourceRange AngleBrackets;\n\nprotected:\n  friend class ASTStmtReader;\n\n  CXXNamedCastExpr(StmtClass SC, QualType ty, ExprValueKind VK, CastKind kind,\n                   Expr *op, unsigned PathSize, bool HasFPFeatures,\n                   TypeSourceInfo *writtenTy, SourceLocation l,\n                   SourceLocation RParenLoc, SourceRange AngleBrackets)\n      : ExplicitCastExpr(SC, ty, VK, kind, op, PathSize, HasFPFeatures,\n                         writtenTy),\n        Loc(l), RParenLoc(RParenLoc), AngleBrackets(AngleBrackets) {}\n\n  explicit CXXNamedCastExpr(StmtClass SC, EmptyShell Shell, unsigned PathSize,\n                            bool HasFPFeatures)\n      : ExplicitCastExpr(SC, Shell, PathSize, HasFPFeatures) {}\n\npublic:\n  const char *getCastName() const;\n\n  /// Retrieve the location of the cast operator keyword, e.g.,\n  /// \\c static_cast.\n  SourceLocation getOperatorLoc() const { return Loc; }\n\n  /// Retrieve the location of the closing parenthesis.\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n  SourceRange getAngleBrackets() const LLVM_READONLY { return AngleBrackets; }\n\n  static bool classof(const Stmt *T) {\n    switch (T->getStmtClass()) {\n    case CXXStaticCastExprClass:\n    case CXXDynamicCastExprClass:\n    case CXXReinterpretCastExprClass:\n    case CXXConstCastExprClass:\n    case CXXAddrspaceCastExprClass:\n      return true;\n    default:\n      return false;\n    }\n  }\n};\n\n/// A C++ \\c static_cast expression (C++ [expr.static.cast]).\n///\n/// This expression node represents a C++ static cast, e.g.,\n/// \\c static_cast<int>(1.0).\nclass CXXStaticCastExpr final\n    : public CXXNamedCastExpr,\n      private llvm::TrailingObjects<CXXStaticCastExpr, CXXBaseSpecifier *,\n                                    FPOptionsOverride> {\n  CXXStaticCastExpr(QualType ty, ExprValueKind vk, CastKind kind, Expr *op,\n                    unsigned pathSize, TypeSourceInfo *writtenTy,\n                    FPOptionsOverride FPO, SourceLocation l,\n                    SourceLocation RParenLoc, SourceRange AngleBrackets)\n      : CXXNamedCastExpr(CXXStaticCastExprClass, ty, vk, kind, op, pathSize,\n                         FPO.requiresTrailingStorage(), writtenTy, l, RParenLoc,\n                         AngleBrackets) {\n    if (hasStoredFPFeatures())\n      *getTrailingFPFeatures() = FPO;\n  }\n\n  explicit CXXStaticCastExpr(EmptyShell Empty, unsigned PathSize,\n                             bool HasFPFeatures)\n      : CXXNamedCastExpr(CXXStaticCastExprClass, Empty, PathSize,\n                         HasFPFeatures) {}\n\n  unsigned numTrailingObjects(OverloadToken<CXXBaseSpecifier *>) const {\n    return path_size();\n  }\n\npublic:\n  friend class CastExpr;\n  friend TrailingObjects;\n\n  static CXXStaticCastExpr *\n  Create(const ASTContext &Context, QualType T, ExprValueKind VK, CastKind K,\n         Expr *Op, const CXXCastPath *Path, TypeSourceInfo *Written,\n         FPOptionsOverride FPO, SourceLocation L, SourceLocation RParenLoc,\n         SourceRange AngleBrackets);\n  static CXXStaticCastExpr *CreateEmpty(const ASTContext &Context,\n                                        unsigned PathSize, bool hasFPFeatures);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXStaticCastExprClass;\n  }\n};\n\n/// A C++ @c dynamic_cast expression (C++ [expr.dynamic.cast]).\n///\n/// This expression node represents a dynamic cast, e.g.,\n/// \\c dynamic_cast<Derived*>(BasePtr). Such a cast may perform a run-time\n/// check to determine how to perform the type conversion.\nclass CXXDynamicCastExpr final\n    : public CXXNamedCastExpr,\n      private llvm::TrailingObjects<CXXDynamicCastExpr, CXXBaseSpecifier *> {\n  CXXDynamicCastExpr(QualType ty, ExprValueKind VK, CastKind kind, Expr *op,\n                     unsigned pathSize, TypeSourceInfo *writtenTy,\n                     SourceLocation l, SourceLocation RParenLoc,\n                     SourceRange AngleBrackets)\n      : CXXNamedCastExpr(CXXDynamicCastExprClass, ty, VK, kind, op, pathSize,\n                         /*HasFPFeatures*/ false, writtenTy, l, RParenLoc,\n                         AngleBrackets) {}\n\n  explicit CXXDynamicCastExpr(EmptyShell Empty, unsigned pathSize)\n      : CXXNamedCastExpr(CXXDynamicCastExprClass, Empty, pathSize,\n                         /*HasFPFeatures*/ false) {}\n\npublic:\n  friend class CastExpr;\n  friend TrailingObjects;\n\n  static CXXDynamicCastExpr *Create(const ASTContext &Context, QualType T,\n                                    ExprValueKind VK, CastKind Kind, Expr *Op,\n                                    const CXXCastPath *Path,\n                                    TypeSourceInfo *Written, SourceLocation L,\n                                    SourceLocation RParenLoc,\n                                    SourceRange AngleBrackets);\n\n  static CXXDynamicCastExpr *CreateEmpty(const ASTContext &Context,\n                                         unsigned pathSize);\n\n  bool isAlwaysNull() const;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXDynamicCastExprClass;\n  }\n};\n\n/// A C++ @c reinterpret_cast expression (C++ [expr.reinterpret.cast]).\n///\n/// This expression node represents a reinterpret cast, e.g.,\n/// @c reinterpret_cast<int>(VoidPtr).\n///\n/// A reinterpret_cast provides a differently-typed view of a value but\n/// (in Clang, as in most C++ implementations) performs no actual work at\n/// run time.\nclass CXXReinterpretCastExpr final\n    : public CXXNamedCastExpr,\n      private llvm::TrailingObjects<CXXReinterpretCastExpr,\n                                    CXXBaseSpecifier *> {\n  CXXReinterpretCastExpr(QualType ty, ExprValueKind vk, CastKind kind, Expr *op,\n                         unsigned pathSize, TypeSourceInfo *writtenTy,\n                         SourceLocation l, SourceLocation RParenLoc,\n                         SourceRange AngleBrackets)\n      : CXXNamedCastExpr(CXXReinterpretCastExprClass, ty, vk, kind, op,\n                         pathSize, /*HasFPFeatures*/ false, writtenTy, l,\n                         RParenLoc, AngleBrackets) {}\n\n  CXXReinterpretCastExpr(EmptyShell Empty, unsigned pathSize)\n      : CXXNamedCastExpr(CXXReinterpretCastExprClass, Empty, pathSize,\n                         /*HasFPFeatures*/ false) {}\n\npublic:\n  friend class CastExpr;\n  friend TrailingObjects;\n\n  static CXXReinterpretCastExpr *Create(const ASTContext &Context, QualType T,\n                                        ExprValueKind VK, CastKind Kind,\n                                        Expr *Op, const CXXCastPath *Path,\n                                 TypeSourceInfo *WrittenTy, SourceLocation L,\n                                        SourceLocation RParenLoc,\n                                        SourceRange AngleBrackets);\n  static CXXReinterpretCastExpr *CreateEmpty(const ASTContext &Context,\n                                             unsigned pathSize);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXReinterpretCastExprClass;\n  }\n};\n\n/// A C++ \\c const_cast expression (C++ [expr.const.cast]).\n///\n/// This expression node represents a const cast, e.g.,\n/// \\c const_cast<char*>(PtrToConstChar).\n///\n/// A const_cast can remove type qualifiers but does not change the underlying\n/// value.\nclass CXXConstCastExpr final\n    : public CXXNamedCastExpr,\n      private llvm::TrailingObjects<CXXConstCastExpr, CXXBaseSpecifier *> {\n  CXXConstCastExpr(QualType ty, ExprValueKind VK, Expr *op,\n                   TypeSourceInfo *writtenTy, SourceLocation l,\n                   SourceLocation RParenLoc, SourceRange AngleBrackets)\n      : CXXNamedCastExpr(CXXConstCastExprClass, ty, VK, CK_NoOp, op, 0,\n                         /*HasFPFeatures*/ false, writtenTy, l, RParenLoc,\n                         AngleBrackets) {}\n\n  explicit CXXConstCastExpr(EmptyShell Empty)\n      : CXXNamedCastExpr(CXXConstCastExprClass, Empty, 0,\n                         /*HasFPFeatures*/ false) {}\n\npublic:\n  friend class CastExpr;\n  friend TrailingObjects;\n\n  static CXXConstCastExpr *Create(const ASTContext &Context, QualType T,\n                                  ExprValueKind VK, Expr *Op,\n                                  TypeSourceInfo *WrittenTy, SourceLocation L,\n                                  SourceLocation RParenLoc,\n                                  SourceRange AngleBrackets);\n  static CXXConstCastExpr *CreateEmpty(const ASTContext &Context);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXConstCastExprClass;\n  }\n};\n\n/// A C++ addrspace_cast expression (currently only enabled for OpenCL).\n///\n/// This expression node represents a cast between pointers to objects in\n/// different address spaces e.g.,\n/// \\c addrspace_cast<global int*>(PtrToGenericInt).\n///\n/// A addrspace_cast can cast address space type qualifiers but does not change\n/// the underlying value.\nclass CXXAddrspaceCastExpr final\n    : public CXXNamedCastExpr,\n      private llvm::TrailingObjects<CXXAddrspaceCastExpr, CXXBaseSpecifier *> {\n  CXXAddrspaceCastExpr(QualType ty, ExprValueKind VK, CastKind Kind, Expr *op,\n                       TypeSourceInfo *writtenTy, SourceLocation l,\n                       SourceLocation RParenLoc, SourceRange AngleBrackets)\n      : CXXNamedCastExpr(CXXAddrspaceCastExprClass, ty, VK, Kind, op, 0,\n                         /*HasFPFeatures*/ false, writtenTy, l, RParenLoc,\n                         AngleBrackets) {}\n\n  explicit CXXAddrspaceCastExpr(EmptyShell Empty)\n      : CXXNamedCastExpr(CXXAddrspaceCastExprClass, Empty, 0,\n                         /*HasFPFeatures*/ false) {}\n\npublic:\n  friend class CastExpr;\n  friend TrailingObjects;\n\n  static CXXAddrspaceCastExpr *\n  Create(const ASTContext &Context, QualType T, ExprValueKind VK, CastKind Kind,\n         Expr *Op, TypeSourceInfo *WrittenTy, SourceLocation L,\n         SourceLocation RParenLoc, SourceRange AngleBrackets);\n  static CXXAddrspaceCastExpr *CreateEmpty(const ASTContext &Context);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXAddrspaceCastExprClass;\n  }\n};\n\n/// A call to a literal operator (C++11 [over.literal])\n/// written as a user-defined literal (C++11 [lit.ext]).\n///\n/// Represents a user-defined literal, e.g. \"foo\"_bar or 1.23_xyz. While this\n/// is semantically equivalent to a normal call, this AST node provides better\n/// information about the syntactic representation of the literal.\n///\n/// Since literal operators are never found by ADL and can only be declared at\n/// namespace scope, a user-defined literal is never dependent.\nclass UserDefinedLiteral final : public CallExpr {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  /// The location of a ud-suffix within the literal.\n  SourceLocation UDSuffixLoc;\n\n  // UserDefinedLiteral has some trailing objects belonging\n  // to CallExpr. See CallExpr for the details.\n\n  UserDefinedLiteral(Expr *Fn, ArrayRef<Expr *> Args, QualType Ty,\n                     ExprValueKind VK, SourceLocation LitEndLoc,\n                     SourceLocation SuffixLoc, FPOptionsOverride FPFeatures);\n\n  UserDefinedLiteral(unsigned NumArgs, bool HasFPFeatures, EmptyShell Empty);\n\npublic:\n  static UserDefinedLiteral *Create(const ASTContext &Ctx, Expr *Fn,\n                                    ArrayRef<Expr *> Args, QualType Ty,\n                                    ExprValueKind VK, SourceLocation LitEndLoc,\n                                    SourceLocation SuffixLoc,\n                                    FPOptionsOverride FPFeatures);\n\n  static UserDefinedLiteral *CreateEmpty(const ASTContext &Ctx,\n                                         unsigned NumArgs, bool HasFPOptions,\n                                         EmptyShell Empty);\n\n  /// The kind of literal operator which is invoked.\n  enum LiteralOperatorKind {\n    /// Raw form: operator \"\" X (const char *)\n    LOK_Raw,\n\n    /// Raw form: operator \"\" X<cs...> ()\n    LOK_Template,\n\n    /// operator \"\" X (unsigned long long)\n    LOK_Integer,\n\n    /// operator \"\" X (long double)\n    LOK_Floating,\n\n    /// operator \"\" X (const CharT *, size_t)\n    LOK_String,\n\n    /// operator \"\" X (CharT)\n    LOK_Character\n  };\n\n  /// Returns the kind of literal operator invocation\n  /// which this expression represents.\n  LiteralOperatorKind getLiteralOperatorKind() const;\n\n  /// If this is not a raw user-defined literal, get the\n  /// underlying cooked literal (representing the literal with the suffix\n  /// removed).\n  Expr *getCookedLiteral();\n  const Expr *getCookedLiteral() const {\n    return const_cast<UserDefinedLiteral*>(this)->getCookedLiteral();\n  }\n\n  SourceLocation getBeginLoc() const {\n    if (getLiteralOperatorKind() == LOK_Template)\n      return getRParenLoc();\n    return getArg(0)->getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const { return getRParenLoc(); }\n\n  /// Returns the location of a ud-suffix in the expression.\n  ///\n  /// For a string literal, there may be multiple identical suffixes. This\n  /// returns the first.\n  SourceLocation getUDSuffixLoc() const { return UDSuffixLoc; }\n\n  /// Returns the ud-suffix specified for this literal.\n  const IdentifierInfo *getUDSuffix() const;\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() == UserDefinedLiteralClass;\n  }\n};\n\n/// A boolean literal, per ([C++ lex.bool] Boolean literals).\nclass CXXBoolLiteralExpr : public Expr {\npublic:\n  CXXBoolLiteralExpr(bool Val, QualType Ty, SourceLocation Loc)\n      : Expr(CXXBoolLiteralExprClass, Ty, VK_RValue, OK_Ordinary) {\n    CXXBoolLiteralExprBits.Value = Val;\n    CXXBoolLiteralExprBits.Loc = Loc;\n    setDependence(ExprDependence::None);\n  }\n\n  explicit CXXBoolLiteralExpr(EmptyShell Empty)\n      : Expr(CXXBoolLiteralExprClass, Empty) {}\n\n  bool getValue() const { return CXXBoolLiteralExprBits.Value; }\n  void setValue(bool V) { CXXBoolLiteralExprBits.Value = V; }\n\n  SourceLocation getBeginLoc() const { return getLocation(); }\n  SourceLocation getEndLoc() const { return getLocation(); }\n\n  SourceLocation getLocation() const { return CXXBoolLiteralExprBits.Loc; }\n  void setLocation(SourceLocation L) { CXXBoolLiteralExprBits.Loc = L; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXBoolLiteralExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// The null pointer literal (C++11 [lex.nullptr])\n///\n/// Introduced in C++11, the only literal of type \\c nullptr_t is \\c nullptr.\nclass CXXNullPtrLiteralExpr : public Expr {\npublic:\n  CXXNullPtrLiteralExpr(QualType Ty, SourceLocation Loc)\n      : Expr(CXXNullPtrLiteralExprClass, Ty, VK_RValue, OK_Ordinary) {\n    CXXNullPtrLiteralExprBits.Loc = Loc;\n    setDependence(ExprDependence::None);\n  }\n\n  explicit CXXNullPtrLiteralExpr(EmptyShell Empty)\n      : Expr(CXXNullPtrLiteralExprClass, Empty) {}\n\n  SourceLocation getBeginLoc() const { return getLocation(); }\n  SourceLocation getEndLoc() const { return getLocation(); }\n\n  SourceLocation getLocation() const { return CXXNullPtrLiteralExprBits.Loc; }\n  void setLocation(SourceLocation L) { CXXNullPtrLiteralExprBits.Loc = L; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXNullPtrLiteralExprClass;\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Implicit construction of a std::initializer_list<T> object from an\n/// array temporary within list-initialization (C++11 [dcl.init.list]p5).\nclass CXXStdInitializerListExpr : public Expr {\n  Stmt *SubExpr = nullptr;\n\n  CXXStdInitializerListExpr(EmptyShell Empty)\n      : Expr(CXXStdInitializerListExprClass, Empty) {}\n\npublic:\n  friend class ASTReader;\n  friend class ASTStmtReader;\n\n  CXXStdInitializerListExpr(QualType Ty, Expr *SubExpr)\n      : Expr(CXXStdInitializerListExprClass, Ty, VK_RValue, OK_Ordinary),\n        SubExpr(SubExpr) {\n    setDependence(computeDependence(this));\n  }\n\n  Expr *getSubExpr() { return static_cast<Expr*>(SubExpr); }\n  const Expr *getSubExpr() const { return static_cast<const Expr*>(SubExpr); }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return SubExpr->getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return SubExpr->getEndLoc();\n  }\n\n  /// Retrieve the source range of the expression.\n  SourceRange getSourceRange() const LLVM_READONLY {\n    return SubExpr->getSourceRange();\n  }\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() == CXXStdInitializerListExprClass;\n  }\n\n  child_range children() { return child_range(&SubExpr, &SubExpr + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&SubExpr, &SubExpr + 1);\n  }\n};\n\n/// A C++ \\c typeid expression (C++ [expr.typeid]), which gets\n/// the \\c type_info that corresponds to the supplied type, or the (possibly\n/// dynamic) type of the supplied expression.\n///\n/// This represents code like \\c typeid(int) or \\c typeid(*objPtr)\nclass CXXTypeidExpr : public Expr {\n  friend class ASTStmtReader;\n\nprivate:\n  llvm::PointerUnion<Stmt *, TypeSourceInfo *> Operand;\n  SourceRange Range;\n\npublic:\n  CXXTypeidExpr(QualType Ty, TypeSourceInfo *Operand, SourceRange R)\n      : Expr(CXXTypeidExprClass, Ty, VK_LValue, OK_Ordinary), Operand(Operand),\n        Range(R) {\n    setDependence(computeDependence(this));\n  }\n\n  CXXTypeidExpr(QualType Ty, Expr *Operand, SourceRange R)\n      : Expr(CXXTypeidExprClass, Ty, VK_LValue, OK_Ordinary), Operand(Operand),\n        Range(R) {\n    setDependence(computeDependence(this));\n  }\n\n  CXXTypeidExpr(EmptyShell Empty, bool isExpr)\n      : Expr(CXXTypeidExprClass, Empty) {\n    if (isExpr)\n      Operand = (Expr*)nullptr;\n    else\n      Operand = (TypeSourceInfo*)nullptr;\n  }\n\n  /// Determine whether this typeid has a type operand which is potentially\n  /// evaluated, per C++11 [expr.typeid]p3.\n  bool isPotentiallyEvaluated() const;\n\n  /// Best-effort check if the expression operand refers to a most derived\n  /// object. This is not a strong guarantee.\n  bool isMostDerived(ASTContext &Context) const;\n\n  bool isTypeOperand() const { return Operand.is<TypeSourceInfo *>(); }\n\n  /// Retrieves the type operand of this typeid() expression after\n  /// various required adjustments (removing reference types, cv-qualifiers).\n  QualType getTypeOperand(ASTContext &Context) const;\n\n  /// Retrieve source information for the type operand.\n  TypeSourceInfo *getTypeOperandSourceInfo() const {\n    assert(isTypeOperand() && \"Cannot call getTypeOperand for typeid(expr)\");\n    return Operand.get<TypeSourceInfo *>();\n  }\n  Expr *getExprOperand() const {\n    assert(!isTypeOperand() && \"Cannot call getExprOperand for typeid(type)\");\n    return static_cast<Expr*>(Operand.get<Stmt *>());\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n  SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n  void setSourceRange(SourceRange R) { Range = R; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXTypeidExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    if (isTypeOperand())\n      return child_range(child_iterator(), child_iterator());\n    auto **begin = reinterpret_cast<Stmt **>(&Operand);\n    return child_range(begin, begin + 1);\n  }\n\n  const_child_range children() const {\n    if (isTypeOperand())\n      return const_child_range(const_child_iterator(), const_child_iterator());\n\n    auto **begin =\n        reinterpret_cast<Stmt **>(&const_cast<CXXTypeidExpr *>(this)->Operand);\n    return const_child_range(begin, begin + 1);\n  }\n};\n\n/// A member reference to an MSPropertyDecl.\n///\n/// This expression always has pseudo-object type, and therefore it is\n/// typically not encountered in a fully-typechecked expression except\n/// within the syntactic form of a PseudoObjectExpr.\nclass MSPropertyRefExpr : public Expr {\n  Expr *BaseExpr;\n  MSPropertyDecl *TheDecl;\n  SourceLocation MemberLoc;\n  bool IsArrow;\n  NestedNameSpecifierLoc QualifierLoc;\n\npublic:\n  friend class ASTStmtReader;\n\n  MSPropertyRefExpr(Expr *baseExpr, MSPropertyDecl *decl, bool isArrow,\n                    QualType ty, ExprValueKind VK,\n                    NestedNameSpecifierLoc qualifierLoc, SourceLocation nameLoc)\n      : Expr(MSPropertyRefExprClass, ty, VK, OK_Ordinary), BaseExpr(baseExpr),\n        TheDecl(decl), MemberLoc(nameLoc), IsArrow(isArrow),\n        QualifierLoc(qualifierLoc) {\n    setDependence(computeDependence(this));\n  }\n\n  MSPropertyRefExpr(EmptyShell Empty) : Expr(MSPropertyRefExprClass, Empty) {}\n\n  SourceRange getSourceRange() const LLVM_READONLY {\n    return SourceRange(getBeginLoc(), getEndLoc());\n  }\n\n  bool isImplicitAccess() const {\n    return getBaseExpr() && getBaseExpr()->isImplicitCXXThis();\n  }\n\n  SourceLocation getBeginLoc() const {\n    if (!isImplicitAccess())\n      return BaseExpr->getBeginLoc();\n    else if (QualifierLoc)\n      return QualifierLoc.getBeginLoc();\n    else\n        return MemberLoc;\n  }\n\n  SourceLocation getEndLoc() const { return getMemberLoc(); }\n\n  child_range children() {\n    return child_range((Stmt**)&BaseExpr, (Stmt**)&BaseExpr + 1);\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<MSPropertyRefExpr *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == MSPropertyRefExprClass;\n  }\n\n  Expr *getBaseExpr() const { return BaseExpr; }\n  MSPropertyDecl *getPropertyDecl() const { return TheDecl; }\n  bool isArrow() const { return IsArrow; }\n  SourceLocation getMemberLoc() const { return MemberLoc; }\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n};\n\n/// MS property subscript expression.\n/// MSVC supports 'property' attribute and allows to apply it to the\n/// declaration of an empty array in a class or structure definition.\n/// For example:\n/// \\code\n/// __declspec(property(get=GetX, put=PutX)) int x[];\n/// \\endcode\n/// The above statement indicates that x[] can be used with one or more array\n/// indices. In this case, i=p->x[a][b] will be turned into i=p->GetX(a, b), and\n/// p->x[a][b] = i will be turned into p->PutX(a, b, i).\n/// This is a syntactic pseudo-object expression.\nclass MSPropertySubscriptExpr : public Expr {\n  friend class ASTStmtReader;\n\n  enum { BASE_EXPR, IDX_EXPR, NUM_SUBEXPRS = 2 };\n\n  Stmt *SubExprs[NUM_SUBEXPRS];\n  SourceLocation RBracketLoc;\n\n  void setBase(Expr *Base) { SubExprs[BASE_EXPR] = Base; }\n  void setIdx(Expr *Idx) { SubExprs[IDX_EXPR] = Idx; }\n\npublic:\n  MSPropertySubscriptExpr(Expr *Base, Expr *Idx, QualType Ty, ExprValueKind VK,\n                          ExprObjectKind OK, SourceLocation RBracketLoc)\n      : Expr(MSPropertySubscriptExprClass, Ty, VK, OK),\n        RBracketLoc(RBracketLoc) {\n    SubExprs[BASE_EXPR] = Base;\n    SubExprs[IDX_EXPR] = Idx;\n    setDependence(computeDependence(this));\n  }\n\n  /// Create an empty array subscript expression.\n  explicit MSPropertySubscriptExpr(EmptyShell Shell)\n      : Expr(MSPropertySubscriptExprClass, Shell) {}\n\n  Expr *getBase() { return cast<Expr>(SubExprs[BASE_EXPR]); }\n  const Expr *getBase() const { return cast<Expr>(SubExprs[BASE_EXPR]); }\n\n  Expr *getIdx() { return cast<Expr>(SubExprs[IDX_EXPR]); }\n  const Expr *getIdx() const { return cast<Expr>(SubExprs[IDX_EXPR]); }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getBase()->getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY { return RBracketLoc; }\n\n  SourceLocation getRBracketLoc() const { return RBracketLoc; }\n  void setRBracketLoc(SourceLocation L) { RBracketLoc = L; }\n\n  SourceLocation getExprLoc() const LLVM_READONLY {\n    return getBase()->getExprLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == MSPropertySubscriptExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0] + NUM_SUBEXPRS);\n  }\n\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + NUM_SUBEXPRS);\n  }\n};\n\n/// A Microsoft C++ @c __uuidof expression, which gets\n/// the _GUID that corresponds to the supplied type or expression.\n///\n/// This represents code like @c __uuidof(COMTYPE) or @c __uuidof(*comPtr)\nclass CXXUuidofExpr : public Expr {\n  friend class ASTStmtReader;\n\nprivate:\n  llvm::PointerUnion<Stmt *, TypeSourceInfo *> Operand;\n  MSGuidDecl *Guid;\n  SourceRange Range;\n\npublic:\n  CXXUuidofExpr(QualType Ty, TypeSourceInfo *Operand, MSGuidDecl *Guid,\n                SourceRange R)\n      : Expr(CXXUuidofExprClass, Ty, VK_LValue, OK_Ordinary), Operand(Operand),\n        Guid(Guid), Range(R) {\n    setDependence(computeDependence(this));\n  }\n\n  CXXUuidofExpr(QualType Ty, Expr *Operand, MSGuidDecl *Guid, SourceRange R)\n      : Expr(CXXUuidofExprClass, Ty, VK_LValue, OK_Ordinary), Operand(Operand),\n        Guid(Guid), Range(R) {\n    setDependence(computeDependence(this));\n  }\n\n  CXXUuidofExpr(EmptyShell Empty, bool isExpr)\n    : Expr(CXXUuidofExprClass, Empty) {\n    if (isExpr)\n      Operand = (Expr*)nullptr;\n    else\n      Operand = (TypeSourceInfo*)nullptr;\n  }\n\n  bool isTypeOperand() const { return Operand.is<TypeSourceInfo *>(); }\n\n  /// Retrieves the type operand of this __uuidof() expression after\n  /// various required adjustments (removing reference types, cv-qualifiers).\n  QualType getTypeOperand(ASTContext &Context) const;\n\n  /// Retrieve source information for the type operand.\n  TypeSourceInfo *getTypeOperandSourceInfo() const {\n    assert(isTypeOperand() && \"Cannot call getTypeOperand for __uuidof(expr)\");\n    return Operand.get<TypeSourceInfo *>();\n  }\n  Expr *getExprOperand() const {\n    assert(!isTypeOperand() && \"Cannot call getExprOperand for __uuidof(type)\");\n    return static_cast<Expr*>(Operand.get<Stmt *>());\n  }\n\n  MSGuidDecl *getGuidDecl() const { return Guid; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n  SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n  void setSourceRange(SourceRange R) { Range = R; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXUuidofExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    if (isTypeOperand())\n      return child_range(child_iterator(), child_iterator());\n    auto **begin = reinterpret_cast<Stmt **>(&Operand);\n    return child_range(begin, begin + 1);\n  }\n\n  const_child_range children() const {\n    if (isTypeOperand())\n      return const_child_range(const_child_iterator(), const_child_iterator());\n    auto **begin =\n        reinterpret_cast<Stmt **>(&const_cast<CXXUuidofExpr *>(this)->Operand);\n    return const_child_range(begin, begin + 1);\n  }\n};\n\n/// Represents the \\c this expression in C++.\n///\n/// This is a pointer to the object on which the current member function is\n/// executing (C++ [expr.prim]p3). Example:\n///\n/// \\code\n/// class Foo {\n/// public:\n///   void bar();\n///   void test() { this->bar(); }\n/// };\n/// \\endcode\nclass CXXThisExpr : public Expr {\npublic:\n  CXXThisExpr(SourceLocation L, QualType Ty, bool IsImplicit)\n      : Expr(CXXThisExprClass, Ty, VK_RValue, OK_Ordinary) {\n    CXXThisExprBits.IsImplicit = IsImplicit;\n    CXXThisExprBits.Loc = L;\n    setDependence(computeDependence(this));\n  }\n\n  CXXThisExpr(EmptyShell Empty) : Expr(CXXThisExprClass, Empty) {}\n\n  SourceLocation getLocation() const { return CXXThisExprBits.Loc; }\n  void setLocation(SourceLocation L) { CXXThisExprBits.Loc = L; }\n\n  SourceLocation getBeginLoc() const { return getLocation(); }\n  SourceLocation getEndLoc() const { return getLocation(); }\n\n  bool isImplicit() const { return CXXThisExprBits.IsImplicit; }\n  void setImplicit(bool I) { CXXThisExprBits.IsImplicit = I; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXThisExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// A C++ throw-expression (C++ [except.throw]).\n///\n/// This handles 'throw' (for re-throwing the current exception) and\n/// 'throw' assignment-expression.  When assignment-expression isn't\n/// present, Op will be null.\nclass CXXThrowExpr : public Expr {\n  friend class ASTStmtReader;\n\n  /// The optional expression in the throw statement.\n  Stmt *Operand;\n\npublic:\n  // \\p Ty is the void type which is used as the result type of the\n  // expression. The \\p Loc is the location of the throw keyword.\n  // \\p Operand is the expression in the throw statement, and can be\n  // null if not present.\n  CXXThrowExpr(Expr *Operand, QualType Ty, SourceLocation Loc,\n               bool IsThrownVariableInScope)\n      : Expr(CXXThrowExprClass, Ty, VK_RValue, OK_Ordinary), Operand(Operand) {\n    CXXThrowExprBits.ThrowLoc = Loc;\n    CXXThrowExprBits.IsThrownVariableInScope = IsThrownVariableInScope;\n    setDependence(computeDependence(this));\n  }\n  CXXThrowExpr(EmptyShell Empty) : Expr(CXXThrowExprClass, Empty) {}\n\n  const Expr *getSubExpr() const { return cast_or_null<Expr>(Operand); }\n  Expr *getSubExpr() { return cast_or_null<Expr>(Operand); }\n\n  SourceLocation getThrowLoc() const { return CXXThrowExprBits.ThrowLoc; }\n\n  /// Determines whether the variable thrown by this expression (if any!)\n  /// is within the innermost try block.\n  ///\n  /// This information is required to determine whether the NRVO can apply to\n  /// this variable.\n  bool isThrownVariableInScope() const {\n    return CXXThrowExprBits.IsThrownVariableInScope;\n  }\n\n  SourceLocation getBeginLoc() const { return getThrowLoc(); }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    if (!getSubExpr())\n      return getThrowLoc();\n    return getSubExpr()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXThrowExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&Operand, Operand ? &Operand + 1 : &Operand);\n  }\n\n  const_child_range children() const {\n    return const_child_range(&Operand, Operand ? &Operand + 1 : &Operand);\n  }\n};\n\n/// A default argument (C++ [dcl.fct.default]).\n///\n/// This wraps up a function call argument that was created from the\n/// corresponding parameter's default argument, when the call did not\n/// explicitly supply arguments for all of the parameters.\nclass CXXDefaultArgExpr final : public Expr {\n  friend class ASTStmtReader;\n\n  /// The parameter whose default is being used.\n  ParmVarDecl *Param;\n\n  /// The context where the default argument expression was used.\n  DeclContext *UsedContext;\n\n  CXXDefaultArgExpr(StmtClass SC, SourceLocation Loc, ParmVarDecl *Param,\n                    DeclContext *UsedContext)\n      : Expr(SC,\n             Param->hasUnparsedDefaultArg()\n                 ? Param->getType().getNonReferenceType()\n                 : Param->getDefaultArg()->getType(),\n             Param->getDefaultArg()->getValueKind(),\n             Param->getDefaultArg()->getObjectKind()),\n        Param(Param), UsedContext(UsedContext) {\n    CXXDefaultArgExprBits.Loc = Loc;\n    setDependence(ExprDependence::None);\n  }\n\npublic:\n  CXXDefaultArgExpr(EmptyShell Empty) : Expr(CXXDefaultArgExprClass, Empty) {}\n\n  // \\p Param is the parameter whose default argument is used by this\n  // expression.\n  static CXXDefaultArgExpr *Create(const ASTContext &C, SourceLocation Loc,\n                                   ParmVarDecl *Param,\n                                   DeclContext *UsedContext) {\n    return new (C)\n        CXXDefaultArgExpr(CXXDefaultArgExprClass, Loc, Param, UsedContext);\n  }\n\n  // Retrieve the parameter that the argument was created from.\n  const ParmVarDecl *getParam() const { return Param; }\n  ParmVarDecl *getParam() { return Param; }\n\n  // Retrieve the actual argument to the function call.\n  const Expr *getExpr() const { return getParam()->getDefaultArg(); }\n  Expr *getExpr() { return getParam()->getDefaultArg(); }\n\n  const DeclContext *getUsedContext() const { return UsedContext; }\n  DeclContext *getUsedContext() { return UsedContext; }\n\n  /// Retrieve the location where this default argument was actually used.\n  SourceLocation getUsedLocation() const { return CXXDefaultArgExprBits.Loc; }\n\n  /// Default argument expressions have no representation in the\n  /// source, so they have an empty source range.\n  SourceLocation getBeginLoc() const { return SourceLocation(); }\n  SourceLocation getEndLoc() const { return SourceLocation(); }\n\n  SourceLocation getExprLoc() const { return getUsedLocation(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXDefaultArgExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// A use of a default initializer in a constructor or in aggregate\n/// initialization.\n///\n/// This wraps a use of a C++ default initializer (technically,\n/// a brace-or-equal-initializer for a non-static data member) when it\n/// is implicitly used in a mem-initializer-list in a constructor\n/// (C++11 [class.base.init]p8) or in aggregate initialization\n/// (C++1y [dcl.init.aggr]p7).\nclass CXXDefaultInitExpr : public Expr {\n  friend class ASTReader;\n  friend class ASTStmtReader;\n\n  /// The field whose default is being used.\n  FieldDecl *Field;\n\n  /// The context where the default initializer expression was used.\n  DeclContext *UsedContext;\n\n  CXXDefaultInitExpr(const ASTContext &Ctx, SourceLocation Loc,\n                     FieldDecl *Field, QualType Ty, DeclContext *UsedContext);\n\n  CXXDefaultInitExpr(EmptyShell Empty) : Expr(CXXDefaultInitExprClass, Empty) {}\n\npublic:\n  /// \\p Field is the non-static data member whose default initializer is used\n  /// by this expression.\n  static CXXDefaultInitExpr *Create(const ASTContext &Ctx, SourceLocation Loc,\n                                    FieldDecl *Field, DeclContext *UsedContext) {\n    return new (Ctx) CXXDefaultInitExpr(Ctx, Loc, Field, Field->getType(), UsedContext);\n  }\n\n  /// Get the field whose initializer will be used.\n  FieldDecl *getField() { return Field; }\n  const FieldDecl *getField() const { return Field; }\n\n  /// Get the initialization expression that will be used.\n  const Expr *getExpr() const {\n    assert(Field->getInClassInitializer() && \"initializer hasn't been parsed\");\n    return Field->getInClassInitializer();\n  }\n  Expr *getExpr() {\n    assert(Field->getInClassInitializer() && \"initializer hasn't been parsed\");\n    return Field->getInClassInitializer();\n  }\n\n  const DeclContext *getUsedContext() const { return UsedContext; }\n  DeclContext *getUsedContext() { return UsedContext; }\n\n  /// Retrieve the location where this default initializer expression was\n  /// actually used.\n  SourceLocation getUsedLocation() const { return getBeginLoc(); }\n\n  SourceLocation getBeginLoc() const { return CXXDefaultInitExprBits.Loc; }\n  SourceLocation getEndLoc() const { return CXXDefaultInitExprBits.Loc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXDefaultInitExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Represents a C++ temporary.\nclass CXXTemporary {\n  /// The destructor that needs to be called.\n  const CXXDestructorDecl *Destructor;\n\n  explicit CXXTemporary(const CXXDestructorDecl *destructor)\n      : Destructor(destructor) {}\n\npublic:\n  static CXXTemporary *Create(const ASTContext &C,\n                              const CXXDestructorDecl *Destructor);\n\n  const CXXDestructorDecl *getDestructor() const { return Destructor; }\n\n  void setDestructor(const CXXDestructorDecl *Dtor) {\n    Destructor = Dtor;\n  }\n};\n\n/// Represents binding an expression to a temporary.\n///\n/// This ensures the destructor is called for the temporary. It should only be\n/// needed for non-POD, non-trivially destructable class types. For example:\n///\n/// \\code\n///   struct S {\n///     S() { }  // User defined constructor makes S non-POD.\n///     ~S() { } // User defined destructor makes it non-trivial.\n///   };\n///   void test() {\n///     const S &s_ref = S(); // Requires a CXXBindTemporaryExpr.\n///   }\n/// \\endcode\nclass CXXBindTemporaryExpr : public Expr {\n  CXXTemporary *Temp = nullptr;\n  Stmt *SubExpr = nullptr;\n\n  CXXBindTemporaryExpr(CXXTemporary *temp, Expr *SubExpr)\n      : Expr(CXXBindTemporaryExprClass, SubExpr->getType(), VK_RValue,\n             OK_Ordinary),\n        Temp(temp), SubExpr(SubExpr) {\n    setDependence(computeDependence(this));\n  }\n\npublic:\n  CXXBindTemporaryExpr(EmptyShell Empty)\n      : Expr(CXXBindTemporaryExprClass, Empty) {}\n\n  static CXXBindTemporaryExpr *Create(const ASTContext &C, CXXTemporary *Temp,\n                                      Expr* SubExpr);\n\n  CXXTemporary *getTemporary() { return Temp; }\n  const CXXTemporary *getTemporary() const { return Temp; }\n  void setTemporary(CXXTemporary *T) { Temp = T; }\n\n  const Expr *getSubExpr() const { return cast<Expr>(SubExpr); }\n  Expr *getSubExpr() { return cast<Expr>(SubExpr); }\n  void setSubExpr(Expr *E) { SubExpr = E; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return SubExpr->getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return SubExpr->getEndLoc();\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXBindTemporaryExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&SubExpr, &SubExpr + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&SubExpr, &SubExpr + 1);\n  }\n};\n\n/// Represents a call to a C++ constructor.\nclass CXXConstructExpr : public Expr {\n  friend class ASTStmtReader;\n\npublic:\n  enum ConstructionKind {\n    CK_Complete,\n    CK_NonVirtualBase,\n    CK_VirtualBase,\n    CK_Delegating\n  };\n\nprivate:\n  /// A pointer to the constructor which will be ultimately called.\n  CXXConstructorDecl *Constructor;\n\n  SourceRange ParenOrBraceRange;\n\n  /// The number of arguments.\n  unsigned NumArgs;\n\n  // We would like to stash the arguments of the constructor call after\n  // CXXConstructExpr. However CXXConstructExpr is used as a base class of\n  // CXXTemporaryObjectExpr which makes the use of llvm::TrailingObjects\n  // impossible.\n  //\n  // Instead we manually stash the trailing object after the full object\n  // containing CXXConstructExpr (that is either CXXConstructExpr or\n  // CXXTemporaryObjectExpr).\n  //\n  // The trailing objects are:\n  //\n  // * An array of getNumArgs() \"Stmt *\" for the arguments of the\n  //   constructor call.\n\n  /// Return a pointer to the start of the trailing arguments.\n  /// Defined just after CXXTemporaryObjectExpr.\n  inline Stmt **getTrailingArgs();\n  const Stmt *const *getTrailingArgs() const {\n    return const_cast<CXXConstructExpr *>(this)->getTrailingArgs();\n  }\n\nprotected:\n  /// Build a C++ construction expression.\n  CXXConstructExpr(StmtClass SC, QualType Ty, SourceLocation Loc,\n                   CXXConstructorDecl *Ctor, bool Elidable,\n                   ArrayRef<Expr *> Args, bool HadMultipleCandidates,\n                   bool ListInitialization, bool StdInitListInitialization,\n                   bool ZeroInitialization, ConstructionKind ConstructKind,\n                   SourceRange ParenOrBraceRange);\n\n  /// Build an empty C++ construction expression.\n  CXXConstructExpr(StmtClass SC, EmptyShell Empty, unsigned NumArgs);\n\n  /// Return the size in bytes of the trailing objects. Used by\n  /// CXXTemporaryObjectExpr to allocate the right amount of storage.\n  static unsigned sizeOfTrailingObjects(unsigned NumArgs) {\n    return NumArgs * sizeof(Stmt *);\n  }\n\npublic:\n  /// Create a C++ construction expression.\n  static CXXConstructExpr *\n  Create(const ASTContext &Ctx, QualType Ty, SourceLocation Loc,\n         CXXConstructorDecl *Ctor, bool Elidable, ArrayRef<Expr *> Args,\n         bool HadMultipleCandidates, bool ListInitialization,\n         bool StdInitListInitialization, bool ZeroInitialization,\n         ConstructionKind ConstructKind, SourceRange ParenOrBraceRange);\n\n  /// Create an empty C++ construction expression.\n  static CXXConstructExpr *CreateEmpty(const ASTContext &Ctx, unsigned NumArgs);\n\n  /// Get the constructor that this expression will (ultimately) call.\n  CXXConstructorDecl *getConstructor() const { return Constructor; }\n\n  SourceLocation getLocation() const { return CXXConstructExprBits.Loc; }\n  void setLocation(SourceLocation Loc) { CXXConstructExprBits.Loc = Loc; }\n\n  /// Whether this construction is elidable.\n  bool isElidable() const { return CXXConstructExprBits.Elidable; }\n  void setElidable(bool E) { CXXConstructExprBits.Elidable = E; }\n\n  /// Whether the referred constructor was resolved from\n  /// an overloaded set having size greater than 1.\n  bool hadMultipleCandidates() const {\n    return CXXConstructExprBits.HadMultipleCandidates;\n  }\n  void setHadMultipleCandidates(bool V) {\n    CXXConstructExprBits.HadMultipleCandidates = V;\n  }\n\n  /// Whether this constructor call was written as list-initialization.\n  bool isListInitialization() const {\n    return CXXConstructExprBits.ListInitialization;\n  }\n  void setListInitialization(bool V) {\n    CXXConstructExprBits.ListInitialization = V;\n  }\n\n  /// Whether this constructor call was written as list-initialization,\n  /// but was interpreted as forming a std::initializer_list<T> from the list\n  /// and passing that as a single constructor argument.\n  /// See C++11 [over.match.list]p1 bullet 1.\n  bool isStdInitListInitialization() const {\n    return CXXConstructExprBits.StdInitListInitialization;\n  }\n  void setStdInitListInitialization(bool V) {\n    CXXConstructExprBits.StdInitListInitialization = V;\n  }\n\n  /// Whether this construction first requires\n  /// zero-initialization before the initializer is called.\n  bool requiresZeroInitialization() const {\n    return CXXConstructExprBits.ZeroInitialization;\n  }\n  void setRequiresZeroInitialization(bool ZeroInit) {\n    CXXConstructExprBits.ZeroInitialization = ZeroInit;\n  }\n\n  /// Determine whether this constructor is actually constructing\n  /// a base class (rather than a complete object).\n  ConstructionKind getConstructionKind() const {\n    return static_cast<ConstructionKind>(CXXConstructExprBits.ConstructionKind);\n  }\n  void setConstructionKind(ConstructionKind CK) {\n    CXXConstructExprBits.ConstructionKind = CK;\n  }\n\n  using arg_iterator = ExprIterator;\n  using const_arg_iterator = ConstExprIterator;\n  using arg_range = llvm::iterator_range<arg_iterator>;\n  using const_arg_range = llvm::iterator_range<const_arg_iterator>;\n\n  arg_range arguments() { return arg_range(arg_begin(), arg_end()); }\n  const_arg_range arguments() const {\n    return const_arg_range(arg_begin(), arg_end());\n  }\n\n  arg_iterator arg_begin() { return getTrailingArgs(); }\n  arg_iterator arg_end() { return arg_begin() + getNumArgs(); }\n  const_arg_iterator arg_begin() const { return getTrailingArgs(); }\n  const_arg_iterator arg_end() const { return arg_begin() + getNumArgs(); }\n\n  Expr **getArgs() { return reinterpret_cast<Expr **>(getTrailingArgs()); }\n  const Expr *const *getArgs() const {\n    return reinterpret_cast<const Expr *const *>(getTrailingArgs());\n  }\n\n  /// Return the number of arguments to the constructor call.\n  unsigned getNumArgs() const { return NumArgs; }\n\n  /// Return the specified argument.\n  Expr *getArg(unsigned Arg) {\n    assert(Arg < getNumArgs() && \"Arg access out of range!\");\n    return getArgs()[Arg];\n  }\n  const Expr *getArg(unsigned Arg) const {\n    assert(Arg < getNumArgs() && \"Arg access out of range!\");\n    return getArgs()[Arg];\n  }\n\n  /// Set the specified argument.\n  void setArg(unsigned Arg, Expr *ArgExpr) {\n    assert(Arg < getNumArgs() && \"Arg access out of range!\");\n    getArgs()[Arg] = ArgExpr;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n  SourceRange getParenOrBraceRange() const { return ParenOrBraceRange; }\n  void setParenOrBraceRange(SourceRange Range) { ParenOrBraceRange = Range; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXConstructExprClass ||\n           T->getStmtClass() == CXXTemporaryObjectExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(getTrailingArgs(), getTrailingArgs() + getNumArgs());\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<CXXConstructExpr *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n};\n\n/// Represents a call to an inherited base class constructor from an\n/// inheriting constructor. This call implicitly forwards the arguments from\n/// the enclosing context (an inheriting constructor) to the specified inherited\n/// base class constructor.\nclass CXXInheritedCtorInitExpr : public Expr {\nprivate:\n  CXXConstructorDecl *Constructor = nullptr;\n\n  /// The location of the using declaration.\n  SourceLocation Loc;\n\n  /// Whether this is the construction of a virtual base.\n  unsigned ConstructsVirtualBase : 1;\n\n  /// Whether the constructor is inherited from a virtual base class of the\n  /// class that we construct.\n  unsigned InheritedFromVirtualBase : 1;\n\npublic:\n  friend class ASTStmtReader;\n\n  /// Construct a C++ inheriting construction expression.\n  CXXInheritedCtorInitExpr(SourceLocation Loc, QualType T,\n                           CXXConstructorDecl *Ctor, bool ConstructsVirtualBase,\n                           bool InheritedFromVirtualBase)\n      : Expr(CXXInheritedCtorInitExprClass, T, VK_RValue, OK_Ordinary),\n        Constructor(Ctor), Loc(Loc),\n        ConstructsVirtualBase(ConstructsVirtualBase),\n        InheritedFromVirtualBase(InheritedFromVirtualBase) {\n    assert(!T->isDependentType());\n    setDependence(ExprDependence::None);\n  }\n\n  /// Construct an empty C++ inheriting construction expression.\n  explicit CXXInheritedCtorInitExpr(EmptyShell Empty)\n      : Expr(CXXInheritedCtorInitExprClass, Empty),\n        ConstructsVirtualBase(false), InheritedFromVirtualBase(false) {}\n\n  /// Get the constructor that this expression will call.\n  CXXConstructorDecl *getConstructor() const { return Constructor; }\n\n  /// Determine whether this constructor is actually constructing\n  /// a base class (rather than a complete object).\n  bool constructsVBase() const { return ConstructsVirtualBase; }\n  CXXConstructExpr::ConstructionKind getConstructionKind() const {\n    return ConstructsVirtualBase ? CXXConstructExpr::CK_VirtualBase\n                                 : CXXConstructExpr::CK_NonVirtualBase;\n  }\n\n  /// Determine whether the inherited constructor is inherited from a\n  /// virtual base of the object we construct. If so, we are not responsible\n  /// for calling the inherited constructor (the complete object constructor\n  /// does that), and so we don't need to pass any arguments.\n  bool inheritedFromVBase() const { return InheritedFromVirtualBase; }\n\n  SourceLocation getLocation() const LLVM_READONLY { return Loc; }\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Loc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXInheritedCtorInitExprClass;\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Represents an explicit C++ type conversion that uses \"functional\"\n/// notation (C++ [expr.type.conv]).\n///\n/// Example:\n/// \\code\n///   x = int(0.5);\n/// \\endcode\nclass CXXFunctionalCastExpr final\n    : public ExplicitCastExpr,\n      private llvm::TrailingObjects<CXXFunctionalCastExpr, CXXBaseSpecifier *,\n                                    FPOptionsOverride> {\n  SourceLocation LParenLoc;\n  SourceLocation RParenLoc;\n\n  CXXFunctionalCastExpr(QualType ty, ExprValueKind VK,\n                        TypeSourceInfo *writtenTy, CastKind kind,\n                        Expr *castExpr, unsigned pathSize,\n                        FPOptionsOverride FPO, SourceLocation lParenLoc,\n                        SourceLocation rParenLoc)\n      : ExplicitCastExpr(CXXFunctionalCastExprClass, ty, VK, kind, castExpr,\n                         pathSize, FPO.requiresTrailingStorage(), writtenTy),\n        LParenLoc(lParenLoc), RParenLoc(rParenLoc) {\n    if (hasStoredFPFeatures())\n      *getTrailingFPFeatures() = FPO;\n  }\n\n  explicit CXXFunctionalCastExpr(EmptyShell Shell, unsigned PathSize,\n                                 bool HasFPFeatures)\n      : ExplicitCastExpr(CXXFunctionalCastExprClass, Shell, PathSize,\n                         HasFPFeatures) {}\n\n  unsigned numTrailingObjects(OverloadToken<CXXBaseSpecifier *>) const {\n    return path_size();\n  }\n\npublic:\n  friend class CastExpr;\n  friend TrailingObjects;\n\n  static CXXFunctionalCastExpr *\n  Create(const ASTContext &Context, QualType T, ExprValueKind VK,\n         TypeSourceInfo *Written, CastKind Kind, Expr *Op,\n         const CXXCastPath *Path, FPOptionsOverride FPO, SourceLocation LPLoc,\n         SourceLocation RPLoc);\n  static CXXFunctionalCastExpr *\n  CreateEmpty(const ASTContext &Context, unsigned PathSize, bool HasFPFeatures);\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  void setLParenLoc(SourceLocation L) { LParenLoc = L; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  /// Determine whether this expression models list-initialization.\n  bool isListInitialization() const { return LParenLoc.isInvalid(); }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXFunctionalCastExprClass;\n  }\n};\n\n/// Represents a C++ functional cast expression that builds a\n/// temporary object.\n///\n/// This expression type represents a C++ \"functional\" cast\n/// (C++[expr.type.conv]) with N != 1 arguments that invokes a\n/// constructor to build a temporary object. With N == 1 arguments the\n/// functional cast expression will be represented by CXXFunctionalCastExpr.\n/// Example:\n/// \\code\n/// struct X { X(int, float); }\n///\n/// X create_X() {\n///   return X(1, 3.14f); // creates a CXXTemporaryObjectExpr\n/// };\n/// \\endcode\nclass CXXTemporaryObjectExpr final : public CXXConstructExpr {\n  friend class ASTStmtReader;\n\n  // CXXTemporaryObjectExpr has some trailing objects belonging\n  // to CXXConstructExpr. See the comment inside CXXConstructExpr\n  // for more details.\n\n  TypeSourceInfo *TSI;\n\n  CXXTemporaryObjectExpr(CXXConstructorDecl *Cons, QualType Ty,\n                         TypeSourceInfo *TSI, ArrayRef<Expr *> Args,\n                         SourceRange ParenOrBraceRange,\n                         bool HadMultipleCandidates, bool ListInitialization,\n                         bool StdInitListInitialization,\n                         bool ZeroInitialization);\n\n  CXXTemporaryObjectExpr(EmptyShell Empty, unsigned NumArgs);\n\npublic:\n  static CXXTemporaryObjectExpr *\n  Create(const ASTContext &Ctx, CXXConstructorDecl *Cons, QualType Ty,\n         TypeSourceInfo *TSI, ArrayRef<Expr *> Args,\n         SourceRange ParenOrBraceRange, bool HadMultipleCandidates,\n         bool ListInitialization, bool StdInitListInitialization,\n         bool ZeroInitialization);\n\n  static CXXTemporaryObjectExpr *CreateEmpty(const ASTContext &Ctx,\n                                             unsigned NumArgs);\n\n  TypeSourceInfo *getTypeSourceInfo() const { return TSI; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXTemporaryObjectExprClass;\n  }\n};\n\nStmt **CXXConstructExpr::getTrailingArgs() {\n  if (auto *E = dyn_cast<CXXTemporaryObjectExpr>(this))\n    return reinterpret_cast<Stmt **>(E + 1);\n  assert((getStmtClass() == CXXConstructExprClass) &&\n         \"Unexpected class deriving from CXXConstructExpr!\");\n  return reinterpret_cast<Stmt **>(this + 1);\n}\n\n/// A C++ lambda expression, which produces a function object\n/// (of unspecified type) that can be invoked later.\n///\n/// Example:\n/// \\code\n/// void low_pass_filter(std::vector<double> &values, double cutoff) {\n///   values.erase(std::remove_if(values.begin(), values.end(),\n///                               [=](double value) { return value > cutoff; });\n/// }\n/// \\endcode\n///\n/// C++11 lambda expressions can capture local variables, either by copying\n/// the values of those local variables at the time the function\n/// object is constructed (not when it is called!) or by holding a\n/// reference to the local variable. These captures can occur either\n/// implicitly or can be written explicitly between the square\n/// brackets ([...]) that start the lambda expression.\n///\n/// C++1y introduces a new form of \"capture\" called an init-capture that\n/// includes an initializing expression (rather than capturing a variable),\n/// and which can never occur implicitly.\nclass LambdaExpr final : public Expr,\n                         private llvm::TrailingObjects<LambdaExpr, Stmt *> {\n  // LambdaExpr has some data stored in LambdaExprBits.\n\n  /// The source range that covers the lambda introducer ([...]).\n  SourceRange IntroducerRange;\n\n  /// The source location of this lambda's capture-default ('=' or '&').\n  SourceLocation CaptureDefaultLoc;\n\n  /// The location of the closing brace ('}') that completes\n  /// the lambda.\n  ///\n  /// The location of the brace is also available by looking up the\n  /// function call operator in the lambda class. However, it is\n  /// stored here to improve the performance of getSourceRange(), and\n  /// to avoid having to deserialize the function call operator from a\n  /// module file just to determine the source range.\n  SourceLocation ClosingBrace;\n\n  /// Construct a lambda expression.\n  LambdaExpr(QualType T, SourceRange IntroducerRange,\n             LambdaCaptureDefault CaptureDefault,\n             SourceLocation CaptureDefaultLoc, bool ExplicitParams,\n             bool ExplicitResultType, ArrayRef<Expr *> CaptureInits,\n             SourceLocation ClosingBrace, bool ContainsUnexpandedParameterPack);\n\n  /// Construct an empty lambda expression.\n  LambdaExpr(EmptyShell Empty, unsigned NumCaptures);\n\n  Stmt **getStoredStmts() { return getTrailingObjects<Stmt *>(); }\n  Stmt *const *getStoredStmts() const { return getTrailingObjects<Stmt *>(); }\n\n  void initBodyIfNeeded() const;\n\npublic:\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// Construct a new lambda expression.\n  static LambdaExpr *\n  Create(const ASTContext &C, CXXRecordDecl *Class, SourceRange IntroducerRange,\n         LambdaCaptureDefault CaptureDefault, SourceLocation CaptureDefaultLoc,\n         bool ExplicitParams, bool ExplicitResultType,\n         ArrayRef<Expr *> CaptureInits, SourceLocation ClosingBrace,\n         bool ContainsUnexpandedParameterPack);\n\n  /// Construct a new lambda expression that will be deserialized from\n  /// an external source.\n  static LambdaExpr *CreateDeserialized(const ASTContext &C,\n                                        unsigned NumCaptures);\n\n  /// Determine the default capture kind for this lambda.\n  LambdaCaptureDefault getCaptureDefault() const {\n    return static_cast<LambdaCaptureDefault>(LambdaExprBits.CaptureDefault);\n  }\n\n  /// Retrieve the location of this lambda's capture-default, if any.\n  SourceLocation getCaptureDefaultLoc() const { return CaptureDefaultLoc; }\n\n  /// Determine whether one of this lambda's captures is an init-capture.\n  bool isInitCapture(const LambdaCapture *Capture) const;\n\n  /// An iterator that walks over the captures of the lambda,\n  /// both implicit and explicit.\n  using capture_iterator = const LambdaCapture *;\n\n  /// An iterator over a range of lambda captures.\n  using capture_range = llvm::iterator_range<capture_iterator>;\n\n  /// Retrieve this lambda's captures.\n  capture_range captures() const;\n\n  /// Retrieve an iterator pointing to the first lambda capture.\n  capture_iterator capture_begin() const;\n\n  /// Retrieve an iterator pointing past the end of the\n  /// sequence of lambda captures.\n  capture_iterator capture_end() const;\n\n  /// Determine the number of captures in this lambda.\n  unsigned capture_size() const { return LambdaExprBits.NumCaptures; }\n\n  /// Retrieve this lambda's explicit captures.\n  capture_range explicit_captures() const;\n\n  /// Retrieve an iterator pointing to the first explicit\n  /// lambda capture.\n  capture_iterator explicit_capture_begin() const;\n\n  /// Retrieve an iterator pointing past the end of the sequence of\n  /// explicit lambda captures.\n  capture_iterator explicit_capture_end() const;\n\n  /// Retrieve this lambda's implicit captures.\n  capture_range implicit_captures() const;\n\n  /// Retrieve an iterator pointing to the first implicit\n  /// lambda capture.\n  capture_iterator implicit_capture_begin() const;\n\n  /// Retrieve an iterator pointing past the end of the sequence of\n  /// implicit lambda captures.\n  capture_iterator implicit_capture_end() const;\n\n  /// Iterator that walks over the capture initialization\n  /// arguments.\n  using capture_init_iterator = Expr **;\n\n  /// Const iterator that walks over the capture initialization\n  /// arguments.\n  /// FIXME: This interface is prone to being used incorrectly.\n  using const_capture_init_iterator = Expr *const *;\n\n  /// Retrieve the initialization expressions for this lambda's captures.\n  llvm::iterator_range<capture_init_iterator> capture_inits() {\n    return llvm::make_range(capture_init_begin(), capture_init_end());\n  }\n\n  /// Retrieve the initialization expressions for this lambda's captures.\n  llvm::iterator_range<const_capture_init_iterator> capture_inits() const {\n    return llvm::make_range(capture_init_begin(), capture_init_end());\n  }\n\n  /// Retrieve the first initialization argument for this\n  /// lambda expression (which initializes the first capture field).\n  capture_init_iterator capture_init_begin() {\n    return reinterpret_cast<Expr **>(getStoredStmts());\n  }\n\n  /// Retrieve the first initialization argument for this\n  /// lambda expression (which initializes the first capture field).\n  const_capture_init_iterator capture_init_begin() const {\n    return reinterpret_cast<Expr *const *>(getStoredStmts());\n  }\n\n  /// Retrieve the iterator pointing one past the last\n  /// initialization argument for this lambda expression.\n  capture_init_iterator capture_init_end() {\n    return capture_init_begin() + capture_size();\n  }\n\n  /// Retrieve the iterator pointing one past the last\n  /// initialization argument for this lambda expression.\n  const_capture_init_iterator capture_init_end() const {\n    return capture_init_begin() + capture_size();\n  }\n\n  /// Retrieve the source range covering the lambda introducer,\n  /// which contains the explicit capture list surrounded by square\n  /// brackets ([...]).\n  SourceRange getIntroducerRange() const { return IntroducerRange; }\n\n  /// Retrieve the class that corresponds to the lambda.\n  ///\n  /// This is the \"closure type\" (C++1y [expr.prim.lambda]), and stores the\n  /// captures in its fields and provides the various operations permitted\n  /// on a lambda (copying, calling).\n  CXXRecordDecl *getLambdaClass() const;\n\n  /// Retrieve the function call operator associated with this\n  /// lambda expression.\n  CXXMethodDecl *getCallOperator() const;\n\n  /// Retrieve the function template call operator associated with this\n  /// lambda expression.\n  FunctionTemplateDecl *getDependentCallOperator() const;\n\n  /// If this is a generic lambda expression, retrieve the template\n  /// parameter list associated with it, or else return null.\n  TemplateParameterList *getTemplateParameterList() const;\n\n  /// Get the template parameters were explicitly specified (as opposed to being\n  /// invented by use of an auto parameter).\n  ArrayRef<NamedDecl *> getExplicitTemplateParameters() const;\n\n  /// Get the trailing requires clause, if any.\n  Expr *getTrailingRequiresClause() const;\n\n  /// Whether this is a generic lambda.\n  bool isGenericLambda() const { return getTemplateParameterList(); }\n\n  /// Retrieve the body of the lambda. This will be most of the time\n  /// a \\p CompoundStmt, but can also be \\p CoroutineBodyStmt wrapping\n  /// a \\p CompoundStmt. Note that unlike functions, lambda-expressions\n  /// cannot have a function-try-block.\n  Stmt *getBody() const;\n\n  /// Retrieve the \\p CompoundStmt representing the body of the lambda.\n  /// This is a convenience function for callers who do not need\n  /// to handle node(s) which may wrap a \\p CompoundStmt.\n  const CompoundStmt *getCompoundStmtBody() const;\n  CompoundStmt *getCompoundStmtBody() {\n    const auto *ConstThis = this;\n    return const_cast<CompoundStmt *>(ConstThis->getCompoundStmtBody());\n  }\n\n  /// Determine whether the lambda is mutable, meaning that any\n  /// captures values can be modified.\n  bool isMutable() const;\n\n  /// Determine whether this lambda has an explicit parameter\n  /// list vs. an implicit (empty) parameter list.\n  bool hasExplicitParameters() const { return LambdaExprBits.ExplicitParams; }\n\n  /// Whether this lambda had its result type explicitly specified.\n  bool hasExplicitResultType() const {\n    return LambdaExprBits.ExplicitResultType;\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == LambdaExprClass;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return IntroducerRange.getBegin();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY { return ClosingBrace; }\n\n  /// Includes the captures and the body of the lambda.\n  child_range children();\n  const_child_range children() const;\n};\n\n/// An expression \"T()\" which creates a value-initialized rvalue of type\n/// T, which is a non-class type.  See (C++98 [5.2.3p2]).\nclass CXXScalarValueInitExpr : public Expr {\n  friend class ASTStmtReader;\n\n  TypeSourceInfo *TypeInfo;\n\npublic:\n  /// Create an explicitly-written scalar-value initialization\n  /// expression.\n  CXXScalarValueInitExpr(QualType Type, TypeSourceInfo *TypeInfo,\n                         SourceLocation RParenLoc)\n      : Expr(CXXScalarValueInitExprClass, Type, VK_RValue, OK_Ordinary),\n        TypeInfo(TypeInfo) {\n    CXXScalarValueInitExprBits.RParenLoc = RParenLoc;\n    setDependence(computeDependence(this));\n  }\n\n  explicit CXXScalarValueInitExpr(EmptyShell Shell)\n      : Expr(CXXScalarValueInitExprClass, Shell) {}\n\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return TypeInfo;\n  }\n\n  SourceLocation getRParenLoc() const {\n    return CXXScalarValueInitExprBits.RParenLoc;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const { return getRParenLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXScalarValueInitExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Represents a new-expression for memory allocation and constructor\n/// calls, e.g: \"new CXXNewExpr(foo)\".\nclass CXXNewExpr final\n    : public Expr,\n      private llvm::TrailingObjects<CXXNewExpr, Stmt *, SourceRange> {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// Points to the allocation function used.\n  FunctionDecl *OperatorNew;\n\n  /// Points to the deallocation function used in case of error. May be null.\n  FunctionDecl *OperatorDelete;\n\n  /// The allocated type-source information, as written in the source.\n  TypeSourceInfo *AllocatedTypeInfo;\n\n  /// Range of the entire new expression.\n  SourceRange Range;\n\n  /// Source-range of a paren-delimited initializer.\n  SourceRange DirectInitRange;\n\n  // CXXNewExpr is followed by several optional trailing objects.\n  // They are in order:\n  //\n  // * An optional \"Stmt *\" for the array size expression.\n  //    Present if and ony if isArray().\n  //\n  // * An optional \"Stmt *\" for the init expression.\n  //    Present if and only if hasInitializer().\n  //\n  // * An array of getNumPlacementArgs() \"Stmt *\" for the placement new\n  //   arguments, if any.\n  //\n  // * An optional SourceRange for the range covering the parenthesized type-id\n  //    if the allocated type was expressed as a parenthesized type-id.\n  //    Present if and only if isParenTypeId().\n  unsigned arraySizeOffset() const { return 0; }\n  unsigned initExprOffset() const { return arraySizeOffset() + isArray(); }\n  unsigned placementNewArgsOffset() const {\n    return initExprOffset() + hasInitializer();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<Stmt *>) const {\n    return isArray() + hasInitializer() + getNumPlacementArgs();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<SourceRange>) const {\n    return isParenTypeId();\n  }\n\npublic:\n  enum InitializationStyle {\n    /// New-expression has no initializer as written.\n    NoInit,\n\n    /// New-expression has a C++98 paren-delimited initializer.\n    CallInit,\n\n    /// New-expression has a C++11 list-initializer.\n    ListInit\n  };\n\nprivate:\n  /// Build a c++ new expression.\n  CXXNewExpr(bool IsGlobalNew, FunctionDecl *OperatorNew,\n             FunctionDecl *OperatorDelete, bool ShouldPassAlignment,\n             bool UsualArrayDeleteWantsSize, ArrayRef<Expr *> PlacementArgs,\n             SourceRange TypeIdParens, Optional<Expr *> ArraySize,\n             InitializationStyle InitializationStyle, Expr *Initializer,\n             QualType Ty, TypeSourceInfo *AllocatedTypeInfo, SourceRange Range,\n             SourceRange DirectInitRange);\n\n  /// Build an empty c++ new expression.\n  CXXNewExpr(EmptyShell Empty, bool IsArray, unsigned NumPlacementArgs,\n             bool IsParenTypeId);\n\npublic:\n  /// Create a c++ new expression.\n  static CXXNewExpr *\n  Create(const ASTContext &Ctx, bool IsGlobalNew, FunctionDecl *OperatorNew,\n         FunctionDecl *OperatorDelete, bool ShouldPassAlignment,\n         bool UsualArrayDeleteWantsSize, ArrayRef<Expr *> PlacementArgs,\n         SourceRange TypeIdParens, Optional<Expr *> ArraySize,\n         InitializationStyle InitializationStyle, Expr *Initializer,\n         QualType Ty, TypeSourceInfo *AllocatedTypeInfo, SourceRange Range,\n         SourceRange DirectInitRange);\n\n  /// Create an empty c++ new expression.\n  static CXXNewExpr *CreateEmpty(const ASTContext &Ctx, bool IsArray,\n                                 bool HasInit, unsigned NumPlacementArgs,\n                                 bool IsParenTypeId);\n\n  QualType getAllocatedType() const {\n    return getType()->castAs<PointerType>()->getPointeeType();\n  }\n\n  TypeSourceInfo *getAllocatedTypeSourceInfo() const {\n    return AllocatedTypeInfo;\n  }\n\n  /// True if the allocation result needs to be null-checked.\n  ///\n  /// C++11 [expr.new]p13:\n  ///   If the allocation function returns null, initialization shall\n  ///   not be done, the deallocation function shall not be called,\n  ///   and the value of the new-expression shall be null.\n  ///\n  /// C++ DR1748:\n  ///   If the allocation function is a reserved placement allocation\n  ///   function that returns null, the behavior is undefined.\n  ///\n  /// An allocation function is not allowed to return null unless it\n  /// has a non-throwing exception-specification.  The '03 rule is\n  /// identical except that the definition of a non-throwing\n  /// exception specification is just \"is it throw()?\".\n  bool shouldNullCheckAllocation() const;\n\n  FunctionDecl *getOperatorNew() const { return OperatorNew; }\n  void setOperatorNew(FunctionDecl *D) { OperatorNew = D; }\n  FunctionDecl *getOperatorDelete() const { return OperatorDelete; }\n  void setOperatorDelete(FunctionDecl *D) { OperatorDelete = D; }\n\n  bool isArray() const { return CXXNewExprBits.IsArray; }\n\n  Optional<Expr *> getArraySize() {\n    if (!isArray())\n      return None;\n    return cast_or_null<Expr>(getTrailingObjects<Stmt *>()[arraySizeOffset()]);\n  }\n  Optional<const Expr *> getArraySize() const {\n    if (!isArray())\n      return None;\n    return cast_or_null<Expr>(getTrailingObjects<Stmt *>()[arraySizeOffset()]);\n  }\n\n  unsigned getNumPlacementArgs() const {\n    return CXXNewExprBits.NumPlacementArgs;\n  }\n\n  Expr **getPlacementArgs() {\n    return reinterpret_cast<Expr **>(getTrailingObjects<Stmt *>() +\n                                     placementNewArgsOffset());\n  }\n\n  Expr *getPlacementArg(unsigned I) {\n    assert((I < getNumPlacementArgs()) && \"Index out of range!\");\n    return getPlacementArgs()[I];\n  }\n  const Expr *getPlacementArg(unsigned I) const {\n    return const_cast<CXXNewExpr *>(this)->getPlacementArg(I);\n  }\n\n  bool isParenTypeId() const { return CXXNewExprBits.IsParenTypeId; }\n  SourceRange getTypeIdParens() const {\n    return isParenTypeId() ? getTrailingObjects<SourceRange>()[0]\n                           : SourceRange();\n  }\n\n  bool isGlobalNew() const { return CXXNewExprBits.IsGlobalNew; }\n\n  /// Whether this new-expression has any initializer at all.\n  bool hasInitializer() const {\n    return CXXNewExprBits.StoredInitializationStyle > 0;\n  }\n\n  /// The kind of initializer this new-expression has.\n  InitializationStyle getInitializationStyle() const {\n    if (CXXNewExprBits.StoredInitializationStyle == 0)\n      return NoInit;\n    return static_cast<InitializationStyle>(\n        CXXNewExprBits.StoredInitializationStyle - 1);\n  }\n\n  /// The initializer of this new-expression.\n  Expr *getInitializer() {\n    return hasInitializer()\n               ? cast<Expr>(getTrailingObjects<Stmt *>()[initExprOffset()])\n               : nullptr;\n  }\n  const Expr *getInitializer() const {\n    return hasInitializer()\n               ? cast<Expr>(getTrailingObjects<Stmt *>()[initExprOffset()])\n               : nullptr;\n  }\n\n  /// Returns the CXXConstructExpr from this new-expression, or null.\n  const CXXConstructExpr *getConstructExpr() const {\n    return dyn_cast_or_null<CXXConstructExpr>(getInitializer());\n  }\n\n  /// Indicates whether the required alignment should be implicitly passed to\n  /// the allocation function.\n  bool passAlignment() const { return CXXNewExprBits.ShouldPassAlignment; }\n\n  /// Answers whether the usual array deallocation function for the\n  /// allocated type expects the size of the allocation as a\n  /// parameter.\n  bool doesUsualArrayDeleteWantSize() const {\n    return CXXNewExprBits.UsualArrayDeleteWantsSize;\n  }\n\n  using arg_iterator = ExprIterator;\n  using const_arg_iterator = ConstExprIterator;\n\n  llvm::iterator_range<arg_iterator> placement_arguments() {\n    return llvm::make_range(placement_arg_begin(), placement_arg_end());\n  }\n\n  llvm::iterator_range<const_arg_iterator> placement_arguments() const {\n    return llvm::make_range(placement_arg_begin(), placement_arg_end());\n  }\n\n  arg_iterator placement_arg_begin() {\n    return getTrailingObjects<Stmt *>() + placementNewArgsOffset();\n  }\n  arg_iterator placement_arg_end() {\n    return placement_arg_begin() + getNumPlacementArgs();\n  }\n  const_arg_iterator placement_arg_begin() const {\n    return getTrailingObjects<Stmt *>() + placementNewArgsOffset();\n  }\n  const_arg_iterator placement_arg_end() const {\n    return placement_arg_begin() + getNumPlacementArgs();\n  }\n\n  using raw_arg_iterator = Stmt **;\n\n  raw_arg_iterator raw_arg_begin() { return getTrailingObjects<Stmt *>(); }\n  raw_arg_iterator raw_arg_end() {\n    return raw_arg_begin() + numTrailingObjects(OverloadToken<Stmt *>());\n  }\n  const_arg_iterator raw_arg_begin() const {\n    return getTrailingObjects<Stmt *>();\n  }\n  const_arg_iterator raw_arg_end() const {\n    return raw_arg_begin() + numTrailingObjects(OverloadToken<Stmt *>());\n  }\n\n  SourceLocation getBeginLoc() const { return Range.getBegin(); }\n  SourceLocation getEndLoc() const { return Range.getEnd(); }\n\n  SourceRange getDirectInitRange() const { return DirectInitRange; }\n  SourceRange getSourceRange() const { return Range; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXNewExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(raw_arg_begin(), raw_arg_end()); }\n\n  const_child_range children() const {\n    return const_child_range(const_cast<CXXNewExpr *>(this)->children());\n  }\n};\n\n/// Represents a \\c delete expression for memory deallocation and\n/// destructor calls, e.g. \"delete[] pArray\".\nclass CXXDeleteExpr : public Expr {\n  friend class ASTStmtReader;\n\n  /// Points to the operator delete overload that is used. Could be a member.\n  FunctionDecl *OperatorDelete = nullptr;\n\n  /// The pointer expression to be deleted.\n  Stmt *Argument = nullptr;\n\npublic:\n  CXXDeleteExpr(QualType Ty, bool GlobalDelete, bool ArrayForm,\n                bool ArrayFormAsWritten, bool UsualArrayDeleteWantsSize,\n                FunctionDecl *OperatorDelete, Expr *Arg, SourceLocation Loc)\n      : Expr(CXXDeleteExprClass, Ty, VK_RValue, OK_Ordinary),\n        OperatorDelete(OperatorDelete), Argument(Arg) {\n    CXXDeleteExprBits.GlobalDelete = GlobalDelete;\n    CXXDeleteExprBits.ArrayForm = ArrayForm;\n    CXXDeleteExprBits.ArrayFormAsWritten = ArrayFormAsWritten;\n    CXXDeleteExprBits.UsualArrayDeleteWantsSize = UsualArrayDeleteWantsSize;\n    CXXDeleteExprBits.Loc = Loc;\n    setDependence(computeDependence(this));\n  }\n\n  explicit CXXDeleteExpr(EmptyShell Shell) : Expr(CXXDeleteExprClass, Shell) {}\n\n  bool isGlobalDelete() const { return CXXDeleteExprBits.GlobalDelete; }\n  bool isArrayForm() const { return CXXDeleteExprBits.ArrayForm; }\n  bool isArrayFormAsWritten() const {\n    return CXXDeleteExprBits.ArrayFormAsWritten;\n  }\n\n  /// Answers whether the usual array deallocation function for the\n  /// allocated type expects the size of the allocation as a\n  /// parameter.  This can be true even if the actual deallocation\n  /// function that we're using doesn't want a size.\n  bool doesUsualArrayDeleteWantSize() const {\n    return CXXDeleteExprBits.UsualArrayDeleteWantsSize;\n  }\n\n  FunctionDecl *getOperatorDelete() const { return OperatorDelete; }\n\n  Expr *getArgument() { return cast<Expr>(Argument); }\n  const Expr *getArgument() const { return cast<Expr>(Argument); }\n\n  /// Retrieve the type being destroyed.\n  ///\n  /// If the type being destroyed is a dependent type which may or may not\n  /// be a pointer, return an invalid type.\n  QualType getDestroyedType() const;\n\n  SourceLocation getBeginLoc() const { return CXXDeleteExprBits.Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return Argument->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXDeleteExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Argument, &Argument + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Argument, &Argument + 1);\n  }\n};\n\n/// Stores the type being destroyed by a pseudo-destructor expression.\nclass PseudoDestructorTypeStorage {\n  /// Either the type source information or the name of the type, if\n  /// it couldn't be resolved due to type-dependence.\n  llvm::PointerUnion<TypeSourceInfo *, IdentifierInfo *> Type;\n\n  /// The starting source location of the pseudo-destructor type.\n  SourceLocation Location;\n\npublic:\n  PseudoDestructorTypeStorage() = default;\n\n  PseudoDestructorTypeStorage(IdentifierInfo *II, SourceLocation Loc)\n      : Type(II), Location(Loc) {}\n\n  PseudoDestructorTypeStorage(TypeSourceInfo *Info);\n\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return Type.dyn_cast<TypeSourceInfo *>();\n  }\n\n  IdentifierInfo *getIdentifier() const {\n    return Type.dyn_cast<IdentifierInfo *>();\n  }\n\n  SourceLocation getLocation() const { return Location; }\n};\n\n/// Represents a C++ pseudo-destructor (C++ [expr.pseudo]).\n///\n/// A pseudo-destructor is an expression that looks like a member access to a\n/// destructor of a scalar type, except that scalar types don't have\n/// destructors. For example:\n///\n/// \\code\n/// typedef int T;\n/// void f(int *p) {\n///   p->T::~T();\n/// }\n/// \\endcode\n///\n/// Pseudo-destructors typically occur when instantiating templates such as:\n///\n/// \\code\n/// template<typename T>\n/// void destroy(T* ptr) {\n///   ptr->T::~T();\n/// }\n/// \\endcode\n///\n/// for scalar types. A pseudo-destructor expression has no run-time semantics\n/// beyond evaluating the base expression.\nclass CXXPseudoDestructorExpr : public Expr {\n  friend class ASTStmtReader;\n\n  /// The base expression (that is being destroyed).\n  Stmt *Base = nullptr;\n\n  /// Whether the operator was an arrow ('->'); otherwise, it was a\n  /// period ('.').\n  bool IsArrow : 1;\n\n  /// The location of the '.' or '->' operator.\n  SourceLocation OperatorLoc;\n\n  /// The nested-name-specifier that follows the operator, if present.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// The type that precedes the '::' in a qualified pseudo-destructor\n  /// expression.\n  TypeSourceInfo *ScopeType = nullptr;\n\n  /// The location of the '::' in a qualified pseudo-destructor\n  /// expression.\n  SourceLocation ColonColonLoc;\n\n  /// The location of the '~'.\n  SourceLocation TildeLoc;\n\n  /// The type being destroyed, or its name if we were unable to\n  /// resolve the name.\n  PseudoDestructorTypeStorage DestroyedType;\n\npublic:\n  CXXPseudoDestructorExpr(const ASTContext &Context,\n                          Expr *Base, bool isArrow, SourceLocation OperatorLoc,\n                          NestedNameSpecifierLoc QualifierLoc,\n                          TypeSourceInfo *ScopeType,\n                          SourceLocation ColonColonLoc,\n                          SourceLocation TildeLoc,\n                          PseudoDestructorTypeStorage DestroyedType);\n\n  explicit CXXPseudoDestructorExpr(EmptyShell Shell)\n      : Expr(CXXPseudoDestructorExprClass, Shell), IsArrow(false) {}\n\n  Expr *getBase() const { return cast<Expr>(Base); }\n\n  /// Determines whether this member expression actually had\n  /// a C++ nested-name-specifier prior to the name of the member, e.g.,\n  /// x->Base::foo.\n  bool hasQualifier() const { return QualifierLoc.hasQualifier(); }\n\n  /// Retrieves the nested-name-specifier that qualifies the type name,\n  /// with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// If the member name was qualified, retrieves the\n  /// nested-name-specifier that precedes the member name. Otherwise, returns\n  /// null.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  /// Determine whether this pseudo-destructor expression was written\n  /// using an '->' (otherwise, it used a '.').\n  bool isArrow() const { return IsArrow; }\n\n  /// Retrieve the location of the '.' or '->' operator.\n  SourceLocation getOperatorLoc() const { return OperatorLoc; }\n\n  /// Retrieve the scope type in a qualified pseudo-destructor\n  /// expression.\n  ///\n  /// Pseudo-destructor expressions can have extra qualification within them\n  /// that is not part of the nested-name-specifier, e.g., \\c p->T::~T().\n  /// Here, if the object type of the expression is (or may be) a scalar type,\n  /// \\p T may also be a scalar type and, therefore, cannot be part of a\n  /// nested-name-specifier. It is stored as the \"scope type\" of the pseudo-\n  /// destructor expression.\n  TypeSourceInfo *getScopeTypeInfo() const { return ScopeType; }\n\n  /// Retrieve the location of the '::' in a qualified pseudo-destructor\n  /// expression.\n  SourceLocation getColonColonLoc() const { return ColonColonLoc; }\n\n  /// Retrieve the location of the '~'.\n  SourceLocation getTildeLoc() const { return TildeLoc; }\n\n  /// Retrieve the source location information for the type\n  /// being destroyed.\n  ///\n  /// This type-source information is available for non-dependent\n  /// pseudo-destructor expressions and some dependent pseudo-destructor\n  /// expressions. Returns null if we only have the identifier for a\n  /// dependent pseudo-destructor expression.\n  TypeSourceInfo *getDestroyedTypeInfo() const {\n    return DestroyedType.getTypeSourceInfo();\n  }\n\n  /// In a dependent pseudo-destructor expression for which we do not\n  /// have full type information on the destroyed type, provides the name\n  /// of the destroyed type.\n  IdentifierInfo *getDestroyedTypeIdentifier() const {\n    return DestroyedType.getIdentifier();\n  }\n\n  /// Retrieve the type being destroyed.\n  QualType getDestroyedType() const;\n\n  /// Retrieve the starting location of the type being destroyed.\n  SourceLocation getDestroyedTypeLoc() const {\n    return DestroyedType.getLocation();\n  }\n\n  /// Set the name of destroyed type for a dependent pseudo-destructor\n  /// expression.\n  void setDestroyedType(IdentifierInfo *II, SourceLocation Loc) {\n    DestroyedType = PseudoDestructorTypeStorage(II, Loc);\n  }\n\n  /// Set the destroyed type.\n  void setDestroyedType(TypeSourceInfo *Info) {\n    DestroyedType = PseudoDestructorTypeStorage(Info);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return Base->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXPseudoDestructorExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Base, &Base + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Base, &Base + 1);\n  }\n};\n\n/// A type trait used in the implementation of various C++11 and\n/// Library TR1 trait templates.\n///\n/// \\code\n///   __is_pod(int) == true\n///   __is_enum(std::string) == false\n///   __is_trivially_constructible(vector<int>, int*, int*)\n/// \\endcode\nclass TypeTraitExpr final\n    : public Expr,\n      private llvm::TrailingObjects<TypeTraitExpr, TypeSourceInfo *> {\n  /// The location of the type trait keyword.\n  SourceLocation Loc;\n\n  ///  The location of the closing parenthesis.\n  SourceLocation RParenLoc;\n\n  // Note: The TypeSourceInfos for the arguments are allocated after the\n  // TypeTraitExpr.\n\n  TypeTraitExpr(QualType T, SourceLocation Loc, TypeTrait Kind,\n                ArrayRef<TypeSourceInfo *> Args,\n                SourceLocation RParenLoc,\n                bool Value);\n\n  TypeTraitExpr(EmptyShell Empty) : Expr(TypeTraitExprClass, Empty) {}\n\n  size_t numTrailingObjects(OverloadToken<TypeSourceInfo *>) const {\n    return getNumArgs();\n  }\n\npublic:\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// Create a new type trait expression.\n  static TypeTraitExpr *Create(const ASTContext &C, QualType T,\n                               SourceLocation Loc, TypeTrait Kind,\n                               ArrayRef<TypeSourceInfo *> Args,\n                               SourceLocation RParenLoc,\n                               bool Value);\n\n  static TypeTraitExpr *CreateDeserialized(const ASTContext &C,\n                                           unsigned NumArgs);\n\n  /// Determine which type trait this expression uses.\n  TypeTrait getTrait() const {\n    return static_cast<TypeTrait>(TypeTraitExprBits.Kind);\n  }\n\n  bool getValue() const {\n    assert(!isValueDependent());\n    return TypeTraitExprBits.Value;\n  }\n\n  /// Determine the number of arguments to this type trait.\n  unsigned getNumArgs() const { return TypeTraitExprBits.NumArgs; }\n\n  /// Retrieve the Ith argument.\n  TypeSourceInfo *getArg(unsigned I) const {\n    assert(I < getNumArgs() && \"Argument out-of-range\");\n    return getArgs()[I];\n  }\n\n  /// Retrieve the argument types.\n  ArrayRef<TypeSourceInfo *> getArgs() const {\n    return llvm::makeArrayRef(getTrailingObjects<TypeSourceInfo *>(),\n                              getNumArgs());\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == TypeTraitExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// An Embarcadero array type trait, as used in the implementation of\n/// __array_rank and __array_extent.\n///\n/// Example:\n/// \\code\n///   __array_rank(int[10][20]) == 2\n///   __array_extent(int, 1)    == 20\n/// \\endcode\nclass ArrayTypeTraitExpr : public Expr {\n  /// The trait. An ArrayTypeTrait enum in MSVC compat unsigned.\n  unsigned ATT : 2;\n\n  /// The value of the type trait. Unspecified if dependent.\n  uint64_t Value = 0;\n\n  /// The array dimension being queried, or -1 if not used.\n  Expr *Dimension;\n\n  /// The location of the type trait keyword.\n  SourceLocation Loc;\n\n  /// The location of the closing paren.\n  SourceLocation RParen;\n\n  /// The type being queried.\n  TypeSourceInfo *QueriedType = nullptr;\n\npublic:\n  friend class ASTStmtReader;\n\n  ArrayTypeTraitExpr(SourceLocation loc, ArrayTypeTrait att,\n                     TypeSourceInfo *queried, uint64_t value, Expr *dimension,\n                     SourceLocation rparen, QualType ty)\n      : Expr(ArrayTypeTraitExprClass, ty, VK_RValue, OK_Ordinary), ATT(att),\n        Value(value), Dimension(dimension), Loc(loc), RParen(rparen),\n        QueriedType(queried) {\n    assert(att <= ATT_Last && \"invalid enum value!\");\n    assert(static_cast<unsigned>(att) == ATT && \"ATT overflow!\");\n    setDependence(computeDependence(this));\n  }\n\n  explicit ArrayTypeTraitExpr(EmptyShell Empty)\n      : Expr(ArrayTypeTraitExprClass, Empty), ATT(0) {}\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParen; }\n\n  ArrayTypeTrait getTrait() const { return static_cast<ArrayTypeTrait>(ATT); }\n\n  QualType getQueriedType() const { return QueriedType->getType(); }\n\n  TypeSourceInfo *getQueriedTypeSourceInfo() const { return QueriedType; }\n\n  uint64_t getValue() const { assert(!isTypeDependent()); return Value; }\n\n  Expr *getDimensionExpression() const { return Dimension; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ArrayTypeTraitExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// An expression trait intrinsic.\n///\n/// Example:\n/// \\code\n///   __is_lvalue_expr(std::cout) == true\n///   __is_lvalue_expr(1) == false\n/// \\endcode\nclass ExpressionTraitExpr : public Expr {\n  /// The trait. A ExpressionTrait enum in MSVC compatible unsigned.\n  unsigned ET : 31;\n\n  /// The value of the type trait. Unspecified if dependent.\n  unsigned Value : 1;\n\n  /// The location of the type trait keyword.\n  SourceLocation Loc;\n\n  /// The location of the closing paren.\n  SourceLocation RParen;\n\n  /// The expression being queried.\n  Expr* QueriedExpression = nullptr;\n\npublic:\n  friend class ASTStmtReader;\n\n  ExpressionTraitExpr(SourceLocation loc, ExpressionTrait et, Expr *queried,\n                      bool value, SourceLocation rparen, QualType resultType)\n      : Expr(ExpressionTraitExprClass, resultType, VK_RValue, OK_Ordinary),\n        ET(et), Value(value), Loc(loc), RParen(rparen),\n        QueriedExpression(queried) {\n    assert(et <= ET_Last && \"invalid enum value!\");\n    assert(static_cast<unsigned>(et) == ET && \"ET overflow!\");\n    setDependence(computeDependence(this));\n  }\n\n  explicit ExpressionTraitExpr(EmptyShell Empty)\n      : Expr(ExpressionTraitExprClass, Empty), ET(0), Value(false) {}\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParen; }\n\n  ExpressionTrait getTrait() const { return static_cast<ExpressionTrait>(ET); }\n\n  Expr *getQueriedExpression() const { return QueriedExpression; }\n\n  bool getValue() const { return Value; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ExpressionTraitExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// A reference to an overloaded function set, either an\n/// \\c UnresolvedLookupExpr or an \\c UnresolvedMemberExpr.\nclass OverloadExpr : public Expr {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  /// The common name of these declarations.\n  DeclarationNameInfo NameInfo;\n\n  /// The nested-name-specifier that qualifies the name, if any.\n  NestedNameSpecifierLoc QualifierLoc;\n\nprotected:\n  OverloadExpr(StmtClass SC, const ASTContext &Context,\n               NestedNameSpecifierLoc QualifierLoc,\n               SourceLocation TemplateKWLoc,\n               const DeclarationNameInfo &NameInfo,\n               const TemplateArgumentListInfo *TemplateArgs,\n               UnresolvedSetIterator Begin, UnresolvedSetIterator End,\n               bool KnownDependent, bool KnownInstantiationDependent,\n               bool KnownContainsUnexpandedParameterPack);\n\n  OverloadExpr(StmtClass SC, EmptyShell Empty, unsigned NumResults,\n               bool HasTemplateKWAndArgsInfo);\n\n  /// Return the results. Defined after UnresolvedMemberExpr.\n  inline DeclAccessPair *getTrailingResults();\n  const DeclAccessPair *getTrailingResults() const {\n    return const_cast<OverloadExpr *>(this)->getTrailingResults();\n  }\n\n  /// Return the optional template keyword and arguments info.\n  /// Defined after UnresolvedMemberExpr.\n  inline ASTTemplateKWAndArgsInfo *getTrailingASTTemplateKWAndArgsInfo();\n  const ASTTemplateKWAndArgsInfo *getTrailingASTTemplateKWAndArgsInfo() const {\n    return const_cast<OverloadExpr *>(this)\n        ->getTrailingASTTemplateKWAndArgsInfo();\n  }\n\n  /// Return the optional template arguments. Defined after\n  /// UnresolvedMemberExpr.\n  inline TemplateArgumentLoc *getTrailingTemplateArgumentLoc();\n  const TemplateArgumentLoc *getTrailingTemplateArgumentLoc() const {\n    return const_cast<OverloadExpr *>(this)->getTrailingTemplateArgumentLoc();\n  }\n\n  bool hasTemplateKWAndArgsInfo() const {\n    return OverloadExprBits.HasTemplateKWAndArgsInfo;\n  }\n\npublic:\n  struct FindResult {\n    OverloadExpr *Expression;\n    bool IsAddressOfOperand;\n    bool HasFormOfMemberPointer;\n  };\n\n  /// Finds the overloaded expression in the given expression \\p E of\n  /// OverloadTy.\n  ///\n  /// \\return the expression (which must be there) and true if it has\n  /// the particular form of a member pointer expression\n  static FindResult find(Expr *E) {\n    assert(E->getType()->isSpecificBuiltinType(BuiltinType::Overload));\n\n    FindResult Result;\n\n    E = E->IgnoreParens();\n    if (isa<UnaryOperator>(E)) {\n      assert(cast<UnaryOperator>(E)->getOpcode() == UO_AddrOf);\n      E = cast<UnaryOperator>(E)->getSubExpr();\n      auto *Ovl = cast<OverloadExpr>(E->IgnoreParens());\n\n      Result.HasFormOfMemberPointer = (E == Ovl && Ovl->getQualifier());\n      Result.IsAddressOfOperand = true;\n      Result.Expression = Ovl;\n    } else {\n      Result.HasFormOfMemberPointer = false;\n      Result.IsAddressOfOperand = false;\n      Result.Expression = cast<OverloadExpr>(E);\n    }\n\n    return Result;\n  }\n\n  /// Gets the naming class of this lookup, if any.\n  /// Defined after UnresolvedMemberExpr.\n  inline CXXRecordDecl *getNamingClass();\n  const CXXRecordDecl *getNamingClass() const {\n    return const_cast<OverloadExpr *>(this)->getNamingClass();\n  }\n\n  using decls_iterator = UnresolvedSetImpl::iterator;\n\n  decls_iterator decls_begin() const {\n    return UnresolvedSetIterator(getTrailingResults());\n  }\n  decls_iterator decls_end() const {\n    return UnresolvedSetIterator(getTrailingResults() + getNumDecls());\n  }\n  llvm::iterator_range<decls_iterator> decls() const {\n    return llvm::make_range(decls_begin(), decls_end());\n  }\n\n  /// Gets the number of declarations in the unresolved set.\n  unsigned getNumDecls() const { return OverloadExprBits.NumResults; }\n\n  /// Gets the full name info.\n  const DeclarationNameInfo &getNameInfo() const { return NameInfo; }\n\n  /// Gets the name looked up.\n  DeclarationName getName() const { return NameInfo.getName(); }\n\n  /// Gets the location of the name.\n  SourceLocation getNameLoc() const { return NameInfo.getLoc(); }\n\n  /// Fetches the nested-name qualifier, if one was given.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  /// Fetches the nested-name qualifier with source-location\n  /// information, if one was given.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the location of the template keyword preceding\n  /// this name, if any.\n  SourceLocation getTemplateKeywordLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingASTTemplateKWAndArgsInfo()->TemplateKWLoc;\n  }\n\n  /// Retrieve the location of the left angle bracket starting the\n  /// explicit template argument list following the name, if any.\n  SourceLocation getLAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingASTTemplateKWAndArgsInfo()->LAngleLoc;\n  }\n\n  /// Retrieve the location of the right angle bracket ending the\n  /// explicit template argument list following the name, if any.\n  SourceLocation getRAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingASTTemplateKWAndArgsInfo()->RAngleLoc;\n  }\n\n  /// Determines whether the name was preceded by the template keyword.\n  bool hasTemplateKeyword() const { return getTemplateKeywordLoc().isValid(); }\n\n  /// Determines whether this expression had explicit template arguments.\n  bool hasExplicitTemplateArgs() const { return getLAngleLoc().isValid(); }\n\n  TemplateArgumentLoc const *getTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return nullptr;\n    return const_cast<OverloadExpr *>(this)->getTrailingTemplateArgumentLoc();\n  }\n\n  unsigned getNumTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return 0;\n\n    return getTrailingASTTemplateKWAndArgsInfo()->NumTemplateArgs;\n  }\n\n  ArrayRef<TemplateArgumentLoc> template_arguments() const {\n    return {getTemplateArgs(), getNumTemplateArgs()};\n  }\n\n  /// Copies the template arguments into the given structure.\n  void copyTemplateArgumentsInto(TemplateArgumentListInfo &List) const {\n    if (hasExplicitTemplateArgs())\n      getTrailingASTTemplateKWAndArgsInfo()->copyInto(getTemplateArgs(), List);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == UnresolvedLookupExprClass ||\n           T->getStmtClass() == UnresolvedMemberExprClass;\n  }\n};\n\n/// A reference to a name which we were able to look up during\n/// parsing but could not resolve to a specific declaration.\n///\n/// This arises in several ways:\n///   * we might be waiting for argument-dependent lookup;\n///   * the name might resolve to an overloaded function;\n/// and eventually:\n///   * the lookup might have included a function template.\n///\n/// These never include UnresolvedUsingValueDecls, which are always class\n/// members and therefore appear only in UnresolvedMemberLookupExprs.\nclass UnresolvedLookupExpr final\n    : public OverloadExpr,\n      private llvm::TrailingObjects<UnresolvedLookupExpr, DeclAccessPair,\n                                    ASTTemplateKWAndArgsInfo,\n                                    TemplateArgumentLoc> {\n  friend class ASTStmtReader;\n  friend class OverloadExpr;\n  friend TrailingObjects;\n\n  /// The naming class (C++ [class.access.base]p5) of the lookup, if\n  /// any.  This can generally be recalculated from the context chain,\n  /// but that can be fairly expensive for unqualified lookups.\n  CXXRecordDecl *NamingClass;\n\n  // UnresolvedLookupExpr is followed by several trailing objects.\n  // They are in order:\n  //\n  // * An array of getNumResults() DeclAccessPair for the results. These are\n  //   undesugared, which is to say, they may include UsingShadowDecls.\n  //   Access is relative to the naming class.\n  //\n  // * An optional ASTTemplateKWAndArgsInfo for the explicitly specified\n  //   template keyword and arguments. Present if and only if\n  //   hasTemplateKWAndArgsInfo().\n  //\n  // * An array of getNumTemplateArgs() TemplateArgumentLoc containing\n  //   location information for the explicitly specified template arguments.\n\n  UnresolvedLookupExpr(const ASTContext &Context, CXXRecordDecl *NamingClass,\n                       NestedNameSpecifierLoc QualifierLoc,\n                       SourceLocation TemplateKWLoc,\n                       const DeclarationNameInfo &NameInfo, bool RequiresADL,\n                       bool Overloaded,\n                       const TemplateArgumentListInfo *TemplateArgs,\n                       UnresolvedSetIterator Begin, UnresolvedSetIterator End);\n\n  UnresolvedLookupExpr(EmptyShell Empty, unsigned NumResults,\n                       bool HasTemplateKWAndArgsInfo);\n\n  unsigned numTrailingObjects(OverloadToken<DeclAccessPair>) const {\n    return getNumDecls();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<ASTTemplateKWAndArgsInfo>) const {\n    return hasTemplateKWAndArgsInfo();\n  }\n\npublic:\n  static UnresolvedLookupExpr *\n  Create(const ASTContext &Context, CXXRecordDecl *NamingClass,\n         NestedNameSpecifierLoc QualifierLoc,\n         const DeclarationNameInfo &NameInfo, bool RequiresADL, bool Overloaded,\n         UnresolvedSetIterator Begin, UnresolvedSetIterator End);\n\n  static UnresolvedLookupExpr *\n  Create(const ASTContext &Context, CXXRecordDecl *NamingClass,\n         NestedNameSpecifierLoc QualifierLoc, SourceLocation TemplateKWLoc,\n         const DeclarationNameInfo &NameInfo, bool RequiresADL,\n         const TemplateArgumentListInfo *Args, UnresolvedSetIterator Begin,\n         UnresolvedSetIterator End);\n\n  static UnresolvedLookupExpr *CreateEmpty(const ASTContext &Context,\n                                           unsigned NumResults,\n                                           bool HasTemplateKWAndArgsInfo,\n                                           unsigned NumTemplateArgs);\n\n  /// True if this declaration should be extended by\n  /// argument-dependent lookup.\n  bool requiresADL() const { return UnresolvedLookupExprBits.RequiresADL; }\n\n  /// True if this lookup is overloaded.\n  bool isOverloaded() const { return UnresolvedLookupExprBits.Overloaded; }\n\n  /// Gets the 'naming class' (in the sense of C++0x\n  /// [class.access.base]p5) of the lookup.  This is the scope\n  /// that was looked in to find these results.\n  CXXRecordDecl *getNamingClass() { return NamingClass; }\n  const CXXRecordDecl *getNamingClass() const { return NamingClass; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    if (NestedNameSpecifierLoc l = getQualifierLoc())\n      return l.getBeginLoc();\n    return getNameInfo().getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    if (hasExplicitTemplateArgs())\n      return getRAngleLoc();\n    return getNameInfo().getEndLoc();\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == UnresolvedLookupExprClass;\n  }\n};\n\n/// A qualified reference to a name whose declaration cannot\n/// yet be resolved.\n///\n/// DependentScopeDeclRefExpr is similar to DeclRefExpr in that\n/// it expresses a reference to a declaration such as\n/// X<T>::value. The difference, however, is that an\n/// DependentScopeDeclRefExpr node is used only within C++ templates when\n/// the qualification (e.g., X<T>::) refers to a dependent type. In\n/// this case, X<T>::value cannot resolve to a declaration because the\n/// declaration will differ from one instantiation of X<T> to the\n/// next. Therefore, DependentScopeDeclRefExpr keeps track of the\n/// qualifier (X<T>::) and the name of the entity being referenced\n/// (\"value\"). Such expressions will instantiate to a DeclRefExpr once the\n/// declaration can be found.\nclass DependentScopeDeclRefExpr final\n    : public Expr,\n      private llvm::TrailingObjects<DependentScopeDeclRefExpr,\n                                    ASTTemplateKWAndArgsInfo,\n                                    TemplateArgumentLoc> {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// The nested-name-specifier that qualifies this unresolved\n  /// declaration name.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// The name of the entity we will be referencing.\n  DeclarationNameInfo NameInfo;\n\n  DependentScopeDeclRefExpr(QualType Ty, NestedNameSpecifierLoc QualifierLoc,\n                            SourceLocation TemplateKWLoc,\n                            const DeclarationNameInfo &NameInfo,\n                            const TemplateArgumentListInfo *Args);\n\n  size_t numTrailingObjects(OverloadToken<ASTTemplateKWAndArgsInfo>) const {\n    return hasTemplateKWAndArgsInfo();\n  }\n\n  bool hasTemplateKWAndArgsInfo() const {\n    return DependentScopeDeclRefExprBits.HasTemplateKWAndArgsInfo;\n  }\n\npublic:\n  static DependentScopeDeclRefExpr *\n  Create(const ASTContext &Context, NestedNameSpecifierLoc QualifierLoc,\n         SourceLocation TemplateKWLoc, const DeclarationNameInfo &NameInfo,\n         const TemplateArgumentListInfo *TemplateArgs);\n\n  static DependentScopeDeclRefExpr *CreateEmpty(const ASTContext &Context,\n                                                bool HasTemplateKWAndArgsInfo,\n                                                unsigned NumTemplateArgs);\n\n  /// Retrieve the name that this expression refers to.\n  const DeclarationNameInfo &getNameInfo() const { return NameInfo; }\n\n  /// Retrieve the name that this expression refers to.\n  DeclarationName getDeclName() const { return NameInfo.getName(); }\n\n  /// Retrieve the location of the name within the expression.\n  ///\n  /// For example, in \"X<T>::value\" this is the location of \"value\".\n  SourceLocation getLocation() const { return NameInfo.getLoc(); }\n\n  /// Retrieve the nested-name-specifier that qualifies the\n  /// name, with source location information.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the nested-name-specifier that qualifies this\n  /// declaration.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  /// Retrieve the location of the template keyword preceding\n  /// this name, if any.\n  SourceLocation getTemplateKeywordLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->TemplateKWLoc;\n  }\n\n  /// Retrieve the location of the left angle bracket starting the\n  /// explicit template argument list following the name, if any.\n  SourceLocation getLAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->LAngleLoc;\n  }\n\n  /// Retrieve the location of the right angle bracket ending the\n  /// explicit template argument list following the name, if any.\n  SourceLocation getRAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->RAngleLoc;\n  }\n\n  /// Determines whether the name was preceded by the template keyword.\n  bool hasTemplateKeyword() const { return getTemplateKeywordLoc().isValid(); }\n\n  /// Determines whether this lookup had explicit template arguments.\n  bool hasExplicitTemplateArgs() const { return getLAngleLoc().isValid(); }\n\n  /// Copies the template arguments (if present) into the given\n  /// structure.\n  void copyTemplateArgumentsInto(TemplateArgumentListInfo &List) const {\n    if (hasExplicitTemplateArgs())\n      getTrailingObjects<ASTTemplateKWAndArgsInfo>()->copyInto(\n          getTrailingObjects<TemplateArgumentLoc>(), List);\n  }\n\n  TemplateArgumentLoc const *getTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return nullptr;\n\n    return getTrailingObjects<TemplateArgumentLoc>();\n  }\n\n  unsigned getNumTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return 0;\n\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->NumTemplateArgs;\n  }\n\n  ArrayRef<TemplateArgumentLoc> template_arguments() const {\n    return {getTemplateArgs(), getNumTemplateArgs()};\n  }\n\n  /// Note: getBeginLoc() is the start of the whole DependentScopeDeclRefExpr,\n  /// and differs from getLocation().getStart().\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return QualifierLoc.getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    if (hasExplicitTemplateArgs())\n      return getRAngleLoc();\n    return getLocation();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == DependentScopeDeclRefExprClass;\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Represents an expression -- generally a full-expression -- that\n/// introduces cleanups to be run at the end of the sub-expression's\n/// evaluation.  The most common source of expression-introduced\n/// cleanups is temporary objects in C++, but several other kinds of\n/// expressions can create cleanups, including basically every\n/// call in ARC that returns an Objective-C pointer.\n///\n/// This expression also tracks whether the sub-expression contains a\n/// potentially-evaluated block literal.  The lifetime of a block\n/// literal is the extent of the enclosing scope.\nclass ExprWithCleanups final\n    : public FullExpr,\n      private llvm::TrailingObjects<\n          ExprWithCleanups,\n          llvm::PointerUnion<BlockDecl *, CompoundLiteralExpr *>> {\npublic:\n  /// The type of objects that are kept in the cleanup.\n  /// It's useful to remember the set of blocks and block-scoped compound\n  /// literals; we could also remember the set of temporaries, but there's\n  /// currently no need.\n  using CleanupObject = llvm::PointerUnion<BlockDecl *, CompoundLiteralExpr *>;\n\nprivate:\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  ExprWithCleanups(EmptyShell, unsigned NumObjects);\n  ExprWithCleanups(Expr *SubExpr, bool CleanupsHaveSideEffects,\n                   ArrayRef<CleanupObject> Objects);\n\npublic:\n  static ExprWithCleanups *Create(const ASTContext &C, EmptyShell empty,\n                                  unsigned numObjects);\n\n  static ExprWithCleanups *Create(const ASTContext &C, Expr *subexpr,\n                                  bool CleanupsHaveSideEffects,\n                                  ArrayRef<CleanupObject> objects);\n\n  ArrayRef<CleanupObject> getObjects() const {\n    return llvm::makeArrayRef(getTrailingObjects<CleanupObject>(),\n                              getNumObjects());\n  }\n\n  unsigned getNumObjects() const { return ExprWithCleanupsBits.NumObjects; }\n\n  CleanupObject getObject(unsigned i) const {\n    assert(i < getNumObjects() && \"Index out of range\");\n    return getObjects()[i];\n  }\n\n  bool cleanupsHaveSideEffects() const {\n    return ExprWithCleanupsBits.CleanupsHaveSideEffects;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return SubExpr->getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return SubExpr->getEndLoc();\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ExprWithCleanupsClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&SubExpr, &SubExpr + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&SubExpr, &SubExpr + 1);\n  }\n};\n\n/// Describes an explicit type conversion that uses functional\n/// notion but could not be resolved because one or more arguments are\n/// type-dependent.\n///\n/// The explicit type conversions expressed by\n/// CXXUnresolvedConstructExpr have the form <tt>T(a1, a2, ..., aN)</tt>,\n/// where \\c T is some type and \\c a1, \\c a2, ..., \\c aN are values, and\n/// either \\c T is a dependent type or one or more of the <tt>a</tt>'s is\n/// type-dependent. For example, this would occur in a template such\n/// as:\n///\n/// \\code\n///   template<typename T, typename A1>\n///   inline T make_a(const A1& a1) {\n///     return T(a1);\n///   }\n/// \\endcode\n///\n/// When the returned expression is instantiated, it may resolve to a\n/// constructor call, conversion function call, or some kind of type\n/// conversion.\nclass CXXUnresolvedConstructExpr final\n    : public Expr,\n      private llvm::TrailingObjects<CXXUnresolvedConstructExpr, Expr *> {\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  /// The type being constructed.\n  TypeSourceInfo *TSI;\n\n  /// The location of the left parentheses ('(').\n  SourceLocation LParenLoc;\n\n  /// The location of the right parentheses (')').\n  SourceLocation RParenLoc;\n\n  CXXUnresolvedConstructExpr(QualType T, TypeSourceInfo *TSI,\n                             SourceLocation LParenLoc, ArrayRef<Expr *> Args,\n                             SourceLocation RParenLoc);\n\n  CXXUnresolvedConstructExpr(EmptyShell Empty, unsigned NumArgs)\n      : Expr(CXXUnresolvedConstructExprClass, Empty), TSI(nullptr) {\n    CXXUnresolvedConstructExprBits.NumArgs = NumArgs;\n  }\n\npublic:\n  static CXXUnresolvedConstructExpr *Create(const ASTContext &Context,\n                                            QualType T, TypeSourceInfo *TSI,\n                                            SourceLocation LParenLoc,\n                                            ArrayRef<Expr *> Args,\n                                            SourceLocation RParenLoc);\n\n  static CXXUnresolvedConstructExpr *CreateEmpty(const ASTContext &Context,\n                                                 unsigned NumArgs);\n\n  /// Retrieve the type that is being constructed, as specified\n  /// in the source code.\n  QualType getTypeAsWritten() const { return TSI->getType(); }\n\n  /// Retrieve the type source information for the type being\n  /// constructed.\n  TypeSourceInfo *getTypeSourceInfo() const { return TSI; }\n\n  /// Retrieve the location of the left parentheses ('(') that\n  /// precedes the argument list.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  void setLParenLoc(SourceLocation L) { LParenLoc = L; }\n\n  /// Retrieve the location of the right parentheses (')') that\n  /// follows the argument list.\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  /// Determine whether this expression models list-initialization.\n  /// If so, there will be exactly one subexpression, which will be\n  /// an InitListExpr.\n  bool isListInitialization() const { return LParenLoc.isInvalid(); }\n\n  /// Retrieve the number of arguments.\n  unsigned getNumArgs() const { return CXXUnresolvedConstructExprBits.NumArgs; }\n\n  using arg_iterator = Expr **;\n  using arg_range = llvm::iterator_range<arg_iterator>;\n\n  arg_iterator arg_begin() { return getTrailingObjects<Expr *>(); }\n  arg_iterator arg_end() { return arg_begin() + getNumArgs(); }\n  arg_range arguments() { return arg_range(arg_begin(), arg_end()); }\n\n  using const_arg_iterator = const Expr* const *;\n  using const_arg_range = llvm::iterator_range<const_arg_iterator>;\n\n  const_arg_iterator arg_begin() const { return getTrailingObjects<Expr *>(); }\n  const_arg_iterator arg_end() const { return arg_begin() + getNumArgs(); }\n  const_arg_range arguments() const {\n    return const_arg_range(arg_begin(), arg_end());\n  }\n\n  Expr *getArg(unsigned I) {\n    assert(I < getNumArgs() && \"Argument index out-of-range\");\n    return arg_begin()[I];\n  }\n\n  const Expr *getArg(unsigned I) const {\n    assert(I < getNumArgs() && \"Argument index out-of-range\");\n    return arg_begin()[I];\n  }\n\n  void setArg(unsigned I, Expr *E) {\n    assert(I < getNumArgs() && \"Argument index out-of-range\");\n    arg_begin()[I] = E;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    if (!RParenLoc.isValid() && getNumArgs() > 0)\n      return getArg(getNumArgs() - 1)->getEndLoc();\n    return RParenLoc;\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXUnresolvedConstructExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    auto **begin = reinterpret_cast<Stmt **>(arg_begin());\n    return child_range(begin, begin + getNumArgs());\n  }\n\n  const_child_range children() const {\n    auto **begin = reinterpret_cast<Stmt **>(\n        const_cast<CXXUnresolvedConstructExpr *>(this)->arg_begin());\n    return const_child_range(begin, begin + getNumArgs());\n  }\n};\n\n/// Represents a C++ member access expression where the actual\n/// member referenced could not be resolved because the base\n/// expression or the member name was dependent.\n///\n/// Like UnresolvedMemberExprs, these can be either implicit or\n/// explicit accesses.  It is only possible to get one of these with\n/// an implicit access if a qualifier is provided.\nclass CXXDependentScopeMemberExpr final\n    : public Expr,\n      private llvm::TrailingObjects<CXXDependentScopeMemberExpr,\n                                    ASTTemplateKWAndArgsInfo,\n                                    TemplateArgumentLoc, NamedDecl *> {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// The expression for the base pointer or class reference,\n  /// e.g., the \\c x in x.f.  Can be null in implicit accesses.\n  Stmt *Base;\n\n  /// The type of the base expression.  Never null, even for\n  /// implicit accesses.\n  QualType BaseType;\n\n  /// The nested-name-specifier that precedes the member name, if any.\n  /// FIXME: This could be in principle store as a trailing object.\n  /// However the performance impact of doing so should be investigated first.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// The member to which this member expression refers, which\n  /// can be name, overloaded operator, or destructor.\n  ///\n  /// FIXME: could also be a template-id\n  DeclarationNameInfo MemberNameInfo;\n\n  // CXXDependentScopeMemberExpr is followed by several trailing objects,\n  // some of which optional. They are in order:\n  //\n  // * An optional ASTTemplateKWAndArgsInfo for the explicitly specified\n  //   template keyword and arguments. Present if and only if\n  //   hasTemplateKWAndArgsInfo().\n  //\n  // * An array of getNumTemplateArgs() TemplateArgumentLoc containing location\n  //   information for the explicitly specified template arguments.\n  //\n  // * An optional NamedDecl *. In a qualified member access expression such\n  //   as t->Base::f, this member stores the resolves of name lookup in the\n  //   context of the member access expression, to be used at instantiation\n  //   time. Present if and only if hasFirstQualifierFoundInScope().\n\n  bool hasTemplateKWAndArgsInfo() const {\n    return CXXDependentScopeMemberExprBits.HasTemplateKWAndArgsInfo;\n  }\n\n  bool hasFirstQualifierFoundInScope() const {\n    return CXXDependentScopeMemberExprBits.HasFirstQualifierFoundInScope;\n  }\n\n  unsigned numTrailingObjects(OverloadToken<ASTTemplateKWAndArgsInfo>) const {\n    return hasTemplateKWAndArgsInfo();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<TemplateArgumentLoc>) const {\n    return getNumTemplateArgs();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<NamedDecl *>) const {\n    return hasFirstQualifierFoundInScope();\n  }\n\n  CXXDependentScopeMemberExpr(const ASTContext &Ctx, Expr *Base,\n                              QualType BaseType, bool IsArrow,\n                              SourceLocation OperatorLoc,\n                              NestedNameSpecifierLoc QualifierLoc,\n                              SourceLocation TemplateKWLoc,\n                              NamedDecl *FirstQualifierFoundInScope,\n                              DeclarationNameInfo MemberNameInfo,\n                              const TemplateArgumentListInfo *TemplateArgs);\n\n  CXXDependentScopeMemberExpr(EmptyShell Empty, bool HasTemplateKWAndArgsInfo,\n                              bool HasFirstQualifierFoundInScope);\n\npublic:\n  static CXXDependentScopeMemberExpr *\n  Create(const ASTContext &Ctx, Expr *Base, QualType BaseType, bool IsArrow,\n         SourceLocation OperatorLoc, NestedNameSpecifierLoc QualifierLoc,\n         SourceLocation TemplateKWLoc, NamedDecl *FirstQualifierFoundInScope,\n         DeclarationNameInfo MemberNameInfo,\n         const TemplateArgumentListInfo *TemplateArgs);\n\n  static CXXDependentScopeMemberExpr *\n  CreateEmpty(const ASTContext &Ctx, bool HasTemplateKWAndArgsInfo,\n              unsigned NumTemplateArgs, bool HasFirstQualifierFoundInScope);\n\n  /// True if this is an implicit access, i.e. one in which the\n  /// member being accessed was not written in the source.  The source\n  /// location of the operator is invalid in this case.\n  bool isImplicitAccess() const {\n    if (!Base)\n      return true;\n    return cast<Expr>(Base)->isImplicitCXXThis();\n  }\n\n  /// Retrieve the base object of this member expressions,\n  /// e.g., the \\c x in \\c x.m.\n  Expr *getBase() const {\n    assert(!isImplicitAccess());\n    return cast<Expr>(Base);\n  }\n\n  QualType getBaseType() const { return BaseType; }\n\n  /// Determine whether this member expression used the '->'\n  /// operator; otherwise, it used the '.' operator.\n  bool isArrow() const { return CXXDependentScopeMemberExprBits.IsArrow; }\n\n  /// Retrieve the location of the '->' or '.' operator.\n  SourceLocation getOperatorLoc() const {\n    return CXXDependentScopeMemberExprBits.OperatorLoc;\n  }\n\n  /// Retrieve the nested-name-specifier that qualifies the member name.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  /// Retrieve the nested-name-specifier that qualifies the member\n  /// name, with source location information.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the first part of the nested-name-specifier that was\n  /// found in the scope of the member access expression when the member access\n  /// was initially parsed.\n  ///\n  /// This function only returns a useful result when member access expression\n  /// uses a qualified member name, e.g., \"x.Base::f\". Here, the declaration\n  /// returned by this function describes what was found by unqualified name\n  /// lookup for the identifier \"Base\" within the scope of the member access\n  /// expression itself. At template instantiation time, this information is\n  /// combined with the results of name lookup into the type of the object\n  /// expression itself (the class type of x).\n  NamedDecl *getFirstQualifierFoundInScope() const {\n    if (!hasFirstQualifierFoundInScope())\n      return nullptr;\n    return *getTrailingObjects<NamedDecl *>();\n  }\n\n  /// Retrieve the name of the member that this expression refers to.\n  const DeclarationNameInfo &getMemberNameInfo() const {\n    return MemberNameInfo;\n  }\n\n  /// Retrieve the name of the member that this expression refers to.\n  DeclarationName getMember() const { return MemberNameInfo.getName(); }\n\n  // Retrieve the location of the name of the member that this\n  // expression refers to.\n  SourceLocation getMemberLoc() const { return MemberNameInfo.getLoc(); }\n\n  /// Retrieve the location of the template keyword preceding the\n  /// member name, if any.\n  SourceLocation getTemplateKeywordLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->TemplateKWLoc;\n  }\n\n  /// Retrieve the location of the left angle bracket starting the\n  /// explicit template argument list following the member name, if any.\n  SourceLocation getLAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->LAngleLoc;\n  }\n\n  /// Retrieve the location of the right angle bracket ending the\n  /// explicit template argument list following the member name, if any.\n  SourceLocation getRAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->RAngleLoc;\n  }\n\n  /// Determines whether the member name was preceded by the template keyword.\n  bool hasTemplateKeyword() const { return getTemplateKeywordLoc().isValid(); }\n\n  /// Determines whether this member expression actually had a C++\n  /// template argument list explicitly specified, e.g., x.f<int>.\n  bool hasExplicitTemplateArgs() const { return getLAngleLoc().isValid(); }\n\n  /// Copies the template arguments (if present) into the given\n  /// structure.\n  void copyTemplateArgumentsInto(TemplateArgumentListInfo &List) const {\n    if (hasExplicitTemplateArgs())\n      getTrailingObjects<ASTTemplateKWAndArgsInfo>()->copyInto(\n          getTrailingObjects<TemplateArgumentLoc>(), List);\n  }\n\n  /// Retrieve the template arguments provided as part of this\n  /// template-id.\n  const TemplateArgumentLoc *getTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return nullptr;\n\n    return getTrailingObjects<TemplateArgumentLoc>();\n  }\n\n  /// Retrieve the number of template arguments provided as part of this\n  /// template-id.\n  unsigned getNumTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return 0;\n\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->NumTemplateArgs;\n  }\n\n  ArrayRef<TemplateArgumentLoc> template_arguments() const {\n    return {getTemplateArgs(), getNumTemplateArgs()};\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    if (!isImplicitAccess())\n      return Base->getBeginLoc();\n    if (getQualifier())\n      return getQualifierLoc().getBeginLoc();\n    return MemberNameInfo.getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    if (hasExplicitTemplateArgs())\n      return getRAngleLoc();\n    return MemberNameInfo.getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXDependentScopeMemberExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    if (isImplicitAccess())\n      return child_range(child_iterator(), child_iterator());\n    return child_range(&Base, &Base + 1);\n  }\n\n  const_child_range children() const {\n    if (isImplicitAccess())\n      return const_child_range(const_child_iterator(), const_child_iterator());\n    return const_child_range(&Base, &Base + 1);\n  }\n};\n\n/// Represents a C++ member access expression for which lookup\n/// produced a set of overloaded functions.\n///\n/// The member access may be explicit or implicit:\n/// \\code\n///    struct A {\n///      int a, b;\n///      int explicitAccess() { return this->a + this->A::b; }\n///      int implicitAccess() { return a + A::b; }\n///    };\n/// \\endcode\n///\n/// In the final AST, an explicit access always becomes a MemberExpr.\n/// An implicit access may become either a MemberExpr or a\n/// DeclRefExpr, depending on whether the member is static.\nclass UnresolvedMemberExpr final\n    : public OverloadExpr,\n      private llvm::TrailingObjects<UnresolvedMemberExpr, DeclAccessPair,\n                                    ASTTemplateKWAndArgsInfo,\n                                    TemplateArgumentLoc> {\n  friend class ASTStmtReader;\n  friend class OverloadExpr;\n  friend TrailingObjects;\n\n  /// The expression for the base pointer or class reference,\n  /// e.g., the \\c x in x.f.\n  ///\n  /// This can be null if this is an 'unbased' member expression.\n  Stmt *Base;\n\n  /// The type of the base expression; never null.\n  QualType BaseType;\n\n  /// The location of the '->' or '.' operator.\n  SourceLocation OperatorLoc;\n\n  // UnresolvedMemberExpr is followed by several trailing objects.\n  // They are in order:\n  //\n  // * An array of getNumResults() DeclAccessPair for the results. These are\n  //   undesugared, which is to say, they may include UsingShadowDecls.\n  //   Access is relative to the naming class.\n  //\n  // * An optional ASTTemplateKWAndArgsInfo for the explicitly specified\n  //   template keyword and arguments. Present if and only if\n  //   hasTemplateKWAndArgsInfo().\n  //\n  // * An array of getNumTemplateArgs() TemplateArgumentLoc containing\n  //   location information for the explicitly specified template arguments.\n\n  UnresolvedMemberExpr(const ASTContext &Context, bool HasUnresolvedUsing,\n                       Expr *Base, QualType BaseType, bool IsArrow,\n                       SourceLocation OperatorLoc,\n                       NestedNameSpecifierLoc QualifierLoc,\n                       SourceLocation TemplateKWLoc,\n                       const DeclarationNameInfo &MemberNameInfo,\n                       const TemplateArgumentListInfo *TemplateArgs,\n                       UnresolvedSetIterator Begin, UnresolvedSetIterator End);\n\n  UnresolvedMemberExpr(EmptyShell Empty, unsigned NumResults,\n                       bool HasTemplateKWAndArgsInfo);\n\n  unsigned numTrailingObjects(OverloadToken<DeclAccessPair>) const {\n    return getNumDecls();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<ASTTemplateKWAndArgsInfo>) const {\n    return hasTemplateKWAndArgsInfo();\n  }\n\npublic:\n  static UnresolvedMemberExpr *\n  Create(const ASTContext &Context, bool HasUnresolvedUsing, Expr *Base,\n         QualType BaseType, bool IsArrow, SourceLocation OperatorLoc,\n         NestedNameSpecifierLoc QualifierLoc, SourceLocation TemplateKWLoc,\n         const DeclarationNameInfo &MemberNameInfo,\n         const TemplateArgumentListInfo *TemplateArgs,\n         UnresolvedSetIterator Begin, UnresolvedSetIterator End);\n\n  static UnresolvedMemberExpr *CreateEmpty(const ASTContext &Context,\n                                           unsigned NumResults,\n                                           bool HasTemplateKWAndArgsInfo,\n                                           unsigned NumTemplateArgs);\n\n  /// True if this is an implicit access, i.e., one in which the\n  /// member being accessed was not written in the source.\n  ///\n  /// The source location of the operator is invalid in this case.\n  bool isImplicitAccess() const;\n\n  /// Retrieve the base object of this member expressions,\n  /// e.g., the \\c x in \\c x.m.\n  Expr *getBase() {\n    assert(!isImplicitAccess());\n    return cast<Expr>(Base);\n  }\n  const Expr *getBase() const {\n    assert(!isImplicitAccess());\n    return cast<Expr>(Base);\n  }\n\n  QualType getBaseType() const { return BaseType; }\n\n  /// Determine whether the lookup results contain an unresolved using\n  /// declaration.\n  bool hasUnresolvedUsing() const {\n    return UnresolvedMemberExprBits.HasUnresolvedUsing;\n  }\n\n  /// Determine whether this member expression used the '->'\n  /// operator; otherwise, it used the '.' operator.\n  bool isArrow() const { return UnresolvedMemberExprBits.IsArrow; }\n\n  /// Retrieve the location of the '->' or '.' operator.\n  SourceLocation getOperatorLoc() const { return OperatorLoc; }\n\n  /// Retrieve the naming class of this lookup.\n  CXXRecordDecl *getNamingClass();\n  const CXXRecordDecl *getNamingClass() const {\n    return const_cast<UnresolvedMemberExpr *>(this)->getNamingClass();\n  }\n\n  /// Retrieve the full name info for the member that this expression\n  /// refers to.\n  const DeclarationNameInfo &getMemberNameInfo() const { return getNameInfo(); }\n\n  /// Retrieve the name of the member that this expression refers to.\n  DeclarationName getMemberName() const { return getName(); }\n\n  /// Retrieve the location of the name of the member that this\n  /// expression refers to.\n  SourceLocation getMemberLoc() const { return getNameLoc(); }\n\n  /// Return the preferred location (the member name) for the arrow when\n  /// diagnosing a problem with this expression.\n  SourceLocation getExprLoc() const LLVM_READONLY { return getMemberLoc(); }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    if (!isImplicitAccess())\n      return Base->getBeginLoc();\n    if (NestedNameSpecifierLoc l = getQualifierLoc())\n      return l.getBeginLoc();\n    return getMemberNameInfo().getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    if (hasExplicitTemplateArgs())\n      return getRAngleLoc();\n    return getMemberNameInfo().getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == UnresolvedMemberExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    if (isImplicitAccess())\n      return child_range(child_iterator(), child_iterator());\n    return child_range(&Base, &Base + 1);\n  }\n\n  const_child_range children() const {\n    if (isImplicitAccess())\n      return const_child_range(const_child_iterator(), const_child_iterator());\n    return const_child_range(&Base, &Base + 1);\n  }\n};\n\nDeclAccessPair *OverloadExpr::getTrailingResults() {\n  if (auto *ULE = dyn_cast<UnresolvedLookupExpr>(this))\n    return ULE->getTrailingObjects<DeclAccessPair>();\n  return cast<UnresolvedMemberExpr>(this)->getTrailingObjects<DeclAccessPair>();\n}\n\nASTTemplateKWAndArgsInfo *OverloadExpr::getTrailingASTTemplateKWAndArgsInfo() {\n  if (!hasTemplateKWAndArgsInfo())\n    return nullptr;\n\n  if (auto *ULE = dyn_cast<UnresolvedLookupExpr>(this))\n    return ULE->getTrailingObjects<ASTTemplateKWAndArgsInfo>();\n  return cast<UnresolvedMemberExpr>(this)\n      ->getTrailingObjects<ASTTemplateKWAndArgsInfo>();\n}\n\nTemplateArgumentLoc *OverloadExpr::getTrailingTemplateArgumentLoc() {\n  if (auto *ULE = dyn_cast<UnresolvedLookupExpr>(this))\n    return ULE->getTrailingObjects<TemplateArgumentLoc>();\n  return cast<UnresolvedMemberExpr>(this)\n      ->getTrailingObjects<TemplateArgumentLoc>();\n}\n\nCXXRecordDecl *OverloadExpr::getNamingClass() {\n  if (auto *ULE = dyn_cast<UnresolvedLookupExpr>(this))\n    return ULE->getNamingClass();\n  return cast<UnresolvedMemberExpr>(this)->getNamingClass();\n}\n\n/// Represents a C++11 noexcept expression (C++ [expr.unary.noexcept]).\n///\n/// The noexcept expression tests whether a given expression might throw. Its\n/// result is a boolean constant.\nclass CXXNoexceptExpr : public Expr {\n  friend class ASTStmtReader;\n\n  Stmt *Operand;\n  SourceRange Range;\n\npublic:\n  CXXNoexceptExpr(QualType Ty, Expr *Operand, CanThrowResult Val,\n                  SourceLocation Keyword, SourceLocation RParen)\n      : Expr(CXXNoexceptExprClass, Ty, VK_RValue, OK_Ordinary),\n        Operand(Operand), Range(Keyword, RParen) {\n    CXXNoexceptExprBits.Value = Val == CT_Cannot;\n    setDependence(computeDependence(this, Val));\n  }\n\n  CXXNoexceptExpr(EmptyShell Empty) : Expr(CXXNoexceptExprClass, Empty) {}\n\n  Expr *getOperand() const { return static_cast<Expr *>(Operand); }\n\n  SourceLocation getBeginLoc() const { return Range.getBegin(); }\n  SourceLocation getEndLoc() const { return Range.getEnd(); }\n  SourceRange getSourceRange() const { return Range; }\n\n  bool getValue() const { return CXXNoexceptExprBits.Value; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXNoexceptExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Operand, &Operand + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Operand, &Operand + 1);\n  }\n};\n\n/// Represents a C++11 pack expansion that produces a sequence of\n/// expressions.\n///\n/// A pack expansion expression contains a pattern (which itself is an\n/// expression) followed by an ellipsis. For example:\n///\n/// \\code\n/// template<typename F, typename ...Types>\n/// void forward(F f, Types &&...args) {\n///   f(static_cast<Types&&>(args)...);\n/// }\n/// \\endcode\n///\n/// Here, the argument to the function object \\c f is a pack expansion whose\n/// pattern is \\c static_cast<Types&&>(args). When the \\c forward function\n/// template is instantiated, the pack expansion will instantiate to zero or\n/// or more function arguments to the function object \\c f.\nclass PackExpansionExpr : public Expr {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  SourceLocation EllipsisLoc;\n\n  /// The number of expansions that will be produced by this pack\n  /// expansion expression, if known.\n  ///\n  /// When zero, the number of expansions is not known. Otherwise, this value\n  /// is the number of expansions + 1.\n  unsigned NumExpansions;\n\n  Stmt *Pattern;\n\npublic:\n  PackExpansionExpr(QualType T, Expr *Pattern, SourceLocation EllipsisLoc,\n                    Optional<unsigned> NumExpansions)\n      : Expr(PackExpansionExprClass, T, Pattern->getValueKind(),\n             Pattern->getObjectKind()),\n        EllipsisLoc(EllipsisLoc),\n        NumExpansions(NumExpansions ? *NumExpansions + 1 : 0),\n        Pattern(Pattern) {\n    setDependence(computeDependence(this));\n  }\n\n  PackExpansionExpr(EmptyShell Empty) : Expr(PackExpansionExprClass, Empty) {}\n\n  /// Retrieve the pattern of the pack expansion.\n  Expr *getPattern() { return reinterpret_cast<Expr *>(Pattern); }\n\n  /// Retrieve the pattern of the pack expansion.\n  const Expr *getPattern() const { return reinterpret_cast<Expr *>(Pattern); }\n\n  /// Retrieve the location of the ellipsis that describes this pack\n  /// expansion.\n  SourceLocation getEllipsisLoc() const { return EllipsisLoc; }\n\n  /// Determine the number of expansions that will be produced when\n  /// this pack expansion is instantiated, if already known.\n  Optional<unsigned> getNumExpansions() const {\n    if (NumExpansions)\n      return NumExpansions - 1;\n\n    return None;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return Pattern->getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY { return EllipsisLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == PackExpansionExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&Pattern, &Pattern + 1);\n  }\n\n  const_child_range children() const {\n    return const_child_range(&Pattern, &Pattern + 1);\n  }\n};\n\n/// Represents an expression that computes the length of a parameter\n/// pack.\n///\n/// \\code\n/// template<typename ...Types>\n/// struct count {\n///   static const unsigned value = sizeof...(Types);\n/// };\n/// \\endcode\nclass SizeOfPackExpr final\n    : public Expr,\n      private llvm::TrailingObjects<SizeOfPackExpr, TemplateArgument> {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// The location of the \\c sizeof keyword.\n  SourceLocation OperatorLoc;\n\n  /// The location of the name of the parameter pack.\n  SourceLocation PackLoc;\n\n  /// The location of the closing parenthesis.\n  SourceLocation RParenLoc;\n\n  /// The length of the parameter pack, if known.\n  ///\n  /// When this expression is not value-dependent, this is the length of\n  /// the pack. When the expression was parsed rather than instantiated\n  /// (and thus is value-dependent), this is zero.\n  ///\n  /// After partial substitution into a sizeof...(X) expression (for instance,\n  /// within an alias template or during function template argument deduction),\n  /// we store a trailing array of partially-substituted TemplateArguments,\n  /// and this is the length of that array.\n  unsigned Length;\n\n  /// The parameter pack.\n  NamedDecl *Pack = nullptr;\n\n  /// Create an expression that computes the length of\n  /// the given parameter pack.\n  SizeOfPackExpr(QualType SizeType, SourceLocation OperatorLoc, NamedDecl *Pack,\n                 SourceLocation PackLoc, SourceLocation RParenLoc,\n                 Optional<unsigned> Length,\n                 ArrayRef<TemplateArgument> PartialArgs)\n      : Expr(SizeOfPackExprClass, SizeType, VK_RValue, OK_Ordinary),\n        OperatorLoc(OperatorLoc), PackLoc(PackLoc), RParenLoc(RParenLoc),\n        Length(Length ? *Length : PartialArgs.size()), Pack(Pack) {\n    assert((!Length || PartialArgs.empty()) &&\n           \"have partial args for non-dependent sizeof... expression\");\n    auto *Args = getTrailingObjects<TemplateArgument>();\n    std::uninitialized_copy(PartialArgs.begin(), PartialArgs.end(), Args);\n    setDependence(Length ? ExprDependence::None\n                         : ExprDependence::ValueInstantiation);\n  }\n\n  /// Create an empty expression.\n  SizeOfPackExpr(EmptyShell Empty, unsigned NumPartialArgs)\n      : Expr(SizeOfPackExprClass, Empty), Length(NumPartialArgs) {}\n\npublic:\n  static SizeOfPackExpr *Create(ASTContext &Context, SourceLocation OperatorLoc,\n                                NamedDecl *Pack, SourceLocation PackLoc,\n                                SourceLocation RParenLoc,\n                                Optional<unsigned> Length = None,\n                                ArrayRef<TemplateArgument> PartialArgs = None);\n  static SizeOfPackExpr *CreateDeserialized(ASTContext &Context,\n                                            unsigned NumPartialArgs);\n\n  /// Determine the location of the 'sizeof' keyword.\n  SourceLocation getOperatorLoc() const { return OperatorLoc; }\n\n  /// Determine the location of the parameter pack.\n  SourceLocation getPackLoc() const { return PackLoc; }\n\n  /// Determine the location of the right parenthesis.\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n\n  /// Retrieve the parameter pack.\n  NamedDecl *getPack() const { return Pack; }\n\n  /// Retrieve the length of the parameter pack.\n  ///\n  /// This routine may only be invoked when the expression is not\n  /// value-dependent.\n  unsigned getPackLength() const {\n    assert(!isValueDependent() &&\n           \"Cannot get the length of a value-dependent pack size expression\");\n    return Length;\n  }\n\n  /// Determine whether this represents a partially-substituted sizeof...\n  /// expression, such as is produced for:\n  ///\n  ///   template<typename ...Ts> using X = int[sizeof...(Ts)];\n  ///   template<typename ...Us> void f(X<Us..., 1, 2, 3, Us...>);\n  bool isPartiallySubstituted() const {\n    return isValueDependent() && Length;\n  }\n\n  /// Get\n  ArrayRef<TemplateArgument> getPartialArguments() const {\n    assert(isPartiallySubstituted());\n    const auto *Args = getTrailingObjects<TemplateArgument>();\n    return llvm::makeArrayRef(Args, Args + Length);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return OperatorLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == SizeOfPackExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Represents a reference to a non-type template parameter\n/// that has been substituted with a template argument.\nclass SubstNonTypeTemplateParmExpr : public Expr {\n  friend class ASTReader;\n  friend class ASTStmtReader;\n\n  /// The replaced parameter and a flag indicating if it was a reference\n  /// parameter. For class NTTPs, we can't determine that based on the value\n  /// category alone.\n  llvm::PointerIntPair<NonTypeTemplateParmDecl*, 1, bool> ParamAndRef;\n\n  /// The replacement expression.\n  Stmt *Replacement;\n\n  explicit SubstNonTypeTemplateParmExpr(EmptyShell Empty)\n      : Expr(SubstNonTypeTemplateParmExprClass, Empty) {}\n\npublic:\n  SubstNonTypeTemplateParmExpr(QualType Ty, ExprValueKind ValueKind,\n                               SourceLocation Loc,\n                               NonTypeTemplateParmDecl *Param, bool RefParam,\n                               Expr *Replacement)\n      : Expr(SubstNonTypeTemplateParmExprClass, Ty, ValueKind, OK_Ordinary),\n        ParamAndRef(Param, RefParam), Replacement(Replacement) {\n    SubstNonTypeTemplateParmExprBits.NameLoc = Loc;\n    setDependence(computeDependence(this));\n  }\n\n  SourceLocation getNameLoc() const {\n    return SubstNonTypeTemplateParmExprBits.NameLoc;\n  }\n  SourceLocation getBeginLoc() const { return getNameLoc(); }\n  SourceLocation getEndLoc() const { return getNameLoc(); }\n\n  Expr *getReplacement() const { return cast<Expr>(Replacement); }\n\n  NonTypeTemplateParmDecl *getParameter() const {\n    return ParamAndRef.getPointer();\n  }\n\n  bool isReferenceParameter() const { return ParamAndRef.getInt(); }\n\n  /// Determine the substituted type of the template parameter.\n  QualType getParameterType(const ASTContext &Ctx) const;\n\n  static bool classof(const Stmt *s) {\n    return s->getStmtClass() == SubstNonTypeTemplateParmExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Replacement, &Replacement + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Replacement, &Replacement + 1);\n  }\n};\n\n/// Represents a reference to a non-type template parameter pack that\n/// has been substituted with a non-template argument pack.\n///\n/// When a pack expansion in the source code contains multiple parameter packs\n/// and those parameter packs correspond to different levels of template\n/// parameter lists, this node is used to represent a non-type template\n/// parameter pack from an outer level, which has already had its argument pack\n/// substituted but that still lives within a pack expansion that itself\n/// could not be instantiated. When actually performing a substitution into\n/// that pack expansion (e.g., when all template parameters have corresponding\n/// arguments), this type will be replaced with the appropriate underlying\n/// expression at the current pack substitution index.\nclass SubstNonTypeTemplateParmPackExpr : public Expr {\n  friend class ASTReader;\n  friend class ASTStmtReader;\n\n  /// The non-type template parameter pack itself.\n  NonTypeTemplateParmDecl *Param;\n\n  /// A pointer to the set of template arguments that this\n  /// parameter pack is instantiated with.\n  const TemplateArgument *Arguments;\n\n  /// The number of template arguments in \\c Arguments.\n  unsigned NumArguments;\n\n  /// The location of the non-type template parameter pack reference.\n  SourceLocation NameLoc;\n\n  explicit SubstNonTypeTemplateParmPackExpr(EmptyShell Empty)\n      : Expr(SubstNonTypeTemplateParmPackExprClass, Empty) {}\n\npublic:\n  SubstNonTypeTemplateParmPackExpr(QualType T,\n                                   ExprValueKind ValueKind,\n                                   NonTypeTemplateParmDecl *Param,\n                                   SourceLocation NameLoc,\n                                   const TemplateArgument &ArgPack);\n\n  /// Retrieve the non-type template parameter pack being substituted.\n  NonTypeTemplateParmDecl *getParameterPack() const { return Param; }\n\n  /// Retrieve the location of the parameter pack name.\n  SourceLocation getParameterPackLocation() const { return NameLoc; }\n\n  /// Retrieve the template argument pack containing the substituted\n  /// template arguments.\n  TemplateArgument getArgumentPack() const;\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return NameLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return NameLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == SubstNonTypeTemplateParmPackExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Represents a reference to a function parameter pack or init-capture pack\n/// that has been substituted but not yet expanded.\n///\n/// When a pack expansion contains multiple parameter packs at different levels,\n/// this node is used to represent a function parameter pack at an outer level\n/// which we have already substituted to refer to expanded parameters, but where\n/// the containing pack expansion cannot yet be expanded.\n///\n/// \\code\n/// template<typename...Ts> struct S {\n///   template<typename...Us> auto f(Ts ...ts) -> decltype(g(Us(ts)...));\n/// };\n/// template struct S<int, int>;\n/// \\endcode\nclass FunctionParmPackExpr final\n    : public Expr,\n      private llvm::TrailingObjects<FunctionParmPackExpr, VarDecl *> {\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  /// The function parameter pack which was referenced.\n  VarDecl *ParamPack;\n\n  /// The location of the function parameter pack reference.\n  SourceLocation NameLoc;\n\n  /// The number of expansions of this pack.\n  unsigned NumParameters;\n\n  FunctionParmPackExpr(QualType T, VarDecl *ParamPack,\n                       SourceLocation NameLoc, unsigned NumParams,\n                       VarDecl *const *Params);\n\npublic:\n  static FunctionParmPackExpr *Create(const ASTContext &Context, QualType T,\n                                      VarDecl *ParamPack,\n                                      SourceLocation NameLoc,\n                                      ArrayRef<VarDecl *> Params);\n  static FunctionParmPackExpr *CreateEmpty(const ASTContext &Context,\n                                           unsigned NumParams);\n\n  /// Get the parameter pack which this expression refers to.\n  VarDecl *getParameterPack() const { return ParamPack; }\n\n  /// Get the location of the parameter pack.\n  SourceLocation getParameterPackLocation() const { return NameLoc; }\n\n  /// Iterators over the parameters which the parameter pack expanded\n  /// into.\n  using iterator = VarDecl * const *;\n  iterator begin() const { return getTrailingObjects<VarDecl *>(); }\n  iterator end() const { return begin() + NumParameters; }\n\n  /// Get the number of parameters in this parameter pack.\n  unsigned getNumExpansions() const { return NumParameters; }\n\n  /// Get an expansion of the parameter pack by index.\n  VarDecl *getExpansion(unsigned I) const { return begin()[I]; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return NameLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return NameLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == FunctionParmPackExprClass;\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Represents a prvalue temporary that is written into memory so that\n/// a reference can bind to it.\n///\n/// Prvalue expressions are materialized when they need to have an address\n/// in memory for a reference to bind to. This happens when binding a\n/// reference to the result of a conversion, e.g.,\n///\n/// \\code\n/// const int &r = 1.0;\n/// \\endcode\n///\n/// Here, 1.0 is implicitly converted to an \\c int. That resulting \\c int is\n/// then materialized via a \\c MaterializeTemporaryExpr, and the reference\n/// binds to the temporary. \\c MaterializeTemporaryExprs are always glvalues\n/// (either an lvalue or an xvalue, depending on the kind of reference binding\n/// to it), maintaining the invariant that references always bind to glvalues.\n///\n/// Reference binding and copy-elision can both extend the lifetime of a\n/// temporary. When either happens, the expression will also track the\n/// declaration which is responsible for the lifetime extension.\nclass MaterializeTemporaryExpr : public Expr {\nprivate:\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  llvm::PointerUnion<Stmt *, LifetimeExtendedTemporaryDecl *> State;\n\npublic:\n  MaterializeTemporaryExpr(QualType T, Expr *Temporary,\n                           bool BoundToLvalueReference,\n                           LifetimeExtendedTemporaryDecl *MTD = nullptr);\n\n  MaterializeTemporaryExpr(EmptyShell Empty)\n      : Expr(MaterializeTemporaryExprClass, Empty) {}\n\n  /// Retrieve the temporary-generating subexpression whose value will\n  /// be materialized into a glvalue.\n  Expr *getSubExpr() const {\n    return cast<Expr>(\n        State.is<Stmt *>()\n            ? State.get<Stmt *>()\n            : State.get<LifetimeExtendedTemporaryDecl *>()->getTemporaryExpr());\n  }\n\n  /// Retrieve the storage duration for the materialized temporary.\n  StorageDuration getStorageDuration() const {\n    return State.is<Stmt *>() ? SD_FullExpression\n                              : State.get<LifetimeExtendedTemporaryDecl *>()\n                                    ->getStorageDuration();\n  }\n\n  /// Get the storage for the constant value of a materialized temporary\n  /// of static storage duration.\n  APValue *getOrCreateValue(bool MayCreate) const {\n    assert(State.is<LifetimeExtendedTemporaryDecl *>() &&\n           \"the temporary has not been lifetime extended\");\n    return State.get<LifetimeExtendedTemporaryDecl *>()->getOrCreateValue(\n        MayCreate);\n  }\n\n  LifetimeExtendedTemporaryDecl *getLifetimeExtendedTemporaryDecl() {\n    return State.dyn_cast<LifetimeExtendedTemporaryDecl *>();\n  }\n  const LifetimeExtendedTemporaryDecl *\n  getLifetimeExtendedTemporaryDecl() const {\n    return State.dyn_cast<LifetimeExtendedTemporaryDecl *>();\n  }\n\n  /// Get the declaration which triggered the lifetime-extension of this\n  /// temporary, if any.\n  ValueDecl *getExtendingDecl() {\n    return State.is<Stmt *>() ? nullptr\n                              : State.get<LifetimeExtendedTemporaryDecl *>()\n                                    ->getExtendingDecl();\n  }\n  const ValueDecl *getExtendingDecl() const {\n    return const_cast<MaterializeTemporaryExpr *>(this)->getExtendingDecl();\n  }\n\n  void setExtendingDecl(ValueDecl *ExtendedBy, unsigned ManglingNumber);\n\n  unsigned getManglingNumber() const {\n    return State.is<Stmt *>() ? 0\n                              : State.get<LifetimeExtendedTemporaryDecl *>()\n                                    ->getManglingNumber();\n  }\n\n  /// Determine whether this materialized temporary is bound to an\n  /// lvalue reference; otherwise, it's bound to an rvalue reference.\n  bool isBoundToLvalueReference() const {\n    return getValueKind() == VK_LValue;\n  }\n\n  /// Determine whether this temporary object is usable in constant\n  /// expressions, as specified in C++20 [expr.const]p4.\n  bool isUsableInConstantExpressions(const ASTContext &Context) const;\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getSubExpr()->getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getSubExpr()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == MaterializeTemporaryExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return State.is<Stmt *>()\n               ? child_range(State.getAddrOfPtr1(), State.getAddrOfPtr1() + 1)\n               : State.get<LifetimeExtendedTemporaryDecl *>()->childrenExpr();\n  }\n\n  const_child_range children() const {\n    return State.is<Stmt *>()\n               ? const_child_range(State.getAddrOfPtr1(),\n                                   State.getAddrOfPtr1() + 1)\n               : const_cast<const LifetimeExtendedTemporaryDecl *>(\n                     State.get<LifetimeExtendedTemporaryDecl *>())\n                     ->childrenExpr();\n  }\n};\n\n/// Represents a folding of a pack over an operator.\n///\n/// This expression is always dependent and represents a pack expansion of the\n/// forms:\n///\n///    ( expr op ... )\n///    ( ... op expr )\n///    ( expr op ... op expr )\nclass CXXFoldExpr : public Expr {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  enum SubExpr { Callee, LHS, RHS, Count };\n\n  SourceLocation LParenLoc;\n  SourceLocation EllipsisLoc;\n  SourceLocation RParenLoc;\n  // When 0, the number of expansions is not known. Otherwise, this is one more\n  // than the number of expansions.\n  unsigned NumExpansions;\n  Stmt *SubExprs[SubExpr::Count];\n  BinaryOperatorKind Opcode;\n\npublic:\n  CXXFoldExpr(QualType T, UnresolvedLookupExpr *Callee,\n              SourceLocation LParenLoc, Expr *LHS, BinaryOperatorKind Opcode,\n              SourceLocation EllipsisLoc, Expr *RHS, SourceLocation RParenLoc,\n              Optional<unsigned> NumExpansions)\n      : Expr(CXXFoldExprClass, T, VK_RValue, OK_Ordinary), LParenLoc(LParenLoc),\n        EllipsisLoc(EllipsisLoc), RParenLoc(RParenLoc),\n        NumExpansions(NumExpansions ? *NumExpansions + 1 : 0), Opcode(Opcode) {\n    SubExprs[SubExpr::Callee] = Callee;\n    SubExprs[SubExpr::LHS] = LHS;\n    SubExprs[SubExpr::RHS] = RHS;\n    setDependence(computeDependence(this));\n  }\n\n  CXXFoldExpr(EmptyShell Empty) : Expr(CXXFoldExprClass, Empty) {}\n\n  UnresolvedLookupExpr *getCallee() const {\n    return static_cast<UnresolvedLookupExpr *>(SubExprs[SubExpr::Callee]);\n  }\n  Expr *getLHS() const { return static_cast<Expr*>(SubExprs[SubExpr::LHS]); }\n  Expr *getRHS() const { return static_cast<Expr*>(SubExprs[SubExpr::RHS]); }\n\n  /// Does this produce a right-associated sequence of operators?\n  bool isRightFold() const {\n    return getLHS() && getLHS()->containsUnexpandedParameterPack();\n  }\n\n  /// Does this produce a left-associated sequence of operators?\n  bool isLeftFold() const { return !isRightFold(); }\n\n  /// Get the pattern, that is, the operand that contains an unexpanded pack.\n  Expr *getPattern() const { return isLeftFold() ? getRHS() : getLHS(); }\n\n  /// Get the operand that doesn't contain a pack, for a binary fold.\n  Expr *getInit() const { return isLeftFold() ? getLHS() : getRHS(); }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  SourceLocation getEllipsisLoc() const { return EllipsisLoc; }\n  BinaryOperatorKind getOperator() const { return Opcode; }\n\n  Optional<unsigned> getNumExpansions() const {\n    if (NumExpansions)\n      return NumExpansions - 1;\n    return None;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    if (LParenLoc.isValid())\n      return LParenLoc;\n    if (isLeftFold())\n      return getEllipsisLoc();\n    return getLHS()->getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    if (RParenLoc.isValid())\n      return RParenLoc;\n    if (isRightFold())\n      return getEllipsisLoc();\n    return getRHS()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXFoldExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(SubExprs, SubExprs + SubExpr::Count);\n  }\n\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + SubExpr::Count);\n  }\n};\n\n/// Represents an expression that might suspend coroutine execution;\n/// either a co_await or co_yield expression.\n///\n/// Evaluation of this expression first evaluates its 'ready' expression. If\n/// that returns 'false':\n///  -- execution of the coroutine is suspended\n///  -- the 'suspend' expression is evaluated\n///     -- if the 'suspend' expression returns 'false', the coroutine is\n///        resumed\n///     -- otherwise, control passes back to the resumer.\n/// If the coroutine is not suspended, or when it is resumed, the 'resume'\n/// expression is evaluated, and its result is the result of the overall\n/// expression.\nclass CoroutineSuspendExpr : public Expr {\n  friend class ASTStmtReader;\n\n  SourceLocation KeywordLoc;\n\n  enum SubExpr { Common, Ready, Suspend, Resume, Count };\n\n  Stmt *SubExprs[SubExpr::Count];\n  OpaqueValueExpr *OpaqueValue = nullptr;\n\npublic:\n  CoroutineSuspendExpr(StmtClass SC, SourceLocation KeywordLoc, Expr *Common,\n                       Expr *Ready, Expr *Suspend, Expr *Resume,\n                       OpaqueValueExpr *OpaqueValue)\n      : Expr(SC, Resume->getType(), Resume->getValueKind(),\n             Resume->getObjectKind()),\n        KeywordLoc(KeywordLoc), OpaqueValue(OpaqueValue) {\n    SubExprs[SubExpr::Common] = Common;\n    SubExprs[SubExpr::Ready] = Ready;\n    SubExprs[SubExpr::Suspend] = Suspend;\n    SubExprs[SubExpr::Resume] = Resume;\n    setDependence(computeDependence(this));\n  }\n\n  CoroutineSuspendExpr(StmtClass SC, SourceLocation KeywordLoc, QualType Ty,\n                       Expr *Common)\n      : Expr(SC, Ty, VK_RValue, OK_Ordinary), KeywordLoc(KeywordLoc) {\n    assert(Common->isTypeDependent() && Ty->isDependentType() &&\n           \"wrong constructor for non-dependent co_await/co_yield expression\");\n    SubExprs[SubExpr::Common] = Common;\n    SubExprs[SubExpr::Ready] = nullptr;\n    SubExprs[SubExpr::Suspend] = nullptr;\n    SubExprs[SubExpr::Resume] = nullptr;\n    setDependence(computeDependence(this));\n  }\n\n  CoroutineSuspendExpr(StmtClass SC, EmptyShell Empty) : Expr(SC, Empty) {\n    SubExprs[SubExpr::Common] = nullptr;\n    SubExprs[SubExpr::Ready] = nullptr;\n    SubExprs[SubExpr::Suspend] = nullptr;\n    SubExprs[SubExpr::Resume] = nullptr;\n  }\n\n  SourceLocation getKeywordLoc() const { return KeywordLoc; }\n\n  Expr *getCommonExpr() const {\n    return static_cast<Expr*>(SubExprs[SubExpr::Common]);\n  }\n\n  /// getOpaqueValue - Return the opaque value placeholder.\n  OpaqueValueExpr *getOpaqueValue() const { return OpaqueValue; }\n\n  Expr *getReadyExpr() const {\n    return static_cast<Expr*>(SubExprs[SubExpr::Ready]);\n  }\n\n  Expr *getSuspendExpr() const {\n    return static_cast<Expr*>(SubExprs[SubExpr::Suspend]);\n  }\n\n  Expr *getResumeExpr() const {\n    return static_cast<Expr*>(SubExprs[SubExpr::Resume]);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return KeywordLoc; }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getCommonExpr()->getEndLoc();\n  }\n\n  child_range children() {\n    return child_range(SubExprs, SubExprs + SubExpr::Count);\n  }\n\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + SubExpr::Count);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CoawaitExprClass ||\n           T->getStmtClass() == CoyieldExprClass;\n  }\n};\n\n/// Represents a 'co_await' expression.\nclass CoawaitExpr : public CoroutineSuspendExpr {\n  friend class ASTStmtReader;\n\npublic:\n  CoawaitExpr(SourceLocation CoawaitLoc, Expr *Operand, Expr *Ready,\n              Expr *Suspend, Expr *Resume, OpaqueValueExpr *OpaqueValue,\n              bool IsImplicit = false)\n      : CoroutineSuspendExpr(CoawaitExprClass, CoawaitLoc, Operand, Ready,\n                             Suspend, Resume, OpaqueValue) {\n    CoawaitBits.IsImplicit = IsImplicit;\n  }\n\n  CoawaitExpr(SourceLocation CoawaitLoc, QualType Ty, Expr *Operand,\n              bool IsImplicit = false)\n      : CoroutineSuspendExpr(CoawaitExprClass, CoawaitLoc, Ty, Operand) {\n    CoawaitBits.IsImplicit = IsImplicit;\n  }\n\n  CoawaitExpr(EmptyShell Empty)\n      : CoroutineSuspendExpr(CoawaitExprClass, Empty) {}\n\n  Expr *getOperand() const {\n    // FIXME: Dig out the actual operand or store it.\n    return getCommonExpr();\n  }\n\n  bool isImplicit() const { return CoawaitBits.IsImplicit; }\n  void setIsImplicit(bool value = true) { CoawaitBits.IsImplicit = value; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CoawaitExprClass;\n  }\n};\n\n/// Represents a 'co_await' expression while the type of the promise\n/// is dependent.\nclass DependentCoawaitExpr : public Expr {\n  friend class ASTStmtReader;\n\n  SourceLocation KeywordLoc;\n  Stmt *SubExprs[2];\n\npublic:\n  DependentCoawaitExpr(SourceLocation KeywordLoc, QualType Ty, Expr *Op,\n                       UnresolvedLookupExpr *OpCoawait)\n      : Expr(DependentCoawaitExprClass, Ty, VK_RValue, OK_Ordinary),\n        KeywordLoc(KeywordLoc) {\n    // NOTE: A co_await expression is dependent on the coroutines promise\n    // type and may be dependent even when the `Op` expression is not.\n    assert(Ty->isDependentType() &&\n           \"wrong constructor for non-dependent co_await/co_yield expression\");\n    SubExprs[0] = Op;\n    SubExprs[1] = OpCoawait;\n    setDependence(computeDependence(this));\n  }\n\n  DependentCoawaitExpr(EmptyShell Empty)\n      : Expr(DependentCoawaitExprClass, Empty) {}\n\n  Expr *getOperand() const { return cast<Expr>(SubExprs[0]); }\n\n  UnresolvedLookupExpr *getOperatorCoawaitLookup() const {\n    return cast<UnresolvedLookupExpr>(SubExprs[1]);\n  }\n\n  SourceLocation getKeywordLoc() const { return KeywordLoc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return KeywordLoc; }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getOperand()->getEndLoc();\n  }\n\n  child_range children() { return child_range(SubExprs, SubExprs + 2); }\n\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + 2);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == DependentCoawaitExprClass;\n  }\n};\n\n/// Represents a 'co_yield' expression.\nclass CoyieldExpr : public CoroutineSuspendExpr {\n  friend class ASTStmtReader;\n\npublic:\n  CoyieldExpr(SourceLocation CoyieldLoc, Expr *Operand, Expr *Ready,\n              Expr *Suspend, Expr *Resume, OpaqueValueExpr *OpaqueValue)\n      : CoroutineSuspendExpr(CoyieldExprClass, CoyieldLoc, Operand, Ready,\n                             Suspend, Resume, OpaqueValue) {}\n  CoyieldExpr(SourceLocation CoyieldLoc, QualType Ty, Expr *Operand)\n      : CoroutineSuspendExpr(CoyieldExprClass, CoyieldLoc, Ty, Operand) {}\n  CoyieldExpr(EmptyShell Empty)\n      : CoroutineSuspendExpr(CoyieldExprClass, Empty) {}\n\n  Expr *getOperand() const {\n    // FIXME: Dig out the actual operand or store it.\n    return getCommonExpr();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CoyieldExprClass;\n  }\n};\n\n/// Represents a C++2a __builtin_bit_cast(T, v) expression. Used to implement\n/// std::bit_cast. These can sometimes be evaluated as part of a constant\n/// expression, but otherwise CodeGen to a simple memcpy in general.\nclass BuiltinBitCastExpr final\n    : public ExplicitCastExpr,\n      private llvm::TrailingObjects<BuiltinBitCastExpr, CXXBaseSpecifier *> {\n  friend class ASTStmtReader;\n  friend class CastExpr;\n  friend TrailingObjects;\n\n  SourceLocation KWLoc;\n  SourceLocation RParenLoc;\n\npublic:\n  BuiltinBitCastExpr(QualType T, ExprValueKind VK, CastKind CK, Expr *SrcExpr,\n                     TypeSourceInfo *DstType, SourceLocation KWLoc,\n                     SourceLocation RParenLoc)\n      : ExplicitCastExpr(BuiltinBitCastExprClass, T, VK, CK, SrcExpr, 0, false,\n                         DstType),\n        KWLoc(KWLoc), RParenLoc(RParenLoc) {}\n  BuiltinBitCastExpr(EmptyShell Empty)\n      : ExplicitCastExpr(BuiltinBitCastExprClass, Empty, 0, false) {}\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return KWLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == BuiltinBitCastExprClass;\n  }\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_EXPRCXX_H\n"}, "11": {"id": 11, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprObjC.h", "content": "//===- ExprObjC.h - Classes for representing ObjC expressions ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the ExprObjC interface and subclasses.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_EXPROBJC_H\n#define LLVM_CLANG_AST_EXPROBJC_H\n\n#include \"clang/AST/ComputeDependence.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/DependenceFlags.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/OperationKinds.h\"\n#include \"clang/AST/SelectorLocationsKind.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include \"llvm/Support/VersionTuple.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n\nnamespace clang {\n\nclass ASTContext;\nclass CXXBaseSpecifier;\n\n/// ObjCStringLiteral, used for Objective-C string literals\n/// i.e. @\"foo\".\nclass ObjCStringLiteral : public Expr {\n  Stmt *String;\n  SourceLocation AtLoc;\n\npublic:\n  ObjCStringLiteral(StringLiteral *SL, QualType T, SourceLocation L)\n      : Expr(ObjCStringLiteralClass, T, VK_RValue, OK_Ordinary), String(SL),\n        AtLoc(L) {\n    setDependence(ExprDependence::None);\n  }\n  explicit ObjCStringLiteral(EmptyShell Empty)\n      : Expr(ObjCStringLiteralClass, Empty) {}\n\n  StringLiteral *getString() { return cast<StringLiteral>(String); }\n  const StringLiteral *getString() const { return cast<StringLiteral>(String); }\n  void setString(StringLiteral *S) { String = S; }\n\n  SourceLocation getAtLoc() const { return AtLoc; }\n  void setAtLoc(SourceLocation L) { AtLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AtLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return String->getEndLoc(); }\n\n  // Iterators\n  child_range children() { return child_range(&String, &String+1); }\n\n  const_child_range children() const {\n    return const_child_range(&String, &String + 1);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCStringLiteralClass;\n  }\n};\n\n/// ObjCBoolLiteralExpr - Objective-C Boolean Literal.\nclass ObjCBoolLiteralExpr : public Expr {\n  bool Value;\n  SourceLocation Loc;\n\npublic:\n  ObjCBoolLiteralExpr(bool val, QualType Ty, SourceLocation l)\n      : Expr(ObjCBoolLiteralExprClass, Ty, VK_RValue, OK_Ordinary), Value(val),\n        Loc(l) {\n    setDependence(ExprDependence::None);\n  }\n  explicit ObjCBoolLiteralExpr(EmptyShell Empty)\n      : Expr(ObjCBoolLiteralExprClass, Empty) {}\n\n  bool getValue() const { return Value; }\n  void setValue(bool V) { Value = V; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Loc; }\n\n  SourceLocation getLocation() const { return Loc; }\n  void setLocation(SourceLocation L) { Loc = L; }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCBoolLiteralExprClass;\n  }\n};\n\n/// ObjCBoxedExpr - used for generalized expression boxing.\n/// as in: @(strdup(\"hello world\")), @(random()) or @(view.frame)\n/// Also used for boxing non-parenthesized numeric literals;\n/// as in: @42 or \\@true (c++/objc++) or \\@__objc_yes (c/objc).\nclass ObjCBoxedExpr : public Expr {\n  Stmt *SubExpr;\n  ObjCMethodDecl *BoxingMethod;\n  SourceRange Range;\n\npublic:\n  friend class ASTStmtReader;\n\n  ObjCBoxedExpr(Expr *E, QualType T, ObjCMethodDecl *method, SourceRange R)\n      : Expr(ObjCBoxedExprClass, T, VK_RValue, OK_Ordinary), SubExpr(E),\n        BoxingMethod(method), Range(R) {\n    setDependence(computeDependence(this));\n  }\n  explicit ObjCBoxedExpr(EmptyShell Empty)\n      : Expr(ObjCBoxedExprClass, Empty) {}\n\n  Expr *getSubExpr() { return cast<Expr>(SubExpr); }\n  const Expr *getSubExpr() const { return cast<Expr>(SubExpr); }\n\n  ObjCMethodDecl *getBoxingMethod() const {\n    return BoxingMethod;\n  }\n\n  // Indicates whether this boxed expression can be emitted as a compile-time\n  // constant.\n  bool isExpressibleAsConstantInitializer() const {\n    return !BoxingMethod && SubExpr;\n  }\n\n  SourceLocation getAtLoc() const { return Range.getBegin(); }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n\n  SourceRange getSourceRange() const LLVM_READONLY {\n    return Range;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&SubExpr, &SubExpr+1); }\n\n  const_child_range children() const {\n    return const_child_range(&SubExpr, &SubExpr + 1);\n  }\n\n  using const_arg_iterator = ConstExprIterator;\n\n  const_arg_iterator arg_begin() const {\n    return reinterpret_cast<Stmt const * const*>(&SubExpr);\n  }\n\n  const_arg_iterator arg_end() const {\n    return reinterpret_cast<Stmt const * const*>(&SubExpr + 1);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCBoxedExprClass;\n  }\n};\n\n/// ObjCArrayLiteral - used for objective-c array containers; as in:\n/// @[@\"Hello\", NSApp, [NSNumber numberWithInt:42]];\nclass ObjCArrayLiteral final\n    : public Expr,\n      private llvm::TrailingObjects<ObjCArrayLiteral, Expr *> {\n  unsigned NumElements;\n  SourceRange Range;\n  ObjCMethodDecl *ArrayWithObjectsMethod;\n\n  ObjCArrayLiteral(ArrayRef<Expr *> Elements,\n                   QualType T, ObjCMethodDecl * Method,\n                   SourceRange SR);\n\n  explicit ObjCArrayLiteral(EmptyShell Empty, unsigned NumElements)\n      : Expr(ObjCArrayLiteralClass, Empty), NumElements(NumElements) {}\n\npublic:\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  static ObjCArrayLiteral *Create(const ASTContext &C,\n                                  ArrayRef<Expr *> Elements,\n                                  QualType T, ObjCMethodDecl * Method,\n                                  SourceRange SR);\n\n  static ObjCArrayLiteral *CreateEmpty(const ASTContext &C,\n                                       unsigned NumElements);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n  SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n\n  /// Retrieve elements of array of literals.\n  Expr **getElements() { return getTrailingObjects<Expr *>(); }\n\n  /// Retrieve elements of array of literals.\n  const Expr * const *getElements() const {\n    return getTrailingObjects<Expr *>();\n  }\n\n  /// getNumElements - Return number of elements of objective-c array literal.\n  unsigned getNumElements() const { return NumElements; }\n\n  /// getElement - Return the Element at the specified index.\n  Expr *getElement(unsigned Index) {\n    assert((Index < NumElements) && \"Arg access out of range!\");\n    return getElements()[Index];\n  }\n  const Expr *getElement(unsigned Index) const {\n    assert((Index < NumElements) && \"Arg access out of range!\");\n    return getElements()[Index];\n  }\n\n  ObjCMethodDecl *getArrayWithObjectsMethod() const {\n    return ArrayWithObjectsMethod;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(getElements()),\n                       reinterpret_cast<Stmt **>(getElements()) + NumElements);\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<ObjCArrayLiteral *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  static bool classof(const Stmt *T) {\n      return T->getStmtClass() == ObjCArrayLiteralClass;\n  }\n};\n\n/// An element in an Objective-C dictionary literal.\n///\nstruct ObjCDictionaryElement {\n  /// The key for the dictionary element.\n  Expr *Key;\n\n  /// The value of the dictionary element.\n  Expr *Value;\n\n  /// The location of the ellipsis, if this is a pack expansion.\n  SourceLocation EllipsisLoc;\n\n  /// The number of elements this pack expansion will expand to, if\n  /// this is a pack expansion and is known.\n  Optional<unsigned> NumExpansions;\n\n  /// Determines whether this dictionary element is a pack expansion.\n  bool isPackExpansion() const { return EllipsisLoc.isValid(); }\n};\n\n} // namespace clang\n\nnamespace clang {\n\n/// Internal struct for storing Key/value pair.\nstruct ObjCDictionaryLiteral_KeyValuePair {\n  Expr *Key;\n  Expr *Value;\n};\n\n/// Internal struct to describes an element that is a pack\n/// expansion, used if any of the elements in the dictionary literal\n/// are pack expansions.\nstruct ObjCDictionaryLiteral_ExpansionData {\n  /// The location of the ellipsis, if this element is a pack\n  /// expansion.\n  SourceLocation EllipsisLoc;\n\n  /// If non-zero, the number of elements that this pack\n  /// expansion will expand to (+1).\n  unsigned NumExpansionsPlusOne;\n};\n\n/// ObjCDictionaryLiteral - AST node to represent objective-c dictionary\n/// literals; as in:  @{@\"name\" : NSUserName(), @\"date\" : [NSDate date] };\nclass ObjCDictionaryLiteral final\n    : public Expr,\n      private llvm::TrailingObjects<ObjCDictionaryLiteral,\n                                    ObjCDictionaryLiteral_KeyValuePair,\n                                    ObjCDictionaryLiteral_ExpansionData> {\n  /// The number of elements in this dictionary literal.\n  unsigned NumElements : 31;\n\n  /// Determine whether this dictionary literal has any pack expansions.\n  ///\n  /// If the dictionary literal has pack expansions, then there will\n  /// be an array of pack expansion data following the array of\n  /// key/value pairs, which provide the locations of the ellipses (if\n  /// any) and number of elements in the expansion (if known). If\n  /// there are no pack expansions, we optimize away this storage.\n  unsigned HasPackExpansions : 1;\n\n  SourceRange Range;\n  ObjCMethodDecl *DictWithObjectsMethod;\n\n  using KeyValuePair = ObjCDictionaryLiteral_KeyValuePair;\n  using ExpansionData = ObjCDictionaryLiteral_ExpansionData;\n\n  ObjCDictionaryLiteral(ArrayRef<ObjCDictionaryElement> VK,\n                        bool HasPackExpansions,\n                        QualType T, ObjCMethodDecl *method,\n                        SourceRange SR);\n\n  explicit ObjCDictionaryLiteral(EmptyShell Empty, unsigned NumElements,\n                                 bool HasPackExpansions)\n      : Expr(ObjCDictionaryLiteralClass, Empty), NumElements(NumElements),\n        HasPackExpansions(HasPackExpansions) {}\n\n  size_t numTrailingObjects(OverloadToken<KeyValuePair>) const {\n    return NumElements;\n  }\n\npublic:\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  static ObjCDictionaryLiteral *Create(const ASTContext &C,\n                                       ArrayRef<ObjCDictionaryElement> VK,\n                                       bool HasPackExpansions,\n                                       QualType T, ObjCMethodDecl *method,\n                                       SourceRange SR);\n\n  static ObjCDictionaryLiteral *CreateEmpty(const ASTContext &C,\n                                            unsigned NumElements,\n                                            bool HasPackExpansions);\n\n  /// getNumElements - Return number of elements of objective-c dictionary\n  /// literal.\n  unsigned getNumElements() const { return NumElements; }\n\n  ObjCDictionaryElement getKeyValueElement(unsigned Index) const {\n    assert((Index < NumElements) && \"Arg access out of range!\");\n    const KeyValuePair &KV = getTrailingObjects<KeyValuePair>()[Index];\n    ObjCDictionaryElement Result = { KV.Key, KV.Value, SourceLocation(), None };\n    if (HasPackExpansions) {\n      const ExpansionData &Expansion =\n          getTrailingObjects<ExpansionData>()[Index];\n      Result.EllipsisLoc = Expansion.EllipsisLoc;\n      if (Expansion.NumExpansionsPlusOne > 0)\n        Result.NumExpansions = Expansion.NumExpansionsPlusOne - 1;\n    }\n    return Result;\n  }\n\n  ObjCMethodDecl *getDictWithObjectsMethod() const {\n    return DictWithObjectsMethod;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n  SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n\n  // Iterators\n  child_range children() {\n    // Note: we're taking advantage of the layout of the KeyValuePair struct\n    // here. If that struct changes, this code will need to change as well.\n    static_assert(sizeof(KeyValuePair) == sizeof(Stmt *) * 2,\n                  \"KeyValuePair is expected size\");\n    return child_range(\n        reinterpret_cast<Stmt **>(getTrailingObjects<KeyValuePair>()),\n        reinterpret_cast<Stmt **>(getTrailingObjects<KeyValuePair>()) +\n            NumElements * 2);\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<ObjCDictionaryLiteral *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCDictionaryLiteralClass;\n  }\n};\n\n/// ObjCEncodeExpr, used for \\@encode in Objective-C.  \\@encode has the same\n/// type and behavior as StringLiteral except that the string initializer is\n/// obtained from ASTContext with the encoding type as an argument.\nclass ObjCEncodeExpr : public Expr {\n  TypeSourceInfo *EncodedType;\n  SourceLocation AtLoc, RParenLoc;\n\npublic:\n  ObjCEncodeExpr(QualType T, TypeSourceInfo *EncodedType, SourceLocation at,\n                 SourceLocation rp)\n      : Expr(ObjCEncodeExprClass, T, VK_LValue, OK_Ordinary),\n        EncodedType(EncodedType), AtLoc(at), RParenLoc(rp) {\n    setDependence(computeDependence(this));\n  }\n\n  explicit ObjCEncodeExpr(EmptyShell Empty) : Expr(ObjCEncodeExprClass, Empty){}\n\n  SourceLocation getAtLoc() const { return AtLoc; }\n  void setAtLoc(SourceLocation L) { AtLoc = L; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  QualType getEncodedType() const { return EncodedType->getType(); }\n\n  TypeSourceInfo *getEncodedTypeSourceInfo() const { return EncodedType; }\n\n  void setEncodedTypeSourceInfo(TypeSourceInfo *EncType) {\n    EncodedType = EncType;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AtLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCEncodeExprClass;\n  }\n};\n\n/// ObjCSelectorExpr used for \\@selector in Objective-C.\nclass ObjCSelectorExpr : public Expr {\n  Selector SelName;\n  SourceLocation AtLoc, RParenLoc;\n\npublic:\n  ObjCSelectorExpr(QualType T, Selector selInfo, SourceLocation at,\n                   SourceLocation rp)\n      : Expr(ObjCSelectorExprClass, T, VK_RValue, OK_Ordinary),\n        SelName(selInfo), AtLoc(at), RParenLoc(rp) {\n    setDependence(ExprDependence::None);\n  }\n  explicit ObjCSelectorExpr(EmptyShell Empty)\n      : Expr(ObjCSelectorExprClass, Empty) {}\n\n  Selector getSelector() const { return SelName; }\n  void setSelector(Selector S) { SelName = S; }\n\n  SourceLocation getAtLoc() const { return AtLoc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setAtLoc(SourceLocation L) { AtLoc = L; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AtLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  /// getNumArgs - Return the number of actual arguments to this call.\n  unsigned getNumArgs() const { return SelName.getNumArgs(); }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCSelectorExprClass;\n  }\n};\n\n/// ObjCProtocolExpr used for protocol expression in Objective-C.\n///\n/// This is used as: \\@protocol(foo), as in:\n/// \\code\n///   [obj conformsToProtocol:@protocol(foo)]\n/// \\endcode\n///\n/// The return type is \"Protocol*\".\nclass ObjCProtocolExpr : public Expr {\n  ObjCProtocolDecl *TheProtocol;\n  SourceLocation AtLoc, ProtoLoc, RParenLoc;\n\npublic:\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  ObjCProtocolExpr(QualType T, ObjCProtocolDecl *protocol, SourceLocation at,\n                   SourceLocation protoLoc, SourceLocation rp)\n      : Expr(ObjCProtocolExprClass, T, VK_RValue, OK_Ordinary),\n        TheProtocol(protocol), AtLoc(at), ProtoLoc(protoLoc), RParenLoc(rp) {\n    setDependence(ExprDependence::None);\n  }\n  explicit ObjCProtocolExpr(EmptyShell Empty)\n      : Expr(ObjCProtocolExprClass, Empty) {}\n\n  ObjCProtocolDecl *getProtocol() const { return TheProtocol; }\n  void setProtocol(ObjCProtocolDecl *P) { TheProtocol = P; }\n\n  SourceLocation getProtocolIdLoc() const { return ProtoLoc; }\n  SourceLocation getAtLoc() const { return AtLoc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setAtLoc(SourceLocation L) { AtLoc = L; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AtLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCProtocolExprClass;\n  }\n};\n\n/// ObjCIvarRefExpr - A reference to an ObjC instance variable.\nclass ObjCIvarRefExpr : public Expr {\n  ObjCIvarDecl *D;\n  Stmt *Base;\n  SourceLocation Loc;\n\n  /// OpLoc - This is the location of '.' or '->'\n  SourceLocation OpLoc;\n\n  // True if this is \"X->F\", false if this is \"X.F\".\n  bool IsArrow : 1;\n\n  // True if ivar reference has no base (self assumed).\n  bool IsFreeIvar : 1;\n\npublic:\n  ObjCIvarRefExpr(ObjCIvarDecl *d, QualType t, SourceLocation l,\n                  SourceLocation oploc, Expr *base, bool arrow = false,\n                  bool freeIvar = false)\n      : Expr(ObjCIvarRefExprClass, t, VK_LValue,\n             d->isBitField() ? OK_BitField : OK_Ordinary),\n        D(d), Base(base), Loc(l), OpLoc(oploc), IsArrow(arrow),\n        IsFreeIvar(freeIvar) {\n    setDependence(computeDependence(this));\n  }\n\n  explicit ObjCIvarRefExpr(EmptyShell Empty)\n      : Expr(ObjCIvarRefExprClass, Empty) {}\n\n  ObjCIvarDecl *getDecl() { return D; }\n  const ObjCIvarDecl *getDecl() const { return D; }\n  void setDecl(ObjCIvarDecl *d) { D = d; }\n\n  const Expr *getBase() const { return cast<Expr>(Base); }\n  Expr *getBase() { return cast<Expr>(Base); }\n  void setBase(Expr * base) { Base = base; }\n\n  bool isArrow() const { return IsArrow; }\n  bool isFreeIvar() const { return IsFreeIvar; }\n  void setIsArrow(bool A) { IsArrow = A; }\n  void setIsFreeIvar(bool A) { IsFreeIvar = A; }\n\n  SourceLocation getLocation() const { return Loc; }\n  void setLocation(SourceLocation L) { Loc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return isFreeIvar() ? Loc : getBase()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Loc; }\n\n  SourceLocation getOpLoc() const { return OpLoc; }\n  void setOpLoc(SourceLocation L) { OpLoc = L; }\n\n  // Iterators\n  child_range children() { return child_range(&Base, &Base+1); }\n\n  const_child_range children() const {\n    return const_child_range(&Base, &Base + 1);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCIvarRefExprClass;\n  }\n};\n\n/// ObjCPropertyRefExpr - A dot-syntax expression to access an ObjC\n/// property.\nclass ObjCPropertyRefExpr : public Expr {\nprivate:\n  /// If the bool is true, this is an implicit property reference; the\n  /// pointer is an (optional) ObjCMethodDecl and Setter may be set.\n  /// if the bool is false, this is an explicit property reference;\n  /// the pointer is an ObjCPropertyDecl and Setter is always null.\n  llvm::PointerIntPair<NamedDecl *, 1, bool> PropertyOrGetter;\n\n  /// Indicates whether the property reference will result in a message\n  /// to the getter, the setter, or both.\n  /// This applies to both implicit and explicit property references.\n  enum MethodRefFlags {\n    MethodRef_None = 0,\n    MethodRef_Getter = 0x1,\n    MethodRef_Setter = 0x2\n  };\n\n  /// Contains the Setter method pointer and MethodRefFlags bit flags.\n  llvm::PointerIntPair<ObjCMethodDecl *, 2, unsigned> SetterAndMethodRefFlags;\n\n  // FIXME: Maybe we should store the property identifier here,\n  // because it's not rederivable from the other data when there's an\n  // implicit property with no getter (because the 'foo' -> 'setFoo:'\n  // transformation is lossy on the first character).\n\n  SourceLocation IdLoc;\n\n  /// When the receiver in property access is 'super', this is\n  /// the location of the 'super' keyword.  When it's an interface,\n  /// this is that interface.\n  SourceLocation ReceiverLoc;\n  llvm::PointerUnion<Stmt *, const Type *, ObjCInterfaceDecl *> Receiver;\n\npublic:\n  ObjCPropertyRefExpr(ObjCPropertyDecl *PD, QualType t, ExprValueKind VK,\n                      ExprObjectKind OK, SourceLocation l, Expr *base)\n      : Expr(ObjCPropertyRefExprClass, t, VK, OK), PropertyOrGetter(PD, false),\n        IdLoc(l), Receiver(base) {\n    assert(t->isSpecificPlaceholderType(BuiltinType::PseudoObject));\n    setDependence(computeDependence(this));\n  }\n\n  ObjCPropertyRefExpr(ObjCPropertyDecl *PD, QualType t, ExprValueKind VK,\n                      ExprObjectKind OK, SourceLocation l, SourceLocation sl,\n                      QualType st)\n      : Expr(ObjCPropertyRefExprClass, t, VK, OK), PropertyOrGetter(PD, false),\n        IdLoc(l), ReceiverLoc(sl), Receiver(st.getTypePtr()) {\n    assert(t->isSpecificPlaceholderType(BuiltinType::PseudoObject));\n    setDependence(computeDependence(this));\n  }\n\n  ObjCPropertyRefExpr(ObjCMethodDecl *Getter, ObjCMethodDecl *Setter,\n                      QualType T, ExprValueKind VK, ExprObjectKind OK,\n                      SourceLocation IdLoc, Expr *Base)\n      : Expr(ObjCPropertyRefExprClass, T, VK, OK),\n        PropertyOrGetter(Getter, true), SetterAndMethodRefFlags(Setter, 0),\n        IdLoc(IdLoc), Receiver(Base) {\n    assert(T->isSpecificPlaceholderType(BuiltinType::PseudoObject));\n    setDependence(computeDependence(this));\n  }\n\n  ObjCPropertyRefExpr(ObjCMethodDecl *Getter, ObjCMethodDecl *Setter,\n                      QualType T, ExprValueKind VK, ExprObjectKind OK,\n                      SourceLocation IdLoc, SourceLocation SuperLoc,\n                      QualType SuperTy)\n      : Expr(ObjCPropertyRefExprClass, T, VK, OK),\n        PropertyOrGetter(Getter, true), SetterAndMethodRefFlags(Setter, 0),\n        IdLoc(IdLoc), ReceiverLoc(SuperLoc), Receiver(SuperTy.getTypePtr()) {\n    assert(T->isSpecificPlaceholderType(BuiltinType::PseudoObject));\n    setDependence(computeDependence(this));\n  }\n\n  ObjCPropertyRefExpr(ObjCMethodDecl *Getter, ObjCMethodDecl *Setter,\n                      QualType T, ExprValueKind VK, ExprObjectKind OK,\n                      SourceLocation IdLoc, SourceLocation ReceiverLoc,\n                      ObjCInterfaceDecl *Receiver)\n      : Expr(ObjCPropertyRefExprClass, T, VK, OK),\n        PropertyOrGetter(Getter, true), SetterAndMethodRefFlags(Setter, 0),\n        IdLoc(IdLoc), ReceiverLoc(ReceiverLoc), Receiver(Receiver) {\n    assert(T->isSpecificPlaceholderType(BuiltinType::PseudoObject));\n    setDependence(computeDependence(this));\n  }\n\n  explicit ObjCPropertyRefExpr(EmptyShell Empty)\n      : Expr(ObjCPropertyRefExprClass, Empty) {}\n\n  bool isImplicitProperty() const { return PropertyOrGetter.getInt(); }\n  bool isExplicitProperty() const { return !PropertyOrGetter.getInt(); }\n\n  ObjCPropertyDecl *getExplicitProperty() const {\n    assert(!isImplicitProperty());\n    return cast<ObjCPropertyDecl>(PropertyOrGetter.getPointer());\n  }\n\n  ObjCMethodDecl *getImplicitPropertyGetter() const {\n    assert(isImplicitProperty());\n    return cast_or_null<ObjCMethodDecl>(PropertyOrGetter.getPointer());\n  }\n\n  ObjCMethodDecl *getImplicitPropertySetter() const {\n    assert(isImplicitProperty());\n    return SetterAndMethodRefFlags.getPointer();\n  }\n\n  Selector getGetterSelector() const {\n    if (isImplicitProperty())\n      return getImplicitPropertyGetter()->getSelector();\n    return getExplicitProperty()->getGetterName();\n  }\n\n  Selector getSetterSelector() const {\n    if (isImplicitProperty())\n      return getImplicitPropertySetter()->getSelector();\n    return getExplicitProperty()->getSetterName();\n  }\n\n  /// True if the property reference will result in a message to the\n  /// getter.\n  /// This applies to both implicit and explicit property references.\n  bool isMessagingGetter() const {\n    return SetterAndMethodRefFlags.getInt() & MethodRef_Getter;\n  }\n\n  /// True if the property reference will result in a message to the\n  /// setter.\n  /// This applies to both implicit and explicit property references.\n  bool isMessagingSetter() const {\n    return SetterAndMethodRefFlags.getInt() & MethodRef_Setter;\n  }\n\n  void setIsMessagingGetter(bool val = true) {\n    setMethodRefFlag(MethodRef_Getter, val);\n  }\n\n  void setIsMessagingSetter(bool val = true) {\n    setMethodRefFlag(MethodRef_Setter, val);\n  }\n\n  const Expr *getBase() const {\n    return cast<Expr>(Receiver.get<Stmt*>());\n  }\n  Expr *getBase() {\n    return cast<Expr>(Receiver.get<Stmt*>());\n  }\n\n  SourceLocation getLocation() const { return IdLoc; }\n\n  SourceLocation getReceiverLocation() const { return ReceiverLoc; }\n\n  QualType getSuperReceiverType() const {\n    return QualType(Receiver.get<const Type*>(), 0);\n  }\n\n  ObjCInterfaceDecl *getClassReceiver() const {\n    return Receiver.get<ObjCInterfaceDecl*>();\n  }\n\n  bool isObjectReceiver() const { return Receiver.is<Stmt*>(); }\n  bool isSuperReceiver() const { return Receiver.is<const Type*>(); }\n  bool isClassReceiver() const { return Receiver.is<ObjCInterfaceDecl*>(); }\n\n  /// Determine the type of the base, regardless of the kind of receiver.\n  QualType getReceiverType(const ASTContext &ctx) const;\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return isObjectReceiver() ? getBase()->getBeginLoc()\n                              : getReceiverLocation();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY { return IdLoc; }\n\n  // Iterators\n  child_range children() {\n    if (Receiver.is<Stmt*>()) {\n      Stmt **begin = reinterpret_cast<Stmt**>(&Receiver); // hack!\n      return child_range(begin, begin+1);\n    }\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<ObjCPropertyRefExpr *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCPropertyRefExprClass;\n  }\n\nprivate:\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  void setExplicitProperty(ObjCPropertyDecl *D, unsigned methRefFlags) {\n    PropertyOrGetter.setPointer(D);\n    PropertyOrGetter.setInt(false);\n    SetterAndMethodRefFlags.setPointer(nullptr);\n    SetterAndMethodRefFlags.setInt(methRefFlags);\n  }\n\n  void setImplicitProperty(ObjCMethodDecl *Getter, ObjCMethodDecl *Setter,\n                           unsigned methRefFlags) {\n    PropertyOrGetter.setPointer(Getter);\n    PropertyOrGetter.setInt(true);\n    SetterAndMethodRefFlags.setPointer(Setter);\n    SetterAndMethodRefFlags.setInt(methRefFlags);\n  }\n\n  void setBase(Expr *Base) { Receiver = Base; }\n  void setSuperReceiver(QualType T) { Receiver = T.getTypePtr(); }\n  void setClassReceiver(ObjCInterfaceDecl *D) { Receiver = D; }\n\n  void setLocation(SourceLocation L) { IdLoc = L; }\n  void setReceiverLocation(SourceLocation Loc) { ReceiverLoc = Loc; }\n\n  void setMethodRefFlag(MethodRefFlags flag, bool val) {\n    unsigned f = SetterAndMethodRefFlags.getInt();\n    if (val)\n      f |= flag;\n    else\n      f &= ~flag;\n    SetterAndMethodRefFlags.setInt(f);\n  }\n};\n\n/// ObjCSubscriptRefExpr - used for array and dictionary subscripting.\n/// array[4] = array[3]; dictionary[key] = dictionary[alt_key];\nclass ObjCSubscriptRefExpr : public Expr {\n  // Location of ']' in an indexing expression.\n  SourceLocation RBracket;\n\n  // array/dictionary base expression.\n  // for arrays, this is a numeric expression. For dictionaries, this is\n  // an objective-c object pointer expression.\n  enum { BASE, KEY, END_EXPR };\n  Stmt* SubExprs[END_EXPR];\n\n  ObjCMethodDecl *GetAtIndexMethodDecl;\n\n  // For immutable objects this is null. When ObjCSubscriptRefExpr is to read\n  // an indexed object this is null too.\n  ObjCMethodDecl *SetAtIndexMethodDecl;\n\npublic:\n  ObjCSubscriptRefExpr(Expr *base, Expr *key, QualType T, ExprValueKind VK,\n                       ExprObjectKind OK, ObjCMethodDecl *getMethod,\n                       ObjCMethodDecl *setMethod, SourceLocation RB)\n      : Expr(ObjCSubscriptRefExprClass, T, VK, OK), RBracket(RB),\n        GetAtIndexMethodDecl(getMethod), SetAtIndexMethodDecl(setMethod) {\n    SubExprs[BASE] = base;\n    SubExprs[KEY] = key;\n    setDependence(computeDependence(this));\n  }\n\n  explicit ObjCSubscriptRefExpr(EmptyShell Empty)\n      : Expr(ObjCSubscriptRefExprClass, Empty) {}\n\n  SourceLocation getRBracket() const { return RBracket; }\n  void setRBracket(SourceLocation RB) { RBracket = RB; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return SubExprs[BASE]->getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY { return RBracket; }\n\n  Expr *getBaseExpr() const { return cast<Expr>(SubExprs[BASE]); }\n  void setBaseExpr(Stmt *S) { SubExprs[BASE] = S; }\n\n  Expr *getKeyExpr() const { return cast<Expr>(SubExprs[KEY]); }\n  void setKeyExpr(Stmt *S) { SubExprs[KEY] = S; }\n\n  ObjCMethodDecl *getAtIndexMethodDecl() const {\n    return GetAtIndexMethodDecl;\n  }\n\n  ObjCMethodDecl *setAtIndexMethodDecl() const {\n    return SetAtIndexMethodDecl;\n  }\n\n  bool isArraySubscriptRefExpr() const {\n    return getKeyExpr()->getType()->isIntegralOrEnumerationType();\n  }\n\n  child_range children() {\n    return child_range(SubExprs, SubExprs+END_EXPR);\n  }\n\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + END_EXPR);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCSubscriptRefExprClass;\n  }\n\nprivate:\n  friend class ASTStmtReader;\n};\n\n/// An expression that sends a message to the given Objective-C\n/// object or class.\n///\n/// The following contains two message send expressions:\n///\n/// \\code\n///   [[NSString alloc] initWithString:@\"Hello\"]\n/// \\endcode\n///\n/// The innermost message send invokes the \"alloc\" class method on the\n/// NSString class, while the outermost message send invokes the\n/// \"initWithString\" instance method on the object returned from\n/// NSString's \"alloc\". In all, an Objective-C message send can take\n/// on four different (although related) forms:\n///\n///   1. Send to an object instance.\n///   2. Send to a class.\n///   3. Send to the superclass instance of the current class.\n///   4. Send to the superclass of the current class.\n///\n/// All four kinds of message sends are modeled by the ObjCMessageExpr\n/// class, and can be distinguished via \\c getReceiverKind(). Example:\n///\n/// The \"void *\" trailing objects are actually ONE void * (the\n/// receiver pointer), and NumArgs Expr *. But due to the\n/// implementation of children(), these must be together contiguously.\nclass ObjCMessageExpr final\n    : public Expr,\n      private llvm::TrailingObjects<ObjCMessageExpr, void *, SourceLocation> {\n  /// Stores either the selector that this message is sending\n  /// to (when \\c HasMethod is zero) or an \\c ObjCMethodDecl pointer\n  /// referring to the method that we type-checked against.\n  uintptr_t SelectorOrMethod = 0;\n\n  enum { NumArgsBitWidth = 16 };\n\n  /// The number of arguments in the message send, not\n  /// including the receiver.\n  unsigned NumArgs : NumArgsBitWidth;\n\n  /// The kind of message send this is, which is one of the\n  /// ReceiverKind values.\n  ///\n  /// We pad this out to a byte to avoid excessive masking and shifting.\n  unsigned Kind : 8;\n\n  /// Whether we have an actual method prototype in \\c\n  /// SelectorOrMethod.\n  ///\n  /// When non-zero, we have a method declaration; otherwise, we just\n  /// have a selector.\n  unsigned HasMethod : 1;\n\n  /// Whether this message send is a \"delegate init call\",\n  /// i.e. a call of an init method on self from within an init method.\n  unsigned IsDelegateInitCall : 1;\n\n  /// Whether this message send was implicitly generated by\n  /// the implementation rather than explicitly written by the user.\n  unsigned IsImplicit : 1;\n\n  /// Whether the locations of the selector identifiers are in a\n  /// \"standard\" position, a enum SelectorLocationsKind.\n  unsigned SelLocsKind : 2;\n\n  /// When the message expression is a send to 'super', this is\n  /// the location of the 'super' keyword.\n  SourceLocation SuperLoc;\n\n  /// The source locations of the open and close square\n  /// brackets ('[' and ']', respectively).\n  SourceLocation LBracLoc, RBracLoc;\n\n  ObjCMessageExpr(EmptyShell Empty, unsigned NumArgs)\n      : Expr(ObjCMessageExprClass, Empty), Kind(0), HasMethod(false),\n        IsDelegateInitCall(false), IsImplicit(false), SelLocsKind(0) {\n    setNumArgs(NumArgs);\n  }\n\n  ObjCMessageExpr(QualType T, ExprValueKind VK,\n                  SourceLocation LBracLoc,\n                  SourceLocation SuperLoc,\n                  bool IsInstanceSuper,\n                  QualType SuperType,\n                  Selector Sel,\n                  ArrayRef<SourceLocation> SelLocs,\n                  SelectorLocationsKind SelLocsK,\n                  ObjCMethodDecl *Method,\n                  ArrayRef<Expr *> Args,\n                  SourceLocation RBracLoc,\n                  bool isImplicit);\n  ObjCMessageExpr(QualType T, ExprValueKind VK,\n                  SourceLocation LBracLoc,\n                  TypeSourceInfo *Receiver,\n                  Selector Sel,\n                  ArrayRef<SourceLocation> SelLocs,\n                  SelectorLocationsKind SelLocsK,\n                  ObjCMethodDecl *Method,\n                  ArrayRef<Expr *> Args,\n                  SourceLocation RBracLoc,\n                  bool isImplicit);\n  ObjCMessageExpr(QualType T, ExprValueKind VK,\n                  SourceLocation LBracLoc,\n                  Expr *Receiver,\n                  Selector Sel,\n                  ArrayRef<SourceLocation> SelLocs,\n                  SelectorLocationsKind SelLocsK,\n                  ObjCMethodDecl *Method,\n                  ArrayRef<Expr *> Args,\n                  SourceLocation RBracLoc,\n                  bool isImplicit);\n\n  size_t numTrailingObjects(OverloadToken<void *>) const { return NumArgs + 1; }\n\n  void setNumArgs(unsigned Num) {\n    assert((Num >> NumArgsBitWidth) == 0 && \"Num of args is out of range!\");\n    NumArgs = Num;\n  }\n\n  void initArgsAndSelLocs(ArrayRef<Expr *> Args,\n                          ArrayRef<SourceLocation> SelLocs,\n                          SelectorLocationsKind SelLocsK);\n\n  /// Retrieve the pointer value of the message receiver.\n  void *getReceiverPointer() const { return *getTrailingObjects<void *>(); }\n\n  /// Set the pointer value of the message receiver.\n  void setReceiverPointer(void *Value) {\n    *getTrailingObjects<void *>() = Value;\n  }\n\n  SelectorLocationsKind getSelLocsKind() const {\n    return (SelectorLocationsKind)SelLocsKind;\n  }\n\n  bool hasStandardSelLocs() const {\n    return getSelLocsKind() != SelLoc_NonStandard;\n  }\n\n  /// Get a pointer to the stored selector identifiers locations array.\n  /// No locations will be stored if HasStandardSelLocs is true.\n  SourceLocation *getStoredSelLocs() {\n    return getTrailingObjects<SourceLocation>();\n  }\n  const SourceLocation *getStoredSelLocs() const {\n    return getTrailingObjects<SourceLocation>();\n  }\n\n  /// Get the number of stored selector identifiers locations.\n  /// No locations will be stored if HasStandardSelLocs is true.\n  unsigned getNumStoredSelLocs() const {\n    if (hasStandardSelLocs())\n      return 0;\n    return getNumSelectorLocs();\n  }\n\n  static ObjCMessageExpr *alloc(const ASTContext &C,\n                                ArrayRef<Expr *> Args,\n                                SourceLocation RBraceLoc,\n                                ArrayRef<SourceLocation> SelLocs,\n                                Selector Sel,\n                                SelectorLocationsKind &SelLocsK);\n  static ObjCMessageExpr *alloc(const ASTContext &C,\n                                unsigned NumArgs,\n                                unsigned NumStoredSelLocs);\n\npublic:\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// The kind of receiver this message is sending to.\n  enum ReceiverKind {\n    /// The receiver is a class.\n    Class = 0,\n\n    /// The receiver is an object instance.\n    Instance,\n\n    /// The receiver is a superclass.\n    SuperClass,\n\n    /// The receiver is the instance of the superclass object.\n    SuperInstance\n  };\n\n  /// Create a message send to super.\n  ///\n  /// \\param Context The ASTContext in which this expression will be created.\n  ///\n  /// \\param T The result type of this message.\n  ///\n  /// \\param VK The value kind of this message.  A message returning\n  /// a l-value or r-value reference will be an l-value or x-value,\n  /// respectively.\n  ///\n  /// \\param LBracLoc The location of the open square bracket '['.\n  ///\n  /// \\param SuperLoc The location of the \"super\" keyword.\n  ///\n  /// \\param IsInstanceSuper Whether this is an instance \"super\"\n  /// message (otherwise, it's a class \"super\" message).\n  ///\n  /// \\param Sel The selector used to determine which method gets called.\n  ///\n  /// \\param Method The Objective-C method against which this message\n  /// send was type-checked. May be nullptr.\n  ///\n  /// \\param Args The message send arguments.\n  ///\n  /// \\param RBracLoc The location of the closing square bracket ']'.\n  static ObjCMessageExpr *Create(const ASTContext &Context, QualType T,\n                                 ExprValueKind VK,\n                                 SourceLocation LBracLoc,\n                                 SourceLocation SuperLoc,\n                                 bool IsInstanceSuper,\n                                 QualType SuperType,\n                                 Selector Sel,\n                                 ArrayRef<SourceLocation> SelLocs,\n                                 ObjCMethodDecl *Method,\n                                 ArrayRef<Expr *> Args,\n                                 SourceLocation RBracLoc,\n                                 bool isImplicit);\n\n  /// Create a class message send.\n  ///\n  /// \\param Context The ASTContext in which this expression will be created.\n  ///\n  /// \\param T The result type of this message.\n  ///\n  /// \\param VK The value kind of this message.  A message returning\n  /// a l-value or r-value reference will be an l-value or x-value,\n  /// respectively.\n  ///\n  /// \\param LBracLoc The location of the open square bracket '['.\n  ///\n  /// \\param Receiver The type of the receiver, including\n  /// source-location information.\n  ///\n  /// \\param Sel The selector used to determine which method gets called.\n  ///\n  /// \\param Method The Objective-C method against which this message\n  /// send was type-checked. May be nullptr.\n  ///\n  /// \\param Args The message send arguments.\n  ///\n  /// \\param RBracLoc The location of the closing square bracket ']'.\n  static ObjCMessageExpr *Create(const ASTContext &Context, QualType T,\n                                 ExprValueKind VK,\n                                 SourceLocation LBracLoc,\n                                 TypeSourceInfo *Receiver,\n                                 Selector Sel,\n                                 ArrayRef<SourceLocation> SelLocs,\n                                 ObjCMethodDecl *Method,\n                                 ArrayRef<Expr *> Args,\n                                 SourceLocation RBracLoc,\n                                 bool isImplicit);\n\n  /// Create an instance message send.\n  ///\n  /// \\param Context The ASTContext in which this expression will be created.\n  ///\n  /// \\param T The result type of this message.\n  ///\n  /// \\param VK The value kind of this message.  A message returning\n  /// a l-value or r-value reference will be an l-value or x-value,\n  /// respectively.\n  ///\n  /// \\param LBracLoc The location of the open square bracket '['.\n  ///\n  /// \\param Receiver The expression used to produce the object that\n  /// will receive this message.\n  ///\n  /// \\param Sel The selector used to determine which method gets called.\n  ///\n  /// \\param Method The Objective-C method against which this message\n  /// send was type-checked. May be nullptr.\n  ///\n  /// \\param Args The message send arguments.\n  ///\n  /// \\param RBracLoc The location of the closing square bracket ']'.\n  static ObjCMessageExpr *Create(const ASTContext &Context, QualType T,\n                                 ExprValueKind VK,\n                                 SourceLocation LBracLoc,\n                                 Expr *Receiver,\n                                 Selector Sel,\n                                 ArrayRef<SourceLocation> SeLocs,\n                                 ObjCMethodDecl *Method,\n                                 ArrayRef<Expr *> Args,\n                                 SourceLocation RBracLoc,\n                                 bool isImplicit);\n\n  /// Create an empty Objective-C message expression, to be\n  /// filled in by subsequent calls.\n  ///\n  /// \\param Context The context in which the message send will be created.\n  ///\n  /// \\param NumArgs The number of message arguments, not including\n  /// the receiver.\n  static ObjCMessageExpr *CreateEmpty(const ASTContext &Context,\n                                      unsigned NumArgs,\n                                      unsigned NumStoredSelLocs);\n\n  /// Indicates whether the message send was implicitly\n  /// generated by the implementation. If false, it was written explicitly\n  /// in the source code.\n  bool isImplicit() const { return IsImplicit; }\n\n  /// Determine the kind of receiver that this message is being\n  /// sent to.\n  ReceiverKind getReceiverKind() const { return (ReceiverKind)Kind; }\n\n  /// \\return the return type of the message being sent.\n  /// This is not always the type of the message expression itself because\n  /// of references (the expression would not have a reference type).\n  /// It is also not always the declared return type of the method because\n  /// of `instancetype` (in that case it's an expression type).\n  QualType getCallReturnType(ASTContext &Ctx) const;\n\n  /// Source range of the receiver.\n  SourceRange getReceiverRange() const;\n\n  /// Determine whether this is an instance message to either a\n  /// computed object or to super.\n  bool isInstanceMessage() const {\n    return getReceiverKind() == Instance || getReceiverKind() == SuperInstance;\n  }\n\n  /// Determine whether this is an class message to either a\n  /// specified class or to super.\n  bool isClassMessage() const {\n    return getReceiverKind() == Class || getReceiverKind() == SuperClass;\n  }\n\n  /// Returns the object expression (receiver) for an instance message,\n  /// or null for a message that is not an instance message.\n  Expr *getInstanceReceiver() {\n    if (getReceiverKind() == Instance)\n      return static_cast<Expr *>(getReceiverPointer());\n\n    return nullptr;\n  }\n  const Expr *getInstanceReceiver() const {\n    return const_cast<ObjCMessageExpr*>(this)->getInstanceReceiver();\n  }\n\n  /// Turn this message send into an instance message that\n  /// computes the receiver object with the given expression.\n  void setInstanceReceiver(Expr *rec) {\n    Kind = Instance;\n    setReceiverPointer(rec);\n  }\n\n  /// Returns the type of a class message send, or NULL if the\n  /// message is not a class message.\n  QualType getClassReceiver() const {\n    if (TypeSourceInfo *TSInfo = getClassReceiverTypeInfo())\n      return TSInfo->getType();\n\n    return {};\n  }\n\n  /// Returns a type-source information of a class message\n  /// send, or nullptr if the message is not a class message.\n  TypeSourceInfo *getClassReceiverTypeInfo() const {\n    if (getReceiverKind() == Class)\n      return reinterpret_cast<TypeSourceInfo *>(getReceiverPointer());\n    return nullptr;\n  }\n\n  void setClassReceiver(TypeSourceInfo *TSInfo) {\n    Kind = Class;\n    setReceiverPointer(TSInfo);\n  }\n\n  /// Retrieve the location of the 'super' keyword for a class\n  /// or instance message to 'super', otherwise an invalid source location.\n  SourceLocation getSuperLoc() const {\n    if (getReceiverKind() == SuperInstance || getReceiverKind() == SuperClass)\n      return SuperLoc;\n\n    return SourceLocation();\n  }\n\n  /// Retrieve the receiver type to which this message is being directed.\n  ///\n  /// This routine cross-cuts all of the different kinds of message\n  /// sends to determine what the underlying (statically known) type\n  /// of the receiver will be; use \\c getReceiverKind() to determine\n  /// whether the message is a class or an instance method, whether it\n  /// is a send to super or not, etc.\n  ///\n  /// \\returns The type of the receiver.\n  QualType getReceiverType() const;\n\n  /// Retrieve the Objective-C interface to which this message\n  /// is being directed, if known.\n  ///\n  /// This routine cross-cuts all of the different kinds of message\n  /// sends to determine what the underlying (statically known) type\n  /// of the receiver will be; use \\c getReceiverKind() to determine\n  /// whether the message is a class or an instance method, whether it\n  /// is a send to super or not, etc.\n  ///\n  /// \\returns The Objective-C interface if known, otherwise nullptr.\n  ObjCInterfaceDecl *getReceiverInterface() const;\n\n  /// Retrieve the type referred to by 'super'.\n  ///\n  /// The returned type will either be an ObjCInterfaceType (for an\n  /// class message to super) or an ObjCObjectPointerType that refers\n  /// to a class (for an instance message to super);\n  QualType getSuperType() const {\n    if (getReceiverKind() == SuperInstance || getReceiverKind() == SuperClass)\n      return QualType::getFromOpaquePtr(getReceiverPointer());\n\n    return QualType();\n  }\n\n  void setSuper(SourceLocation Loc, QualType T, bool IsInstanceSuper) {\n    Kind = IsInstanceSuper? SuperInstance : SuperClass;\n    SuperLoc = Loc;\n    setReceiverPointer(T.getAsOpaquePtr());\n  }\n\n  Selector getSelector() const;\n\n  void setSelector(Selector S) {\n    HasMethod = false;\n    SelectorOrMethod = reinterpret_cast<uintptr_t>(S.getAsOpaquePtr());\n  }\n\n  const ObjCMethodDecl *getMethodDecl() const {\n    if (HasMethod)\n      return reinterpret_cast<const ObjCMethodDecl *>(SelectorOrMethod);\n\n    return nullptr;\n  }\n\n  ObjCMethodDecl *getMethodDecl() {\n    if (HasMethod)\n      return reinterpret_cast<ObjCMethodDecl *>(SelectorOrMethod);\n\n    return nullptr;\n  }\n\n  void setMethodDecl(ObjCMethodDecl *MD) {\n    HasMethod = true;\n    SelectorOrMethod = reinterpret_cast<uintptr_t>(MD);\n  }\n\n  ObjCMethodFamily getMethodFamily() const {\n    if (HasMethod) return getMethodDecl()->getMethodFamily();\n    return getSelector().getMethodFamily();\n  }\n\n  /// Return the number of actual arguments in this message,\n  /// not counting the receiver.\n  unsigned getNumArgs() const { return NumArgs; }\n\n  /// Retrieve the arguments to this message, not including the\n  /// receiver.\n  Expr **getArgs() {\n    return reinterpret_cast<Expr **>(getTrailingObjects<void *>() + 1);\n  }\n  const Expr * const *getArgs() const {\n    return reinterpret_cast<const Expr *const *>(getTrailingObjects<void *>() +\n                                                 1);\n  }\n\n  /// getArg - Return the specified argument.\n  Expr *getArg(unsigned Arg) {\n    assert(Arg < NumArgs && \"Arg access out of range!\");\n    return getArgs()[Arg];\n  }\n  const Expr *getArg(unsigned Arg) const {\n    assert(Arg < NumArgs && \"Arg access out of range!\");\n    return getArgs()[Arg];\n  }\n\n  /// setArg - Set the specified argument.\n  void setArg(unsigned Arg, Expr *ArgExpr) {\n    assert(Arg < NumArgs && \"Arg access out of range!\");\n    getArgs()[Arg] = ArgExpr;\n  }\n\n  /// isDelegateInitCall - Answers whether this message send has been\n  /// tagged as a \"delegate init call\", i.e. a call to a method in the\n  /// -init family on self from within an -init method implementation.\n  bool isDelegateInitCall() const { return IsDelegateInitCall; }\n  void setDelegateInitCall(bool isDelegate) { IsDelegateInitCall = isDelegate; }\n\n  SourceLocation getLeftLoc() const { return LBracLoc; }\n  SourceLocation getRightLoc() const { return RBracLoc; }\n\n  SourceLocation getSelectorStartLoc() const {\n    if (isImplicit())\n      return getBeginLoc();\n    return getSelectorLoc(0);\n  }\n\n  SourceLocation getSelectorLoc(unsigned Index) const {\n    assert(Index < getNumSelectorLocs() && \"Index out of range!\");\n    if (hasStandardSelLocs())\n      return getStandardSelectorLoc(Index, getSelector(),\n                                   getSelLocsKind() == SelLoc_StandardWithSpace,\n                               llvm::makeArrayRef(const_cast<Expr**>(getArgs()),\n                                                  getNumArgs()),\n                                   RBracLoc);\n    return getStoredSelLocs()[Index];\n  }\n\n  void getSelectorLocs(SmallVectorImpl<SourceLocation> &SelLocs) const;\n\n  unsigned getNumSelectorLocs() const {\n    if (isImplicit())\n      return 0;\n    Selector Sel = getSelector();\n    if (Sel.isUnarySelector())\n      return 1;\n    return Sel.getNumArgs();\n  }\n\n  void setSourceRange(SourceRange R) {\n    LBracLoc = R.getBegin();\n    RBracLoc = R.getEnd();\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return LBracLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RBracLoc; }\n\n  // Iterators\n  child_range children();\n\n  const_child_range children() const;\n\n  using arg_iterator = ExprIterator;\n  using const_arg_iterator = ConstExprIterator;\n\n  llvm::iterator_range<arg_iterator> arguments() {\n    return llvm::make_range(arg_begin(), arg_end());\n  }\n\n  llvm::iterator_range<const_arg_iterator> arguments() const {\n    return llvm::make_range(arg_begin(), arg_end());\n  }\n\n  arg_iterator arg_begin() { return reinterpret_cast<Stmt **>(getArgs()); }\n\n  arg_iterator arg_end()   {\n    return reinterpret_cast<Stmt **>(getArgs() + NumArgs);\n  }\n\n  const_arg_iterator arg_begin() const {\n    return reinterpret_cast<Stmt const * const*>(getArgs());\n  }\n\n  const_arg_iterator arg_end() const {\n    return reinterpret_cast<Stmt const * const*>(getArgs() + NumArgs);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCMessageExprClass;\n  }\n};\n\n/// ObjCIsaExpr - Represent X->isa and X.isa when X is an ObjC 'id' type.\n/// (similar in spirit to MemberExpr).\nclass ObjCIsaExpr : public Expr {\n  /// Base - the expression for the base object pointer.\n  Stmt *Base;\n\n  /// IsaMemberLoc - This is the location of the 'isa'.\n  SourceLocation IsaMemberLoc;\n\n  /// OpLoc - This is the location of '.' or '->'\n  SourceLocation OpLoc;\n\n  /// IsArrow - True if this is \"X->F\", false if this is \"X.F\".\n  bool IsArrow;\n\npublic:\n  ObjCIsaExpr(Expr *base, bool isarrow, SourceLocation l, SourceLocation oploc,\n              QualType ty)\n      : Expr(ObjCIsaExprClass, ty, VK_LValue, OK_Ordinary), Base(base),\n        IsaMemberLoc(l), OpLoc(oploc), IsArrow(isarrow) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Build an empty expression.\n  explicit ObjCIsaExpr(EmptyShell Empty) : Expr(ObjCIsaExprClass, Empty) {}\n\n  void setBase(Expr *E) { Base = E; }\n  Expr *getBase() const { return cast<Expr>(Base); }\n\n  bool isArrow() const { return IsArrow; }\n  void setArrow(bool A) { IsArrow = A; }\n\n  /// getMemberLoc - Return the location of the \"member\", in X->F, it is the\n  /// location of 'F'.\n  SourceLocation getIsaMemberLoc() const { return IsaMemberLoc; }\n  void setIsaMemberLoc(SourceLocation L) { IsaMemberLoc = L; }\n\n  SourceLocation getOpLoc() const { return OpLoc; }\n  void setOpLoc(SourceLocation L) { OpLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getBase()->getBeginLoc();\n  }\n\n  SourceLocation getBaseLocEnd() const LLVM_READONLY {\n    return getBase()->getEndLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY { return IsaMemberLoc; }\n\n  SourceLocation getExprLoc() const LLVM_READONLY { return IsaMemberLoc; }\n\n  // Iterators\n  child_range children() { return child_range(&Base, &Base+1); }\n\n  const_child_range children() const {\n    return const_child_range(&Base, &Base + 1);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCIsaExprClass;\n  }\n};\n\n/// ObjCIndirectCopyRestoreExpr - Represents the passing of a function\n/// argument by indirect copy-restore in ARC.  This is used to support\n/// passing indirect arguments with the wrong lifetime, e.g. when\n/// passing the address of a __strong local variable to an 'out'\n/// parameter.  This expression kind is only valid in an \"argument\"\n/// position to some sort of call expression.\n///\n/// The parameter must have type 'pointer to T', and the argument must\n/// have type 'pointer to U', where T and U agree except possibly in\n/// qualification.  If the argument value is null, then a null pointer\n/// is passed;  otherwise it points to an object A, and:\n/// 1. A temporary object B of type T is initialized, either by\n///    zero-initialization (used when initializing an 'out' parameter)\n///    or copy-initialization (used when initializing an 'inout'\n///    parameter).\n/// 2. The address of the temporary is passed to the function.\n/// 3. If the call completes normally, A is move-assigned from B.\n/// 4. Finally, A is destroyed immediately.\n///\n/// Currently 'T' must be a retainable object lifetime and must be\n/// __autoreleasing;  this qualifier is ignored when initializing\n/// the value.\nclass ObjCIndirectCopyRestoreExpr : public Expr {\n  friend class ASTReader;\n  friend class ASTStmtReader;\n\n  Stmt *Operand;\n\n  // unsigned ObjCIndirectCopyRestoreBits.ShouldCopy : 1;\n\n  explicit ObjCIndirectCopyRestoreExpr(EmptyShell Empty)\n      : Expr(ObjCIndirectCopyRestoreExprClass, Empty) {}\n\n  void setShouldCopy(bool shouldCopy) {\n    ObjCIndirectCopyRestoreExprBits.ShouldCopy = shouldCopy;\n  }\n\npublic:\n  ObjCIndirectCopyRestoreExpr(Expr *operand, QualType type, bool shouldCopy)\n      : Expr(ObjCIndirectCopyRestoreExprClass, type, VK_LValue, OK_Ordinary),\n        Operand(operand) {\n    setShouldCopy(shouldCopy);\n    setDependence(computeDependence(this));\n  }\n\n  Expr *getSubExpr() { return cast<Expr>(Operand); }\n  const Expr *getSubExpr() const { return cast<Expr>(Operand); }\n\n  /// shouldCopy - True if we should do the 'copy' part of the\n  /// copy-restore.  If false, the temporary will be zero-initialized.\n  bool shouldCopy() const { return ObjCIndirectCopyRestoreExprBits.ShouldCopy; }\n\n  child_range children() { return child_range(&Operand, &Operand+1); }\n\n  const_child_range children() const {\n    return const_child_range(&Operand, &Operand + 1);\n  }\n\n  // Source locations are determined by the subexpression.\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return Operand->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return Operand->getEndLoc();\n  }\n\n  SourceLocation getExprLoc() const LLVM_READONLY {\n    return getSubExpr()->getExprLoc();\n  }\n\n  static bool classof(const Stmt *s) {\n    return s->getStmtClass() == ObjCIndirectCopyRestoreExprClass;\n  }\n};\n\n/// An Objective-C \"bridged\" cast expression, which casts between\n/// Objective-C pointers and C pointers, transferring ownership in the process.\n///\n/// \\code\n/// NSString *str = (__bridge_transfer NSString *)CFCreateString();\n/// \\endcode\nclass ObjCBridgedCastExpr final\n    : public ExplicitCastExpr,\n      private llvm::TrailingObjects<ObjCBridgedCastExpr, CXXBaseSpecifier *> {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend class CastExpr;\n  friend TrailingObjects;\n\n  SourceLocation LParenLoc;\n  SourceLocation BridgeKeywordLoc;\n  unsigned Kind : 2;\n\npublic:\n  ObjCBridgedCastExpr(SourceLocation LParenLoc, ObjCBridgeCastKind Kind,\n                      CastKind CK, SourceLocation BridgeKeywordLoc,\n                      TypeSourceInfo *TSInfo, Expr *Operand)\n      : ExplicitCastExpr(ObjCBridgedCastExprClass, TSInfo->getType(), VK_RValue,\n                         CK, Operand, 0, false, TSInfo),\n        LParenLoc(LParenLoc), BridgeKeywordLoc(BridgeKeywordLoc), Kind(Kind) {}\n\n  /// Construct an empty Objective-C bridged cast.\n  explicit ObjCBridgedCastExpr(EmptyShell Shell)\n      : ExplicitCastExpr(ObjCBridgedCastExprClass, Shell, 0, false) {}\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Determine which kind of bridge is being performed via this cast.\n  ObjCBridgeCastKind getBridgeKind() const {\n    return static_cast<ObjCBridgeCastKind>(Kind);\n  }\n\n  /// Retrieve the kind of bridge being performed as a string.\n  StringRef getBridgeKindName() const;\n\n  /// The location of the bridge keyword.\n  SourceLocation getBridgeKeywordLoc() const { return BridgeKeywordLoc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return LParenLoc; }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getSubExpr()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCBridgedCastExprClass;\n  }\n};\n\n/// A runtime availability query.\n///\n/// There are 2 ways to spell this node:\n/// \\code\n///   @available(macos 10.10, ios 8, *); // Objective-C\n///   __builtin_available(macos 10.10, ios 8, *); // C, C++, and Objective-C\n/// \\endcode\n///\n/// Note that we only need to keep track of one \\c VersionTuple here, which is\n/// the one that corresponds to the current deployment target. This is meant to\n/// be used in the condition of an \\c if, but it is also usable as top level\n/// expressions.\n///\nclass ObjCAvailabilityCheckExpr : public Expr {\n  friend class ASTStmtReader;\n\n  VersionTuple VersionToCheck;\n  SourceLocation AtLoc, RParen;\n\npublic:\n  ObjCAvailabilityCheckExpr(VersionTuple VersionToCheck, SourceLocation AtLoc,\n                            SourceLocation RParen, QualType Ty)\n      : Expr(ObjCAvailabilityCheckExprClass, Ty, VK_RValue, OK_Ordinary),\n        VersionToCheck(VersionToCheck), AtLoc(AtLoc), RParen(RParen) {\n    setDependence(ExprDependence::None);\n  }\n\n  explicit ObjCAvailabilityCheckExpr(EmptyShell Shell)\n      : Expr(ObjCAvailabilityCheckExprClass, Shell) {}\n\n  SourceLocation getBeginLoc() const { return AtLoc; }\n  SourceLocation getEndLoc() const { return RParen; }\n  SourceRange getSourceRange() const { return {AtLoc, RParen}; }\n\n  /// This may be '*', in which case this should fold to true.\n  bool hasVersion() const { return !VersionToCheck.empty(); }\n  VersionTuple getVersion() { return VersionToCheck; }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCAvailabilityCheckExprClass;\n  }\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_EXPROBJC_H\n"}, "12": {"id": 12, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "content": "//===- Stmt.h - Classes for representing statements -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the Stmt interface and subclasses.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_STMT_H\n#define LLVM_CLANG_AST_STMT_H\n\n#include \"clang/AST/DeclGroup.h\"\n#include \"clang/AST/DependenceFlags.h\"\n#include \"clang/AST/StmtIterator.h\"\n#include \"clang/Basic/CapturedStmt.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/BitmaskEnum.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <string>\n\nnamespace llvm {\n\nclass FoldingSetNodeID;\n\n} // namespace llvm\n\nnamespace clang {\n\nclass ASTContext;\nclass Attr;\nclass CapturedDecl;\nclass Decl;\nclass Expr;\nclass AddrLabelExpr;\nclass LabelDecl;\nclass ODRHash;\nclass PrinterHelper;\nstruct PrintingPolicy;\nclass RecordDecl;\nclass SourceManager;\nclass StringLiteral;\nclass Token;\nclass VarDecl;\n\n//===----------------------------------------------------------------------===//\n// AST classes for statements.\n//===----------------------------------------------------------------------===//\n\n/// Stmt - This represents one statement.\n///\nclass alignas(void *) Stmt {\npublic:\n  enum StmtClass {\n    NoStmtClass = 0,\n#define STMT(CLASS, PARENT) CLASS##Class,\n#define STMT_RANGE(BASE, FIRST, LAST) \\\n        first##BASE##Constant=FIRST##Class, last##BASE##Constant=LAST##Class,\n#define LAST_STMT_RANGE(BASE, FIRST, LAST) \\\n        first##BASE##Constant=FIRST##Class, last##BASE##Constant=LAST##Class\n#define ABSTRACT_STMT(STMT)\n#include \"clang/AST/StmtNodes.inc\"\n  };\n\n  // Make vanilla 'new' and 'delete' illegal for Stmts.\nprotected:\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  void *operator new(size_t bytes) noexcept {\n    llvm_unreachable(\"Stmts cannot be allocated with regular 'new'.\");\n  }\n\n  void operator delete(void *data) noexcept {\n    llvm_unreachable(\"Stmts cannot be released with regular 'delete'.\");\n  }\n\n  //===--- Statement bitfields classes ---===//\n\n  class StmtBitfields {\n    friend class ASTStmtReader;\n    friend class ASTStmtWriter;\n    friend class Stmt;\n\n    /// The statement class.\n    unsigned sClass : 8;\n  };\n  enum { NumStmtBits = 8 };\n\n  class NullStmtBitfields {\n    friend class ASTStmtReader;\n    friend class ASTStmtWriter;\n    friend class NullStmt;\n\n    unsigned : NumStmtBits;\n\n    /// True if the null statement was preceded by an empty macro, e.g:\n    /// @code\n    ///   #define CALL(x)\n    ///   CALL(0);\n    /// @endcode\n    unsigned HasLeadingEmptyMacro : 1;\n\n    /// The location of the semi-colon.\n    SourceLocation SemiLoc;\n  };\n\n  class CompoundStmtBitfields {\n    friend class ASTStmtReader;\n    friend class CompoundStmt;\n\n    unsigned : NumStmtBits;\n\n    unsigned NumStmts : 32 - NumStmtBits;\n\n    /// The location of the opening \"{\".\n    SourceLocation LBraceLoc;\n  };\n\n  class LabelStmtBitfields {\n    friend class LabelStmt;\n\n    unsigned : NumStmtBits;\n\n    SourceLocation IdentLoc;\n  };\n\n  class AttributedStmtBitfields {\n    friend class ASTStmtReader;\n    friend class AttributedStmt;\n\n    unsigned : NumStmtBits;\n\n    /// Number of attributes.\n    unsigned NumAttrs : 32 - NumStmtBits;\n\n    /// The location of the attribute.\n    SourceLocation AttrLoc;\n  };\n\n  class IfStmtBitfields {\n    friend class ASTStmtReader;\n    friend class IfStmt;\n\n    unsigned : NumStmtBits;\n\n    /// True if this if statement is a constexpr if.\n    unsigned IsConstexpr : 1;\n\n    /// True if this if statement has storage for an else statement.\n    unsigned HasElse : 1;\n\n    /// True if this if statement has storage for a variable declaration.\n    unsigned HasVar : 1;\n\n    /// True if this if statement has storage for an init statement.\n    unsigned HasInit : 1;\n\n    /// The location of the \"if\".\n    SourceLocation IfLoc;\n  };\n\n  class SwitchStmtBitfields {\n    friend class SwitchStmt;\n\n    unsigned : NumStmtBits;\n\n    /// True if the SwitchStmt has storage for an init statement.\n    unsigned HasInit : 1;\n\n    /// True if the SwitchStmt has storage for a condition variable.\n    unsigned HasVar : 1;\n\n    /// If the SwitchStmt is a switch on an enum value, records whether all\n    /// the enum values were covered by CaseStmts.  The coverage information\n    /// value is meant to be a hint for possible clients.\n    unsigned AllEnumCasesCovered : 1;\n\n    /// The location of the \"switch\".\n    SourceLocation SwitchLoc;\n  };\n\n  class WhileStmtBitfields {\n    friend class ASTStmtReader;\n    friend class WhileStmt;\n\n    unsigned : NumStmtBits;\n\n    /// True if the WhileStmt has storage for a condition variable.\n    unsigned HasVar : 1;\n\n    /// The location of the \"while\".\n    SourceLocation WhileLoc;\n  };\n\n  class DoStmtBitfields {\n    friend class DoStmt;\n\n    unsigned : NumStmtBits;\n\n    /// The location of the \"do\".\n    SourceLocation DoLoc;\n  };\n\n  class ForStmtBitfields {\n    friend class ForStmt;\n\n    unsigned : NumStmtBits;\n\n    /// The location of the \"for\".\n    SourceLocation ForLoc;\n  };\n\n  class GotoStmtBitfields {\n    friend class GotoStmt;\n    friend class IndirectGotoStmt;\n\n    unsigned : NumStmtBits;\n\n    /// The location of the \"goto\".\n    SourceLocation GotoLoc;\n  };\n\n  class ContinueStmtBitfields {\n    friend class ContinueStmt;\n\n    unsigned : NumStmtBits;\n\n    /// The location of the \"continue\".\n    SourceLocation ContinueLoc;\n  };\n\n  class BreakStmtBitfields {\n    friend class BreakStmt;\n\n    unsigned : NumStmtBits;\n\n    /// The location of the \"break\".\n    SourceLocation BreakLoc;\n  };\n\n  class ReturnStmtBitfields {\n    friend class ReturnStmt;\n\n    unsigned : NumStmtBits;\n\n    /// True if this ReturnStmt has storage for an NRVO candidate.\n    unsigned HasNRVOCandidate : 1;\n\n    /// The location of the \"return\".\n    SourceLocation RetLoc;\n  };\n\n  class SwitchCaseBitfields {\n    friend class SwitchCase;\n    friend class CaseStmt;\n\n    unsigned : NumStmtBits;\n\n    /// Used by CaseStmt to store whether it is a case statement\n    /// of the form case LHS ... RHS (a GNU extension).\n    unsigned CaseStmtIsGNURange : 1;\n\n    /// The location of the \"case\" or \"default\" keyword.\n    SourceLocation KeywordLoc;\n  };\n\n  //===--- Expression bitfields classes ---===//\n\n  class ExprBitfields {\n    friend class ASTStmtReader; // deserialization\n    friend class AtomicExpr; // ctor\n    friend class BlockDeclRefExpr; // ctor\n    friend class CallExpr; // ctor\n    friend class CXXConstructExpr; // ctor\n    friend class CXXDependentScopeMemberExpr; // ctor\n    friend class CXXNewExpr; // ctor\n    friend class CXXUnresolvedConstructExpr; // ctor\n    friend class DeclRefExpr; // computeDependence\n    friend class DependentScopeDeclRefExpr; // ctor\n    friend class DesignatedInitExpr; // ctor\n    friend class Expr;\n    friend class InitListExpr; // ctor\n    friend class ObjCArrayLiteral; // ctor\n    friend class ObjCDictionaryLiteral; // ctor\n    friend class ObjCMessageExpr; // ctor\n    friend class OffsetOfExpr; // ctor\n    friend class OpaqueValueExpr; // ctor\n    friend class OverloadExpr; // ctor\n    friend class ParenListExpr; // ctor\n    friend class PseudoObjectExpr; // ctor\n    friend class ShuffleVectorExpr; // ctor\n\n    unsigned : NumStmtBits;\n\n    unsigned ValueKind : 2;\n    unsigned ObjectKind : 3;\n    unsigned /*ExprDependence*/ Dependent : llvm::BitWidth<ExprDependence>;\n  };\n  enum { NumExprBits = NumStmtBits + 5 + llvm::BitWidth<ExprDependence> };\n\n  class ConstantExprBitfields {\n    friend class ASTStmtReader;\n    friend class ASTStmtWriter;\n    friend class ConstantExpr;\n\n    unsigned : NumExprBits;\n\n    /// The kind of result that is tail-allocated.\n    unsigned ResultKind : 2;\n\n    /// The kind of Result as defined by APValue::Kind.\n    unsigned APValueKind : 4;\n\n    /// When ResultKind == RSK_Int64, true if the tail-allocated integer is\n    /// unsigned.\n    unsigned IsUnsigned : 1;\n\n    /// When ResultKind == RSK_Int64. the BitWidth of the tail-allocated\n    /// integer. 7 bits because it is the minimal number of bits to represent a\n    /// value from 0 to 64 (the size of the tail-allocated integer).\n    unsigned BitWidth : 7;\n\n    /// When ResultKind == RSK_APValue, true if the ASTContext will cleanup the\n    /// tail-allocated APValue.\n    unsigned HasCleanup : 1;\n\n    /// True if this ConstantExpr was created for immediate invocation.\n    unsigned IsImmediateInvocation : 1;\n  };\n\n  class PredefinedExprBitfields {\n    friend class ASTStmtReader;\n    friend class PredefinedExpr;\n\n    unsigned : NumExprBits;\n\n    /// The kind of this PredefinedExpr. One of the enumeration values\n    /// in PredefinedExpr::IdentKind.\n    unsigned Kind : 4;\n\n    /// True if this PredefinedExpr has a trailing \"StringLiteral *\"\n    /// for the predefined identifier.\n    unsigned HasFunctionName : 1;\n\n    /// The location of this PredefinedExpr.\n    SourceLocation Loc;\n  };\n\n  class DeclRefExprBitfields {\n    friend class ASTStmtReader; // deserialization\n    friend class DeclRefExpr;\n\n    unsigned : NumExprBits;\n\n    unsigned HasQualifier : 1;\n    unsigned HasTemplateKWAndArgsInfo : 1;\n    unsigned HasFoundDecl : 1;\n    unsigned HadMultipleCandidates : 1;\n    unsigned RefersToEnclosingVariableOrCapture : 1;\n    unsigned NonOdrUseReason : 2;\n\n    /// The location of the declaration name itself.\n    SourceLocation Loc;\n  };\n\n\n  class FloatingLiteralBitfields {\n    friend class FloatingLiteral;\n\n    unsigned : NumExprBits;\n\n    unsigned Semantics : 3; // Provides semantics for APFloat construction\n    unsigned IsExact : 1;\n  };\n\n  class StringLiteralBitfields {\n    friend class ASTStmtReader;\n    friend class StringLiteral;\n\n    unsigned : NumExprBits;\n\n    /// The kind of this string literal.\n    /// One of the enumeration values of StringLiteral::StringKind.\n    unsigned Kind : 3;\n\n    /// The width of a single character in bytes. Only values of 1, 2,\n    /// and 4 bytes are supported. StringLiteral::mapCharByteWidth maps\n    /// the target + string kind to the appropriate CharByteWidth.\n    unsigned CharByteWidth : 3;\n\n    unsigned IsPascal : 1;\n\n    /// The number of concatenated token this string is made of.\n    /// This is the number of trailing SourceLocation.\n    unsigned NumConcatenated;\n  };\n\n  class CharacterLiteralBitfields {\n    friend class CharacterLiteral;\n\n    unsigned : NumExprBits;\n\n    unsigned Kind : 3;\n  };\n\n  class UnaryOperatorBitfields {\n    friend class UnaryOperator;\n\n    unsigned : NumExprBits;\n\n    unsigned Opc : 5;\n    unsigned CanOverflow : 1;\n    //\n    /// This is only meaningful for operations on floating point\n    /// types when additional values need to be in trailing storage.\n    /// It is 0 otherwise.\n    unsigned HasFPFeatures : 1;\n\n    SourceLocation Loc;\n  };\n\n  class UnaryExprOrTypeTraitExprBitfields {\n    friend class UnaryExprOrTypeTraitExpr;\n\n    unsigned : NumExprBits;\n\n    unsigned Kind : 3;\n    unsigned IsType : 1; // true if operand is a type, false if an expression.\n  };\n\n  class ArrayOrMatrixSubscriptExprBitfields {\n    friend class ArraySubscriptExpr;\n    friend class MatrixSubscriptExpr;\n\n    unsigned : NumExprBits;\n\n    SourceLocation RBracketLoc;\n  };\n\n  class CallExprBitfields {\n    friend class CallExpr;\n\n    unsigned : NumExprBits;\n\n    unsigned NumPreArgs : 1;\n\n    /// True if the callee of the call expression was found using ADL.\n    unsigned UsesADL : 1;\n\n    /// True if the call expression has some floating-point features.\n    unsigned HasFPFeatures : 1;\n\n    /// Padding used to align OffsetToTrailingObjects to a byte multiple.\n    unsigned : 24 - 3 - NumExprBits;\n\n    /// The offset in bytes from the this pointer to the start of the\n    /// trailing objects belonging to CallExpr. Intentionally byte sized\n    /// for faster access.\n    unsigned OffsetToTrailingObjects : 8;\n  };\n  enum { NumCallExprBits = 32 };\n\n  class MemberExprBitfields {\n    friend class ASTStmtReader;\n    friend class MemberExpr;\n\n    unsigned : NumExprBits;\n\n    /// IsArrow - True if this is \"X->F\", false if this is \"X.F\".\n    unsigned IsArrow : 1;\n\n    /// True if this member expression used a nested-name-specifier to\n    /// refer to the member, e.g., \"x->Base::f\", or found its member via\n    /// a using declaration.  When true, a MemberExprNameQualifier\n    /// structure is allocated immediately after the MemberExpr.\n    unsigned HasQualifierOrFoundDecl : 1;\n\n    /// True if this member expression specified a template keyword\n    /// and/or a template argument list explicitly, e.g., x->f<int>,\n    /// x->template f, x->template f<int>.\n    /// When true, an ASTTemplateKWAndArgsInfo structure and its\n    /// TemplateArguments (if any) are present.\n    unsigned HasTemplateKWAndArgsInfo : 1;\n\n    /// True if this member expression refers to a method that\n    /// was resolved from an overloaded set having size greater than 1.\n    unsigned HadMultipleCandidates : 1;\n\n    /// Value of type NonOdrUseReason indicating why this MemberExpr does\n    /// not constitute an odr-use of the named declaration. Meaningful only\n    /// when naming a static member.\n    unsigned NonOdrUseReason : 2;\n\n    /// This is the location of the -> or . in the expression.\n    SourceLocation OperatorLoc;\n  };\n\n  class CastExprBitfields {\n    friend class CastExpr;\n    friend class ImplicitCastExpr;\n\n    unsigned : NumExprBits;\n\n    unsigned Kind : 6;\n    unsigned PartOfExplicitCast : 1; // Only set for ImplicitCastExpr.\n\n    /// True if the call expression has some floating-point features.\n    unsigned HasFPFeatures : 1;\n\n    /// The number of CXXBaseSpecifiers in the cast. 14 bits would be enough\n    /// here. ([implimits] Direct and indirect base classes [16384]).\n    unsigned BasePathSize;\n  };\n\n  class BinaryOperatorBitfields {\n    friend class BinaryOperator;\n\n    unsigned : NumExprBits;\n\n    unsigned Opc : 6;\n\n    /// This is only meaningful for operations on floating point\n    /// types when additional values need to be in trailing storage.\n    /// It is 0 otherwise.\n    unsigned HasFPFeatures : 1;\n\n    SourceLocation OpLoc;\n  };\n\n  class InitListExprBitfields {\n    friend class InitListExpr;\n\n    unsigned : NumExprBits;\n\n    /// Whether this initializer list originally had a GNU array-range\n    /// designator in it. This is a temporary marker used by CodeGen.\n    unsigned HadArrayRangeDesignator : 1;\n  };\n\n  class ParenListExprBitfields {\n    friend class ASTStmtReader;\n    friend class ParenListExpr;\n\n    unsigned : NumExprBits;\n\n    /// The number of expressions in the paren list.\n    unsigned NumExprs;\n  };\n\n  class GenericSelectionExprBitfields {\n    friend class ASTStmtReader;\n    friend class GenericSelectionExpr;\n\n    unsigned : NumExprBits;\n\n    /// The location of the \"_Generic\".\n    SourceLocation GenericLoc;\n  };\n\n  class PseudoObjectExprBitfields {\n    friend class ASTStmtReader; // deserialization\n    friend class PseudoObjectExpr;\n\n    unsigned : NumExprBits;\n\n    // These don't need to be particularly wide, because they're\n    // strictly limited by the forms of expressions we permit.\n    unsigned NumSubExprs : 8;\n    unsigned ResultIndex : 32 - 8 - NumExprBits;\n  };\n\n  class SourceLocExprBitfields {\n    friend class ASTStmtReader;\n    friend class SourceLocExpr;\n\n    unsigned : NumExprBits;\n\n    /// The kind of source location builtin represented by the SourceLocExpr.\n    /// Ex. __builtin_LINE, __builtin_FUNCTION, ect.\n    unsigned Kind : 2;\n  };\n\n  class StmtExprBitfields {\n    friend class ASTStmtReader;\n    friend class StmtExpr;\n\n    unsigned : NumExprBits;\n\n    /// The number of levels of template parameters enclosing this statement\n    /// expression. Used to determine if a statement expression remains\n    /// dependent after instantiation.\n    unsigned TemplateDepth;\n  };\n\n  //===--- C++ Expression bitfields classes ---===//\n\n  class CXXOperatorCallExprBitfields {\n    friend class ASTStmtReader;\n    friend class CXXOperatorCallExpr;\n\n    unsigned : NumCallExprBits;\n\n    /// The kind of this overloaded operator. One of the enumerator\n    /// value of OverloadedOperatorKind.\n    unsigned OperatorKind : 6;\n  };\n\n  class CXXRewrittenBinaryOperatorBitfields {\n    friend class ASTStmtReader;\n    friend class CXXRewrittenBinaryOperator;\n\n    unsigned : NumCallExprBits;\n\n    unsigned IsReversed : 1;\n  };\n\n  class CXXBoolLiteralExprBitfields {\n    friend class CXXBoolLiteralExpr;\n\n    unsigned : NumExprBits;\n\n    /// The value of the boolean literal.\n    unsigned Value : 1;\n\n    /// The location of the boolean literal.\n    SourceLocation Loc;\n  };\n\n  class CXXNullPtrLiteralExprBitfields {\n    friend class CXXNullPtrLiteralExpr;\n\n    unsigned : NumExprBits;\n\n    /// The location of the null pointer literal.\n    SourceLocation Loc;\n  };\n\n  class CXXThisExprBitfields {\n    friend class CXXThisExpr;\n\n    unsigned : NumExprBits;\n\n    /// Whether this is an implicit \"this\".\n    unsigned IsImplicit : 1;\n\n    /// The location of the \"this\".\n    SourceLocation Loc;\n  };\n\n  class CXXThrowExprBitfields {\n    friend class ASTStmtReader;\n    friend class CXXThrowExpr;\n\n    unsigned : NumExprBits;\n\n    /// Whether the thrown variable (if any) is in scope.\n    unsigned IsThrownVariableInScope : 1;\n\n    /// The location of the \"throw\".\n    SourceLocation ThrowLoc;\n  };\n\n  class CXXDefaultArgExprBitfields {\n    friend class ASTStmtReader;\n    friend class CXXDefaultArgExpr;\n\n    unsigned : NumExprBits;\n\n    /// The location where the default argument expression was used.\n    SourceLocation Loc;\n  };\n\n  class CXXDefaultInitExprBitfields {\n    friend class ASTStmtReader;\n    friend class CXXDefaultInitExpr;\n\n    unsigned : NumExprBits;\n\n    /// The location where the default initializer expression was used.\n    SourceLocation Loc;\n  };\n\n  class CXXScalarValueInitExprBitfields {\n    friend class ASTStmtReader;\n    friend class CXXScalarValueInitExpr;\n\n    unsigned : NumExprBits;\n\n    SourceLocation RParenLoc;\n  };\n\n  class CXXNewExprBitfields {\n    friend class ASTStmtReader;\n    friend class ASTStmtWriter;\n    friend class CXXNewExpr;\n\n    unsigned : NumExprBits;\n\n    /// Was the usage ::new, i.e. is the global new to be used?\n    unsigned IsGlobalNew : 1;\n\n    /// Do we allocate an array? If so, the first trailing \"Stmt *\" is the\n    /// size expression.\n    unsigned IsArray : 1;\n\n    /// Should the alignment be passed to the allocation function?\n    unsigned ShouldPassAlignment : 1;\n\n    /// If this is an array allocation, does the usual deallocation\n    /// function for the allocated type want to know the allocated size?\n    unsigned UsualArrayDeleteWantsSize : 1;\n\n    /// What kind of initializer do we have? Could be none, parens, or braces.\n    /// In storage, we distinguish between \"none, and no initializer expr\", and\n    /// \"none, but an implicit initializer expr\".\n    unsigned StoredInitializationStyle : 2;\n\n    /// True if the allocated type was expressed as a parenthesized type-id.\n    unsigned IsParenTypeId : 1;\n\n    /// The number of placement new arguments.\n    unsigned NumPlacementArgs;\n  };\n\n  class CXXDeleteExprBitfields {\n    friend class ASTStmtReader;\n    friend class CXXDeleteExpr;\n\n    unsigned : NumExprBits;\n\n    /// Is this a forced global delete, i.e. \"::delete\"?\n    unsigned GlobalDelete : 1;\n\n    /// Is this the array form of delete, i.e. \"delete[]\"?\n    unsigned ArrayForm : 1;\n\n    /// ArrayFormAsWritten can be different from ArrayForm if 'delete' is\n    /// applied to pointer-to-array type (ArrayFormAsWritten will be false\n    /// while ArrayForm will be true).\n    unsigned ArrayFormAsWritten : 1;\n\n    /// Does the usual deallocation function for the element type require\n    /// a size_t argument?\n    unsigned UsualArrayDeleteWantsSize : 1;\n\n    /// Location of the expression.\n    SourceLocation Loc;\n  };\n\n  class TypeTraitExprBitfields {\n    friend class ASTStmtReader;\n    friend class ASTStmtWriter;\n    friend class TypeTraitExpr;\n\n    unsigned : NumExprBits;\n\n    /// The kind of type trait, which is a value of a TypeTrait enumerator.\n    unsigned Kind : 8;\n\n    /// If this expression is not value-dependent, this indicates whether\n    /// the trait evaluated true or false.\n    unsigned Value : 1;\n\n    /// The number of arguments to this type trait. According to [implimits]\n    /// 8 bits would be enough, but we require (and test for) at least 16 bits\n    /// to mirror FunctionType.\n    unsigned NumArgs;\n  };\n\n  class DependentScopeDeclRefExprBitfields {\n    friend class ASTStmtReader;\n    friend class ASTStmtWriter;\n    friend class DependentScopeDeclRefExpr;\n\n    unsigned : NumExprBits;\n\n    /// Whether the name includes info for explicit template\n    /// keyword and arguments.\n    unsigned HasTemplateKWAndArgsInfo : 1;\n  };\n\n  class CXXConstructExprBitfields {\n    friend class ASTStmtReader;\n    friend class CXXConstructExpr;\n\n    unsigned : NumExprBits;\n\n    unsigned Elidable : 1;\n    unsigned HadMultipleCandidates : 1;\n    unsigned ListInitialization : 1;\n    unsigned StdInitListInitialization : 1;\n    unsigned ZeroInitialization : 1;\n    unsigned ConstructionKind : 3;\n\n    SourceLocation Loc;\n  };\n\n  class ExprWithCleanupsBitfields {\n    friend class ASTStmtReader; // deserialization\n    friend class ExprWithCleanups;\n\n    unsigned : NumExprBits;\n\n    // When false, it must not have side effects.\n    unsigned CleanupsHaveSideEffects : 1;\n\n    unsigned NumObjects : 32 - 1 - NumExprBits;\n  };\n\n  class CXXUnresolvedConstructExprBitfields {\n    friend class ASTStmtReader;\n    friend class CXXUnresolvedConstructExpr;\n\n    unsigned : NumExprBits;\n\n    /// The number of arguments used to construct the type.\n    unsigned NumArgs;\n  };\n\n  class CXXDependentScopeMemberExprBitfields {\n    friend class ASTStmtReader;\n    friend class CXXDependentScopeMemberExpr;\n\n    unsigned : NumExprBits;\n\n    /// Whether this member expression used the '->' operator or\n    /// the '.' operator.\n    unsigned IsArrow : 1;\n\n    /// Whether this member expression has info for explicit template\n    /// keyword and arguments.\n    unsigned HasTemplateKWAndArgsInfo : 1;\n\n    /// See getFirstQualifierFoundInScope() and the comment listing\n    /// the trailing objects.\n    unsigned HasFirstQualifierFoundInScope : 1;\n\n    /// The location of the '->' or '.' operator.\n    SourceLocation OperatorLoc;\n  };\n\n  class OverloadExprBitfields {\n    friend class ASTStmtReader;\n    friend class OverloadExpr;\n\n    unsigned : NumExprBits;\n\n    /// Whether the name includes info for explicit template\n    /// keyword and arguments.\n    unsigned HasTemplateKWAndArgsInfo : 1;\n\n    /// Padding used by the derived classes to store various bits. If you\n    /// need to add some data here, shrink this padding and add your data\n    /// above. NumOverloadExprBits also needs to be updated.\n    unsigned : 32 - NumExprBits - 1;\n\n    /// The number of results.\n    unsigned NumResults;\n  };\n  enum { NumOverloadExprBits = NumExprBits + 1 };\n\n  class UnresolvedLookupExprBitfields {\n    friend class ASTStmtReader;\n    friend class UnresolvedLookupExpr;\n\n    unsigned : NumOverloadExprBits;\n\n    /// True if these lookup results should be extended by\n    /// argument-dependent lookup if this is the operand of a function call.\n    unsigned RequiresADL : 1;\n\n    /// True if these lookup results are overloaded.  This is pretty trivially\n    /// rederivable if we urgently need to kill this field.\n    unsigned Overloaded : 1;\n  };\n  static_assert(sizeof(UnresolvedLookupExprBitfields) <= 4,\n                \"UnresolvedLookupExprBitfields must be <= than 4 bytes to\"\n                \"avoid trashing OverloadExprBitfields::NumResults!\");\n\n  class UnresolvedMemberExprBitfields {\n    friend class ASTStmtReader;\n    friend class UnresolvedMemberExpr;\n\n    unsigned : NumOverloadExprBits;\n\n    /// Whether this member expression used the '->' operator or\n    /// the '.' operator.\n    unsigned IsArrow : 1;\n\n    /// Whether the lookup results contain an unresolved using declaration.\n    unsigned HasUnresolvedUsing : 1;\n  };\n  static_assert(sizeof(UnresolvedMemberExprBitfields) <= 4,\n                \"UnresolvedMemberExprBitfields must be <= than 4 bytes to\"\n                \"avoid trashing OverloadExprBitfields::NumResults!\");\n\n  class CXXNoexceptExprBitfields {\n    friend class ASTStmtReader;\n    friend class CXXNoexceptExpr;\n\n    unsigned : NumExprBits;\n\n    unsigned Value : 1;\n  };\n\n  class SubstNonTypeTemplateParmExprBitfields {\n    friend class ASTStmtReader;\n    friend class SubstNonTypeTemplateParmExpr;\n\n    unsigned : NumExprBits;\n\n    /// The location of the non-type template parameter reference.\n    SourceLocation NameLoc;\n  };\n\n  class LambdaExprBitfields {\n    friend class ASTStmtReader;\n    friend class ASTStmtWriter;\n    friend class LambdaExpr;\n\n    unsigned : NumExprBits;\n\n    /// The default capture kind, which is a value of type\n    /// LambdaCaptureDefault.\n    unsigned CaptureDefault : 2;\n\n    /// Whether this lambda had an explicit parameter list vs. an\n    /// implicit (and empty) parameter list.\n    unsigned ExplicitParams : 1;\n\n    /// Whether this lambda had the result type explicitly specified.\n    unsigned ExplicitResultType : 1;\n\n    /// The number of captures.\n    unsigned NumCaptures : 16;\n  };\n\n  class RequiresExprBitfields {\n    friend class ASTStmtReader;\n    friend class ASTStmtWriter;\n    friend class RequiresExpr;\n\n    unsigned : NumExprBits;\n\n    unsigned IsSatisfied : 1;\n    SourceLocation RequiresKWLoc;\n  };\n\n  //===--- C++ Coroutines TS bitfields classes ---===//\n\n  class CoawaitExprBitfields {\n    friend class CoawaitExpr;\n\n    unsigned : NumExprBits;\n\n    unsigned IsImplicit : 1;\n  };\n\n  //===--- Obj-C Expression bitfields classes ---===//\n\n  class ObjCIndirectCopyRestoreExprBitfields {\n    friend class ObjCIndirectCopyRestoreExpr;\n\n    unsigned : NumExprBits;\n\n    unsigned ShouldCopy : 1;\n  };\n\n  //===--- Clang Extensions bitfields classes ---===//\n\n  class OpaqueValueExprBitfields {\n    friend class ASTStmtReader;\n    friend class OpaqueValueExpr;\n\n    unsigned : NumExprBits;\n\n    /// The OVE is a unique semantic reference to its source expression if this\n    /// bit is set to true.\n    unsigned IsUnique : 1;\n\n    SourceLocation Loc;\n  };\n\n  union {\n    // Same order as in StmtNodes.td.\n    // Statements\n    StmtBitfields StmtBits;\n    NullStmtBitfields NullStmtBits;\n    CompoundStmtBitfields CompoundStmtBits;\n    LabelStmtBitfields LabelStmtBits;\n    AttributedStmtBitfields AttributedStmtBits;\n    IfStmtBitfields IfStmtBits;\n    SwitchStmtBitfields SwitchStmtBits;\n    WhileStmtBitfields WhileStmtBits;\n    DoStmtBitfields DoStmtBits;\n    ForStmtBitfields ForStmtBits;\n    GotoStmtBitfields GotoStmtBits;\n    ContinueStmtBitfields ContinueStmtBits;\n    BreakStmtBitfields BreakStmtBits;\n    ReturnStmtBitfields ReturnStmtBits;\n    SwitchCaseBitfields SwitchCaseBits;\n\n    // Expressions\n    ExprBitfields ExprBits;\n    ConstantExprBitfields ConstantExprBits;\n    PredefinedExprBitfields PredefinedExprBits;\n    DeclRefExprBitfields DeclRefExprBits;\n    FloatingLiteralBitfields FloatingLiteralBits;\n    StringLiteralBitfields StringLiteralBits;\n    CharacterLiteralBitfields CharacterLiteralBits;\n    UnaryOperatorBitfields UnaryOperatorBits;\n    UnaryExprOrTypeTraitExprBitfields UnaryExprOrTypeTraitExprBits;\n    ArrayOrMatrixSubscriptExprBitfields ArrayOrMatrixSubscriptExprBits;\n    CallExprBitfields CallExprBits;\n    MemberExprBitfields MemberExprBits;\n    CastExprBitfields CastExprBits;\n    BinaryOperatorBitfields BinaryOperatorBits;\n    InitListExprBitfields InitListExprBits;\n    ParenListExprBitfields ParenListExprBits;\n    GenericSelectionExprBitfields GenericSelectionExprBits;\n    PseudoObjectExprBitfields PseudoObjectExprBits;\n    SourceLocExprBitfields SourceLocExprBits;\n\n    // GNU Extensions.\n    StmtExprBitfields StmtExprBits;\n\n    // C++ Expressions\n    CXXOperatorCallExprBitfields CXXOperatorCallExprBits;\n    CXXRewrittenBinaryOperatorBitfields CXXRewrittenBinaryOperatorBits;\n    CXXBoolLiteralExprBitfields CXXBoolLiteralExprBits;\n    CXXNullPtrLiteralExprBitfields CXXNullPtrLiteralExprBits;\n    CXXThisExprBitfields CXXThisExprBits;\n    CXXThrowExprBitfields CXXThrowExprBits;\n    CXXDefaultArgExprBitfields CXXDefaultArgExprBits;\n    CXXDefaultInitExprBitfields CXXDefaultInitExprBits;\n    CXXScalarValueInitExprBitfields CXXScalarValueInitExprBits;\n    CXXNewExprBitfields CXXNewExprBits;\n    CXXDeleteExprBitfields CXXDeleteExprBits;\n    TypeTraitExprBitfields TypeTraitExprBits;\n    DependentScopeDeclRefExprBitfields DependentScopeDeclRefExprBits;\n    CXXConstructExprBitfields CXXConstructExprBits;\n    ExprWithCleanupsBitfields ExprWithCleanupsBits;\n    CXXUnresolvedConstructExprBitfields CXXUnresolvedConstructExprBits;\n    CXXDependentScopeMemberExprBitfields CXXDependentScopeMemberExprBits;\n    OverloadExprBitfields OverloadExprBits;\n    UnresolvedLookupExprBitfields UnresolvedLookupExprBits;\n    UnresolvedMemberExprBitfields UnresolvedMemberExprBits;\n    CXXNoexceptExprBitfields CXXNoexceptExprBits;\n    SubstNonTypeTemplateParmExprBitfields SubstNonTypeTemplateParmExprBits;\n    LambdaExprBitfields LambdaExprBits;\n    RequiresExprBitfields RequiresExprBits;\n\n    // C++ Coroutines TS expressions\n    CoawaitExprBitfields CoawaitBits;\n\n    // Obj-C Expressions\n    ObjCIndirectCopyRestoreExprBitfields ObjCIndirectCopyRestoreExprBits;\n\n    // Clang Extensions\n    OpaqueValueExprBitfields OpaqueValueExprBits;\n  };\n\npublic:\n  // Only allow allocation of Stmts using the allocator in ASTContext\n  // or by doing a placement new.\n  void* operator new(size_t bytes, const ASTContext& C,\n                     unsigned alignment = 8);\n\n  void* operator new(size_t bytes, const ASTContext* C,\n                     unsigned alignment = 8) {\n    return operator new(bytes, *C, alignment);\n  }\n\n  void *operator new(size_t bytes, void *mem) noexcept { return mem; }\n\n  void operator delete(void *, const ASTContext &, unsigned) noexcept {}\n  void operator delete(void *, const ASTContext *, unsigned) noexcept {}\n  void operator delete(void *, size_t) noexcept {}\n  void operator delete(void *, void *) noexcept {}\n\npublic:\n  /// A placeholder type used to construct an empty shell of a\n  /// type, that will be filled in later (e.g., by some\n  /// de-serialization).\n  struct EmptyShell {};\n\n  /// The likelihood of a branch being taken.\n  enum Likelihood {\n    LH_Unlikely = -1, ///< Branch has the [[unlikely]] attribute.\n    LH_None,          ///< No attribute set or branches of the IfStmt have\n                      ///< the same attribute.\n    LH_Likely         ///< Branch has the [[likely]] attribute.\n  };\n\nprotected:\n  /// Iterator for iterating over Stmt * arrays that contain only T *.\n  ///\n  /// This is needed because AST nodes use Stmt* arrays to store\n  /// references to children (to be compatible with StmtIterator).\n  template<typename T, typename TPtr = T *, typename StmtPtr = Stmt *>\n  struct CastIterator\n      : llvm::iterator_adaptor_base<CastIterator<T, TPtr, StmtPtr>, StmtPtr *,\n                                    std::random_access_iterator_tag, TPtr> {\n    using Base = typename CastIterator::iterator_adaptor_base;\n\n    CastIterator() : Base(nullptr) {}\n    CastIterator(StmtPtr *I) : Base(I) {}\n\n    typename Base::value_type operator*() const {\n      return cast_or_null<T>(*this->I);\n    }\n  };\n\n  /// Const iterator for iterating over Stmt * arrays that contain only T *.\n  template <typename T>\n  using ConstCastIterator = CastIterator<T, const T *const, const Stmt *const>;\n\n  using ExprIterator = CastIterator<Expr>;\n  using ConstExprIterator = ConstCastIterator<Expr>;\n\nprivate:\n  /// Whether statistic collection is enabled.\n  static bool StatisticsEnabled;\n\nprotected:\n  /// Construct an empty statement.\n  explicit Stmt(StmtClass SC, EmptyShell) : Stmt(SC) {}\n\npublic:\n  Stmt() = delete;\n  Stmt(const Stmt &) = delete;\n  Stmt(Stmt &&) = delete;\n  Stmt &operator=(const Stmt &) = delete;\n  Stmt &operator=(Stmt &&) = delete;\n\n  Stmt(StmtClass SC) {\n    static_assert(sizeof(*this) <= 8,\n                  \"changing bitfields changed sizeof(Stmt)\");\n    static_assert(sizeof(*this) % alignof(void *) == 0,\n                  \"Insufficient alignment!\");\n    StmtBits.sClass = SC;\n    if (StatisticsEnabled) Stmt::addStmtClass(SC);\n  }\n\n  StmtClass getStmtClass() const {\n    return static_cast<StmtClass>(StmtBits.sClass);\n  }\n\n  const char *getStmtClassName() const;\n\n  /// SourceLocation tokens are not useful in isolation - they are low level\n  /// value objects created/interpreted by SourceManager. We assume AST\n  /// clients will have a pointer to the respective SourceManager.\n  SourceRange getSourceRange() const LLVM_READONLY;\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  // global temp stats (until we have a per-module visitor)\n  static void addStmtClass(const StmtClass s);\n  static void EnableStatistics();\n  static void PrintStats();\n\n  /// \\returns the likelihood of a set of attributes.\n  static Likelihood getLikelihood(ArrayRef<const Attr *> Attrs);\n\n  /// \\returns the likelihood of a statement.\n  static Likelihood getLikelihood(const Stmt *S);\n\n  /// \\returns the likelihood attribute of a statement.\n  static const Attr *getLikelihoodAttr(const Stmt *S);\n\n  /// \\returns the likelihood of the 'then' branch of an 'if' statement. The\n  /// 'else' branch is required to determine whether both branches specify the\n  /// same likelihood, which affects the result.\n  static Likelihood getLikelihood(const Stmt *Then, const Stmt *Else);\n\n  /// \\returns whether the likelihood of the branches of an if statement are\n  /// conflicting. When the first element is \\c true there's a conflict and\n  /// the Attr's are the conflicting attributes of the Then and Else Stmt.\n  static std::tuple<bool, const Attr *, const Attr *>\n  determineLikelihoodConflict(const Stmt *Then, const Stmt *Else);\n\n  /// Dumps the specified AST fragment and all subtrees to\n  /// \\c llvm::errs().\n  void dump() const;\n  void dump(raw_ostream &OS, const ASTContext &Context) const;\n\n  /// \\return Unique reproducible object identifier\n  int64_t getID(const ASTContext &Context) const;\n\n  /// dumpColor - same as dump(), but forces color highlighting.\n  void dumpColor() const;\n\n  /// dumpPretty/printPretty - These two methods do a \"pretty print\" of the AST\n  /// back to its original source language syntax.\n  void dumpPretty(const ASTContext &Context) const;\n  void printPretty(raw_ostream &OS, PrinterHelper *Helper,\n                   const PrintingPolicy &Policy, unsigned Indentation = 0,\n                   StringRef NewlineSymbol = \"\\n\",\n                   const ASTContext *Context = nullptr) const;\n\n  /// Pretty-prints in JSON format.\n  void printJson(raw_ostream &Out, PrinterHelper *Helper,\n                 const PrintingPolicy &Policy, bool AddQuotes) const;\n\n  /// viewAST - Visualize an AST rooted at this Stmt* using GraphViz.  Only\n  ///   works on systems with GraphViz (Mac OS X) or dot+gv installed.\n  void viewAST() const;\n\n  /// Skip no-op (attributed, compound) container stmts and skip captured\n  /// stmt at the top, if \\a IgnoreCaptured is true.\n  Stmt *IgnoreContainers(bool IgnoreCaptured = false);\n  const Stmt *IgnoreContainers(bool IgnoreCaptured = false) const {\n    return const_cast<Stmt *>(this)->IgnoreContainers(IgnoreCaptured);\n  }\n\n  const Stmt *stripLabelLikeStatements() const;\n  Stmt *stripLabelLikeStatements() {\n    return const_cast<Stmt*>(\n      const_cast<const Stmt*>(this)->stripLabelLikeStatements());\n  }\n\n  /// Child Iterators: All subclasses must implement 'children'\n  /// to permit easy iteration over the substatements/subexpessions of an\n  /// AST node.  This permits easy iteration over all nodes in the AST.\n  using child_iterator = StmtIterator;\n  using const_child_iterator = ConstStmtIterator;\n\n  using child_range = llvm::iterator_range<child_iterator>;\n  using const_child_range = llvm::iterator_range<const_child_iterator>;\n\n  child_range children();\n\n  const_child_range children() const {\n    auto Children = const_cast<Stmt *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_iterator child_begin() { return children().begin(); }\n  child_iterator child_end() { return children().end(); }\n\n  const_child_iterator child_begin() const { return children().begin(); }\n  const_child_iterator child_end() const { return children().end(); }\n\n  /// Produce a unique representation of the given statement.\n  ///\n  /// \\param ID once the profiling operation is complete, will contain\n  /// the unique representation of the given statement.\n  ///\n  /// \\param Context the AST context in which the statement resides\n  ///\n  /// \\param Canonical whether the profile should be based on the canonical\n  /// representation of this statement (e.g., where non-type template\n  /// parameters are identified by index/level rather than their\n  /// declaration pointers) or the exact representation of the statement as\n  /// written in the source.\n  void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n               bool Canonical) const;\n\n  /// Calculate a unique representation for a statement that is\n  /// stable across compiler invocations.\n  ///\n  /// \\param ID profile information will be stored in ID.\n  ///\n  /// \\param Hash an ODRHash object which will be called where pointers would\n  /// have been used in the Profile function.\n  void ProcessODRHash(llvm::FoldingSetNodeID &ID, ODRHash& Hash) const;\n};\n\n/// DeclStmt - Adaptor class for mixing declarations with statements and\n/// expressions. For example, CompoundStmt mixes statements, expressions\n/// and declarations (variables, types). Another example is ForStmt, where\n/// the first statement can be an expression or a declaration.\nclass DeclStmt : public Stmt {\n  DeclGroupRef DG;\n  SourceLocation StartLoc, EndLoc;\n\npublic:\n  DeclStmt(DeclGroupRef dg, SourceLocation startLoc, SourceLocation endLoc)\n      : Stmt(DeclStmtClass), DG(dg), StartLoc(startLoc), EndLoc(endLoc) {}\n\n  /// Build an empty declaration statement.\n  explicit DeclStmt(EmptyShell Empty) : Stmt(DeclStmtClass, Empty) {}\n\n  /// isSingleDecl - This method returns true if this DeclStmt refers\n  /// to a single Decl.\n  bool isSingleDecl() const { return DG.isSingleDecl(); }\n\n  const Decl *getSingleDecl() const { return DG.getSingleDecl(); }\n  Decl *getSingleDecl() { return DG.getSingleDecl(); }\n\n  const DeclGroupRef getDeclGroup() const { return DG; }\n  DeclGroupRef getDeclGroup() { return DG; }\n  void setDeclGroup(DeclGroupRef DGR) { DG = DGR; }\n\n  void setStartLoc(SourceLocation L) { StartLoc = L; }\n  SourceLocation getEndLoc() const { return EndLoc; }\n  void setEndLoc(SourceLocation L) { EndLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return StartLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == DeclStmtClass;\n  }\n\n  // Iterators over subexpressions.\n  child_range children() {\n    return child_range(child_iterator(DG.begin(), DG.end()),\n                       child_iterator(DG.end(), DG.end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<DeclStmt *>(this)->children();\n    return const_child_range(Children);\n  }\n\n  using decl_iterator = DeclGroupRef::iterator;\n  using const_decl_iterator = DeclGroupRef::const_iterator;\n  using decl_range = llvm::iterator_range<decl_iterator>;\n  using decl_const_range = llvm::iterator_range<const_decl_iterator>;\n\n  decl_range decls() { return decl_range(decl_begin(), decl_end()); }\n\n  decl_const_range decls() const {\n    return decl_const_range(decl_begin(), decl_end());\n  }\n\n  decl_iterator decl_begin() { return DG.begin(); }\n  decl_iterator decl_end() { return DG.end(); }\n  const_decl_iterator decl_begin() const { return DG.begin(); }\n  const_decl_iterator decl_end() const { return DG.end(); }\n\n  using reverse_decl_iterator = std::reverse_iterator<decl_iterator>;\n\n  reverse_decl_iterator decl_rbegin() {\n    return reverse_decl_iterator(decl_end());\n  }\n\n  reverse_decl_iterator decl_rend() {\n    return reverse_decl_iterator(decl_begin());\n  }\n};\n\n/// NullStmt - This is the null statement \";\": C99 6.8.3p3.\n///\nclass NullStmt : public Stmt {\npublic:\n  NullStmt(SourceLocation L, bool hasLeadingEmptyMacro = false)\n      : Stmt(NullStmtClass) {\n    NullStmtBits.HasLeadingEmptyMacro = hasLeadingEmptyMacro;\n    setSemiLoc(L);\n  }\n\n  /// Build an empty null statement.\n  explicit NullStmt(EmptyShell Empty) : Stmt(NullStmtClass, Empty) {}\n\n  SourceLocation getSemiLoc() const { return NullStmtBits.SemiLoc; }\n  void setSemiLoc(SourceLocation L) { NullStmtBits.SemiLoc = L; }\n\n  bool hasLeadingEmptyMacro() const {\n    return NullStmtBits.HasLeadingEmptyMacro;\n  }\n\n  SourceLocation getBeginLoc() const { return getSemiLoc(); }\n  SourceLocation getEndLoc() const { return getSemiLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == NullStmtClass;\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// CompoundStmt - This represents a group of statements like { stmt stmt }.\nclass CompoundStmt final : public Stmt,\n                           private llvm::TrailingObjects<CompoundStmt, Stmt *> {\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  /// The location of the closing \"}\". LBraceLoc is stored in CompoundStmtBits.\n  SourceLocation RBraceLoc;\n\n  CompoundStmt(ArrayRef<Stmt *> Stmts, SourceLocation LB, SourceLocation RB);\n  explicit CompoundStmt(EmptyShell Empty) : Stmt(CompoundStmtClass, Empty) {}\n\n  void setStmts(ArrayRef<Stmt *> Stmts);\n\npublic:\n  static CompoundStmt *Create(const ASTContext &C, ArrayRef<Stmt *> Stmts,\n                              SourceLocation LB, SourceLocation RB);\n\n  // Build an empty compound statement with a location.\n  explicit CompoundStmt(SourceLocation Loc)\n      : Stmt(CompoundStmtClass), RBraceLoc(Loc) {\n    CompoundStmtBits.NumStmts = 0;\n    CompoundStmtBits.LBraceLoc = Loc;\n  }\n\n  // Build an empty compound statement.\n  static CompoundStmt *CreateEmpty(const ASTContext &C, unsigned NumStmts);\n\n  bool body_empty() const { return CompoundStmtBits.NumStmts == 0; }\n  unsigned size() const { return CompoundStmtBits.NumStmts; }\n\n  using body_iterator = Stmt **;\n  using body_range = llvm::iterator_range<body_iterator>;\n\n  body_range body() { return body_range(body_begin(), body_end()); }\n  body_iterator body_begin() { return getTrailingObjects<Stmt *>(); }\n  body_iterator body_end() { return body_begin() + size(); }\n  Stmt *body_front() { return !body_empty() ? body_begin()[0] : nullptr; }\n\n  Stmt *body_back() {\n    return !body_empty() ? body_begin()[size() - 1] : nullptr;\n  }\n\n  using const_body_iterator = Stmt *const *;\n  using body_const_range = llvm::iterator_range<const_body_iterator>;\n\n  body_const_range body() const {\n    return body_const_range(body_begin(), body_end());\n  }\n\n  const_body_iterator body_begin() const {\n    return getTrailingObjects<Stmt *>();\n  }\n\n  const_body_iterator body_end() const { return body_begin() + size(); }\n\n  const Stmt *body_front() const {\n    return !body_empty() ? body_begin()[0] : nullptr;\n  }\n\n  const Stmt *body_back() const {\n    return !body_empty() ? body_begin()[size() - 1] : nullptr;\n  }\n\n  using reverse_body_iterator = std::reverse_iterator<body_iterator>;\n\n  reverse_body_iterator body_rbegin() {\n    return reverse_body_iterator(body_end());\n  }\n\n  reverse_body_iterator body_rend() {\n    return reverse_body_iterator(body_begin());\n  }\n\n  using const_reverse_body_iterator =\n      std::reverse_iterator<const_body_iterator>;\n\n  const_reverse_body_iterator body_rbegin() const {\n    return const_reverse_body_iterator(body_end());\n  }\n\n  const_reverse_body_iterator body_rend() const {\n    return const_reverse_body_iterator(body_begin());\n  }\n\n  // Get the Stmt that StmtExpr would consider to be the result of this\n  // compound statement. This is used by StmtExpr to properly emulate the GCC\n  // compound expression extension, which ignores trailing NullStmts when\n  // getting the result of the expression.\n  // i.e. ({ 5;;; })\n  //           ^^ ignored\n  // If we don't find something that isn't a NullStmt, just return the last\n  // Stmt.\n  Stmt *getStmtExprResult() {\n    for (auto *B : llvm::reverse(body())) {\n      if (!isa<NullStmt>(B))\n        return B;\n    }\n    return body_back();\n  }\n\n  const Stmt *getStmtExprResult() const {\n    return const_cast<CompoundStmt *>(this)->getStmtExprResult();\n  }\n\n  SourceLocation getBeginLoc() const { return CompoundStmtBits.LBraceLoc; }\n  SourceLocation getEndLoc() const { return RBraceLoc; }\n\n  SourceLocation getLBracLoc() const { return CompoundStmtBits.LBraceLoc; }\n  SourceLocation getRBracLoc() const { return RBraceLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CompoundStmtClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(body_begin(), body_end()); }\n\n  const_child_range children() const {\n    return const_child_range(body_begin(), body_end());\n  }\n};\n\n// SwitchCase is the base class for CaseStmt and DefaultStmt,\nclass SwitchCase : public Stmt {\nprotected:\n  /// The location of the \":\".\n  SourceLocation ColonLoc;\n\n  // The location of the \"case\" or \"default\" keyword. Stored in SwitchCaseBits.\n  // SourceLocation KeywordLoc;\n\n  /// A pointer to the following CaseStmt or DefaultStmt class,\n  /// used by SwitchStmt.\n  SwitchCase *NextSwitchCase = nullptr;\n\n  SwitchCase(StmtClass SC, SourceLocation KWLoc, SourceLocation ColonLoc)\n      : Stmt(SC), ColonLoc(ColonLoc) {\n    setKeywordLoc(KWLoc);\n  }\n\n  SwitchCase(StmtClass SC, EmptyShell) : Stmt(SC) {}\n\npublic:\n  const SwitchCase *getNextSwitchCase() const { return NextSwitchCase; }\n  SwitchCase *getNextSwitchCase() { return NextSwitchCase; }\n  void setNextSwitchCase(SwitchCase *SC) { NextSwitchCase = SC; }\n\n  SourceLocation getKeywordLoc() const { return SwitchCaseBits.KeywordLoc; }\n  void setKeywordLoc(SourceLocation L) { SwitchCaseBits.KeywordLoc = L; }\n  SourceLocation getColonLoc() const { return ColonLoc; }\n  void setColonLoc(SourceLocation L) { ColonLoc = L; }\n\n  inline Stmt *getSubStmt();\n  const Stmt *getSubStmt() const {\n    return const_cast<SwitchCase *>(this)->getSubStmt();\n  }\n\n  SourceLocation getBeginLoc() const { return getKeywordLoc(); }\n  inline SourceLocation getEndLoc() const LLVM_READONLY;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CaseStmtClass ||\n           T->getStmtClass() == DefaultStmtClass;\n  }\n};\n\n/// CaseStmt - Represent a case statement. It can optionally be a GNU case\n/// statement of the form LHS ... RHS representing a range of cases.\nclass CaseStmt final\n    : public SwitchCase,\n      private llvm::TrailingObjects<CaseStmt, Stmt *, SourceLocation> {\n  friend TrailingObjects;\n\n  // CaseStmt is followed by several trailing objects, some of which optional.\n  // Note that it would be more convenient to put the optional trailing objects\n  // at the end but this would impact children().\n  // The trailing objects are in order:\n  //\n  // * A \"Stmt *\" for the LHS of the case statement. Always present.\n  //\n  // * A \"Stmt *\" for the RHS of the case statement. This is a GNU extension\n  //   which allow ranges in cases statement of the form LHS ... RHS.\n  //   Present if and only if caseStmtIsGNURange() is true.\n  //\n  // * A \"Stmt *\" for the substatement of the case statement. Always present.\n  //\n  // * A SourceLocation for the location of the ... if this is a case statement\n  //   with a range. Present if and only if caseStmtIsGNURange() is true.\n  enum { LhsOffset = 0, SubStmtOffsetFromRhs = 1 };\n  enum { NumMandatoryStmtPtr = 2 };\n\n  unsigned numTrailingObjects(OverloadToken<Stmt *>) const {\n    return NumMandatoryStmtPtr + caseStmtIsGNURange();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<SourceLocation>) const {\n    return caseStmtIsGNURange();\n  }\n\n  unsigned lhsOffset() const { return LhsOffset; }\n  unsigned rhsOffset() const { return LhsOffset + caseStmtIsGNURange(); }\n  unsigned subStmtOffset() const { return rhsOffset() + SubStmtOffsetFromRhs; }\n\n  /// Build a case statement assuming that the storage for the\n  /// trailing objects has been properly allocated.\n  CaseStmt(Expr *lhs, Expr *rhs, SourceLocation caseLoc,\n           SourceLocation ellipsisLoc, SourceLocation colonLoc)\n      : SwitchCase(CaseStmtClass, caseLoc, colonLoc) {\n    // Handle GNU case statements of the form LHS ... RHS.\n    bool IsGNURange = rhs != nullptr;\n    SwitchCaseBits.CaseStmtIsGNURange = IsGNURange;\n    setLHS(lhs);\n    setSubStmt(nullptr);\n    if (IsGNURange) {\n      setRHS(rhs);\n      setEllipsisLoc(ellipsisLoc);\n    }\n  }\n\n  /// Build an empty switch case statement.\n  explicit CaseStmt(EmptyShell Empty, bool CaseStmtIsGNURange)\n      : SwitchCase(CaseStmtClass, Empty) {\n    SwitchCaseBits.CaseStmtIsGNURange = CaseStmtIsGNURange;\n  }\n\npublic:\n  /// Build a case statement.\n  static CaseStmt *Create(const ASTContext &Ctx, Expr *lhs, Expr *rhs,\n                          SourceLocation caseLoc, SourceLocation ellipsisLoc,\n                          SourceLocation colonLoc);\n\n  /// Build an empty case statement.\n  static CaseStmt *CreateEmpty(const ASTContext &Ctx, bool CaseStmtIsGNURange);\n\n  /// True if this case statement is of the form case LHS ... RHS, which\n  /// is a GNU extension. In this case the RHS can be obtained with getRHS()\n  /// and the location of the ellipsis can be obtained with getEllipsisLoc().\n  bool caseStmtIsGNURange() const { return SwitchCaseBits.CaseStmtIsGNURange; }\n\n  SourceLocation getCaseLoc() const { return getKeywordLoc(); }\n  void setCaseLoc(SourceLocation L) { setKeywordLoc(L); }\n\n  /// Get the location of the ... in a case statement of the form LHS ... RHS.\n  SourceLocation getEllipsisLoc() const {\n    return caseStmtIsGNURange() ? *getTrailingObjects<SourceLocation>()\n                                : SourceLocation();\n  }\n\n  /// Set the location of the ... in a case statement of the form LHS ... RHS.\n  /// Assert that this case statement is of this form.\n  void setEllipsisLoc(SourceLocation L) {\n    assert(\n        caseStmtIsGNURange() &&\n        \"setEllipsisLoc but this is not a case stmt of the form LHS ... RHS!\");\n    *getTrailingObjects<SourceLocation>() = L;\n  }\n\n  Expr *getLHS() {\n    return reinterpret_cast<Expr *>(getTrailingObjects<Stmt *>()[lhsOffset()]);\n  }\n\n  const Expr *getLHS() const {\n    return reinterpret_cast<Expr *>(getTrailingObjects<Stmt *>()[lhsOffset()]);\n  }\n\n  void setLHS(Expr *Val) {\n    getTrailingObjects<Stmt *>()[lhsOffset()] = reinterpret_cast<Stmt *>(Val);\n  }\n\n  Expr *getRHS() {\n    return caseStmtIsGNURange() ? reinterpret_cast<Expr *>(\n                                      getTrailingObjects<Stmt *>()[rhsOffset()])\n                                : nullptr;\n  }\n\n  const Expr *getRHS() const {\n    return caseStmtIsGNURange() ? reinterpret_cast<Expr *>(\n                                      getTrailingObjects<Stmt *>()[rhsOffset()])\n                                : nullptr;\n  }\n\n  void setRHS(Expr *Val) {\n    assert(caseStmtIsGNURange() &&\n           \"setRHS but this is not a case stmt of the form LHS ... RHS!\");\n    getTrailingObjects<Stmt *>()[rhsOffset()] = reinterpret_cast<Stmt *>(Val);\n  }\n\n  Stmt *getSubStmt() { return getTrailingObjects<Stmt *>()[subStmtOffset()]; }\n  const Stmt *getSubStmt() const {\n    return getTrailingObjects<Stmt *>()[subStmtOffset()];\n  }\n\n  void setSubStmt(Stmt *S) {\n    getTrailingObjects<Stmt *>()[subStmtOffset()] = S;\n  }\n\n  SourceLocation getBeginLoc() const { return getKeywordLoc(); }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    // Handle deeply nested case statements with iteration instead of recursion.\n    const CaseStmt *CS = this;\n    while (const auto *CS2 = dyn_cast<CaseStmt>(CS->getSubStmt()))\n      CS = CS2;\n\n    return CS->getSubStmt()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CaseStmtClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(getTrailingObjects<Stmt *>(),\n                       getTrailingObjects<Stmt *>() +\n                           numTrailingObjects(OverloadToken<Stmt *>()));\n  }\n\n  const_child_range children() const {\n    return const_child_range(getTrailingObjects<Stmt *>(),\n                             getTrailingObjects<Stmt *>() +\n                                 numTrailingObjects(OverloadToken<Stmt *>()));\n  }\n};\n\nclass DefaultStmt : public SwitchCase {\n  Stmt *SubStmt;\n\npublic:\n  DefaultStmt(SourceLocation DL, SourceLocation CL, Stmt *substmt)\n      : SwitchCase(DefaultStmtClass, DL, CL), SubStmt(substmt) {}\n\n  /// Build an empty default statement.\n  explicit DefaultStmt(EmptyShell Empty)\n      : SwitchCase(DefaultStmtClass, Empty) {}\n\n  Stmt *getSubStmt() { return SubStmt; }\n  const Stmt *getSubStmt() const { return SubStmt; }\n  void setSubStmt(Stmt *S) { SubStmt = S; }\n\n  SourceLocation getDefaultLoc() const { return getKeywordLoc(); }\n  void setDefaultLoc(SourceLocation L) { setKeywordLoc(L); }\n\n  SourceLocation getBeginLoc() const { return getKeywordLoc(); }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return SubStmt->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == DefaultStmtClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&SubStmt, &SubStmt + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&SubStmt, &SubStmt + 1);\n  }\n};\n\nSourceLocation SwitchCase::getEndLoc() const {\n  if (const auto *CS = dyn_cast<CaseStmt>(this))\n    return CS->getEndLoc();\n  else if (const auto *DS = dyn_cast<DefaultStmt>(this))\n    return DS->getEndLoc();\n  llvm_unreachable(\"SwitchCase is neither a CaseStmt nor a DefaultStmt!\");\n}\n\nStmt *SwitchCase::getSubStmt() {\n  if (auto *CS = dyn_cast<CaseStmt>(this))\n    return CS->getSubStmt();\n  else if (auto *DS = dyn_cast<DefaultStmt>(this))\n    return DS->getSubStmt();\n  llvm_unreachable(\"SwitchCase is neither a CaseStmt nor a DefaultStmt!\");\n}\n\n/// Represents a statement that could possibly have a value and type. This\n/// covers expression-statements, as well as labels and attributed statements.\n///\n/// Value statements have a special meaning when they are the last non-null\n/// statement in a GNU statement expression, where they determine the value\n/// of the statement expression.\nclass ValueStmt : public Stmt {\nprotected:\n  using Stmt::Stmt;\n\npublic:\n  const Expr *getExprStmt() const;\n  Expr *getExprStmt() {\n    const ValueStmt *ConstThis = this;\n    return const_cast<Expr*>(ConstThis->getExprStmt());\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() >= firstValueStmtConstant &&\n           T->getStmtClass() <= lastValueStmtConstant;\n  }\n};\n\n/// LabelStmt - Represents a label, which has a substatement.  For example:\n///    foo: return;\nclass LabelStmt : public ValueStmt {\n  LabelDecl *TheDecl;\n  Stmt *SubStmt;\n\npublic:\n  /// Build a label statement.\n  LabelStmt(SourceLocation IL, LabelDecl *D, Stmt *substmt)\n      : ValueStmt(LabelStmtClass), TheDecl(D), SubStmt(substmt) {\n    setIdentLoc(IL);\n  }\n\n  /// Build an empty label statement.\n  explicit LabelStmt(EmptyShell Empty) : ValueStmt(LabelStmtClass, Empty) {}\n\n  SourceLocation getIdentLoc() const { return LabelStmtBits.IdentLoc; }\n  void setIdentLoc(SourceLocation L) { LabelStmtBits.IdentLoc = L; }\n\n  LabelDecl *getDecl() const { return TheDecl; }\n  void setDecl(LabelDecl *D) { TheDecl = D; }\n\n  const char *getName() const;\n  Stmt *getSubStmt() { return SubStmt; }\n\n  const Stmt *getSubStmt() const { return SubStmt; }\n  void setSubStmt(Stmt *SS) { SubStmt = SS; }\n\n  SourceLocation getBeginLoc() const { return getIdentLoc(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return SubStmt->getEndLoc();}\n\n  child_range children() { return child_range(&SubStmt, &SubStmt + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&SubStmt, &SubStmt + 1);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == LabelStmtClass;\n  }\n};\n\n/// Represents an attribute applied to a statement.\n///\n/// Represents an attribute applied to a statement. For example:\n///   [[omp::for(...)]] for (...) { ... }\nclass AttributedStmt final\n    : public ValueStmt,\n      private llvm::TrailingObjects<AttributedStmt, const Attr *> {\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  Stmt *SubStmt;\n\n  AttributedStmt(SourceLocation Loc, ArrayRef<const Attr *> Attrs,\n                 Stmt *SubStmt)\n      : ValueStmt(AttributedStmtClass), SubStmt(SubStmt) {\n    AttributedStmtBits.NumAttrs = Attrs.size();\n    AttributedStmtBits.AttrLoc = Loc;\n    std::copy(Attrs.begin(), Attrs.end(), getAttrArrayPtr());\n  }\n\n  explicit AttributedStmt(EmptyShell Empty, unsigned NumAttrs)\n      : ValueStmt(AttributedStmtClass, Empty) {\n    AttributedStmtBits.NumAttrs = NumAttrs;\n    AttributedStmtBits.AttrLoc = SourceLocation{};\n    std::fill_n(getAttrArrayPtr(), NumAttrs, nullptr);\n  }\n\n  const Attr *const *getAttrArrayPtr() const {\n    return getTrailingObjects<const Attr *>();\n  }\n  const Attr **getAttrArrayPtr() { return getTrailingObjects<const Attr *>(); }\n\npublic:\n  static AttributedStmt *Create(const ASTContext &C, SourceLocation Loc,\n                                ArrayRef<const Attr *> Attrs, Stmt *SubStmt);\n\n  // Build an empty attributed statement.\n  static AttributedStmt *CreateEmpty(const ASTContext &C, unsigned NumAttrs);\n\n  SourceLocation getAttrLoc() const { return AttributedStmtBits.AttrLoc; }\n  ArrayRef<const Attr *> getAttrs() const {\n    return llvm::makeArrayRef(getAttrArrayPtr(), AttributedStmtBits.NumAttrs);\n  }\n\n  Stmt *getSubStmt() { return SubStmt; }\n  const Stmt *getSubStmt() const { return SubStmt; }\n\n  SourceLocation getBeginLoc() const { return getAttrLoc(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return SubStmt->getEndLoc();}\n\n  child_range children() { return child_range(&SubStmt, &SubStmt + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&SubStmt, &SubStmt + 1);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == AttributedStmtClass;\n  }\n};\n\n/// IfStmt - This represents an if/then/else.\nclass IfStmt final\n    : public Stmt,\n      private llvm::TrailingObjects<IfStmt, Stmt *, SourceLocation> {\n  friend TrailingObjects;\n\n  // IfStmt is followed by several trailing objects, some of which optional.\n  // Note that it would be more convenient to put the optional trailing\n  // objects at then end but this would change the order of the children.\n  // The trailing objects are in order:\n  //\n  // * A \"Stmt *\" for the init statement.\n  //    Present if and only if hasInitStorage().\n  //\n  // * A \"Stmt *\" for the condition variable.\n  //    Present if and only if hasVarStorage(). This is in fact a \"DeclStmt *\".\n  //\n  // * A \"Stmt *\" for the condition.\n  //    Always present. This is in fact a \"Expr *\".\n  //\n  // * A \"Stmt *\" for the then statement.\n  //    Always present.\n  //\n  // * A \"Stmt *\" for the else statement.\n  //    Present if and only if hasElseStorage().\n  //\n  // * A \"SourceLocation\" for the location of the \"else\".\n  //    Present if and only if hasElseStorage().\n  enum { InitOffset = 0, ThenOffsetFromCond = 1, ElseOffsetFromCond = 2 };\n  enum { NumMandatoryStmtPtr = 2 };\n  SourceLocation LParenLoc;\n  SourceLocation RParenLoc;\n\n  unsigned numTrailingObjects(OverloadToken<Stmt *>) const {\n    return NumMandatoryStmtPtr + hasElseStorage() + hasVarStorage() +\n           hasInitStorage();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<SourceLocation>) const {\n    return hasElseStorage();\n  }\n\n  unsigned initOffset() const { return InitOffset; }\n  unsigned varOffset() const { return InitOffset + hasInitStorage(); }\n  unsigned condOffset() const {\n    return InitOffset + hasInitStorage() + hasVarStorage();\n  }\n  unsigned thenOffset() const { return condOffset() + ThenOffsetFromCond; }\n  unsigned elseOffset() const { return condOffset() + ElseOffsetFromCond; }\n\n  /// Build an if/then/else statement.\n  IfStmt(const ASTContext &Ctx, SourceLocation IL, bool IsConstexpr, Stmt *Init,\n         VarDecl *Var, Expr *Cond, SourceLocation LParenLoc,\n         SourceLocation RParenLoc, Stmt *Then, SourceLocation EL, Stmt *Else);\n\n  /// Build an empty if/then/else statement.\n  explicit IfStmt(EmptyShell Empty, bool HasElse, bool HasVar, bool HasInit);\n\npublic:\n  /// Create an IfStmt.\n  static IfStmt *Create(const ASTContext &Ctx, SourceLocation IL,\n                        bool IsConstexpr, Stmt *Init, VarDecl *Var, Expr *Cond,\n                        SourceLocation LPL, SourceLocation RPL, Stmt *Then,\n                        SourceLocation EL = SourceLocation(),\n                        Stmt *Else = nullptr);\n\n  /// Create an empty IfStmt optionally with storage for an else statement,\n  /// condition variable and init expression.\n  static IfStmt *CreateEmpty(const ASTContext &Ctx, bool HasElse, bool HasVar,\n                             bool HasInit);\n\n  /// True if this IfStmt has the storage for an init statement.\n  bool hasInitStorage() const { return IfStmtBits.HasInit; }\n\n  /// True if this IfStmt has storage for a variable declaration.\n  bool hasVarStorage() const { return IfStmtBits.HasVar; }\n\n  /// True if this IfStmt has storage for an else statement.\n  bool hasElseStorage() const { return IfStmtBits.HasElse; }\n\n  Expr *getCond() {\n    return reinterpret_cast<Expr *>(getTrailingObjects<Stmt *>()[condOffset()]);\n  }\n\n  const Expr *getCond() const {\n    return reinterpret_cast<Expr *>(getTrailingObjects<Stmt *>()[condOffset()]);\n  }\n\n  void setCond(Expr *Cond) {\n    getTrailingObjects<Stmt *>()[condOffset()] = reinterpret_cast<Stmt *>(Cond);\n  }\n\n  Stmt *getThen() { return getTrailingObjects<Stmt *>()[thenOffset()]; }\n  const Stmt *getThen() const {\n    return getTrailingObjects<Stmt *>()[thenOffset()];\n  }\n\n  void setThen(Stmt *Then) {\n    getTrailingObjects<Stmt *>()[thenOffset()] = Then;\n  }\n\n  Stmt *getElse() {\n    return hasElseStorage() ? getTrailingObjects<Stmt *>()[elseOffset()]\n                            : nullptr;\n  }\n\n  const Stmt *getElse() const {\n    return hasElseStorage() ? getTrailingObjects<Stmt *>()[elseOffset()]\n                            : nullptr;\n  }\n\n  void setElse(Stmt *Else) {\n    assert(hasElseStorage() &&\n           \"This if statement has no storage for an else statement!\");\n    getTrailingObjects<Stmt *>()[elseOffset()] = Else;\n  }\n\n  /// Retrieve the variable declared in this \"if\" statement, if any.\n  ///\n  /// In the following example, \"x\" is the condition variable.\n  /// \\code\n  /// if (int x = foo()) {\n  ///   printf(\"x is %d\", x);\n  /// }\n  /// \\endcode\n  VarDecl *getConditionVariable();\n  const VarDecl *getConditionVariable() const {\n    return const_cast<IfStmt *>(this)->getConditionVariable();\n  }\n\n  /// Set the condition variable for this if statement.\n  /// The if statement must have storage for the condition variable.\n  void setConditionVariable(const ASTContext &Ctx, VarDecl *V);\n\n  /// If this IfStmt has a condition variable, return the faux DeclStmt\n  /// associated with the creation of that condition variable.\n  DeclStmt *getConditionVariableDeclStmt() {\n    return hasVarStorage() ? static_cast<DeclStmt *>(\n                                 getTrailingObjects<Stmt *>()[varOffset()])\n                           : nullptr;\n  }\n\n  const DeclStmt *getConditionVariableDeclStmt() const {\n    return hasVarStorage() ? static_cast<DeclStmt *>(\n                                 getTrailingObjects<Stmt *>()[varOffset()])\n                           : nullptr;\n  }\n\n  Stmt *getInit() {\n    return hasInitStorage() ? getTrailingObjects<Stmt *>()[initOffset()]\n                            : nullptr;\n  }\n\n  const Stmt *getInit() const {\n    return hasInitStorage() ? getTrailingObjects<Stmt *>()[initOffset()]\n                            : nullptr;\n  }\n\n  void setInit(Stmt *Init) {\n    assert(hasInitStorage() &&\n           \"This if statement has no storage for an init statement!\");\n    getTrailingObjects<Stmt *>()[initOffset()] = Init;\n  }\n\n  SourceLocation getIfLoc() const { return IfStmtBits.IfLoc; }\n  void setIfLoc(SourceLocation IfLoc) { IfStmtBits.IfLoc = IfLoc; }\n\n  SourceLocation getElseLoc() const {\n    return hasElseStorage() ? *getTrailingObjects<SourceLocation>()\n                            : SourceLocation();\n  }\n\n  void setElseLoc(SourceLocation ElseLoc) {\n    assert(hasElseStorage() &&\n           \"This if statement has no storage for an else statement!\");\n    *getTrailingObjects<SourceLocation>() = ElseLoc;\n  }\n\n  bool isConstexpr() const { return IfStmtBits.IsConstexpr; }\n  void setConstexpr(bool C) { IfStmtBits.IsConstexpr = C; }\n\n  /// If this is an 'if constexpr', determine which substatement will be taken.\n  /// Otherwise, or if the condition is value-dependent, returns None.\n  Optional<const Stmt*> getNondiscardedCase(const ASTContext &Ctx) const;\n\n  bool isObjCAvailabilityCheck() const;\n\n  SourceLocation getBeginLoc() const { return getIfLoc(); }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    if (getElse())\n      return getElse()->getEndLoc();\n    return getThen()->getEndLoc();\n  }\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation Loc) { RParenLoc = Loc; }\n\n  // Iterators over subexpressions.  The iterators will include iterating\n  // over the initialization expression referenced by the condition variable.\n  child_range children() {\n    return child_range(getTrailingObjects<Stmt *>(),\n                       getTrailingObjects<Stmt *>() +\n                           numTrailingObjects(OverloadToken<Stmt *>()));\n  }\n\n  const_child_range children() const {\n    return const_child_range(getTrailingObjects<Stmt *>(),\n                             getTrailingObjects<Stmt *>() +\n                                 numTrailingObjects(OverloadToken<Stmt *>()));\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == IfStmtClass;\n  }\n};\n\n/// SwitchStmt - This represents a 'switch' stmt.\nclass SwitchStmt final : public Stmt,\n                         private llvm::TrailingObjects<SwitchStmt, Stmt *> {\n  friend TrailingObjects;\n\n  /// Points to a linked list of case and default statements.\n  SwitchCase *FirstCase = nullptr;\n\n  // SwitchStmt is followed by several trailing objects,\n  // some of which optional. Note that it would be more convenient to\n  // put the optional trailing objects at the end but this would change\n  // the order in children().\n  // The trailing objects are in order:\n  //\n  // * A \"Stmt *\" for the init statement.\n  //    Present if and only if hasInitStorage().\n  //\n  // * A \"Stmt *\" for the condition variable.\n  //    Present if and only if hasVarStorage(). This is in fact a \"DeclStmt *\".\n  //\n  // * A \"Stmt *\" for the condition.\n  //    Always present. This is in fact an \"Expr *\".\n  //\n  // * A \"Stmt *\" for the body.\n  //    Always present.\n  enum { InitOffset = 0, BodyOffsetFromCond = 1 };\n  enum { NumMandatoryStmtPtr = 2 };\n  SourceLocation LParenLoc;\n  SourceLocation RParenLoc;\n\n  unsigned numTrailingObjects(OverloadToken<Stmt *>) const {\n    return NumMandatoryStmtPtr + hasInitStorage() + hasVarStorage();\n  }\n\n  unsigned initOffset() const { return InitOffset; }\n  unsigned varOffset() const { return InitOffset + hasInitStorage(); }\n  unsigned condOffset() const {\n    return InitOffset + hasInitStorage() + hasVarStorage();\n  }\n  unsigned bodyOffset() const { return condOffset() + BodyOffsetFromCond; }\n\n  /// Build a switch statement.\n  SwitchStmt(const ASTContext &Ctx, Stmt *Init, VarDecl *Var, Expr *Cond,\n             SourceLocation LParenLoc, SourceLocation RParenLoc);\n\n  /// Build a empty switch statement.\n  explicit SwitchStmt(EmptyShell Empty, bool HasInit, bool HasVar);\n\npublic:\n  /// Create a switch statement.\n  static SwitchStmt *Create(const ASTContext &Ctx, Stmt *Init, VarDecl *Var,\n                            Expr *Cond, SourceLocation LParenLoc,\n                            SourceLocation RParenLoc);\n\n  /// Create an empty switch statement optionally with storage for\n  /// an init expression and a condition variable.\n  static SwitchStmt *CreateEmpty(const ASTContext &Ctx, bool HasInit,\n                                 bool HasVar);\n\n  /// True if this SwitchStmt has storage for an init statement.\n  bool hasInitStorage() const { return SwitchStmtBits.HasInit; }\n\n  /// True if this SwitchStmt has storage for a condition variable.\n  bool hasVarStorage() const { return SwitchStmtBits.HasVar; }\n\n  Expr *getCond() {\n    return reinterpret_cast<Expr *>(getTrailingObjects<Stmt *>()[condOffset()]);\n  }\n\n  const Expr *getCond() const {\n    return reinterpret_cast<Expr *>(getTrailingObjects<Stmt *>()[condOffset()]);\n  }\n\n  void setCond(Expr *Cond) {\n    getTrailingObjects<Stmt *>()[condOffset()] = reinterpret_cast<Stmt *>(Cond);\n  }\n\n  Stmt *getBody() { return getTrailingObjects<Stmt *>()[bodyOffset()]; }\n  const Stmt *getBody() const {\n    return getTrailingObjects<Stmt *>()[bodyOffset()];\n  }\n\n  void setBody(Stmt *Body) {\n    getTrailingObjects<Stmt *>()[bodyOffset()] = Body;\n  }\n\n  Stmt *getInit() {\n    return hasInitStorage() ? getTrailingObjects<Stmt *>()[initOffset()]\n                            : nullptr;\n  }\n\n  const Stmt *getInit() const {\n    return hasInitStorage() ? getTrailingObjects<Stmt *>()[initOffset()]\n                            : nullptr;\n  }\n\n  void setInit(Stmt *Init) {\n    assert(hasInitStorage() &&\n           \"This switch statement has no storage for an init statement!\");\n    getTrailingObjects<Stmt *>()[initOffset()] = Init;\n  }\n\n  /// Retrieve the variable declared in this \"switch\" statement, if any.\n  ///\n  /// In the following example, \"x\" is the condition variable.\n  /// \\code\n  /// switch (int x = foo()) {\n  ///   case 0: break;\n  ///   // ...\n  /// }\n  /// \\endcode\n  VarDecl *getConditionVariable();\n  const VarDecl *getConditionVariable() const {\n    return const_cast<SwitchStmt *>(this)->getConditionVariable();\n  }\n\n  /// Set the condition variable in this switch statement.\n  /// The switch statement must have storage for it.\n  void setConditionVariable(const ASTContext &Ctx, VarDecl *VD);\n\n  /// If this SwitchStmt has a condition variable, return the faux DeclStmt\n  /// associated with the creation of that condition variable.\n  DeclStmt *getConditionVariableDeclStmt() {\n    return hasVarStorage() ? static_cast<DeclStmt *>(\n                                 getTrailingObjects<Stmt *>()[varOffset()])\n                           : nullptr;\n  }\n\n  const DeclStmt *getConditionVariableDeclStmt() const {\n    return hasVarStorage() ? static_cast<DeclStmt *>(\n                                 getTrailingObjects<Stmt *>()[varOffset()])\n                           : nullptr;\n  }\n\n  SwitchCase *getSwitchCaseList() { return FirstCase; }\n  const SwitchCase *getSwitchCaseList() const { return FirstCase; }\n  void setSwitchCaseList(SwitchCase *SC) { FirstCase = SC; }\n\n  SourceLocation getSwitchLoc() const { return SwitchStmtBits.SwitchLoc; }\n  void setSwitchLoc(SourceLocation L) { SwitchStmtBits.SwitchLoc = L; }\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation Loc) { RParenLoc = Loc; }\n\n  void setBody(Stmt *S, SourceLocation SL) {\n    setBody(S);\n    setSwitchLoc(SL);\n  }\n\n  void addSwitchCase(SwitchCase *SC) {\n    assert(!SC->getNextSwitchCase() &&\n           \"case/default already added to a switch\");\n    SC->setNextSwitchCase(FirstCase);\n    FirstCase = SC;\n  }\n\n  /// Set a flag in the SwitchStmt indicating that if the 'switch (X)' is a\n  /// switch over an enum value then all cases have been explicitly covered.\n  void setAllEnumCasesCovered() { SwitchStmtBits.AllEnumCasesCovered = true; }\n\n  /// Returns true if the SwitchStmt is a switch of an enum value and all cases\n  /// have been explicitly covered.\n  bool isAllEnumCasesCovered() const {\n    return SwitchStmtBits.AllEnumCasesCovered;\n  }\n\n  SourceLocation getBeginLoc() const { return getSwitchLoc(); }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getBody() ? getBody()->getEndLoc()\n                     : reinterpret_cast<const Stmt *>(getCond())->getEndLoc();\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(getTrailingObjects<Stmt *>(),\n                       getTrailingObjects<Stmt *>() +\n                           numTrailingObjects(OverloadToken<Stmt *>()));\n  }\n\n  const_child_range children() const {\n    return const_child_range(getTrailingObjects<Stmt *>(),\n                             getTrailingObjects<Stmt *>() +\n                                 numTrailingObjects(OverloadToken<Stmt *>()));\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == SwitchStmtClass;\n  }\n};\n\n/// WhileStmt - This represents a 'while' stmt.\nclass WhileStmt final : public Stmt,\n                        private llvm::TrailingObjects<WhileStmt, Stmt *> {\n  friend TrailingObjects;\n\n  // WhileStmt is followed by several trailing objects,\n  // some of which optional. Note that it would be more\n  // convenient to put the optional trailing object at the end\n  // but this would affect children().\n  // The trailing objects are in order:\n  //\n  // * A \"Stmt *\" for the condition variable.\n  //    Present if and only if hasVarStorage(). This is in fact a \"DeclStmt *\".\n  //\n  // * A \"Stmt *\" for the condition.\n  //    Always present. This is in fact an \"Expr *\".\n  //\n  // * A \"Stmt *\" for the body.\n  //    Always present.\n  //\n  enum { VarOffset = 0, BodyOffsetFromCond = 1 };\n  enum { NumMandatoryStmtPtr = 2 };\n\n  SourceLocation LParenLoc, RParenLoc;\n\n  unsigned varOffset() const { return VarOffset; }\n  unsigned condOffset() const { return VarOffset + hasVarStorage(); }\n  unsigned bodyOffset() const { return condOffset() + BodyOffsetFromCond; }\n\n  unsigned numTrailingObjects(OverloadToken<Stmt *>) const {\n    return NumMandatoryStmtPtr + hasVarStorage();\n  }\n\n  /// Build a while statement.\n  WhileStmt(const ASTContext &Ctx, VarDecl *Var, Expr *Cond, Stmt *Body,\n            SourceLocation WL, SourceLocation LParenLoc,\n            SourceLocation RParenLoc);\n\n  /// Build an empty while statement.\n  explicit WhileStmt(EmptyShell Empty, bool HasVar);\n\npublic:\n  /// Create a while statement.\n  static WhileStmt *Create(const ASTContext &Ctx, VarDecl *Var, Expr *Cond,\n                           Stmt *Body, SourceLocation WL,\n                           SourceLocation LParenLoc, SourceLocation RParenLoc);\n\n  /// Create an empty while statement optionally with storage for\n  /// a condition variable.\n  static WhileStmt *CreateEmpty(const ASTContext &Ctx, bool HasVar);\n\n  /// True if this WhileStmt has storage for a condition variable.\n  bool hasVarStorage() const { return WhileStmtBits.HasVar; }\n\n  Expr *getCond() {\n    return reinterpret_cast<Expr *>(getTrailingObjects<Stmt *>()[condOffset()]);\n  }\n\n  const Expr *getCond() const {\n    return reinterpret_cast<Expr *>(getTrailingObjects<Stmt *>()[condOffset()]);\n  }\n\n  void setCond(Expr *Cond) {\n    getTrailingObjects<Stmt *>()[condOffset()] = reinterpret_cast<Stmt *>(Cond);\n  }\n\n  Stmt *getBody() { return getTrailingObjects<Stmt *>()[bodyOffset()]; }\n  const Stmt *getBody() const {\n    return getTrailingObjects<Stmt *>()[bodyOffset()];\n  }\n\n  void setBody(Stmt *Body) {\n    getTrailingObjects<Stmt *>()[bodyOffset()] = Body;\n  }\n\n  /// Retrieve the variable declared in this \"while\" statement, if any.\n  ///\n  /// In the following example, \"x\" is the condition variable.\n  /// \\code\n  /// while (int x = random()) {\n  ///   // ...\n  /// }\n  /// \\endcode\n  VarDecl *getConditionVariable();\n  const VarDecl *getConditionVariable() const {\n    return const_cast<WhileStmt *>(this)->getConditionVariable();\n  }\n\n  /// Set the condition variable of this while statement.\n  /// The while statement must have storage for it.\n  void setConditionVariable(const ASTContext &Ctx, VarDecl *V);\n\n  /// If this WhileStmt has a condition variable, return the faux DeclStmt\n  /// associated with the creation of that condition variable.\n  DeclStmt *getConditionVariableDeclStmt() {\n    return hasVarStorage() ? static_cast<DeclStmt *>(\n                                 getTrailingObjects<Stmt *>()[varOffset()])\n                           : nullptr;\n  }\n\n  const DeclStmt *getConditionVariableDeclStmt() const {\n    return hasVarStorage() ? static_cast<DeclStmt *>(\n                                 getTrailingObjects<Stmt *>()[varOffset()])\n                           : nullptr;\n  }\n\n  SourceLocation getWhileLoc() const { return WhileStmtBits.WhileLoc; }\n  void setWhileLoc(SourceLocation L) { WhileStmtBits.WhileLoc = L; }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  void setLParenLoc(SourceLocation L) { LParenLoc = L; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const { return getWhileLoc(); }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getBody()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == WhileStmtClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(getTrailingObjects<Stmt *>(),\n                       getTrailingObjects<Stmt *>() +\n                           numTrailingObjects(OverloadToken<Stmt *>()));\n  }\n\n  const_child_range children() const {\n    return const_child_range(getTrailingObjects<Stmt *>(),\n                             getTrailingObjects<Stmt *>() +\n                                 numTrailingObjects(OverloadToken<Stmt *>()));\n  }\n};\n\n/// DoStmt - This represents a 'do/while' stmt.\nclass DoStmt : public Stmt {\n  enum { BODY, COND, END_EXPR };\n  Stmt *SubExprs[END_EXPR];\n  SourceLocation WhileLoc;\n  SourceLocation RParenLoc; // Location of final ')' in do stmt condition.\n\npublic:\n  DoStmt(Stmt *Body, Expr *Cond, SourceLocation DL, SourceLocation WL,\n         SourceLocation RP)\n      : Stmt(DoStmtClass), WhileLoc(WL), RParenLoc(RP) {\n    setCond(Cond);\n    setBody(Body);\n    setDoLoc(DL);\n  }\n\n  /// Build an empty do-while statement.\n  explicit DoStmt(EmptyShell Empty) : Stmt(DoStmtClass, Empty) {}\n\n  Expr *getCond() { return reinterpret_cast<Expr *>(SubExprs[COND]); }\n  const Expr *getCond() const {\n    return reinterpret_cast<Expr *>(SubExprs[COND]);\n  }\n\n  void setCond(Expr *Cond) { SubExprs[COND] = reinterpret_cast<Stmt *>(Cond); }\n\n  Stmt *getBody() { return SubExprs[BODY]; }\n  const Stmt *getBody() const { return SubExprs[BODY]; }\n  void setBody(Stmt *Body) { SubExprs[BODY] = Body; }\n\n  SourceLocation getDoLoc() const { return DoStmtBits.DoLoc; }\n  void setDoLoc(SourceLocation L) { DoStmtBits.DoLoc = L; }\n  SourceLocation getWhileLoc() const { return WhileLoc; }\n  void setWhileLoc(SourceLocation L) { WhileLoc = L; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const { return getDoLoc(); }\n  SourceLocation getEndLoc() const { return getRParenLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == DoStmtClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n};\n\n/// ForStmt - This represents a 'for (init;cond;inc)' stmt.  Note that any of\n/// the init/cond/inc parts of the ForStmt will be null if they were not\n/// specified in the source.\nclass ForStmt : public Stmt {\n  enum { INIT, CONDVAR, COND, INC, BODY, END_EXPR };\n  Stmt* SubExprs[END_EXPR]; // SubExprs[INIT] is an expression or declstmt.\n  SourceLocation LParenLoc, RParenLoc;\n\npublic:\n  ForStmt(const ASTContext &C, Stmt *Init, Expr *Cond, VarDecl *condVar,\n          Expr *Inc, Stmt *Body, SourceLocation FL, SourceLocation LP,\n          SourceLocation RP);\n\n  /// Build an empty for statement.\n  explicit ForStmt(EmptyShell Empty) : Stmt(ForStmtClass, Empty) {}\n\n  Stmt *getInit() { return SubExprs[INIT]; }\n\n  /// Retrieve the variable declared in this \"for\" statement, if any.\n  ///\n  /// In the following example, \"y\" is the condition variable.\n  /// \\code\n  /// for (int x = random(); int y = mangle(x); ++x) {\n  ///   // ...\n  /// }\n  /// \\endcode\n  VarDecl *getConditionVariable() const;\n  void setConditionVariable(const ASTContext &C, VarDecl *V);\n\n  /// If this ForStmt has a condition variable, return the faux DeclStmt\n  /// associated with the creation of that condition variable.\n  const DeclStmt *getConditionVariableDeclStmt() const {\n    return reinterpret_cast<DeclStmt*>(SubExprs[CONDVAR]);\n  }\n\n  Expr *getCond() { return reinterpret_cast<Expr*>(SubExprs[COND]); }\n  Expr *getInc()  { return reinterpret_cast<Expr*>(SubExprs[INC]); }\n  Stmt *getBody() { return SubExprs[BODY]; }\n\n  const Stmt *getInit() const { return SubExprs[INIT]; }\n  const Expr *getCond() const { return reinterpret_cast<Expr*>(SubExprs[COND]);}\n  const Expr *getInc()  const { return reinterpret_cast<Expr*>(SubExprs[INC]); }\n  const Stmt *getBody() const { return SubExprs[BODY]; }\n\n  void setInit(Stmt *S) { SubExprs[INIT] = S; }\n  void setCond(Expr *E) { SubExprs[COND] = reinterpret_cast<Stmt*>(E); }\n  void setInc(Expr *E) { SubExprs[INC] = reinterpret_cast<Stmt*>(E); }\n  void setBody(Stmt *S) { SubExprs[BODY] = S; }\n\n  SourceLocation getForLoc() const { return ForStmtBits.ForLoc; }\n  void setForLoc(SourceLocation L) { ForStmtBits.ForLoc = L; }\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  void setLParenLoc(SourceLocation L) { LParenLoc = L; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const { return getForLoc(); }\n  SourceLocation getEndLoc() const { return getBody()->getEndLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ForStmtClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0]+END_EXPR);\n  }\n\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n};\n\n/// GotoStmt - This represents a direct goto.\nclass GotoStmt : public Stmt {\n  LabelDecl *Label;\n  SourceLocation LabelLoc;\n\npublic:\n  GotoStmt(LabelDecl *label, SourceLocation GL, SourceLocation LL)\n      : Stmt(GotoStmtClass), Label(label), LabelLoc(LL) {\n    setGotoLoc(GL);\n  }\n\n  /// Build an empty goto statement.\n  explicit GotoStmt(EmptyShell Empty) : Stmt(GotoStmtClass, Empty) {}\n\n  LabelDecl *getLabel() const { return Label; }\n  void setLabel(LabelDecl *D) { Label = D; }\n\n  SourceLocation getGotoLoc() const { return GotoStmtBits.GotoLoc; }\n  void setGotoLoc(SourceLocation L) { GotoStmtBits.GotoLoc = L; }\n  SourceLocation getLabelLoc() const { return LabelLoc; }\n  void setLabelLoc(SourceLocation L) { LabelLoc = L; }\n\n  SourceLocation getBeginLoc() const { return getGotoLoc(); }\n  SourceLocation getEndLoc() const { return getLabelLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == GotoStmtClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// IndirectGotoStmt - This represents an indirect goto.\nclass IndirectGotoStmt : public Stmt {\n  SourceLocation StarLoc;\n  Stmt *Target;\n\npublic:\n  IndirectGotoStmt(SourceLocation gotoLoc, SourceLocation starLoc, Expr *target)\n      : Stmt(IndirectGotoStmtClass), StarLoc(starLoc) {\n    setTarget(target);\n    setGotoLoc(gotoLoc);\n  }\n\n  /// Build an empty indirect goto statement.\n  explicit IndirectGotoStmt(EmptyShell Empty)\n      : Stmt(IndirectGotoStmtClass, Empty) {}\n\n  void setGotoLoc(SourceLocation L) { GotoStmtBits.GotoLoc = L; }\n  SourceLocation getGotoLoc() const { return GotoStmtBits.GotoLoc; }\n  void setStarLoc(SourceLocation L) { StarLoc = L; }\n  SourceLocation getStarLoc() const { return StarLoc; }\n\n  Expr *getTarget() { return reinterpret_cast<Expr *>(Target); }\n  const Expr *getTarget() const {\n    return reinterpret_cast<const Expr *>(Target);\n  }\n  void setTarget(Expr *E) { Target = reinterpret_cast<Stmt *>(E); }\n\n  /// getConstantTarget - Returns the fixed target of this indirect\n  /// goto, if one exists.\n  LabelDecl *getConstantTarget();\n  const LabelDecl *getConstantTarget() const {\n    return const_cast<IndirectGotoStmt *>(this)->getConstantTarget();\n  }\n\n  SourceLocation getBeginLoc() const { return getGotoLoc(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Target->getEndLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == IndirectGotoStmtClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Target, &Target + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Target, &Target + 1);\n  }\n};\n\n/// ContinueStmt - This represents a continue.\nclass ContinueStmt : public Stmt {\npublic:\n  ContinueStmt(SourceLocation CL) : Stmt(ContinueStmtClass) {\n    setContinueLoc(CL);\n  }\n\n  /// Build an empty continue statement.\n  explicit ContinueStmt(EmptyShell Empty) : Stmt(ContinueStmtClass, Empty) {}\n\n  SourceLocation getContinueLoc() const { return ContinueStmtBits.ContinueLoc; }\n  void setContinueLoc(SourceLocation L) { ContinueStmtBits.ContinueLoc = L; }\n\n  SourceLocation getBeginLoc() const { return getContinueLoc(); }\n  SourceLocation getEndLoc() const { return getContinueLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ContinueStmtClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// BreakStmt - This represents a break.\nclass BreakStmt : public Stmt {\npublic:\n  BreakStmt(SourceLocation BL) : Stmt(BreakStmtClass) {\n    setBreakLoc(BL);\n  }\n\n  /// Build an empty break statement.\n  explicit BreakStmt(EmptyShell Empty) : Stmt(BreakStmtClass, Empty) {}\n\n  SourceLocation getBreakLoc() const { return BreakStmtBits.BreakLoc; }\n  void setBreakLoc(SourceLocation L) { BreakStmtBits.BreakLoc = L; }\n\n  SourceLocation getBeginLoc() const { return getBreakLoc(); }\n  SourceLocation getEndLoc() const { return getBreakLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == BreakStmtClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// ReturnStmt - This represents a return, optionally of an expression:\n///   return;\n///   return 4;\n///\n/// Note that GCC allows return with no argument in a function declared to\n/// return a value, and it allows returning a value in functions declared to\n/// return void.  We explicitly model this in the AST, which means you can't\n/// depend on the return type of the function and the presence of an argument.\nclass ReturnStmt final\n    : public Stmt,\n      private llvm::TrailingObjects<ReturnStmt, const VarDecl *> {\n  friend TrailingObjects;\n\n  /// The return expression.\n  Stmt *RetExpr;\n\n  // ReturnStmt is followed optionally by a trailing \"const VarDecl *\"\n  // for the NRVO candidate. Present if and only if hasNRVOCandidate().\n\n  /// True if this ReturnStmt has storage for an NRVO candidate.\n  bool hasNRVOCandidate() const { return ReturnStmtBits.HasNRVOCandidate; }\n\n  unsigned numTrailingObjects(OverloadToken<const VarDecl *>) const {\n    return hasNRVOCandidate();\n  }\n\n  /// Build a return statement.\n  ReturnStmt(SourceLocation RL, Expr *E, const VarDecl *NRVOCandidate);\n\n  /// Build an empty return statement.\n  explicit ReturnStmt(EmptyShell Empty, bool HasNRVOCandidate);\n\npublic:\n  /// Create a return statement.\n  static ReturnStmt *Create(const ASTContext &Ctx, SourceLocation RL, Expr *E,\n                            const VarDecl *NRVOCandidate);\n\n  /// Create an empty return statement, optionally with\n  /// storage for an NRVO candidate.\n  static ReturnStmt *CreateEmpty(const ASTContext &Ctx, bool HasNRVOCandidate);\n\n  Expr *getRetValue() { return reinterpret_cast<Expr *>(RetExpr); }\n  const Expr *getRetValue() const { return reinterpret_cast<Expr *>(RetExpr); }\n  void setRetValue(Expr *E) { RetExpr = reinterpret_cast<Stmt *>(E); }\n\n  /// Retrieve the variable that might be used for the named return\n  /// value optimization.\n  ///\n  /// The optimization itself can only be performed if the variable is\n  /// also marked as an NRVO object.\n  const VarDecl *getNRVOCandidate() const {\n    return hasNRVOCandidate() ? *getTrailingObjects<const VarDecl *>()\n                              : nullptr;\n  }\n\n  /// Set the variable that might be used for the named return value\n  /// optimization. The return statement must have storage for it,\n  /// which is the case if and only if hasNRVOCandidate() is true.\n  void setNRVOCandidate(const VarDecl *Var) {\n    assert(hasNRVOCandidate() &&\n           \"This return statement has no storage for an NRVO candidate!\");\n    *getTrailingObjects<const VarDecl *>() = Var;\n  }\n\n  SourceLocation getReturnLoc() const { return ReturnStmtBits.RetLoc; }\n  void setReturnLoc(SourceLocation L) { ReturnStmtBits.RetLoc = L; }\n\n  SourceLocation getBeginLoc() const { return getReturnLoc(); }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return RetExpr ? RetExpr->getEndLoc() : getReturnLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ReturnStmtClass;\n  }\n\n  // Iterators\n  child_range children() {\n    if (RetExpr)\n      return child_range(&RetExpr, &RetExpr + 1);\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    if (RetExpr)\n      return const_child_range(&RetExpr, &RetExpr + 1);\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// AsmStmt is the base class for GCCAsmStmt and MSAsmStmt.\nclass AsmStmt : public Stmt {\nprotected:\n  friend class ASTStmtReader;\n\n  SourceLocation AsmLoc;\n\n  /// True if the assembly statement does not have any input or output\n  /// operands.\n  bool IsSimple;\n\n  /// If true, treat this inline assembly as having side effects.\n  /// This assembly statement should not be optimized, deleted or moved.\n  bool IsVolatile;\n\n  unsigned NumOutputs;\n  unsigned NumInputs;\n  unsigned NumClobbers;\n\n  Stmt **Exprs = nullptr;\n\n  AsmStmt(StmtClass SC, SourceLocation asmloc, bool issimple, bool isvolatile,\n          unsigned numoutputs, unsigned numinputs, unsigned numclobbers)\n      : Stmt (SC), AsmLoc(asmloc), IsSimple(issimple), IsVolatile(isvolatile),\n        NumOutputs(numoutputs), NumInputs(numinputs),\n        NumClobbers(numclobbers) {}\n\npublic:\n  /// Build an empty inline-assembly statement.\n  explicit AsmStmt(StmtClass SC, EmptyShell Empty) : Stmt(SC, Empty) {}\n\n  SourceLocation getAsmLoc() const { return AsmLoc; }\n  void setAsmLoc(SourceLocation L) { AsmLoc = L; }\n\n  bool isSimple() const { return IsSimple; }\n  void setSimple(bool V) { IsSimple = V; }\n\n  bool isVolatile() const { return IsVolatile; }\n  void setVolatile(bool V) { IsVolatile = V; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return {}; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return {}; }\n\n  //===--- Asm String Analysis ---===//\n\n  /// Assemble final IR asm string.\n  std::string generateAsmString(const ASTContext &C) const;\n\n  //===--- Output operands ---===//\n\n  unsigned getNumOutputs() const { return NumOutputs; }\n\n  /// getOutputConstraint - Return the constraint string for the specified\n  /// output operand.  All output constraints are known to be non-empty (either\n  /// '=' or '+').\n  StringRef getOutputConstraint(unsigned i) const;\n\n  /// isOutputPlusConstraint - Return true if the specified output constraint\n  /// is a \"+\" constraint (which is both an input and an output) or false if it\n  /// is an \"=\" constraint (just an output).\n  bool isOutputPlusConstraint(unsigned i) const {\n    return getOutputConstraint(i)[0] == '+';\n  }\n\n  const Expr *getOutputExpr(unsigned i) const;\n\n  /// getNumPlusOperands - Return the number of output operands that have a \"+\"\n  /// constraint.\n  unsigned getNumPlusOperands() const;\n\n  //===--- Input operands ---===//\n\n  unsigned getNumInputs() const { return NumInputs; }\n\n  /// getInputConstraint - Return the specified input constraint.  Unlike output\n  /// constraints, these can be empty.\n  StringRef getInputConstraint(unsigned i) const;\n\n  const Expr *getInputExpr(unsigned i) const;\n\n  //===--- Other ---===//\n\n  unsigned getNumClobbers() const { return NumClobbers; }\n  StringRef getClobber(unsigned i) const;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == GCCAsmStmtClass ||\n      T->getStmtClass() == MSAsmStmtClass;\n  }\n\n  // Input expr iterators.\n\n  using inputs_iterator = ExprIterator;\n  using const_inputs_iterator = ConstExprIterator;\n  using inputs_range = llvm::iterator_range<inputs_iterator>;\n  using inputs_const_range = llvm::iterator_range<const_inputs_iterator>;\n\n  inputs_iterator begin_inputs() {\n    return &Exprs[0] + NumOutputs;\n  }\n\n  inputs_iterator end_inputs() {\n    return &Exprs[0] + NumOutputs + NumInputs;\n  }\n\n  inputs_range inputs() { return inputs_range(begin_inputs(), end_inputs()); }\n\n  const_inputs_iterator begin_inputs() const {\n    return &Exprs[0] + NumOutputs;\n  }\n\n  const_inputs_iterator end_inputs() const {\n    return &Exprs[0] + NumOutputs + NumInputs;\n  }\n\n  inputs_const_range inputs() const {\n    return inputs_const_range(begin_inputs(), end_inputs());\n  }\n\n  // Output expr iterators.\n\n  using outputs_iterator = ExprIterator;\n  using const_outputs_iterator = ConstExprIterator;\n  using outputs_range = llvm::iterator_range<outputs_iterator>;\n  using outputs_const_range = llvm::iterator_range<const_outputs_iterator>;\n\n  outputs_iterator begin_outputs() {\n    return &Exprs[0];\n  }\n\n  outputs_iterator end_outputs() {\n    return &Exprs[0] + NumOutputs;\n  }\n\n  outputs_range outputs() {\n    return outputs_range(begin_outputs(), end_outputs());\n  }\n\n  const_outputs_iterator begin_outputs() const {\n    return &Exprs[0];\n  }\n\n  const_outputs_iterator end_outputs() const {\n    return &Exprs[0] + NumOutputs;\n  }\n\n  outputs_const_range outputs() const {\n    return outputs_const_range(begin_outputs(), end_outputs());\n  }\n\n  child_range children() {\n    return child_range(&Exprs[0], &Exprs[0] + NumOutputs + NumInputs);\n  }\n\n  const_child_range children() const {\n    return const_child_range(&Exprs[0], &Exprs[0] + NumOutputs + NumInputs);\n  }\n};\n\n/// This represents a GCC inline-assembly statement extension.\nclass GCCAsmStmt : public AsmStmt {\n  friend class ASTStmtReader;\n\n  SourceLocation RParenLoc;\n  StringLiteral *AsmStr;\n\n  // FIXME: If we wanted to, we could allocate all of these in one big array.\n  StringLiteral **Constraints = nullptr;\n  StringLiteral **Clobbers = nullptr;\n  IdentifierInfo **Names = nullptr;\n  unsigned NumLabels = 0;\n\npublic:\n  GCCAsmStmt(const ASTContext &C, SourceLocation asmloc, bool issimple,\n             bool isvolatile, unsigned numoutputs, unsigned numinputs,\n             IdentifierInfo **names, StringLiteral **constraints, Expr **exprs,\n             StringLiteral *asmstr, unsigned numclobbers,\n             StringLiteral **clobbers, unsigned numlabels,\n             SourceLocation rparenloc);\n\n  /// Build an empty inline-assembly statement.\n  explicit GCCAsmStmt(EmptyShell Empty) : AsmStmt(GCCAsmStmtClass, Empty) {}\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  //===--- Asm String Analysis ---===//\n\n  const StringLiteral *getAsmString() const { return AsmStr; }\n  StringLiteral *getAsmString() { return AsmStr; }\n  void setAsmString(StringLiteral *E) { AsmStr = E; }\n\n  /// AsmStringPiece - this is part of a decomposed asm string specification\n  /// (for use with the AnalyzeAsmString function below).  An asm string is\n  /// considered to be a concatenation of these parts.\n  class AsmStringPiece {\n  public:\n    enum Kind {\n      String,  // String in .ll asm string form, \"$\" -> \"$$\" and \"%%\" -> \"%\".\n      Operand  // Operand reference, with optional modifier %c4.\n    };\n\n  private:\n    Kind MyKind;\n    std::string Str;\n    unsigned OperandNo;\n\n    // Source range for operand references.\n    CharSourceRange Range;\n\n  public:\n    AsmStringPiece(const std::string &S) : MyKind(String), Str(S) {}\n    AsmStringPiece(unsigned OpNo, const std::string &S, SourceLocation Begin,\n                   SourceLocation End)\n        : MyKind(Operand), Str(S), OperandNo(OpNo),\n          Range(CharSourceRange::getCharRange(Begin, End)) {}\n\n    bool isString() const { return MyKind == String; }\n    bool isOperand() const { return MyKind == Operand; }\n\n    const std::string &getString() const { return Str; }\n\n    unsigned getOperandNo() const {\n      assert(isOperand());\n      return OperandNo;\n    }\n\n    CharSourceRange getRange() const {\n      assert(isOperand() && \"Range is currently used only for Operands.\");\n      return Range;\n    }\n\n    /// getModifier - Get the modifier for this operand, if present.  This\n    /// returns '\\0' if there was no modifier.\n    char getModifier() const;\n  };\n\n  /// AnalyzeAsmString - Analyze the asm string of the current asm, decomposing\n  /// it into pieces.  If the asm string is erroneous, emit errors and return\n  /// true, otherwise return false.  This handles canonicalization and\n  /// translation of strings from GCC syntax to LLVM IR syntax, and handles\n  //// flattening of named references like %[foo] to Operand AsmStringPiece's.\n  unsigned AnalyzeAsmString(SmallVectorImpl<AsmStringPiece> &Pieces,\n                            const ASTContext &C, unsigned &DiagOffs) const;\n\n  /// Assemble final IR asm string.\n  std::string generateAsmString(const ASTContext &C) const;\n\n  //===--- Output operands ---===//\n\n  IdentifierInfo *getOutputIdentifier(unsigned i) const { return Names[i]; }\n\n  StringRef getOutputName(unsigned i) const {\n    if (IdentifierInfo *II = getOutputIdentifier(i))\n      return II->getName();\n\n    return {};\n  }\n\n  StringRef getOutputConstraint(unsigned i) const;\n\n  const StringLiteral *getOutputConstraintLiteral(unsigned i) const {\n    return Constraints[i];\n  }\n  StringLiteral *getOutputConstraintLiteral(unsigned i) {\n    return Constraints[i];\n  }\n\n  Expr *getOutputExpr(unsigned i);\n\n  const Expr *getOutputExpr(unsigned i) const {\n    return const_cast<GCCAsmStmt*>(this)->getOutputExpr(i);\n  }\n\n  //===--- Input operands ---===//\n\n  IdentifierInfo *getInputIdentifier(unsigned i) const {\n    return Names[i + NumOutputs];\n  }\n\n  StringRef getInputName(unsigned i) const {\n    if (IdentifierInfo *II = getInputIdentifier(i))\n      return II->getName();\n\n    return {};\n  }\n\n  StringRef getInputConstraint(unsigned i) const;\n\n  const StringLiteral *getInputConstraintLiteral(unsigned i) const {\n    return Constraints[i + NumOutputs];\n  }\n  StringLiteral *getInputConstraintLiteral(unsigned i) {\n    return Constraints[i + NumOutputs];\n  }\n\n  Expr *getInputExpr(unsigned i);\n  void setInputExpr(unsigned i, Expr *E);\n\n  const Expr *getInputExpr(unsigned i) const {\n    return const_cast<GCCAsmStmt*>(this)->getInputExpr(i);\n  }\n\n  //===--- Labels ---===//\n\n  bool isAsmGoto() const {\n    return NumLabels > 0;\n  }\n\n  unsigned getNumLabels() const {\n    return NumLabels;\n  }\n\n  IdentifierInfo *getLabelIdentifier(unsigned i) const {\n    return Names[i + NumOutputs + NumInputs];\n  }\n\n  AddrLabelExpr *getLabelExpr(unsigned i) const;\n  StringRef getLabelName(unsigned i) const;\n  using labels_iterator = CastIterator<AddrLabelExpr>;\n  using const_labels_iterator = ConstCastIterator<AddrLabelExpr>;\n  using labels_range = llvm::iterator_range<labels_iterator>;\n  using labels_const_range = llvm::iterator_range<const_labels_iterator>;\n\n  labels_iterator begin_labels() {\n    return &Exprs[0] + NumOutputs + NumInputs;\n  }\n\n  labels_iterator end_labels() {\n    return &Exprs[0] + NumOutputs + NumInputs + NumLabels;\n  }\n\n  labels_range labels() {\n    return labels_range(begin_labels(), end_labels());\n  }\n\n  const_labels_iterator begin_labels() const {\n    return &Exprs[0] + NumOutputs + NumInputs;\n  }\n\n  const_labels_iterator end_labels() const {\n    return &Exprs[0] + NumOutputs + NumInputs + NumLabels;\n  }\n\n  labels_const_range labels() const {\n    return labels_const_range(begin_labels(), end_labels());\n  }\n\nprivate:\n  void setOutputsAndInputsAndClobbers(const ASTContext &C,\n                                      IdentifierInfo **Names,\n                                      StringLiteral **Constraints,\n                                      Stmt **Exprs,\n                                      unsigned NumOutputs,\n                                      unsigned NumInputs,\n                                      unsigned NumLabels,\n                                      StringLiteral **Clobbers,\n                                      unsigned NumClobbers);\n\npublic:\n  //===--- Other ---===//\n\n  /// getNamedOperand - Given a symbolic operand reference like %[foo],\n  /// translate this into a numeric value needed to reference the same operand.\n  /// This returns -1 if the operand name is invalid.\n  int getNamedOperand(StringRef SymbolicName) const;\n\n  StringRef getClobber(unsigned i) const;\n\n  StringLiteral *getClobberStringLiteral(unsigned i) { return Clobbers[i]; }\n  const StringLiteral *getClobberStringLiteral(unsigned i) const {\n    return Clobbers[i];\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AsmLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == GCCAsmStmtClass;\n  }\n};\n\n/// This represents a Microsoft inline-assembly statement extension.\nclass MSAsmStmt : public AsmStmt {\n  friend class ASTStmtReader;\n\n  SourceLocation LBraceLoc, EndLoc;\n  StringRef AsmStr;\n\n  unsigned NumAsmToks = 0;\n\n  Token *AsmToks = nullptr;\n  StringRef *Constraints = nullptr;\n  StringRef *Clobbers = nullptr;\n\npublic:\n  MSAsmStmt(const ASTContext &C, SourceLocation asmloc,\n            SourceLocation lbraceloc, bool issimple, bool isvolatile,\n            ArrayRef<Token> asmtoks, unsigned numoutputs, unsigned numinputs,\n            ArrayRef<StringRef> constraints,\n            ArrayRef<Expr*> exprs, StringRef asmstr,\n            ArrayRef<StringRef> clobbers, SourceLocation endloc);\n\n  /// Build an empty MS-style inline-assembly statement.\n  explicit MSAsmStmt(EmptyShell Empty) : AsmStmt(MSAsmStmtClass, Empty) {}\n\n  SourceLocation getLBraceLoc() const { return LBraceLoc; }\n  void setLBraceLoc(SourceLocation L) { LBraceLoc = L; }\n  SourceLocation getEndLoc() const { return EndLoc; }\n  void setEndLoc(SourceLocation L) { EndLoc = L; }\n\n  bool hasBraces() const { return LBraceLoc.isValid(); }\n\n  unsigned getNumAsmToks() { return NumAsmToks; }\n  Token *getAsmToks() { return AsmToks; }\n\n  //===--- Asm String Analysis ---===//\n  StringRef getAsmString() const { return AsmStr; }\n\n  /// Assemble final IR asm string.\n  std::string generateAsmString(const ASTContext &C) const;\n\n  //===--- Output operands ---===//\n\n  StringRef getOutputConstraint(unsigned i) const {\n    assert(i < NumOutputs);\n    return Constraints[i];\n  }\n\n  Expr *getOutputExpr(unsigned i);\n\n  const Expr *getOutputExpr(unsigned i) const {\n    return const_cast<MSAsmStmt*>(this)->getOutputExpr(i);\n  }\n\n  //===--- Input operands ---===//\n\n  StringRef getInputConstraint(unsigned i) const {\n    assert(i < NumInputs);\n    return Constraints[i + NumOutputs];\n  }\n\n  Expr *getInputExpr(unsigned i);\n  void setInputExpr(unsigned i, Expr *E);\n\n  const Expr *getInputExpr(unsigned i) const {\n    return const_cast<MSAsmStmt*>(this)->getInputExpr(i);\n  }\n\n  //===--- Other ---===//\n\n  ArrayRef<StringRef> getAllConstraints() const {\n    return llvm::makeArrayRef(Constraints, NumInputs + NumOutputs);\n  }\n\n  ArrayRef<StringRef> getClobbers() const {\n    return llvm::makeArrayRef(Clobbers, NumClobbers);\n  }\n\n  ArrayRef<Expr*> getAllExprs() const {\n    return llvm::makeArrayRef(reinterpret_cast<Expr**>(Exprs),\n                              NumInputs + NumOutputs);\n  }\n\n  StringRef getClobber(unsigned i) const { return getClobbers()[i]; }\n\nprivate:\n  void initialize(const ASTContext &C, StringRef AsmString,\n                  ArrayRef<Token> AsmToks, ArrayRef<StringRef> Constraints,\n                  ArrayRef<Expr*> Exprs, ArrayRef<StringRef> Clobbers);\n\npublic:\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AsmLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == MSAsmStmtClass;\n  }\n\n  child_range children() {\n    return child_range(&Exprs[0], &Exprs[NumInputs + NumOutputs]);\n  }\n\n  const_child_range children() const {\n    return const_child_range(&Exprs[0], &Exprs[NumInputs + NumOutputs]);\n  }\n};\n\nclass SEHExceptStmt : public Stmt {\n  friend class ASTReader;\n  friend class ASTStmtReader;\n\n  SourceLocation  Loc;\n  Stmt *Children[2];\n\n  enum { FILTER_EXPR, BLOCK };\n\n  SEHExceptStmt(SourceLocation Loc, Expr *FilterExpr, Stmt *Block);\n  explicit SEHExceptStmt(EmptyShell E) : Stmt(SEHExceptStmtClass, E) {}\n\npublic:\n  static SEHExceptStmt* Create(const ASTContext &C,\n                               SourceLocation ExceptLoc,\n                               Expr *FilterExpr,\n                               Stmt *Block);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return getExceptLoc(); }\n\n  SourceLocation getExceptLoc() const { return Loc; }\n  SourceLocation getEndLoc() const { return getBlock()->getEndLoc(); }\n\n  Expr *getFilterExpr() const {\n    return reinterpret_cast<Expr*>(Children[FILTER_EXPR]);\n  }\n\n  CompoundStmt *getBlock() const {\n    return cast<CompoundStmt>(Children[BLOCK]);\n  }\n\n  child_range children() {\n    return child_range(Children, Children+2);\n  }\n\n  const_child_range children() const {\n    return const_child_range(Children, Children + 2);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == SEHExceptStmtClass;\n  }\n};\n\nclass SEHFinallyStmt : public Stmt {\n  friend class ASTReader;\n  friend class ASTStmtReader;\n\n  SourceLocation  Loc;\n  Stmt *Block;\n\n  SEHFinallyStmt(SourceLocation Loc, Stmt *Block);\n  explicit SEHFinallyStmt(EmptyShell E) : Stmt(SEHFinallyStmtClass, E) {}\n\npublic:\n  static SEHFinallyStmt* Create(const ASTContext &C,\n                                SourceLocation FinallyLoc,\n                                Stmt *Block);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return getFinallyLoc(); }\n\n  SourceLocation getFinallyLoc() const { return Loc; }\n  SourceLocation getEndLoc() const { return Block->getEndLoc(); }\n\n  CompoundStmt *getBlock() const { return cast<CompoundStmt>(Block); }\n\n  child_range children() {\n    return child_range(&Block,&Block+1);\n  }\n\n  const_child_range children() const {\n    return const_child_range(&Block, &Block + 1);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == SEHFinallyStmtClass;\n  }\n};\n\nclass SEHTryStmt : public Stmt {\n  friend class ASTReader;\n  friend class ASTStmtReader;\n\n  bool IsCXXTry;\n  SourceLocation  TryLoc;\n  Stmt *Children[2];\n\n  enum { TRY = 0, HANDLER = 1 };\n\n  SEHTryStmt(bool isCXXTry, // true if 'try' otherwise '__try'\n             SourceLocation TryLoc,\n             Stmt *TryBlock,\n             Stmt *Handler);\n\n  explicit SEHTryStmt(EmptyShell E) : Stmt(SEHTryStmtClass, E) {}\n\npublic:\n  static SEHTryStmt* Create(const ASTContext &C, bool isCXXTry,\n                            SourceLocation TryLoc, Stmt *TryBlock,\n                            Stmt *Handler);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return getTryLoc(); }\n\n  SourceLocation getTryLoc() const { return TryLoc; }\n  SourceLocation getEndLoc() const { return Children[HANDLER]->getEndLoc(); }\n\n  bool getIsCXXTry() const { return IsCXXTry; }\n\n  CompoundStmt* getTryBlock() const {\n    return cast<CompoundStmt>(Children[TRY]);\n  }\n\n  Stmt *getHandler() const { return Children[HANDLER]; }\n\n  /// Returns 0 if not defined\n  SEHExceptStmt  *getExceptHandler() const;\n  SEHFinallyStmt *getFinallyHandler() const;\n\n  child_range children() {\n    return child_range(Children, Children+2);\n  }\n\n  const_child_range children() const {\n    return const_child_range(Children, Children + 2);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == SEHTryStmtClass;\n  }\n};\n\n/// Represents a __leave statement.\nclass SEHLeaveStmt : public Stmt {\n  SourceLocation LeaveLoc;\n\npublic:\n  explicit SEHLeaveStmt(SourceLocation LL)\n      : Stmt(SEHLeaveStmtClass), LeaveLoc(LL) {}\n\n  /// Build an empty __leave statement.\n  explicit SEHLeaveStmt(EmptyShell Empty) : Stmt(SEHLeaveStmtClass, Empty) {}\n\n  SourceLocation getLeaveLoc() const { return LeaveLoc; }\n  void setLeaveLoc(SourceLocation L) { LeaveLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return LeaveLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return LeaveLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == SEHLeaveStmtClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// This captures a statement into a function. For example, the following\n/// pragma annotated compound statement can be represented as a CapturedStmt,\n/// and this compound statement is the body of an anonymous outlined function.\n/// @code\n/// #pragma omp parallel\n/// {\n///   compute();\n/// }\n/// @endcode\nclass CapturedStmt : public Stmt {\npublic:\n  /// The different capture forms: by 'this', by reference, capture for\n  /// variable-length array type etc.\n  enum VariableCaptureKind {\n    VCK_This,\n    VCK_ByRef,\n    VCK_ByCopy,\n    VCK_VLAType,\n  };\n\n  /// Describes the capture of either a variable, or 'this', or\n  /// variable-length array type.\n  class Capture {\n    llvm::PointerIntPair<VarDecl *, 2, VariableCaptureKind> VarAndKind;\n    SourceLocation Loc;\n\n  public:\n    friend class ASTStmtReader;\n\n    /// Create a new capture.\n    ///\n    /// \\param Loc The source location associated with this capture.\n    ///\n    /// \\param Kind The kind of capture (this, ByRef, ...).\n    ///\n    /// \\param Var The variable being captured, or null if capturing this.\n    Capture(SourceLocation Loc, VariableCaptureKind Kind,\n            VarDecl *Var = nullptr);\n\n    /// Determine the kind of capture.\n    VariableCaptureKind getCaptureKind() const;\n\n    /// Retrieve the source location at which the variable or 'this' was\n    /// first used.\n    SourceLocation getLocation() const { return Loc; }\n\n    /// Determine whether this capture handles the C++ 'this' pointer.\n    bool capturesThis() const { return getCaptureKind() == VCK_This; }\n\n    /// Determine whether this capture handles a variable (by reference).\n    bool capturesVariable() const { return getCaptureKind() == VCK_ByRef; }\n\n    /// Determine whether this capture handles a variable by copy.\n    bool capturesVariableByCopy() const {\n      return getCaptureKind() == VCK_ByCopy;\n    }\n\n    /// Determine whether this capture handles a variable-length array\n    /// type.\n    bool capturesVariableArrayType() const {\n      return getCaptureKind() == VCK_VLAType;\n    }\n\n    /// Retrieve the declaration of the variable being captured.\n    ///\n    /// This operation is only valid if this capture captures a variable.\n    VarDecl *getCapturedVar() const;\n  };\n\nprivate:\n  /// The number of variable captured, including 'this'.\n  unsigned NumCaptures;\n\n  /// The pointer part is the implicit the outlined function and the\n  /// int part is the captured region kind, 'CR_Default' etc.\n  llvm::PointerIntPair<CapturedDecl *, 2, CapturedRegionKind> CapDeclAndKind;\n\n  /// The record for captured variables, a RecordDecl or CXXRecordDecl.\n  RecordDecl *TheRecordDecl = nullptr;\n\n  /// Construct a captured statement.\n  CapturedStmt(Stmt *S, CapturedRegionKind Kind, ArrayRef<Capture> Captures,\n               ArrayRef<Expr *> CaptureInits, CapturedDecl *CD, RecordDecl *RD);\n\n  /// Construct an empty captured statement.\n  CapturedStmt(EmptyShell Empty, unsigned NumCaptures);\n\n  Stmt **getStoredStmts() { return reinterpret_cast<Stmt **>(this + 1); }\n\n  Stmt *const *getStoredStmts() const {\n    return reinterpret_cast<Stmt *const *>(this + 1);\n  }\n\n  Capture *getStoredCaptures() const;\n\n  void setCapturedStmt(Stmt *S) { getStoredStmts()[NumCaptures] = S; }\n\npublic:\n  friend class ASTStmtReader;\n\n  static CapturedStmt *Create(const ASTContext &Context, Stmt *S,\n                              CapturedRegionKind Kind,\n                              ArrayRef<Capture> Captures,\n                              ArrayRef<Expr *> CaptureInits,\n                              CapturedDecl *CD, RecordDecl *RD);\n\n  static CapturedStmt *CreateDeserialized(const ASTContext &Context,\n                                          unsigned NumCaptures);\n\n  /// Retrieve the statement being captured.\n  Stmt *getCapturedStmt() { return getStoredStmts()[NumCaptures]; }\n  const Stmt *getCapturedStmt() const { return getStoredStmts()[NumCaptures]; }\n\n  /// Retrieve the outlined function declaration.\n  CapturedDecl *getCapturedDecl();\n  const CapturedDecl *getCapturedDecl() const;\n\n  /// Set the outlined function declaration.\n  void setCapturedDecl(CapturedDecl *D);\n\n  /// Retrieve the captured region kind.\n  CapturedRegionKind getCapturedRegionKind() const;\n\n  /// Set the captured region kind.\n  void setCapturedRegionKind(CapturedRegionKind Kind);\n\n  /// Retrieve the record declaration for captured variables.\n  const RecordDecl *getCapturedRecordDecl() const { return TheRecordDecl; }\n\n  /// Set the record declaration for captured variables.\n  void setCapturedRecordDecl(RecordDecl *D) {\n    assert(D && \"null RecordDecl\");\n    TheRecordDecl = D;\n  }\n\n  /// True if this variable has been captured.\n  bool capturesVariable(const VarDecl *Var) const;\n\n  /// An iterator that walks over the captures.\n  using capture_iterator = Capture *;\n  using const_capture_iterator = const Capture *;\n  using capture_range = llvm::iterator_range<capture_iterator>;\n  using capture_const_range = llvm::iterator_range<const_capture_iterator>;\n\n  capture_range captures() {\n    return capture_range(capture_begin(), capture_end());\n  }\n  capture_const_range captures() const {\n    return capture_const_range(capture_begin(), capture_end());\n  }\n\n  /// Retrieve an iterator pointing to the first capture.\n  capture_iterator capture_begin() { return getStoredCaptures(); }\n  const_capture_iterator capture_begin() const { return getStoredCaptures(); }\n\n  /// Retrieve an iterator pointing past the end of the sequence of\n  /// captures.\n  capture_iterator capture_end() const {\n    return getStoredCaptures() + NumCaptures;\n  }\n\n  /// Retrieve the number of captures, including 'this'.\n  unsigned capture_size() const { return NumCaptures; }\n\n  /// Iterator that walks over the capture initialization arguments.\n  using capture_init_iterator = Expr **;\n  using capture_init_range = llvm::iterator_range<capture_init_iterator>;\n\n  /// Const iterator that walks over the capture initialization\n  /// arguments.\n  using const_capture_init_iterator = Expr *const *;\n  using const_capture_init_range =\n      llvm::iterator_range<const_capture_init_iterator>;\n\n  capture_init_range capture_inits() {\n    return capture_init_range(capture_init_begin(), capture_init_end());\n  }\n\n  const_capture_init_range capture_inits() const {\n    return const_capture_init_range(capture_init_begin(), capture_init_end());\n  }\n\n  /// Retrieve the first initialization argument.\n  capture_init_iterator capture_init_begin() {\n    return reinterpret_cast<Expr **>(getStoredStmts());\n  }\n\n  const_capture_init_iterator capture_init_begin() const {\n    return reinterpret_cast<Expr *const *>(getStoredStmts());\n  }\n\n  /// Retrieve the iterator pointing one past the last initialization\n  /// argument.\n  capture_init_iterator capture_init_end() {\n    return capture_init_begin() + NumCaptures;\n  }\n\n  const_capture_init_iterator capture_init_end() const {\n    return capture_init_begin() + NumCaptures;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getCapturedStmt()->getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getCapturedStmt()->getEndLoc();\n  }\n\n  SourceRange getSourceRange() const LLVM_READONLY {\n    return getCapturedStmt()->getSourceRange();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CapturedStmtClass;\n  }\n\n  child_range children();\n\n  const_child_range children() const;\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_STMT_H\n"}, "13": {"id": 13, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtCXX.h", "content": "//===--- StmtCXX.h - Classes for representing C++ statements ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the C++ statement AST node classes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_STMTCXX_H\n#define LLVM_CLANG_AST_STMTCXX_H\n\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"llvm/Support/Compiler.h\"\n\nnamespace clang {\n\nclass VarDecl;\n\n/// CXXCatchStmt - This represents a C++ catch block.\n///\nclass CXXCatchStmt : public Stmt {\n  SourceLocation CatchLoc;\n  /// The exception-declaration of the type.\n  VarDecl *ExceptionDecl;\n  /// The handler block.\n  Stmt *HandlerBlock;\n\npublic:\n  CXXCatchStmt(SourceLocation catchLoc, VarDecl *exDecl, Stmt *handlerBlock)\n  : Stmt(CXXCatchStmtClass), CatchLoc(catchLoc), ExceptionDecl(exDecl),\n    HandlerBlock(handlerBlock) {}\n\n  CXXCatchStmt(EmptyShell Empty)\n  : Stmt(CXXCatchStmtClass), ExceptionDecl(nullptr), HandlerBlock(nullptr) {}\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return CatchLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return HandlerBlock->getEndLoc();\n  }\n\n  SourceLocation getCatchLoc() const { return CatchLoc; }\n  VarDecl *getExceptionDecl() const { return ExceptionDecl; }\n  QualType getCaughtType() const;\n  Stmt *getHandlerBlock() const { return HandlerBlock; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXCatchStmtClass;\n  }\n\n  child_range children() { return child_range(&HandlerBlock, &HandlerBlock+1); }\n\n  const_child_range children() const {\n    return const_child_range(&HandlerBlock, &HandlerBlock + 1);\n  }\n\n  friend class ASTStmtReader;\n};\n\n/// CXXTryStmt - A C++ try block, including all handlers.\n///\nclass CXXTryStmt final : public Stmt,\n                         private llvm::TrailingObjects<CXXTryStmt, Stmt *> {\n\n  friend TrailingObjects;\n  friend class ASTStmtReader;\n\n  SourceLocation TryLoc;\n  unsigned NumHandlers;\n  size_t numTrailingObjects(OverloadToken<Stmt *>) const { return NumHandlers; }\n\n  CXXTryStmt(SourceLocation tryLoc, Stmt *tryBlock, ArrayRef<Stmt*> handlers);\n  CXXTryStmt(EmptyShell Empty, unsigned numHandlers)\n    : Stmt(CXXTryStmtClass), NumHandlers(numHandlers) { }\n\n  Stmt *const *getStmts() const { return getTrailingObjects<Stmt *>(); }\n  Stmt **getStmts() { return getTrailingObjects<Stmt *>(); }\n\npublic:\n  static CXXTryStmt *Create(const ASTContext &C, SourceLocation tryLoc,\n                            Stmt *tryBlock, ArrayRef<Stmt*> handlers);\n\n  static CXXTryStmt *Create(const ASTContext &C, EmptyShell Empty,\n                            unsigned numHandlers);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return getTryLoc(); }\n\n  SourceLocation getTryLoc() const { return TryLoc; }\n  SourceLocation getEndLoc() const {\n    return getStmts()[NumHandlers]->getEndLoc();\n  }\n\n  CompoundStmt *getTryBlock() {\n    return cast<CompoundStmt>(getStmts()[0]);\n  }\n  const CompoundStmt *getTryBlock() const {\n    return cast<CompoundStmt>(getStmts()[0]);\n  }\n\n  unsigned getNumHandlers() const { return NumHandlers; }\n  CXXCatchStmt *getHandler(unsigned i) {\n    return cast<CXXCatchStmt>(getStmts()[i + 1]);\n  }\n  const CXXCatchStmt *getHandler(unsigned i) const {\n    return cast<CXXCatchStmt>(getStmts()[i + 1]);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXTryStmtClass;\n  }\n\n  child_range children() {\n    return child_range(getStmts(), getStmts() + getNumHandlers() + 1);\n  }\n\n  const_child_range children() const {\n    return const_child_range(getStmts(), getStmts() + getNumHandlers() + 1);\n  }\n};\n\n/// CXXForRangeStmt - This represents C++0x [stmt.ranged]'s ranged for\n/// statement, represented as 'for (range-declarator : range-expression)'\n/// or 'for (init-statement range-declarator : range-expression)'.\n///\n/// This is stored in a partially-desugared form to allow full semantic\n/// analysis of the constituent components. The original syntactic components\n/// can be extracted using getLoopVariable and getRangeInit.\nclass CXXForRangeStmt : public Stmt {\n  SourceLocation ForLoc;\n  enum { INIT, RANGE, BEGINSTMT, ENDSTMT, COND, INC, LOOPVAR, BODY, END };\n  // SubExprs[RANGE] is an expression or declstmt.\n  // SubExprs[COND] and SubExprs[INC] are expressions.\n  Stmt *SubExprs[END];\n  SourceLocation CoawaitLoc;\n  SourceLocation ColonLoc;\n  SourceLocation RParenLoc;\n\n  friend class ASTStmtReader;\npublic:\n  CXXForRangeStmt(Stmt *InitStmt, DeclStmt *Range, DeclStmt *Begin,\n                  DeclStmt *End, Expr *Cond, Expr *Inc, DeclStmt *LoopVar,\n                  Stmt *Body, SourceLocation FL, SourceLocation CAL,\n                  SourceLocation CL, SourceLocation RPL);\n  CXXForRangeStmt(EmptyShell Empty) : Stmt(CXXForRangeStmtClass, Empty) { }\n\n  Stmt *getInit() { return SubExprs[INIT]; }\n  VarDecl *getLoopVariable();\n  Expr *getRangeInit();\n\n  const Stmt *getInit() const { return SubExprs[INIT]; }\n  const VarDecl *getLoopVariable() const;\n  const Expr *getRangeInit() const;\n\n\n  DeclStmt *getRangeStmt() { return cast<DeclStmt>(SubExprs[RANGE]); }\n  DeclStmt *getBeginStmt() {\n    return cast_or_null<DeclStmt>(SubExprs[BEGINSTMT]);\n  }\n  DeclStmt *getEndStmt() { return cast_or_null<DeclStmt>(SubExprs[ENDSTMT]); }\n  Expr *getCond() { return cast_or_null<Expr>(SubExprs[COND]); }\n  Expr *getInc() { return cast_or_null<Expr>(SubExprs[INC]); }\n  DeclStmt *getLoopVarStmt() { return cast<DeclStmt>(SubExprs[LOOPVAR]); }\n  Stmt *getBody() { return SubExprs[BODY]; }\n\n  const DeclStmt *getRangeStmt() const {\n    return cast<DeclStmt>(SubExprs[RANGE]);\n  }\n  const DeclStmt *getBeginStmt() const {\n    return cast_or_null<DeclStmt>(SubExprs[BEGINSTMT]);\n  }\n  const DeclStmt *getEndStmt() const {\n    return cast_or_null<DeclStmt>(SubExprs[ENDSTMT]);\n  }\n  const Expr *getCond() const {\n    return cast_or_null<Expr>(SubExprs[COND]);\n  }\n  const Expr *getInc() const {\n    return cast_or_null<Expr>(SubExprs[INC]);\n  }\n  const DeclStmt *getLoopVarStmt() const {\n    return cast<DeclStmt>(SubExprs[LOOPVAR]);\n  }\n  const Stmt *getBody() const { return SubExprs[BODY]; }\n\n  void setInit(Stmt *S) { SubExprs[INIT] = S; }\n  void setRangeInit(Expr *E) { SubExprs[RANGE] = reinterpret_cast<Stmt*>(E); }\n  void setRangeStmt(Stmt *S) { SubExprs[RANGE] = S; }\n  void setBeginStmt(Stmt *S) { SubExprs[BEGINSTMT] = S; }\n  void setEndStmt(Stmt *S) { SubExprs[ENDSTMT] = S; }\n  void setCond(Expr *E) { SubExprs[COND] = reinterpret_cast<Stmt*>(E); }\n  void setInc(Expr *E) { SubExprs[INC] = reinterpret_cast<Stmt*>(E); }\n  void setLoopVarStmt(Stmt *S) { SubExprs[LOOPVAR] = S; }\n  void setBody(Stmt *S) { SubExprs[BODY] = S; }\n\n  SourceLocation getForLoc() const { return ForLoc; }\n  SourceLocation getCoawaitLoc() const { return CoawaitLoc; }\n  SourceLocation getColonLoc() const { return ColonLoc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return ForLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return SubExprs[BODY]->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CXXForRangeStmtClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[END]);\n  }\n\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[END]);\n  }\n};\n\n/// Representation of a Microsoft __if_exists or __if_not_exists\n/// statement with a dependent name.\n///\n/// The __if_exists statement can be used to include a sequence of statements\n/// in the program only when a particular dependent name does not exist. For\n/// example:\n///\n/// \\code\n/// template<typename T>\n/// void call_foo(T &t) {\n///   __if_exists (T::foo) {\n///     t.foo(); // okay: only called when T::foo exists.\n///   }\n/// }\n/// \\endcode\n///\n/// Similarly, the __if_not_exists statement can be used to include the\n/// statements when a particular name does not exist.\n///\n/// Note that this statement only captures __if_exists and __if_not_exists\n/// statements whose name is dependent. All non-dependent cases are handled\n/// directly in the parser, so that they don't introduce a new scope. Clang\n/// introduces scopes in the dependent case to keep names inside the compound\n/// statement from leaking out into the surround statements, which would\n/// compromise the template instantiation model. This behavior differs from\n/// Visual C++ (which never introduces a scope), but is a fairly reasonable\n/// approximation of the VC++ behavior.\nclass MSDependentExistsStmt : public Stmt {\n  SourceLocation KeywordLoc;\n  bool IsIfExists;\n  NestedNameSpecifierLoc QualifierLoc;\n  DeclarationNameInfo NameInfo;\n  Stmt *SubStmt;\n\n  friend class ASTReader;\n  friend class ASTStmtReader;\n\npublic:\n  MSDependentExistsStmt(SourceLocation KeywordLoc, bool IsIfExists,\n                        NestedNameSpecifierLoc QualifierLoc,\n                        DeclarationNameInfo NameInfo,\n                        CompoundStmt *SubStmt)\n  : Stmt(MSDependentExistsStmtClass),\n    KeywordLoc(KeywordLoc), IsIfExists(IsIfExists),\n    QualifierLoc(QualifierLoc), NameInfo(NameInfo),\n    SubStmt(reinterpret_cast<Stmt *>(SubStmt)) { }\n\n  /// Retrieve the location of the __if_exists or __if_not_exists\n  /// keyword.\n  SourceLocation getKeywordLoc() const { return KeywordLoc; }\n\n  /// Determine whether this is an __if_exists statement.\n  bool isIfExists() const { return IsIfExists; }\n\n  /// Determine whether this is an __if_exists statement.\n  bool isIfNotExists() const { return !IsIfExists; }\n\n  /// Retrieve the nested-name-specifier that qualifies this name, if\n  /// any.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the name of the entity we're testing for, along with\n  /// location information\n  DeclarationNameInfo getNameInfo() const { return NameInfo; }\n\n  /// Retrieve the compound statement that will be included in the\n  /// program only if the existence of the symbol matches the initial keyword.\n  CompoundStmt *getSubStmt() const {\n    return reinterpret_cast<CompoundStmt *>(SubStmt);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return KeywordLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return SubStmt->getEndLoc();\n  }\n\n  child_range children() {\n    return child_range(&SubStmt, &SubStmt+1);\n  }\n\n  const_child_range children() const {\n    return const_child_range(&SubStmt, &SubStmt + 1);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == MSDependentExistsStmtClass;\n  }\n};\n\n/// Represents the body of a coroutine. This wraps the normal function\n/// body and holds the additional semantic context required to set up and tear\n/// down the coroutine frame.\nclass CoroutineBodyStmt final\n    : public Stmt,\n      private llvm::TrailingObjects<CoroutineBodyStmt, Stmt *> {\n  enum SubStmt {\n    Body,          ///< The body of the coroutine.\n    Promise,       ///< The promise statement.\n    InitSuspend,   ///< The initial suspend statement, run before the body.\n    FinalSuspend,  ///< The final suspend statement, run after the body.\n    OnException,   ///< Handler for exceptions thrown in the body.\n    OnFallthrough, ///< Handler for control flow falling off the body.\n    Allocate,      ///< Coroutine frame memory allocation.\n    Deallocate,    ///< Coroutine frame memory deallocation.\n    ReturnValue,   ///< Return value for thunk function: p.get_return_object().\n    ResultDecl,    ///< Declaration holding the result of get_return_object.\n    ReturnStmt,    ///< Return statement for the thunk function.\n    ReturnStmtOnAllocFailure, ///< Return statement if allocation failed.\n    FirstParamMove ///< First offset for move construction of parameter copies.\n  };\n  unsigned NumParams;\n\n  friend class ASTStmtReader;\n  friend class ASTReader;\n  friend TrailingObjects;\n\n  Stmt **getStoredStmts() { return getTrailingObjects<Stmt *>(); }\n\n  Stmt *const *getStoredStmts() const { return getTrailingObjects<Stmt *>(); }\n\npublic:\n\n  struct CtorArgs {\n    Stmt *Body = nullptr;\n    Stmt *Promise = nullptr;\n    Expr *InitialSuspend = nullptr;\n    Expr *FinalSuspend = nullptr;\n    Stmt *OnException = nullptr;\n    Stmt *OnFallthrough = nullptr;\n    Expr *Allocate = nullptr;\n    Expr *Deallocate = nullptr;\n    Expr *ReturnValue = nullptr;\n    Stmt *ResultDecl = nullptr;\n    Stmt *ReturnStmt = nullptr;\n    Stmt *ReturnStmtOnAllocFailure = nullptr;\n    ArrayRef<Stmt *> ParamMoves;\n  };\n\nprivate:\n\n  CoroutineBodyStmt(CtorArgs const& Args);\n\npublic:\n  static CoroutineBodyStmt *Create(const ASTContext &C, CtorArgs const &Args);\n  static CoroutineBodyStmt *Create(const ASTContext &C, EmptyShell,\n                                   unsigned NumParams);\n\n  bool hasDependentPromiseType() const {\n    return getPromiseDecl()->getType()->isDependentType();\n  }\n\n  /// Retrieve the body of the coroutine as written. This will be either\n  /// a CompoundStmt or a TryStmt.\n  Stmt *getBody() const {\n    return getStoredStmts()[SubStmt::Body];\n  }\n\n  Stmt *getPromiseDeclStmt() const {\n    return getStoredStmts()[SubStmt::Promise];\n  }\n  VarDecl *getPromiseDecl() const {\n    return cast<VarDecl>(cast<DeclStmt>(getPromiseDeclStmt())->getSingleDecl());\n  }\n\n  Stmt *getInitSuspendStmt() const {\n    return getStoredStmts()[SubStmt::InitSuspend];\n  }\n  Stmt *getFinalSuspendStmt() const {\n    return getStoredStmts()[SubStmt::FinalSuspend];\n  }\n\n  Stmt *getExceptionHandler() const {\n    return getStoredStmts()[SubStmt::OnException];\n  }\n  Stmt *getFallthroughHandler() const {\n    return getStoredStmts()[SubStmt::OnFallthrough];\n  }\n\n  Expr *getAllocate() const {\n    return cast_or_null<Expr>(getStoredStmts()[SubStmt::Allocate]);\n  }\n  Expr *getDeallocate() const {\n    return cast_or_null<Expr>(getStoredStmts()[SubStmt::Deallocate]);\n  }\n  Expr *getReturnValueInit() const {\n    return cast<Expr>(getStoredStmts()[SubStmt::ReturnValue]);\n  }\n  Stmt *getResultDecl() const { return getStoredStmts()[SubStmt::ResultDecl]; }\n  Stmt *getReturnStmt() const { return getStoredStmts()[SubStmt::ReturnStmt]; }\n  Stmt *getReturnStmtOnAllocFailure() const {\n    return getStoredStmts()[SubStmt::ReturnStmtOnAllocFailure];\n  }\n  ArrayRef<Stmt const *> getParamMoves() const {\n    return {getStoredStmts() + SubStmt::FirstParamMove, NumParams};\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getBody() ? getBody()->getBeginLoc()\n                     : getPromiseDecl()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getBody() ? getBody()->getEndLoc() : getPromiseDecl()->getEndLoc();\n  }\n\n  child_range children() {\n    return child_range(getStoredStmts(),\n                       getStoredStmts() + SubStmt::FirstParamMove + NumParams);\n  }\n\n  const_child_range children() const {\n    return const_child_range(getStoredStmts(), getStoredStmts() +\n                                                   SubStmt::FirstParamMove +\n                                                   NumParams);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CoroutineBodyStmtClass;\n  }\n};\n\n/// Represents a 'co_return' statement in the C++ Coroutines TS.\n///\n/// This statament models the initialization of the coroutine promise\n/// (encapsulating the eventual notional return value) from an expression\n/// (or braced-init-list), followed by termination of the coroutine.\n///\n/// This initialization is modeled by the evaluation of the operand\n/// followed by a call to one of:\n///   <promise>.return_value(<operand>)\n///   <promise>.return_void()\n/// which we name the \"promise call\".\nclass CoreturnStmt : public Stmt {\n  SourceLocation CoreturnLoc;\n\n  enum SubStmt { Operand, PromiseCall, Count };\n  Stmt *SubStmts[SubStmt::Count];\n\n  bool IsImplicit : 1;\n\n  friend class ASTStmtReader;\npublic:\n  CoreturnStmt(SourceLocation CoreturnLoc, Stmt *Operand, Stmt *PromiseCall,\n               bool IsImplicit = false)\n      : Stmt(CoreturnStmtClass), CoreturnLoc(CoreturnLoc),\n        IsImplicit(IsImplicit) {\n    SubStmts[SubStmt::Operand] = Operand;\n    SubStmts[SubStmt::PromiseCall] = PromiseCall;\n  }\n\n  CoreturnStmt(EmptyShell) : CoreturnStmt({}, {}, {}) {}\n\n  SourceLocation getKeywordLoc() const { return CoreturnLoc; }\n\n  /// Retrieve the operand of the 'co_return' statement. Will be nullptr\n  /// if none was specified.\n  Expr *getOperand() const { return static_cast<Expr*>(SubStmts[Operand]); }\n\n  /// Retrieve the promise call that results from this 'co_return'\n  /// statement. Will be nullptr if either the coroutine has not yet been\n  /// finalized or the coroutine has no eventual return type.\n  Expr *getPromiseCall() const {\n    return static_cast<Expr*>(SubStmts[PromiseCall]);\n  }\n\n  bool isImplicit() const { return IsImplicit; }\n  void setIsImplicit(bool value = true) { IsImplicit = value; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return CoreturnLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getOperand() ? getOperand()->getEndLoc() : getBeginLoc();\n  }\n\n  child_range children() {\n    if (!getOperand())\n      return child_range(SubStmts + SubStmt::PromiseCall,\n                         SubStmts + SubStmt::Count);\n    return child_range(SubStmts, SubStmts + SubStmt::Count);\n  }\n\n  const_child_range children() const {\n    if (!getOperand())\n      return const_child_range(SubStmts + SubStmt::PromiseCall,\n                               SubStmts + SubStmt::Count);\n    return const_child_range(SubStmts, SubStmts + SubStmt::Count);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CoreturnStmtClass;\n  }\n};\n\n}  // end namespace clang\n\n#endif\n"}, "14": {"id": 14, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtIterator.h", "content": "//===- StmtIterator.h - Iterators for Statements ----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the StmtIterator and ConstStmtIterator classes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_STMTITERATOR_H\n#define LLVM_CLANG_AST_STMTITERATOR_H\n\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n\nnamespace clang {\n\nclass Decl;\nclass Stmt;\nclass VariableArrayType;\n\nclass StmtIteratorBase {\nprotected:\n  enum {\n    StmtMode = 0x0,\n    SizeOfTypeVAMode = 0x1,\n    DeclGroupMode = 0x2,\n    Flags = 0x3\n  };\n\n  union {\n    Stmt **stmt;\n    Decl **DGI;\n  };\n  uintptr_t RawVAPtr = 0;\n  Decl **DGE;\n\n  StmtIteratorBase(Stmt **s) : stmt(s) {}\n  StmtIteratorBase(const VariableArrayType *t);\n  StmtIteratorBase(Decl **dgi, Decl **dge);\n  StmtIteratorBase() : stmt(nullptr) {}\n\n  bool inDeclGroup() const {\n    return (RawVAPtr & Flags) == DeclGroupMode;\n  }\n\n  bool inSizeOfTypeVA() const {\n    return (RawVAPtr & Flags) == SizeOfTypeVAMode;\n  }\n\n  bool inStmt() const {\n    return (RawVAPtr & Flags) == StmtMode;\n  }\n\n  const VariableArrayType *getVAPtr() const {\n    return reinterpret_cast<const VariableArrayType*>(RawVAPtr & ~Flags);\n  }\n\n  void setVAPtr(const VariableArrayType *P) {\n    assert(inDeclGroup() || inSizeOfTypeVA());\n    RawVAPtr = reinterpret_cast<uintptr_t>(P) | (RawVAPtr & Flags);\n  }\n\n  void NextDecl(bool ImmediateAdvance = true);\n  bool HandleDecl(Decl* D);\n  void NextVA();\n\n  Stmt*& GetDeclExpr() const;\n};\n\ntemplate <typename DERIVED, typename REFERENCE>\nclass StmtIteratorImpl : public StmtIteratorBase,\n                         public std::iterator<std::forward_iterator_tag,\n                                              REFERENCE, ptrdiff_t,\n                                              REFERENCE, REFERENCE> {\nprotected:\n  StmtIteratorImpl(const StmtIteratorBase& RHS) : StmtIteratorBase(RHS) {}\n\npublic:\n  StmtIteratorImpl() = default;\n  StmtIteratorImpl(Stmt **s) : StmtIteratorBase(s) {}\n  StmtIteratorImpl(Decl **dgi, Decl **dge) : StmtIteratorBase(dgi, dge) {}\n  StmtIteratorImpl(const VariableArrayType *t) : StmtIteratorBase(t) {}\n\n  DERIVED& operator++() {\n    if (inStmt())\n      ++stmt;\n    else if (getVAPtr())\n      NextVA();\n    else\n      NextDecl();\n\n    return static_cast<DERIVED&>(*this);\n  }\n\n  DERIVED operator++(int) {\n    DERIVED tmp = static_cast<DERIVED&>(*this);\n    operator++();\n    return tmp;\n  }\n\n  friend bool operator==(const DERIVED &LHS, const DERIVED &RHS) {\n    return LHS.stmt == RHS.stmt && LHS.DGI == RHS.DGI &&\n           LHS.RawVAPtr == RHS.RawVAPtr;\n  }\n\n  friend bool operator!=(const DERIVED &LHS, const DERIVED &RHS) {\n    return !(LHS == RHS);\n  }\n\n  REFERENCE operator*() const {\n    return inStmt() ? *stmt : GetDeclExpr();\n  }\n\n  REFERENCE operator->() const { return operator*(); }\n};\n\nstruct ConstStmtIterator;\n\nstruct StmtIterator : public StmtIteratorImpl<StmtIterator, Stmt*&> {\n  explicit StmtIterator() = default;\n  StmtIterator(Stmt** S) : StmtIteratorImpl<StmtIterator, Stmt*&>(S) {}\n  StmtIterator(Decl** dgi, Decl** dge)\n      : StmtIteratorImpl<StmtIterator, Stmt*&>(dgi, dge) {}\n  StmtIterator(const VariableArrayType *t)\n      : StmtIteratorImpl<StmtIterator, Stmt*&>(t) {}\n\nprivate:\n  StmtIterator(const StmtIteratorBase &RHS)\n      : StmtIteratorImpl<StmtIterator, Stmt *&>(RHS) {}\n\n  inline friend StmtIterator\n  cast_away_const(const ConstStmtIterator &RHS);\n};\n\nstruct ConstStmtIterator : public StmtIteratorImpl<ConstStmtIterator,\n                                                   const Stmt*> {\n  explicit ConstStmtIterator() = default;\n  ConstStmtIterator(const StmtIterator& RHS)\n      : StmtIteratorImpl<ConstStmtIterator, const Stmt*>(RHS) {}\n\n  ConstStmtIterator(Stmt * const *S)\n      : StmtIteratorImpl<ConstStmtIterator, const Stmt *>(\n            const_cast<Stmt **>(S)) {}\n};\n\ninline StmtIterator cast_away_const(const ConstStmtIterator &RHS) {\n  return RHS;\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_STMTITERATOR_H\n"}, "15": {"id": 15, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/TemplateBase.h", "content": "//===- TemplateBase.h - Core classes for C++ templates ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file provides definitions which are common for all kinds of\n//  template representation.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_TEMPLATEBASE_H\n#define LLVM_CLANG_AST_TEMPLATEBASE_H\n\n#include \"clang/AST/DependenceFlags.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/TemplateName.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n\nnamespace llvm {\n\nclass FoldingSetNodeID;\n\n// Provide PointerLikeTypeTraits for clang::Expr*, this default one requires a\n// full definition of Expr, but this file only sees a forward del because of\n// the dependency.\ntemplate <> struct PointerLikeTypeTraits<clang::Expr *> {\n  static inline void *getAsVoidPointer(clang::Expr *P) { return P; }\n  static inline clang::Expr *getFromVoidPointer(void *P) {\n    return static_cast<clang::Expr *>(P);\n  }\n  static constexpr int NumLowBitsAvailable = 2;\n};\n\n} // namespace llvm\n\nnamespace clang {\n\nclass ASTContext;\nclass DiagnosticBuilder;\nclass Expr;\nstruct PrintingPolicy;\nclass TypeSourceInfo;\nclass ValueDecl;\n\n/// Represents a template argument.\nclass TemplateArgument {\npublic:\n  /// The kind of template argument we're storing.\n  enum ArgKind {\n    /// Represents an empty template argument, e.g., one that has not\n    /// been deduced.\n    Null = 0,\n\n    /// The template argument is a type.\n    Type,\n\n    /// The template argument is a declaration that was provided for a pointer,\n    /// reference, or pointer to member non-type template parameter.\n    Declaration,\n\n    /// The template argument is a null pointer or null pointer to member that\n    /// was provided for a non-type template parameter.\n    NullPtr,\n\n    /// The template argument is an integral value stored in an llvm::APSInt\n    /// that was provided for an integral non-type template parameter.\n    Integral,\n\n    /// The template argument is a template name that was provided for a\n    /// template template parameter.\n    Template,\n\n    /// The template argument is a pack expansion of a template name that was\n    /// provided for a template template parameter.\n    TemplateExpansion,\n\n    /// The template argument is an expression, and we've not resolved it to one\n    /// of the other forms yet, either because it's dependent or because we're\n    /// representing a non-canonical template argument (for instance, in a\n    /// TemplateSpecializationType).\n    Expression,\n\n    /// The template argument is actually a parameter pack. Arguments are stored\n    /// in the Args struct.\n    Pack\n  };\n\nprivate:\n  /// The kind of template argument we're storing.\n\n  struct DA {\n    unsigned Kind;\n    void *QT;\n    ValueDecl *D;\n  };\n  struct I {\n    unsigned Kind;\n    // We store a decomposed APSInt with the data allocated by ASTContext if\n    // BitWidth > 64. The memory may be shared between multiple\n    // TemplateArgument instances.\n    unsigned BitWidth : 31;\n    unsigned IsUnsigned : 1;\n    union {\n      /// Used to store the <= 64 bits integer value.\n      uint64_t VAL;\n\n      /// Used to store the >64 bits integer value.\n      const uint64_t *pVal;\n    };\n    void *Type;\n  };\n  struct A {\n    unsigned Kind;\n    unsigned NumArgs;\n    const TemplateArgument *Args;\n  };\n  struct TA {\n    unsigned Kind;\n    unsigned NumExpansions;\n    void *Name;\n  };\n  struct TV {\n    unsigned Kind;\n    uintptr_t V;\n  };\n  union {\n    struct DA DeclArg;\n    struct I Integer;\n    struct A Args;\n    struct TA TemplateArg;\n    struct TV TypeOrValue;\n  };\n\npublic:\n  /// Construct an empty, invalid template argument.\n  constexpr TemplateArgument() : TypeOrValue({Null, 0}) {}\n\n  /// Construct a template type argument.\n  TemplateArgument(QualType T, bool isNullPtr = false) {\n    TypeOrValue.Kind = isNullPtr ? NullPtr : Type;\n    TypeOrValue.V = reinterpret_cast<uintptr_t>(T.getAsOpaquePtr());\n  }\n\n  /// Construct a template argument that refers to a\n  /// declaration, which is either an external declaration or a\n  /// template declaration.\n  TemplateArgument(ValueDecl *D, QualType QT) {\n    assert(D && \"Expected decl\");\n    DeclArg.Kind = Declaration;\n    DeclArg.QT = QT.getAsOpaquePtr();\n    DeclArg.D = D;\n  }\n\n  /// Construct an integral constant template argument. The memory to\n  /// store the value is allocated with Ctx.\n  TemplateArgument(ASTContext &Ctx, const llvm::APSInt &Value, QualType Type);\n\n  /// Construct an integral constant template argument with the same\n  /// value as Other but a different type.\n  TemplateArgument(const TemplateArgument &Other, QualType Type) {\n    Integer = Other.Integer;\n    Integer.Type = Type.getAsOpaquePtr();\n  }\n\n  /// Construct a template argument that is a template.\n  ///\n  /// This form of template argument is generally used for template template\n  /// parameters. However, the template name could be a dependent template\n  /// name that ends up being instantiated to a function template whose address\n  /// is taken.\n  ///\n  /// \\param Name The template name.\n  TemplateArgument(TemplateName Name) {\n    TemplateArg.Kind = Template;\n    TemplateArg.Name = Name.getAsVoidPointer();\n    TemplateArg.NumExpansions = 0;\n  }\n\n  /// Construct a template argument that is a template pack expansion.\n  ///\n  /// This form of template argument is generally used for template template\n  /// parameters. However, the template name could be a dependent template\n  /// name that ends up being instantiated to a function template whose address\n  /// is taken.\n  ///\n  /// \\param Name The template name.\n  ///\n  /// \\param NumExpansions The number of expansions that will be generated by\n  /// instantiating\n  TemplateArgument(TemplateName Name, Optional<unsigned> NumExpansions) {\n    TemplateArg.Kind = TemplateExpansion;\n    TemplateArg.Name = Name.getAsVoidPointer();\n    if (NumExpansions)\n      TemplateArg.NumExpansions = *NumExpansions + 1;\n    else\n      TemplateArg.NumExpansions = 0;\n  }\n\n  /// Construct a template argument that is an expression.\n  ///\n  /// This form of template argument only occurs in template argument\n  /// lists used for dependent types and for expression; it will not\n  /// occur in a non-dependent, canonical template argument list.\n  TemplateArgument(Expr *E) {\n    TypeOrValue.Kind = Expression;\n    TypeOrValue.V = reinterpret_cast<uintptr_t>(E);\n  }\n\n  /// Construct a template argument that is a template argument pack.\n  ///\n  /// We assume that storage for the template arguments provided\n  /// outlives the TemplateArgument itself.\n  explicit TemplateArgument(ArrayRef<TemplateArgument> Args) {\n    this->Args.Kind = Pack;\n    this->Args.Args = Args.data();\n    this->Args.NumArgs = Args.size();\n  }\n\n  TemplateArgument(TemplateName, bool) = delete;\n\n  static TemplateArgument getEmptyPack() { return TemplateArgument(None); }\n\n  /// Create a new template argument pack by copying the given set of\n  /// template arguments.\n  static TemplateArgument CreatePackCopy(ASTContext &Context,\n                                         ArrayRef<TemplateArgument> Args);\n\n  /// Return the kind of stored template argument.\n  ArgKind getKind() const { return (ArgKind)TypeOrValue.Kind; }\n\n  /// Determine whether this template argument has no value.\n  bool isNull() const { return getKind() == Null; }\n\n  TemplateArgumentDependence getDependence() const;\n\n  /// Whether this template argument is dependent on a template\n  /// parameter such that its result can change from one instantiation to\n  /// another.\n  bool isDependent() const;\n\n  /// Whether this template argument is dependent on a template\n  /// parameter.\n  bool isInstantiationDependent() const;\n\n  /// Whether this template argument contains an unexpanded\n  /// parameter pack.\n  bool containsUnexpandedParameterPack() const;\n\n  /// Determine whether this template argument is a pack expansion.\n  bool isPackExpansion() const;\n\n  /// Retrieve the type for a type template argument.\n  QualType getAsType() const {\n    assert(getKind() == Type && \"Unexpected kind\");\n    return QualType::getFromOpaquePtr(reinterpret_cast<void*>(TypeOrValue.V));\n  }\n\n  /// Retrieve the declaration for a declaration non-type\n  /// template argument.\n  ValueDecl *getAsDecl() const {\n    assert(getKind() == Declaration && \"Unexpected kind\");\n    return DeclArg.D;\n  }\n\n  QualType getParamTypeForDecl() const {\n    assert(getKind() == Declaration && \"Unexpected kind\");\n    return QualType::getFromOpaquePtr(DeclArg.QT);\n  }\n\n  /// Retrieve the type for null non-type template argument.\n  QualType getNullPtrType() const {\n    assert(getKind() == NullPtr && \"Unexpected kind\");\n    return QualType::getFromOpaquePtr(reinterpret_cast<void*>(TypeOrValue.V));\n  }\n\n  /// Retrieve the template name for a template name argument.\n  TemplateName getAsTemplate() const {\n    assert(getKind() == Template && \"Unexpected kind\");\n    return TemplateName::getFromVoidPointer(TemplateArg.Name);\n  }\n\n  /// Retrieve the template argument as a template name; if the argument\n  /// is a pack expansion, return the pattern as a template name.\n  TemplateName getAsTemplateOrTemplatePattern() const {\n    assert((getKind() == Template || getKind() == TemplateExpansion) &&\n           \"Unexpected kind\");\n\n    return TemplateName::getFromVoidPointer(TemplateArg.Name);\n  }\n\n  /// Retrieve the number of expansions that a template template argument\n  /// expansion will produce, if known.\n  Optional<unsigned> getNumTemplateExpansions() const;\n\n  /// Retrieve the template argument as an integral value.\n  // FIXME: Provide a way to read the integral data without copying the value.\n  llvm::APSInt getAsIntegral() const {\n    assert(getKind() == Integral && \"Unexpected kind\");\n\n    using namespace llvm;\n\n    if (Integer.BitWidth <= 64)\n      return APSInt(APInt(Integer.BitWidth, Integer.VAL), Integer.IsUnsigned);\n\n    unsigned NumWords = APInt::getNumWords(Integer.BitWidth);\n    return APSInt(APInt(Integer.BitWidth, makeArrayRef(Integer.pVal, NumWords)),\n                  Integer.IsUnsigned);\n  }\n\n  /// Retrieve the type of the integral value.\n  QualType getIntegralType() const {\n    assert(getKind() == Integral && \"Unexpected kind\");\n    return QualType::getFromOpaquePtr(Integer.Type);\n  }\n\n  void setIntegralType(QualType T) {\n    assert(getKind() == Integral && \"Unexpected kind\");\n    Integer.Type = T.getAsOpaquePtr();\n  }\n\n  /// If this is a non-type template argument, get its type. Otherwise,\n  /// returns a null QualType.\n  QualType getNonTypeTemplateArgumentType() const;\n\n  /// Retrieve the template argument as an expression.\n  Expr *getAsExpr() const {\n    assert(getKind() == Expression && \"Unexpected kind\");\n    return reinterpret_cast<Expr *>(TypeOrValue.V);\n  }\n\n  /// Iterator that traverses the elements of a template argument pack.\n  using pack_iterator = const TemplateArgument *;\n\n  /// Iterator referencing the first argument of a template argument\n  /// pack.\n  pack_iterator pack_begin() const {\n    assert(getKind() == Pack);\n    return Args.Args;\n  }\n\n  /// Iterator referencing one past the last argument of a template\n  /// argument pack.\n  pack_iterator pack_end() const {\n    assert(getKind() == Pack);\n    return Args.Args + Args.NumArgs;\n  }\n\n  /// Iterator range referencing all of the elements of a template\n  /// argument pack.\n  ArrayRef<TemplateArgument> pack_elements() const {\n    return llvm::makeArrayRef(pack_begin(), pack_end());\n  }\n\n  /// The number of template arguments in the given template argument\n  /// pack.\n  unsigned pack_size() const {\n    assert(getKind() == Pack);\n    return Args.NumArgs;\n  }\n\n  /// Return the array of arguments in this template argument pack.\n  ArrayRef<TemplateArgument> getPackAsArray() const {\n    assert(getKind() == Pack);\n    return llvm::makeArrayRef(Args.Args, Args.NumArgs);\n  }\n\n  /// Determines whether two template arguments are superficially the\n  /// same.\n  bool structurallyEquals(const TemplateArgument &Other) const;\n\n  /// When the template argument is a pack expansion, returns\n  /// the pattern of the pack expansion.\n  TemplateArgument getPackExpansionPattern() const;\n\n  /// Print this template argument to the given output stream.\n  void print(const PrintingPolicy &Policy, raw_ostream &Out) const;\n\n  /// Debugging aid that dumps the template argument.\n  void dump(raw_ostream &Out) const;\n\n  /// Debugging aid that dumps the template argument to standard error.\n  void dump() const;\n\n  /// Used to insert TemplateArguments into FoldingSets.\n  void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context) const;\n};\n\n/// Location information for a TemplateArgument.\nstruct TemplateArgumentLocInfo {\nprivate:\n  struct TemplateTemplateArgLocInfo {\n    // FIXME: We'd like to just use the qualifier in the TemplateName,\n    // but template arguments get canonicalized too quickly.\n    NestedNameSpecifier *Qualifier;\n    void *QualifierLocData;\n    SourceLocation TemplateNameLoc;\n    SourceLocation EllipsisLoc;\n  };\n\n  llvm::PointerUnion<TemplateTemplateArgLocInfo *, Expr *, TypeSourceInfo *>\n      Pointer;\n\n  TemplateTemplateArgLocInfo *getTemplate() const {\n    return Pointer.get<TemplateTemplateArgLocInfo *>();\n  }\n\npublic:\n  TemplateArgumentLocInfo() {}\n  TemplateArgumentLocInfo(TypeSourceInfo *Declarator) { Pointer = Declarator; }\n\n  TemplateArgumentLocInfo(Expr *E) { Pointer = E; }\n  // Ctx is used for allocation -- this case is unusually large and also rare,\n  // so we store the payload out-of-line.\n  TemplateArgumentLocInfo(ASTContext &Ctx, NestedNameSpecifierLoc QualifierLoc,\n                          SourceLocation TemplateNameLoc,\n                          SourceLocation EllipsisLoc);\n\n  TypeSourceInfo *getAsTypeSourceInfo() const {\n    return Pointer.get<TypeSourceInfo *>();\n  }\n\n  Expr *getAsExpr() const { return Pointer.get<Expr *>(); }\n\n  NestedNameSpecifierLoc getTemplateQualifierLoc() const {\n    const auto *Template = getTemplate();\n    return NestedNameSpecifierLoc(Template->Qualifier,\n                                  Template->QualifierLocData);\n  }\n\n  SourceLocation getTemplateNameLoc() const {\n    return getTemplate()->TemplateNameLoc;\n  }\n\n  SourceLocation getTemplateEllipsisLoc() const {\n    return getTemplate()->EllipsisLoc;\n  }\n};\n\n/// Location wrapper for a TemplateArgument.  TemplateArgument is to\n/// TemplateArgumentLoc as Type is to TypeLoc.\nclass TemplateArgumentLoc {\n  TemplateArgument Argument;\n  TemplateArgumentLocInfo LocInfo;\n\npublic:\n  TemplateArgumentLoc() {}\n\n  TemplateArgumentLoc(const TemplateArgument &Argument,\n                      TemplateArgumentLocInfo Opaque)\n      : Argument(Argument), LocInfo(Opaque) {}\n\n  TemplateArgumentLoc(const TemplateArgument &Argument, TypeSourceInfo *TInfo)\n      : Argument(Argument), LocInfo(TInfo) {\n    assert(Argument.getKind() == TemplateArgument::Type);\n  }\n\n  TemplateArgumentLoc(const TemplateArgument &Argument, Expr *E)\n      : Argument(Argument), LocInfo(E) {\n\n    // Permit any kind of template argument that can be represented with an\n    // expression.\n    assert(Argument.getKind() == TemplateArgument::NullPtr ||\n           Argument.getKind() == TemplateArgument::Integral ||\n           Argument.getKind() == TemplateArgument::Declaration ||\n           Argument.getKind() == TemplateArgument::Expression);\n  }\n\n  TemplateArgumentLoc(ASTContext &Ctx, const TemplateArgument &Argument,\n                      NestedNameSpecifierLoc QualifierLoc,\n                      SourceLocation TemplateNameLoc,\n                      SourceLocation EllipsisLoc = SourceLocation())\n      : Argument(Argument),\n        LocInfo(Ctx, QualifierLoc, TemplateNameLoc, EllipsisLoc) {\n    assert(Argument.getKind() == TemplateArgument::Template ||\n           Argument.getKind() == TemplateArgument::TemplateExpansion);\n  }\n\n  /// - Fetches the primary location of the argument.\n  SourceLocation getLocation() const {\n    if (Argument.getKind() == TemplateArgument::Template ||\n        Argument.getKind() == TemplateArgument::TemplateExpansion)\n      return getTemplateNameLoc();\n\n    return getSourceRange().getBegin();\n  }\n\n  /// - Fetches the full source range of the argument.\n  SourceRange getSourceRange() const LLVM_READONLY;\n\n  const TemplateArgument &getArgument() const {\n    return Argument;\n  }\n\n  TemplateArgumentLocInfo getLocInfo() const {\n    return LocInfo;\n  }\n\n  TypeSourceInfo *getTypeSourceInfo() const {\n    assert(Argument.getKind() == TemplateArgument::Type);\n    return LocInfo.getAsTypeSourceInfo();\n  }\n\n  Expr *getSourceExpression() const {\n    assert(Argument.getKind() == TemplateArgument::Expression);\n    return LocInfo.getAsExpr();\n  }\n\n  Expr *getSourceDeclExpression() const {\n    assert(Argument.getKind() == TemplateArgument::Declaration);\n    return LocInfo.getAsExpr();\n  }\n\n  Expr *getSourceNullPtrExpression() const {\n    assert(Argument.getKind() == TemplateArgument::NullPtr);\n    return LocInfo.getAsExpr();\n  }\n\n  Expr *getSourceIntegralExpression() const {\n    assert(Argument.getKind() == TemplateArgument::Integral);\n    return LocInfo.getAsExpr();\n  }\n\n  NestedNameSpecifierLoc getTemplateQualifierLoc() const {\n    if (Argument.getKind() != TemplateArgument::Template &&\n        Argument.getKind() != TemplateArgument::TemplateExpansion)\n      return NestedNameSpecifierLoc();\n    return LocInfo.getTemplateQualifierLoc();\n  }\n\n  SourceLocation getTemplateNameLoc() const {\n    if (Argument.getKind() != TemplateArgument::Template &&\n        Argument.getKind() != TemplateArgument::TemplateExpansion)\n      return SourceLocation();\n    return LocInfo.getTemplateNameLoc();\n  }\n\n  SourceLocation getTemplateEllipsisLoc() const {\n    if (Argument.getKind() != TemplateArgument::TemplateExpansion)\n      return SourceLocation();\n    return LocInfo.getTemplateEllipsisLoc();\n  }\n};\n\n/// A convenient class for passing around template argument\n/// information.  Designed to be passed by reference.\nclass TemplateArgumentListInfo {\n  SmallVector<TemplateArgumentLoc, 8> Arguments;\n  SourceLocation LAngleLoc;\n  SourceLocation RAngleLoc;\n\npublic:\n  TemplateArgumentListInfo() = default;\n\n  TemplateArgumentListInfo(SourceLocation LAngleLoc,\n                           SourceLocation RAngleLoc)\n      : LAngleLoc(LAngleLoc), RAngleLoc(RAngleLoc) {}\n\n  // This can leak if used in an AST node, use ASTTemplateArgumentListInfo\n  // instead.\n  void *operator new(size_t bytes, ASTContext &C) = delete;\n\n  SourceLocation getLAngleLoc() const { return LAngleLoc; }\n  SourceLocation getRAngleLoc() const { return RAngleLoc; }\n\n  void setLAngleLoc(SourceLocation Loc) { LAngleLoc = Loc; }\n  void setRAngleLoc(SourceLocation Loc) { RAngleLoc = Loc; }\n\n  unsigned size() const { return Arguments.size(); }\n\n  const TemplateArgumentLoc *getArgumentArray() const {\n    return Arguments.data();\n  }\n\n  llvm::ArrayRef<TemplateArgumentLoc> arguments() const {\n    return Arguments;\n  }\n\n  const TemplateArgumentLoc &operator[](unsigned I) const {\n    return Arguments[I];\n  }\n\n  TemplateArgumentLoc &operator[](unsigned I) {\n    return Arguments[I];\n  }\n\n  void addArgument(const TemplateArgumentLoc &Loc) {\n    Arguments.push_back(Loc);\n  }\n};\n\n/// Represents an explicit template argument list in C++, e.g.,\n/// the \"<int>\" in \"sort<int>\".\n/// This is safe to be used inside an AST node, in contrast with\n/// TemplateArgumentListInfo.\nstruct ASTTemplateArgumentListInfo final\n    : private llvm::TrailingObjects<ASTTemplateArgumentListInfo,\n                                    TemplateArgumentLoc> {\nprivate:\n  friend class ASTNodeImporter;\n  friend TrailingObjects;\n\n  ASTTemplateArgumentListInfo(const TemplateArgumentListInfo &List);\n\npublic:\n  /// The source location of the left angle bracket ('<').\n  SourceLocation LAngleLoc;\n\n  /// The source location of the right angle bracket ('>').\n  SourceLocation RAngleLoc;\n\n  /// The number of template arguments in TemplateArgs.\n  unsigned NumTemplateArgs;\n\n  SourceLocation getLAngleLoc() const { return LAngleLoc; }\n  SourceLocation getRAngleLoc() const { return RAngleLoc; }\n\n  /// Retrieve the template arguments\n  const TemplateArgumentLoc *getTemplateArgs() const {\n    return getTrailingObjects<TemplateArgumentLoc>();\n  }\n  unsigned getNumTemplateArgs() const { return NumTemplateArgs; }\n\n  llvm::ArrayRef<TemplateArgumentLoc> arguments() const {\n    return llvm::makeArrayRef(getTemplateArgs(), getNumTemplateArgs());\n  }\n\n  const TemplateArgumentLoc &operator[](unsigned I) const {\n    return getTemplateArgs()[I];\n  }\n\n  static const ASTTemplateArgumentListInfo *\n  Create(const ASTContext &C, const TemplateArgumentListInfo &List);\n};\n\n/// Represents an explicit template argument list in C++, e.g.,\n/// the \"<int>\" in \"sort<int>\".\n///\n/// It is intended to be used as a trailing object on AST nodes, and\n/// as such, doesn't contain the array of TemplateArgumentLoc itself,\n/// but expects the containing object to also provide storage for\n/// that.\nstruct alignas(void *) ASTTemplateKWAndArgsInfo {\n  /// The source location of the left angle bracket ('<').\n  SourceLocation LAngleLoc;\n\n  /// The source location of the right angle bracket ('>').\n  SourceLocation RAngleLoc;\n\n  /// The source location of the template keyword; this is used\n  /// as part of the representation of qualified identifiers, such as\n  /// S<T>::template apply<T>.  Will be empty if this expression does\n  /// not have a template keyword.\n  SourceLocation TemplateKWLoc;\n\n  /// The number of template arguments in TemplateArgs.\n  unsigned NumTemplateArgs;\n\n  void initializeFrom(SourceLocation TemplateKWLoc,\n                      const TemplateArgumentListInfo &List,\n                      TemplateArgumentLoc *OutArgArray);\n  // FIXME: The parameter Deps is the result populated by this method, the\n  // caller doesn't need it since it is populated by computeDependence. remove\n  // it.\n  void initializeFrom(SourceLocation TemplateKWLoc,\n                      const TemplateArgumentListInfo &List,\n                      TemplateArgumentLoc *OutArgArray,\n                      TemplateArgumentDependence &Deps);\n  void initializeFrom(SourceLocation TemplateKWLoc);\n\n  void copyInto(const TemplateArgumentLoc *ArgArray,\n                TemplateArgumentListInfo &List) const;\n};\n\nconst StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                      const TemplateArgument &Arg);\n\ninline TemplateSpecializationType::iterator\n    TemplateSpecializationType::end() const {\n  return getArgs() + getNumArgs();\n}\n\ninline DependentTemplateSpecializationType::iterator\n    DependentTemplateSpecializationType::end() const {\n  return getArgs() + getNumArgs();\n}\n\ninline const TemplateArgument &\n    TemplateSpecializationType::getArg(unsigned Idx) const {\n  assert(Idx < getNumArgs() && \"Template argument out of range\");\n  return getArgs()[Idx];\n}\n\ninline const TemplateArgument &\n    DependentTemplateSpecializationType::getArg(unsigned Idx) const {\n  assert(Idx < getNumArgs() && \"Template argument out of range\");\n  return getArgs()[Idx];\n}\n\ninline const TemplateArgument &AutoType::getArg(unsigned Idx) const {\n  assert(Idx < getNumArgs() && \"Template argument out of range\");\n  return getArgs()[Idx];\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_TEMPLATEBASE_H\n"}, "16": {"id": 16, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/TemplateName.h", "content": "//===- TemplateName.h - C++ Template Name Representation --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the TemplateName interface and subclasses.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_TEMPLATENAME_H\n#define LLVM_CLANG_AST_TEMPLATENAME_H\n\n#include \"clang/AST/DependenceFlags.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include <cassert>\n\nnamespace clang {\n\nclass ASTContext;\nclass DependentTemplateName;\nclass DiagnosticBuilder;\nclass IdentifierInfo;\nclass NamedDecl;\nclass NestedNameSpecifier;\nenum OverloadedOperatorKind : int;\nclass OverloadedTemplateStorage;\nclass AssumedTemplateStorage;\nclass PartialDiagnostic;\nstruct PrintingPolicy;\nclass QualifiedTemplateName;\nclass SubstTemplateTemplateParmPackStorage;\nclass SubstTemplateTemplateParmStorage;\nclass TemplateArgument;\nclass TemplateDecl;\nclass TemplateTemplateParmDecl;\n\n/// Implementation class used to describe either a set of overloaded\n/// template names or an already-substituted template template parameter pack.\nclass UncommonTemplateNameStorage {\nprotected:\n  enum Kind {\n    Overloaded,\n    Assumed, // defined in DeclarationName.h\n    SubstTemplateTemplateParm,\n    SubstTemplateTemplateParmPack\n  };\n\n  struct BitsTag {\n    /// A Kind.\n    unsigned Kind : 2;\n\n    /// The number of stored templates or template arguments,\n    /// depending on which subclass we have.\n    unsigned Size : 30;\n  };\n\n  union {\n    struct BitsTag Bits;\n    void *PointerAlignment;\n  };\n\n  UncommonTemplateNameStorage(Kind kind, unsigned size) {\n    Bits.Kind = kind;\n    Bits.Size = size;\n  }\n\npublic:\n  unsigned size() const { return Bits.Size; }\n\n  OverloadedTemplateStorage *getAsOverloadedStorage()  {\n    return Bits.Kind == Overloaded\n             ? reinterpret_cast<OverloadedTemplateStorage *>(this)\n             : nullptr;\n  }\n\n  AssumedTemplateStorage *getAsAssumedTemplateName()  {\n    return Bits.Kind == Assumed\n             ? reinterpret_cast<AssumedTemplateStorage *>(this)\n             : nullptr;\n  }\n\n  SubstTemplateTemplateParmStorage *getAsSubstTemplateTemplateParm() {\n    return Bits.Kind == SubstTemplateTemplateParm\n             ? reinterpret_cast<SubstTemplateTemplateParmStorage *>(this)\n             : nullptr;\n  }\n\n  SubstTemplateTemplateParmPackStorage *getAsSubstTemplateTemplateParmPack() {\n    return Bits.Kind == SubstTemplateTemplateParmPack\n             ? reinterpret_cast<SubstTemplateTemplateParmPackStorage *>(this)\n             : nullptr;\n  }\n};\n\n/// A structure for storing the information associated with an\n/// overloaded template name.\nclass OverloadedTemplateStorage : public UncommonTemplateNameStorage {\n  friend class ASTContext;\n\n  OverloadedTemplateStorage(unsigned size)\n      : UncommonTemplateNameStorage(Overloaded, size) {}\n\n  NamedDecl **getStorage() {\n    return reinterpret_cast<NamedDecl **>(this + 1);\n  }\n  NamedDecl * const *getStorage() const {\n    return reinterpret_cast<NamedDecl *const *>(this + 1);\n  }\n\npublic:\n  using iterator = NamedDecl *const *;\n\n  iterator begin() const { return getStorage(); }\n  iterator end() const { return getStorage() + size(); }\n\n  llvm::ArrayRef<NamedDecl*> decls() const {\n    return llvm::makeArrayRef(begin(), end());\n  }\n};\n\n/// A structure for storing an already-substituted template template\n/// parameter pack.\n///\n/// This kind of template names occurs when the parameter pack has been\n/// provided with a template template argument pack in a context where its\n/// enclosing pack expansion could not be fully expanded.\nclass SubstTemplateTemplateParmPackStorage\n  : public UncommonTemplateNameStorage, public llvm::FoldingSetNode\n{\n  TemplateTemplateParmDecl *Parameter;\n  const TemplateArgument *Arguments;\n\npublic:\n  SubstTemplateTemplateParmPackStorage(TemplateTemplateParmDecl *Parameter,\n                                       unsigned Size,\n                                       const TemplateArgument *Arguments)\n      : UncommonTemplateNameStorage(SubstTemplateTemplateParmPack, Size),\n        Parameter(Parameter), Arguments(Arguments) {}\n\n  /// Retrieve the template template parameter pack being substituted.\n  TemplateTemplateParmDecl *getParameterPack() const {\n    return Parameter;\n  }\n\n  /// Retrieve the template template argument pack with which this\n  /// parameter was substituted.\n  TemplateArgument getArgumentPack() const;\n\n  void Profile(llvm::FoldingSetNodeID &ID, ASTContext &Context);\n\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      ASTContext &Context,\n                      TemplateTemplateParmDecl *Parameter,\n                      const TemplateArgument &ArgPack);\n};\n\n/// Represents a C++ template name within the type system.\n///\n/// A C++ template name refers to a template within the C++ type\n/// system. In most cases, a template name is simply a reference to a\n/// class template, e.g.\n///\n/// \\code\n/// template<typename T> class X { };\n///\n/// X<int> xi;\n/// \\endcode\n///\n/// Here, the 'X' in \\c X<int> is a template name that refers to the\n/// declaration of the class template X, above. Template names can\n/// also refer to function templates, C++0x template aliases, etc.\n///\n/// Some template names are dependent. For example, consider:\n///\n/// \\code\n/// template<typename MetaFun, typename T1, typename T2> struct apply2 {\n///   typedef typename MetaFun::template apply<T1, T2>::type type;\n/// };\n/// \\endcode\n///\n/// Here, \"apply\" is treated as a template name within the typename\n/// specifier in the typedef. \"apply\" is a nested template, and can\n/// only be understood in the context of\nclass TemplateName {\n  using StorageType =\n      llvm::PointerUnion<TemplateDecl *, UncommonTemplateNameStorage *,\n                         QualifiedTemplateName *, DependentTemplateName *>;\n\n  StorageType Storage;\n\n  explicit TemplateName(void *Ptr);\n\npublic:\n  // Kind of name that is actually stored.\n  enum NameKind {\n    /// A single template declaration.\n    Template,\n\n    /// A set of overloaded template declarations.\n    OverloadedTemplate,\n\n    /// An unqualified-id that has been assumed to name a function template\n    /// that will be found by ADL.\n    AssumedTemplate,\n\n    /// A qualified template name, where the qualification is kept\n    /// to describe the source code as written.\n    QualifiedTemplate,\n\n    /// A dependent template name that has not been resolved to a\n    /// template (or set of templates).\n    DependentTemplate,\n\n    /// A template template parameter that has been substituted\n    /// for some other template name.\n    SubstTemplateTemplateParm,\n\n    /// A template template parameter pack that has been substituted for\n    /// a template template argument pack, but has not yet been expanded into\n    /// individual arguments.\n    SubstTemplateTemplateParmPack\n  };\n\n  TemplateName() = default;\n  explicit TemplateName(TemplateDecl *Template);\n  explicit TemplateName(OverloadedTemplateStorage *Storage);\n  explicit TemplateName(AssumedTemplateStorage *Storage);\n  explicit TemplateName(SubstTemplateTemplateParmStorage *Storage);\n  explicit TemplateName(SubstTemplateTemplateParmPackStorage *Storage);\n  explicit TemplateName(QualifiedTemplateName *Qual);\n  explicit TemplateName(DependentTemplateName *Dep);\n\n  /// Determine whether this template name is NULL.\n  bool isNull() const;\n\n  // Get the kind of name that is actually stored.\n  NameKind getKind() const;\n\n  /// Retrieve the underlying template declaration that\n  /// this template name refers to, if known.\n  ///\n  /// \\returns The template declaration that this template name refers\n  /// to, if any. If the template name does not refer to a specific\n  /// declaration because it is a dependent name, or if it refers to a\n  /// set of function templates, returns NULL.\n  TemplateDecl *getAsTemplateDecl() const;\n\n  /// Retrieve the underlying, overloaded function template\n  /// declarations that this template name refers to, if known.\n  ///\n  /// \\returns The set of overloaded function templates that this template\n  /// name refers to, if known. If the template name does not refer to a\n  /// specific set of function templates because it is a dependent name or\n  /// refers to a single template, returns NULL.\n  OverloadedTemplateStorage *getAsOverloadedTemplate() const;\n\n  /// Retrieve information on a name that has been assumed to be a\n  /// template-name in order to permit a call via ADL.\n  AssumedTemplateStorage *getAsAssumedTemplateName() const;\n\n  /// Retrieve the substituted template template parameter, if\n  /// known.\n  ///\n  /// \\returns The storage for the substituted template template parameter,\n  /// if known. Otherwise, returns NULL.\n  SubstTemplateTemplateParmStorage *getAsSubstTemplateTemplateParm() const;\n\n  /// Retrieve the substituted template template parameter pack, if\n  /// known.\n  ///\n  /// \\returns The storage for the substituted template template parameter pack,\n  /// if known. Otherwise, returns NULL.\n  SubstTemplateTemplateParmPackStorage *\n  getAsSubstTemplateTemplateParmPack() const;\n\n  /// Retrieve the underlying qualified template name\n  /// structure, if any.\n  QualifiedTemplateName *getAsQualifiedTemplateName() const;\n\n  /// Retrieve the underlying dependent template name\n  /// structure, if any.\n  DependentTemplateName *getAsDependentTemplateName() const;\n\n  TemplateName getUnderlying() const;\n\n  /// Get the template name to substitute when this template name is used as a\n  /// template template argument. This refers to the most recent declaration of\n  /// the template, including any default template arguments.\n  TemplateName getNameToSubstitute() const;\n\n  TemplateNameDependence getDependence() const;\n\n  /// Determines whether this is a dependent template name.\n  bool isDependent() const;\n\n  /// Determines whether this is a template name that somehow\n  /// depends on a template parameter.\n  bool isInstantiationDependent() const;\n\n  /// Determines whether this template name contains an\n  /// unexpanded parameter pack (for C++0x variadic templates).\n  bool containsUnexpandedParameterPack() const;\n\n  /// Print the template name.\n  ///\n  /// \\param OS the output stream to which the template name will be\n  /// printed.\n  ///\n  /// \\param SuppressNNS if true, don't print the\n  /// nested-name-specifier that precedes the template name (if it has\n  /// one).\n  void print(raw_ostream &OS, const PrintingPolicy &Policy,\n             bool SuppressNNS = false) const;\n\n  /// Debugging aid that dumps the template name.\n  void dump(raw_ostream &OS) const;\n\n  /// Debugging aid that dumps the template name to standard\n  /// error.\n  void dump() const;\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    ID.AddPointer(Storage.getOpaqueValue());\n  }\n\n  /// Retrieve the template name as a void pointer.\n  void *getAsVoidPointer() const { return Storage.getOpaqueValue(); }\n\n  /// Build a template name from a void pointer.\n  static TemplateName getFromVoidPointer(void *Ptr) {\n    return TemplateName(Ptr);\n  }\n};\n\n/// Insertion operator for diagnostics.  This allows sending TemplateName's\n/// into a diagnostic with <<.\nconst StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                      TemplateName N);\n\n/// A structure for storing the information associated with a\n/// substituted template template parameter.\nclass SubstTemplateTemplateParmStorage\n  : public UncommonTemplateNameStorage, public llvm::FoldingSetNode {\n  friend class ASTContext;\n\n  TemplateTemplateParmDecl *Parameter;\n  TemplateName Replacement;\n\n  SubstTemplateTemplateParmStorage(TemplateTemplateParmDecl *parameter,\n                                   TemplateName replacement)\n      : UncommonTemplateNameStorage(SubstTemplateTemplateParm, 0),\n        Parameter(parameter), Replacement(replacement) {}\n\npublic:\n  TemplateTemplateParmDecl *getParameter() const { return Parameter; }\n  TemplateName getReplacement() const { return Replacement; }\n\n  void Profile(llvm::FoldingSetNodeID &ID);\n\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      TemplateTemplateParmDecl *parameter,\n                      TemplateName replacement);\n};\n\ninline TemplateName TemplateName::getUnderlying() const {\n  if (SubstTemplateTemplateParmStorage *subst\n        = getAsSubstTemplateTemplateParm())\n    return subst->getReplacement().getUnderlying();\n  return *this;\n}\n\n/// Represents a template name that was expressed as a\n/// qualified name.\n///\n/// This kind of template name refers to a template name that was\n/// preceded by a nested name specifier, e.g., \\c std::vector. Here,\n/// the nested name specifier is \"std::\" and the template name is the\n/// declaration for \"vector\". The QualifiedTemplateName class is only\n/// used to provide \"sugar\" for template names that were expressed\n/// with a qualified name, and has no semantic meaning. In this\n/// manner, it is to TemplateName what ElaboratedType is to Type,\n/// providing extra syntactic sugar for downstream clients.\nclass QualifiedTemplateName : public llvm::FoldingSetNode {\n  friend class ASTContext;\n\n  /// The nested name specifier that qualifies the template name.\n  ///\n  /// The bit is used to indicate whether the \"template\" keyword was\n  /// present before the template name itself. Note that the\n  /// \"template\" keyword is always redundant in this case (otherwise,\n  /// the template name would be a dependent name and we would express\n  /// this name with DependentTemplateName).\n  llvm::PointerIntPair<NestedNameSpecifier *, 1> Qualifier;\n\n  /// The template declaration or set of overloaded function templates\n  /// that this qualified name refers to.\n  TemplateDecl *Template;\n\n  QualifiedTemplateName(NestedNameSpecifier *NNS, bool TemplateKeyword,\n                        TemplateDecl *Template)\n      : Qualifier(NNS, TemplateKeyword? 1 : 0), Template(Template) {}\n\npublic:\n  /// Return the nested name specifier that qualifies this name.\n  NestedNameSpecifier *getQualifier() const { return Qualifier.getPointer(); }\n\n  /// Whether the template name was prefixed by the \"template\"\n  /// keyword.\n  bool hasTemplateKeyword() const { return Qualifier.getInt(); }\n\n  /// The template declaration that this qualified name refers\n  /// to.\n  TemplateDecl *getDecl() const { return Template; }\n\n  /// The template declaration to which this qualified name\n  /// refers.\n  TemplateDecl *getTemplateDecl() const { return Template; }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getQualifier(), hasTemplateKeyword(), getTemplateDecl());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, NestedNameSpecifier *NNS,\n                      bool TemplateKeyword, TemplateDecl *Template) {\n    ID.AddPointer(NNS);\n    ID.AddBoolean(TemplateKeyword);\n    ID.AddPointer(Template);\n  }\n};\n\n/// Represents a dependent template name that cannot be\n/// resolved prior to template instantiation.\n///\n/// This kind of template name refers to a dependent template name,\n/// including its nested name specifier (if any). For example,\n/// DependentTemplateName can refer to \"MetaFun::template apply\",\n/// where \"MetaFun::\" is the nested name specifier and \"apply\" is the\n/// template name referenced. The \"template\" keyword is implied.\nclass DependentTemplateName : public llvm::FoldingSetNode {\n  friend class ASTContext;\n\n  /// The nested name specifier that qualifies the template\n  /// name.\n  ///\n  /// The bit stored in this qualifier describes whether the \\c Name field\n  /// is interpreted as an IdentifierInfo pointer (when clear) or as an\n  /// overloaded operator kind (when set).\n  llvm::PointerIntPair<NestedNameSpecifier *, 1, bool> Qualifier;\n\n  /// The dependent template name.\n  union {\n    /// The identifier template name.\n    ///\n    /// Only valid when the bit on \\c Qualifier is clear.\n    const IdentifierInfo *Identifier;\n\n    /// The overloaded operator name.\n    ///\n    /// Only valid when the bit on \\c Qualifier is set.\n    OverloadedOperatorKind Operator;\n  };\n\n  /// The canonical template name to which this dependent\n  /// template name refers.\n  ///\n  /// The canonical template name for a dependent template name is\n  /// another dependent template name whose nested name specifier is\n  /// canonical.\n  TemplateName CanonicalTemplateName;\n\n  DependentTemplateName(NestedNameSpecifier *Qualifier,\n                        const IdentifierInfo *Identifier)\n      : Qualifier(Qualifier, false), Identifier(Identifier),\n        CanonicalTemplateName(this) {}\n\n  DependentTemplateName(NestedNameSpecifier *Qualifier,\n                        const IdentifierInfo *Identifier,\n                        TemplateName Canon)\n      : Qualifier(Qualifier, false), Identifier(Identifier),\n        CanonicalTemplateName(Canon) {}\n\n  DependentTemplateName(NestedNameSpecifier *Qualifier,\n                        OverloadedOperatorKind Operator)\n      : Qualifier(Qualifier, true), Operator(Operator),\n        CanonicalTemplateName(this) {}\n\n  DependentTemplateName(NestedNameSpecifier *Qualifier,\n                        OverloadedOperatorKind Operator,\n                        TemplateName Canon)\n       : Qualifier(Qualifier, true), Operator(Operator),\n         CanonicalTemplateName(Canon) {}\n\npublic:\n  /// Return the nested name specifier that qualifies this name.\n  NestedNameSpecifier *getQualifier() const { return Qualifier.getPointer(); }\n\n  /// Determine whether this template name refers to an identifier.\n  bool isIdentifier() const { return !Qualifier.getInt(); }\n\n  /// Returns the identifier to which this template name refers.\n  const IdentifierInfo *getIdentifier() const {\n    assert(isIdentifier() && \"Template name isn't an identifier?\");\n    return Identifier;\n  }\n\n  /// Determine whether this template name refers to an overloaded\n  /// operator.\n  bool isOverloadedOperator() const { return Qualifier.getInt(); }\n\n  /// Return the overloaded operator to which this template name refers.\n  OverloadedOperatorKind getOperator() const {\n    assert(isOverloadedOperator() &&\n           \"Template name isn't an overloaded operator?\");\n    return Operator;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    if (isIdentifier())\n      Profile(ID, getQualifier(), getIdentifier());\n    else\n      Profile(ID, getQualifier(), getOperator());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, NestedNameSpecifier *NNS,\n                      const IdentifierInfo *Identifier) {\n    ID.AddPointer(NNS);\n    ID.AddBoolean(false);\n    ID.AddPointer(Identifier);\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, NestedNameSpecifier *NNS,\n                      OverloadedOperatorKind Operator) {\n    ID.AddPointer(NNS);\n    ID.AddBoolean(true);\n    ID.AddInteger(Operator);\n  }\n};\n\n} // namespace clang.\n\nnamespace llvm {\n\n/// The clang::TemplateName class is effectively a pointer.\ntemplate<>\nstruct PointerLikeTypeTraits<clang::TemplateName> {\n  static inline void *getAsVoidPointer(clang::TemplateName TN) {\n    return TN.getAsVoidPointer();\n  }\n\n  static inline clang::TemplateName getFromVoidPointer(void *Ptr) {\n    return clang::TemplateName::getFromVoidPointer(Ptr);\n  }\n\n  // No bits are available!\n  static constexpr int NumLowBitsAvailable = 0;\n};\n\n} // namespace llvm.\n\n#endif // LLVM_CLANG_AST_TEMPLATENAME_H\n"}, "17": {"id": 17, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "content": "//===- Type.h - C Language Family Type Representation -----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// C Language Family Type Representation\n///\n/// This file defines the clang::Type interface and subclasses, used to\n/// represent types for languages in the C family.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_TYPE_H\n#define LLVM_CLANG_AST_TYPE_H\n\n#include \"clang/AST/DependenceFlags.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/TemplateName.h\"\n#include \"clang/Basic/AddressSpaces.h\"\n#include \"clang/Basic/AttrKinds.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/ExceptionSpecificationType.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/Linkage.h\"\n#include \"clang/Basic/PartialDiagnostic.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Basic/Visibility.h\"\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <cstring>\n#include <string>\n#include <type_traits>\n#include <utility>\n\nnamespace clang {\n\nclass ExtQuals;\nclass QualType;\nclass ConceptDecl;\nclass TagDecl;\nclass TemplateParameterList;\nclass Type;\n\nenum {\n  TypeAlignmentInBits = 4,\n  TypeAlignment = 1 << TypeAlignmentInBits\n};\n\nnamespace serialization {\n  template <class T> class AbstractTypeReader;\n  template <class T> class AbstractTypeWriter;\n}\n\n} // namespace clang\n\nnamespace llvm {\n\n  template <typename T>\n  struct PointerLikeTypeTraits;\n  template<>\n  struct PointerLikeTypeTraits< ::clang::Type*> {\n    static inline void *getAsVoidPointer(::clang::Type *P) { return P; }\n\n    static inline ::clang::Type *getFromVoidPointer(void *P) {\n      return static_cast< ::clang::Type*>(P);\n    }\n\n    static constexpr int NumLowBitsAvailable = clang::TypeAlignmentInBits;\n  };\n\n  template<>\n  struct PointerLikeTypeTraits< ::clang::ExtQuals*> {\n    static inline void *getAsVoidPointer(::clang::ExtQuals *P) { return P; }\n\n    static inline ::clang::ExtQuals *getFromVoidPointer(void *P) {\n      return static_cast< ::clang::ExtQuals*>(P);\n    }\n\n    static constexpr int NumLowBitsAvailable = clang::TypeAlignmentInBits;\n  };\n\n} // namespace llvm\n\nnamespace clang {\n\nclass ASTContext;\ntemplate <typename> class CanQual;\nclass CXXRecordDecl;\nclass DeclContext;\nclass EnumDecl;\nclass Expr;\nclass ExtQualsTypeCommonBase;\nclass FunctionDecl;\nclass IdentifierInfo;\nclass NamedDecl;\nclass ObjCInterfaceDecl;\nclass ObjCProtocolDecl;\nclass ObjCTypeParamDecl;\nstruct PrintingPolicy;\nclass RecordDecl;\nclass Stmt;\nclass TagDecl;\nclass TemplateArgument;\nclass TemplateArgumentListInfo;\nclass TemplateArgumentLoc;\nclass TemplateTypeParmDecl;\nclass TypedefNameDecl;\nclass UnresolvedUsingTypenameDecl;\n\nusing CanQualType = CanQual<Type>;\n\n// Provide forward declarations for all of the *Type classes.\n#define TYPE(Class, Base) class Class##Type;\n#include \"clang/AST/TypeNodes.inc\"\n\n/// The collection of all-type qualifiers we support.\n/// Clang supports five independent qualifiers:\n/// * C99: const, volatile, and restrict\n/// * MS: __unaligned\n/// * Embedded C (TR18037): address spaces\n/// * Objective C: the GC attributes (none, weak, or strong)\nclass Qualifiers {\npublic:\n  enum TQ { // NOTE: These flags must be kept in sync with DeclSpec::TQ.\n    Const    = 0x1,\n    Restrict = 0x2,\n    Volatile = 0x4,\n    CVRMask = Const | Volatile | Restrict\n  };\n\n  enum GC {\n    GCNone = 0,\n    Weak,\n    Strong\n  };\n\n  enum ObjCLifetime {\n    /// There is no lifetime qualification on this type.\n    OCL_None,\n\n    /// This object can be modified without requiring retains or\n    /// releases.\n    OCL_ExplicitNone,\n\n    /// Assigning into this object requires the old value to be\n    /// released and the new value to be retained.  The timing of the\n    /// release of the old value is inexact: it may be moved to\n    /// immediately after the last known point where the value is\n    /// live.\n    OCL_Strong,\n\n    /// Reading or writing from this object requires a barrier call.\n    OCL_Weak,\n\n    /// Assigning into this object requires a lifetime extension.\n    OCL_Autoreleasing\n  };\n\n  enum {\n    /// The maximum supported address space number.\n    /// 23 bits should be enough for anyone.\n    MaxAddressSpace = 0x7fffffu,\n\n    /// The width of the \"fast\" qualifier mask.\n    FastWidth = 3,\n\n    /// The fast qualifier mask.\n    FastMask = (1 << FastWidth) - 1\n  };\n\n  /// Returns the common set of qualifiers while removing them from\n  /// the given sets.\n  static Qualifiers removeCommonQualifiers(Qualifiers &L, Qualifiers &R) {\n    // If both are only CVR-qualified, bit operations are sufficient.\n    if (!(L.Mask & ~CVRMask) && !(R.Mask & ~CVRMask)) {\n      Qualifiers Q;\n      Q.Mask = L.Mask & R.Mask;\n      L.Mask &= ~Q.Mask;\n      R.Mask &= ~Q.Mask;\n      return Q;\n    }\n\n    Qualifiers Q;\n    unsigned CommonCRV = L.getCVRQualifiers() & R.getCVRQualifiers();\n    Q.addCVRQualifiers(CommonCRV);\n    L.removeCVRQualifiers(CommonCRV);\n    R.removeCVRQualifiers(CommonCRV);\n\n    if (L.getObjCGCAttr() == R.getObjCGCAttr()) {\n      Q.setObjCGCAttr(L.getObjCGCAttr());\n      L.removeObjCGCAttr();\n      R.removeObjCGCAttr();\n    }\n\n    if (L.getObjCLifetime() == R.getObjCLifetime()) {\n      Q.setObjCLifetime(L.getObjCLifetime());\n      L.removeObjCLifetime();\n      R.removeObjCLifetime();\n    }\n\n    if (L.getAddressSpace() == R.getAddressSpace()) {\n      Q.setAddressSpace(L.getAddressSpace());\n      L.removeAddressSpace();\n      R.removeAddressSpace();\n    }\n    return Q;\n  }\n\n  static Qualifiers fromFastMask(unsigned Mask) {\n    Qualifiers Qs;\n    Qs.addFastQualifiers(Mask);\n    return Qs;\n  }\n\n  static Qualifiers fromCVRMask(unsigned CVR) {\n    Qualifiers Qs;\n    Qs.addCVRQualifiers(CVR);\n    return Qs;\n  }\n\n  static Qualifiers fromCVRUMask(unsigned CVRU) {\n    Qualifiers Qs;\n    Qs.addCVRUQualifiers(CVRU);\n    return Qs;\n  }\n\n  // Deserialize qualifiers from an opaque representation.\n  static Qualifiers fromOpaqueValue(unsigned opaque) {\n    Qualifiers Qs;\n    Qs.Mask = opaque;\n    return Qs;\n  }\n\n  // Serialize these qualifiers into an opaque representation.\n  unsigned getAsOpaqueValue() const {\n    return Mask;\n  }\n\n  bool hasConst() const { return Mask & Const; }\n  bool hasOnlyConst() const { return Mask == Const; }\n  void removeConst() { Mask &= ~Const; }\n  void addConst() { Mask |= Const; }\n\n  bool hasVolatile() const { return Mask & Volatile; }\n  bool hasOnlyVolatile() const { return Mask == Volatile; }\n  void removeVolatile() { Mask &= ~Volatile; }\n  void addVolatile() { Mask |= Volatile; }\n\n  bool hasRestrict() const { return Mask & Restrict; }\n  bool hasOnlyRestrict() const { return Mask == Restrict; }\n  void removeRestrict() { Mask &= ~Restrict; }\n  void addRestrict() { Mask |= Restrict; }\n\n  bool hasCVRQualifiers() const { return getCVRQualifiers(); }\n  unsigned getCVRQualifiers() const { return Mask & CVRMask; }\n  unsigned getCVRUQualifiers() const { return Mask & (CVRMask | UMask); }\n\n  void setCVRQualifiers(unsigned mask) {\n    assert(!(mask & ~CVRMask) && \"bitmask contains non-CVR bits\");\n    Mask = (Mask & ~CVRMask) | mask;\n  }\n  void removeCVRQualifiers(unsigned mask) {\n    assert(!(mask & ~CVRMask) && \"bitmask contains non-CVR bits\");\n    Mask &= ~mask;\n  }\n  void removeCVRQualifiers() {\n    removeCVRQualifiers(CVRMask);\n  }\n  void addCVRQualifiers(unsigned mask) {\n    assert(!(mask & ~CVRMask) && \"bitmask contains non-CVR bits\");\n    Mask |= mask;\n  }\n  void addCVRUQualifiers(unsigned mask) {\n    assert(!(mask & ~CVRMask & ~UMask) && \"bitmask contains non-CVRU bits\");\n    Mask |= mask;\n  }\n\n  bool hasUnaligned() const { return Mask & UMask; }\n  void setUnaligned(bool flag) {\n    Mask = (Mask & ~UMask) | (flag ? UMask : 0);\n  }\n  void removeUnaligned() { Mask &= ~UMask; }\n  void addUnaligned() { Mask |= UMask; }\n\n  bool hasObjCGCAttr() const { return Mask & GCAttrMask; }\n  GC getObjCGCAttr() const { return GC((Mask & GCAttrMask) >> GCAttrShift); }\n  void setObjCGCAttr(GC type) {\n    Mask = (Mask & ~GCAttrMask) | (type << GCAttrShift);\n  }\n  void removeObjCGCAttr() { setObjCGCAttr(GCNone); }\n  void addObjCGCAttr(GC type) {\n    assert(type);\n    setObjCGCAttr(type);\n  }\n  Qualifiers withoutObjCGCAttr() const {\n    Qualifiers qs = *this;\n    qs.removeObjCGCAttr();\n    return qs;\n  }\n  Qualifiers withoutObjCLifetime() const {\n    Qualifiers qs = *this;\n    qs.removeObjCLifetime();\n    return qs;\n  }\n  Qualifiers withoutAddressSpace() const {\n    Qualifiers qs = *this;\n    qs.removeAddressSpace();\n    return qs;\n  }\n\n  bool hasObjCLifetime() const { return Mask & LifetimeMask; }\n  ObjCLifetime getObjCLifetime() const {\n    return ObjCLifetime((Mask & LifetimeMask) >> LifetimeShift);\n  }\n  void setObjCLifetime(ObjCLifetime type) {\n    Mask = (Mask & ~LifetimeMask) | (type << LifetimeShift);\n  }\n  void removeObjCLifetime() { setObjCLifetime(OCL_None); }\n  void addObjCLifetime(ObjCLifetime type) {\n    assert(type);\n    assert(!hasObjCLifetime());\n    Mask |= (type << LifetimeShift);\n  }\n\n  /// True if the lifetime is neither None or ExplicitNone.\n  bool hasNonTrivialObjCLifetime() const {\n    ObjCLifetime lifetime = getObjCLifetime();\n    return (lifetime > OCL_ExplicitNone);\n  }\n\n  /// True if the lifetime is either strong or weak.\n  bool hasStrongOrWeakObjCLifetime() const {\n    ObjCLifetime lifetime = getObjCLifetime();\n    return (lifetime == OCL_Strong || lifetime == OCL_Weak);\n  }\n\n  bool hasAddressSpace() const { return Mask & AddressSpaceMask; }\n  LangAS getAddressSpace() const {\n    return static_cast<LangAS>(Mask >> AddressSpaceShift);\n  }\n  bool hasTargetSpecificAddressSpace() const {\n    return isTargetAddressSpace(getAddressSpace());\n  }\n  /// Get the address space attribute value to be printed by diagnostics.\n  unsigned getAddressSpaceAttributePrintValue() const {\n    auto Addr = getAddressSpace();\n    // This function is not supposed to be used with language specific\n    // address spaces. If that happens, the diagnostic message should consider\n    // printing the QualType instead of the address space value.\n    assert(Addr == LangAS::Default || hasTargetSpecificAddressSpace());\n    if (Addr != LangAS::Default)\n      return toTargetAddressSpace(Addr);\n    // TODO: The diagnostic messages where Addr may be 0 should be fixed\n    // since it cannot differentiate the situation where 0 denotes the default\n    // address space or user specified __attribute__((address_space(0))).\n    return 0;\n  }\n  void setAddressSpace(LangAS space) {\n    assert((unsigned)space <= MaxAddressSpace);\n    Mask = (Mask & ~AddressSpaceMask)\n         | (((uint32_t) space) << AddressSpaceShift);\n  }\n  void removeAddressSpace() { setAddressSpace(LangAS::Default); }\n  void addAddressSpace(LangAS space) {\n    assert(space != LangAS::Default);\n    setAddressSpace(space);\n  }\n\n  // Fast qualifiers are those that can be allocated directly\n  // on a QualType object.\n  bool hasFastQualifiers() const { return getFastQualifiers(); }\n  unsigned getFastQualifiers() const { return Mask & FastMask; }\n  void setFastQualifiers(unsigned mask) {\n    assert(!(mask & ~FastMask) && \"bitmask contains non-fast qualifier bits\");\n    Mask = (Mask & ~FastMask) | mask;\n  }\n  void removeFastQualifiers(unsigned mask) {\n    assert(!(mask & ~FastMask) && \"bitmask contains non-fast qualifier bits\");\n    Mask &= ~mask;\n  }\n  void removeFastQualifiers() {\n    removeFastQualifiers(FastMask);\n  }\n  void addFastQualifiers(unsigned mask) {\n    assert(!(mask & ~FastMask) && \"bitmask contains non-fast qualifier bits\");\n    Mask |= mask;\n  }\n\n  /// Return true if the set contains any qualifiers which require an ExtQuals\n  /// node to be allocated.\n  bool hasNonFastQualifiers() const { return Mask & ~FastMask; }\n  Qualifiers getNonFastQualifiers() const {\n    Qualifiers Quals = *this;\n    Quals.setFastQualifiers(0);\n    return Quals;\n  }\n\n  /// Return true if the set contains any qualifiers.\n  bool hasQualifiers() const { return Mask; }\n  bool empty() const { return !Mask; }\n\n  /// Add the qualifiers from the given set to this set.\n  void addQualifiers(Qualifiers Q) {\n    // If the other set doesn't have any non-boolean qualifiers, just\n    // bit-or it in.\n    if (!(Q.Mask & ~CVRMask))\n      Mask |= Q.Mask;\n    else {\n      Mask |= (Q.Mask & CVRMask);\n      if (Q.hasAddressSpace())\n        addAddressSpace(Q.getAddressSpace());\n      if (Q.hasObjCGCAttr())\n        addObjCGCAttr(Q.getObjCGCAttr());\n      if (Q.hasObjCLifetime())\n        addObjCLifetime(Q.getObjCLifetime());\n    }\n  }\n\n  /// Remove the qualifiers from the given set from this set.\n  void removeQualifiers(Qualifiers Q) {\n    // If the other set doesn't have any non-boolean qualifiers, just\n    // bit-and the inverse in.\n    if (!(Q.Mask & ~CVRMask))\n      Mask &= ~Q.Mask;\n    else {\n      Mask &= ~(Q.Mask & CVRMask);\n      if (getObjCGCAttr() == Q.getObjCGCAttr())\n        removeObjCGCAttr();\n      if (getObjCLifetime() == Q.getObjCLifetime())\n        removeObjCLifetime();\n      if (getAddressSpace() == Q.getAddressSpace())\n        removeAddressSpace();\n    }\n  }\n\n  /// Add the qualifiers from the given set to this set, given that\n  /// they don't conflict.\n  void addConsistentQualifiers(Qualifiers qs) {\n    assert(getAddressSpace() == qs.getAddressSpace() ||\n           !hasAddressSpace() || !qs.hasAddressSpace());\n    assert(getObjCGCAttr() == qs.getObjCGCAttr() ||\n           !hasObjCGCAttr() || !qs.hasObjCGCAttr());\n    assert(getObjCLifetime() == qs.getObjCLifetime() ||\n           !hasObjCLifetime() || !qs.hasObjCLifetime());\n    Mask |= qs.Mask;\n  }\n\n  /// Returns true if address space A is equal to or a superset of B.\n  /// OpenCL v2.0 defines conversion rules (OpenCLC v2.0 s6.5.5) and notion of\n  /// overlapping address spaces.\n  /// CL1.1 or CL1.2:\n  ///   every address space is a superset of itself.\n  /// CL2.0 adds:\n  ///   __generic is a superset of any address space except for __constant.\n  static bool isAddressSpaceSupersetOf(LangAS A, LangAS B) {\n    // Address spaces must match exactly.\n    return A == B ||\n           // Otherwise in OpenCLC v2.0 s6.5.5: every address space except\n           // for __constant can be used as __generic.\n           (A == LangAS::opencl_generic && B != LangAS::opencl_constant) ||\n           // We also define global_device and global_host address spaces,\n           // to distinguish global pointers allocated on host from pointers\n           // allocated on device, which are a subset of __global.\n           (A == LangAS::opencl_global && (B == LangAS::opencl_global_device ||\n                                           B == LangAS::opencl_global_host)) ||\n           // Consider pointer size address spaces to be equivalent to default.\n           ((isPtrSizeAddressSpace(A) || A == LangAS::Default) &&\n            (isPtrSizeAddressSpace(B) || B == LangAS::Default));\n  }\n\n  /// Returns true if the address space in these qualifiers is equal to or\n  /// a superset of the address space in the argument qualifiers.\n  bool isAddressSpaceSupersetOf(Qualifiers other) const {\n    return isAddressSpaceSupersetOf(getAddressSpace(), other.getAddressSpace());\n  }\n\n  /// Determines if these qualifiers compatibly include another set.\n  /// Generally this answers the question of whether an object with the other\n  /// qualifiers can be safely used as an object with these qualifiers.\n  bool compatiblyIncludes(Qualifiers other) const {\n    return isAddressSpaceSupersetOf(other) &&\n           // ObjC GC qualifiers can match, be added, or be removed, but can't\n           // be changed.\n           (getObjCGCAttr() == other.getObjCGCAttr() || !hasObjCGCAttr() ||\n            !other.hasObjCGCAttr()) &&\n           // ObjC lifetime qualifiers must match exactly.\n           getObjCLifetime() == other.getObjCLifetime() &&\n           // CVR qualifiers may subset.\n           (((Mask & CVRMask) | (other.Mask & CVRMask)) == (Mask & CVRMask)) &&\n           // U qualifier may superset.\n           (!other.hasUnaligned() || hasUnaligned());\n  }\n\n  /// Determines if these qualifiers compatibly include another set of\n  /// qualifiers from the narrow perspective of Objective-C ARC lifetime.\n  ///\n  /// One set of Objective-C lifetime qualifiers compatibly includes the other\n  /// if the lifetime qualifiers match, or if both are non-__weak and the\n  /// including set also contains the 'const' qualifier, or both are non-__weak\n  /// and one is None (which can only happen in non-ARC modes).\n  bool compatiblyIncludesObjCLifetime(Qualifiers other) const {\n    if (getObjCLifetime() == other.getObjCLifetime())\n      return true;\n\n    if (getObjCLifetime() == OCL_Weak || other.getObjCLifetime() == OCL_Weak)\n      return false;\n\n    if (getObjCLifetime() == OCL_None || other.getObjCLifetime() == OCL_None)\n      return true;\n\n    return hasConst();\n  }\n\n  /// Determine whether this set of qualifiers is a strict superset of\n  /// another set of qualifiers, not considering qualifier compatibility.\n  bool isStrictSupersetOf(Qualifiers Other) const;\n\n  bool operator==(Qualifiers Other) const { return Mask == Other.Mask; }\n  bool operator!=(Qualifiers Other) const { return Mask != Other.Mask; }\n\n  explicit operator bool() const { return hasQualifiers(); }\n\n  Qualifiers &operator+=(Qualifiers R) {\n    addQualifiers(R);\n    return *this;\n  }\n\n  // Union two qualifier sets.  If an enumerated qualifier appears\n  // in both sets, use the one from the right.\n  friend Qualifiers operator+(Qualifiers L, Qualifiers R) {\n    L += R;\n    return L;\n  }\n\n  Qualifiers &operator-=(Qualifiers R) {\n    removeQualifiers(R);\n    return *this;\n  }\n\n  /// Compute the difference between two qualifier sets.\n  friend Qualifiers operator-(Qualifiers L, Qualifiers R) {\n    L -= R;\n    return L;\n  }\n\n  std::string getAsString() const;\n  std::string getAsString(const PrintingPolicy &Policy) const;\n\n  static std::string getAddrSpaceAsString(LangAS AS);\n\n  bool isEmptyWhenPrinted(const PrintingPolicy &Policy) const;\n  void print(raw_ostream &OS, const PrintingPolicy &Policy,\n             bool appendSpaceIfNonEmpty = false) const;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    ID.AddInteger(Mask);\n  }\n\nprivate:\n  // bits:     |0 1 2|3|4 .. 5|6  ..  8|9   ...   31|\n  //           |C R V|U|GCAttr|Lifetime|AddressSpace|\n  uint32_t Mask = 0;\n\n  static const uint32_t UMask = 0x8;\n  static const uint32_t UShift = 3;\n  static const uint32_t GCAttrMask = 0x30;\n  static const uint32_t GCAttrShift = 4;\n  static const uint32_t LifetimeMask = 0x1C0;\n  static const uint32_t LifetimeShift = 6;\n  static const uint32_t AddressSpaceMask =\n      ~(CVRMask | UMask | GCAttrMask | LifetimeMask);\n  static const uint32_t AddressSpaceShift = 9;\n};\n\n/// A std::pair-like structure for storing a qualified type split\n/// into its local qualifiers and its locally-unqualified type.\nstruct SplitQualType {\n  /// The locally-unqualified type.\n  const Type *Ty = nullptr;\n\n  /// The local qualifiers.\n  Qualifiers Quals;\n\n  SplitQualType() = default;\n  SplitQualType(const Type *ty, Qualifiers qs) : Ty(ty), Quals(qs) {}\n\n  SplitQualType getSingleStepDesugaredType() const; // end of this file\n\n  // Make std::tie work.\n  std::pair<const Type *,Qualifiers> asPair() const {\n    return std::pair<const Type *, Qualifiers>(Ty, Quals);\n  }\n\n  friend bool operator==(SplitQualType a, SplitQualType b) {\n    return a.Ty == b.Ty && a.Quals == b.Quals;\n  }\n  friend bool operator!=(SplitQualType a, SplitQualType b) {\n    return a.Ty != b.Ty || a.Quals != b.Quals;\n  }\n};\n\n/// The kind of type we are substituting Objective-C type arguments into.\n///\n/// The kind of substitution affects the replacement of type parameters when\n/// no concrete type information is provided, e.g., when dealing with an\n/// unspecialized type.\nenum class ObjCSubstitutionContext {\n  /// An ordinary type.\n  Ordinary,\n\n  /// The result type of a method or function.\n  Result,\n\n  /// The parameter type of a method or function.\n  Parameter,\n\n  /// The type of a property.\n  Property,\n\n  /// The superclass of a type.\n  Superclass,\n};\n\n/// A (possibly-)qualified type.\n///\n/// For efficiency, we don't store CV-qualified types as nodes on their\n/// own: instead each reference to a type stores the qualifiers.  This\n/// greatly reduces the number of nodes we need to allocate for types (for\n/// example we only need one for 'int', 'const int', 'volatile int',\n/// 'const volatile int', etc).\n///\n/// As an added efficiency bonus, instead of making this a pair, we\n/// just store the two bits we care about in the low bits of the\n/// pointer.  To handle the packing/unpacking, we make QualType be a\n/// simple wrapper class that acts like a smart pointer.  A third bit\n/// indicates whether there are extended qualifiers present, in which\n/// case the pointer points to a special structure.\nclass QualType {\n  friend class QualifierCollector;\n\n  // Thankfully, these are efficiently composable.\n  llvm::PointerIntPair<llvm::PointerUnion<const Type *, const ExtQuals *>,\n                       Qualifiers::FastWidth> Value;\n\n  const ExtQuals *getExtQualsUnsafe() const {\n    return Value.getPointer().get<const ExtQuals*>();\n  }\n\n  const Type *getTypePtrUnsafe() const {\n    return Value.getPointer().get<const Type*>();\n  }\n\n  const ExtQualsTypeCommonBase *getCommonPtr() const {\n    assert(!isNull() && \"Cannot retrieve a NULL type pointer\");\n    auto CommonPtrVal = reinterpret_cast<uintptr_t>(Value.getOpaqueValue());\n    CommonPtrVal &= ~(uintptr_t)((1 << TypeAlignmentInBits) - 1);\n    return reinterpret_cast<ExtQualsTypeCommonBase*>(CommonPtrVal);\n  }\n\npublic:\n  QualType() = default;\n  QualType(const Type *Ptr, unsigned Quals) : Value(Ptr, Quals) {}\n  QualType(const ExtQuals *Ptr, unsigned Quals) : Value(Ptr, Quals) {}\n\n  unsigned getLocalFastQualifiers() const { return Value.getInt(); }\n  void setLocalFastQualifiers(unsigned Quals) { Value.setInt(Quals); }\n\n  /// Retrieves a pointer to the underlying (unqualified) type.\n  ///\n  /// This function requires that the type not be NULL. If the type might be\n  /// NULL, use the (slightly less efficient) \\c getTypePtrOrNull().\n  const Type *getTypePtr() const;\n\n  const Type *getTypePtrOrNull() const;\n\n  /// Retrieves a pointer to the name of the base type.\n  const IdentifierInfo *getBaseTypeIdentifier() const;\n\n  /// Divides a QualType into its unqualified type and a set of local\n  /// qualifiers.\n  SplitQualType split() const;\n\n  void *getAsOpaquePtr() const { return Value.getOpaqueValue(); }\n\n  static QualType getFromOpaquePtr(const void *Ptr) {\n    QualType T;\n    T.Value.setFromOpaqueValue(const_cast<void*>(Ptr));\n    return T;\n  }\n\n  const Type &operator*() const {\n    return *getTypePtr();\n  }\n\n  const Type *operator->() const {\n    return getTypePtr();\n  }\n\n  bool isCanonical() const;\n  bool isCanonicalAsParam() const;\n\n  /// Return true if this QualType doesn't point to a type yet.\n  bool isNull() const {\n    return Value.getPointer().isNull();\n  }\n\n  /// Determine whether this particular QualType instance has the\n  /// \"const\" qualifier set, without looking through typedefs that may have\n  /// added \"const\" at a different level.\n  bool isLocalConstQualified() const {\n    return (getLocalFastQualifiers() & Qualifiers::Const);\n  }\n\n  /// Determine whether this type is const-qualified.\n  bool isConstQualified() const;\n\n  /// Determine whether this particular QualType instance has the\n  /// \"restrict\" qualifier set, without looking through typedefs that may have\n  /// added \"restrict\" at a different level.\n  bool isLocalRestrictQualified() const {\n    return (getLocalFastQualifiers() & Qualifiers::Restrict);\n  }\n\n  /// Determine whether this type is restrict-qualified.\n  bool isRestrictQualified() const;\n\n  /// Determine whether this particular QualType instance has the\n  /// \"volatile\" qualifier set, without looking through typedefs that may have\n  /// added \"volatile\" at a different level.\n  bool isLocalVolatileQualified() const {\n    return (getLocalFastQualifiers() & Qualifiers::Volatile);\n  }\n\n  /// Determine whether this type is volatile-qualified.\n  bool isVolatileQualified() const;\n\n  /// Determine whether this particular QualType instance has any\n  /// qualifiers, without looking through any typedefs that might add\n  /// qualifiers at a different level.\n  bool hasLocalQualifiers() const {\n    return getLocalFastQualifiers() || hasLocalNonFastQualifiers();\n  }\n\n  /// Determine whether this type has any qualifiers.\n  bool hasQualifiers() const;\n\n  /// Determine whether this particular QualType instance has any\n  /// \"non-fast\" qualifiers, e.g., those that are stored in an ExtQualType\n  /// instance.\n  bool hasLocalNonFastQualifiers() const {\n    return Value.getPointer().is<const ExtQuals*>();\n  }\n\n  /// Retrieve the set of qualifiers local to this particular QualType\n  /// instance, not including any qualifiers acquired through typedefs or\n  /// other sugar.\n  Qualifiers getLocalQualifiers() const;\n\n  /// Retrieve the set of qualifiers applied to this type.\n  Qualifiers getQualifiers() const;\n\n  /// Retrieve the set of CVR (const-volatile-restrict) qualifiers\n  /// local to this particular QualType instance, not including any qualifiers\n  /// acquired through typedefs or other sugar.\n  unsigned getLocalCVRQualifiers() const {\n    return getLocalFastQualifiers();\n  }\n\n  /// Retrieve the set of CVR (const-volatile-restrict) qualifiers\n  /// applied to this type.\n  unsigned getCVRQualifiers() const;\n\n  bool isConstant(const ASTContext& Ctx) const {\n    return QualType::isConstant(*this, Ctx);\n  }\n\n  /// Determine whether this is a Plain Old Data (POD) type (C++ 3.9p10).\n  bool isPODType(const ASTContext &Context) const;\n\n  /// Return true if this is a POD type according to the rules of the C++98\n  /// standard, regardless of the current compilation's language.\n  bool isCXX98PODType(const ASTContext &Context) const;\n\n  /// Return true if this is a POD type according to the more relaxed rules\n  /// of the C++11 standard, regardless of the current compilation's language.\n  /// (C++0x [basic.types]p9). Note that, unlike\n  /// CXXRecordDecl::isCXX11StandardLayout, this takes DRs into account.\n  bool isCXX11PODType(const ASTContext &Context) const;\n\n  /// Return true if this is a trivial type per (C++0x [basic.types]p9)\n  bool isTrivialType(const ASTContext &Context) const;\n\n  /// Return true if this is a trivially copyable type (C++0x [basic.types]p9)\n  bool isTriviallyCopyableType(const ASTContext &Context) const;\n\n\n  /// Returns true if it is a class and it might be dynamic.\n  bool mayBeDynamicClass() const;\n\n  /// Returns true if it is not a class or if the class might not be dynamic.\n  bool mayBeNotDynamicClass() const;\n\n  // Don't promise in the API that anything besides 'const' can be\n  // easily added.\n\n  /// Add the `const` type qualifier to this QualType.\n  void addConst() {\n    addFastQualifiers(Qualifiers::Const);\n  }\n  QualType withConst() const {\n    return withFastQualifiers(Qualifiers::Const);\n  }\n\n  /// Add the `volatile` type qualifier to this QualType.\n  void addVolatile() {\n    addFastQualifiers(Qualifiers::Volatile);\n  }\n  QualType withVolatile() const {\n    return withFastQualifiers(Qualifiers::Volatile);\n  }\n\n  /// Add the `restrict` qualifier to this QualType.\n  void addRestrict() {\n    addFastQualifiers(Qualifiers::Restrict);\n  }\n  QualType withRestrict() const {\n    return withFastQualifiers(Qualifiers::Restrict);\n  }\n\n  QualType withCVRQualifiers(unsigned CVR) const {\n    return withFastQualifiers(CVR);\n  }\n\n  void addFastQualifiers(unsigned TQs) {\n    assert(!(TQs & ~Qualifiers::FastMask)\n           && \"non-fast qualifier bits set in mask!\");\n    Value.setInt(Value.getInt() | TQs);\n  }\n\n  void removeLocalConst();\n  void removeLocalVolatile();\n  void removeLocalRestrict();\n  void removeLocalCVRQualifiers(unsigned Mask);\n\n  void removeLocalFastQualifiers() { Value.setInt(0); }\n  void removeLocalFastQualifiers(unsigned Mask) {\n    assert(!(Mask & ~Qualifiers::FastMask) && \"mask has non-fast qualifiers\");\n    Value.setInt(Value.getInt() & ~Mask);\n  }\n\n  // Creates a type with the given qualifiers in addition to any\n  // qualifiers already on this type.\n  QualType withFastQualifiers(unsigned TQs) const {\n    QualType T = *this;\n    T.addFastQualifiers(TQs);\n    return T;\n  }\n\n  // Creates a type with exactly the given fast qualifiers, removing\n  // any existing fast qualifiers.\n  QualType withExactLocalFastQualifiers(unsigned TQs) const {\n    return withoutLocalFastQualifiers().withFastQualifiers(TQs);\n  }\n\n  // Removes fast qualifiers, but leaves any extended qualifiers in place.\n  QualType withoutLocalFastQualifiers() const {\n    QualType T = *this;\n    T.removeLocalFastQualifiers();\n    return T;\n  }\n\n  QualType getCanonicalType() const;\n\n  /// Return this type with all of the instance-specific qualifiers\n  /// removed, but without removing any qualifiers that may have been applied\n  /// through typedefs.\n  QualType getLocalUnqualifiedType() const { return QualType(getTypePtr(), 0); }\n\n  /// Retrieve the unqualified variant of the given type,\n  /// removing as little sugar as possible.\n  ///\n  /// This routine looks through various kinds of sugar to find the\n  /// least-desugared type that is unqualified. For example, given:\n  ///\n  /// \\code\n  /// typedef int Integer;\n  /// typedef const Integer CInteger;\n  /// typedef CInteger DifferenceType;\n  /// \\endcode\n  ///\n  /// Executing \\c getUnqualifiedType() on the type \\c DifferenceType will\n  /// desugar until we hit the type \\c Integer, which has no qualifiers on it.\n  ///\n  /// The resulting type might still be qualified if it's sugar for an array\n  /// type.  To strip qualifiers even from within a sugared array type, use\n  /// ASTContext::getUnqualifiedArrayType.\n  inline QualType getUnqualifiedType() const;\n\n  /// Retrieve the unqualified variant of the given type, removing as little\n  /// sugar as possible.\n  ///\n  /// Like getUnqualifiedType(), but also returns the set of\n  /// qualifiers that were built up.\n  ///\n  /// The resulting type might still be qualified if it's sugar for an array\n  /// type.  To strip qualifiers even from within a sugared array type, use\n  /// ASTContext::getUnqualifiedArrayType.\n  inline SplitQualType getSplitUnqualifiedType() const;\n\n  /// Determine whether this type is more qualified than the other\n  /// given type, requiring exact equality for non-CVR qualifiers.\n  bool isMoreQualifiedThan(QualType Other) const;\n\n  /// Determine whether this type is at least as qualified as the other\n  /// given type, requiring exact equality for non-CVR qualifiers.\n  bool isAtLeastAsQualifiedAs(QualType Other) const;\n\n  QualType getNonReferenceType() const;\n\n  /// Determine the type of a (typically non-lvalue) expression with the\n  /// specified result type.\n  ///\n  /// This routine should be used for expressions for which the return type is\n  /// explicitly specified (e.g., in a cast or call) and isn't necessarily\n  /// an lvalue. It removes a top-level reference (since there are no\n  /// expressions of reference type) and deletes top-level cvr-qualifiers\n  /// from non-class types (in C++) or all types (in C).\n  QualType getNonLValueExprType(const ASTContext &Context) const;\n\n  /// Remove an outer pack expansion type (if any) from this type. Used as part\n  /// of converting the type of a declaration to the type of an expression that\n  /// references that expression. It's meaningless for an expression to have a\n  /// pack expansion type.\n  QualType getNonPackExpansionType() const;\n\n  /// Return the specified type with any \"sugar\" removed from\n  /// the type.  This takes off typedefs, typeof's etc.  If the outer level of\n  /// the type is already concrete, it returns it unmodified.  This is similar\n  /// to getting the canonical type, but it doesn't remove *all* typedefs.  For\n  /// example, it returns \"T*\" as \"T*\", (not as \"int*\"), because the pointer is\n  /// concrete.\n  ///\n  /// Qualifiers are left in place.\n  QualType getDesugaredType(const ASTContext &Context) const {\n    return getDesugaredType(*this, Context);\n  }\n\n  SplitQualType getSplitDesugaredType() const {\n    return getSplitDesugaredType(*this);\n  }\n\n  /// Return the specified type with one level of \"sugar\" removed from\n  /// the type.\n  ///\n  /// This routine takes off the first typedef, typeof, etc. If the outer level\n  /// of the type is already concrete, it returns it unmodified.\n  QualType getSingleStepDesugaredType(const ASTContext &Context) const {\n    return getSingleStepDesugaredTypeImpl(*this, Context);\n  }\n\n  /// Returns the specified type after dropping any\n  /// outer-level parentheses.\n  QualType IgnoreParens() const {\n    if (isa<ParenType>(*this))\n      return QualType::IgnoreParens(*this);\n    return *this;\n  }\n\n  /// Indicate whether the specified types and qualifiers are identical.\n  friend bool operator==(const QualType &LHS, const QualType &RHS) {\n    return LHS.Value == RHS.Value;\n  }\n  friend bool operator!=(const QualType &LHS, const QualType &RHS) {\n    return LHS.Value != RHS.Value;\n  }\n  friend bool operator<(const QualType &LHS, const QualType &RHS) {\n    return LHS.Value < RHS.Value;\n  }\n\n  static std::string getAsString(SplitQualType split,\n                                 const PrintingPolicy &Policy) {\n    return getAsString(split.Ty, split.Quals, Policy);\n  }\n  static std::string getAsString(const Type *ty, Qualifiers qs,\n                                 const PrintingPolicy &Policy);\n\n  std::string getAsString() const;\n  std::string getAsString(const PrintingPolicy &Policy) const;\n\n  void print(raw_ostream &OS, const PrintingPolicy &Policy,\n             const Twine &PlaceHolder = Twine(),\n             unsigned Indentation = 0) const;\n\n  static void print(SplitQualType split, raw_ostream &OS,\n                    const PrintingPolicy &policy, const Twine &PlaceHolder,\n                    unsigned Indentation = 0) {\n    return print(split.Ty, split.Quals, OS, policy, PlaceHolder, Indentation);\n  }\n\n  static void print(const Type *ty, Qualifiers qs,\n                    raw_ostream &OS, const PrintingPolicy &policy,\n                    const Twine &PlaceHolder,\n                    unsigned Indentation = 0);\n\n  void getAsStringInternal(std::string &Str,\n                           const PrintingPolicy &Policy) const;\n\n  static void getAsStringInternal(SplitQualType split, std::string &out,\n                                  const PrintingPolicy &policy) {\n    return getAsStringInternal(split.Ty, split.Quals, out, policy);\n  }\n\n  static void getAsStringInternal(const Type *ty, Qualifiers qs,\n                                  std::string &out,\n                                  const PrintingPolicy &policy);\n\n  class StreamedQualTypeHelper {\n    const QualType &T;\n    const PrintingPolicy &Policy;\n    const Twine &PlaceHolder;\n    unsigned Indentation;\n\n  public:\n    StreamedQualTypeHelper(const QualType &T, const PrintingPolicy &Policy,\n                           const Twine &PlaceHolder, unsigned Indentation)\n        : T(T), Policy(Policy), PlaceHolder(PlaceHolder),\n          Indentation(Indentation) {}\n\n    friend raw_ostream &operator<<(raw_ostream &OS,\n                                   const StreamedQualTypeHelper &SQT) {\n      SQT.T.print(OS, SQT.Policy, SQT.PlaceHolder, SQT.Indentation);\n      return OS;\n    }\n  };\n\n  StreamedQualTypeHelper stream(const PrintingPolicy &Policy,\n                                const Twine &PlaceHolder = Twine(),\n                                unsigned Indentation = 0) const {\n    return StreamedQualTypeHelper(*this, Policy, PlaceHolder, Indentation);\n  }\n\n  void dump(const char *s) const;\n  void dump() const;\n  void dump(llvm::raw_ostream &OS, const ASTContext &Context) const;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    ID.AddPointer(getAsOpaquePtr());\n  }\n\n  /// Check if this type has any address space qualifier.\n  inline bool hasAddressSpace() const;\n\n  /// Return the address space of this type.\n  inline LangAS getAddressSpace() const;\n\n  /// Returns true if address space qualifiers overlap with T address space\n  /// qualifiers.\n  /// OpenCL C defines conversion rules for pointers to different address spaces\n  /// and notion of overlapping address spaces.\n  /// CL1.1 or CL1.2:\n  ///   address spaces overlap iff they are they same.\n  /// OpenCL C v2.0 s6.5.5 adds:\n  ///   __generic overlaps with any address space except for __constant.\n  bool isAddressSpaceOverlapping(QualType T) const {\n    Qualifiers Q = getQualifiers();\n    Qualifiers TQ = T.getQualifiers();\n    // Address spaces overlap if at least one of them is a superset of another\n    return Q.isAddressSpaceSupersetOf(TQ) || TQ.isAddressSpaceSupersetOf(Q);\n  }\n\n  /// Returns gc attribute of this type.\n  inline Qualifiers::GC getObjCGCAttr() const;\n\n  /// true when Type is objc's weak.\n  bool isObjCGCWeak() const {\n    return getObjCGCAttr() == Qualifiers::Weak;\n  }\n\n  /// true when Type is objc's strong.\n  bool isObjCGCStrong() const {\n    return getObjCGCAttr() == Qualifiers::Strong;\n  }\n\n  /// Returns lifetime attribute of this type.\n  Qualifiers::ObjCLifetime getObjCLifetime() const {\n    return getQualifiers().getObjCLifetime();\n  }\n\n  bool hasNonTrivialObjCLifetime() const {\n    return getQualifiers().hasNonTrivialObjCLifetime();\n  }\n\n  bool hasStrongOrWeakObjCLifetime() const {\n    return getQualifiers().hasStrongOrWeakObjCLifetime();\n  }\n\n  // true when Type is objc's weak and weak is enabled but ARC isn't.\n  bool isNonWeakInMRRWithObjCWeak(const ASTContext &Context) const;\n\n  enum PrimitiveDefaultInitializeKind {\n    /// The type does not fall into any of the following categories. Note that\n    /// this case is zero-valued so that values of this enum can be used as a\n    /// boolean condition for non-triviality.\n    PDIK_Trivial,\n\n    /// The type is an Objective-C retainable pointer type that is qualified\n    /// with the ARC __strong qualifier.\n    PDIK_ARCStrong,\n\n    /// The type is an Objective-C retainable pointer type that is qualified\n    /// with the ARC __weak qualifier.\n    PDIK_ARCWeak,\n\n    /// The type is a struct containing a field whose type is not PCK_Trivial.\n    PDIK_Struct\n  };\n\n  /// Functions to query basic properties of non-trivial C struct types.\n\n  /// Check if this is a non-trivial type that would cause a C struct\n  /// transitively containing this type to be non-trivial to default initialize\n  /// and return the kind.\n  PrimitiveDefaultInitializeKind\n  isNonTrivialToPrimitiveDefaultInitialize() const;\n\n  enum PrimitiveCopyKind {\n    /// The type does not fall into any of the following categories. Note that\n    /// this case is zero-valued so that values of this enum can be used as a\n    /// boolean condition for non-triviality.\n    PCK_Trivial,\n\n    /// The type would be trivial except that it is volatile-qualified. Types\n    /// that fall into one of the other non-trivial cases may additionally be\n    /// volatile-qualified.\n    PCK_VolatileTrivial,\n\n    /// The type is an Objective-C retainable pointer type that is qualified\n    /// with the ARC __strong qualifier.\n    PCK_ARCStrong,\n\n    /// The type is an Objective-C retainable pointer type that is qualified\n    /// with the ARC __weak qualifier.\n    PCK_ARCWeak,\n\n    /// The type is a struct containing a field whose type is neither\n    /// PCK_Trivial nor PCK_VolatileTrivial.\n    /// Note that a C++ struct type does not necessarily match this; C++ copying\n    /// semantics are too complex to express here, in part because they depend\n    /// on the exact constructor or assignment operator that is chosen by\n    /// overload resolution to do the copy.\n    PCK_Struct\n  };\n\n  /// Check if this is a non-trivial type that would cause a C struct\n  /// transitively containing this type to be non-trivial to copy and return the\n  /// kind.\n  PrimitiveCopyKind isNonTrivialToPrimitiveCopy() const;\n\n  /// Check if this is a non-trivial type that would cause a C struct\n  /// transitively containing this type to be non-trivial to destructively\n  /// move and return the kind. Destructive move in this context is a C++-style\n  /// move in which the source object is placed in a valid but unspecified state\n  /// after it is moved, as opposed to a truly destructive move in which the\n  /// source object is placed in an uninitialized state.\n  PrimitiveCopyKind isNonTrivialToPrimitiveDestructiveMove() const;\n\n  enum DestructionKind {\n    DK_none,\n    DK_cxx_destructor,\n    DK_objc_strong_lifetime,\n    DK_objc_weak_lifetime,\n    DK_nontrivial_c_struct\n  };\n\n  /// Returns a nonzero value if objects of this type require\n  /// non-trivial work to clean up after.  Non-zero because it's\n  /// conceivable that qualifiers (objc_gc(weak)?) could make\n  /// something require destruction.\n  DestructionKind isDestructedType() const {\n    return isDestructedTypeImpl(*this);\n  }\n\n  /// Check if this is or contains a C union that is non-trivial to\n  /// default-initialize, which is a union that has a member that is non-trivial\n  /// to default-initialize. If this returns true,\n  /// isNonTrivialToPrimitiveDefaultInitialize returns PDIK_Struct.\n  bool hasNonTrivialToPrimitiveDefaultInitializeCUnion() const;\n\n  /// Check if this is or contains a C union that is non-trivial to destruct,\n  /// which is a union that has a member that is non-trivial to destruct. If\n  /// this returns true, isDestructedType returns DK_nontrivial_c_struct.\n  bool hasNonTrivialToPrimitiveDestructCUnion() const;\n\n  /// Check if this is or contains a C union that is non-trivial to copy, which\n  /// is a union that has a member that is non-trivial to copy. If this returns\n  /// true, isNonTrivialToPrimitiveCopy returns PCK_Struct.\n  bool hasNonTrivialToPrimitiveCopyCUnion() const;\n\n  /// Determine whether expressions of the given type are forbidden\n  /// from being lvalues in C.\n  ///\n  /// The expression types that are forbidden to be lvalues are:\n  ///   - 'void', but not qualified void\n  ///   - function types\n  ///\n  /// The exact rule here is C99 6.3.2.1:\n  ///   An lvalue is an expression with an object type or an incomplete\n  ///   type other than void.\n  bool isCForbiddenLValueType() const;\n\n  /// Substitute type arguments for the Objective-C type parameters used in the\n  /// subject type.\n  ///\n  /// \\param ctx ASTContext in which the type exists.\n  ///\n  /// \\param typeArgs The type arguments that will be substituted for the\n  /// Objective-C type parameters in the subject type, which are generally\n  /// computed via \\c Type::getObjCSubstitutions. If empty, the type\n  /// parameters will be replaced with their bounds or id/Class, as appropriate\n  /// for the context.\n  ///\n  /// \\param context The context in which the subject type was written.\n  ///\n  /// \\returns the resulting type.\n  QualType substObjCTypeArgs(ASTContext &ctx,\n                             ArrayRef<QualType> typeArgs,\n                             ObjCSubstitutionContext context) const;\n\n  /// Substitute type arguments from an object type for the Objective-C type\n  /// parameters used in the subject type.\n  ///\n  /// This operation combines the computation of type arguments for\n  /// substitution (\\c Type::getObjCSubstitutions) with the actual process of\n  /// substitution (\\c QualType::substObjCTypeArgs) for the convenience of\n  /// callers that need to perform a single substitution in isolation.\n  ///\n  /// \\param objectType The type of the object whose member type we're\n  /// substituting into. For example, this might be the receiver of a message\n  /// or the base of a property access.\n  ///\n  /// \\param dc The declaration context from which the subject type was\n  /// retrieved, which indicates (for example) which type parameters should\n  /// be substituted.\n  ///\n  /// \\param context The context in which the subject type was written.\n  ///\n  /// \\returns the subject type after replacing all of the Objective-C type\n  /// parameters with their corresponding arguments.\n  QualType substObjCMemberType(QualType objectType,\n                               const DeclContext *dc,\n                               ObjCSubstitutionContext context) const;\n\n  /// Strip Objective-C \"__kindof\" types from the given type.\n  QualType stripObjCKindOfType(const ASTContext &ctx) const;\n\n  /// Remove all qualifiers including _Atomic.\n  QualType getAtomicUnqualifiedType() const;\n\nprivate:\n  // These methods are implemented in a separate translation unit;\n  // \"static\"-ize them to avoid creating temporary QualTypes in the\n  // caller.\n  static bool isConstant(QualType T, const ASTContext& Ctx);\n  static QualType getDesugaredType(QualType T, const ASTContext &Context);\n  static SplitQualType getSplitDesugaredType(QualType T);\n  static SplitQualType getSplitUnqualifiedTypeImpl(QualType type);\n  static QualType getSingleStepDesugaredTypeImpl(QualType type,\n                                                 const ASTContext &C);\n  static QualType IgnoreParens(QualType T);\n  static DestructionKind isDestructedTypeImpl(QualType type);\n\n  /// Check if \\param RD is or contains a non-trivial C union.\n  static bool hasNonTrivialToPrimitiveDefaultInitializeCUnion(const RecordDecl *RD);\n  static bool hasNonTrivialToPrimitiveDestructCUnion(const RecordDecl *RD);\n  static bool hasNonTrivialToPrimitiveCopyCUnion(const RecordDecl *RD);\n};\n\n} // namespace clang\n\nnamespace llvm {\n\n/// Implement simplify_type for QualType, so that we can dyn_cast from QualType\n/// to a specific Type class.\ntemplate<> struct simplify_type< ::clang::QualType> {\n  using SimpleType = const ::clang::Type *;\n\n  static SimpleType getSimplifiedValue(::clang::QualType Val) {\n    return Val.getTypePtr();\n  }\n};\n\n// Teach SmallPtrSet that QualType is \"basically a pointer\".\ntemplate<>\nstruct PointerLikeTypeTraits<clang::QualType> {\n  static inline void *getAsVoidPointer(clang::QualType P) {\n    return P.getAsOpaquePtr();\n  }\n\n  static inline clang::QualType getFromVoidPointer(void *P) {\n    return clang::QualType::getFromOpaquePtr(P);\n  }\n\n  // Various qualifiers go in low bits.\n  static constexpr int NumLowBitsAvailable = 0;\n};\n\n} // namespace llvm\n\nnamespace clang {\n\n/// Base class that is common to both the \\c ExtQuals and \\c Type\n/// classes, which allows \\c QualType to access the common fields between the\n/// two.\nclass ExtQualsTypeCommonBase {\n  friend class ExtQuals;\n  friend class QualType;\n  friend class Type;\n\n  /// The \"base\" type of an extended qualifiers type (\\c ExtQuals) or\n  /// a self-referential pointer (for \\c Type).\n  ///\n  /// This pointer allows an efficient mapping from a QualType to its\n  /// underlying type pointer.\n  const Type *const BaseType;\n\n  /// The canonical type of this type.  A QualType.\n  QualType CanonicalType;\n\n  ExtQualsTypeCommonBase(const Type *baseType, QualType canon)\n      : BaseType(baseType), CanonicalType(canon) {}\n};\n\n/// We can encode up to four bits in the low bits of a\n/// type pointer, but there are many more type qualifiers that we want\n/// to be able to apply to an arbitrary type.  Therefore we have this\n/// struct, intended to be heap-allocated and used by QualType to\n/// store qualifiers.\n///\n/// The current design tags the 'const', 'restrict', and 'volatile' qualifiers\n/// in three low bits on the QualType pointer; a fourth bit records whether\n/// the pointer is an ExtQuals node. The extended qualifiers (address spaces,\n/// Objective-C GC attributes) are much more rare.\nclass ExtQuals : public ExtQualsTypeCommonBase, public llvm::FoldingSetNode {\n  // NOTE: changing the fast qualifiers should be straightforward as\n  // long as you don't make 'const' non-fast.\n  // 1. Qualifiers:\n  //    a) Modify the bitmasks (Qualifiers::TQ and DeclSpec::TQ).\n  //       Fast qualifiers must occupy the low-order bits.\n  //    b) Update Qualifiers::FastWidth and FastMask.\n  // 2. QualType:\n  //    a) Update is{Volatile,Restrict}Qualified(), defined inline.\n  //    b) Update remove{Volatile,Restrict}, defined near the end of\n  //       this header.\n  // 3. ASTContext:\n  //    a) Update get{Volatile,Restrict}Type.\n\n  /// The immutable set of qualifiers applied by this node. Always contains\n  /// extended qualifiers.\n  Qualifiers Quals;\n\n  ExtQuals *this_() { return this; }\n\npublic:\n  ExtQuals(const Type *baseType, QualType canon, Qualifiers quals)\n      : ExtQualsTypeCommonBase(baseType,\n                               canon.isNull() ? QualType(this_(), 0) : canon),\n        Quals(quals) {\n    assert(Quals.hasNonFastQualifiers()\n           && \"ExtQuals created with no fast qualifiers\");\n    assert(!Quals.hasFastQualifiers()\n           && \"ExtQuals created with fast qualifiers\");\n  }\n\n  Qualifiers getQualifiers() const { return Quals; }\n\n  bool hasObjCGCAttr() const { return Quals.hasObjCGCAttr(); }\n  Qualifiers::GC getObjCGCAttr() const { return Quals.getObjCGCAttr(); }\n\n  bool hasObjCLifetime() const { return Quals.hasObjCLifetime(); }\n  Qualifiers::ObjCLifetime getObjCLifetime() const {\n    return Quals.getObjCLifetime();\n  }\n\n  bool hasAddressSpace() const { return Quals.hasAddressSpace(); }\n  LangAS getAddressSpace() const { return Quals.getAddressSpace(); }\n\n  const Type *getBaseType() const { return BaseType; }\n\npublic:\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    Profile(ID, getBaseType(), Quals);\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      const Type *BaseType,\n                      Qualifiers Quals) {\n    assert(!Quals.hasFastQualifiers() && \"fast qualifiers in ExtQuals hash!\");\n    ID.AddPointer(BaseType);\n    Quals.Profile(ID);\n  }\n};\n\n/// The kind of C++11 ref-qualifier associated with a function type.\n/// This determines whether a member function's \"this\" object can be an\n/// lvalue, rvalue, or neither.\nenum RefQualifierKind {\n  /// No ref-qualifier was provided.\n  RQ_None = 0,\n\n  /// An lvalue ref-qualifier was provided (\\c &).\n  RQ_LValue,\n\n  /// An rvalue ref-qualifier was provided (\\c &&).\n  RQ_RValue\n};\n\n/// Which keyword(s) were used to create an AutoType.\nenum class AutoTypeKeyword {\n  /// auto\n  Auto,\n\n  /// decltype(auto)\n  DecltypeAuto,\n\n  /// __auto_type (GNU extension)\n  GNUAutoType\n};\n\n/// The base class of the type hierarchy.\n///\n/// A central concept with types is that each type always has a canonical\n/// type.  A canonical type is the type with any typedef names stripped out\n/// of it or the types it references.  For example, consider:\n///\n///  typedef int  foo;\n///  typedef foo* bar;\n///    'int *'    'foo *'    'bar'\n///\n/// There will be a Type object created for 'int'.  Since int is canonical, its\n/// CanonicalType pointer points to itself.  There is also a Type for 'foo' (a\n/// TypedefType).  Its CanonicalType pointer points to the 'int' Type.  Next\n/// there is a PointerType that represents 'int*', which, like 'int', is\n/// canonical.  Finally, there is a PointerType type for 'foo*' whose canonical\n/// type is 'int*', and there is a TypedefType for 'bar', whose canonical type\n/// is also 'int*'.\n///\n/// Non-canonical types are useful for emitting diagnostics, without losing\n/// information about typedefs being used.  Canonical types are useful for type\n/// comparisons (they allow by-pointer equality tests) and useful for reasoning\n/// about whether something has a particular form (e.g. is a function type),\n/// because they implicitly, recursively, strip all typedefs out of a type.\n///\n/// Types, once created, are immutable.\n///\nclass alignas(8) Type : public ExtQualsTypeCommonBase {\npublic:\n  enum TypeClass {\n#define TYPE(Class, Base) Class,\n#define LAST_TYPE(Class) TypeLast = Class\n#define ABSTRACT_TYPE(Class, Base)\n#include \"clang/AST/TypeNodes.inc\"\n  };\n\nprivate:\n  /// Bitfields required by the Type class.\n  class TypeBitfields {\n    friend class Type;\n    template <class T> friend class TypePropertyCache;\n\n    /// TypeClass bitfield - Enum that specifies what subclass this belongs to.\n    unsigned TC : 8;\n\n    /// Store information on the type dependency.\n    unsigned Dependence : llvm::BitWidth<TypeDependence>;\n\n    /// True if the cache (i.e. the bitfields here starting with\n    /// 'Cache') is valid.\n    mutable unsigned CacheValid : 1;\n\n    /// Linkage of this type.\n    mutable unsigned CachedLinkage : 3;\n\n    /// Whether this type involves and local or unnamed types.\n    mutable unsigned CachedLocalOrUnnamed : 1;\n\n    /// Whether this type comes from an AST file.\n    mutable unsigned FromAST : 1;\n\n    bool isCacheValid() const {\n      return CacheValid;\n    }\n\n    Linkage getLinkage() const {\n      assert(isCacheValid() && \"getting linkage from invalid cache\");\n      return static_cast<Linkage>(CachedLinkage);\n    }\n\n    bool hasLocalOrUnnamedType() const {\n      assert(isCacheValid() && \"getting linkage from invalid cache\");\n      return CachedLocalOrUnnamed;\n    }\n  };\n  enum { NumTypeBits = 8 + llvm::BitWidth<TypeDependence> + 6 };\n\nprotected:\n  // These classes allow subclasses to somewhat cleanly pack bitfields\n  // into Type.\n\n  class ArrayTypeBitfields {\n    friend class ArrayType;\n\n    unsigned : NumTypeBits;\n\n    /// CVR qualifiers from declarations like\n    /// 'int X[static restrict 4]'. For function parameters only.\n    unsigned IndexTypeQuals : 3;\n\n    /// Storage class qualifiers from declarations like\n    /// 'int X[static restrict 4]'. For function parameters only.\n    /// Actually an ArrayType::ArraySizeModifier.\n    unsigned SizeModifier : 3;\n  };\n\n  class ConstantArrayTypeBitfields {\n    friend class ConstantArrayType;\n\n    unsigned : NumTypeBits + 3 + 3;\n\n    /// Whether we have a stored size expression.\n    unsigned HasStoredSizeExpr : 1;\n  };\n\n  class BuiltinTypeBitfields {\n    friend class BuiltinType;\n\n    unsigned : NumTypeBits;\n\n    /// The kind (BuiltinType::Kind) of builtin type this is.\n    unsigned Kind : 8;\n  };\n\n  /// FunctionTypeBitfields store various bits belonging to FunctionProtoType.\n  /// Only common bits are stored here. Additional uncommon bits are stored\n  /// in a trailing object after FunctionProtoType.\n  class FunctionTypeBitfields {\n    friend class FunctionProtoType;\n    friend class FunctionType;\n\n    unsigned : NumTypeBits;\n\n    /// Extra information which affects how the function is called, like\n    /// regparm and the calling convention.\n    unsigned ExtInfo : 13;\n\n    /// The ref-qualifier associated with a \\c FunctionProtoType.\n    ///\n    /// This is a value of type \\c RefQualifierKind.\n    unsigned RefQualifier : 2;\n\n    /// Used only by FunctionProtoType, put here to pack with the\n    /// other bitfields.\n    /// The qualifiers are part of FunctionProtoType because...\n    ///\n    /// C++ 8.3.5p4: The return type, the parameter type list and the\n    /// cv-qualifier-seq, [...], are part of the function type.\n    unsigned FastTypeQuals : Qualifiers::FastWidth;\n    /// Whether this function has extended Qualifiers.\n    unsigned HasExtQuals : 1;\n\n    /// The number of parameters this function has, not counting '...'.\n    /// According to [implimits] 8 bits should be enough here but this is\n    /// somewhat easy to exceed with metaprogramming and so we would like to\n    /// keep NumParams as wide as reasonably possible.\n    unsigned NumParams : 16;\n\n    /// The type of exception specification this function has.\n    unsigned ExceptionSpecType : 4;\n\n    /// Whether this function has extended parameter information.\n    unsigned HasExtParameterInfos : 1;\n\n    /// Whether the function is variadic.\n    unsigned Variadic : 1;\n\n    /// Whether this function has a trailing return type.\n    unsigned HasTrailingReturn : 1;\n  };\n\n  class ObjCObjectTypeBitfields {\n    friend class ObjCObjectType;\n\n    unsigned : NumTypeBits;\n\n    /// The number of type arguments stored directly on this object type.\n    unsigned NumTypeArgs : 7;\n\n    /// The number of protocols stored directly on this object type.\n    unsigned NumProtocols : 6;\n\n    /// Whether this is a \"kindof\" type.\n    unsigned IsKindOf : 1;\n  };\n\n  class ReferenceTypeBitfields {\n    friend class ReferenceType;\n\n    unsigned : NumTypeBits;\n\n    /// True if the type was originally spelled with an lvalue sigil.\n    /// This is never true of rvalue references but can also be false\n    /// on lvalue references because of C++0x [dcl.typedef]p9,\n    /// as follows:\n    ///\n    ///   typedef int &ref;    // lvalue, spelled lvalue\n    ///   typedef int &&rvref; // rvalue\n    ///   ref &a;              // lvalue, inner ref, spelled lvalue\n    ///   ref &&a;             // lvalue, inner ref\n    ///   rvref &a;            // lvalue, inner ref, spelled lvalue\n    ///   rvref &&a;           // rvalue, inner ref\n    unsigned SpelledAsLValue : 1;\n\n    /// True if the inner type is a reference type.  This only happens\n    /// in non-canonical forms.\n    unsigned InnerRef : 1;\n  };\n\n  class TypeWithKeywordBitfields {\n    friend class TypeWithKeyword;\n\n    unsigned : NumTypeBits;\n\n    /// An ElaboratedTypeKeyword.  8 bits for efficient access.\n    unsigned Keyword : 8;\n  };\n\n  enum { NumTypeWithKeywordBits = 8 };\n\n  class ElaboratedTypeBitfields {\n    friend class ElaboratedType;\n\n    unsigned : NumTypeBits;\n    unsigned : NumTypeWithKeywordBits;\n\n    /// Whether the ElaboratedType has a trailing OwnedTagDecl.\n    unsigned HasOwnedTagDecl : 1;\n  };\n\n  class VectorTypeBitfields {\n    friend class VectorType;\n    friend class DependentVectorType;\n\n    unsigned : NumTypeBits;\n\n    /// The kind of vector, either a generic vector type or some\n    /// target-specific vector type such as for AltiVec or Neon.\n    unsigned VecKind : 3;\n    /// The number of elements in the vector.\n    uint32_t NumElements;\n  };\n\n  class AttributedTypeBitfields {\n    friend class AttributedType;\n\n    unsigned : NumTypeBits;\n\n    /// An AttributedType::Kind\n    unsigned AttrKind : 32 - NumTypeBits;\n  };\n\n  class AutoTypeBitfields {\n    friend class AutoType;\n\n    unsigned : NumTypeBits;\n\n    /// Was this placeholder type spelled as 'auto', 'decltype(auto)',\n    /// or '__auto_type'?  AutoTypeKeyword value.\n    unsigned Keyword : 2;\n\n    /// The number of template arguments in the type-constraints, which is\n    /// expected to be able to hold at least 1024 according to [implimits].\n    /// However as this limit is somewhat easy to hit with template\n    /// metaprogramming we'd prefer to keep it as large as possible.\n    /// At the moment it has been left as a non-bitfield since this type\n    /// safely fits in 64 bits as an unsigned, so there is no reason to\n    /// introduce the performance impact of a bitfield.\n    unsigned NumArgs;\n  };\n\n  class SubstTemplateTypeParmPackTypeBitfields {\n    friend class SubstTemplateTypeParmPackType;\n\n    unsigned : NumTypeBits;\n\n    /// The number of template arguments in \\c Arguments, which is\n    /// expected to be able to hold at least 1024 according to [implimits].\n    /// However as this limit is somewhat easy to hit with template\n    /// metaprogramming we'd prefer to keep it as large as possible.\n    /// At the moment it has been left as a non-bitfield since this type\n    /// safely fits in 64 bits as an unsigned, so there is no reason to\n    /// introduce the performance impact of a bitfield.\n    unsigned NumArgs;\n  };\n\n  class TemplateSpecializationTypeBitfields {\n    friend class TemplateSpecializationType;\n\n    unsigned : NumTypeBits;\n\n    /// Whether this template specialization type is a substituted type alias.\n    unsigned TypeAlias : 1;\n\n    /// The number of template arguments named in this class template\n    /// specialization, which is expected to be able to hold at least 1024\n    /// according to [implimits]. However, as this limit is somewhat easy to\n    /// hit with template metaprogramming we'd prefer to keep it as large\n    /// as possible. At the moment it has been left as a non-bitfield since\n    /// this type safely fits in 64 bits as an unsigned, so there is no reason\n    /// to introduce the performance impact of a bitfield.\n    unsigned NumArgs;\n  };\n\n  class DependentTemplateSpecializationTypeBitfields {\n    friend class DependentTemplateSpecializationType;\n\n    unsigned : NumTypeBits;\n    unsigned : NumTypeWithKeywordBits;\n\n    /// The number of template arguments named in this class template\n    /// specialization, which is expected to be able to hold at least 1024\n    /// according to [implimits]. However, as this limit is somewhat easy to\n    /// hit with template metaprogramming we'd prefer to keep it as large\n    /// as possible. At the moment it has been left as a non-bitfield since\n    /// this type safely fits in 64 bits as an unsigned, so there is no reason\n    /// to introduce the performance impact of a bitfield.\n    unsigned NumArgs;\n  };\n\n  class PackExpansionTypeBitfields {\n    friend class PackExpansionType;\n\n    unsigned : NumTypeBits;\n\n    /// The number of expansions that this pack expansion will\n    /// generate when substituted (+1), which is expected to be able to\n    /// hold at least 1024 according to [implimits]. However, as this limit\n    /// is somewhat easy to hit with template metaprogramming we'd prefer to\n    /// keep it as large as possible. At the moment it has been left as a\n    /// non-bitfield since this type safely fits in 64 bits as an unsigned, so\n    /// there is no reason to introduce the performance impact of a bitfield.\n    ///\n    /// This field will only have a non-zero value when some of the parameter\n    /// packs that occur within the pattern have been substituted but others\n    /// have not.\n    unsigned NumExpansions;\n  };\n\n  union {\n    TypeBitfields TypeBits;\n    ArrayTypeBitfields ArrayTypeBits;\n    ConstantArrayTypeBitfields ConstantArrayTypeBits;\n    AttributedTypeBitfields AttributedTypeBits;\n    AutoTypeBitfields AutoTypeBits;\n    BuiltinTypeBitfields BuiltinTypeBits;\n    FunctionTypeBitfields FunctionTypeBits;\n    ObjCObjectTypeBitfields ObjCObjectTypeBits;\n    ReferenceTypeBitfields ReferenceTypeBits;\n    TypeWithKeywordBitfields TypeWithKeywordBits;\n    ElaboratedTypeBitfields ElaboratedTypeBits;\n    VectorTypeBitfields VectorTypeBits;\n    SubstTemplateTypeParmPackTypeBitfields SubstTemplateTypeParmPackTypeBits;\n    TemplateSpecializationTypeBitfields TemplateSpecializationTypeBits;\n    DependentTemplateSpecializationTypeBitfields\n      DependentTemplateSpecializationTypeBits;\n    PackExpansionTypeBitfields PackExpansionTypeBits;\n  };\n\nprivate:\n  template <class T> friend class TypePropertyCache;\n\n  /// Set whether this type comes from an AST file.\n  void setFromAST(bool V = true) const {\n    TypeBits.FromAST = V;\n  }\n\nprotected:\n  friend class ASTContext;\n\n  Type(TypeClass tc, QualType canon, TypeDependence Dependence)\n      : ExtQualsTypeCommonBase(this,\n                               canon.isNull() ? QualType(this_(), 0) : canon) {\n    static_assert(sizeof(*this) <= 8 + sizeof(ExtQualsTypeCommonBase),\n                  \"changing bitfields changed sizeof(Type)!\");\n    static_assert(alignof(decltype(*this)) % sizeof(void *) == 0,\n                  \"Insufficient alignment!\");\n    TypeBits.TC = tc;\n    TypeBits.Dependence = static_cast<unsigned>(Dependence);\n    TypeBits.CacheValid = false;\n    TypeBits.CachedLocalOrUnnamed = false;\n    TypeBits.CachedLinkage = NoLinkage;\n    TypeBits.FromAST = false;\n  }\n\n  // silence VC++ warning C4355: 'this' : used in base member initializer list\n  Type *this_() { return this; }\n\n  void setDependence(TypeDependence D) {\n    TypeBits.Dependence = static_cast<unsigned>(D);\n  }\n\n  void addDependence(TypeDependence D) { setDependence(getDependence() | D); }\n\npublic:\n  friend class ASTReader;\n  friend class ASTWriter;\n  template <class T> friend class serialization::AbstractTypeReader;\n  template <class T> friend class serialization::AbstractTypeWriter;\n\n  Type(const Type &) = delete;\n  Type(Type &&) = delete;\n  Type &operator=(const Type &) = delete;\n  Type &operator=(Type &&) = delete;\n\n  TypeClass getTypeClass() const { return static_cast<TypeClass>(TypeBits.TC); }\n\n  /// Whether this type comes from an AST file.\n  bool isFromAST() const { return TypeBits.FromAST; }\n\n  /// Whether this type is or contains an unexpanded parameter\n  /// pack, used to support C++0x variadic templates.\n  ///\n  /// A type that contains a parameter pack shall be expanded by the\n  /// ellipsis operator at some point. For example, the typedef in the\n  /// following example contains an unexpanded parameter pack 'T':\n  ///\n  /// \\code\n  /// template<typename ...T>\n  /// struct X {\n  ///   typedef T* pointer_types; // ill-formed; T is a parameter pack.\n  /// };\n  /// \\endcode\n  ///\n  /// Note that this routine does not specify which\n  bool containsUnexpandedParameterPack() const {\n    return getDependence() & TypeDependence::UnexpandedPack;\n  }\n\n  /// Determines if this type would be canonical if it had no further\n  /// qualification.\n  bool isCanonicalUnqualified() const {\n    return CanonicalType == QualType(this, 0);\n  }\n\n  /// Pull a single level of sugar off of this locally-unqualified type.\n  /// Users should generally prefer SplitQualType::getSingleStepDesugaredType()\n  /// or QualType::getSingleStepDesugaredType(const ASTContext&).\n  QualType getLocallyUnqualifiedSingleStepDesugaredType() const;\n\n  /// As an extension, we classify types as one of \"sized\" or \"sizeless\";\n  /// every type is one or the other.  Standard types are all sized;\n  /// sizeless types are purely an extension.\n  ///\n  /// Sizeless types contain data with no specified size, alignment,\n  /// or layout.\n  bool isSizelessType() const;\n  bool isSizelessBuiltinType() const;\n\n  /// Determines if this is a sizeless type supported by the\n  /// 'arm_sve_vector_bits' type attribute, which can be applied to a single\n  /// SVE vector or predicate, excluding tuple types such as svint32x4_t.\n  bool isVLSTBuiltinType() const;\n\n  /// Returns the representative type for the element of an SVE builtin type.\n  /// This is used to represent fixed-length SVE vectors created with the\n  /// 'arm_sve_vector_bits' type attribute as VectorType.\n  QualType getSveEltType(const ASTContext &Ctx) const;\n\n  /// Types are partitioned into 3 broad categories (C99 6.2.5p1):\n  /// object types, function types, and incomplete types.\n\n  /// Return true if this is an incomplete type.\n  /// A type that can describe objects, but which lacks information needed to\n  /// determine its size (e.g. void, or a fwd declared struct). Clients of this\n  /// routine will need to determine if the size is actually required.\n  ///\n  /// Def If non-null, and the type refers to some kind of declaration\n  /// that can be completed (such as a C struct, C++ class, or Objective-C\n  /// class), will be set to the declaration.\n  bool isIncompleteType(NamedDecl **Def = nullptr) const;\n\n  /// Return true if this is an incomplete or object\n  /// type, in other words, not a function type.\n  bool isIncompleteOrObjectType() const {\n    return !isFunctionType();\n  }\n\n  /// Determine whether this type is an object type.\n  bool isObjectType() const {\n    // C++ [basic.types]p8:\n    //   An object type is a (possibly cv-qualified) type that is not a\n    //   function type, not a reference type, and not a void type.\n    return !isReferenceType() && !isFunctionType() && !isVoidType();\n  }\n\n  /// Return true if this is a literal type\n  /// (C++11 [basic.types]p10)\n  bool isLiteralType(const ASTContext &Ctx) const;\n\n  /// Determine if this type is a structural type, per C++20 [temp.param]p7.\n  bool isStructuralType() const;\n\n  /// Test if this type is a standard-layout type.\n  /// (C++0x [basic.type]p9)\n  bool isStandardLayoutType() const;\n\n  /// Helper methods to distinguish type categories. All type predicates\n  /// operate on the canonical type, ignoring typedefs and qualifiers.\n\n  /// Returns true if the type is a builtin type.\n  bool isBuiltinType() const;\n\n  /// Test for a particular builtin type.\n  bool isSpecificBuiltinType(unsigned K) const;\n\n  /// Test for a type which does not represent an actual type-system type but\n  /// is instead used as a placeholder for various convenient purposes within\n  /// Clang.  All such types are BuiltinTypes.\n  bool isPlaceholderType() const;\n  const BuiltinType *getAsPlaceholderType() const;\n\n  /// Test for a specific placeholder type.\n  bool isSpecificPlaceholderType(unsigned K) const;\n\n  /// Test for a placeholder type other than Overload; see\n  /// BuiltinType::isNonOverloadPlaceholderType.\n  bool isNonOverloadPlaceholderType() const;\n\n  /// isIntegerType() does *not* include complex integers (a GCC extension).\n  /// isComplexIntegerType() can be used to test for complex integers.\n  bool isIntegerType() const;     // C99 6.2.5p17 (int, char, bool, enum)\n  bool isEnumeralType() const;\n\n  /// Determine whether this type is a scoped enumeration type.\n  bool isScopedEnumeralType() const;\n  bool isBooleanType() const;\n  bool isCharType() const;\n  bool isWideCharType() const;\n  bool isChar8Type() const;\n  bool isChar16Type() const;\n  bool isChar32Type() const;\n  bool isAnyCharacterType() const;\n  bool isIntegralType(const ASTContext &Ctx) const;\n\n  /// Determine whether this type is an integral or enumeration type.\n  bool isIntegralOrEnumerationType() const;\n\n  /// Determine whether this type is an integral or unscoped enumeration type.\n  bool isIntegralOrUnscopedEnumerationType() const;\n  bool isUnscopedEnumerationType() const;\n\n  /// Floating point categories.\n  bool isRealFloatingType() const; // C99 6.2.5p10 (float, double, long double)\n  /// isComplexType() does *not* include complex integers (a GCC extension).\n  /// isComplexIntegerType() can be used to test for complex integers.\n  bool isComplexType() const;      // C99 6.2.5p11 (complex)\n  bool isAnyComplexType() const;   // C99 6.2.5p11 (complex) + Complex Int.\n  bool isFloatingType() const;     // C99 6.2.5p11 (real floating + complex)\n  bool isHalfType() const;         // OpenCL 6.1.1.1, NEON (IEEE 754-2008 half)\n  bool isFloat16Type() const;      // C11 extension ISO/IEC TS 18661\n  bool isBFloat16Type() const;\n  bool isFloat128Type() const;\n  bool isRealType() const;         // C99 6.2.5p17 (real floating + integer)\n  bool isArithmeticType() const;   // C99 6.2.5p18 (integer + floating)\n  bool isVoidType() const;         // C99 6.2.5p19\n  bool isScalarType() const;       // C99 6.2.5p21 (arithmetic + pointers)\n  bool isAggregateType() const;\n  bool isFundamentalType() const;\n  bool isCompoundType() const;\n\n  // Type Predicates: Check to see if this type is structurally the specified\n  // type, ignoring typedefs and qualifiers.\n  bool isFunctionType() const;\n  bool isFunctionNoProtoType() const { return getAs<FunctionNoProtoType>(); }\n  bool isFunctionProtoType() const { return getAs<FunctionProtoType>(); }\n  bool isPointerType() const;\n  bool isAnyPointerType() const;   // Any C pointer or ObjC object pointer\n  bool isBlockPointerType() const;\n  bool isVoidPointerType() const;\n  bool isReferenceType() const;\n  bool isLValueReferenceType() const;\n  bool isRValueReferenceType() const;\n  bool isObjectPointerType() const;\n  bool isFunctionPointerType() const;\n  bool isFunctionReferenceType() const;\n  bool isMemberPointerType() const;\n  bool isMemberFunctionPointerType() const;\n  bool isMemberDataPointerType() const;\n  bool isArrayType() const;\n  bool isConstantArrayType() const;\n  bool isIncompleteArrayType() const;\n  bool isVariableArrayType() const;\n  bool isDependentSizedArrayType() const;\n  bool isRecordType() const;\n  bool isClassType() const;\n  bool isStructureType() const;\n  bool isObjCBoxableRecordType() const;\n  bool isInterfaceType() const;\n  bool isStructureOrClassType() const;\n  bool isUnionType() const;\n  bool isComplexIntegerType() const;            // GCC _Complex integer type.\n  bool isVectorType() const;                    // GCC vector type.\n  bool isExtVectorType() const;                 // Extended vector type.\n  bool isMatrixType() const;                    // Matrix type.\n  bool isConstantMatrixType() const;            // Constant matrix type.\n  bool isDependentAddressSpaceType() const;     // value-dependent address space qualifier\n  bool isObjCObjectPointerType() const;         // pointer to ObjC object\n  bool isObjCRetainableType() const;            // ObjC object or block pointer\n  bool isObjCLifetimeType() const;              // (array of)* retainable type\n  bool isObjCIndirectLifetimeType() const;      // (pointer to)* lifetime type\n  bool isObjCNSObjectType() const;              // __attribute__((NSObject))\n  bool isObjCIndependentClassType() const;      // __attribute__((objc_independent_class))\n  // FIXME: change this to 'raw' interface type, so we can used 'interface' type\n  // for the common case.\n  bool isObjCObjectType() const;                // NSString or typeof(*(id)0)\n  bool isObjCQualifiedInterfaceType() const;    // NSString<foo>\n  bool isObjCQualifiedIdType() const;           // id<foo>\n  bool isObjCQualifiedClassType() const;        // Class<foo>\n  bool isObjCObjectOrInterfaceType() const;\n  bool isObjCIdType() const;                    // id\n  bool isDecltypeType() const;\n  /// Was this type written with the special inert-in-ARC __unsafe_unretained\n  /// qualifier?\n  ///\n  /// This approximates the answer to the following question: if this\n  /// translation unit were compiled in ARC, would this type be qualified\n  /// with __unsafe_unretained?\n  bool isObjCInertUnsafeUnretainedType() const {\n    return hasAttr(attr::ObjCInertUnsafeUnretained);\n  }\n\n  /// Whether the type is Objective-C 'id' or a __kindof type of an\n  /// object type, e.g., __kindof NSView * or __kindof id\n  /// <NSCopying>.\n  ///\n  /// \\param bound Will be set to the bound on non-id subtype types,\n  /// which will be (possibly specialized) Objective-C class type, or\n  /// null for 'id.\n  bool isObjCIdOrObjectKindOfType(const ASTContext &ctx,\n                                  const ObjCObjectType *&bound) const;\n\n  bool isObjCClassType() const;                 // Class\n\n  /// Whether the type is Objective-C 'Class' or a __kindof type of an\n  /// Class type, e.g., __kindof Class <NSCopying>.\n  ///\n  /// Unlike \\c isObjCIdOrObjectKindOfType, there is no relevant bound\n  /// here because Objective-C's type system cannot express \"a class\n  /// object for a subclass of NSFoo\".\n  bool isObjCClassOrClassKindOfType() const;\n\n  bool isBlockCompatibleObjCPointerType(ASTContext &ctx) const;\n  bool isObjCSelType() const;                 // Class\n  bool isObjCBuiltinType() const;               // 'id' or 'Class'\n  bool isObjCARCBridgableType() const;\n  bool isCARCBridgableType() const;\n  bool isTemplateTypeParmType() const;          // C++ template type parameter\n  bool isNullPtrType() const;                   // C++11 std::nullptr_t\n  bool isNothrowT() const;                      // C++   std::nothrow_t\n  bool isAlignValT() const;                     // C++17 std::align_val_t\n  bool isStdByteType() const;                   // C++17 std::byte\n  bool isAtomicType() const;                    // C11 _Atomic()\n  bool isUndeducedAutoType() const;             // C++11 auto or\n                                                // C++14 decltype(auto)\n  bool isTypedefNameType() const;               // typedef or alias template\n\n#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \\\n  bool is##Id##Type() const;\n#include \"clang/Basic/OpenCLImageTypes.def\"\n\n  bool isImageType() const;                     // Any OpenCL image type\n\n  bool isSamplerT() const;                      // OpenCL sampler_t\n  bool isEventT() const;                        // OpenCL event_t\n  bool isClkEventT() const;                     // OpenCL clk_event_t\n  bool isQueueT() const;                        // OpenCL queue_t\n  bool isReserveIDT() const;                    // OpenCL reserve_id_t\n\n#define EXT_OPAQUE_TYPE(ExtType, Id, Ext) \\\n  bool is##Id##Type() const;\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n  // Type defined in cl_intel_device_side_avc_motion_estimation OpenCL extension\n  bool isOCLIntelSubgroupAVCType() const;\n  bool isOCLExtOpaqueType() const;              // Any OpenCL extension type\n\n  bool isPipeType() const;                      // OpenCL pipe type\n  bool isExtIntType() const;                    // Extended Int Type\n  bool isOpenCLSpecificType() const;            // Any OpenCL specific type\n\n  /// Determines if this type, which must satisfy\n  /// isObjCLifetimeType(), is implicitly __unsafe_unretained rather\n  /// than implicitly __strong.\n  bool isObjCARCImplicitlyUnretainedType() const;\n\n  /// Check if the type is the CUDA device builtin surface type.\n  bool isCUDADeviceBuiltinSurfaceType() const;\n  /// Check if the type is the CUDA device builtin texture type.\n  bool isCUDADeviceBuiltinTextureType() const;\n\n  /// Return the implicit lifetime for this type, which must not be dependent.\n  Qualifiers::ObjCLifetime getObjCARCImplicitLifetime() const;\n\n  enum ScalarTypeKind {\n    STK_CPointer,\n    STK_BlockPointer,\n    STK_ObjCObjectPointer,\n    STK_MemberPointer,\n    STK_Bool,\n    STK_Integral,\n    STK_Floating,\n    STK_IntegralComplex,\n    STK_FloatingComplex,\n    STK_FixedPoint\n  };\n\n  /// Given that this is a scalar type, classify it.\n  ScalarTypeKind getScalarTypeKind() const;\n\n  TypeDependence getDependence() const {\n    return static_cast<TypeDependence>(TypeBits.Dependence);\n  }\n\n  /// Whether this type is an error type.\n  bool containsErrors() const {\n    return getDependence() & TypeDependence::Error;\n  }\n\n  /// Whether this type is a dependent type, meaning that its definition\n  /// somehow depends on a template parameter (C++ [temp.dep.type]).\n  bool isDependentType() const {\n    return getDependence() & TypeDependence::Dependent;\n  }\n\n  /// Determine whether this type is an instantiation-dependent type,\n  /// meaning that the type involves a template parameter (even if the\n  /// definition does not actually depend on the type substituted for that\n  /// template parameter).\n  bool isInstantiationDependentType() const {\n    return getDependence() & TypeDependence::Instantiation;\n  }\n\n  /// Determine whether this type is an undeduced type, meaning that\n  /// it somehow involves a C++11 'auto' type or similar which has not yet been\n  /// deduced.\n  bool isUndeducedType() const;\n\n  /// Whether this type is a variably-modified type (C99 6.7.5).\n  bool isVariablyModifiedType() const {\n    return getDependence() & TypeDependence::VariablyModified;\n  }\n\n  /// Whether this type involves a variable-length array type\n  /// with a definite size.\n  bool hasSizedVLAType() const;\n\n  /// Whether this type is or contains a local or unnamed type.\n  bool hasUnnamedOrLocalType() const;\n\n  bool isOverloadableType() const;\n\n  /// Determine wither this type is a C++ elaborated-type-specifier.\n  bool isElaboratedTypeSpecifier() const;\n\n  bool canDecayToPointerType() const;\n\n  /// Whether this type is represented natively as a pointer.  This includes\n  /// pointers, references, block pointers, and Objective-C interface,\n  /// qualified id, and qualified interface types, as well as nullptr_t.\n  bool hasPointerRepresentation() const;\n\n  /// Whether this type can represent an objective pointer type for the\n  /// purpose of GC'ability\n  bool hasObjCPointerRepresentation() const;\n\n  /// Determine whether this type has an integer representation\n  /// of some sort, e.g., it is an integer type or a vector.\n  bool hasIntegerRepresentation() const;\n\n  /// Determine whether this type has an signed integer representation\n  /// of some sort, e.g., it is an signed integer type or a vector.\n  bool hasSignedIntegerRepresentation() const;\n\n  /// Determine whether this type has an unsigned integer representation\n  /// of some sort, e.g., it is an unsigned integer type or a vector.\n  bool hasUnsignedIntegerRepresentation() const;\n\n  /// Determine whether this type has a floating-point representation\n  /// of some sort, e.g., it is a floating-point type or a vector thereof.\n  bool hasFloatingRepresentation() const;\n\n  // Type Checking Functions: Check to see if this type is structurally the\n  // specified type, ignoring typedefs and qualifiers, and return a pointer to\n  // the best type we can.\n  const RecordType *getAsStructureType() const;\n  /// NOTE: getAs*ArrayType are methods on ASTContext.\n  const RecordType *getAsUnionType() const;\n  const ComplexType *getAsComplexIntegerType() const; // GCC complex int type.\n  const ObjCObjectType *getAsObjCInterfaceType() const;\n\n  // The following is a convenience method that returns an ObjCObjectPointerType\n  // for object declared using an interface.\n  const ObjCObjectPointerType *getAsObjCInterfacePointerType() const;\n  const ObjCObjectPointerType *getAsObjCQualifiedIdType() const;\n  const ObjCObjectPointerType *getAsObjCQualifiedClassType() const;\n  const ObjCObjectType *getAsObjCQualifiedInterfaceType() const;\n\n  /// Retrieves the CXXRecordDecl that this type refers to, either\n  /// because the type is a RecordType or because it is the injected-class-name\n  /// type of a class template or class template partial specialization.\n  CXXRecordDecl *getAsCXXRecordDecl() const;\n\n  /// Retrieves the RecordDecl this type refers to.\n  RecordDecl *getAsRecordDecl() const;\n\n  /// Retrieves the TagDecl that this type refers to, either\n  /// because the type is a TagType or because it is the injected-class-name\n  /// type of a class template or class template partial specialization.\n  TagDecl *getAsTagDecl() const;\n\n  /// If this is a pointer or reference to a RecordType, return the\n  /// CXXRecordDecl that the type refers to.\n  ///\n  /// If this is not a pointer or reference, or the type being pointed to does\n  /// not refer to a CXXRecordDecl, returns NULL.\n  const CXXRecordDecl *getPointeeCXXRecordDecl() const;\n\n  /// Get the DeducedType whose type will be deduced for a variable with\n  /// an initializer of this type. This looks through declarators like pointer\n  /// types, but not through decltype or typedefs.\n  DeducedType *getContainedDeducedType() const;\n\n  /// Get the AutoType whose type will be deduced for a variable with\n  /// an initializer of this type. This looks through declarators like pointer\n  /// types, but not through decltype or typedefs.\n  AutoType *getContainedAutoType() const {\n    return dyn_cast_or_null<AutoType>(getContainedDeducedType());\n  }\n\n  /// Determine whether this type was written with a leading 'auto'\n  /// corresponding to a trailing return type (possibly for a nested\n  /// function type within a pointer to function type or similar).\n  bool hasAutoForTrailingReturnType() const;\n\n  /// Member-template getAs<specific type>'.  Look through sugar for\n  /// an instance of \\<specific type>.   This scheme will eventually\n  /// replace the specific getAsXXXX methods above.\n  ///\n  /// There are some specializations of this member template listed\n  /// immediately following this class.\n  template <typename T> const T *getAs() const;\n\n  /// Member-template getAsAdjusted<specific type>. Look through specific kinds\n  /// of sugar (parens, attributes, etc) for an instance of \\<specific type>.\n  /// This is used when you need to walk over sugar nodes that represent some\n  /// kind of type adjustment from a type that was written as a \\<specific type>\n  /// to another type that is still canonically a \\<specific type>.\n  template <typename T> const T *getAsAdjusted() const;\n\n  /// A variant of getAs<> for array types which silently discards\n  /// qualifiers from the outermost type.\n  const ArrayType *getAsArrayTypeUnsafe() const;\n\n  /// Member-template castAs<specific type>.  Look through sugar for\n  /// the underlying instance of \\<specific type>.\n  ///\n  /// This method has the same relationship to getAs<T> as cast<T> has\n  /// to dyn_cast<T>; which is to say, the underlying type *must*\n  /// have the intended type, and this method will never return null.\n  template <typename T> const T *castAs() const;\n\n  /// A variant of castAs<> for array type which silently discards\n  /// qualifiers from the outermost type.\n  const ArrayType *castAsArrayTypeUnsafe() const;\n\n  /// Determine whether this type had the specified attribute applied to it\n  /// (looking through top-level type sugar).\n  bool hasAttr(attr::Kind AK) const;\n\n  /// Get the base element type of this type, potentially discarding type\n  /// qualifiers.  This should never be used when type qualifiers\n  /// are meaningful.\n  const Type *getBaseElementTypeUnsafe() const;\n\n  /// If this is an array type, return the element type of the array,\n  /// potentially with type qualifiers missing.\n  /// This should never be used when type qualifiers are meaningful.\n  const Type *getArrayElementTypeNoTypeQual() const;\n\n  /// If this is a pointer type, return the pointee type.\n  /// If this is an array type, return the array element type.\n  /// This should never be used when type qualifiers are meaningful.\n  const Type *getPointeeOrArrayElementType() const;\n\n  /// If this is a pointer, ObjC object pointer, or block\n  /// pointer, this returns the respective pointee.\n  QualType getPointeeType() const;\n\n  /// Return the specified type with any \"sugar\" removed from the type,\n  /// removing any typedefs, typeofs, etc., as well as any qualifiers.\n  const Type *getUnqualifiedDesugaredType() const;\n\n  /// More type predicates useful for type checking/promotion\n  bool isPromotableIntegerType() const; // C99 6.3.1.1p2\n\n  /// Return true if this is an integer type that is\n  /// signed, according to C99 6.2.5p4 [char, signed char, short, int, long..],\n  /// or an enum decl which has a signed representation.\n  bool isSignedIntegerType() const;\n\n  /// Return true if this is an integer type that is\n  /// unsigned, according to C99 6.2.5p6 [which returns true for _Bool],\n  /// or an enum decl which has an unsigned representation.\n  bool isUnsignedIntegerType() const;\n\n  /// Determines whether this is an integer type that is signed or an\n  /// enumeration types whose underlying type is a signed integer type.\n  bool isSignedIntegerOrEnumerationType() const;\n\n  /// Determines whether this is an integer type that is unsigned or an\n  /// enumeration types whose underlying type is a unsigned integer type.\n  bool isUnsignedIntegerOrEnumerationType() const;\n\n  /// Return true if this is a fixed point type according to\n  /// ISO/IEC JTC1 SC22 WG14 N1169.\n  bool isFixedPointType() const;\n\n  /// Return true if this is a fixed point or integer type.\n  bool isFixedPointOrIntegerType() const;\n\n  /// Return true if this is a saturated fixed point type according to\n  /// ISO/IEC JTC1 SC22 WG14 N1169. This type can be signed or unsigned.\n  bool isSaturatedFixedPointType() const;\n\n  /// Return true if this is a saturated fixed point type according to\n  /// ISO/IEC JTC1 SC22 WG14 N1169. This type can be signed or unsigned.\n  bool isUnsaturatedFixedPointType() const;\n\n  /// Return true if this is a fixed point type that is signed according\n  /// to ISO/IEC JTC1 SC22 WG14 N1169. This type can also be saturated.\n  bool isSignedFixedPointType() const;\n\n  /// Return true if this is a fixed point type that is unsigned according\n  /// to ISO/IEC JTC1 SC22 WG14 N1169. This type can also be saturated.\n  bool isUnsignedFixedPointType() const;\n\n  /// Return true if this is not a variable sized type,\n  /// according to the rules of C99 6.7.5p3.  It is not legal to call this on\n  /// incomplete types.\n  bool isConstantSizeType() const;\n\n  /// Returns true if this type can be represented by some\n  /// set of type specifiers.\n  bool isSpecifierType() const;\n\n  /// Determine the linkage of this type.\n  Linkage getLinkage() const;\n\n  /// Determine the visibility of this type.\n  Visibility getVisibility() const {\n    return getLinkageAndVisibility().getVisibility();\n  }\n\n  /// Return true if the visibility was explicitly set is the code.\n  bool isVisibilityExplicit() const {\n    return getLinkageAndVisibility().isVisibilityExplicit();\n  }\n\n  /// Determine the linkage and visibility of this type.\n  LinkageInfo getLinkageAndVisibility() const;\n\n  /// True if the computed linkage is valid. Used for consistency\n  /// checking. Should always return true.\n  bool isLinkageValid() const;\n\n  /// Determine the nullability of the given type.\n  ///\n  /// Note that nullability is only captured as sugar within the type\n  /// system, not as part of the canonical type, so nullability will\n  /// be lost by canonicalization and desugaring.\n  Optional<NullabilityKind> getNullability(const ASTContext &context) const;\n\n  /// Determine whether the given type can have a nullability\n  /// specifier applied to it, i.e., if it is any kind of pointer type.\n  ///\n  /// \\param ResultIfUnknown The value to return if we don't yet know whether\n  ///        this type can have nullability because it is dependent.\n  bool canHaveNullability(bool ResultIfUnknown = true) const;\n\n  /// Retrieve the set of substitutions required when accessing a member\n  /// of the Objective-C receiver type that is declared in the given context.\n  ///\n  /// \\c *this is the type of the object we're operating on, e.g., the\n  /// receiver for a message send or the base of a property access, and is\n  /// expected to be of some object or object pointer type.\n  ///\n  /// \\param dc The declaration context for which we are building up a\n  /// substitution mapping, which should be an Objective-C class, extension,\n  /// category, or method within.\n  ///\n  /// \\returns an array of type arguments that can be substituted for\n  /// the type parameters of the given declaration context in any type described\n  /// within that context, or an empty optional to indicate that no\n  /// substitution is required.\n  Optional<ArrayRef<QualType>>\n  getObjCSubstitutions(const DeclContext *dc) const;\n\n  /// Determines if this is an ObjC interface type that may accept type\n  /// parameters.\n  bool acceptsObjCTypeParams() const;\n\n  const char *getTypeClassName() const;\n\n  QualType getCanonicalTypeInternal() const {\n    return CanonicalType;\n  }\n\n  CanQualType getCanonicalTypeUnqualified() const; // in CanonicalType.h\n  void dump() const;\n  void dump(llvm::raw_ostream &OS, const ASTContext &Context) const;\n};\n\n/// This will check for a TypedefType by removing any existing sugar\n/// until it reaches a TypedefType or a non-sugared type.\ntemplate <> const TypedefType *Type::getAs() const;\n\n/// This will check for a TemplateSpecializationType by removing any\n/// existing sugar until it reaches a TemplateSpecializationType or a\n/// non-sugared type.\ntemplate <> const TemplateSpecializationType *Type::getAs() const;\n\n/// This will check for an AttributedType by removing any existing sugar\n/// until it reaches an AttributedType or a non-sugared type.\ntemplate <> const AttributedType *Type::getAs() const;\n\n// We can do canonical leaf types faster, because we don't have to\n// worry about preserving child type decoration.\n#define TYPE(Class, Base)\n#define LEAF_TYPE(Class) \\\ntemplate <> inline const Class##Type *Type::getAs() const { \\\n  return dyn_cast<Class##Type>(CanonicalType); \\\n} \\\ntemplate <> inline const Class##Type *Type::castAs() const { \\\n  return cast<Class##Type>(CanonicalType); \\\n}\n#include \"clang/AST/TypeNodes.inc\"\n\n/// This class is used for builtin types like 'int'.  Builtin\n/// types are always canonical and have a literal name field.\nclass BuiltinType : public Type {\npublic:\n  enum Kind {\n// OpenCL image types\n#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) Id,\n#include \"clang/Basic/OpenCLImageTypes.def\"\n// OpenCL extension types\n#define EXT_OPAQUE_TYPE(ExtType, Id, Ext) Id,\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n// SVE Types\n#define SVE_TYPE(Name, Id, SingletonId) Id,\n#include \"clang/Basic/AArch64SVEACLETypes.def\"\n// PPC MMA Types\n#define PPC_VECTOR_TYPE(Name, Id, Size) Id,\n#include \"clang/Basic/PPCTypes.def\"\n// RVV Types\n#define RVV_TYPE(Name, Id, SingletonId) Id,\n#include \"clang/Basic/RISCVVTypes.def\"\n// All other builtin types\n#define BUILTIN_TYPE(Id, SingletonId) Id,\n#define LAST_BUILTIN_TYPE(Id) LastKind = Id\n#include \"clang/AST/BuiltinTypes.def\"\n  };\n\nprivate:\n  friend class ASTContext; // ASTContext creates these.\n\n  BuiltinType(Kind K)\n      : Type(Builtin, QualType(),\n             K == Dependent ? TypeDependence::DependentInstantiation\n                            : TypeDependence::None) {\n    BuiltinTypeBits.Kind = K;\n  }\n\npublic:\n  Kind getKind() const { return static_cast<Kind>(BuiltinTypeBits.Kind); }\n  StringRef getName(const PrintingPolicy &Policy) const;\n\n  const char *getNameAsCString(const PrintingPolicy &Policy) const {\n    // The StringRef is null-terminated.\n    StringRef str = getName(Policy);\n    assert(!str.empty() && str.data()[str.size()] == '\\0');\n    return str.data();\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  bool isInteger() const {\n    return getKind() >= Bool && getKind() <= Int128;\n  }\n\n  bool isSignedInteger() const {\n    return getKind() >= Char_S && getKind() <= Int128;\n  }\n\n  bool isUnsignedInteger() const {\n    return getKind() >= Bool && getKind() <= UInt128;\n  }\n\n  bool isFloatingPoint() const {\n    return getKind() >= Half && getKind() <= Float128;\n  }\n\n  /// Determines whether the given kind corresponds to a placeholder type.\n  static bool isPlaceholderTypeKind(Kind K) {\n    return K >= Overload;\n  }\n\n  /// Determines whether this type is a placeholder type, i.e. a type\n  /// which cannot appear in arbitrary positions in a fully-formed\n  /// expression.\n  bool isPlaceholderType() const {\n    return isPlaceholderTypeKind(getKind());\n  }\n\n  /// Determines whether this type is a placeholder type other than\n  /// Overload.  Most placeholder types require only syntactic\n  /// information about their context in order to be resolved (e.g.\n  /// whether it is a call expression), which means they can (and\n  /// should) be resolved in an earlier \"phase\" of analysis.\n  /// Overload expressions sometimes pick up further information\n  /// from their context, like whether the context expects a\n  /// specific function-pointer type, and so frequently need\n  /// special treatment.\n  bool isNonOverloadPlaceholderType() const {\n    return getKind() > Overload;\n  }\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Builtin; }\n};\n\n/// Complex values, per C99 6.2.5p11.  This supports the C99 complex\n/// types (_Complex float etc) as well as the GCC integer complex extensions.\nclass ComplexType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these.\n\n  QualType ElementType;\n\n  ComplexType(QualType Element, QualType CanonicalPtr)\n      : Type(Complex, CanonicalPtr, Element->getDependence()),\n        ElementType(Element) {}\n\npublic:\n  QualType getElementType() const { return ElementType; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getElementType());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType Element) {\n    ID.AddPointer(Element.getAsOpaquePtr());\n  }\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Complex; }\n};\n\n/// Sugar for parentheses used when specifying types.\nclass ParenType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these.\n\n  QualType Inner;\n\n  ParenType(QualType InnerType, QualType CanonType)\n      : Type(Paren, CanonType, InnerType->getDependence()), Inner(InnerType) {}\n\npublic:\n  QualType getInnerType() const { return Inner; }\n\n  bool isSugared() const { return true; }\n  QualType desugar() const { return getInnerType(); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getInnerType());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType Inner) {\n    Inner.Profile(ID);\n  }\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Paren; }\n};\n\n/// PointerType - C99 6.7.5.1 - Pointer Declarators.\nclass PointerType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these.\n\n  QualType PointeeType;\n\n  PointerType(QualType Pointee, QualType CanonicalPtr)\n      : Type(Pointer, CanonicalPtr, Pointee->getDependence()),\n        PointeeType(Pointee) {}\n\npublic:\n  QualType getPointeeType() const { return PointeeType; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getPointeeType());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType Pointee) {\n    ID.AddPointer(Pointee.getAsOpaquePtr());\n  }\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Pointer; }\n};\n\n/// Represents a type which was implicitly adjusted by the semantic\n/// engine for arbitrary reasons.  For example, array and function types can\n/// decay, and function types can have their calling conventions adjusted.\nclass AdjustedType : public Type, public llvm::FoldingSetNode {\n  QualType OriginalTy;\n  QualType AdjustedTy;\n\nprotected:\n  friend class ASTContext; // ASTContext creates these.\n\n  AdjustedType(TypeClass TC, QualType OriginalTy, QualType AdjustedTy,\n               QualType CanonicalPtr)\n      : Type(TC, CanonicalPtr, OriginalTy->getDependence()),\n        OriginalTy(OriginalTy), AdjustedTy(AdjustedTy) {}\n\npublic:\n  QualType getOriginalType() const { return OriginalTy; }\n  QualType getAdjustedType() const { return AdjustedTy; }\n\n  bool isSugared() const { return true; }\n  QualType desugar() const { return AdjustedTy; }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, OriginalTy, AdjustedTy);\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType Orig, QualType New) {\n    ID.AddPointer(Orig.getAsOpaquePtr());\n    ID.AddPointer(New.getAsOpaquePtr());\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == Adjusted || T->getTypeClass() == Decayed;\n  }\n};\n\n/// Represents a pointer type decayed from an array or function type.\nclass DecayedType : public AdjustedType {\n  friend class ASTContext; // ASTContext creates these.\n\n  inline\n  DecayedType(QualType OriginalType, QualType Decayed, QualType Canonical);\n\npublic:\n  QualType getDecayedType() const { return getAdjustedType(); }\n\n  inline QualType getPointeeType() const;\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Decayed; }\n};\n\n/// Pointer to a block type.\n/// This type is to represent types syntactically represented as\n/// \"void (^)(int)\", etc. Pointee is required to always be a function type.\nclass BlockPointerType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these.\n\n  // Block is some kind of pointer type\n  QualType PointeeType;\n\n  BlockPointerType(QualType Pointee, QualType CanonicalCls)\n      : Type(BlockPointer, CanonicalCls, Pointee->getDependence()),\n        PointeeType(Pointee) {}\n\npublic:\n  // Get the pointee type. Pointee is required to always be a function type.\n  QualType getPointeeType() const { return PointeeType; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n      Profile(ID, getPointeeType());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType Pointee) {\n      ID.AddPointer(Pointee.getAsOpaquePtr());\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == BlockPointer;\n  }\n};\n\n/// Base for LValueReferenceType and RValueReferenceType\nclass ReferenceType : public Type, public llvm::FoldingSetNode {\n  QualType PointeeType;\n\nprotected:\n  ReferenceType(TypeClass tc, QualType Referencee, QualType CanonicalRef,\n                bool SpelledAsLValue)\n      : Type(tc, CanonicalRef, Referencee->getDependence()),\n        PointeeType(Referencee) {\n    ReferenceTypeBits.SpelledAsLValue = SpelledAsLValue;\n    ReferenceTypeBits.InnerRef = Referencee->isReferenceType();\n  }\n\npublic:\n  bool isSpelledAsLValue() const { return ReferenceTypeBits.SpelledAsLValue; }\n  bool isInnerRef() const { return ReferenceTypeBits.InnerRef; }\n\n  QualType getPointeeTypeAsWritten() const { return PointeeType; }\n\n  QualType getPointeeType() const {\n    // FIXME: this might strip inner qualifiers; okay?\n    const ReferenceType *T = this;\n    while (T->isInnerRef())\n      T = T->PointeeType->castAs<ReferenceType>();\n    return T->PointeeType;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, PointeeType, isSpelledAsLValue());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      QualType Referencee,\n                      bool SpelledAsLValue) {\n    ID.AddPointer(Referencee.getAsOpaquePtr());\n    ID.AddBoolean(SpelledAsLValue);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == LValueReference ||\n           T->getTypeClass() == RValueReference;\n  }\n};\n\n/// An lvalue reference type, per C++11 [dcl.ref].\nclass LValueReferenceType : public ReferenceType {\n  friend class ASTContext; // ASTContext creates these\n\n  LValueReferenceType(QualType Referencee, QualType CanonicalRef,\n                      bool SpelledAsLValue)\n      : ReferenceType(LValueReference, Referencee, CanonicalRef,\n                      SpelledAsLValue) {}\n\npublic:\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == LValueReference;\n  }\n};\n\n/// An rvalue reference type, per C++11 [dcl.ref].\nclass RValueReferenceType : public ReferenceType {\n  friend class ASTContext; // ASTContext creates these\n\n  RValueReferenceType(QualType Referencee, QualType CanonicalRef)\n       : ReferenceType(RValueReference, Referencee, CanonicalRef, false) {}\n\npublic:\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == RValueReference;\n  }\n};\n\n/// A pointer to member type per C++ 8.3.3 - Pointers to members.\n///\n/// This includes both pointers to data members and pointer to member functions.\nclass MemberPointerType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these.\n\n  QualType PointeeType;\n\n  /// The class of which the pointee is a member. Must ultimately be a\n  /// RecordType, but could be a typedef or a template parameter too.\n  const Type *Class;\n\n  MemberPointerType(QualType Pointee, const Type *Cls, QualType CanonicalPtr)\n      : Type(MemberPointer, CanonicalPtr,\n             (Cls->getDependence() & ~TypeDependence::VariablyModified) |\n                 Pointee->getDependence()),\n        PointeeType(Pointee), Class(Cls) {}\n\npublic:\n  QualType getPointeeType() const { return PointeeType; }\n\n  /// Returns true if the member type (i.e. the pointee type) is a\n  /// function type rather than a data-member type.\n  bool isMemberFunctionPointer() const {\n    return PointeeType->isFunctionProtoType();\n  }\n\n  /// Returns true if the member type (i.e. the pointee type) is a\n  /// data type rather than a function type.\n  bool isMemberDataPointer() const {\n    return !PointeeType->isFunctionProtoType();\n  }\n\n  const Type *getClass() const { return Class; }\n  CXXRecordDecl *getMostRecentCXXRecordDecl() const;\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getPointeeType(), getClass());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType Pointee,\n                      const Type *Class) {\n    ID.AddPointer(Pointee.getAsOpaquePtr());\n    ID.AddPointer(Class);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == MemberPointer;\n  }\n};\n\n/// Represents an array type, per C99 6.7.5.2 - Array Declarators.\nclass ArrayType : public Type, public llvm::FoldingSetNode {\npublic:\n  /// Capture whether this is a normal array (e.g. int X[4])\n  /// an array with a static size (e.g. int X[static 4]), or an array\n  /// with a star size (e.g. int X[*]).\n  /// 'static' is only allowed on function parameters.\n  enum ArraySizeModifier {\n    Normal, Static, Star\n  };\n\nprivate:\n  /// The element type of the array.\n  QualType ElementType;\n\nprotected:\n  friend class ASTContext; // ASTContext creates these.\n\n  ArrayType(TypeClass tc, QualType et, QualType can, ArraySizeModifier sm,\n            unsigned tq, const Expr *sz = nullptr);\n\npublic:\n  QualType getElementType() const { return ElementType; }\n\n  ArraySizeModifier getSizeModifier() const {\n    return ArraySizeModifier(ArrayTypeBits.SizeModifier);\n  }\n\n  Qualifiers getIndexTypeQualifiers() const {\n    return Qualifiers::fromCVRMask(getIndexTypeCVRQualifiers());\n  }\n\n  unsigned getIndexTypeCVRQualifiers() const {\n    return ArrayTypeBits.IndexTypeQuals;\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ConstantArray ||\n           T->getTypeClass() == VariableArray ||\n           T->getTypeClass() == IncompleteArray ||\n           T->getTypeClass() == DependentSizedArray;\n  }\n};\n\n/// Represents the canonical version of C arrays with a specified constant size.\n/// For example, the canonical type for 'int A[4 + 4*100]' is a\n/// ConstantArrayType where the element type is 'int' and the size is 404.\nclass ConstantArrayType final\n    : public ArrayType,\n      private llvm::TrailingObjects<ConstantArrayType, const Expr *> {\n  friend class ASTContext; // ASTContext creates these.\n  friend TrailingObjects;\n\n  llvm::APInt Size; // Allows us to unique the type.\n\n  ConstantArrayType(QualType et, QualType can, const llvm::APInt &size,\n                    const Expr *sz, ArraySizeModifier sm, unsigned tq)\n      : ArrayType(ConstantArray, et, can, sm, tq, sz), Size(size) {\n    ConstantArrayTypeBits.HasStoredSizeExpr = sz != nullptr;\n    if (ConstantArrayTypeBits.HasStoredSizeExpr) {\n      assert(!can.isNull() && \"canonical constant array should not have size\");\n      *getTrailingObjects<const Expr*>() = sz;\n    }\n  }\n\n  unsigned numTrailingObjects(OverloadToken<const Expr*>) const {\n    return ConstantArrayTypeBits.HasStoredSizeExpr;\n  }\n\npublic:\n  const llvm::APInt &getSize() const { return Size; }\n  const Expr *getSizeExpr() const {\n    return ConstantArrayTypeBits.HasStoredSizeExpr\n               ? *getTrailingObjects<const Expr *>()\n               : nullptr;\n  }\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  /// Determine the number of bits required to address a member of\n  // an array with the given element type and number of elements.\n  static unsigned getNumAddressingBits(const ASTContext &Context,\n                                       QualType ElementType,\n                                       const llvm::APInt &NumElements);\n\n  /// Determine the maximum number of active bits that an array's size\n  /// can require, which limits the maximum size of the array.\n  static unsigned getMaxSizeBits(const ASTContext &Context);\n\n  void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Ctx) {\n    Profile(ID, Ctx, getElementType(), getSize(), getSizeExpr(),\n            getSizeModifier(), getIndexTypeCVRQualifiers());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Ctx,\n                      QualType ET, const llvm::APInt &ArraySize,\n                      const Expr *SizeExpr, ArraySizeModifier SizeMod,\n                      unsigned TypeQuals);\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ConstantArray;\n  }\n};\n\n/// Represents a C array with an unspecified size.  For example 'int A[]' has\n/// an IncompleteArrayType where the element type is 'int' and the size is\n/// unspecified.\nclass IncompleteArrayType : public ArrayType {\n  friend class ASTContext; // ASTContext creates these.\n\n  IncompleteArrayType(QualType et, QualType can,\n                      ArraySizeModifier sm, unsigned tq)\n      : ArrayType(IncompleteArray, et, can, sm, tq) {}\n\npublic:\n  friend class StmtIteratorBase;\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == IncompleteArray;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getElementType(), getSizeModifier(),\n            getIndexTypeCVRQualifiers());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType ET,\n                      ArraySizeModifier SizeMod, unsigned TypeQuals) {\n    ID.AddPointer(ET.getAsOpaquePtr());\n    ID.AddInteger(SizeMod);\n    ID.AddInteger(TypeQuals);\n  }\n};\n\n/// Represents a C array with a specified size that is not an\n/// integer-constant-expression.  For example, 'int s[x+foo()]'.\n/// Since the size expression is an arbitrary expression, we store it as such.\n///\n/// Note: VariableArrayType's aren't uniqued (since the expressions aren't) and\n/// should not be: two lexically equivalent variable array types could mean\n/// different things, for example, these variables do not have the same type\n/// dynamically:\n///\n/// void foo(int x) {\n///   int Y[x];\n///   ++x;\n///   int Z[x];\n/// }\nclass VariableArrayType : public ArrayType {\n  friend class ASTContext; // ASTContext creates these.\n\n  /// An assignment-expression. VLA's are only permitted within\n  /// a function block.\n  Stmt *SizeExpr;\n\n  /// The range spanned by the left and right array brackets.\n  SourceRange Brackets;\n\n  VariableArrayType(QualType et, QualType can, Expr *e,\n                    ArraySizeModifier sm, unsigned tq,\n                    SourceRange brackets)\n      : ArrayType(VariableArray, et, can, sm, tq, e),\n        SizeExpr((Stmt*) e), Brackets(brackets) {}\n\npublic:\n  friend class StmtIteratorBase;\n\n  Expr *getSizeExpr() const {\n    // We use C-style casts instead of cast<> here because we do not wish\n    // to have a dependency of Type.h on Stmt.h/Expr.h.\n    return (Expr*) SizeExpr;\n  }\n\n  SourceRange getBracketsRange() const { return Brackets; }\n  SourceLocation getLBracketLoc() const { return Brackets.getBegin(); }\n  SourceLocation getRBracketLoc() const { return Brackets.getEnd(); }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == VariableArray;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    llvm_unreachable(\"Cannot unique VariableArrayTypes.\");\n  }\n};\n\n/// Represents an array type in C++ whose size is a value-dependent expression.\n///\n/// For example:\n/// \\code\n/// template<typename T, int Size>\n/// class array {\n///   T data[Size];\n/// };\n/// \\endcode\n///\n/// For these types, we won't actually know what the array bound is\n/// until template instantiation occurs, at which point this will\n/// become either a ConstantArrayType or a VariableArrayType.\nclass DependentSizedArrayType : public ArrayType {\n  friend class ASTContext; // ASTContext creates these.\n\n  const ASTContext &Context;\n\n  /// An assignment expression that will instantiate to the\n  /// size of the array.\n  ///\n  /// The expression itself might be null, in which case the array\n  /// type will have its size deduced from an initializer.\n  Stmt *SizeExpr;\n\n  /// The range spanned by the left and right array brackets.\n  SourceRange Brackets;\n\n  DependentSizedArrayType(const ASTContext &Context, QualType et, QualType can,\n                          Expr *e, ArraySizeModifier sm, unsigned tq,\n                          SourceRange brackets);\n\npublic:\n  friend class StmtIteratorBase;\n\n  Expr *getSizeExpr() const {\n    // We use C-style casts instead of cast<> here because we do not wish\n    // to have a dependency of Type.h on Stmt.h/Expr.h.\n    return (Expr*) SizeExpr;\n  }\n\n  SourceRange getBracketsRange() const { return Brackets; }\n  SourceLocation getLBracketLoc() const { return Brackets.getBegin(); }\n  SourceLocation getRBracketLoc() const { return Brackets.getEnd(); }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DependentSizedArray;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Context, getElementType(),\n            getSizeModifier(), getIndexTypeCVRQualifiers(), getSizeExpr());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      QualType ET, ArraySizeModifier SizeMod,\n                      unsigned TypeQuals, Expr *E);\n};\n\n/// Represents an extended address space qualifier where the input address space\n/// value is dependent. Non-dependent address spaces are not represented with a\n/// special Type subclass; they are stored on an ExtQuals node as part of a QualType.\n///\n/// For example:\n/// \\code\n/// template<typename T, int AddrSpace>\n/// class AddressSpace {\n///   typedef T __attribute__((address_space(AddrSpace))) type;\n/// }\n/// \\endcode\nclass DependentAddressSpaceType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext;\n\n  const ASTContext &Context;\n  Expr *AddrSpaceExpr;\n  QualType PointeeType;\n  SourceLocation loc;\n\n  DependentAddressSpaceType(const ASTContext &Context, QualType PointeeType,\n                            QualType can, Expr *AddrSpaceExpr,\n                            SourceLocation loc);\n\npublic:\n  Expr *getAddrSpaceExpr() const { return AddrSpaceExpr; }\n  QualType getPointeeType() const { return PointeeType; }\n  SourceLocation getAttributeLoc() const { return loc; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DependentAddressSpace;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Context, getPointeeType(), getAddrSpaceExpr());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      QualType PointeeType, Expr *AddrSpaceExpr);\n};\n\n/// Represents an extended vector type where either the type or size is\n/// dependent.\n///\n/// For example:\n/// \\code\n/// template<typename T, int Size>\n/// class vector {\n///   typedef T __attribute__((ext_vector_type(Size))) type;\n/// }\n/// \\endcode\nclass DependentSizedExtVectorType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext;\n\n  const ASTContext &Context;\n  Expr *SizeExpr;\n\n  /// The element type of the array.\n  QualType ElementType;\n\n  SourceLocation loc;\n\n  DependentSizedExtVectorType(const ASTContext &Context, QualType ElementType,\n                              QualType can, Expr *SizeExpr, SourceLocation loc);\n\npublic:\n  Expr *getSizeExpr() const { return SizeExpr; }\n  QualType getElementType() const { return ElementType; }\n  SourceLocation getAttributeLoc() const { return loc; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DependentSizedExtVector;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Context, getElementType(), getSizeExpr());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      QualType ElementType, Expr *SizeExpr);\n};\n\n\n/// Represents a GCC generic vector type. This type is created using\n/// __attribute__((vector_size(n)), where \"n\" specifies the vector size in\n/// bytes; or from an Altivec __vector or vector declaration.\n/// Since the constructor takes the number of vector elements, the\n/// client is responsible for converting the size into the number of elements.\nclass VectorType : public Type, public llvm::FoldingSetNode {\npublic:\n  enum VectorKind {\n    /// not a target-specific vector type\n    GenericVector,\n\n    /// is AltiVec vector\n    AltiVecVector,\n\n    /// is AltiVec 'vector Pixel'\n    AltiVecPixel,\n\n    /// is AltiVec 'vector bool ...'\n    AltiVecBool,\n\n    /// is ARM Neon vector\n    NeonVector,\n\n    /// is ARM Neon polynomial vector\n    NeonPolyVector,\n\n    /// is AArch64 SVE fixed-length data vector\n    SveFixedLengthDataVector,\n\n    /// is AArch64 SVE fixed-length predicate vector\n    SveFixedLengthPredicateVector\n  };\n\nprotected:\n  friend class ASTContext; // ASTContext creates these.\n\n  /// The element type of the vector.\n  QualType ElementType;\n\n  VectorType(QualType vecType, unsigned nElements, QualType canonType,\n             VectorKind vecKind);\n\n  VectorType(TypeClass tc, QualType vecType, unsigned nElements,\n             QualType canonType, VectorKind vecKind);\n\npublic:\n  QualType getElementType() const { return ElementType; }\n  unsigned getNumElements() const { return VectorTypeBits.NumElements; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  VectorKind getVectorKind() const {\n    return VectorKind(VectorTypeBits.VecKind);\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getElementType(), getNumElements(),\n            getTypeClass(), getVectorKind());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType ElementType,\n                      unsigned NumElements, TypeClass TypeClass,\n                      VectorKind VecKind) {\n    ID.AddPointer(ElementType.getAsOpaquePtr());\n    ID.AddInteger(NumElements);\n    ID.AddInteger(TypeClass);\n    ID.AddInteger(VecKind);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == Vector || T->getTypeClass() == ExtVector;\n  }\n};\n\n/// Represents a vector type where either the type or size is dependent.\n////\n/// For example:\n/// \\code\n/// template<typename T, int Size>\n/// class vector {\n///   typedef T __attribute__((vector_size(Size))) type;\n/// }\n/// \\endcode\nclass DependentVectorType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext;\n\n  const ASTContext &Context;\n  QualType ElementType;\n  Expr *SizeExpr;\n  SourceLocation Loc;\n\n  DependentVectorType(const ASTContext &Context, QualType ElementType,\n                           QualType CanonType, Expr *SizeExpr,\n                           SourceLocation Loc, VectorType::VectorKind vecKind);\n\npublic:\n  Expr *getSizeExpr() const { return SizeExpr; }\n  QualType getElementType() const { return ElementType; }\n  SourceLocation getAttributeLoc() const { return Loc; }\n  VectorType::VectorKind getVectorKind() const {\n    return VectorType::VectorKind(VectorTypeBits.VecKind);\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DependentVector;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Context, getElementType(), getSizeExpr(), getVectorKind());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      QualType ElementType, const Expr *SizeExpr,\n                      VectorType::VectorKind VecKind);\n};\n\n/// ExtVectorType - Extended vector type. This type is created using\n/// __attribute__((ext_vector_type(n)), where \"n\" is the number of elements.\n/// Unlike vector_size, ext_vector_type is only allowed on typedef's. This\n/// class enables syntactic extensions, like Vector Components for accessing\n/// points (as .xyzw), colors (as .rgba), and textures (modeled after OpenGL\n/// Shading Language).\nclass ExtVectorType : public VectorType {\n  friend class ASTContext; // ASTContext creates these.\n\n  ExtVectorType(QualType vecType, unsigned nElements, QualType canonType)\n      : VectorType(ExtVector, vecType, nElements, canonType, GenericVector) {}\n\npublic:\n  static int getPointAccessorIdx(char c) {\n    switch (c) {\n    default: return -1;\n    case 'x': case 'r': return 0;\n    case 'y': case 'g': return 1;\n    case 'z': case 'b': return 2;\n    case 'w': case 'a': return 3;\n    }\n  }\n\n  static int getNumericAccessorIdx(char c) {\n    switch (c) {\n      default: return -1;\n      case '0': return 0;\n      case '1': return 1;\n      case '2': return 2;\n      case '3': return 3;\n      case '4': return 4;\n      case '5': return 5;\n      case '6': return 6;\n      case '7': return 7;\n      case '8': return 8;\n      case '9': return 9;\n      case 'A':\n      case 'a': return 10;\n      case 'B':\n      case 'b': return 11;\n      case 'C':\n      case 'c': return 12;\n      case 'D':\n      case 'd': return 13;\n      case 'E':\n      case 'e': return 14;\n      case 'F':\n      case 'f': return 15;\n    }\n  }\n\n  static int getAccessorIdx(char c, bool isNumericAccessor) {\n    if (isNumericAccessor)\n      return getNumericAccessorIdx(c);\n    else\n      return getPointAccessorIdx(c);\n  }\n\n  bool isAccessorWithinNumElements(char c, bool isNumericAccessor) const {\n    if (int idx = getAccessorIdx(c, isNumericAccessor)+1)\n      return unsigned(idx-1) < getNumElements();\n    return false;\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ExtVector;\n  }\n};\n\n/// Represents a matrix type, as defined in the Matrix Types clang extensions.\n/// __attribute__((matrix_type(rows, columns))), where \"rows\" specifies\n/// number of rows and \"columns\" specifies the number of columns.\nclass MatrixType : public Type, public llvm::FoldingSetNode {\nprotected:\n  friend class ASTContext;\n\n  /// The element type of the matrix.\n  QualType ElementType;\n\n  MatrixType(QualType ElementTy, QualType CanonElementTy);\n\n  MatrixType(TypeClass TypeClass, QualType ElementTy, QualType CanonElementTy,\n             const Expr *RowExpr = nullptr, const Expr *ColumnExpr = nullptr);\n\npublic:\n  /// Returns type of the elements being stored in the matrix\n  QualType getElementType() const { return ElementType; }\n\n  /// Valid elements types are the following:\n  /// * an integer type (as in C2x 6.2.5p19), but excluding enumerated types\n  ///   and _Bool\n  /// * the standard floating types float or double\n  /// * a half-precision floating point type, if one is supported on the target\n  static bool isValidElementType(QualType T) {\n    return T->isDependentType() ||\n           (T->isRealType() && !T->isBooleanType() && !T->isEnumeralType());\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ConstantMatrix ||\n           T->getTypeClass() == DependentSizedMatrix;\n  }\n};\n\n/// Represents a concrete matrix type with constant number of rows and columns\nclass ConstantMatrixType final : public MatrixType {\nprotected:\n  friend class ASTContext;\n\n  /// The element type of the matrix.\n  // FIXME: Appears to be unused? There is also MatrixType::ElementType...\n  QualType ElementType;\n\n  /// Number of rows and columns.\n  unsigned NumRows;\n  unsigned NumColumns;\n\n  static constexpr unsigned MaxElementsPerDimension = (1 << 20) - 1;\n\n  ConstantMatrixType(QualType MatrixElementType, unsigned NRows,\n                     unsigned NColumns, QualType CanonElementType);\n\n  ConstantMatrixType(TypeClass typeClass, QualType MatrixType, unsigned NRows,\n                     unsigned NColumns, QualType CanonElementType);\n\npublic:\n  /// Returns the number of rows in the matrix.\n  unsigned getNumRows() const { return NumRows; }\n\n  /// Returns the number of columns in the matrix.\n  unsigned getNumColumns() const { return NumColumns; }\n\n  /// Returns the number of elements required to embed the matrix into a vector.\n  unsigned getNumElementsFlattened() const {\n    return getNumRows() * getNumColumns();\n  }\n\n  /// Returns true if \\p NumElements is a valid matrix dimension.\n  static constexpr bool isDimensionValid(size_t NumElements) {\n    return NumElements > 0 && NumElements <= MaxElementsPerDimension;\n  }\n\n  /// Returns the maximum number of elements per dimension.\n  static constexpr unsigned getMaxElementsPerDimension() {\n    return MaxElementsPerDimension;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getElementType(), getNumRows(), getNumColumns(),\n            getTypeClass());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType ElementType,\n                      unsigned NumRows, unsigned NumColumns,\n                      TypeClass TypeClass) {\n    ID.AddPointer(ElementType.getAsOpaquePtr());\n    ID.AddInteger(NumRows);\n    ID.AddInteger(NumColumns);\n    ID.AddInteger(TypeClass);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ConstantMatrix;\n  }\n};\n\n/// Represents a matrix type where the type and the number of rows and columns\n/// is dependent on a template.\nclass DependentSizedMatrixType final : public MatrixType {\n  friend class ASTContext;\n\n  const ASTContext &Context;\n  Expr *RowExpr;\n  Expr *ColumnExpr;\n\n  SourceLocation loc;\n\n  DependentSizedMatrixType(const ASTContext &Context, QualType ElementType,\n                           QualType CanonicalType, Expr *RowExpr,\n                           Expr *ColumnExpr, SourceLocation loc);\n\npublic:\n  QualType getElementType() const { return ElementType; }\n  Expr *getRowExpr() const { return RowExpr; }\n  Expr *getColumnExpr() const { return ColumnExpr; }\n  SourceLocation getAttributeLoc() const { return loc; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DependentSizedMatrix;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Context, getElementType(), getRowExpr(), getColumnExpr());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      QualType ElementType, Expr *RowExpr, Expr *ColumnExpr);\n};\n\n/// FunctionType - C99 6.7.5.3 - Function Declarators.  This is the common base\n/// class of FunctionNoProtoType and FunctionProtoType.\nclass FunctionType : public Type {\n  // The type returned by the function.\n  QualType ResultType;\n\npublic:\n  /// Interesting information about a specific parameter that can't simply\n  /// be reflected in parameter's type. This is only used by FunctionProtoType\n  /// but is in FunctionType to make this class available during the\n  /// specification of the bases of FunctionProtoType.\n  ///\n  /// It makes sense to model language features this way when there's some\n  /// sort of parameter-specific override (such as an attribute) that\n  /// affects how the function is called.  For example, the ARC ns_consumed\n  /// attribute changes whether a parameter is passed at +0 (the default)\n  /// or +1 (ns_consumed).  This must be reflected in the function type,\n  /// but isn't really a change to the parameter type.\n  ///\n  /// One serious disadvantage of modelling language features this way is\n  /// that they generally do not work with language features that attempt\n  /// to destructure types.  For example, template argument deduction will\n  /// not be able to match a parameter declared as\n  ///   T (*)(U)\n  /// against an argument of type\n  ///   void (*)(__attribute__((ns_consumed)) id)\n  /// because the substitution of T=void, U=id into the former will\n  /// not produce the latter.\n  class ExtParameterInfo {\n    enum {\n      ABIMask = 0x0F,\n      IsConsumed = 0x10,\n      HasPassObjSize = 0x20,\n      IsNoEscape = 0x40,\n    };\n    unsigned char Data = 0;\n\n  public:\n    ExtParameterInfo() = default;\n\n    /// Return the ABI treatment of this parameter.\n    ParameterABI getABI() const { return ParameterABI(Data & ABIMask); }\n    ExtParameterInfo withABI(ParameterABI kind) const {\n      ExtParameterInfo copy = *this;\n      copy.Data = (copy.Data & ~ABIMask) | unsigned(kind);\n      return copy;\n    }\n\n    /// Is this parameter considered \"consumed\" by Objective-C ARC?\n    /// Consumed parameters must have retainable object type.\n    bool isConsumed() const { return (Data & IsConsumed); }\n    ExtParameterInfo withIsConsumed(bool consumed) const {\n      ExtParameterInfo copy = *this;\n      if (consumed)\n        copy.Data |= IsConsumed;\n      else\n        copy.Data &= ~IsConsumed;\n      return copy;\n    }\n\n    bool hasPassObjectSize() const { return Data & HasPassObjSize; }\n    ExtParameterInfo withHasPassObjectSize() const {\n      ExtParameterInfo Copy = *this;\n      Copy.Data |= HasPassObjSize;\n      return Copy;\n    }\n\n    bool isNoEscape() const { return Data & IsNoEscape; }\n    ExtParameterInfo withIsNoEscape(bool NoEscape) const {\n      ExtParameterInfo Copy = *this;\n      if (NoEscape)\n        Copy.Data |= IsNoEscape;\n      else\n        Copy.Data &= ~IsNoEscape;\n      return Copy;\n    }\n\n    unsigned char getOpaqueValue() const { return Data; }\n    static ExtParameterInfo getFromOpaqueValue(unsigned char data) {\n      ExtParameterInfo result;\n      result.Data = data;\n      return result;\n    }\n\n    friend bool operator==(ExtParameterInfo lhs, ExtParameterInfo rhs) {\n      return lhs.Data == rhs.Data;\n    }\n\n    friend bool operator!=(ExtParameterInfo lhs, ExtParameterInfo rhs) {\n      return lhs.Data != rhs.Data;\n    }\n  };\n\n  /// A class which abstracts out some details necessary for\n  /// making a call.\n  ///\n  /// It is not actually used directly for storing this information in\n  /// a FunctionType, although FunctionType does currently use the\n  /// same bit-pattern.\n  ///\n  // If you add a field (say Foo), other than the obvious places (both,\n  // constructors, compile failures), what you need to update is\n  // * Operator==\n  // * getFoo\n  // * withFoo\n  // * functionType. Add Foo, getFoo.\n  // * ASTContext::getFooType\n  // * ASTContext::mergeFunctionTypes\n  // * FunctionNoProtoType::Profile\n  // * FunctionProtoType::Profile\n  // * TypePrinter::PrintFunctionProto\n  // * AST read and write\n  // * Codegen\n  class ExtInfo {\n    friend class FunctionType;\n\n    // Feel free to rearrange or add bits, but if you go over 16, you'll need to\n    // adjust the Bits field below, and if you add bits, you'll need to adjust\n    // Type::FunctionTypeBitfields::ExtInfo as well.\n\n    // |  CC  |noreturn|produces|nocallersavedregs|regparm|nocfcheck|cmsenscall|\n    // |0 .. 4|   5    |    6   |       7         |8 .. 10|    11   |    12    |\n    //\n    // regparm is either 0 (no regparm attribute) or the regparm value+1.\n    enum { CallConvMask = 0x1F };\n    enum { NoReturnMask = 0x20 };\n    enum { ProducesResultMask = 0x40 };\n    enum { NoCallerSavedRegsMask = 0x80 };\n    enum {\n      RegParmMask =  0x700,\n      RegParmOffset = 8\n    };\n    enum { NoCfCheckMask = 0x800 };\n    enum { CmseNSCallMask = 0x1000 };\n    uint16_t Bits = CC_C;\n\n    ExtInfo(unsigned Bits) : Bits(static_cast<uint16_t>(Bits)) {}\n\n  public:\n    // Constructor with no defaults. Use this when you know that you\n    // have all the elements (when reading an AST file for example).\n    ExtInfo(bool noReturn, bool hasRegParm, unsigned regParm, CallingConv cc,\n            bool producesResult, bool noCallerSavedRegs, bool NoCfCheck,\n            bool cmseNSCall) {\n      assert((!hasRegParm || regParm < 7) && \"Invalid regparm value\");\n      Bits = ((unsigned)cc) | (noReturn ? NoReturnMask : 0) |\n             (producesResult ? ProducesResultMask : 0) |\n             (noCallerSavedRegs ? NoCallerSavedRegsMask : 0) |\n             (hasRegParm ? ((regParm + 1) << RegParmOffset) : 0) |\n             (NoCfCheck ? NoCfCheckMask : 0) |\n             (cmseNSCall ? CmseNSCallMask : 0);\n    }\n\n    // Constructor with all defaults. Use when for example creating a\n    // function known to use defaults.\n    ExtInfo() = default;\n\n    // Constructor with just the calling convention, which is an important part\n    // of the canonical type.\n    ExtInfo(CallingConv CC) : Bits(CC) {}\n\n    bool getNoReturn() const { return Bits & NoReturnMask; }\n    bool getProducesResult() const { return Bits & ProducesResultMask; }\n    bool getCmseNSCall() const { return Bits & CmseNSCallMask; }\n    bool getNoCallerSavedRegs() const { return Bits & NoCallerSavedRegsMask; }\n    bool getNoCfCheck() const { return Bits & NoCfCheckMask; }\n    bool getHasRegParm() const { return ((Bits & RegParmMask) >> RegParmOffset) != 0; }\n\n    unsigned getRegParm() const {\n      unsigned RegParm = (Bits & RegParmMask) >> RegParmOffset;\n      if (RegParm > 0)\n        --RegParm;\n      return RegParm;\n    }\n\n    CallingConv getCC() const { return CallingConv(Bits & CallConvMask); }\n\n    bool operator==(ExtInfo Other) const {\n      return Bits == Other.Bits;\n    }\n    bool operator!=(ExtInfo Other) const {\n      return Bits != Other.Bits;\n    }\n\n    // Note that we don't have setters. That is by design, use\n    // the following with methods instead of mutating these objects.\n\n    ExtInfo withNoReturn(bool noReturn) const {\n      if (noReturn)\n        return ExtInfo(Bits | NoReturnMask);\n      else\n        return ExtInfo(Bits & ~NoReturnMask);\n    }\n\n    ExtInfo withProducesResult(bool producesResult) const {\n      if (producesResult)\n        return ExtInfo(Bits | ProducesResultMask);\n      else\n        return ExtInfo(Bits & ~ProducesResultMask);\n    }\n\n    ExtInfo withCmseNSCall(bool cmseNSCall) const {\n      if (cmseNSCall)\n        return ExtInfo(Bits | CmseNSCallMask);\n      else\n        return ExtInfo(Bits & ~CmseNSCallMask);\n    }\n\n    ExtInfo withNoCallerSavedRegs(bool noCallerSavedRegs) const {\n      if (noCallerSavedRegs)\n        return ExtInfo(Bits | NoCallerSavedRegsMask);\n      else\n        return ExtInfo(Bits & ~NoCallerSavedRegsMask);\n    }\n\n    ExtInfo withNoCfCheck(bool noCfCheck) const {\n      if (noCfCheck)\n        return ExtInfo(Bits | NoCfCheckMask);\n      else\n        return ExtInfo(Bits & ~NoCfCheckMask);\n    }\n\n    ExtInfo withRegParm(unsigned RegParm) const {\n      assert(RegParm < 7 && \"Invalid regparm value\");\n      return ExtInfo((Bits & ~RegParmMask) |\n                     ((RegParm + 1) << RegParmOffset));\n    }\n\n    ExtInfo withCallingConv(CallingConv cc) const {\n      return ExtInfo((Bits & ~CallConvMask) | (unsigned) cc);\n    }\n\n    void Profile(llvm::FoldingSetNodeID &ID) const {\n      ID.AddInteger(Bits);\n    }\n  };\n\n  /// A simple holder for a QualType representing a type in an\n  /// exception specification. Unfortunately needed by FunctionProtoType\n  /// because TrailingObjects cannot handle repeated types.\n  struct ExceptionType { QualType Type; };\n\n  /// A simple holder for various uncommon bits which do not fit in\n  /// FunctionTypeBitfields. Aligned to alignof(void *) to maintain the\n  /// alignment of subsequent objects in TrailingObjects. You must update\n  /// hasExtraBitfields in FunctionProtoType after adding extra data here.\n  struct alignas(void *) FunctionTypeExtraBitfields {\n    /// The number of types in the exception specification.\n    /// A whole unsigned is not needed here and according to\n    /// [implimits] 8 bits would be enough here.\n    unsigned NumExceptionType;\n  };\n\nprotected:\n  FunctionType(TypeClass tc, QualType res, QualType Canonical,\n               TypeDependence Dependence, ExtInfo Info)\n      : Type(tc, Canonical, Dependence), ResultType(res) {\n    FunctionTypeBits.ExtInfo = Info.Bits;\n  }\n\n  Qualifiers getFastTypeQuals() const {\n    return Qualifiers::fromFastMask(FunctionTypeBits.FastTypeQuals);\n  }\n\npublic:\n  QualType getReturnType() const { return ResultType; }\n\n  bool getHasRegParm() const { return getExtInfo().getHasRegParm(); }\n  unsigned getRegParmType() const { return getExtInfo().getRegParm(); }\n\n  /// Determine whether this function type includes the GNU noreturn\n  /// attribute. The C++11 [[noreturn]] attribute does not affect the function\n  /// type.\n  bool getNoReturnAttr() const { return getExtInfo().getNoReturn(); }\n\n  bool getCmseNSCallAttr() const { return getExtInfo().getCmseNSCall(); }\n  CallingConv getCallConv() const { return getExtInfo().getCC(); }\n  ExtInfo getExtInfo() const { return ExtInfo(FunctionTypeBits.ExtInfo); }\n\n  static_assert((~Qualifiers::FastMask & Qualifiers::CVRMask) == 0,\n                \"Const, volatile and restrict are assumed to be a subset of \"\n                \"the fast qualifiers.\");\n\n  bool isConst() const { return getFastTypeQuals().hasConst(); }\n  bool isVolatile() const { return getFastTypeQuals().hasVolatile(); }\n  bool isRestrict() const { return getFastTypeQuals().hasRestrict(); }\n\n  /// Determine the type of an expression that calls a function of\n  /// this type.\n  QualType getCallResultType(const ASTContext &Context) const {\n    return getReturnType().getNonLValueExprType(Context);\n  }\n\n  static StringRef getNameForCallConv(CallingConv CC);\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == FunctionNoProto ||\n           T->getTypeClass() == FunctionProto;\n  }\n};\n\n/// Represents a K&R-style 'int foo()' function, which has\n/// no information available about its arguments.\nclass FunctionNoProtoType : public FunctionType, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these.\n\n  FunctionNoProtoType(QualType Result, QualType Canonical, ExtInfo Info)\n      : FunctionType(FunctionNoProto, Result, Canonical,\n                     Result->getDependence() &\n                         ~(TypeDependence::DependentInstantiation |\n                           TypeDependence::UnexpandedPack),\n                     Info) {}\n\npublic:\n  // No additional state past what FunctionType provides.\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getReturnType(), getExtInfo());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType ResultType,\n                      ExtInfo Info) {\n    Info.Profile(ID);\n    ID.AddPointer(ResultType.getAsOpaquePtr());\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == FunctionNoProto;\n  }\n};\n\n/// Represents a prototype with parameter type info, e.g.\n/// 'int foo(int)' or 'int foo(void)'.  'void' is represented as having no\n/// parameters, not as having a single void parameter. Such a type can have\n/// an exception specification, but this specification is not part of the\n/// canonical type. FunctionProtoType has several trailing objects, some of\n/// which optional. For more information about the trailing objects see\n/// the first comment inside FunctionProtoType.\nclass FunctionProtoType final\n    : public FunctionType,\n      public llvm::FoldingSetNode,\n      private llvm::TrailingObjects<\n          FunctionProtoType, QualType, SourceLocation,\n          FunctionType::FunctionTypeExtraBitfields, FunctionType::ExceptionType,\n          Expr *, FunctionDecl *, FunctionType::ExtParameterInfo, Qualifiers> {\n  friend class ASTContext; // ASTContext creates these.\n  friend TrailingObjects;\n\n  // FunctionProtoType is followed by several trailing objects, some of\n  // which optional. They are in order:\n  //\n  // * An array of getNumParams() QualType holding the parameter types.\n  //   Always present. Note that for the vast majority of FunctionProtoType,\n  //   these will be the only trailing objects.\n  //\n  // * Optionally if the function is variadic, the SourceLocation of the\n  //   ellipsis.\n  //\n  // * Optionally if some extra data is stored in FunctionTypeExtraBitfields\n  //   (see FunctionTypeExtraBitfields and FunctionTypeBitfields):\n  //   a single FunctionTypeExtraBitfields. Present if and only if\n  //   hasExtraBitfields() is true.\n  //\n  // * Optionally exactly one of:\n  //   * an array of getNumExceptions() ExceptionType,\n  //   * a single Expr *,\n  //   * a pair of FunctionDecl *,\n  //   * a single FunctionDecl *\n  //   used to store information about the various types of exception\n  //   specification. See getExceptionSpecSize for the details.\n  //\n  // * Optionally an array of getNumParams() ExtParameterInfo holding\n  //   an ExtParameterInfo for each of the parameters. Present if and\n  //   only if hasExtParameterInfos() is true.\n  //\n  // * Optionally a Qualifiers object to represent extra qualifiers that can't\n  //   be represented by FunctionTypeBitfields.FastTypeQuals. Present if and only\n  //   if hasExtQualifiers() is true.\n  //\n  // The optional FunctionTypeExtraBitfields has to be before the data\n  // related to the exception specification since it contains the number\n  // of exception types.\n  //\n  // We put the ExtParameterInfos last.  If all were equal, it would make\n  // more sense to put these before the exception specification, because\n  // it's much easier to skip past them compared to the elaborate switch\n  // required to skip the exception specification.  However, all is not\n  // equal; ExtParameterInfos are used to model very uncommon features,\n  // and it's better not to burden the more common paths.\n\npublic:\n  /// Holds information about the various types of exception specification.\n  /// ExceptionSpecInfo is not stored as such in FunctionProtoType but is\n  /// used to group together the various bits of information about the\n  /// exception specification.\n  struct ExceptionSpecInfo {\n    /// The kind of exception specification this is.\n    ExceptionSpecificationType Type = EST_None;\n\n    /// Explicitly-specified list of exception types.\n    ArrayRef<QualType> Exceptions;\n\n    /// Noexcept expression, if this is a computed noexcept specification.\n    Expr *NoexceptExpr = nullptr;\n\n    /// The function whose exception specification this is, for\n    /// EST_Unevaluated and EST_Uninstantiated.\n    FunctionDecl *SourceDecl = nullptr;\n\n    /// The function template whose exception specification this is instantiated\n    /// from, for EST_Uninstantiated.\n    FunctionDecl *SourceTemplate = nullptr;\n\n    ExceptionSpecInfo() = default;\n\n    ExceptionSpecInfo(ExceptionSpecificationType EST) : Type(EST) {}\n  };\n\n  /// Extra information about a function prototype. ExtProtoInfo is not\n  /// stored as such in FunctionProtoType but is used to group together\n  /// the various bits of extra information about a function prototype.\n  struct ExtProtoInfo {\n    FunctionType::ExtInfo ExtInfo;\n    bool Variadic : 1;\n    bool HasTrailingReturn : 1;\n    Qualifiers TypeQuals;\n    RefQualifierKind RefQualifier = RQ_None;\n    ExceptionSpecInfo ExceptionSpec;\n    const ExtParameterInfo *ExtParameterInfos = nullptr;\n    SourceLocation EllipsisLoc;\n\n    ExtProtoInfo() : Variadic(false), HasTrailingReturn(false) {}\n\n    ExtProtoInfo(CallingConv CC)\n        : ExtInfo(CC), Variadic(false), HasTrailingReturn(false) {}\n\n    ExtProtoInfo withExceptionSpec(const ExceptionSpecInfo &ESI) {\n      ExtProtoInfo Result(*this);\n      Result.ExceptionSpec = ESI;\n      return Result;\n    }\n  };\n\nprivate:\n  unsigned numTrailingObjects(OverloadToken<QualType>) const {\n    return getNumParams();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<SourceLocation>) const {\n    return isVariadic();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<FunctionTypeExtraBitfields>) const {\n    return hasExtraBitfields();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<ExceptionType>) const {\n    return getExceptionSpecSize().NumExceptionType;\n  }\n\n  unsigned numTrailingObjects(OverloadToken<Expr *>) const {\n    return getExceptionSpecSize().NumExprPtr;\n  }\n\n  unsigned numTrailingObjects(OverloadToken<FunctionDecl *>) const {\n    return getExceptionSpecSize().NumFunctionDeclPtr;\n  }\n\n  unsigned numTrailingObjects(OverloadToken<ExtParameterInfo>) const {\n    return hasExtParameterInfos() ? getNumParams() : 0;\n  }\n\n  /// Determine whether there are any argument types that\n  /// contain an unexpanded parameter pack.\n  static bool containsAnyUnexpandedParameterPack(const QualType *ArgArray,\n                                                 unsigned numArgs) {\n    for (unsigned Idx = 0; Idx < numArgs; ++Idx)\n      if (ArgArray[Idx]->containsUnexpandedParameterPack())\n        return true;\n\n    return false;\n  }\n\n  FunctionProtoType(QualType result, ArrayRef<QualType> params,\n                    QualType canonical, const ExtProtoInfo &epi);\n\n  /// This struct is returned by getExceptionSpecSize and is used to\n  /// translate an ExceptionSpecificationType to the number and kind\n  /// of trailing objects related to the exception specification.\n  struct ExceptionSpecSizeHolder {\n    unsigned NumExceptionType;\n    unsigned NumExprPtr;\n    unsigned NumFunctionDeclPtr;\n  };\n\n  /// Return the number and kind of trailing objects\n  /// related to the exception specification.\n  static ExceptionSpecSizeHolder\n  getExceptionSpecSize(ExceptionSpecificationType EST, unsigned NumExceptions) {\n    switch (EST) {\n    case EST_None:\n    case EST_DynamicNone:\n    case EST_MSAny:\n    case EST_BasicNoexcept:\n    case EST_Unparsed:\n    case EST_NoThrow:\n      return {0, 0, 0};\n\n    case EST_Dynamic:\n      return {NumExceptions, 0, 0};\n\n    case EST_DependentNoexcept:\n    case EST_NoexceptFalse:\n    case EST_NoexceptTrue:\n      return {0, 1, 0};\n\n    case EST_Uninstantiated:\n      return {0, 0, 2};\n\n    case EST_Unevaluated:\n      return {0, 0, 1};\n    }\n    llvm_unreachable(\"bad exception specification kind\");\n  }\n\n  /// Return the number and kind of trailing objects\n  /// related to the exception specification.\n  ExceptionSpecSizeHolder getExceptionSpecSize() const {\n    return getExceptionSpecSize(getExceptionSpecType(), getNumExceptions());\n  }\n\n  /// Whether the trailing FunctionTypeExtraBitfields is present.\n  static bool hasExtraBitfields(ExceptionSpecificationType EST) {\n    // If the exception spec type is EST_Dynamic then we have > 0 exception\n    // types and the exact number is stored in FunctionTypeExtraBitfields.\n    return EST == EST_Dynamic;\n  }\n\n  /// Whether the trailing FunctionTypeExtraBitfields is present.\n  bool hasExtraBitfields() const {\n    return hasExtraBitfields(getExceptionSpecType());\n  }\n\n  bool hasExtQualifiers() const {\n    return FunctionTypeBits.HasExtQuals;\n  }\n\npublic:\n  unsigned getNumParams() const { return FunctionTypeBits.NumParams; }\n\n  QualType getParamType(unsigned i) const {\n    assert(i < getNumParams() && \"invalid parameter index\");\n    return param_type_begin()[i];\n  }\n\n  ArrayRef<QualType> getParamTypes() const {\n    return llvm::makeArrayRef(param_type_begin(), param_type_end());\n  }\n\n  ExtProtoInfo getExtProtoInfo() const {\n    ExtProtoInfo EPI;\n    EPI.ExtInfo = getExtInfo();\n    EPI.Variadic = isVariadic();\n    EPI.EllipsisLoc = getEllipsisLoc();\n    EPI.HasTrailingReturn = hasTrailingReturn();\n    EPI.ExceptionSpec = getExceptionSpecInfo();\n    EPI.TypeQuals = getMethodQuals();\n    EPI.RefQualifier = getRefQualifier();\n    EPI.ExtParameterInfos = getExtParameterInfosOrNull();\n    return EPI;\n  }\n\n  /// Get the kind of exception specification on this function.\n  ExceptionSpecificationType getExceptionSpecType() const {\n    return static_cast<ExceptionSpecificationType>(\n        FunctionTypeBits.ExceptionSpecType);\n  }\n\n  /// Return whether this function has any kind of exception spec.\n  bool hasExceptionSpec() const { return getExceptionSpecType() != EST_None; }\n\n  /// Return whether this function has a dynamic (throw) exception spec.\n  bool hasDynamicExceptionSpec() const {\n    return isDynamicExceptionSpec(getExceptionSpecType());\n  }\n\n  /// Return whether this function has a noexcept exception spec.\n  bool hasNoexceptExceptionSpec() const {\n    return isNoexceptExceptionSpec(getExceptionSpecType());\n  }\n\n  /// Return whether this function has a dependent exception spec.\n  bool hasDependentExceptionSpec() const;\n\n  /// Return whether this function has an instantiation-dependent exception\n  /// spec.\n  bool hasInstantiationDependentExceptionSpec() const;\n\n  /// Return all the available information about this type's exception spec.\n  ExceptionSpecInfo getExceptionSpecInfo() const {\n    ExceptionSpecInfo Result;\n    Result.Type = getExceptionSpecType();\n    if (Result.Type == EST_Dynamic) {\n      Result.Exceptions = exceptions();\n    } else if (isComputedNoexcept(Result.Type)) {\n      Result.NoexceptExpr = getNoexceptExpr();\n    } else if (Result.Type == EST_Uninstantiated) {\n      Result.SourceDecl = getExceptionSpecDecl();\n      Result.SourceTemplate = getExceptionSpecTemplate();\n    } else if (Result.Type == EST_Unevaluated) {\n      Result.SourceDecl = getExceptionSpecDecl();\n    }\n    return Result;\n  }\n\n  /// Return the number of types in the exception specification.\n  unsigned getNumExceptions() const {\n    return getExceptionSpecType() == EST_Dynamic\n               ? getTrailingObjects<FunctionTypeExtraBitfields>()\n                     ->NumExceptionType\n               : 0;\n  }\n\n  /// Return the ith exception type, where 0 <= i < getNumExceptions().\n  QualType getExceptionType(unsigned i) const {\n    assert(i < getNumExceptions() && \"Invalid exception number!\");\n    return exception_begin()[i];\n  }\n\n  /// Return the expression inside noexcept(expression), or a null pointer\n  /// if there is none (because the exception spec is not of this form).\n  Expr *getNoexceptExpr() const {\n    if (!isComputedNoexcept(getExceptionSpecType()))\n      return nullptr;\n    return *getTrailingObjects<Expr *>();\n  }\n\n  /// If this function type has an exception specification which hasn't\n  /// been determined yet (either because it has not been evaluated or because\n  /// it has not been instantiated), this is the function whose exception\n  /// specification is represented by this type.\n  FunctionDecl *getExceptionSpecDecl() const {\n    if (getExceptionSpecType() != EST_Uninstantiated &&\n        getExceptionSpecType() != EST_Unevaluated)\n      return nullptr;\n    return getTrailingObjects<FunctionDecl *>()[0];\n  }\n\n  /// If this function type has an uninstantiated exception\n  /// specification, this is the function whose exception specification\n  /// should be instantiated to find the exception specification for\n  /// this type.\n  FunctionDecl *getExceptionSpecTemplate() const {\n    if (getExceptionSpecType() != EST_Uninstantiated)\n      return nullptr;\n    return getTrailingObjects<FunctionDecl *>()[1];\n  }\n\n  /// Determine whether this function type has a non-throwing exception\n  /// specification.\n  CanThrowResult canThrow() const;\n\n  /// Determine whether this function type has a non-throwing exception\n  /// specification. If this depends on template arguments, returns\n  /// \\c ResultIfDependent.\n  bool isNothrow(bool ResultIfDependent = false) const {\n    return ResultIfDependent ? canThrow() != CT_Can : canThrow() == CT_Cannot;\n  }\n\n  /// Whether this function prototype is variadic.\n  bool isVariadic() const { return FunctionTypeBits.Variadic; }\n\n  SourceLocation getEllipsisLoc() const {\n    return isVariadic() ? *getTrailingObjects<SourceLocation>()\n                        : SourceLocation();\n  }\n\n  /// Determines whether this function prototype contains a\n  /// parameter pack at the end.\n  ///\n  /// A function template whose last parameter is a parameter pack can be\n  /// called with an arbitrary number of arguments, much like a variadic\n  /// function.\n  bool isTemplateVariadic() const;\n\n  /// Whether this function prototype has a trailing return type.\n  bool hasTrailingReturn() const { return FunctionTypeBits.HasTrailingReturn; }\n\n  Qualifiers getMethodQuals() const {\n    if (hasExtQualifiers())\n      return *getTrailingObjects<Qualifiers>();\n    else\n      return getFastTypeQuals();\n  }\n\n  /// Retrieve the ref-qualifier associated with this function type.\n  RefQualifierKind getRefQualifier() const {\n    return static_cast<RefQualifierKind>(FunctionTypeBits.RefQualifier);\n  }\n\n  using param_type_iterator = const QualType *;\n  using param_type_range = llvm::iterator_range<param_type_iterator>;\n\n  param_type_range param_types() const {\n    return param_type_range(param_type_begin(), param_type_end());\n  }\n\n  param_type_iterator param_type_begin() const {\n    return getTrailingObjects<QualType>();\n  }\n\n  param_type_iterator param_type_end() const {\n    return param_type_begin() + getNumParams();\n  }\n\n  using exception_iterator = const QualType *;\n\n  ArrayRef<QualType> exceptions() const {\n    return llvm::makeArrayRef(exception_begin(), exception_end());\n  }\n\n  exception_iterator exception_begin() const {\n    return reinterpret_cast<exception_iterator>(\n        getTrailingObjects<ExceptionType>());\n  }\n\n  exception_iterator exception_end() const {\n    return exception_begin() + getNumExceptions();\n  }\n\n  /// Is there any interesting extra information for any of the parameters\n  /// of this function type?\n  bool hasExtParameterInfos() const {\n    return FunctionTypeBits.HasExtParameterInfos;\n  }\n\n  ArrayRef<ExtParameterInfo> getExtParameterInfos() const {\n    assert(hasExtParameterInfos());\n    return ArrayRef<ExtParameterInfo>(getTrailingObjects<ExtParameterInfo>(),\n                                      getNumParams());\n  }\n\n  /// Return a pointer to the beginning of the array of extra parameter\n  /// information, if present, or else null if none of the parameters\n  /// carry it.  This is equivalent to getExtProtoInfo().ExtParameterInfos.\n  const ExtParameterInfo *getExtParameterInfosOrNull() const {\n    if (!hasExtParameterInfos())\n      return nullptr;\n    return getTrailingObjects<ExtParameterInfo>();\n  }\n\n  ExtParameterInfo getExtParameterInfo(unsigned I) const {\n    assert(I < getNumParams() && \"parameter index out of range\");\n    if (hasExtParameterInfos())\n      return getTrailingObjects<ExtParameterInfo>()[I];\n    return ExtParameterInfo();\n  }\n\n  ParameterABI getParameterABI(unsigned I) const {\n    assert(I < getNumParams() && \"parameter index out of range\");\n    if (hasExtParameterInfos())\n      return getTrailingObjects<ExtParameterInfo>()[I].getABI();\n    return ParameterABI::Ordinary;\n  }\n\n  bool isParamConsumed(unsigned I) const {\n    assert(I < getNumParams() && \"parameter index out of range\");\n    if (hasExtParameterInfos())\n      return getTrailingObjects<ExtParameterInfo>()[I].isConsumed();\n    return false;\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void printExceptionSpecification(raw_ostream &OS,\n                                   const PrintingPolicy &Policy) const;\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == FunctionProto;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Ctx);\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType Result,\n                      param_type_iterator ArgTys, unsigned NumArgs,\n                      const ExtProtoInfo &EPI, const ASTContext &Context,\n                      bool Canonical);\n};\n\n/// Represents the dependent type named by a dependently-scoped\n/// typename using declaration, e.g.\n///   using typename Base<T>::foo;\n///\n/// Template instantiation turns these into the underlying type.\nclass UnresolvedUsingType : public Type {\n  friend class ASTContext; // ASTContext creates these.\n\n  UnresolvedUsingTypenameDecl *Decl;\n\n  UnresolvedUsingType(const UnresolvedUsingTypenameDecl *D)\n      : Type(UnresolvedUsing, QualType(),\n             TypeDependence::DependentInstantiation),\n        Decl(const_cast<UnresolvedUsingTypenameDecl *>(D)) {}\n\npublic:\n  UnresolvedUsingTypenameDecl *getDecl() const { return Decl; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == UnresolvedUsing;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    return Profile(ID, Decl);\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      UnresolvedUsingTypenameDecl *D) {\n    ID.AddPointer(D);\n  }\n};\n\nclass TypedefType : public Type {\n  TypedefNameDecl *Decl;\n\nprivate:\n  friend class ASTContext; // ASTContext creates these.\n\n  TypedefType(TypeClass tc, const TypedefNameDecl *D, QualType underlying,\n              QualType can);\n\npublic:\n  TypedefNameDecl *getDecl() const { return Decl; }\n\n  bool isSugared() const { return true; }\n  QualType desugar() const;\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Typedef; }\n};\n\n/// Sugar type that represents a type that was qualified by a qualifier written\n/// as a macro invocation.\nclass MacroQualifiedType : public Type {\n  friend class ASTContext; // ASTContext creates these.\n\n  QualType UnderlyingTy;\n  const IdentifierInfo *MacroII;\n\n  MacroQualifiedType(QualType UnderlyingTy, QualType CanonTy,\n                     const IdentifierInfo *MacroII)\n      : Type(MacroQualified, CanonTy, UnderlyingTy->getDependence()),\n        UnderlyingTy(UnderlyingTy), MacroII(MacroII) {\n    assert(isa<AttributedType>(UnderlyingTy) &&\n           \"Expected a macro qualified type to only wrap attributed types.\");\n  }\n\npublic:\n  const IdentifierInfo *getMacroIdentifier() const { return MacroII; }\n  QualType getUnderlyingType() const { return UnderlyingTy; }\n\n  /// Return this attributed type's modified type with no qualifiers attached to\n  /// it.\n  QualType getModifiedType() const;\n\n  bool isSugared() const { return true; }\n  QualType desugar() const;\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == MacroQualified;\n  }\n};\n\n/// Represents a `typeof` (or __typeof__) expression (a GCC extension).\nclass TypeOfExprType : public Type {\n  Expr *TOExpr;\n\nprotected:\n  friend class ASTContext; // ASTContext creates these.\n\n  TypeOfExprType(Expr *E, QualType can = QualType());\n\npublic:\n  Expr *getUnderlyingExpr() const { return TOExpr; }\n\n  /// Remove a single level of sugar.\n  QualType desugar() const;\n\n  /// Returns whether this type directly provides sugar.\n  bool isSugared() const;\n\n  static bool classof(const Type *T) { return T->getTypeClass() == TypeOfExpr; }\n};\n\n/// Internal representation of canonical, dependent\n/// `typeof(expr)` types.\n///\n/// This class is used internally by the ASTContext to manage\n/// canonical, dependent types, only. Clients will only see instances\n/// of this class via TypeOfExprType nodes.\nclass DependentTypeOfExprType\n  : public TypeOfExprType, public llvm::FoldingSetNode {\n  const ASTContext &Context;\n\npublic:\n  DependentTypeOfExprType(const ASTContext &Context, Expr *E)\n      : TypeOfExprType(E), Context(Context) {}\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Context, getUnderlyingExpr());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      Expr *E);\n};\n\n/// Represents `typeof(type)`, a GCC extension.\nclass TypeOfType : public Type {\n  friend class ASTContext; // ASTContext creates these.\n\n  QualType TOType;\n\n  TypeOfType(QualType T, QualType can)\n      : Type(TypeOf, can, T->getDependence()), TOType(T) {\n    assert(!isa<TypedefType>(can) && \"Invalid canonical type\");\n  }\n\npublic:\n  QualType getUnderlyingType() const { return TOType; }\n\n  /// Remove a single level of sugar.\n  QualType desugar() const { return getUnderlyingType(); }\n\n  /// Returns whether this type directly provides sugar.\n  bool isSugared() const { return true; }\n\n  static bool classof(const Type *T) { return T->getTypeClass() == TypeOf; }\n};\n\n/// Represents the type `decltype(expr)` (C++11).\nclass DecltypeType : public Type {\n  Expr *E;\n  QualType UnderlyingType;\n\nprotected:\n  friend class ASTContext; // ASTContext creates these.\n\n  DecltypeType(Expr *E, QualType underlyingType, QualType can = QualType());\n\npublic:\n  Expr *getUnderlyingExpr() const { return E; }\n  QualType getUnderlyingType() const { return UnderlyingType; }\n\n  /// Remove a single level of sugar.\n  QualType desugar() const;\n\n  /// Returns whether this type directly provides sugar.\n  bool isSugared() const;\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Decltype; }\n};\n\n/// Internal representation of canonical, dependent\n/// decltype(expr) types.\n///\n/// This class is used internally by the ASTContext to manage\n/// canonical, dependent types, only. Clients will only see instances\n/// of this class via DecltypeType nodes.\nclass DependentDecltypeType : public DecltypeType, public llvm::FoldingSetNode {\n  const ASTContext &Context;\n\npublic:\n  DependentDecltypeType(const ASTContext &Context, Expr *E);\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Context, getUnderlyingExpr());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      Expr *E);\n};\n\n/// A unary type transform, which is a type constructed from another.\nclass UnaryTransformType : public Type {\npublic:\n  enum UTTKind {\n    EnumUnderlyingType\n  };\n\nprivate:\n  /// The untransformed type.\n  QualType BaseType;\n\n  /// The transformed type if not dependent, otherwise the same as BaseType.\n  QualType UnderlyingType;\n\n  UTTKind UKind;\n\nprotected:\n  friend class ASTContext;\n\n  UnaryTransformType(QualType BaseTy, QualType UnderlyingTy, UTTKind UKind,\n                     QualType CanonicalTy);\n\npublic:\n  bool isSugared() const { return !isDependentType(); }\n  QualType desugar() const { return UnderlyingType; }\n\n  QualType getUnderlyingType() const { return UnderlyingType; }\n  QualType getBaseType() const { return BaseType; }\n\n  UTTKind getUTTKind() const { return UKind; }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == UnaryTransform;\n  }\n};\n\n/// Internal representation of canonical, dependent\n/// __underlying_type(type) types.\n///\n/// This class is used internally by the ASTContext to manage\n/// canonical, dependent types, only. Clients will only see instances\n/// of this class via UnaryTransformType nodes.\nclass DependentUnaryTransformType : public UnaryTransformType,\n                                    public llvm::FoldingSetNode {\npublic:\n  DependentUnaryTransformType(const ASTContext &C, QualType BaseType,\n                              UTTKind UKind);\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getBaseType(), getUTTKind());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType BaseType,\n                      UTTKind UKind) {\n    ID.AddPointer(BaseType.getAsOpaquePtr());\n    ID.AddInteger((unsigned)UKind);\n  }\n};\n\nclass TagType : public Type {\n  friend class ASTReader;\n  template <class T> friend class serialization::AbstractTypeReader;\n\n  /// Stores the TagDecl associated with this type. The decl may point to any\n  /// TagDecl that declares the entity.\n  TagDecl *decl;\n\nprotected:\n  TagType(TypeClass TC, const TagDecl *D, QualType can);\n\npublic:\n  TagDecl *getDecl() const;\n\n  /// Determines whether this type is in the process of being defined.\n  bool isBeingDefined() const;\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == Enum || T->getTypeClass() == Record;\n  }\n};\n\n/// A helper class that allows the use of isa/cast/dyncast\n/// to detect TagType objects of structs/unions/classes.\nclass RecordType : public TagType {\nprotected:\n  friend class ASTContext; // ASTContext creates these.\n\n  explicit RecordType(const RecordDecl *D)\n      : TagType(Record, reinterpret_cast<const TagDecl*>(D), QualType()) {}\n  explicit RecordType(TypeClass TC, RecordDecl *D)\n      : TagType(TC, reinterpret_cast<const TagDecl*>(D), QualType()) {}\n\npublic:\n  RecordDecl *getDecl() const {\n    return reinterpret_cast<RecordDecl*>(TagType::getDecl());\n  }\n\n  /// Recursively check all fields in the record for const-ness. If any field\n  /// is declared const, return true. Otherwise, return false.\n  bool hasConstFields() const;\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Record; }\n};\n\n/// A helper class that allows the use of isa/cast/dyncast\n/// to detect TagType objects of enums.\nclass EnumType : public TagType {\n  friend class ASTContext; // ASTContext creates these.\n\n  explicit EnumType(const EnumDecl *D)\n      : TagType(Enum, reinterpret_cast<const TagDecl*>(D), QualType()) {}\n\npublic:\n  EnumDecl *getDecl() const {\n    return reinterpret_cast<EnumDecl*>(TagType::getDecl());\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Enum; }\n};\n\n/// An attributed type is a type to which a type attribute has been applied.\n///\n/// The \"modified type\" is the fully-sugared type to which the attributed\n/// type was applied; generally it is not canonically equivalent to the\n/// attributed type. The \"equivalent type\" is the minimally-desugared type\n/// which the type is canonically equivalent to.\n///\n/// For example, in the following attributed type:\n///     int32_t __attribute__((vector_size(16)))\n///   - the modified type is the TypedefType for int32_t\n///   - the equivalent type is VectorType(16, int32_t)\n///   - the canonical type is VectorType(16, int)\nclass AttributedType : public Type, public llvm::FoldingSetNode {\npublic:\n  using Kind = attr::Kind;\n\nprivate:\n  friend class ASTContext; // ASTContext creates these\n\n  QualType ModifiedType;\n  QualType EquivalentType;\n\n  AttributedType(QualType canon, attr::Kind attrKind, QualType modified,\n                 QualType equivalent)\n      : Type(Attributed, canon, equivalent->getDependence()),\n        ModifiedType(modified), EquivalentType(equivalent) {\n    AttributedTypeBits.AttrKind = attrKind;\n  }\n\npublic:\n  Kind getAttrKind() const {\n    return static_cast<Kind>(AttributedTypeBits.AttrKind);\n  }\n\n  QualType getModifiedType() const { return ModifiedType; }\n  QualType getEquivalentType() const { return EquivalentType; }\n\n  bool isSugared() const { return true; }\n  QualType desugar() const { return getEquivalentType(); }\n\n  /// Does this attribute behave like a type qualifier?\n  ///\n  /// A type qualifier adjusts a type to provide specialized rules for\n  /// a specific object, like the standard const and volatile qualifiers.\n  /// This includes attributes controlling things like nullability,\n  /// address spaces, and ARC ownership.  The value of the object is still\n  /// largely described by the modified type.\n  ///\n  /// In contrast, many type attributes \"rewrite\" their modified type to\n  /// produce a fundamentally different type, not necessarily related in any\n  /// formalizable way to the original type.  For example, calling convention\n  /// and vector attributes are not simple type qualifiers.\n  ///\n  /// Type qualifiers are often, but not always, reflected in the canonical\n  /// type.\n  bool isQualifier() const;\n\n  bool isMSTypeSpec() const;\n\n  bool isCallingConv() const;\n\n  llvm::Optional<NullabilityKind> getImmediateNullability() const;\n\n  /// Retrieve the attribute kind corresponding to the given\n  /// nullability kind.\n  static Kind getNullabilityAttrKind(NullabilityKind kind) {\n    switch (kind) {\n    case NullabilityKind::NonNull:\n      return attr::TypeNonNull;\n\n    case NullabilityKind::Nullable:\n      return attr::TypeNullable;\n\n    case NullabilityKind::NullableResult:\n      return attr::TypeNullableResult;\n\n    case NullabilityKind::Unspecified:\n      return attr::TypeNullUnspecified;\n    }\n    llvm_unreachable(\"Unknown nullability kind.\");\n  }\n\n  /// Strip off the top-level nullability annotation on the given\n  /// type, if it's there.\n  ///\n  /// \\param T The type to strip. If the type is exactly an\n  /// AttributedType specifying nullability (without looking through\n  /// type sugar), the nullability is returned and this type changed\n  /// to the underlying modified type.\n  ///\n  /// \\returns the top-level nullability, if present.\n  static Optional<NullabilityKind> stripOuterNullability(QualType &T);\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getAttrKind(), ModifiedType, EquivalentType);\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, Kind attrKind,\n                      QualType modified, QualType equivalent) {\n    ID.AddInteger(attrKind);\n    ID.AddPointer(modified.getAsOpaquePtr());\n    ID.AddPointer(equivalent.getAsOpaquePtr());\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == Attributed;\n  }\n};\n\nclass TemplateTypeParmType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these\n\n  // Helper data collector for canonical types.\n  struct CanonicalTTPTInfo {\n    unsigned Depth : 15;\n    unsigned ParameterPack : 1;\n    unsigned Index : 16;\n  };\n\n  union {\n    // Info for the canonical type.\n    CanonicalTTPTInfo CanTTPTInfo;\n\n    // Info for the non-canonical type.\n    TemplateTypeParmDecl *TTPDecl;\n  };\n\n  /// Build a non-canonical type.\n  TemplateTypeParmType(TemplateTypeParmDecl *TTPDecl, QualType Canon)\n      : Type(TemplateTypeParm, Canon,\n             TypeDependence::DependentInstantiation |\n                 (Canon->getDependence() & TypeDependence::UnexpandedPack)),\n        TTPDecl(TTPDecl) {}\n\n  /// Build the canonical type.\n  TemplateTypeParmType(unsigned D, unsigned I, bool PP)\n      : Type(TemplateTypeParm, QualType(this, 0),\n             TypeDependence::DependentInstantiation |\n                 (PP ? TypeDependence::UnexpandedPack : TypeDependence::None)) {\n    CanTTPTInfo.Depth = D;\n    CanTTPTInfo.Index = I;\n    CanTTPTInfo.ParameterPack = PP;\n  }\n\n  const CanonicalTTPTInfo& getCanTTPTInfo() const {\n    QualType Can = getCanonicalTypeInternal();\n    return Can->castAs<TemplateTypeParmType>()->CanTTPTInfo;\n  }\n\npublic:\n  unsigned getDepth() const { return getCanTTPTInfo().Depth; }\n  unsigned getIndex() const { return getCanTTPTInfo().Index; }\n  bool isParameterPack() const { return getCanTTPTInfo().ParameterPack; }\n\n  TemplateTypeParmDecl *getDecl() const {\n    return isCanonicalUnqualified() ? nullptr : TTPDecl;\n  }\n\n  IdentifierInfo *getIdentifier() const;\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getDepth(), getIndex(), isParameterPack(), getDecl());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, unsigned Depth,\n                      unsigned Index, bool ParameterPack,\n                      TemplateTypeParmDecl *TTPDecl) {\n    ID.AddInteger(Depth);\n    ID.AddInteger(Index);\n    ID.AddBoolean(ParameterPack);\n    ID.AddPointer(TTPDecl);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == TemplateTypeParm;\n  }\n};\n\n/// Represents the result of substituting a type for a template\n/// type parameter.\n///\n/// Within an instantiated template, all template type parameters have\n/// been replaced with these.  They are used solely to record that a\n/// type was originally written as a template type parameter;\n/// therefore they are never canonical.\nclass SubstTemplateTypeParmType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext;\n\n  // The original type parameter.\n  const TemplateTypeParmType *Replaced;\n\n  SubstTemplateTypeParmType(const TemplateTypeParmType *Param, QualType Canon)\n      : Type(SubstTemplateTypeParm, Canon, Canon->getDependence()),\n        Replaced(Param) {}\n\npublic:\n  /// Gets the template parameter that was substituted for.\n  const TemplateTypeParmType *getReplacedParameter() const {\n    return Replaced;\n  }\n\n  /// Gets the type that was substituted for the template\n  /// parameter.\n  QualType getReplacementType() const {\n    return getCanonicalTypeInternal();\n  }\n\n  bool isSugared() const { return true; }\n  QualType desugar() const { return getReplacementType(); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getReplacedParameter(), getReplacementType());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      const TemplateTypeParmType *Replaced,\n                      QualType Replacement) {\n    ID.AddPointer(Replaced);\n    ID.AddPointer(Replacement.getAsOpaquePtr());\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == SubstTemplateTypeParm;\n  }\n};\n\n/// Represents the result of substituting a set of types for a template\n/// type parameter pack.\n///\n/// When a pack expansion in the source code contains multiple parameter packs\n/// and those parameter packs correspond to different levels of template\n/// parameter lists, this type node is used to represent a template type\n/// parameter pack from an outer level, which has already had its argument pack\n/// substituted but that still lives within a pack expansion that itself\n/// could not be instantiated. When actually performing a substitution into\n/// that pack expansion (e.g., when all template parameters have corresponding\n/// arguments), this type will be replaced with the \\c SubstTemplateTypeParmType\n/// at the current pack substitution index.\nclass SubstTemplateTypeParmPackType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext;\n\n  /// The original type parameter.\n  const TemplateTypeParmType *Replaced;\n\n  /// A pointer to the set of template arguments that this\n  /// parameter pack is instantiated with.\n  const TemplateArgument *Arguments;\n\n  SubstTemplateTypeParmPackType(const TemplateTypeParmType *Param,\n                                QualType Canon,\n                                const TemplateArgument &ArgPack);\n\npublic:\n  IdentifierInfo *getIdentifier() const { return Replaced->getIdentifier(); }\n\n  /// Gets the template parameter that was substituted for.\n  const TemplateTypeParmType *getReplacedParameter() const {\n    return Replaced;\n  }\n\n  unsigned getNumArgs() const {\n    return SubstTemplateTypeParmPackTypeBits.NumArgs;\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  TemplateArgument getArgumentPack() const;\n\n  void Profile(llvm::FoldingSetNodeID &ID);\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      const TemplateTypeParmType *Replaced,\n                      const TemplateArgument &ArgPack);\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == SubstTemplateTypeParmPack;\n  }\n};\n\n/// Common base class for placeholders for types that get replaced by\n/// placeholder type deduction: C++11 auto, C++14 decltype(auto), C++17 deduced\n/// class template types, and constrained type names.\n///\n/// These types are usually a placeholder for a deduced type. However, before\n/// the initializer is attached, or (usually) if the initializer is\n/// type-dependent, there is no deduced type and the type is canonical. In\n/// the latter case, it is also a dependent type.\nclass DeducedType : public Type {\nprotected:\n  DeducedType(TypeClass TC, QualType DeducedAsType,\n              TypeDependence ExtraDependence)\n      : Type(TC,\n             // FIXME: Retain the sugared deduced type?\n             DeducedAsType.isNull() ? QualType(this, 0)\n                                    : DeducedAsType.getCanonicalType(),\n             ExtraDependence | (DeducedAsType.isNull()\n                                    ? TypeDependence::None\n                                    : DeducedAsType->getDependence() &\n                                          ~TypeDependence::VariablyModified)) {}\n\npublic:\n  bool isSugared() const { return !isCanonicalUnqualified(); }\n  QualType desugar() const { return getCanonicalTypeInternal(); }\n\n  /// Get the type deduced for this placeholder type, or null if it's\n  /// either not been deduced or was deduced to a dependent type.\n  QualType getDeducedType() const {\n    return !isCanonicalUnqualified() ? getCanonicalTypeInternal() : QualType();\n  }\n  bool isDeduced() const {\n    return !isCanonicalUnqualified() || isDependentType();\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == Auto ||\n           T->getTypeClass() == DeducedTemplateSpecialization;\n  }\n};\n\n/// Represents a C++11 auto or C++14 decltype(auto) type, possibly constrained\n/// by a type-constraint.\nclass alignas(8) AutoType : public DeducedType, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these\n\n  ConceptDecl *TypeConstraintConcept;\n\n  AutoType(QualType DeducedAsType, AutoTypeKeyword Keyword,\n           TypeDependence ExtraDependence, ConceptDecl *CD,\n           ArrayRef<TemplateArgument> TypeConstraintArgs);\n\n  const TemplateArgument *getArgBuffer() const {\n    return reinterpret_cast<const TemplateArgument*>(this+1);\n  }\n\n  TemplateArgument *getArgBuffer() {\n    return reinterpret_cast<TemplateArgument*>(this+1);\n  }\n\npublic:\n  /// Retrieve the template arguments.\n  const TemplateArgument *getArgs() const {\n    return getArgBuffer();\n  }\n\n  /// Retrieve the number of template arguments.\n  unsigned getNumArgs() const {\n    return AutoTypeBits.NumArgs;\n  }\n\n  const TemplateArgument &getArg(unsigned Idx) const; // in TemplateBase.h\n\n  ArrayRef<TemplateArgument> getTypeConstraintArguments() const {\n    return {getArgs(), getNumArgs()};\n  }\n\n  ConceptDecl *getTypeConstraintConcept() const {\n    return TypeConstraintConcept;\n  }\n\n  bool isConstrained() const {\n    return TypeConstraintConcept != nullptr;\n  }\n\n  bool isDecltypeAuto() const {\n    return getKeyword() == AutoTypeKeyword::DecltypeAuto;\n  }\n\n  AutoTypeKeyword getKeyword() const {\n    return (AutoTypeKeyword)AutoTypeBits.Keyword;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context) {\n    Profile(ID, Context, getDeducedType(), getKeyword(), isDependentType(),\n            getTypeConstraintConcept(), getTypeConstraintArguments());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      QualType Deduced, AutoTypeKeyword Keyword,\n                      bool IsDependent, ConceptDecl *CD,\n                      ArrayRef<TemplateArgument> Arguments);\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == Auto;\n  }\n};\n\n/// Represents a C++17 deduced template specialization type.\nclass DeducedTemplateSpecializationType : public DeducedType,\n                                          public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these\n\n  /// The name of the template whose arguments will be deduced.\n  TemplateName Template;\n\n  DeducedTemplateSpecializationType(TemplateName Template,\n                                    QualType DeducedAsType,\n                                    bool IsDeducedAsDependent)\n      : DeducedType(DeducedTemplateSpecialization, DeducedAsType,\n                    toTypeDependence(Template.getDependence()) |\n                        (IsDeducedAsDependent\n                             ? TypeDependence::DependentInstantiation\n                             : TypeDependence::None)),\n        Template(Template) {}\n\npublic:\n  /// Retrieve the name of the template that we are deducing.\n  TemplateName getTemplateName() const { return Template;}\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getTemplateName(), getDeducedType(), isDependentType());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, TemplateName Template,\n                      QualType Deduced, bool IsDependent) {\n    Template.Profile(ID);\n    ID.AddPointer(Deduced.getAsOpaquePtr());\n    ID.AddBoolean(IsDependent);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DeducedTemplateSpecialization;\n  }\n};\n\n/// Represents a type template specialization; the template\n/// must be a class template, a type alias template, or a template\n/// template parameter.  A template which cannot be resolved to one of\n/// these, e.g. because it is written with a dependent scope\n/// specifier, is instead represented as a\n/// @c DependentTemplateSpecializationType.\n///\n/// A non-dependent template specialization type is always \"sugar\",\n/// typically for a \\c RecordType.  For example, a class template\n/// specialization type of \\c vector<int> will refer to a tag type for\n/// the instantiation \\c std::vector<int, std::allocator<int>>\n///\n/// Template specializations are dependent if either the template or\n/// any of the template arguments are dependent, in which case the\n/// type may also be canonical.\n///\n/// Instances of this type are allocated with a trailing array of\n/// TemplateArguments, followed by a QualType representing the\n/// non-canonical aliased type when the template is a type alias\n/// template.\nclass alignas(8) TemplateSpecializationType\n    : public Type,\n      public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these\n\n  /// The name of the template being specialized.  This is\n  /// either a TemplateName::Template (in which case it is a\n  /// ClassTemplateDecl*, a TemplateTemplateParmDecl*, or a\n  /// TypeAliasTemplateDecl*), a\n  /// TemplateName::SubstTemplateTemplateParmPack, or a\n  /// TemplateName::SubstTemplateTemplateParm (in which case the\n  /// replacement must, recursively, be one of these).\n  TemplateName Template;\n\n  TemplateSpecializationType(TemplateName T,\n                             ArrayRef<TemplateArgument> Args,\n                             QualType Canon,\n                             QualType Aliased);\n\npublic:\n  /// Determine whether any of the given template arguments are dependent.\n  ///\n  /// The converted arguments should be supplied when known; whether an\n  /// argument is dependent can depend on the conversions performed on it\n  /// (for example, a 'const int' passed as a template argument might be\n  /// dependent if the parameter is a reference but non-dependent if the\n  /// parameter is an int).\n  ///\n  /// Note that the \\p Args parameter is unused: this is intentional, to remind\n  /// the caller that they need to pass in the converted arguments, not the\n  /// specified arguments.\n  static bool\n  anyDependentTemplateArguments(ArrayRef<TemplateArgumentLoc> Args,\n                                ArrayRef<TemplateArgument> Converted);\n  static bool\n  anyDependentTemplateArguments(const TemplateArgumentListInfo &,\n                                ArrayRef<TemplateArgument> Converted);\n  static bool anyInstantiationDependentTemplateArguments(\n      ArrayRef<TemplateArgumentLoc> Args);\n\n  /// True if this template specialization type matches a current\n  /// instantiation in the context in which it is found.\n  bool isCurrentInstantiation() const {\n    return isa<InjectedClassNameType>(getCanonicalTypeInternal());\n  }\n\n  /// Determine if this template specialization type is for a type alias\n  /// template that has been substituted.\n  ///\n  /// Nearly every template specialization type whose template is an alias\n  /// template will be substituted. However, this is not the case when\n  /// the specialization contains a pack expansion but the template alias\n  /// does not have a corresponding parameter pack, e.g.,\n  ///\n  /// \\code\n  /// template<typename T, typename U, typename V> struct S;\n  /// template<typename T, typename U> using A = S<T, int, U>;\n  /// template<typename... Ts> struct X {\n  ///   typedef A<Ts...> type; // not a type alias\n  /// };\n  /// \\endcode\n  bool isTypeAlias() const { return TemplateSpecializationTypeBits.TypeAlias; }\n\n  /// Get the aliased type, if this is a specialization of a type alias\n  /// template.\n  QualType getAliasedType() const {\n    assert(isTypeAlias() && \"not a type alias template specialization\");\n    return *reinterpret_cast<const QualType*>(end());\n  }\n\n  using iterator = const TemplateArgument *;\n\n  iterator begin() const { return getArgs(); }\n  iterator end() const; // defined inline in TemplateBase.h\n\n  /// Retrieve the name of the template that we are specializing.\n  TemplateName getTemplateName() const { return Template; }\n\n  /// Retrieve the template arguments.\n  const TemplateArgument *getArgs() const {\n    return reinterpret_cast<const TemplateArgument *>(this + 1);\n  }\n\n  /// Retrieve the number of template arguments.\n  unsigned getNumArgs() const {\n    return TemplateSpecializationTypeBits.NumArgs;\n  }\n\n  /// Retrieve a specific template argument as a type.\n  /// \\pre \\c isArgType(Arg)\n  const TemplateArgument &getArg(unsigned Idx) const; // in TemplateBase.h\n\n  ArrayRef<TemplateArgument> template_arguments() const {\n    return {getArgs(), getNumArgs()};\n  }\n\n  bool isSugared() const {\n    return !isDependentType() || isCurrentInstantiation() || isTypeAlias();\n  }\n\n  QualType desugar() const {\n    return isTypeAlias() ? getAliasedType() : getCanonicalTypeInternal();\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Ctx) {\n    Profile(ID, Template, template_arguments(), Ctx);\n    if (isTypeAlias())\n      getAliasedType().Profile(ID);\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, TemplateName T,\n                      ArrayRef<TemplateArgument> Args,\n                      const ASTContext &Context);\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == TemplateSpecialization;\n  }\n};\n\n/// Print a template argument list, including the '<' and '>'\n/// enclosing the template arguments.\nvoid printTemplateArgumentList(raw_ostream &OS,\n                               ArrayRef<TemplateArgument> Args,\n                               const PrintingPolicy &Policy,\n                               const TemplateParameterList *TPL = nullptr);\n\nvoid printTemplateArgumentList(raw_ostream &OS,\n                               ArrayRef<TemplateArgumentLoc> Args,\n                               const PrintingPolicy &Policy,\n                               const TemplateParameterList *TPL = nullptr);\n\nvoid printTemplateArgumentList(raw_ostream &OS,\n                               const TemplateArgumentListInfo &Args,\n                               const PrintingPolicy &Policy,\n                               const TemplateParameterList *TPL = nullptr);\n\n/// The injected class name of a C++ class template or class\n/// template partial specialization.  Used to record that a type was\n/// spelled with a bare identifier rather than as a template-id; the\n/// equivalent for non-templated classes is just RecordType.\n///\n/// Injected class name types are always dependent.  Template\n/// instantiation turns these into RecordTypes.\n///\n/// Injected class name types are always canonical.  This works\n/// because it is impossible to compare an injected class name type\n/// with the corresponding non-injected template type, for the same\n/// reason that it is impossible to directly compare template\n/// parameters from different dependent contexts: injected class name\n/// types can only occur within the scope of a particular templated\n/// declaration, and within that scope every template specialization\n/// will canonicalize to the injected class name (when appropriate\n/// according to the rules of the language).\nclass InjectedClassNameType : public Type {\n  friend class ASTContext; // ASTContext creates these.\n  friend class ASTNodeImporter;\n  friend class ASTReader; // FIXME: ASTContext::getInjectedClassNameType is not\n                          // currently suitable for AST reading, too much\n                          // interdependencies.\n  template <class T> friend class serialization::AbstractTypeReader;\n\n  CXXRecordDecl *Decl;\n\n  /// The template specialization which this type represents.\n  /// For example, in\n  ///   template <class T> class A { ... };\n  /// this is A<T>, whereas in\n  ///   template <class X, class Y> class A<B<X,Y> > { ... };\n  /// this is A<B<X,Y> >.\n  ///\n  /// It is always unqualified, always a template specialization type,\n  /// and always dependent.\n  QualType InjectedType;\n\n  InjectedClassNameType(CXXRecordDecl *D, QualType TST)\n      : Type(InjectedClassName, QualType(),\n             TypeDependence::DependentInstantiation),\n        Decl(D), InjectedType(TST) {\n    assert(isa<TemplateSpecializationType>(TST));\n    assert(!TST.hasQualifiers());\n    assert(TST->isDependentType());\n  }\n\npublic:\n  QualType getInjectedSpecializationType() const { return InjectedType; }\n\n  const TemplateSpecializationType *getInjectedTST() const {\n    return cast<TemplateSpecializationType>(InjectedType.getTypePtr());\n  }\n\n  TemplateName getTemplateName() const {\n    return getInjectedTST()->getTemplateName();\n  }\n\n  CXXRecordDecl *getDecl() const;\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == InjectedClassName;\n  }\n};\n\n/// The kind of a tag type.\nenum TagTypeKind {\n  /// The \"struct\" keyword.\n  TTK_Struct,\n\n  /// The \"__interface\" keyword.\n  TTK_Interface,\n\n  /// The \"union\" keyword.\n  TTK_Union,\n\n  /// The \"class\" keyword.\n  TTK_Class,\n\n  /// The \"enum\" keyword.\n  TTK_Enum\n};\n\n/// The elaboration keyword that precedes a qualified type name or\n/// introduces an elaborated-type-specifier.\nenum ElaboratedTypeKeyword {\n  /// The \"struct\" keyword introduces the elaborated-type-specifier.\n  ETK_Struct,\n\n  /// The \"__interface\" keyword introduces the elaborated-type-specifier.\n  ETK_Interface,\n\n  /// The \"union\" keyword introduces the elaborated-type-specifier.\n  ETK_Union,\n\n  /// The \"class\" keyword introduces the elaborated-type-specifier.\n  ETK_Class,\n\n  /// The \"enum\" keyword introduces the elaborated-type-specifier.\n  ETK_Enum,\n\n  /// The \"typename\" keyword precedes the qualified type name, e.g.,\n  /// \\c typename T::type.\n  ETK_Typename,\n\n  /// No keyword precedes the qualified type name.\n  ETK_None\n};\n\n/// A helper class for Type nodes having an ElaboratedTypeKeyword.\n/// The keyword in stored in the free bits of the base class.\n/// Also provides a few static helpers for converting and printing\n/// elaborated type keyword and tag type kind enumerations.\nclass TypeWithKeyword : public Type {\nprotected:\n  TypeWithKeyword(ElaboratedTypeKeyword Keyword, TypeClass tc,\n                  QualType Canonical, TypeDependence Dependence)\n      : Type(tc, Canonical, Dependence) {\n    TypeWithKeywordBits.Keyword = Keyword;\n  }\n\npublic:\n  ElaboratedTypeKeyword getKeyword() const {\n    return static_cast<ElaboratedTypeKeyword>(TypeWithKeywordBits.Keyword);\n  }\n\n  /// Converts a type specifier (DeclSpec::TST) into an elaborated type keyword.\n  static ElaboratedTypeKeyword getKeywordForTypeSpec(unsigned TypeSpec);\n\n  /// Converts a type specifier (DeclSpec::TST) into a tag type kind.\n  /// It is an error to provide a type specifier which *isn't* a tag kind here.\n  static TagTypeKind getTagTypeKindForTypeSpec(unsigned TypeSpec);\n\n  /// Converts a TagTypeKind into an elaborated type keyword.\n  static ElaboratedTypeKeyword getKeywordForTagTypeKind(TagTypeKind Tag);\n\n  /// Converts an elaborated type keyword into a TagTypeKind.\n  /// It is an error to provide an elaborated type keyword\n  /// which *isn't* a tag kind here.\n  static TagTypeKind getTagTypeKindForKeyword(ElaboratedTypeKeyword Keyword);\n\n  static bool KeywordIsTagTypeKind(ElaboratedTypeKeyword Keyword);\n\n  static StringRef getKeywordName(ElaboratedTypeKeyword Keyword);\n\n  static StringRef getTagTypeKindName(TagTypeKind Kind) {\n    return getKeywordName(getKeywordForTagTypeKind(Kind));\n  }\n\n  class CannotCastToThisType {};\n  static CannotCastToThisType classof(const Type *);\n};\n\n/// Represents a type that was referred to using an elaborated type\n/// keyword, e.g., struct S, or via a qualified name, e.g., N::M::type,\n/// or both.\n///\n/// This type is used to keep track of a type name as written in the\n/// source code, including tag keywords and any nested-name-specifiers.\n/// The type itself is always \"sugar\", used to express what was written\n/// in the source code but containing no additional semantic information.\nclass ElaboratedType final\n    : public TypeWithKeyword,\n      public llvm::FoldingSetNode,\n      private llvm::TrailingObjects<ElaboratedType, TagDecl *> {\n  friend class ASTContext; // ASTContext creates these\n  friend TrailingObjects;\n\n  /// The nested name specifier containing the qualifier.\n  NestedNameSpecifier *NNS;\n\n  /// The type that this qualified name refers to.\n  QualType NamedType;\n\n  /// The (re)declaration of this tag type owned by this occurrence is stored\n  /// as a trailing object if there is one. Use getOwnedTagDecl to obtain\n  /// it, or obtain a null pointer if there is none.\n\n  ElaboratedType(ElaboratedTypeKeyword Keyword, NestedNameSpecifier *NNS,\n                 QualType NamedType, QualType CanonType, TagDecl *OwnedTagDecl)\n      : TypeWithKeyword(Keyword, Elaborated, CanonType,\n                        // Any semantic dependence on the qualifier will have\n                        // been incorporated into NamedType. We still need to\n                        // track syntactic (instantiation / error / pack)\n                        // dependence on the qualifier.\n                        NamedType->getDependence() |\n                            (NNS ? toSyntacticDependence(\n                                       toTypeDependence(NNS->getDependence()))\n                                 : TypeDependence::None)),\n        NNS(NNS), NamedType(NamedType) {\n    ElaboratedTypeBits.HasOwnedTagDecl = false;\n    if (OwnedTagDecl) {\n      ElaboratedTypeBits.HasOwnedTagDecl = true;\n      *getTrailingObjects<TagDecl *>() = OwnedTagDecl;\n    }\n    assert(!(Keyword == ETK_None && NNS == nullptr) &&\n           \"ElaboratedType cannot have elaborated type keyword \"\n           \"and name qualifier both null.\");\n  }\n\npublic:\n  /// Retrieve the qualification on this type.\n  NestedNameSpecifier *getQualifier() const { return NNS; }\n\n  /// Retrieve the type named by the qualified-id.\n  QualType getNamedType() const { return NamedType; }\n\n  /// Remove a single level of sugar.\n  QualType desugar() const { return getNamedType(); }\n\n  /// Returns whether this type directly provides sugar.\n  bool isSugared() const { return true; }\n\n  /// Return the (re)declaration of this type owned by this occurrence of this\n  /// type, or nullptr if there is none.\n  TagDecl *getOwnedTagDecl() const {\n    return ElaboratedTypeBits.HasOwnedTagDecl ? *getTrailingObjects<TagDecl *>()\n                                              : nullptr;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getKeyword(), NNS, NamedType, getOwnedTagDecl());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, ElaboratedTypeKeyword Keyword,\n                      NestedNameSpecifier *NNS, QualType NamedType,\n                      TagDecl *OwnedTagDecl) {\n    ID.AddInteger(Keyword);\n    ID.AddPointer(NNS);\n    NamedType.Profile(ID);\n    ID.AddPointer(OwnedTagDecl);\n  }\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Elaborated; }\n};\n\n/// Represents a qualified type name for which the type name is\n/// dependent.\n///\n/// DependentNameType represents a class of dependent types that involve a\n/// possibly dependent nested-name-specifier (e.g., \"T::\") followed by a\n/// name of a type. The DependentNameType may start with a \"typename\" (for a\n/// typename-specifier), \"class\", \"struct\", \"union\", or \"enum\" (for a\n/// dependent elaborated-type-specifier), or nothing (in contexts where we\n/// know that we must be referring to a type, e.g., in a base class specifier).\n/// Typically the nested-name-specifier is dependent, but in MSVC compatibility\n/// mode, this type is used with non-dependent names to delay name lookup until\n/// instantiation.\nclass DependentNameType : public TypeWithKeyword, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these\n\n  /// The nested name specifier containing the qualifier.\n  NestedNameSpecifier *NNS;\n\n  /// The type that this typename specifier refers to.\n  const IdentifierInfo *Name;\n\n  DependentNameType(ElaboratedTypeKeyword Keyword, NestedNameSpecifier *NNS,\n                    const IdentifierInfo *Name, QualType CanonType)\n      : TypeWithKeyword(Keyword, DependentName, CanonType,\n                        TypeDependence::DependentInstantiation |\n                            toTypeDependence(NNS->getDependence())),\n        NNS(NNS), Name(Name) {}\n\npublic:\n  /// Retrieve the qualification on this type.\n  NestedNameSpecifier *getQualifier() const { return NNS; }\n\n  /// Retrieve the type named by the typename specifier as an identifier.\n  ///\n  /// This routine will return a non-NULL identifier pointer when the\n  /// form of the original typename was terminated by an identifier,\n  /// e.g., \"typename T::type\".\n  const IdentifierInfo *getIdentifier() const {\n    return Name;\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getKeyword(), NNS, Name);\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, ElaboratedTypeKeyword Keyword,\n                      NestedNameSpecifier *NNS, const IdentifierInfo *Name) {\n    ID.AddInteger(Keyword);\n    ID.AddPointer(NNS);\n    ID.AddPointer(Name);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DependentName;\n  }\n};\n\n/// Represents a template specialization type whose template cannot be\n/// resolved, e.g.\n///   A<T>::template B<T>\nclass alignas(8) DependentTemplateSpecializationType\n    : public TypeWithKeyword,\n      public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these\n\n  /// The nested name specifier containing the qualifier.\n  NestedNameSpecifier *NNS;\n\n  /// The identifier of the template.\n  const IdentifierInfo *Name;\n\n  DependentTemplateSpecializationType(ElaboratedTypeKeyword Keyword,\n                                      NestedNameSpecifier *NNS,\n                                      const IdentifierInfo *Name,\n                                      ArrayRef<TemplateArgument> Args,\n                                      QualType Canon);\n\n  const TemplateArgument *getArgBuffer() const {\n    return reinterpret_cast<const TemplateArgument*>(this+1);\n  }\n\n  TemplateArgument *getArgBuffer() {\n    return reinterpret_cast<TemplateArgument*>(this+1);\n  }\n\npublic:\n  NestedNameSpecifier *getQualifier() const { return NNS; }\n  const IdentifierInfo *getIdentifier() const { return Name; }\n\n  /// Retrieve the template arguments.\n  const TemplateArgument *getArgs() const {\n    return getArgBuffer();\n  }\n\n  /// Retrieve the number of template arguments.\n  unsigned getNumArgs() const {\n    return DependentTemplateSpecializationTypeBits.NumArgs;\n  }\n\n  const TemplateArgument &getArg(unsigned Idx) const; // in TemplateBase.h\n\n  ArrayRef<TemplateArgument> template_arguments() const {\n    return {getArgs(), getNumArgs()};\n  }\n\n  using iterator = const TemplateArgument *;\n\n  iterator begin() const { return getArgs(); }\n  iterator end() const; // inline in TemplateBase.h\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context) {\n    Profile(ID, Context, getKeyword(), NNS, Name, {getArgs(), getNumArgs()});\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      const ASTContext &Context,\n                      ElaboratedTypeKeyword Keyword,\n                      NestedNameSpecifier *Qualifier,\n                      const IdentifierInfo *Name,\n                      ArrayRef<TemplateArgument> Args);\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DependentTemplateSpecialization;\n  }\n};\n\n/// Represents a pack expansion of types.\n///\n/// Pack expansions are part of C++11 variadic templates. A pack\n/// expansion contains a pattern, which itself contains one or more\n/// \"unexpanded\" parameter packs. When instantiated, a pack expansion\n/// produces a series of types, each instantiated from the pattern of\n/// the expansion, where the Ith instantiation of the pattern uses the\n/// Ith arguments bound to each of the unexpanded parameter packs. The\n/// pack expansion is considered to \"expand\" these unexpanded\n/// parameter packs.\n///\n/// \\code\n/// template<typename ...Types> struct tuple;\n///\n/// template<typename ...Types>\n/// struct tuple_of_references {\n///   typedef tuple<Types&...> type;\n/// };\n/// \\endcode\n///\n/// Here, the pack expansion \\c Types&... is represented via a\n/// PackExpansionType whose pattern is Types&.\nclass PackExpansionType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these\n\n  /// The pattern of the pack expansion.\n  QualType Pattern;\n\n  PackExpansionType(QualType Pattern, QualType Canon,\n                    Optional<unsigned> NumExpansions)\n      : Type(PackExpansion, Canon,\n             (Pattern->getDependence() | TypeDependence::Dependent |\n              TypeDependence::Instantiation) &\n                 ~TypeDependence::UnexpandedPack),\n        Pattern(Pattern) {\n    PackExpansionTypeBits.NumExpansions =\n        NumExpansions ? *NumExpansions + 1 : 0;\n  }\n\npublic:\n  /// Retrieve the pattern of this pack expansion, which is the\n  /// type that will be repeatedly instantiated when instantiating the\n  /// pack expansion itself.\n  QualType getPattern() const { return Pattern; }\n\n  /// Retrieve the number of expansions that this pack expansion will\n  /// generate, if known.\n  Optional<unsigned> getNumExpansions() const {\n    if (PackExpansionTypeBits.NumExpansions)\n      return PackExpansionTypeBits.NumExpansions - 1;\n    return None;\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getPattern(), getNumExpansions());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType Pattern,\n                      Optional<unsigned> NumExpansions) {\n    ID.AddPointer(Pattern.getAsOpaquePtr());\n    ID.AddBoolean(NumExpansions.hasValue());\n    if (NumExpansions)\n      ID.AddInteger(*NumExpansions);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == PackExpansion;\n  }\n};\n\n/// This class wraps the list of protocol qualifiers. For types that can\n/// take ObjC protocol qualifers, they can subclass this class.\ntemplate <class T>\nclass ObjCProtocolQualifiers {\nprotected:\n  ObjCProtocolQualifiers() = default;\n\n  ObjCProtocolDecl * const *getProtocolStorage() const {\n    return const_cast<ObjCProtocolQualifiers*>(this)->getProtocolStorage();\n  }\n\n  ObjCProtocolDecl **getProtocolStorage() {\n    return static_cast<T*>(this)->getProtocolStorageImpl();\n  }\n\n  void setNumProtocols(unsigned N) {\n    static_cast<T*>(this)->setNumProtocolsImpl(N);\n  }\n\n  void initialize(ArrayRef<ObjCProtocolDecl *> protocols) {\n    setNumProtocols(protocols.size());\n    assert(getNumProtocols() == protocols.size() &&\n           \"bitfield overflow in protocol count\");\n    if (!protocols.empty())\n      memcpy(getProtocolStorage(), protocols.data(),\n             protocols.size() * sizeof(ObjCProtocolDecl*));\n  }\n\npublic:\n  using qual_iterator = ObjCProtocolDecl * const *;\n  using qual_range = llvm::iterator_range<qual_iterator>;\n\n  qual_range quals() const { return qual_range(qual_begin(), qual_end()); }\n  qual_iterator qual_begin() const { return getProtocolStorage(); }\n  qual_iterator qual_end() const { return qual_begin() + getNumProtocols(); }\n\n  bool qual_empty() const { return getNumProtocols() == 0; }\n\n  /// Return the number of qualifying protocols in this type, or 0 if\n  /// there are none.\n  unsigned getNumProtocols() const {\n    return static_cast<const T*>(this)->getNumProtocolsImpl();\n  }\n\n  /// Fetch a protocol by index.\n  ObjCProtocolDecl *getProtocol(unsigned I) const {\n    assert(I < getNumProtocols() && \"Out-of-range protocol access\");\n    return qual_begin()[I];\n  }\n\n  /// Retrieve all of the protocol qualifiers.\n  ArrayRef<ObjCProtocolDecl *> getProtocols() const {\n    return ArrayRef<ObjCProtocolDecl *>(qual_begin(), getNumProtocols());\n  }\n};\n\n/// Represents a type parameter type in Objective C. It can take\n/// a list of protocols.\nclass ObjCTypeParamType : public Type,\n                          public ObjCProtocolQualifiers<ObjCTypeParamType>,\n                          public llvm::FoldingSetNode {\n  friend class ASTContext;\n  friend class ObjCProtocolQualifiers<ObjCTypeParamType>;\n\n  /// The number of protocols stored on this type.\n  unsigned NumProtocols : 6;\n\n  ObjCTypeParamDecl *OTPDecl;\n\n  /// The protocols are stored after the ObjCTypeParamType node. In the\n  /// canonical type, the list of protocols are sorted alphabetically\n  /// and uniqued.\n  ObjCProtocolDecl **getProtocolStorageImpl();\n\n  /// Return the number of qualifying protocols in this interface type,\n  /// or 0 if there are none.\n  unsigned getNumProtocolsImpl() const {\n    return NumProtocols;\n  }\n\n  void setNumProtocolsImpl(unsigned N) {\n    NumProtocols = N;\n  }\n\n  ObjCTypeParamType(const ObjCTypeParamDecl *D,\n                    QualType can,\n                    ArrayRef<ObjCProtocolDecl *> protocols);\n\npublic:\n  bool isSugared() const { return true; }\n  QualType desugar() const { return getCanonicalTypeInternal(); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ObjCTypeParam;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID);\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      const ObjCTypeParamDecl *OTPDecl,\n                      QualType CanonicalType,\n                      ArrayRef<ObjCProtocolDecl *> protocols);\n\n  ObjCTypeParamDecl *getDecl() const { return OTPDecl; }\n};\n\n/// Represents a class type in Objective C.\n///\n/// Every Objective C type is a combination of a base type, a set of\n/// type arguments (optional, for parameterized classes) and a list of\n/// protocols.\n///\n/// Given the following declarations:\n/// \\code\n///   \\@class C<T>;\n///   \\@protocol P;\n/// \\endcode\n///\n/// 'C' is an ObjCInterfaceType C.  It is sugar for an ObjCObjectType\n/// with base C and no protocols.\n///\n/// 'C<P>' is an unspecialized ObjCObjectType with base C and protocol list [P].\n/// 'C<C*>' is a specialized ObjCObjectType with type arguments 'C*' and no\n/// protocol list.\n/// 'C<C*><P>' is a specialized ObjCObjectType with base C, type arguments 'C*',\n/// and protocol list [P].\n///\n/// 'id' is a TypedefType which is sugar for an ObjCObjectPointerType whose\n/// pointee is an ObjCObjectType with base BuiltinType::ObjCIdType\n/// and no protocols.\n///\n/// 'id<P>' is an ObjCObjectPointerType whose pointee is an ObjCObjectType\n/// with base BuiltinType::ObjCIdType and protocol list [P].  Eventually\n/// this should get its own sugar class to better represent the source.\nclass ObjCObjectType : public Type,\n                       public ObjCProtocolQualifiers<ObjCObjectType> {\n  friend class ObjCProtocolQualifiers<ObjCObjectType>;\n\n  // ObjCObjectType.NumTypeArgs - the number of type arguments stored\n  // after the ObjCObjectPointerType node.\n  // ObjCObjectType.NumProtocols - the number of protocols stored\n  // after the type arguments of ObjCObjectPointerType node.\n  //\n  // These protocols are those written directly on the type.  If\n  // protocol qualifiers ever become additive, the iterators will need\n  // to get kindof complicated.\n  //\n  // In the canonical object type, these are sorted alphabetically\n  // and uniqued.\n\n  /// Either a BuiltinType or an InterfaceType or sugar for either.\n  QualType BaseType;\n\n  /// Cached superclass type.\n  mutable llvm::PointerIntPair<const ObjCObjectType *, 1, bool>\n    CachedSuperClassType;\n\n  QualType *getTypeArgStorage();\n  const QualType *getTypeArgStorage() const {\n    return const_cast<ObjCObjectType *>(this)->getTypeArgStorage();\n  }\n\n  ObjCProtocolDecl **getProtocolStorageImpl();\n  /// Return the number of qualifying protocols in this interface type,\n  /// or 0 if there are none.\n  unsigned getNumProtocolsImpl() const {\n    return ObjCObjectTypeBits.NumProtocols;\n  }\n  void setNumProtocolsImpl(unsigned N) {\n    ObjCObjectTypeBits.NumProtocols = N;\n  }\n\nprotected:\n  enum Nonce_ObjCInterface { Nonce_ObjCInterface };\n\n  ObjCObjectType(QualType Canonical, QualType Base,\n                 ArrayRef<QualType> typeArgs,\n                 ArrayRef<ObjCProtocolDecl *> protocols,\n                 bool isKindOf);\n\n  ObjCObjectType(enum Nonce_ObjCInterface)\n      : Type(ObjCInterface, QualType(), TypeDependence::None),\n        BaseType(QualType(this_(), 0)) {\n    ObjCObjectTypeBits.NumProtocols = 0;\n    ObjCObjectTypeBits.NumTypeArgs = 0;\n    ObjCObjectTypeBits.IsKindOf = 0;\n  }\n\n  void computeSuperClassTypeSlow() const;\n\npublic:\n  /// Gets the base type of this object type.  This is always (possibly\n  /// sugar for) one of:\n  ///  - the 'id' builtin type (as opposed to the 'id' type visible to the\n  ///    user, which is a typedef for an ObjCObjectPointerType)\n  ///  - the 'Class' builtin type (same caveat)\n  ///  - an ObjCObjectType (currently always an ObjCInterfaceType)\n  QualType getBaseType() const { return BaseType; }\n\n  bool isObjCId() const {\n    return getBaseType()->isSpecificBuiltinType(BuiltinType::ObjCId);\n  }\n\n  bool isObjCClass() const {\n    return getBaseType()->isSpecificBuiltinType(BuiltinType::ObjCClass);\n  }\n\n  bool isObjCUnqualifiedId() const { return qual_empty() && isObjCId(); }\n  bool isObjCUnqualifiedClass() const { return qual_empty() && isObjCClass(); }\n  bool isObjCUnqualifiedIdOrClass() const {\n    if (!qual_empty()) return false;\n    if (const BuiltinType *T = getBaseType()->getAs<BuiltinType>())\n      return T->getKind() == BuiltinType::ObjCId ||\n             T->getKind() == BuiltinType::ObjCClass;\n    return false;\n  }\n  bool isObjCQualifiedId() const { return !qual_empty() && isObjCId(); }\n  bool isObjCQualifiedClass() const { return !qual_empty() && isObjCClass(); }\n\n  /// Gets the interface declaration for this object type, if the base type\n  /// really is an interface.\n  ObjCInterfaceDecl *getInterface() const;\n\n  /// Determine whether this object type is \"specialized\", meaning\n  /// that it has type arguments.\n  bool isSpecialized() const;\n\n  /// Determine whether this object type was written with type arguments.\n  bool isSpecializedAsWritten() const {\n    return ObjCObjectTypeBits.NumTypeArgs > 0;\n  }\n\n  /// Determine whether this object type is \"unspecialized\", meaning\n  /// that it has no type arguments.\n  bool isUnspecialized() const { return !isSpecialized(); }\n\n  /// Determine whether this object type is \"unspecialized\" as\n  /// written, meaning that it has no type arguments.\n  bool isUnspecializedAsWritten() const { return !isSpecializedAsWritten(); }\n\n  /// Retrieve the type arguments of this object type (semantically).\n  ArrayRef<QualType> getTypeArgs() const;\n\n  /// Retrieve the type arguments of this object type as they were\n  /// written.\n  ArrayRef<QualType> getTypeArgsAsWritten() const {\n    return llvm::makeArrayRef(getTypeArgStorage(),\n                              ObjCObjectTypeBits.NumTypeArgs);\n  }\n\n  /// Whether this is a \"__kindof\" type as written.\n  bool isKindOfTypeAsWritten() const { return ObjCObjectTypeBits.IsKindOf; }\n\n  /// Whether this ia a \"__kindof\" type (semantically).\n  bool isKindOfType() const;\n\n  /// Retrieve the type of the superclass of this object type.\n  ///\n  /// This operation substitutes any type arguments into the\n  /// superclass of the current class type, potentially producing a\n  /// specialization of the superclass type. Produces a null type if\n  /// there is no superclass.\n  QualType getSuperClassType() const {\n    if (!CachedSuperClassType.getInt())\n      computeSuperClassTypeSlow();\n\n    assert(CachedSuperClassType.getInt() && \"Superclass not set?\");\n    return QualType(CachedSuperClassType.getPointer(), 0);\n  }\n\n  /// Strip off the Objective-C \"kindof\" type and (with it) any\n  /// protocol qualifiers.\n  QualType stripObjCKindOfTypeAndQuals(const ASTContext &ctx) const;\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ObjCObject ||\n           T->getTypeClass() == ObjCInterface;\n  }\n};\n\n/// A class providing a concrete implementation\n/// of ObjCObjectType, so as to not increase the footprint of\n/// ObjCInterfaceType.  Code outside of ASTContext and the core type\n/// system should not reference this type.\nclass ObjCObjectTypeImpl : public ObjCObjectType, public llvm::FoldingSetNode {\n  friend class ASTContext;\n\n  // If anyone adds fields here, ObjCObjectType::getProtocolStorage()\n  // will need to be modified.\n\n  ObjCObjectTypeImpl(QualType Canonical, QualType Base,\n                     ArrayRef<QualType> typeArgs,\n                     ArrayRef<ObjCProtocolDecl *> protocols,\n                     bool isKindOf)\n      : ObjCObjectType(Canonical, Base, typeArgs, protocols, isKindOf) {}\n\npublic:\n  void Profile(llvm::FoldingSetNodeID &ID);\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      QualType Base,\n                      ArrayRef<QualType> typeArgs,\n                      ArrayRef<ObjCProtocolDecl *> protocols,\n                      bool isKindOf);\n};\n\ninline QualType *ObjCObjectType::getTypeArgStorage() {\n  return reinterpret_cast<QualType *>(static_cast<ObjCObjectTypeImpl*>(this)+1);\n}\n\ninline ObjCProtocolDecl **ObjCObjectType::getProtocolStorageImpl() {\n    return reinterpret_cast<ObjCProtocolDecl**>(\n             getTypeArgStorage() + ObjCObjectTypeBits.NumTypeArgs);\n}\n\ninline ObjCProtocolDecl **ObjCTypeParamType::getProtocolStorageImpl() {\n    return reinterpret_cast<ObjCProtocolDecl**>(\n             static_cast<ObjCTypeParamType*>(this)+1);\n}\n\n/// Interfaces are the core concept in Objective-C for object oriented design.\n/// They basically correspond to C++ classes.  There are two kinds of interface\n/// types: normal interfaces like `NSString`, and qualified interfaces, which\n/// are qualified with a protocol list like `NSString<NSCopyable, NSAmazing>`.\n///\n/// ObjCInterfaceType guarantees the following properties when considered\n/// as a subtype of its superclass, ObjCObjectType:\n///   - There are no protocol qualifiers.  To reinforce this, code which\n///     tries to invoke the protocol methods via an ObjCInterfaceType will\n///     fail to compile.\n///   - It is its own base type.  That is, if T is an ObjCInterfaceType*,\n///     T->getBaseType() == QualType(T, 0).\nclass ObjCInterfaceType : public ObjCObjectType {\n  friend class ASTContext; // ASTContext creates these.\n  friend class ASTReader;\n  friend class ObjCInterfaceDecl;\n  template <class T> friend class serialization::AbstractTypeReader;\n\n  mutable ObjCInterfaceDecl *Decl;\n\n  ObjCInterfaceType(const ObjCInterfaceDecl *D)\n      : ObjCObjectType(Nonce_ObjCInterface),\n        Decl(const_cast<ObjCInterfaceDecl*>(D)) {}\n\npublic:\n  /// Get the declaration of this interface.\n  ObjCInterfaceDecl *getDecl() const { return Decl; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ObjCInterface;\n  }\n\n  // Nonsense to \"hide\" certain members of ObjCObjectType within this\n  // class.  People asking for protocols on an ObjCInterfaceType are\n  // not going to get what they want: ObjCInterfaceTypes are\n  // guaranteed to have no protocols.\n  enum {\n    qual_iterator,\n    qual_begin,\n    qual_end,\n    getNumProtocols,\n    getProtocol\n  };\n};\n\ninline ObjCInterfaceDecl *ObjCObjectType::getInterface() const {\n  QualType baseType = getBaseType();\n  while (const auto *ObjT = baseType->getAs<ObjCObjectType>()) {\n    if (const auto *T = dyn_cast<ObjCInterfaceType>(ObjT))\n      return T->getDecl();\n\n    baseType = ObjT->getBaseType();\n  }\n\n  return nullptr;\n}\n\n/// Represents a pointer to an Objective C object.\n///\n/// These are constructed from pointer declarators when the pointee type is\n/// an ObjCObjectType (or sugar for one).  In addition, the 'id' and 'Class'\n/// types are typedefs for these, and the protocol-qualified types 'id<P>'\n/// and 'Class<P>' are translated into these.\n///\n/// Pointers to pointers to Objective C objects are still PointerTypes;\n/// only the first level of pointer gets it own type implementation.\nclass ObjCObjectPointerType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these.\n\n  QualType PointeeType;\n\n  ObjCObjectPointerType(QualType Canonical, QualType Pointee)\n      : Type(ObjCObjectPointer, Canonical, Pointee->getDependence()),\n        PointeeType(Pointee) {}\n\npublic:\n  /// Gets the type pointed to by this ObjC pointer.\n  /// The result will always be an ObjCObjectType or sugar thereof.\n  QualType getPointeeType() const { return PointeeType; }\n\n  /// Gets the type pointed to by this ObjC pointer.  Always returns non-null.\n  ///\n  /// This method is equivalent to getPointeeType() except that\n  /// it discards any typedefs (or other sugar) between this\n  /// type and the \"outermost\" object type.  So for:\n  /// \\code\n  ///   \\@class A; \\@protocol P; \\@protocol Q;\n  ///   typedef A<P> AP;\n  ///   typedef A A1;\n  ///   typedef A1<P> A1P;\n  ///   typedef A1P<Q> A1PQ;\n  /// \\endcode\n  /// For 'A*', getObjectType() will return 'A'.\n  /// For 'A<P>*', getObjectType() will return 'A<P>'.\n  /// For 'AP*', getObjectType() will return 'A<P>'.\n  /// For 'A1*', getObjectType() will return 'A'.\n  /// For 'A1<P>*', getObjectType() will return 'A1<P>'.\n  /// For 'A1P*', getObjectType() will return 'A1<P>'.\n  /// For 'A1PQ*', getObjectType() will return 'A1<Q>', because\n  ///   adding protocols to a protocol-qualified base discards the\n  ///   old qualifiers (for now).  But if it didn't, getObjectType()\n  ///   would return 'A1P<Q>' (and we'd have to make iterating over\n  ///   qualifiers more complicated).\n  const ObjCObjectType *getObjectType() const {\n    return PointeeType->castAs<ObjCObjectType>();\n  }\n\n  /// If this pointer points to an Objective C\n  /// \\@interface type, gets the type for that interface.  Any protocol\n  /// qualifiers on the interface are ignored.\n  ///\n  /// \\return null if the base type for this pointer is 'id' or 'Class'\n  const ObjCInterfaceType *getInterfaceType() const;\n\n  /// If this pointer points to an Objective \\@interface\n  /// type, gets the declaration for that interface.\n  ///\n  /// \\return null if the base type for this pointer is 'id' or 'Class'\n  ObjCInterfaceDecl *getInterfaceDecl() const {\n    return getObjectType()->getInterface();\n  }\n\n  /// True if this is equivalent to the 'id' type, i.e. if\n  /// its object type is the primitive 'id' type with no protocols.\n  bool isObjCIdType() const {\n    return getObjectType()->isObjCUnqualifiedId();\n  }\n\n  /// True if this is equivalent to the 'Class' type,\n  /// i.e. if its object tive is the primitive 'Class' type with no protocols.\n  bool isObjCClassType() const {\n    return getObjectType()->isObjCUnqualifiedClass();\n  }\n\n  /// True if this is equivalent to the 'id' or 'Class' type,\n  bool isObjCIdOrClassType() const {\n    return getObjectType()->isObjCUnqualifiedIdOrClass();\n  }\n\n  /// True if this is equivalent to 'id<P>' for some non-empty set of\n  /// protocols.\n  bool isObjCQualifiedIdType() const {\n    return getObjectType()->isObjCQualifiedId();\n  }\n\n  /// True if this is equivalent to 'Class<P>' for some non-empty set of\n  /// protocols.\n  bool isObjCQualifiedClassType() const {\n    return getObjectType()->isObjCQualifiedClass();\n  }\n\n  /// Whether this is a \"__kindof\" type.\n  bool isKindOfType() const { return getObjectType()->isKindOfType(); }\n\n  /// Whether this type is specialized, meaning that it has type arguments.\n  bool isSpecialized() const { return getObjectType()->isSpecialized(); }\n\n  /// Whether this type is specialized, meaning that it has type arguments.\n  bool isSpecializedAsWritten() const {\n    return getObjectType()->isSpecializedAsWritten();\n  }\n\n  /// Whether this type is unspecialized, meaning that is has no type arguments.\n  bool isUnspecialized() const { return getObjectType()->isUnspecialized(); }\n\n  /// Determine whether this object type is \"unspecialized\" as\n  /// written, meaning that it has no type arguments.\n  bool isUnspecializedAsWritten() const { return !isSpecializedAsWritten(); }\n\n  /// Retrieve the type arguments for this type.\n  ArrayRef<QualType> getTypeArgs() const {\n    return getObjectType()->getTypeArgs();\n  }\n\n  /// Retrieve the type arguments for this type.\n  ArrayRef<QualType> getTypeArgsAsWritten() const {\n    return getObjectType()->getTypeArgsAsWritten();\n  }\n\n  /// An iterator over the qualifiers on the object type.  Provided\n  /// for convenience.  This will always iterate over the full set of\n  /// protocols on a type, not just those provided directly.\n  using qual_iterator = ObjCObjectType::qual_iterator;\n  using qual_range = llvm::iterator_range<qual_iterator>;\n\n  qual_range quals() const { return qual_range(qual_begin(), qual_end()); }\n\n  qual_iterator qual_begin() const {\n    return getObjectType()->qual_begin();\n  }\n\n  qual_iterator qual_end() const {\n    return getObjectType()->qual_end();\n  }\n\n  bool qual_empty() const { return getObjectType()->qual_empty(); }\n\n  /// Return the number of qualifying protocols on the object type.\n  unsigned getNumProtocols() const {\n    return getObjectType()->getNumProtocols();\n  }\n\n  /// Retrieve a qualifying protocol by index on the object type.\n  ObjCProtocolDecl *getProtocol(unsigned I) const {\n    return getObjectType()->getProtocol(I);\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  /// Retrieve the type of the superclass of this object pointer type.\n  ///\n  /// This operation substitutes any type arguments into the\n  /// superclass of the current class type, potentially producing a\n  /// pointer to a specialization of the superclass type. Produces a\n  /// null type if there is no superclass.\n  QualType getSuperClassType() const;\n\n  /// Strip off the Objective-C \"kindof\" type and (with it) any\n  /// protocol qualifiers.\n  const ObjCObjectPointerType *stripObjCKindOfTypeAndQuals(\n                                 const ASTContext &ctx) const;\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getPointeeType());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType T) {\n    ID.AddPointer(T.getAsOpaquePtr());\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ObjCObjectPointer;\n  }\n};\n\nclass AtomicType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these.\n\n  QualType ValueType;\n\n  AtomicType(QualType ValTy, QualType Canonical)\n      : Type(Atomic, Canonical, ValTy->getDependence()), ValueType(ValTy) {}\n\npublic:\n  /// Gets the type contained by this atomic type, i.e.\n  /// the type returned by performing an atomic load of this atomic type.\n  QualType getValueType() const { return ValueType; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getValueType());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType T) {\n    ID.AddPointer(T.getAsOpaquePtr());\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == Atomic;\n  }\n};\n\n/// PipeType - OpenCL20.\nclass PipeType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these.\n\n  QualType ElementType;\n  bool isRead;\n\n  PipeType(QualType elemType, QualType CanonicalPtr, bool isRead)\n      : Type(Pipe, CanonicalPtr, elemType->getDependence()),\n        ElementType(elemType), isRead(isRead) {}\n\npublic:\n  QualType getElementType() const { return ElementType; }\n\n  bool isSugared() const { return false; }\n\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getElementType(), isReadOnly());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType T, bool isRead) {\n    ID.AddPointer(T.getAsOpaquePtr());\n    ID.AddBoolean(isRead);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == Pipe;\n  }\n\n  bool isReadOnly() const { return isRead; }\n};\n\n/// A fixed int type of a specified bitwidth.\nclass ExtIntType final : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext;\n  unsigned IsUnsigned : 1;\n  unsigned NumBits : 24;\n\nprotected:\n  ExtIntType(bool isUnsigned, unsigned NumBits);\n\npublic:\n  bool isUnsigned() const { return IsUnsigned; }\n  bool isSigned() const { return !IsUnsigned; }\n  unsigned getNumBits() const { return NumBits; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, isUnsigned(), getNumBits());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, bool IsUnsigned,\n                      unsigned NumBits) {\n    ID.AddBoolean(IsUnsigned);\n    ID.AddInteger(NumBits);\n  }\n\n  static bool classof(const Type *T) { return T->getTypeClass() == ExtInt; }\n};\n\nclass DependentExtIntType final : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext;\n  const ASTContext &Context;\n  llvm::PointerIntPair<Expr*, 1, bool> ExprAndUnsigned;\n\nprotected:\n  DependentExtIntType(const ASTContext &Context, bool IsUnsigned,\n                      Expr *NumBits);\n\npublic:\n  bool isUnsigned() const;\n  bool isSigned() const { return !isUnsigned(); }\n  Expr *getNumBitsExpr() const;\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Context, isUnsigned(), getNumBitsExpr());\n  }\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      bool IsUnsigned, Expr *NumBitsExpr);\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DependentExtInt;\n  }\n};\n\n/// A qualifier set is used to build a set of qualifiers.\nclass QualifierCollector : public Qualifiers {\npublic:\n  QualifierCollector(Qualifiers Qs = Qualifiers()) : Qualifiers(Qs) {}\n\n  /// Collect any qualifiers on the given type and return an\n  /// unqualified type.  The qualifiers are assumed to be consistent\n  /// with those already in the type.\n  const Type *strip(QualType type) {\n    addFastQualifiers(type.getLocalFastQualifiers());\n    if (!type.hasLocalNonFastQualifiers())\n      return type.getTypePtrUnsafe();\n\n    const ExtQuals *extQuals = type.getExtQualsUnsafe();\n    addConsistentQualifiers(extQuals->getQualifiers());\n    return extQuals->getBaseType();\n  }\n\n  /// Apply the collected qualifiers to the given type.\n  QualType apply(const ASTContext &Context, QualType QT) const;\n\n  /// Apply the collected qualifiers to the given type.\n  QualType apply(const ASTContext &Context, const Type* T) const;\n};\n\n/// A container of type source information.\n///\n/// A client can read the relevant info using TypeLoc wrappers, e.g:\n/// @code\n/// TypeLoc TL = TypeSourceInfo->getTypeLoc();\n/// TL.getBeginLoc().print(OS, SrcMgr);\n/// @endcode\nclass alignas(8) TypeSourceInfo {\n  // Contains a memory block after the class, used for type source information,\n  // allocated by ASTContext.\n  friend class ASTContext;\n\n  QualType Ty;\n\n  TypeSourceInfo(QualType ty) : Ty(ty) {}\n\npublic:\n  /// Return the type wrapped by this type source info.\n  QualType getType() const { return Ty; }\n\n  /// Return the TypeLoc wrapper for the type source info.\n  TypeLoc getTypeLoc() const; // implemented in TypeLoc.h\n\n  /// Override the type stored in this TypeSourceInfo. Use with caution!\n  void overrideType(QualType T) { Ty = T; }\n};\n\n// Inline function definitions.\n\ninline SplitQualType SplitQualType::getSingleStepDesugaredType() const {\n  SplitQualType desugar =\n    Ty->getLocallyUnqualifiedSingleStepDesugaredType().split();\n  desugar.Quals.addConsistentQualifiers(Quals);\n  return desugar;\n}\n\ninline const Type *QualType::getTypePtr() const {\n  return getCommonPtr()->BaseType;\n}\n\ninline const Type *QualType::getTypePtrOrNull() const {\n  return (isNull() ? nullptr : getCommonPtr()->BaseType);\n}\n\ninline SplitQualType QualType::split() const {\n  if (!hasLocalNonFastQualifiers())\n    return SplitQualType(getTypePtrUnsafe(),\n                         Qualifiers::fromFastMask(getLocalFastQualifiers()));\n\n  const ExtQuals *eq = getExtQualsUnsafe();\n  Qualifiers qs = eq->getQualifiers();\n  qs.addFastQualifiers(getLocalFastQualifiers());\n  return SplitQualType(eq->getBaseType(), qs);\n}\n\ninline Qualifiers QualType::getLocalQualifiers() const {\n  Qualifiers Quals;\n  if (hasLocalNonFastQualifiers())\n    Quals = getExtQualsUnsafe()->getQualifiers();\n  Quals.addFastQualifiers(getLocalFastQualifiers());\n  return Quals;\n}\n\ninline Qualifiers QualType::getQualifiers() const {\n  Qualifiers quals = getCommonPtr()->CanonicalType.getLocalQualifiers();\n  quals.addFastQualifiers(getLocalFastQualifiers());\n  return quals;\n}\n\ninline unsigned QualType::getCVRQualifiers() const {\n  unsigned cvr = getCommonPtr()->CanonicalType.getLocalCVRQualifiers();\n  cvr |= getLocalCVRQualifiers();\n  return cvr;\n}\n\ninline QualType QualType::getCanonicalType() const {\n  QualType canon = getCommonPtr()->CanonicalType;\n  return canon.withFastQualifiers(getLocalFastQualifiers());\n}\n\ninline bool QualType::isCanonical() const {\n  return getTypePtr()->isCanonicalUnqualified();\n}\n\ninline bool QualType::isCanonicalAsParam() const {\n  if (!isCanonical()) return false;\n  if (hasLocalQualifiers()) return false;\n\n  const Type *T = getTypePtr();\n  if (T->isVariablyModifiedType() && T->hasSizedVLAType())\n    return false;\n\n  return !isa<FunctionType>(T) && !isa<ArrayType>(T);\n}\n\ninline bool QualType::isConstQualified() const {\n  return isLocalConstQualified() ||\n         getCommonPtr()->CanonicalType.isLocalConstQualified();\n}\n\ninline bool QualType::isRestrictQualified() const {\n  return isLocalRestrictQualified() ||\n         getCommonPtr()->CanonicalType.isLocalRestrictQualified();\n}\n\n\ninline bool QualType::isVolatileQualified() const {\n  return isLocalVolatileQualified() ||\n         getCommonPtr()->CanonicalType.isLocalVolatileQualified();\n}\n\ninline bool QualType::hasQualifiers() const {\n  return hasLocalQualifiers() ||\n         getCommonPtr()->CanonicalType.hasLocalQualifiers();\n}\n\ninline QualType QualType::getUnqualifiedType() const {\n  if (!getTypePtr()->getCanonicalTypeInternal().hasLocalQualifiers())\n    return QualType(getTypePtr(), 0);\n\n  return QualType(getSplitUnqualifiedTypeImpl(*this).Ty, 0);\n}\n\ninline SplitQualType QualType::getSplitUnqualifiedType() const {\n  if (!getTypePtr()->getCanonicalTypeInternal().hasLocalQualifiers())\n    return split();\n\n  return getSplitUnqualifiedTypeImpl(*this);\n}\n\ninline void QualType::removeLocalConst() {\n  removeLocalFastQualifiers(Qualifiers::Const);\n}\n\ninline void QualType::removeLocalRestrict() {\n  removeLocalFastQualifiers(Qualifiers::Restrict);\n}\n\ninline void QualType::removeLocalVolatile() {\n  removeLocalFastQualifiers(Qualifiers::Volatile);\n}\n\ninline void QualType::removeLocalCVRQualifiers(unsigned Mask) {\n  assert(!(Mask & ~Qualifiers::CVRMask) && \"mask has non-CVR bits\");\n  static_assert((int)Qualifiers::CVRMask == (int)Qualifiers::FastMask,\n                \"Fast bits differ from CVR bits!\");\n\n  // Fast path: we don't need to touch the slow qualifiers.\n  removeLocalFastQualifiers(Mask);\n}\n\n/// Check if this type has any address space qualifier.\ninline bool QualType::hasAddressSpace() const {\n  return getQualifiers().hasAddressSpace();\n}\n\n/// Return the address space of this type.\ninline LangAS QualType::getAddressSpace() const {\n  return getQualifiers().getAddressSpace();\n}\n\n/// Return the gc attribute of this type.\ninline Qualifiers::GC QualType::getObjCGCAttr() const {\n  return getQualifiers().getObjCGCAttr();\n}\n\ninline bool QualType::hasNonTrivialToPrimitiveDefaultInitializeCUnion() const {\n  if (auto *RD = getTypePtr()->getBaseElementTypeUnsafe()->getAsRecordDecl())\n    return hasNonTrivialToPrimitiveDefaultInitializeCUnion(RD);\n  return false;\n}\n\ninline bool QualType::hasNonTrivialToPrimitiveDestructCUnion() const {\n  if (auto *RD = getTypePtr()->getBaseElementTypeUnsafe()->getAsRecordDecl())\n    return hasNonTrivialToPrimitiveDestructCUnion(RD);\n  return false;\n}\n\ninline bool QualType::hasNonTrivialToPrimitiveCopyCUnion() const {\n  if (auto *RD = getTypePtr()->getBaseElementTypeUnsafe()->getAsRecordDecl())\n    return hasNonTrivialToPrimitiveCopyCUnion(RD);\n  return false;\n}\n\ninline FunctionType::ExtInfo getFunctionExtInfo(const Type &t) {\n  if (const auto *PT = t.getAs<PointerType>()) {\n    if (const auto *FT = PT->getPointeeType()->getAs<FunctionType>())\n      return FT->getExtInfo();\n  } else if (const auto *FT = t.getAs<FunctionType>())\n    return FT->getExtInfo();\n\n  return FunctionType::ExtInfo();\n}\n\ninline FunctionType::ExtInfo getFunctionExtInfo(QualType t) {\n  return getFunctionExtInfo(*t);\n}\n\n/// Determine whether this type is more\n/// qualified than the Other type. For example, \"const volatile int\"\n/// is more qualified than \"const int\", \"volatile int\", and\n/// \"int\". However, it is not more qualified than \"const volatile\n/// int\".\ninline bool QualType::isMoreQualifiedThan(QualType other) const {\n  Qualifiers MyQuals = getQualifiers();\n  Qualifiers OtherQuals = other.getQualifiers();\n  return (MyQuals != OtherQuals && MyQuals.compatiblyIncludes(OtherQuals));\n}\n\n/// Determine whether this type is at last\n/// as qualified as the Other type. For example, \"const volatile\n/// int\" is at least as qualified as \"const int\", \"volatile int\",\n/// \"int\", and \"const volatile int\".\ninline bool QualType::isAtLeastAsQualifiedAs(QualType other) const {\n  Qualifiers OtherQuals = other.getQualifiers();\n\n  // Ignore __unaligned qualifier if this type is a void.\n  if (getUnqualifiedType()->isVoidType())\n    OtherQuals.removeUnaligned();\n\n  return getQualifiers().compatiblyIncludes(OtherQuals);\n}\n\n/// If Type is a reference type (e.g., const\n/// int&), returns the type that the reference refers to (\"const\n/// int\"). Otherwise, returns the type itself. This routine is used\n/// throughout Sema to implement C++ 5p6:\n///\n///   If an expression initially has the type \"reference to T\" (8.3.2,\n///   8.5.3), the type is adjusted to \"T\" prior to any further\n///   analysis, the expression designates the object or function\n///   denoted by the reference, and the expression is an lvalue.\ninline QualType QualType::getNonReferenceType() const {\n  if (const auto *RefType = (*this)->getAs<ReferenceType>())\n    return RefType->getPointeeType();\n  else\n    return *this;\n}\n\ninline bool QualType::isCForbiddenLValueType() const {\n  return ((getTypePtr()->isVoidType() && !hasQualifiers()) ||\n          getTypePtr()->isFunctionType());\n}\n\n/// Tests whether the type is categorized as a fundamental type.\n///\n/// \\returns True for types specified in C++0x [basic.fundamental].\ninline bool Type::isFundamentalType() const {\n  return isVoidType() ||\n         isNullPtrType() ||\n         // FIXME: It's really annoying that we don't have an\n         // 'isArithmeticType()' which agrees with the standard definition.\n         (isArithmeticType() && !isEnumeralType());\n}\n\n/// Tests whether the type is categorized as a compound type.\n///\n/// \\returns True for types specified in C++0x [basic.compound].\ninline bool Type::isCompoundType() const {\n  // C++0x [basic.compound]p1:\n  //   Compound types can be constructed in the following ways:\n  //    -- arrays of objects of a given type [...];\n  return isArrayType() ||\n  //    -- functions, which have parameters of given types [...];\n         isFunctionType() ||\n  //    -- pointers to void or objects or functions [...];\n         isPointerType() ||\n  //    -- references to objects or functions of a given type. [...]\n         isReferenceType() ||\n  //    -- classes containing a sequence of objects of various types, [...];\n         isRecordType() ||\n  //    -- unions, which are classes capable of containing objects of different\n  //               types at different times;\n         isUnionType() ||\n  //    -- enumerations, which comprise a set of named constant values. [...];\n         isEnumeralType() ||\n  //    -- pointers to non-static class members, [...].\n         isMemberPointerType();\n}\n\ninline bool Type::isFunctionType() const {\n  return isa<FunctionType>(CanonicalType);\n}\n\ninline bool Type::isPointerType() const {\n  return isa<PointerType>(CanonicalType);\n}\n\ninline bool Type::isAnyPointerType() const {\n  return isPointerType() || isObjCObjectPointerType();\n}\n\ninline bool Type::isBlockPointerType() const {\n  return isa<BlockPointerType>(CanonicalType);\n}\n\ninline bool Type::isReferenceType() const {\n  return isa<ReferenceType>(CanonicalType);\n}\n\ninline bool Type::isLValueReferenceType() const {\n  return isa<LValueReferenceType>(CanonicalType);\n}\n\ninline bool Type::isRValueReferenceType() const {\n  return isa<RValueReferenceType>(CanonicalType);\n}\n\ninline bool Type::isObjectPointerType() const {\n  // Note: an \"object pointer type\" is not the same thing as a pointer to an\n  // object type; rather, it is a pointer to an object type or a pointer to cv\n  // void.\n  if (const auto *T = getAs<PointerType>())\n    return !T->getPointeeType()->isFunctionType();\n  else\n    return false;\n}\n\ninline bool Type::isFunctionPointerType() const {\n  if (const auto *T = getAs<PointerType>())\n    return T->getPointeeType()->isFunctionType();\n  else\n    return false;\n}\n\ninline bool Type::isFunctionReferenceType() const {\n  if (const auto *T = getAs<ReferenceType>())\n    return T->getPointeeType()->isFunctionType();\n  else\n    return false;\n}\n\ninline bool Type::isMemberPointerType() const {\n  return isa<MemberPointerType>(CanonicalType);\n}\n\ninline bool Type::isMemberFunctionPointerType() const {\n  if (const auto *T = getAs<MemberPointerType>())\n    return T->isMemberFunctionPointer();\n  else\n    return false;\n}\n\ninline bool Type::isMemberDataPointerType() const {\n  if (const auto *T = getAs<MemberPointerType>())\n    return T->isMemberDataPointer();\n  else\n    return false;\n}\n\ninline bool Type::isArrayType() const {\n  return isa<ArrayType>(CanonicalType);\n}\n\ninline bool Type::isConstantArrayType() const {\n  return isa<ConstantArrayType>(CanonicalType);\n}\n\ninline bool Type::isIncompleteArrayType() const {\n  return isa<IncompleteArrayType>(CanonicalType);\n}\n\ninline bool Type::isVariableArrayType() const {\n  return isa<VariableArrayType>(CanonicalType);\n}\n\ninline bool Type::isDependentSizedArrayType() const {\n  return isa<DependentSizedArrayType>(CanonicalType);\n}\n\ninline bool Type::isBuiltinType() const {\n  return isa<BuiltinType>(CanonicalType);\n}\n\ninline bool Type::isRecordType() const {\n  return isa<RecordType>(CanonicalType);\n}\n\ninline bool Type::isEnumeralType() const {\n  return isa<EnumType>(CanonicalType);\n}\n\ninline bool Type::isAnyComplexType() const {\n  return isa<ComplexType>(CanonicalType);\n}\n\ninline bool Type::isVectorType() const {\n  return isa<VectorType>(CanonicalType);\n}\n\ninline bool Type::isExtVectorType() const {\n  return isa<ExtVectorType>(CanonicalType);\n}\n\ninline bool Type::isMatrixType() const {\n  return isa<MatrixType>(CanonicalType);\n}\n\ninline bool Type::isConstantMatrixType() const {\n  return isa<ConstantMatrixType>(CanonicalType);\n}\n\ninline bool Type::isDependentAddressSpaceType() const {\n  return isa<DependentAddressSpaceType>(CanonicalType);\n}\n\ninline bool Type::isObjCObjectPointerType() const {\n  return isa<ObjCObjectPointerType>(CanonicalType);\n}\n\ninline bool Type::isObjCObjectType() const {\n  return isa<ObjCObjectType>(CanonicalType);\n}\n\ninline bool Type::isObjCObjectOrInterfaceType() const {\n  return isa<ObjCInterfaceType>(CanonicalType) ||\n    isa<ObjCObjectType>(CanonicalType);\n}\n\ninline bool Type::isAtomicType() const {\n  return isa<AtomicType>(CanonicalType);\n}\n\ninline bool Type::isUndeducedAutoType() const {\n  return isa<AutoType>(CanonicalType);\n}\n\ninline bool Type::isObjCQualifiedIdType() const {\n  if (const auto *OPT = getAs<ObjCObjectPointerType>())\n    return OPT->isObjCQualifiedIdType();\n  return false;\n}\n\ninline bool Type::isObjCQualifiedClassType() const {\n  if (const auto *OPT = getAs<ObjCObjectPointerType>())\n    return OPT->isObjCQualifiedClassType();\n  return false;\n}\n\ninline bool Type::isObjCIdType() const {\n  if (const auto *OPT = getAs<ObjCObjectPointerType>())\n    return OPT->isObjCIdType();\n  return false;\n}\n\ninline bool Type::isObjCClassType() const {\n  if (const auto *OPT = getAs<ObjCObjectPointerType>())\n    return OPT->isObjCClassType();\n  return false;\n}\n\ninline bool Type::isObjCSelType() const {\n  if (const auto *OPT = getAs<PointerType>())\n    return OPT->getPointeeType()->isSpecificBuiltinType(BuiltinType::ObjCSel);\n  return false;\n}\n\ninline bool Type::isObjCBuiltinType() const {\n  return isObjCIdType() || isObjCClassType() || isObjCSelType();\n}\n\ninline bool Type::isDecltypeType() const {\n  return isa<DecltypeType>(this);\n}\n\n#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \\\n  inline bool Type::is##Id##Type() const { \\\n    return isSpecificBuiltinType(BuiltinType::Id); \\\n  }\n#include \"clang/Basic/OpenCLImageTypes.def\"\n\ninline bool Type::isSamplerT() const {\n  return isSpecificBuiltinType(BuiltinType::OCLSampler);\n}\n\ninline bool Type::isEventT() const {\n  return isSpecificBuiltinType(BuiltinType::OCLEvent);\n}\n\ninline bool Type::isClkEventT() const {\n  return isSpecificBuiltinType(BuiltinType::OCLClkEvent);\n}\n\ninline bool Type::isQueueT() const {\n  return isSpecificBuiltinType(BuiltinType::OCLQueue);\n}\n\ninline bool Type::isReserveIDT() const {\n  return isSpecificBuiltinType(BuiltinType::OCLReserveID);\n}\n\ninline bool Type::isImageType() const {\n#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) is##Id##Type() ||\n  return\n#include \"clang/Basic/OpenCLImageTypes.def\"\n      false; // end boolean or operation\n}\n\ninline bool Type::isPipeType() const {\n  return isa<PipeType>(CanonicalType);\n}\n\ninline bool Type::isExtIntType() const {\n  return isa<ExtIntType>(CanonicalType);\n}\n\n#define EXT_OPAQUE_TYPE(ExtType, Id, Ext) \\\n  inline bool Type::is##Id##Type() const { \\\n    return isSpecificBuiltinType(BuiltinType::Id); \\\n  }\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n\ninline bool Type::isOCLIntelSubgroupAVCType() const {\n#define INTEL_SUBGROUP_AVC_TYPE(ExtType, Id) \\\n  isOCLIntelSubgroupAVC##Id##Type() ||\n  return\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n    false; // end of boolean or operation\n}\n\ninline bool Type::isOCLExtOpaqueType() const {\n#define EXT_OPAQUE_TYPE(ExtType, Id, Ext) is##Id##Type() ||\n  return\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n    false; // end of boolean or operation\n}\n\ninline bool Type::isOpenCLSpecificType() const {\n  return isSamplerT() || isEventT() || isImageType() || isClkEventT() ||\n         isQueueT() || isReserveIDT() || isPipeType() || isOCLExtOpaqueType();\n}\n\ninline bool Type::isTemplateTypeParmType() const {\n  return isa<TemplateTypeParmType>(CanonicalType);\n}\n\ninline bool Type::isSpecificBuiltinType(unsigned K) const {\n  if (const BuiltinType *BT = getAs<BuiltinType>()) {\n    return BT->getKind() == static_cast<BuiltinType::Kind>(K);\n  }\n  return false;\n}\n\ninline bool Type::isPlaceholderType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(this))\n    return BT->isPlaceholderType();\n  return false;\n}\n\ninline const BuiltinType *Type::getAsPlaceholderType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(this))\n    if (BT->isPlaceholderType())\n      return BT;\n  return nullptr;\n}\n\ninline bool Type::isSpecificPlaceholderType(unsigned K) const {\n  assert(BuiltinType::isPlaceholderTypeKind((BuiltinType::Kind) K));\n  return isSpecificBuiltinType(K);\n}\n\ninline bool Type::isNonOverloadPlaceholderType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(this))\n    return BT->isNonOverloadPlaceholderType();\n  return false;\n}\n\ninline bool Type::isVoidType() const {\n  return isSpecificBuiltinType(BuiltinType::Void);\n}\n\ninline bool Type::isHalfType() const {\n  // FIXME: Should we allow complex __fp16? Probably not.\n  return isSpecificBuiltinType(BuiltinType::Half);\n}\n\ninline bool Type::isFloat16Type() const {\n  return isSpecificBuiltinType(BuiltinType::Float16);\n}\n\ninline bool Type::isBFloat16Type() const {\n  return isSpecificBuiltinType(BuiltinType::BFloat16);\n}\n\ninline bool Type::isFloat128Type() const {\n  return isSpecificBuiltinType(BuiltinType::Float128);\n}\n\ninline bool Type::isNullPtrType() const {\n  return isSpecificBuiltinType(BuiltinType::NullPtr);\n}\n\nbool IsEnumDeclComplete(EnumDecl *);\nbool IsEnumDeclScoped(EnumDecl *);\n\ninline bool Type::isIntegerType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(CanonicalType))\n    return BT->getKind() >= BuiltinType::Bool &&\n           BT->getKind() <= BuiltinType::Int128;\n  if (const EnumType *ET = dyn_cast<EnumType>(CanonicalType)) {\n    // Incomplete enum types are not treated as integer types.\n    // FIXME: In C++, enum types are never integer types.\n    return IsEnumDeclComplete(ET->getDecl()) &&\n      !IsEnumDeclScoped(ET->getDecl());\n  }\n  return isExtIntType();\n}\n\ninline bool Type::isFixedPointType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(CanonicalType)) {\n    return BT->getKind() >= BuiltinType::ShortAccum &&\n           BT->getKind() <= BuiltinType::SatULongFract;\n  }\n  return false;\n}\n\ninline bool Type::isFixedPointOrIntegerType() const {\n  return isFixedPointType() || isIntegerType();\n}\n\ninline bool Type::isSaturatedFixedPointType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(CanonicalType)) {\n    return BT->getKind() >= BuiltinType::SatShortAccum &&\n           BT->getKind() <= BuiltinType::SatULongFract;\n  }\n  return false;\n}\n\ninline bool Type::isUnsaturatedFixedPointType() const {\n  return isFixedPointType() && !isSaturatedFixedPointType();\n}\n\ninline bool Type::isSignedFixedPointType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(CanonicalType)) {\n    return ((BT->getKind() >= BuiltinType::ShortAccum &&\n             BT->getKind() <= BuiltinType::LongAccum) ||\n            (BT->getKind() >= BuiltinType::ShortFract &&\n             BT->getKind() <= BuiltinType::LongFract) ||\n            (BT->getKind() >= BuiltinType::SatShortAccum &&\n             BT->getKind() <= BuiltinType::SatLongAccum) ||\n            (BT->getKind() >= BuiltinType::SatShortFract &&\n             BT->getKind() <= BuiltinType::SatLongFract));\n  }\n  return false;\n}\n\ninline bool Type::isUnsignedFixedPointType() const {\n  return isFixedPointType() && !isSignedFixedPointType();\n}\n\ninline bool Type::isScalarType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(CanonicalType))\n    return BT->getKind() > BuiltinType::Void &&\n           BT->getKind() <= BuiltinType::NullPtr;\n  if (const EnumType *ET = dyn_cast<EnumType>(CanonicalType))\n    // Enums are scalar types, but only if they are defined.  Incomplete enums\n    // are not treated as scalar types.\n    return IsEnumDeclComplete(ET->getDecl());\n  return isa<PointerType>(CanonicalType) ||\n         isa<BlockPointerType>(CanonicalType) ||\n         isa<MemberPointerType>(CanonicalType) ||\n         isa<ComplexType>(CanonicalType) ||\n         isa<ObjCObjectPointerType>(CanonicalType) ||\n         isExtIntType();\n}\n\ninline bool Type::isIntegralOrEnumerationType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(CanonicalType))\n    return BT->getKind() >= BuiltinType::Bool &&\n           BT->getKind() <= BuiltinType::Int128;\n\n  // Check for a complete enum type; incomplete enum types are not properly an\n  // enumeration type in the sense required here.\n  if (const auto *ET = dyn_cast<EnumType>(CanonicalType))\n    return IsEnumDeclComplete(ET->getDecl());\n\n  return isExtIntType();\n}\n\ninline bool Type::isBooleanType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(CanonicalType))\n    return BT->getKind() == BuiltinType::Bool;\n  return false;\n}\n\ninline bool Type::isUndeducedType() const {\n  auto *DT = getContainedDeducedType();\n  return DT && !DT->isDeduced();\n}\n\n/// Determines whether this is a type for which one can define\n/// an overloaded operator.\ninline bool Type::isOverloadableType() const {\n  return isDependentType() || isRecordType() || isEnumeralType();\n}\n\n/// Determines whether this type is written as a typedef-name.\ninline bool Type::isTypedefNameType() const {\n  if (getAs<TypedefType>())\n    return true;\n  if (auto *TST = getAs<TemplateSpecializationType>())\n    return TST->isTypeAlias();\n  return false;\n}\n\n/// Determines whether this type can decay to a pointer type.\ninline bool Type::canDecayToPointerType() const {\n  return isFunctionType() || isArrayType();\n}\n\ninline bool Type::hasPointerRepresentation() const {\n  return (isPointerType() || isReferenceType() || isBlockPointerType() ||\n          isObjCObjectPointerType() || isNullPtrType());\n}\n\ninline bool Type::hasObjCPointerRepresentation() const {\n  return isObjCObjectPointerType();\n}\n\ninline const Type *Type::getBaseElementTypeUnsafe() const {\n  const Type *type = this;\n  while (const ArrayType *arrayType = type->getAsArrayTypeUnsafe())\n    type = arrayType->getElementType().getTypePtr();\n  return type;\n}\n\ninline const Type *Type::getPointeeOrArrayElementType() const {\n  const Type *type = this;\n  if (type->isAnyPointerType())\n    return type->getPointeeType().getTypePtr();\n  else if (type->isArrayType())\n    return type->getBaseElementTypeUnsafe();\n  return type;\n}\n/// Insertion operator for partial diagnostics. This allows sending adress\n/// spaces into a diagnostic with <<.\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &PD,\n                                             LangAS AS) {\n  PD.AddTaggedVal(static_cast<std::underlying_type_t<LangAS>>(AS),\n                  DiagnosticsEngine::ArgumentKind::ak_addrspace);\n  return PD;\n}\n\n/// Insertion operator for partial diagnostics. This allows sending Qualifiers\n/// into a diagnostic with <<.\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &PD,\n                                             Qualifiers Q) {\n  PD.AddTaggedVal(Q.getAsOpaqueValue(),\n                  DiagnosticsEngine::ArgumentKind::ak_qual);\n  return PD;\n}\n\n/// Insertion operator for partial diagnostics.  This allows sending QualType's\n/// into a diagnostic with <<.\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &PD,\n                                             QualType T) {\n  PD.AddTaggedVal(reinterpret_cast<intptr_t>(T.getAsOpaquePtr()),\n                  DiagnosticsEngine::ak_qualtype);\n  return PD;\n}\n\n// Helper class template that is used by Type::getAs to ensure that one does\n// not try to look through a qualified type to get to an array type.\ntemplate <typename T>\nusing TypeIsArrayType =\n    std::integral_constant<bool, std::is_same<T, ArrayType>::value ||\n                                     std::is_base_of<ArrayType, T>::value>;\n\n// Member-template getAs<specific type>'.\ntemplate <typename T> const T *Type::getAs() const {\n  static_assert(!TypeIsArrayType<T>::value,\n                \"ArrayType cannot be used with getAs!\");\n\n  // If this is directly a T type, return it.\n  if (const auto *Ty = dyn_cast<T>(this))\n    return Ty;\n\n  // If the canonical form of this type isn't the right kind, reject it.\n  if (!isa<T>(CanonicalType))\n    return nullptr;\n\n  // If this is a typedef for the type, strip the typedef off without\n  // losing all typedef information.\n  return cast<T>(getUnqualifiedDesugaredType());\n}\n\ntemplate <typename T> const T *Type::getAsAdjusted() const {\n  static_assert(!TypeIsArrayType<T>::value, \"ArrayType cannot be used with getAsAdjusted!\");\n\n  // If this is directly a T type, return it.\n  if (const auto *Ty = dyn_cast<T>(this))\n    return Ty;\n\n  // If the canonical form of this type isn't the right kind, reject it.\n  if (!isa<T>(CanonicalType))\n    return nullptr;\n\n  // Strip off type adjustments that do not modify the underlying nature of the\n  // type.\n  const Type *Ty = this;\n  while (Ty) {\n    if (const auto *A = dyn_cast<AttributedType>(Ty))\n      Ty = A->getModifiedType().getTypePtr();\n    else if (const auto *E = dyn_cast<ElaboratedType>(Ty))\n      Ty = E->desugar().getTypePtr();\n    else if (const auto *P = dyn_cast<ParenType>(Ty))\n      Ty = P->desugar().getTypePtr();\n    else if (const auto *A = dyn_cast<AdjustedType>(Ty))\n      Ty = A->desugar().getTypePtr();\n    else if (const auto *M = dyn_cast<MacroQualifiedType>(Ty))\n      Ty = M->desugar().getTypePtr();\n    else\n      break;\n  }\n\n  // Just because the canonical type is correct does not mean we can use cast<>,\n  // since we may not have stripped off all the sugar down to the base type.\n  return dyn_cast<T>(Ty);\n}\n\ninline const ArrayType *Type::getAsArrayTypeUnsafe() const {\n  // If this is directly an array type, return it.\n  if (const auto *arr = dyn_cast<ArrayType>(this))\n    return arr;\n\n  // If the canonical form of this type isn't the right kind, reject it.\n  if (!isa<ArrayType>(CanonicalType))\n    return nullptr;\n\n  // If this is a typedef for the type, strip the typedef off without\n  // losing all typedef information.\n  return cast<ArrayType>(getUnqualifiedDesugaredType());\n}\n\ntemplate <typename T> const T *Type::castAs() const {\n  static_assert(!TypeIsArrayType<T>::value,\n                \"ArrayType cannot be used with castAs!\");\n\n  if (const auto *ty = dyn_cast<T>(this)) return ty;\n  assert(isa<T>(CanonicalType));\n  return cast<T>(getUnqualifiedDesugaredType());\n}\n\ninline const ArrayType *Type::castAsArrayTypeUnsafe() const {\n  assert(isa<ArrayType>(CanonicalType));\n  if (const auto *arr = dyn_cast<ArrayType>(this)) return arr;\n  return cast<ArrayType>(getUnqualifiedDesugaredType());\n}\n\nDecayedType::DecayedType(QualType OriginalType, QualType DecayedPtr,\n                         QualType CanonicalPtr)\n    : AdjustedType(Decayed, OriginalType, DecayedPtr, CanonicalPtr) {\n#ifndef NDEBUG\n  QualType Adjusted = getAdjustedType();\n  (void)AttributedType::stripOuterNullability(Adjusted);\n  assert(isa<PointerType>(Adjusted));\n#endif\n}\n\nQualType DecayedType::getPointeeType() const {\n  QualType Decayed = getDecayedType();\n  (void)AttributedType::stripOuterNullability(Decayed);\n  return cast<PointerType>(Decayed)->getPointeeType();\n}\n\n// Get the decimal string representation of a fixed point type, represented\n// as a scaled integer.\n// TODO: At some point, we should change the arguments to instead just accept an\n// APFixedPoint instead of APSInt and scale.\nvoid FixedPointValueToString(SmallVectorImpl<char> &Str, llvm::APSInt Val,\n                             unsigned Scale);\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_TYPE_H\n"}, "18": {"id": 18, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/UnresolvedSet.h", "content": "//===- UnresolvedSet.h - Unresolved sets of declarations --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the UnresolvedSet class, which is used to store\n//  collections of declarations in the AST.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_UNRESOLVEDSET_H\n#define LLVM_CLANG_AST_UNRESOLVEDSET_H\n\n#include \"clang/AST/DeclAccessPair.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/iterator.h\"\n#include <cstddef>\n#include <iterator>\n\nnamespace clang {\n\nclass NamedDecl;\n\n/// The iterator over UnresolvedSets.  Serves as both the const and\n/// non-const iterator.\nclass UnresolvedSetIterator : public llvm::iterator_adaptor_base<\n                                  UnresolvedSetIterator, DeclAccessPair *,\n                                  std::random_access_iterator_tag, NamedDecl *,\n                                  std::ptrdiff_t, NamedDecl *, NamedDecl *> {\n  friend class ASTUnresolvedSet;\n  friend class OverloadExpr;\n  friend class UnresolvedSetImpl;\n\n  explicit UnresolvedSetIterator(DeclAccessPair *Iter)\n      : iterator_adaptor_base(Iter) {}\n  explicit UnresolvedSetIterator(const DeclAccessPair *Iter)\n      : iterator_adaptor_base(const_cast<DeclAccessPair *>(Iter)) {}\n\npublic:\n  // Work around a bug in MSVC 2013 where explicitly default constructed\n  // temporaries with defaulted ctors are not zero initialized.\n  UnresolvedSetIterator() : iterator_adaptor_base(nullptr) {}\n\n  NamedDecl *getDecl() const { return I->getDecl(); }\n  void setDecl(NamedDecl *ND) const { return I->setDecl(ND); }\n  AccessSpecifier getAccess() const { return I->getAccess(); }\n  void setAccess(AccessSpecifier AS) { I->setAccess(AS); }\n  const DeclAccessPair &getPair() const { return *I; }\n\n  NamedDecl *operator*() const { return getDecl(); }\n  NamedDecl *operator->() const { return **this; }\n};\n\n/// A set of unresolved declarations.\nclass UnresolvedSetImpl {\n  using DeclsTy = SmallVectorImpl<DeclAccessPair>;\n\n  // Don't allow direct construction, and only permit subclassing by\n  // UnresolvedSet.\nprivate:\n  template <unsigned N> friend class UnresolvedSet;\n\n  UnresolvedSetImpl() = default;\n  UnresolvedSetImpl(const UnresolvedSetImpl &) = default;\n  UnresolvedSetImpl &operator=(const UnresolvedSetImpl &) = default;\n\n  // FIXME: Switch these to \"= default\" once MSVC supports generating move ops\n  UnresolvedSetImpl(UnresolvedSetImpl &&) {}\n  UnresolvedSetImpl &operator=(UnresolvedSetImpl &&) { return *this; }\n\npublic:\n  // We don't currently support assignment through this iterator, so we might\n  // as well use the same implementation twice.\n  using iterator = UnresolvedSetIterator;\n  using const_iterator = UnresolvedSetIterator;\n\n  iterator begin() { return iterator(decls().begin()); }\n  iterator end() { return iterator(decls().end()); }\n\n  const_iterator begin() const { return const_iterator(decls().begin()); }\n  const_iterator end() const { return const_iterator(decls().end()); }\n\n  ArrayRef<DeclAccessPair> pairs() const { return decls(); }\n\n  void addDecl(NamedDecl *D) {\n    addDecl(D, AS_none);\n  }\n\n  void addDecl(NamedDecl *D, AccessSpecifier AS) {\n    decls().push_back(DeclAccessPair::make(D, AS));\n  }\n\n  /// Replaces the given declaration with the new one, once.\n  ///\n  /// \\return true if the set changed\n  bool replace(const NamedDecl* Old, NamedDecl *New) {\n    for (DeclsTy::iterator I = decls().begin(), E = decls().end(); I != E; ++I)\n      if (I->getDecl() == Old)\n        return (I->setDecl(New), true);\n    return false;\n  }\n\n  /// Replaces the declaration at the given iterator with the new one,\n  /// preserving the original access bits.\n  void replace(iterator I, NamedDecl *New) { I.I->setDecl(New); }\n\n  void replace(iterator I, NamedDecl *New, AccessSpecifier AS) {\n    I.I->set(New, AS);\n  }\n\n  void erase(unsigned I) { decls()[I] = decls().pop_back_val(); }\n\n  void erase(iterator I) { *I.I = decls().pop_back_val(); }\n\n  void setAccess(iterator I, AccessSpecifier AS) { I.I->setAccess(AS); }\n\n  void clear() { decls().clear(); }\n  void set_size(unsigned N) { decls().set_size(N); }\n\n  bool empty() const { return decls().empty(); }\n  unsigned size() const { return decls().size(); }\n\n  void append(iterator I, iterator E) { decls().append(I.I, E.I); }\n\n  template<typename Iter> void assign(Iter I, Iter E) { decls().assign(I, E); }\n\n  DeclAccessPair &operator[](unsigned I) { return decls()[I]; }\n  const DeclAccessPair &operator[](unsigned I) const { return decls()[I]; }\n\nprivate:\n  // These work because the only permitted subclass is UnresolvedSetImpl\n\n  DeclsTy &decls() {\n    return *reinterpret_cast<DeclsTy*>(this);\n  }\n  const DeclsTy &decls() const {\n    return *reinterpret_cast<const DeclsTy*>(this);\n  }\n};\n\n/// A set of unresolved declarations.\ntemplate <unsigned InlineCapacity> class UnresolvedSet :\n    public UnresolvedSetImpl {\n  SmallVector<DeclAccessPair, InlineCapacity> Decls;\n};\n\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_UNRESOLVEDSET_H\n"}, "19": {"id": 19, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/AnalysisDeclContext.h", "content": "//===- AnalysisDeclContext.h - Context for path sensitivity -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// This file defines AnalysisDeclContext, a class that manages the analysis\n/// context data for context sensitive and path sensitive analysis.\n/// It also defines the helper classes to model entering, leaving or inlining\n/// function calls.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_ANALYSIS_ANALYSISDECLCONTEXT_H\n#define LLVM_CLANG_ANALYSIS_ANALYSISDECLCONTEXT_H\n\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/Analysis/BodyFarm.h\"\n#include \"clang/Analysis/CFG.h\"\n#include \"clang/Analysis/CodeInjector.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <functional>\n#include <memory>\n\nnamespace clang {\n\nclass AnalysisDeclContextManager;\nclass ASTContext;\nclass BlockDecl;\nclass BlockInvocationContext;\nclass CFGReverseBlockReachabilityAnalysis;\nclass CFGStmtMap;\nclass ImplicitParamDecl;\nclass LocationContext;\nclass LocationContextManager;\nclass ParentMap;\nclass StackFrameContext;\nclass Stmt;\nclass VarDecl;\n\n/// The base class of a hierarchy of objects representing analyses tied\n/// to AnalysisDeclContext.\nclass ManagedAnalysis {\nprotected:\n  ManagedAnalysis() = default;\n\npublic:\n  virtual ~ManagedAnalysis();\n\n  // Subclasses need to implement:\n  //\n  //  static const void *getTag();\n  //\n  // Which returns a fixed pointer address to distinguish classes of\n  // analysis objects.  They also need to implement:\n  //\n  //  static [Derived*] create(AnalysisDeclContext &Ctx);\n  //\n  // which creates the analysis object given an AnalysisDeclContext.\n};\n\n/// AnalysisDeclContext contains the context data for the function, method\n/// or block under analysis.\nclass AnalysisDeclContext {\n  // Backpoint to the AnalysisManager object that created this\n  // AnalysisDeclContext. This may be null.\n  AnalysisDeclContextManager *ADCMgr;\n\n  const Decl *const D;\n\n  std::unique_ptr<CFG> cfg, completeCFG;\n  std::unique_ptr<CFGStmtMap> cfgStmtMap;\n\n  CFG::BuildOptions cfgBuildOptions;\n  CFG::BuildOptions::ForcedBlkExprs *forcedBlkExprs = nullptr;\n\n  bool builtCFG = false;\n  bool builtCompleteCFG = false;\n  std::unique_ptr<ParentMap> PM;\n  std::unique_ptr<CFGReverseBlockReachabilityAnalysis> CFA;\n\n  llvm::BumpPtrAllocator A;\n\n  llvm::DenseMap<const BlockDecl *, void *> *ReferencedBlockVars = nullptr;\n\n  void *ManagedAnalyses = nullptr;\n\npublic:\n  AnalysisDeclContext(AnalysisDeclContextManager *Mgr, const Decl *D);\n\n  AnalysisDeclContext(AnalysisDeclContextManager *Mgr, const Decl *D,\n                      const CFG::BuildOptions &BuildOptions);\n\n  ~AnalysisDeclContext();\n\n  ASTContext &getASTContext() const { return D->getASTContext(); }\n\n  const Decl *getDecl() const { return D; }\n\n  AnalysisDeclContextManager *getManager() const { return ADCMgr; }\n\n  CFG::BuildOptions &getCFGBuildOptions() { return cfgBuildOptions; }\n\n  const CFG::BuildOptions &getCFGBuildOptions() const {\n    return cfgBuildOptions;\n  }\n\n  /// \\returns Whether we are adding exception handling edges from CallExprs.\n  /// If this is false, then try/catch statements and blocks reachable from them\n  /// can appear to be dead in the CFG, analysis passes must cope with that.\n  bool getAddEHEdges() const { return cfgBuildOptions.AddEHEdges; }\n  bool getUseUnoptimizedCFG() const {\n    return !cfgBuildOptions.PruneTriviallyFalseEdges;\n  }\n  bool getAddImplicitDtors() const { return cfgBuildOptions.AddImplicitDtors; }\n  bool getAddInitializers() const { return cfgBuildOptions.AddInitializers; }\n\n  void registerForcedBlockExpression(const Stmt *stmt);\n  const CFGBlock *getBlockForRegisteredExpression(const Stmt *stmt);\n\n  /// \\returns The body of the stored Decl \\c D.\n  Stmt *getBody() const;\n\n  /// \\copydoc AnalysisDeclContext::getBody()\n  /// \\param[out] IsAutosynthesized Specifies if the body is auto-generated\n  ///             by the BodyFarm.\n  Stmt *getBody(bool &IsAutosynthesized) const;\n\n  /// \\returns Whether the body of the Decl \\c D is generated by the BodyFarm.\n  ///\n  /// \\note The lookup is not free. We are going to call getBody behind\n  /// the scenes.\n  /// \\sa getBody\n  bool isBodyAutosynthesized() const;\n\n  /// \\returns Whether the body of the Decl \\c D is generated by the BodyFarm\n  /// from a model file.\n  ///\n  /// \\note The lookup is not free. We are going to call getBody behind\n  /// the scenes.\n  /// \\sa getBody\n  bool isBodyAutosynthesizedFromModelFile() const;\n\n  CFG *getCFG();\n\n  CFGStmtMap *getCFGStmtMap();\n\n  CFGReverseBlockReachabilityAnalysis *getCFGReachablityAnalysis();\n\n  /// \\returns A version of the CFG without any edges pruned.\n  CFG *getUnoptimizedCFG();\n\n  void dumpCFG(bool ShowColors);\n\n  /// \\returns Whether we have built a CFG for this analysis context.\n  ///\n  /// \\note This doesn't correspond to whether or not a valid CFG exists, it\n  /// corresponds to whether we *attempted* to build one.\n  bool isCFGBuilt() const { return builtCFG; }\n\n  ParentMap &getParentMap();\n\n  using referenced_decls_iterator = const VarDecl *const *;\n\n  llvm::iterator_range<referenced_decls_iterator>\n  getReferencedBlockVars(const BlockDecl *BD);\n\n  /// \\returns The ImplicitParamDecl associated with \\c self if this\n  /// AnalysisDeclContext wraps an ObjCMethodDecl or nullptr otherwise.\n  const ImplicitParamDecl *getSelfDecl() const;\n\n  /// \\copydoc LocationContextManager::getStackFrame()\n  const StackFrameContext *getStackFrame(LocationContext const *ParentLC,\n                                         const Stmt *S, const CFGBlock *Blk,\n                                         unsigned BlockCount, unsigned Index);\n\n  /// \\copydoc LocationContextManager::getBlockInvocationContext()\n  const BlockInvocationContext *\n  getBlockInvocationContext(const LocationContext *ParentLC,\n                            const BlockDecl *BD, const void *Data);\n\n  /// \\returns The specified analysis object, lazily running the analysis if\n  /// necessary or nullptr if the analysis could not run.\n  template <typename T> T *getAnalysis() {\n    const void *tag = T::getTag();\n    std::unique_ptr<ManagedAnalysis> &data = getAnalysisImpl(tag);\n    if (!data)\n      data = T::create(*this);\n    return static_cast<T *>(data.get());\n  }\n\n  /// \\returns Whether the root namespace of \\p D is the \\c std C++ namespace.\n  static bool isInStdNamespace(const Decl *D);\n\nprivate:\n  std::unique_ptr<ManagedAnalysis> &getAnalysisImpl(const void *tag);\n\n  LocationContextManager &getLocationContextManager();\n};\n\n/// It wraps the AnalysisDeclContext to represent both the call stack with\n/// the help of StackFrameContext and inside the function calls the\n/// BlockInvocationContext. It is needed for context sensitive analysis to\n/// model entering, leaving or inlining function calls.\nclass LocationContext : public llvm::FoldingSetNode {\npublic:\n  enum ContextKind { StackFrame, Block };\n\nprivate:\n  ContextKind Kind;\n\n  // AnalysisDeclContext can't be const since some methods may modify its\n  // member.\n  AnalysisDeclContext *Ctx;\n\n  const LocationContext *Parent;\n  int64_t ID;\n\nprotected:\n  LocationContext(ContextKind k, AnalysisDeclContext *ctx,\n                  const LocationContext *parent, int64_t ID)\n      : Kind(k), Ctx(ctx), Parent(parent), ID(ID) {}\n\npublic:\n  virtual ~LocationContext();\n\n  ContextKind getKind() const { return Kind; }\n\n  int64_t getID() const { return ID; }\n\n  AnalysisDeclContext *getAnalysisDeclContext() const { return Ctx; }\n\n  const LocationContext *getParent() const { return Parent; }\n\n  bool isParentOf(const LocationContext *LC) const;\n\n  const Decl *getDecl() const { return Ctx->getDecl(); }\n\n  CFG *getCFG() const { return Ctx->getCFG(); }\n\n  template <typename T> T *getAnalysis() const { return Ctx->getAnalysis<T>(); }\n\n  const ParentMap &getParentMap() const { return Ctx->getParentMap(); }\n\n  /// \\copydoc AnalysisDeclContext::getSelfDecl()\n  const ImplicitParamDecl *getSelfDecl() const { return Ctx->getSelfDecl(); }\n\n  const StackFrameContext *getStackFrame() const;\n\n  /// \\returns Whether the current LocationContext has no caller context.\n  virtual bool inTopFrame() const;\n\n  virtual void Profile(llvm::FoldingSetNodeID &ID) = 0;\n\n  /// Prints out the call stack.\n  ///\n  /// \\param Out The out stream.\n  LLVM_DUMP_METHOD void dumpStack(raw_ostream &Out) const;\n\n  /// Prints out the call stack in \\c json format.\n  ///\n  /// \\param Out   The out stream.\n  /// \\param NL    The newline.\n  /// \\param Space The space count for indentation.\n  /// \\param IsDot Whether the output format is \\c dot.\n  /// \\param printMoreInfoPerContext\n  /// A callback to print more information for each context, for example:\n  /// \\code\n  ///   [&](const LocationContext *LC) { LC->dump(); }\n  /// \\endcode\n  void printJson(\n      raw_ostream &Out, const char *NL = \"\\n\", unsigned int Space = 0,\n      bool IsDot = false,\n      std::function<void(const LocationContext *)> printMoreInfoPerContext =\n          [](const LocationContext *) {}) const;\n\n  LLVM_DUMP_METHOD void dump() const;\n\n  static void ProfileCommon(llvm::FoldingSetNodeID &ID, ContextKind ck,\n                            AnalysisDeclContext *ctx,\n                            const LocationContext *parent, const void *data);\n};\n\n/// It represents a stack frame of the call stack (based on CallEvent).\nclass StackFrameContext : public LocationContext {\n  friend class LocationContextManager;\n\n  // The call site where this stack frame is established.\n  const Stmt *CallSite;\n\n  // The parent block of the call site.\n  const CFGBlock *Block;\n\n  // The number of times the 'Block' has been visited.\n  // It allows discriminating between stack frames of the same call that is\n  // called multiple times in a loop.\n  const unsigned BlockCount;\n\n  // The index of the call site in the CFGBlock.\n  const unsigned Index;\n\n  StackFrameContext(AnalysisDeclContext *ADC, const LocationContext *ParentLC,\n                    const Stmt *S, const CFGBlock *Block, unsigned BlockCount,\n                    unsigned Index, int64_t ID)\n      : LocationContext(StackFrame, ADC, ParentLC, ID), CallSite(S),\n        Block(Block), BlockCount(BlockCount), Index(Index) {}\n\npublic:\n  ~StackFrameContext() override = default;\n\n  const Stmt *getCallSite() const { return CallSite; }\n\n  const CFGBlock *getCallSiteBlock() const { return Block; }\n\n  bool inTopFrame() const override { return getParent() == nullptr; }\n\n  unsigned getIndex() const { return Index; }\n\n  CFGElement getCallSiteCFGElement() const { return (*Block)[Index]; }\n  \n  void Profile(llvm::FoldingSetNodeID &ID) override;\n\n  static void Profile(llvm::FoldingSetNodeID &ID, AnalysisDeclContext *ADC,\n                      const LocationContext *ParentLC, const Stmt *S,\n                      const CFGBlock *Block, unsigned BlockCount,\n                      unsigned Index) {\n    ProfileCommon(ID, StackFrame, ADC, ParentLC, S);\n    ID.AddPointer(Block);\n    ID.AddInteger(BlockCount);\n    ID.AddInteger(Index);\n  }\n\n  static bool classof(const LocationContext *LC) {\n    return LC->getKind() == StackFrame;\n  }\n};\n\n/// It represents a block invocation (based on BlockCall).\nclass BlockInvocationContext : public LocationContext {\n  friend class LocationContextManager;\n\n  const BlockDecl *BD;\n\n  // FIXME: Come up with a more type-safe way to model context-sensitivity.\n  const void *Data;\n\n  BlockInvocationContext(AnalysisDeclContext *ADC,\n                         const LocationContext *ParentLC, const BlockDecl *BD,\n                         const void *Data, int64_t ID)\n      : LocationContext(Block, ADC, ParentLC, ID), BD(BD), Data(Data) {}\n\npublic:\n  ~BlockInvocationContext() override = default;\n\n  const BlockDecl *getBlockDecl() const { return BD; }\n\n  const void *getData() const { return Data; }\n\n  void Profile(llvm::FoldingSetNodeID &ID) override;\n\n  static void Profile(llvm::FoldingSetNodeID &ID, AnalysisDeclContext *ADC,\n                      const LocationContext *ParentLC, const BlockDecl *BD,\n                      const void *Data) {\n    ProfileCommon(ID, Block, ADC, ParentLC, BD);\n    ID.AddPointer(Data);\n  }\n\n  static bool classof(const LocationContext *LC) {\n    return LC->getKind() == Block;\n  }\n};\n\nclass LocationContextManager {\n  llvm::FoldingSet<LocationContext> Contexts;\n\n  // ID used for generating a new location context.\n  int64_t NewID = 0;\n\npublic:\n  ~LocationContextManager();\n\n  /// Obtain a context of the call stack using its parent context.\n  ///\n  /// \\param ADC        The AnalysisDeclContext.\n  /// \\param ParentLC   The parent context of this newly created context.\n  /// \\param S          The call.\n  /// \\param Block      The basic block.\n  /// \\param BlockCount The current count of entering into \\p Blk.\n  /// \\param Index      The index of \\p Blk.\n  /// \\returns The context for \\p D with parent context \\p ParentLC.\n  const StackFrameContext *getStackFrame(AnalysisDeclContext *ADC,\n                                         const LocationContext *ParentLC,\n                                         const Stmt *S, const CFGBlock *Block,\n                                         unsigned BlockCount, unsigned Index);\n\n  /// Obtain a context of the block invocation using its parent context.\n  ///\n  /// \\param ADC      The AnalysisDeclContext.\n  /// \\param ParentLC The parent context of this newly created context.\n  /// \\param BD       The BlockDecl.\n  /// \\param Data     The raw data to store as part of the context.\n  const BlockInvocationContext *\n  getBlockInvocationContext(AnalysisDeclContext *ADC,\n                            const LocationContext *ParentLC,\n                            const BlockDecl *BD, const void *Data);\n\n  /// Discard all previously created LocationContext objects.\n  void clear();\n};\n\nclass AnalysisDeclContextManager {\n  using ContextMap =\n      llvm::DenseMap<const Decl *, std::unique_ptr<AnalysisDeclContext>>;\n\n  ContextMap Contexts;\n  LocationContextManager LocCtxMgr;\n  CFG::BuildOptions cfgBuildOptions;\n\n  // Pointer to an interface that can provide function bodies for\n  // declarations from external source.\n  std::unique_ptr<CodeInjector> Injector;\n\n  // A factory for creating and caching implementations for common\n  // methods during the analysis.\n  BodyFarm FunctionBodyFarm;\n\n  // Flag to indicate whether or not bodies should be synthesized\n  // for well-known functions.\n  bool SynthesizeBodies;\n\npublic:\n  AnalysisDeclContextManager(\n      ASTContext &ASTCtx, bool useUnoptimizedCFG = false,\n      bool addImplicitDtors = false, bool addInitializers = false,\n      bool addTemporaryDtors = false, bool addLifetime = false,\n      bool addLoopExit = false, bool addScopes = false,\n      bool synthesizeBodies = false, bool addStaticInitBranches = false,\n      bool addCXXNewAllocator = true, bool addRichCXXConstructors = true,\n      bool markElidedCXXConstructors = true, bool addVirtualBaseBranches = true,\n      CodeInjector *injector = nullptr);\n\n  AnalysisDeclContext *getContext(const Decl *D);\n\n  bool getUseUnoptimizedCFG() const {\n    return !cfgBuildOptions.PruneTriviallyFalseEdges;\n  }\n\n  CFG::BuildOptions &getCFGBuildOptions() { return cfgBuildOptions; }\n\n  /// \\returns Whether faux bodies should be synthesized for known functions.\n  bool synthesizeBodies() const { return SynthesizeBodies; }\n\n  /// Obtain the beginning context of the analysis.\n  ///\n  /// \\returns The top level stack frame for \\p D.\n  const StackFrameContext *getStackFrame(const Decl *D) {\n    return LocCtxMgr.getStackFrame(getContext(D), nullptr, nullptr, nullptr, 0,\n                                   0);\n  }\n\n  /// \\copydoc LocationContextManager::getStackFrame()\n  const StackFrameContext *getStackFrame(AnalysisDeclContext *ADC,\n                                         const LocationContext *Parent,\n                                         const Stmt *S, const CFGBlock *Block,\n                                         unsigned BlockCount, unsigned Index) {\n    return LocCtxMgr.getStackFrame(ADC, Parent, S, Block, BlockCount, Index);\n  }\n\n  BodyFarm &getBodyFarm();\n\n  /// Discard all previously created AnalysisDeclContexts.\n  void clear();\n\nprivate:\n  friend class AnalysisDeclContext;\n\n  LocationContextManager &getLocationContextManager() { return LocCtxMgr; }\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_ANALYSIS_ANALYSISDECLCONTEXT_H\n"}, "20": {"id": 20, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/CFG.h", "content": "//===- CFG.h - Classes for representing and building CFGs -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the CFG and CFGBuilder classes for representing and\n//  building Control-Flow Graphs (CFGs) from ASTs.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_ANALYSIS_CFG_H\n#define LLVM_CLANG_ANALYSIS_CFG_H\n\n#include \"clang/Analysis/Support/BumpVector.h\"\n#include \"clang/Analysis/ConstructionContext.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/ExprObjC.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/GraphTraits.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <bitset>\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <memory>\n#include <vector>\n\nnamespace clang {\n\nclass ASTContext;\nclass BinaryOperator;\nclass CFG;\nclass CXXBaseSpecifier;\nclass CXXBindTemporaryExpr;\nclass CXXCtorInitializer;\nclass CXXDeleteExpr;\nclass CXXDestructorDecl;\nclass CXXNewExpr;\nclass CXXRecordDecl;\nclass Decl;\nclass FieldDecl;\nclass LangOptions;\nclass VarDecl;\n\n/// Represents a top-level expression in a basic block.\nclass CFGElement {\npublic:\n  enum Kind {\n    // main kind\n    Initializer,\n    ScopeBegin,\n    ScopeEnd,\n    NewAllocator,\n    LifetimeEnds,\n    LoopExit,\n    // stmt kind\n    Statement,\n    Constructor,\n    CXXRecordTypedCall,\n    STMT_BEGIN = Statement,\n    STMT_END = CXXRecordTypedCall,\n    // dtor kind\n    AutomaticObjectDtor,\n    DeleteDtor,\n    BaseDtor,\n    MemberDtor,\n    TemporaryDtor,\n    DTOR_BEGIN = AutomaticObjectDtor,\n    DTOR_END = TemporaryDtor\n  };\n\nprotected:\n  // The int bits are used to mark the kind.\n  llvm::PointerIntPair<void *, 2> Data1;\n  llvm::PointerIntPair<void *, 2> Data2;\n\n  CFGElement(Kind kind, const void *Ptr1, const void *Ptr2 = nullptr)\n      : Data1(const_cast<void*>(Ptr1), ((unsigned) kind) & 0x3),\n        Data2(const_cast<void*>(Ptr2), (((unsigned) kind) >> 2) & 0x3) {\n    assert(getKind() == kind);\n  }\n\n  CFGElement() = default;\n\npublic:\n  /// Convert to the specified CFGElement type, asserting that this\n  /// CFGElement is of the desired type.\n  template<typename T>\n  T castAs() const {\n    assert(T::isKind(*this));\n    T t;\n    CFGElement& e = t;\n    e = *this;\n    return t;\n  }\n\n  /// Convert to the specified CFGElement type, returning None if this\n  /// CFGElement is not of the desired type.\n  template<typename T>\n  Optional<T> getAs() const {\n    if (!T::isKind(*this))\n      return None;\n    T t;\n    CFGElement& e = t;\n    e = *this;\n    return t;\n  }\n\n  Kind getKind() const {\n    unsigned x = Data2.getInt();\n    x <<= 2;\n    x |= Data1.getInt();\n    return (Kind) x;\n  }\n\n  void dumpToStream(llvm::raw_ostream &OS) const;\n\n  void dump() const {\n    dumpToStream(llvm::errs());\n  }\n};\n\nclass CFGStmt : public CFGElement {\npublic:\n  explicit CFGStmt(Stmt *S, Kind K = Statement) : CFGElement(K, S) {\n    assert(isKind(*this));\n  }\n\n  const Stmt *getStmt() const {\n    return static_cast<const Stmt *>(Data1.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  static bool isKind(const CFGElement &E) {\n    return E.getKind() >= STMT_BEGIN && E.getKind() <= STMT_END;\n  }\n\nprotected:\n  CFGStmt() = default;\n};\n\n/// Represents C++ constructor call. Maintains information necessary to figure\n/// out what memory is being initialized by the constructor expression. For now\n/// this is only used by the analyzer's CFG.\nclass CFGConstructor : public CFGStmt {\npublic:\n  explicit CFGConstructor(CXXConstructExpr *CE, const ConstructionContext *C)\n      : CFGStmt(CE, Constructor) {\n    assert(C);\n    Data2.setPointer(const_cast<ConstructionContext *>(C));\n  }\n\n  const ConstructionContext *getConstructionContext() const {\n    return static_cast<ConstructionContext *>(Data2.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGConstructor() = default;\n\n  static bool isKind(const CFGElement &E) {\n    return E.getKind() == Constructor;\n  }\n};\n\n/// Represents a function call that returns a C++ object by value. This, like\n/// constructor, requires a construction context in order to understand the\n/// storage of the returned object . In C such tracking is not necessary because\n/// no additional effort is required for destroying the object or modeling copy\n/// elision. Like CFGConstructor, this element is for now only used by the\n/// analyzer's CFG.\nclass CFGCXXRecordTypedCall : public CFGStmt {\npublic:\n  /// Returns true when call expression \\p CE needs to be represented\n  /// by CFGCXXRecordTypedCall, as opposed to a regular CFGStmt.\n  static bool isCXXRecordTypedCall(Expr *E) {\n    assert(isa<CallExpr>(E) || isa<ObjCMessageExpr>(E));\n    // There is no such thing as reference-type expression. If the function\n    // returns a reference, it'll return the respective lvalue or xvalue\n    // instead, and we're only interested in objects.\n    return !E->isGLValue() &&\n           E->getType().getCanonicalType()->getAsCXXRecordDecl();\n  }\n\n  explicit CFGCXXRecordTypedCall(Expr *E, const ConstructionContext *C)\n      : CFGStmt(E, CXXRecordTypedCall) {\n    assert(isCXXRecordTypedCall(E));\n    assert(C && (isa<TemporaryObjectConstructionContext>(C) ||\n                 // These are possible in C++17 due to mandatory copy elision.\n                 isa<ReturnedValueConstructionContext>(C) ||\n                 isa<VariableConstructionContext>(C) ||\n                 isa<ConstructorInitializerConstructionContext>(C) ||\n                 isa<ArgumentConstructionContext>(C)));\n    Data2.setPointer(const_cast<ConstructionContext *>(C));\n  }\n\n  const ConstructionContext *getConstructionContext() const {\n    return static_cast<ConstructionContext *>(Data2.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGCXXRecordTypedCall() = default;\n\n  static bool isKind(const CFGElement &E) {\n    return E.getKind() == CXXRecordTypedCall;\n  }\n};\n\n/// Represents C++ base or member initializer from constructor's initialization\n/// list.\nclass CFGInitializer : public CFGElement {\npublic:\n  explicit CFGInitializer(CXXCtorInitializer *initializer)\n      : CFGElement(Initializer, initializer) {}\n\n  CXXCtorInitializer* getInitializer() const {\n    return static_cast<CXXCtorInitializer*>(Data1.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGInitializer() = default;\n\n  static bool isKind(const CFGElement &E) {\n    return E.getKind() == Initializer;\n  }\n};\n\n/// Represents C++ allocator call.\nclass CFGNewAllocator : public CFGElement {\npublic:\n  explicit CFGNewAllocator(const CXXNewExpr *S)\n    : CFGElement(NewAllocator, S) {}\n\n  // Get the new expression.\n  const CXXNewExpr *getAllocatorExpr() const {\n    return static_cast<CXXNewExpr *>(Data1.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGNewAllocator() = default;\n\n  static bool isKind(const CFGElement &elem) {\n    return elem.getKind() == NewAllocator;\n  }\n};\n\n/// Represents the point where a loop ends.\n/// This element is is only produced when building the CFG for the static\n/// analyzer and hidden behind the 'cfg-loopexit' analyzer config flag.\n///\n/// Note: a loop exit element can be reached even when the loop body was never\n/// entered.\nclass CFGLoopExit : public CFGElement {\npublic:\n  explicit CFGLoopExit(const Stmt *stmt) : CFGElement(LoopExit, stmt) {}\n\n  const Stmt *getLoopStmt() const {\n    return static_cast<Stmt *>(Data1.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGLoopExit() = default;\n\n  static bool isKind(const CFGElement &elem) {\n    return elem.getKind() == LoopExit;\n  }\n};\n\n/// Represents the point where the lifetime of an automatic object ends\nclass CFGLifetimeEnds : public CFGElement {\npublic:\n  explicit CFGLifetimeEnds(const VarDecl *var, const Stmt *stmt)\n      : CFGElement(LifetimeEnds, var, stmt) {}\n\n  const VarDecl *getVarDecl() const {\n    return static_cast<VarDecl *>(Data1.getPointer());\n  }\n\n  const Stmt *getTriggerStmt() const {\n    return static_cast<Stmt *>(Data2.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGLifetimeEnds() = default;\n\n  static bool isKind(const CFGElement &elem) {\n    return elem.getKind() == LifetimeEnds;\n  }\n};\n\n/// Represents beginning of a scope implicitly generated\n/// by the compiler on encountering a CompoundStmt\nclass CFGScopeBegin : public CFGElement {\npublic:\n  CFGScopeBegin() {}\n  CFGScopeBegin(const VarDecl *VD, const Stmt *S)\n      : CFGElement(ScopeBegin, VD, S) {}\n\n  // Get statement that triggered a new scope.\n  const Stmt *getTriggerStmt() const {\n    return static_cast<Stmt*>(Data2.getPointer());\n  }\n\n  // Get VD that triggered a new scope.\n  const VarDecl *getVarDecl() const {\n    return static_cast<VarDecl *>(Data1.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n  static bool isKind(const CFGElement &E) {\n    Kind kind = E.getKind();\n    return kind == ScopeBegin;\n  }\n};\n\n/// Represents end of a scope implicitly generated by\n/// the compiler after the last Stmt in a CompoundStmt's body\nclass CFGScopeEnd : public CFGElement {\npublic:\n  CFGScopeEnd() {}\n  CFGScopeEnd(const VarDecl *VD, const Stmt *S) : CFGElement(ScopeEnd, VD, S) {}\n\n  const VarDecl *getVarDecl() const {\n    return static_cast<VarDecl *>(Data1.getPointer());\n  }\n\n  const Stmt *getTriggerStmt() const {\n    return static_cast<Stmt *>(Data2.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n  static bool isKind(const CFGElement &E) {\n    Kind kind = E.getKind();\n    return kind == ScopeEnd;\n  }\n};\n\n/// Represents C++ object destructor implicitly generated by compiler on various\n/// occasions.\nclass CFGImplicitDtor : public CFGElement {\nprotected:\n  CFGImplicitDtor() = default;\n\n  CFGImplicitDtor(Kind kind, const void *data1, const void *data2 = nullptr)\n    : CFGElement(kind, data1, data2) {\n    assert(kind >= DTOR_BEGIN && kind <= DTOR_END);\n  }\n\npublic:\n  const CXXDestructorDecl *getDestructorDecl(ASTContext &astContext) const;\n  bool isNoReturn(ASTContext &astContext) const;\n\nprivate:\n  friend class CFGElement;\n\n  static bool isKind(const CFGElement &E) {\n    Kind kind = E.getKind();\n    return kind >= DTOR_BEGIN && kind <= DTOR_END;\n  }\n};\n\n/// Represents C++ object destructor implicitly generated for automatic object\n/// or temporary bound to const reference at the point of leaving its local\n/// scope.\nclass CFGAutomaticObjDtor: public CFGImplicitDtor {\npublic:\n  CFGAutomaticObjDtor(const VarDecl *var, const Stmt *stmt)\n      : CFGImplicitDtor(AutomaticObjectDtor, var, stmt) {}\n\n  const VarDecl *getVarDecl() const {\n    return static_cast<VarDecl*>(Data1.getPointer());\n  }\n\n  // Get statement end of which triggered the destructor call.\n  const Stmt *getTriggerStmt() const {\n    return static_cast<Stmt*>(Data2.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGAutomaticObjDtor() = default;\n\n  static bool isKind(const CFGElement &elem) {\n    return elem.getKind() == AutomaticObjectDtor;\n  }\n};\n\n/// Represents C++ object destructor generated from a call to delete.\nclass CFGDeleteDtor : public CFGImplicitDtor {\npublic:\n  CFGDeleteDtor(const CXXRecordDecl *RD, const CXXDeleteExpr *DE)\n      : CFGImplicitDtor(DeleteDtor, RD, DE) {}\n\n  const CXXRecordDecl *getCXXRecordDecl() const {\n    return static_cast<CXXRecordDecl*>(Data1.getPointer());\n  }\n\n  // Get Delete expression which triggered the destructor call.\n  const CXXDeleteExpr *getDeleteExpr() const {\n    return static_cast<CXXDeleteExpr *>(Data2.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGDeleteDtor() = default;\n\n  static bool isKind(const CFGElement &elem) {\n    return elem.getKind() == DeleteDtor;\n  }\n};\n\n/// Represents C++ object destructor implicitly generated for base object in\n/// destructor.\nclass CFGBaseDtor : public CFGImplicitDtor {\npublic:\n  CFGBaseDtor(const CXXBaseSpecifier *base)\n      : CFGImplicitDtor(BaseDtor, base) {}\n\n  const CXXBaseSpecifier *getBaseSpecifier() const {\n    return static_cast<const CXXBaseSpecifier*>(Data1.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGBaseDtor() = default;\n\n  static bool isKind(const CFGElement &E) {\n    return E.getKind() == BaseDtor;\n  }\n};\n\n/// Represents C++ object destructor implicitly generated for member object in\n/// destructor.\nclass CFGMemberDtor : public CFGImplicitDtor {\npublic:\n  CFGMemberDtor(const FieldDecl *field)\n      : CFGImplicitDtor(MemberDtor, field, nullptr) {}\n\n  const FieldDecl *getFieldDecl() const {\n    return static_cast<const FieldDecl*>(Data1.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGMemberDtor() = default;\n\n  static bool isKind(const CFGElement &E) {\n    return E.getKind() == MemberDtor;\n  }\n};\n\n/// Represents C++ object destructor implicitly generated at the end of full\n/// expression for temporary object.\nclass CFGTemporaryDtor : public CFGImplicitDtor {\npublic:\n  CFGTemporaryDtor(CXXBindTemporaryExpr *expr)\n      : CFGImplicitDtor(TemporaryDtor, expr, nullptr) {}\n\n  const CXXBindTemporaryExpr *getBindTemporaryExpr() const {\n    return static_cast<const CXXBindTemporaryExpr *>(Data1.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGTemporaryDtor() = default;\n\n  static bool isKind(const CFGElement &E) {\n    return E.getKind() == TemporaryDtor;\n  }\n};\n\n/// Represents CFGBlock terminator statement.\n///\nclass CFGTerminator {\npublic:\n  enum Kind {\n    /// A branch that corresponds to a statement in the code,\n    /// such as an if-statement.\n    StmtBranch,\n    /// A branch in control flow of destructors of temporaries. In this case\n    /// terminator statement is the same statement that branches control flow\n    /// in evaluation of matching full expression.\n    TemporaryDtorsBranch,\n    /// A shortcut around virtual base initializers. It gets taken when\n    /// virtual base classes have already been initialized by the constructor\n    /// of the most derived class while we're in the base class.\n    VirtualBaseBranch,\n\n    /// Number of different kinds, for sanity checks. We subtract 1 so that\n    /// to keep receiving compiler warnings when we don't cover all enum values\n    /// in a switch.\n    NumKindsMinusOne = VirtualBaseBranch\n  };\n\nprivate:\n  static constexpr int KindBits = 2;\n  static_assert((1 << KindBits) > NumKindsMinusOne,\n                \"Not enough room for kind!\");\n  llvm::PointerIntPair<Stmt *, KindBits> Data;\n\npublic:\n  CFGTerminator() { assert(!isValid()); }\n  CFGTerminator(Stmt *S, Kind K = StmtBranch) : Data(S, K) {}\n\n  bool isValid() const { return Data.getOpaqueValue() != nullptr; }\n  Stmt *getStmt() { return Data.getPointer(); }\n  const Stmt *getStmt() const { return Data.getPointer(); }\n  Kind getKind() const { return static_cast<Kind>(Data.getInt()); }\n\n  bool isStmtBranch() const {\n    return getKind() == StmtBranch;\n  }\n  bool isTemporaryDtorsBranch() const {\n    return getKind() == TemporaryDtorsBranch;\n  }\n  bool isVirtualBaseBranch() const {\n    return getKind() == VirtualBaseBranch;\n  }\n};\n\n/// Represents a single basic block in a source-level CFG.\n///  It consists of:\n///\n///  (1) A set of statements/expressions (which may contain subexpressions).\n///  (2) A \"terminator\" statement (not in the set of statements).\n///  (3) A list of successors and predecessors.\n///\n/// Terminator: The terminator represents the type of control-flow that occurs\n/// at the end of the basic block.  The terminator is a Stmt* referring to an\n/// AST node that has control-flow: if-statements, breaks, loops, etc.\n/// If the control-flow is conditional, the condition expression will appear\n/// within the set of statements in the block (usually the last statement).\n///\n/// Predecessors: the order in the set of predecessors is arbitrary.\n///\n/// Successors: the order in the set of successors is NOT arbitrary.  We\n///  currently have the following orderings based on the terminator:\n///\n///     Terminator     |   Successor Ordering\n///  ------------------|------------------------------------\n///       if           |  Then Block;  Else Block\n///     ? operator     |  LHS expression;  RHS expression\n///     logical and/or |  expression that consumes the op, RHS\n///     vbase inits    |  already handled by the most derived class; not yet\n///\n/// But note that any of that may be NULL in case of optimized-out edges.\nclass CFGBlock {\n  class ElementList {\n    using ImplTy = BumpVector<CFGElement>;\n\n    ImplTy Impl;\n\n  public:\n    ElementList(BumpVectorContext &C) : Impl(C, 4) {}\n\n    using iterator = std::reverse_iterator<ImplTy::iterator>;\n    using const_iterator = std::reverse_iterator<ImplTy::const_iterator>;\n    using reverse_iterator = ImplTy::iterator;\n    using const_reverse_iterator = ImplTy::const_iterator;\n    using const_reference = ImplTy::const_reference;\n\n    void push_back(CFGElement e, BumpVectorContext &C) { Impl.push_back(e, C); }\n\n    reverse_iterator insert(reverse_iterator I, size_t Cnt, CFGElement E,\n        BumpVectorContext &C) {\n      return Impl.insert(I, Cnt, E, C);\n    }\n\n    const_reference front() const { return Impl.back(); }\n    const_reference back() const { return Impl.front(); }\n\n    iterator begin() { return Impl.rbegin(); }\n    iterator end() { return Impl.rend(); }\n    const_iterator begin() const { return Impl.rbegin(); }\n    const_iterator end() const { return Impl.rend(); }\n    reverse_iterator rbegin() { return Impl.begin(); }\n    reverse_iterator rend() { return Impl.end(); }\n    const_reverse_iterator rbegin() const { return Impl.begin(); }\n    const_reverse_iterator rend() const { return Impl.end(); }\n\n    CFGElement operator[](size_t i) const  {\n      assert(i < Impl.size());\n      return Impl[Impl.size() - 1 - i];\n    }\n\n    size_t size() const { return Impl.size(); }\n    bool empty() const { return Impl.empty(); }\n  };\n\n  /// A convenience class for comparing CFGElements, since methods of CFGBlock\n  /// like operator[] return CFGElements by value. This is practically a wrapper\n  /// around a (CFGBlock, Index) pair.\n  template <bool IsConst> class ElementRefImpl {\n\n    template <bool IsOtherConst> friend class ElementRefImpl;\n\n    using CFGBlockPtr =\n        std::conditional_t<IsConst, const CFGBlock *, CFGBlock *>;\n\n    using CFGElementPtr =\n        std::conditional_t<IsConst, const CFGElement *, CFGElement *>;\n\n  protected:\n    CFGBlockPtr Parent;\n    size_t Index;\n\n  public:\n    ElementRefImpl(CFGBlockPtr Parent, size_t Index)\n        : Parent(Parent), Index(Index) {}\n\n    template <bool IsOtherConst>\n    ElementRefImpl(ElementRefImpl<IsOtherConst> Other)\n        : ElementRefImpl(Other.Parent, Other.Index) {}\n\n    size_t getIndexInBlock() const { return Index; }\n\n    CFGBlockPtr getParent() { return Parent; }\n    CFGBlockPtr getParent() const { return Parent; }\n\n    bool operator<(ElementRefImpl Other) const {\n      return std::make_pair(Parent, Index) <\n             std::make_pair(Other.Parent, Other.Index);\n    }\n\n    bool operator==(ElementRefImpl Other) const {\n      return Parent == Other.Parent && Index == Other.Index;\n    }\n\n    bool operator!=(ElementRefImpl Other) const { return !(*this == Other); }\n    CFGElement operator*() const { return (*Parent)[Index]; }\n    CFGElementPtr operator->() const { return &*(Parent->begin() + Index); }\n\n    void dumpToStream(llvm::raw_ostream &OS) const {\n      OS << getIndexInBlock() + 1 << \": \";\n      (*this)->dumpToStream(OS);\n    }\n\n    void dump() const {\n      dumpToStream(llvm::errs());\n    }\n  };\n\n  template <bool IsReverse, bool IsConst> class ElementRefIterator {\n\n    template <bool IsOtherReverse, bool IsOtherConst>\n    friend class ElementRefIterator;\n\n    using CFGBlockRef =\n        std::conditional_t<IsConst, const CFGBlock *, CFGBlock *>;\n\n    using UnderlayingIteratorTy = std::conditional_t<\n        IsConst,\n        std::conditional_t<IsReverse, ElementList::const_reverse_iterator,\n                           ElementList::const_iterator>,\n        std::conditional_t<IsReverse, ElementList::reverse_iterator,\n                           ElementList::iterator>>;\n\n    using IteratorTraits = typename std::iterator_traits<UnderlayingIteratorTy>;\n    using ElementRef = typename CFGBlock::ElementRefImpl<IsConst>;\n\n  public:\n    using difference_type = typename IteratorTraits::difference_type;\n    using value_type = ElementRef;\n    using pointer = ElementRef *;\n    using iterator_category = typename IteratorTraits::iterator_category;\n\n  private:\n    CFGBlockRef Parent;\n    UnderlayingIteratorTy Pos;\n\n  public:\n    ElementRefIterator(CFGBlockRef Parent, UnderlayingIteratorTy Pos)\n        : Parent(Parent), Pos(Pos) {}\n\n    template <bool IsOtherConst>\n    ElementRefIterator(ElementRefIterator<false, IsOtherConst> E)\n        : ElementRefIterator(E.Parent, E.Pos.base()) {}\n\n    template <bool IsOtherConst>\n    ElementRefIterator(ElementRefIterator<true, IsOtherConst> E)\n        : ElementRefIterator(E.Parent, llvm::make_reverse_iterator(E.Pos)) {}\n\n    bool operator<(ElementRefIterator Other) const {\n      assert(Parent == Other.Parent);\n      return Pos < Other.Pos;\n    }\n\n    bool operator==(ElementRefIterator Other) const {\n      return Parent == Other.Parent && Pos == Other.Pos;\n    }\n\n    bool operator!=(ElementRefIterator Other) const {\n      return !(*this == Other);\n    }\n\n  private:\n    template <bool IsOtherConst>\n    static size_t\n    getIndexInBlock(CFGBlock::ElementRefIterator<true, IsOtherConst> E) {\n      return E.Parent->size() - (E.Pos - E.Parent->rbegin()) - 1;\n    }\n\n    template <bool IsOtherConst>\n    static size_t\n    getIndexInBlock(CFGBlock::ElementRefIterator<false, IsOtherConst> E) {\n      return E.Pos - E.Parent->begin();\n    }\n\n  public:\n    value_type operator*() { return {Parent, getIndexInBlock(*this)}; }\n\n    difference_type operator-(ElementRefIterator Other) const {\n      return Pos - Other.Pos;\n    }\n\n    ElementRefIterator operator++() {\n      ++this->Pos;\n      return *this;\n    }\n    ElementRefIterator operator++(int) {\n      ElementRefIterator Ret = *this;\n      ++*this;\n      return Ret;\n    }\n    ElementRefIterator operator+(size_t count) {\n      this->Pos += count;\n      return *this;\n    }\n    ElementRefIterator operator-(size_t count) {\n      this->Pos -= count;\n      return *this;\n    }\n  };\n\npublic:\n  /// The set of statements in the basic block.\n  ElementList Elements;\n\n  /// An (optional) label that prefixes the executable statements in the block.\n  /// When this variable is non-NULL, it is either an instance of LabelStmt,\n  /// SwitchCase or CXXCatchStmt.\n  Stmt *Label = nullptr;\n\n  /// The terminator for a basic block that indicates the type of control-flow\n  /// that occurs between a block and its successors.\n  CFGTerminator Terminator;\n\n  /// Some blocks are used to represent the \"loop edge\" to the start of a loop\n  /// from within the loop body. This Stmt* will be refer to the loop statement\n  /// for such blocks (and be null otherwise).\n  const Stmt *LoopTarget = nullptr;\n\n  /// A numerical ID assigned to a CFGBlock during construction of the CFG.\n  unsigned BlockID;\n\npublic:\n  /// This class represents a potential adjacent block in the CFG.  It encodes\n  /// whether or not the block is actually reachable, or can be proved to be\n  /// trivially unreachable.  For some cases it allows one to encode scenarios\n  /// where a block was substituted because the original (now alternate) block\n  /// is unreachable.\n  class AdjacentBlock {\n    enum Kind {\n      AB_Normal,\n      AB_Unreachable,\n      AB_Alternate\n    };\n\n    CFGBlock *ReachableBlock;\n    llvm::PointerIntPair<CFGBlock *, 2> UnreachableBlock;\n\n  public:\n    /// Construct an AdjacentBlock with a possibly unreachable block.\n    AdjacentBlock(CFGBlock *B, bool IsReachable);\n\n    /// Construct an AdjacentBlock with a reachable block and an alternate\n    /// unreachable block.\n    AdjacentBlock(CFGBlock *B, CFGBlock *AlternateBlock);\n\n    /// Get the reachable block, if one exists.\n    CFGBlock *getReachableBlock() const {\n      return ReachableBlock;\n    }\n\n    /// Get the potentially unreachable block.\n    CFGBlock *getPossiblyUnreachableBlock() const {\n      return UnreachableBlock.getPointer();\n    }\n\n    /// Provide an implicit conversion to CFGBlock* so that\n    /// AdjacentBlock can be substituted for CFGBlock*.\n    operator CFGBlock*() const {\n      return getReachableBlock();\n    }\n\n    CFGBlock& operator *() const {\n      return *getReachableBlock();\n    }\n\n    CFGBlock* operator ->() const {\n      return getReachableBlock();\n    }\n\n    bool isReachable() const {\n      Kind K = (Kind) UnreachableBlock.getInt();\n      return K == AB_Normal || K == AB_Alternate;\n    }\n  };\n\nprivate:\n  /// Keep track of the predecessor / successor CFG blocks.\n  using AdjacentBlocks = BumpVector<AdjacentBlock>;\n  AdjacentBlocks Preds;\n  AdjacentBlocks Succs;\n\n  /// This bit is set when the basic block contains a function call\n  /// or implicit destructor that is attributed as 'noreturn'. In that case,\n  /// control cannot technically ever proceed past this block. All such blocks\n  /// will have a single immediate successor: the exit block. This allows them\n  /// to be easily reached from the exit block and using this bit quickly\n  /// recognized without scanning the contents of the block.\n  ///\n  /// Optimization Note: This bit could be profitably folded with Terminator's\n  /// storage if the memory usage of CFGBlock becomes an issue.\n  unsigned HasNoReturnElement : 1;\n\n  /// The parent CFG that owns this CFGBlock.\n  CFG *Parent;\n\npublic:\n  explicit CFGBlock(unsigned blockid, BumpVectorContext &C, CFG *parent)\n      : Elements(C), Terminator(nullptr), BlockID(blockid), Preds(C, 1),\n        Succs(C, 1), HasNoReturnElement(false), Parent(parent) {}\n\n  // Statement iterators\n  using iterator = ElementList::iterator;\n  using const_iterator = ElementList::const_iterator;\n  using reverse_iterator = ElementList::reverse_iterator;\n  using const_reverse_iterator = ElementList::const_reverse_iterator;\n\n  size_t getIndexInCFG() const;\n\n  CFGElement                 front()       const { return Elements.front();   }\n  CFGElement                 back()        const { return Elements.back();    }\n\n  iterator                   begin()             { return Elements.begin();   }\n  iterator                   end()               { return Elements.end();     }\n  const_iterator             begin()       const { return Elements.begin();   }\n  const_iterator             end()         const { return Elements.end();     }\n\n  reverse_iterator           rbegin()            { return Elements.rbegin();  }\n  reverse_iterator           rend()              { return Elements.rend();    }\n  const_reverse_iterator     rbegin()      const { return Elements.rbegin();  }\n  const_reverse_iterator     rend()        const { return Elements.rend();    }\n\n  using CFGElementRef = ElementRefImpl<false>;\n  using ConstCFGElementRef = ElementRefImpl<true>;\n\n  using ref_iterator = ElementRefIterator<false, false>;\n  using ref_iterator_range = llvm::iterator_range<ref_iterator>;\n  using const_ref_iterator = ElementRefIterator<false, true>;\n  using const_ref_iterator_range = llvm::iterator_range<const_ref_iterator>;\n\n  using reverse_ref_iterator = ElementRefIterator<true, false>;\n  using reverse_ref_iterator_range = llvm::iterator_range<reverse_ref_iterator>;\n\n  using const_reverse_ref_iterator = ElementRefIterator<true, true>;\n  using const_reverse_ref_iterator_range =\n      llvm::iterator_range<const_reverse_ref_iterator>;\n\n  ref_iterator ref_begin() { return {this, begin()}; }\n  ref_iterator ref_end() { return {this, end()}; }\n  const_ref_iterator ref_begin() const { return {this, begin()}; }\n  const_ref_iterator ref_end() const { return {this, end()}; }\n\n  reverse_ref_iterator rref_begin() { return {this, rbegin()}; }\n  reverse_ref_iterator rref_end() { return {this, rend()}; }\n  const_reverse_ref_iterator rref_begin() const { return {this, rbegin()}; }\n  const_reverse_ref_iterator rref_end() const { return {this, rend()}; }\n\n  ref_iterator_range refs() { return {ref_begin(), ref_end()}; }\n  const_ref_iterator_range refs() const { return {ref_begin(), ref_end()}; }\n  reverse_ref_iterator_range rrefs() { return {rref_begin(), rref_end()}; }\n  const_reverse_ref_iterator_range rrefs() const {\n    return {rref_begin(), rref_end()};\n  }\n\n  unsigned                   size()        const { return Elements.size();    }\n  bool                       empty()       const { return Elements.empty();   }\n\n  CFGElement operator[](size_t i) const  { return Elements[i]; }\n\n  // CFG iterators\n  using pred_iterator = AdjacentBlocks::iterator;\n  using const_pred_iterator = AdjacentBlocks::const_iterator;\n  using pred_reverse_iterator = AdjacentBlocks::reverse_iterator;\n  using const_pred_reverse_iterator = AdjacentBlocks::const_reverse_iterator;\n  using pred_range = llvm::iterator_range<pred_iterator>;\n  using pred_const_range = llvm::iterator_range<const_pred_iterator>;\n\n  using succ_iterator = AdjacentBlocks::iterator;\n  using const_succ_iterator = AdjacentBlocks::const_iterator;\n  using succ_reverse_iterator = AdjacentBlocks::reverse_iterator;\n  using const_succ_reverse_iterator = AdjacentBlocks::const_reverse_iterator;\n  using succ_range = llvm::iterator_range<succ_iterator>;\n  using succ_const_range = llvm::iterator_range<const_succ_iterator>;\n\n  pred_iterator                pred_begin()        { return Preds.begin();   }\n  pred_iterator                pred_end()          { return Preds.end();     }\n  const_pred_iterator          pred_begin()  const { return Preds.begin();   }\n  const_pred_iterator          pred_end()    const { return Preds.end();     }\n\n  pred_reverse_iterator        pred_rbegin()       { return Preds.rbegin();  }\n  pred_reverse_iterator        pred_rend()         { return Preds.rend();    }\n  const_pred_reverse_iterator  pred_rbegin() const { return Preds.rbegin();  }\n  const_pred_reverse_iterator  pred_rend()   const { return Preds.rend();    }\n\n  pred_range preds() {\n    return pred_range(pred_begin(), pred_end());\n  }\n\n  pred_const_range preds() const {\n    return pred_const_range(pred_begin(), pred_end());\n  }\n\n  succ_iterator                succ_begin()        { return Succs.begin();   }\n  succ_iterator                succ_end()          { return Succs.end();     }\n  const_succ_iterator          succ_begin()  const { return Succs.begin();   }\n  const_succ_iterator          succ_end()    const { return Succs.end();     }\n\n  succ_reverse_iterator        succ_rbegin()       { return Succs.rbegin();  }\n  succ_reverse_iterator        succ_rend()         { return Succs.rend();    }\n  const_succ_reverse_iterator  succ_rbegin() const { return Succs.rbegin();  }\n  const_succ_reverse_iterator  succ_rend()   const { return Succs.rend();    }\n\n  succ_range succs() {\n    return succ_range(succ_begin(), succ_end());\n  }\n\n  succ_const_range succs() const {\n    return succ_const_range(succ_begin(), succ_end());\n  }\n\n  unsigned                     succ_size()   const { return Succs.size();    }\n  bool                         succ_empty()  const { return Succs.empty();   }\n\n  unsigned                     pred_size()   const { return Preds.size();    }\n  bool                         pred_empty()  const { return Preds.empty();   }\n\n\n  class FilterOptions {\n  public:\n    unsigned IgnoreNullPredecessors : 1;\n    unsigned IgnoreDefaultsWithCoveredEnums : 1;\n\n    FilterOptions()\n        : IgnoreNullPredecessors(1), IgnoreDefaultsWithCoveredEnums(0) {}\n  };\n\n  static bool FilterEdge(const FilterOptions &F, const CFGBlock *Src,\n       const CFGBlock *Dst);\n\n  template <typename IMPL, bool IsPred>\n  class FilteredCFGBlockIterator {\n  private:\n    IMPL I, E;\n    const FilterOptions F;\n    const CFGBlock *From;\n\n  public:\n    explicit FilteredCFGBlockIterator(const IMPL &i, const IMPL &e,\n                                      const CFGBlock *from,\n                                      const FilterOptions &f)\n        : I(i), E(e), F(f), From(from) {\n      while (hasMore() && Filter(*I))\n        ++I;\n    }\n\n    bool hasMore() const { return I != E; }\n\n    FilteredCFGBlockIterator &operator++() {\n      do { ++I; } while (hasMore() && Filter(*I));\n      return *this;\n    }\n\n    const CFGBlock *operator*() const { return *I; }\n\n  private:\n    bool Filter(const CFGBlock *To) {\n      return IsPred ? FilterEdge(F, To, From) : FilterEdge(F, From, To);\n    }\n  };\n\n  using filtered_pred_iterator =\n      FilteredCFGBlockIterator<const_pred_iterator, true>;\n\n  using filtered_succ_iterator =\n      FilteredCFGBlockIterator<const_succ_iterator, false>;\n\n  filtered_pred_iterator filtered_pred_start_end(const FilterOptions &f) const {\n    return filtered_pred_iterator(pred_begin(), pred_end(), this, f);\n  }\n\n  filtered_succ_iterator filtered_succ_start_end(const FilterOptions &f) const {\n    return filtered_succ_iterator(succ_begin(), succ_end(), this, f);\n  }\n\n  // Manipulation of block contents\n\n  void setTerminator(CFGTerminator Term) { Terminator = Term; }\n  void setLabel(Stmt *Statement) { Label = Statement; }\n  void setLoopTarget(const Stmt *loopTarget) { LoopTarget = loopTarget; }\n  void setHasNoReturnElement() { HasNoReturnElement = true; }\n\n  /// Returns true if the block would eventually end with a sink (a noreturn\n  /// node).\n  bool isInevitablySinking() const;\n\n  CFGTerminator getTerminator() const { return Terminator; }\n\n  Stmt *getTerminatorStmt() { return Terminator.getStmt(); }\n  const Stmt *getTerminatorStmt() const { return Terminator.getStmt(); }\n\n  /// \\returns the last (\\c rbegin()) condition, e.g. observe the following code\n  /// snippet:\n  ///   if (A && B && C)\n  /// A block would be created for \\c A, \\c B, and \\c C. For the latter,\n  /// \\c getTerminatorStmt() would retrieve the entire condition, rather than\n  /// C itself, while this method would only return C.\n  const Expr *getLastCondition() const;\n\n  Stmt *getTerminatorCondition(bool StripParens = true);\n\n  const Stmt *getTerminatorCondition(bool StripParens = true) const {\n    return const_cast<CFGBlock*>(this)->getTerminatorCondition(StripParens);\n  }\n\n  const Stmt *getLoopTarget() const { return LoopTarget; }\n\n  Stmt *getLabel() { return Label; }\n  const Stmt *getLabel() const { return Label; }\n\n  bool hasNoReturnElement() const { return HasNoReturnElement; }\n\n  unsigned getBlockID() const { return BlockID; }\n\n  CFG *getParent() const { return Parent; }\n\n  void dump() const;\n\n  void dump(const CFG *cfg, const LangOptions &LO, bool ShowColors = false) const;\n  void print(raw_ostream &OS, const CFG* cfg, const LangOptions &LO,\n             bool ShowColors) const;\n\n  void printTerminator(raw_ostream &OS, const LangOptions &LO) const;\n  void printTerminatorJson(raw_ostream &Out, const LangOptions &LO,\n                           bool AddQuotes) const;\n\n  void printAsOperand(raw_ostream &OS, bool /*PrintType*/) {\n    OS << \"BB#\" << getBlockID();\n  }\n\n  /// Adds a (potentially unreachable) successor block to the current block.\n  void addSuccessor(AdjacentBlock Succ, BumpVectorContext &C);\n\n  void appendStmt(Stmt *statement, BumpVectorContext &C) {\n    Elements.push_back(CFGStmt(statement), C);\n  }\n\n  void appendConstructor(CXXConstructExpr *CE, const ConstructionContext *CC,\n                         BumpVectorContext &C) {\n    Elements.push_back(CFGConstructor(CE, CC), C);\n  }\n\n  void appendCXXRecordTypedCall(Expr *E,\n                                const ConstructionContext *CC,\n                                BumpVectorContext &C) {\n    Elements.push_back(CFGCXXRecordTypedCall(E, CC), C);\n  }\n\n  void appendInitializer(CXXCtorInitializer *initializer,\n                        BumpVectorContext &C) {\n    Elements.push_back(CFGInitializer(initializer), C);\n  }\n\n  void appendNewAllocator(CXXNewExpr *NE,\n                          BumpVectorContext &C) {\n    Elements.push_back(CFGNewAllocator(NE), C);\n  }\n\n  void appendScopeBegin(const VarDecl *VD, const Stmt *S,\n                        BumpVectorContext &C) {\n    Elements.push_back(CFGScopeBegin(VD, S), C);\n  }\n\n  void prependScopeBegin(const VarDecl *VD, const Stmt *S,\n                         BumpVectorContext &C) {\n    Elements.insert(Elements.rbegin(), 1, CFGScopeBegin(VD, S), C);\n  }\n\n  void appendScopeEnd(const VarDecl *VD, const Stmt *S, BumpVectorContext &C) {\n    Elements.push_back(CFGScopeEnd(VD, S), C);\n  }\n\n  void prependScopeEnd(const VarDecl *VD, const Stmt *S, BumpVectorContext &C) {\n    Elements.insert(Elements.rbegin(), 1, CFGScopeEnd(VD, S), C);\n  }\n\n  void appendBaseDtor(const CXXBaseSpecifier *BS, BumpVectorContext &C) {\n    Elements.push_back(CFGBaseDtor(BS), C);\n  }\n\n  void appendMemberDtor(FieldDecl *FD, BumpVectorContext &C) {\n    Elements.push_back(CFGMemberDtor(FD), C);\n  }\n\n  void appendTemporaryDtor(CXXBindTemporaryExpr *E, BumpVectorContext &C) {\n    Elements.push_back(CFGTemporaryDtor(E), C);\n  }\n\n  void appendAutomaticObjDtor(VarDecl *VD, Stmt *S, BumpVectorContext &C) {\n    Elements.push_back(CFGAutomaticObjDtor(VD, S), C);\n  }\n\n  void appendLifetimeEnds(VarDecl *VD, Stmt *S, BumpVectorContext &C) {\n    Elements.push_back(CFGLifetimeEnds(VD, S), C);\n  }\n\n  void appendLoopExit(const Stmt *LoopStmt, BumpVectorContext &C) {\n    Elements.push_back(CFGLoopExit(LoopStmt), C);\n  }\n\n  void appendDeleteDtor(CXXRecordDecl *RD, CXXDeleteExpr *DE, BumpVectorContext &C) {\n    Elements.push_back(CFGDeleteDtor(RD, DE), C);\n  }\n\n  // Destructors must be inserted in reversed order. So insertion is in two\n  // steps. First we prepare space for some number of elements, then we insert\n  // the elements beginning at the last position in prepared space.\n  iterator beginAutomaticObjDtorsInsert(iterator I, size_t Cnt,\n      BumpVectorContext &C) {\n    return iterator(Elements.insert(I.base(), Cnt,\n                                    CFGAutomaticObjDtor(nullptr, nullptr), C));\n  }\n  iterator insertAutomaticObjDtor(iterator I, VarDecl *VD, Stmt *S) {\n    *I = CFGAutomaticObjDtor(VD, S);\n    return ++I;\n  }\n\n  // Scope leaving must be performed in reversed order. So insertion is in two\n  // steps. First we prepare space for some number of elements, then we insert\n  // the elements beginning at the last position in prepared space.\n  iterator beginLifetimeEndsInsert(iterator I, size_t Cnt,\n                                   BumpVectorContext &C) {\n    return iterator(\n        Elements.insert(I.base(), Cnt, CFGLifetimeEnds(nullptr, nullptr), C));\n  }\n  iterator insertLifetimeEnds(iterator I, VarDecl *VD, Stmt *S) {\n    *I = CFGLifetimeEnds(VD, S);\n    return ++I;\n  }\n\n  // Scope leaving must be performed in reversed order. So insertion is in two\n  // steps. First we prepare space for some number of elements, then we insert\n  // the elements beginning at the last position in prepared space.\n  iterator beginScopeEndInsert(iterator I, size_t Cnt, BumpVectorContext &C) {\n    return iterator(\n        Elements.insert(I.base(), Cnt, CFGScopeEnd(nullptr, nullptr), C));\n  }\n  iterator insertScopeEnd(iterator I, VarDecl *VD, Stmt *S) {\n    *I = CFGScopeEnd(VD, S);\n    return ++I;\n  }\n};\n\n/// CFGCallback defines methods that should be called when a logical\n/// operator error is found when building the CFG.\nclass CFGCallback {\npublic:\n  CFGCallback() = default;\n  virtual ~CFGCallback() = default;\n\n  virtual void compareAlwaysTrue(const BinaryOperator *B, bool isAlwaysTrue) {}\n  virtual void compareBitwiseEquality(const BinaryOperator *B,\n                                      bool isAlwaysTrue) {}\n  virtual void compareBitwiseOr(const BinaryOperator *B) {}\n};\n\n/// Represents a source-level, intra-procedural CFG that represents the\n///  control-flow of a Stmt.  The Stmt can represent an entire function body,\n///  or a single expression.  A CFG will always contain one empty block that\n///  represents the Exit point of the CFG.  A CFG will also contain a designated\n///  Entry block.  The CFG solely represents control-flow; it consists of\n///  CFGBlocks which are simply containers of Stmt*'s in the AST the CFG\n///  was constructed from.\nclass CFG {\npublic:\n  //===--------------------------------------------------------------------===//\n  // CFG Construction & Manipulation.\n  //===--------------------------------------------------------------------===//\n\n  class BuildOptions {\n    std::bitset<Stmt::lastStmtConstant> alwaysAddMask;\n\n  public:\n    using ForcedBlkExprs = llvm::DenseMap<const Stmt *, const CFGBlock *>;\n\n    ForcedBlkExprs **forcedBlkExprs = nullptr;\n    CFGCallback *Observer = nullptr;\n    bool PruneTriviallyFalseEdges = true;\n    bool AddEHEdges = false;\n    bool AddInitializers = false;\n    bool AddImplicitDtors = false;\n    bool AddLifetime = false;\n    bool AddLoopExit = false;\n    bool AddTemporaryDtors = false;\n    bool AddScopes = false;\n    bool AddStaticInitBranches = false;\n    bool AddCXXNewAllocator = false;\n    bool AddCXXDefaultInitExprInCtors = false;\n    bool AddCXXDefaultInitExprInAggregates = false;\n    bool AddRichCXXConstructors = false;\n    bool MarkElidedCXXConstructors = false;\n    bool AddVirtualBaseBranches = false;\n    bool OmitImplicitValueInitializers = false;\n\n    BuildOptions() = default;\n\n    bool alwaysAdd(const Stmt *stmt) const {\n      return alwaysAddMask[stmt->getStmtClass()];\n    }\n\n    BuildOptions &setAlwaysAdd(Stmt::StmtClass stmtClass, bool val = true) {\n      alwaysAddMask[stmtClass] = val;\n      return *this;\n    }\n\n    BuildOptions &setAllAlwaysAdd() {\n      alwaysAddMask.set();\n      return *this;\n    }\n  };\n\n  /// Builds a CFG from an AST.\n  static std::unique_ptr<CFG> buildCFG(const Decl *D, Stmt *AST, ASTContext *C,\n                                       const BuildOptions &BO);\n\n  /// Create a new block in the CFG. The CFG owns the block; the caller should\n  /// not directly free it.\n  CFGBlock *createBlock();\n\n  /// Set the entry block of the CFG. This is typically used only during CFG\n  /// construction. Most CFG clients expect that the entry block has no\n  /// predecessors and contains no statements.\n  void setEntry(CFGBlock *B) { Entry = B; }\n\n  /// Set the block used for indirect goto jumps. This is typically used only\n  /// during CFG construction.\n  void setIndirectGotoBlock(CFGBlock *B) { IndirectGotoBlock = B; }\n\n  //===--------------------------------------------------------------------===//\n  // Block Iterators\n  //===--------------------------------------------------------------------===//\n\n  using CFGBlockListTy = BumpVector<CFGBlock *>;\n  using iterator = CFGBlockListTy::iterator;\n  using const_iterator = CFGBlockListTy::const_iterator;\n  using reverse_iterator = std::reverse_iterator<iterator>;\n  using const_reverse_iterator = std::reverse_iterator<const_iterator>;\n\n  CFGBlock &                front()                { return *Blocks.front(); }\n  CFGBlock &                back()                 { return *Blocks.back(); }\n\n  iterator                  begin()                { return Blocks.begin(); }\n  iterator                  end()                  { return Blocks.end(); }\n  const_iterator            begin()       const    { return Blocks.begin(); }\n  const_iterator            end()         const    { return Blocks.end(); }\n\n  iterator nodes_begin() { return iterator(Blocks.begin()); }\n  iterator nodes_end() { return iterator(Blocks.end()); }\n\n  llvm::iterator_range<iterator> nodes() { return {begin(), end()}; }\n  llvm::iterator_range<const_iterator> const_nodes() const {\n    return {begin(), end()};\n  }\n\n  const_iterator nodes_begin() const { return const_iterator(Blocks.begin()); }\n  const_iterator nodes_end() const { return const_iterator(Blocks.end()); }\n\n  reverse_iterator          rbegin()               { return Blocks.rbegin(); }\n  reverse_iterator          rend()                 { return Blocks.rend(); }\n  const_reverse_iterator    rbegin()      const    { return Blocks.rbegin(); }\n  const_reverse_iterator    rend()        const    { return Blocks.rend(); }\n\n  llvm::iterator_range<reverse_iterator> reverse_nodes() {\n    return {rbegin(), rend()};\n  }\n  llvm::iterator_range<const_reverse_iterator> const_reverse_nodes() const {\n    return {rbegin(), rend()};\n  }\n\n  CFGBlock &                getEntry()             { return *Entry; }\n  const CFGBlock &          getEntry()    const    { return *Entry; }\n  CFGBlock &                getExit()              { return *Exit; }\n  const CFGBlock &          getExit()     const    { return *Exit; }\n\n  CFGBlock *       getIndirectGotoBlock() { return IndirectGotoBlock; }\n  const CFGBlock * getIndirectGotoBlock() const { return IndirectGotoBlock; }\n\n  using try_block_iterator = std::vector<const CFGBlock *>::const_iterator;\n\n  try_block_iterator try_blocks_begin() const {\n    return TryDispatchBlocks.begin();\n  }\n\n  try_block_iterator try_blocks_end() const {\n    return TryDispatchBlocks.end();\n  }\n\n  void addTryDispatchBlock(const CFGBlock *block) {\n    TryDispatchBlocks.push_back(block);\n  }\n\n  /// Records a synthetic DeclStmt and the DeclStmt it was constructed from.\n  ///\n  /// The CFG uses synthetic DeclStmts when a single AST DeclStmt contains\n  /// multiple decls.\n  void addSyntheticDeclStmt(const DeclStmt *Synthetic,\n                            const DeclStmt *Source) {\n    assert(Synthetic->isSingleDecl() && \"Can handle single declarations only\");\n    assert(Synthetic != Source && \"Don't include original DeclStmts in map\");\n    assert(!SyntheticDeclStmts.count(Synthetic) && \"Already in map\");\n    SyntheticDeclStmts[Synthetic] = Source;\n  }\n\n  using synthetic_stmt_iterator =\n      llvm::DenseMap<const DeclStmt *, const DeclStmt *>::const_iterator;\n  using synthetic_stmt_range = llvm::iterator_range<synthetic_stmt_iterator>;\n\n  /// Iterates over synthetic DeclStmts in the CFG.\n  ///\n  /// Each element is a (synthetic statement, source statement) pair.\n  ///\n  /// \\sa addSyntheticDeclStmt\n  synthetic_stmt_iterator synthetic_stmt_begin() const {\n    return SyntheticDeclStmts.begin();\n  }\n\n  /// \\sa synthetic_stmt_begin\n  synthetic_stmt_iterator synthetic_stmt_end() const {\n    return SyntheticDeclStmts.end();\n  }\n\n  /// \\sa synthetic_stmt_begin\n  synthetic_stmt_range synthetic_stmts() const {\n    return synthetic_stmt_range(synthetic_stmt_begin(), synthetic_stmt_end());\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Member templates useful for various batch operations over CFGs.\n  //===--------------------------------------------------------------------===//\n\n  template <typename CALLBACK>\n  void VisitBlockStmts(CALLBACK& O) const {\n    for (const_iterator I = begin(), E = end(); I != E; ++I)\n      for (CFGBlock::const_iterator BI = (*I)->begin(), BE = (*I)->end();\n           BI != BE; ++BI) {\n        if (Optional<CFGStmt> stmt = BI->getAs<CFGStmt>())\n          O(const_cast<Stmt*>(stmt->getStmt()));\n      }\n  }\n\n  //===--------------------------------------------------------------------===//\n  // CFG Introspection.\n  //===--------------------------------------------------------------------===//\n\n  /// Returns the total number of BlockIDs allocated (which start at 0).\n  unsigned getNumBlockIDs() const { return NumBlockIDs; }\n\n  /// Return the total number of CFGBlocks within the CFG This is simply a\n  /// renaming of the getNumBlockIDs(). This is necessary because the dominator\n  /// implementation needs such an interface.\n  unsigned size() const { return NumBlockIDs; }\n\n  /// Returns true if the CFG has no branches. Usually it boils down to the CFG\n  /// having exactly three blocks (entry, the actual code, exit), but sometimes\n  /// more blocks appear due to having control flow that can be fully\n  /// resolved in compile time.\n  bool isLinear() const;\n\n  //===--------------------------------------------------------------------===//\n  // CFG Debugging: Pretty-Printing and Visualization.\n  //===--------------------------------------------------------------------===//\n\n  void viewCFG(const LangOptions &LO) const;\n  void print(raw_ostream &OS, const LangOptions &LO, bool ShowColors) const;\n  void dump(const LangOptions &LO, bool ShowColors) const;\n\n  //===--------------------------------------------------------------------===//\n  // Internal: constructors and data.\n  //===--------------------------------------------------------------------===//\n\n  CFG() : Blocks(BlkBVC, 10) {}\n\n  llvm::BumpPtrAllocator& getAllocator() {\n    return BlkBVC.getAllocator();\n  }\n\n  BumpVectorContext &getBumpVectorContext() {\n    return BlkBVC;\n  }\n\nprivate:\n  CFGBlock *Entry = nullptr;\n  CFGBlock *Exit = nullptr;\n\n  // Special block to contain collective dispatch for indirect gotos\n  CFGBlock* IndirectGotoBlock = nullptr;\n\n  unsigned  NumBlockIDs = 0;\n\n  BumpVectorContext BlkBVC;\n\n  CFGBlockListTy Blocks;\n\n  /// C++ 'try' statements are modeled with an indirect dispatch block.\n  /// This is the collection of such blocks present in the CFG.\n  std::vector<const CFGBlock *> TryDispatchBlocks;\n\n  /// Collects DeclStmts synthesized for this CFG and maps each one back to its\n  /// source DeclStmt.\n  llvm::DenseMap<const DeclStmt *, const DeclStmt *> SyntheticDeclStmts;\n};\n\n} // namespace clang\n\n//===----------------------------------------------------------------------===//\n// GraphTraits specializations for CFG basic block graphs (source-level CFGs)\n//===----------------------------------------------------------------------===//\n\nnamespace llvm {\n\n/// Implement simplify_type for CFGTerminator, so that we can dyn_cast from\n/// CFGTerminator to a specific Stmt class.\ntemplate <> struct simplify_type< ::clang::CFGTerminator> {\n  using SimpleType = ::clang::Stmt *;\n\n  static SimpleType getSimplifiedValue(::clang::CFGTerminator Val) {\n    return Val.getStmt();\n  }\n};\n\n// Traits for: CFGBlock\n\ntemplate <> struct GraphTraits< ::clang::CFGBlock *> {\n  using NodeRef = ::clang::CFGBlock *;\n  using ChildIteratorType = ::clang::CFGBlock::succ_iterator;\n\n  static NodeRef getEntryNode(::clang::CFGBlock *BB) { return BB; }\n  static ChildIteratorType child_begin(NodeRef N) { return N->succ_begin(); }\n  static ChildIteratorType child_end(NodeRef N) { return N->succ_end(); }\n};\n\ntemplate <> struct GraphTraits<clang::CFGBlock>\n    : GraphTraits<clang::CFGBlock *> {};\n\ntemplate <> struct GraphTraits< const ::clang::CFGBlock *> {\n  using NodeRef = const ::clang::CFGBlock *;\n  using ChildIteratorType = ::clang::CFGBlock::const_succ_iterator;\n\n  static NodeRef getEntryNode(const clang::CFGBlock *BB) { return BB; }\n  static ChildIteratorType child_begin(NodeRef N) { return N->succ_begin(); }\n  static ChildIteratorType child_end(NodeRef N) { return N->succ_end(); }\n};\n\ntemplate <> struct GraphTraits<const clang::CFGBlock>\n    : GraphTraits<clang::CFGBlock *> {};\n\ntemplate <> struct GraphTraits<Inverse< ::clang::CFGBlock *>> {\n  using NodeRef = ::clang::CFGBlock *;\n  using ChildIteratorType = ::clang::CFGBlock::const_pred_iterator;\n\n  static NodeRef getEntryNode(Inverse<::clang::CFGBlock *> G) {\n    return G.Graph;\n  }\n\n  static ChildIteratorType child_begin(NodeRef N) { return N->pred_begin(); }\n  static ChildIteratorType child_end(NodeRef N) { return N->pred_end(); }\n};\n\ntemplate <> struct GraphTraits<Inverse<clang::CFGBlock>>\n    : GraphTraits<clang::CFGBlock *> {};\n\ntemplate <> struct GraphTraits<Inverse<const ::clang::CFGBlock *>> {\n  using NodeRef = const ::clang::CFGBlock *;\n  using ChildIteratorType = ::clang::CFGBlock::const_pred_iterator;\n\n  static NodeRef getEntryNode(Inverse<const ::clang::CFGBlock *> G) {\n    return G.Graph;\n  }\n\n  static ChildIteratorType child_begin(NodeRef N) { return N->pred_begin(); }\n  static ChildIteratorType child_end(NodeRef N) { return N->pred_end(); }\n};\n\ntemplate <> struct GraphTraits<const Inverse<clang::CFGBlock>>\n    : GraphTraits<clang::CFGBlock *> {};\n\n// Traits for: CFG\n\ntemplate <> struct GraphTraits< ::clang::CFG* >\n    : public GraphTraits< ::clang::CFGBlock *>  {\n  using nodes_iterator = ::clang::CFG::iterator;\n\n  static NodeRef getEntryNode(::clang::CFG *F) { return &F->getEntry(); }\n  static nodes_iterator nodes_begin(::clang::CFG* F) { return F->nodes_begin();}\n  static nodes_iterator   nodes_end(::clang::CFG* F) { return F->nodes_end(); }\n  static unsigned              size(::clang::CFG* F) { return F->size(); }\n};\n\ntemplate <> struct GraphTraits<const ::clang::CFG* >\n    : public GraphTraits<const ::clang::CFGBlock *>  {\n  using nodes_iterator = ::clang::CFG::const_iterator;\n\n  static NodeRef getEntryNode(const ::clang::CFG *F) { return &F->getEntry(); }\n\n  static nodes_iterator nodes_begin( const ::clang::CFG* F) {\n    return F->nodes_begin();\n  }\n\n  static nodes_iterator nodes_end( const ::clang::CFG* F) {\n    return F->nodes_end();\n  }\n\n  static unsigned size(const ::clang::CFG* F) {\n    return F->size();\n  }\n};\n\ntemplate <> struct GraphTraits<Inverse< ::clang::CFG *>>\n  : public GraphTraits<Inverse< ::clang::CFGBlock *>> {\n  using nodes_iterator = ::clang::CFG::iterator;\n\n  static NodeRef getEntryNode(::clang::CFG *F) { return &F->getExit(); }\n  static nodes_iterator nodes_begin( ::clang::CFG* F) {return F->nodes_begin();}\n  static nodes_iterator nodes_end( ::clang::CFG* F) { return F->nodes_end(); }\n};\n\ntemplate <> struct GraphTraits<Inverse<const ::clang::CFG *>>\n  : public GraphTraits<Inverse<const ::clang::CFGBlock *>> {\n  using nodes_iterator = ::clang::CFG::const_iterator;\n\n  static NodeRef getEntryNode(const ::clang::CFG *F) { return &F->getExit(); }\n\n  static nodes_iterator nodes_begin(const ::clang::CFG* F) {\n    return F->nodes_begin();\n  }\n\n  static nodes_iterator nodes_end(const ::clang::CFG* F) {\n    return F->nodes_end();\n  }\n};\n\n} // namespace llvm\n\n#endif // LLVM_CLANG_ANALYSIS_CFG_H\n"}, "21": {"id": 21, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/ConstructionContext.h", "content": "//===- ConstructionContext.h - CFG constructor information ------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the ConstructionContext class and its sub-classes,\n// which represent various different ways of constructing C++ objects\n// with the additional information the users may want to know about\n// the constructor.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_ANALYSIS_CONSTRUCTIONCONTEXT_H\n#define LLVM_CLANG_ANALYSIS_CONSTRUCTIONCONTEXT_H\n\n#include \"clang/Analysis/Support/BumpVector.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/ExprObjC.h\"\n\nnamespace clang {\n\n/// Represents a single point (AST node) in the program that requires attention\n/// during construction of an object. ConstructionContext would be represented\n/// as a list of such items.\nclass ConstructionContextItem {\npublic:\n  enum ItemKind {\n    VariableKind,\n    NewAllocatorKind,\n    ReturnKind,\n    MaterializationKind,\n    TemporaryDestructorKind,\n    ElidedDestructorKind,\n    ElidableConstructorKind,\n    ArgumentKind,\n    STATEMENT_WITH_INDEX_KIND_BEGIN=ArgumentKind,\n    STATEMENT_WITH_INDEX_KIND_END=ArgumentKind,\n    STATEMENT_KIND_BEGIN = VariableKind,\n    STATEMENT_KIND_END = ArgumentKind,\n    InitializerKind,\n    INITIALIZER_KIND_BEGIN=InitializerKind,\n    INITIALIZER_KIND_END=InitializerKind\n  };\n\n  LLVM_DUMP_METHOD static StringRef getKindAsString(ItemKind K) {\n    switch (K) {\n      case VariableKind:            return \"construct into local variable\";\n      case NewAllocatorKind:        return \"construct into new-allocator\";\n      case ReturnKind:              return \"construct into return address\";\n      case MaterializationKind:     return \"materialize temporary\";\n      case TemporaryDestructorKind: return \"destroy temporary\";\n      case ElidedDestructorKind:    return \"elide destructor\";\n      case ElidableConstructorKind: return \"elide constructor\";\n      case ArgumentKind:            return \"construct into argument\";\n      case InitializerKind:         return \"construct into member variable\";\n    };\n    llvm_unreachable(\"Unknown ItemKind\");\n  }\n\nprivate:\n  const void *const Data;\n  const ItemKind Kind;\n  const unsigned Index = 0;\n\n  bool hasStatement() const {\n    return Kind >= STATEMENT_KIND_BEGIN &&\n           Kind <= STATEMENT_KIND_END;\n  }\n\n  bool hasIndex() const {\n    return Kind >= STATEMENT_WITH_INDEX_KIND_BEGIN &&\n           Kind >= STATEMENT_WITH_INDEX_KIND_END;\n  }\n\n  bool hasInitializer() const {\n    return Kind >= INITIALIZER_KIND_BEGIN &&\n           Kind <= INITIALIZER_KIND_END;\n  }\n\npublic:\n  // ConstructionContextItem should be simple enough so that it was easy to\n  // re-construct it from the AST node it captures. For that reason we provide\n  // simple implicit conversions from all sorts of supported AST nodes.\n  ConstructionContextItem(const DeclStmt *DS)\n      : Data(DS), Kind(VariableKind) {}\n\n  ConstructionContextItem(const CXXNewExpr *NE)\n      : Data(NE), Kind(NewAllocatorKind) {}\n\n  ConstructionContextItem(const ReturnStmt *RS)\n      : Data(RS), Kind(ReturnKind) {}\n\n  ConstructionContextItem(const MaterializeTemporaryExpr *MTE)\n      : Data(MTE), Kind(MaterializationKind) {}\n\n  ConstructionContextItem(const CXXBindTemporaryExpr *BTE,\n                          bool IsElided = false)\n      : Data(BTE),\n        Kind(IsElided ? ElidedDestructorKind : TemporaryDestructorKind) {}\n\n  ConstructionContextItem(const CXXConstructExpr *CE)\n      : Data(CE), Kind(ElidableConstructorKind) {}\n\n  ConstructionContextItem(const CallExpr *CE, unsigned Index)\n      : Data(CE), Kind(ArgumentKind), Index(Index) {}\n\n  ConstructionContextItem(const CXXConstructExpr *CE, unsigned Index)\n      : Data(CE), Kind(ArgumentKind), Index(Index) {}\n\n  ConstructionContextItem(const CXXInheritedCtorInitExpr *CE, unsigned Index)\n      : Data(CE), Kind(ArgumentKind), Index(Index) {}\n\n  ConstructionContextItem(const ObjCMessageExpr *ME, unsigned Index)\n      : Data(ME), Kind(ArgumentKind), Index(Index) {}\n\n  // A polymorphic version of the previous calls with dynamic type check.\n  ConstructionContextItem(const Expr *E, unsigned Index)\n      : Data(E), Kind(ArgumentKind), Index(Index) {\n    assert(isa<CallExpr>(E) || isa<CXXConstructExpr>(E) ||\n           isa<CXXInheritedCtorInitExpr>(E) || isa<ObjCMessageExpr>(E));\n  }\n\n  ConstructionContextItem(const CXXCtorInitializer *Init)\n      : Data(Init), Kind(InitializerKind), Index(0) {}\n\n  ItemKind getKind() const { return Kind; }\n\n  LLVM_DUMP_METHOD StringRef getKindAsString() const {\n    return getKindAsString(getKind());\n  }\n\n  /// The construction site - the statement that triggered the construction\n  /// for one of its parts. For instance, stack variable declaration statement\n  /// triggers construction of itself or its elements if it's an array,\n  /// new-expression triggers construction of the newly allocated object(s).\n  const Stmt *getStmt() const {\n    assert(hasStatement());\n    return static_cast<const Stmt *>(Data);\n  }\n\n  const Stmt *getStmtOrNull() const {\n    return hasStatement() ? getStmt() : nullptr;\n  }\n\n  /// The construction site is not necessarily a statement. It may also be a\n  /// CXXCtorInitializer, which means that a member variable is being\n  /// constructed during initialization of the object that contains it.\n  const CXXCtorInitializer *getCXXCtorInitializer() const {\n    assert(hasInitializer());\n    return static_cast<const CXXCtorInitializer *>(Data);\n  }\n\n  /// If a single trigger statement triggers multiple constructors, they are\n  /// usually being enumerated. This covers function argument constructors\n  /// triggered by a call-expression and items in an initializer list triggered\n  /// by an init-list-expression.\n  unsigned getIndex() const {\n    // This is a fairly specific request. Let's make sure the user knows\n    // what he's doing.\n    assert(hasIndex());\n    return Index;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    ID.AddPointer(Data);\n    ID.AddInteger(Kind);\n    ID.AddInteger(Index);\n  }\n\n  bool operator==(const ConstructionContextItem &Other) const {\n    // For most kinds the Index comparison is trivially true, but\n    // checking kind separately doesn't seem to be less expensive\n    // than checking Index. Same in operator<().\n    return std::make_tuple(Data, Kind, Index) ==\n           std::make_tuple(Other.Data, Other.Kind, Other.Index);\n  }\n\n  bool operator<(const ConstructionContextItem &Other) const {\n    return std::make_tuple(Data, Kind, Index) <\n           std::make_tuple(Other.Data, Other.Kind, Other.Index);\n  }\n};\n\n/// Construction context can be seen as a linked list of multiple layers.\n/// Sometimes a single trigger is not enough to describe the construction\n/// site. That's what causing us to have a chain of \"partial\" construction\n/// context layers. Some examples:\n/// - A constructor within in an aggregate initializer list within a variable\n///   would have a construction context of the initializer list with\n///   the parent construction context of a variable.\n/// - A constructor for a temporary that needs to be both destroyed\n///   and materialized into an elidable copy constructor would have a\n///   construction context of a CXXBindTemporaryExpr with the parent\n///   construction context of a MaterializeTemproraryExpr.\n/// Not all of these are currently supported.\n/// Layers are created gradually while traversing the AST, and layers that\n/// represent the outmost AST nodes are built first, while the node that\n/// immediately contains the constructor would be built last and capture the\n/// previous layers as its parents. Construction context captures the last layer\n/// (which has links to the previous layers) and classifies the seemingly\n/// arbitrary chain of layers into one of the possible ways of constructing\n/// an object in C++ for user-friendly experience.\nclass ConstructionContextLayer {\n  const ConstructionContextLayer *Parent = nullptr;\n  ConstructionContextItem Item;\n\n  ConstructionContextLayer(ConstructionContextItem Item,\n                           const ConstructionContextLayer *Parent)\n      : Parent(Parent), Item(Item) {}\n\npublic:\n  static const ConstructionContextLayer *\n  create(BumpVectorContext &C, const ConstructionContextItem &Item,\n         const ConstructionContextLayer *Parent = nullptr);\n\n  const ConstructionContextItem &getItem() const { return Item; }\n  const ConstructionContextLayer *getParent() const { return Parent; }\n  bool isLast() const { return !Parent; }\n\n  /// See if Other is a proper initial segment of this construction context\n  /// in terms of the parent chain - i.e. a few first parents coincide and\n  /// then the other context terminates but our context goes further - i.e.,\n  /// we are providing the same context that the other context provides,\n  /// and a bit more above that.\n  bool isStrictlyMoreSpecificThan(const ConstructionContextLayer *Other) const;\n};\n\n\n/// ConstructionContext's subclasses describe different ways of constructing\n/// an object in C++. The context re-captures the essential parent AST nodes\n/// of the CXXConstructExpr it is assigned to and presents these nodes\n/// through easy-to-understand accessor methods.\nclass ConstructionContext {\npublic:\n  enum Kind {\n    SimpleVariableKind,\n    CXX17ElidedCopyVariableKind,\n    VARIABLE_BEGIN = SimpleVariableKind,\n    VARIABLE_END = CXX17ElidedCopyVariableKind,\n    SimpleConstructorInitializerKind,\n    CXX17ElidedCopyConstructorInitializerKind,\n    INITIALIZER_BEGIN = SimpleConstructorInitializerKind,\n    INITIALIZER_END = CXX17ElidedCopyConstructorInitializerKind,\n    NewAllocatedObjectKind,\n    SimpleTemporaryObjectKind,\n    ElidedTemporaryObjectKind,\n    TEMPORARY_BEGIN = SimpleTemporaryObjectKind,\n    TEMPORARY_END = ElidedTemporaryObjectKind,\n    SimpleReturnedValueKind,\n    CXX17ElidedCopyReturnedValueKind,\n    RETURNED_VALUE_BEGIN = SimpleReturnedValueKind,\n    RETURNED_VALUE_END = CXX17ElidedCopyReturnedValueKind,\n    ArgumentKind\n  };\n\nprotected:\n  Kind K;\n\n  // Do not make public! These need to only be constructed\n  // via createFromLayers().\n  explicit ConstructionContext(Kind K) : K(K) {}\n\nprivate:\n  // A helper function for constructing an instance into a bump vector context.\n  template <typename T, typename... ArgTypes>\n  static T *create(BumpVectorContext &C, ArgTypes... Args) {\n    auto *CC = C.getAllocator().Allocate<T>();\n    return new (CC) T(Args...);\n  }\n\n  // A sub-routine of createFromLayers() that deals with temporary objects\n  // that need to be materialized. The BTE argument is for the situation when\n  // the object also needs to be bound for destruction.\n  static const ConstructionContext *createMaterializedTemporaryFromLayers(\n      BumpVectorContext &C, const MaterializeTemporaryExpr *MTE,\n      const CXXBindTemporaryExpr *BTE,\n      const ConstructionContextLayer *ParentLayer);\n\n  // A sub-routine of createFromLayers() that deals with temporary objects\n  // that need to be bound for destruction. Automatically finds out if the\n  // object also needs to be materialized and delegates to\n  // createMaterializedTemporaryFromLayers() if necessary.\n  static const ConstructionContext *\n  createBoundTemporaryFromLayers(\n      BumpVectorContext &C, const CXXBindTemporaryExpr *BTE,\n      const ConstructionContextLayer *ParentLayer);\n\npublic:\n  /// Consume the construction context layer, together with its parent layers,\n  /// and wrap it up into a complete construction context. May return null\n  /// if layers do not form any supported construction context.\n  static const ConstructionContext *\n  createFromLayers(BumpVectorContext &C,\n                   const ConstructionContextLayer *TopLayer);\n\n  Kind getKind() const { return K; }\n};\n\n/// An abstract base class for local variable constructors.\nclass VariableConstructionContext : public ConstructionContext {\n  const DeclStmt *DS;\n\nprotected:\n  VariableConstructionContext(ConstructionContext::Kind K, const DeclStmt *DS)\n      : ConstructionContext(K), DS(DS) {\n    assert(classof(this));\n    assert(DS);\n  }\n\npublic:\n  const DeclStmt *getDeclStmt() const { return DS; }\n\n  static bool classof(const ConstructionContext *CC) {\n    return CC->getKind() >= VARIABLE_BEGIN &&\n           CC->getKind() <= VARIABLE_END;\n  }\n};\n\n/// Represents construction into a simple local variable, eg. T var(123);.\n/// If a variable has an initializer, eg. T var = makeT();, then the final\n/// elidable copy-constructor from makeT() into var would also be a simple\n/// variable constructor handled by this class.\nclass SimpleVariableConstructionContext : public VariableConstructionContext {\n  friend class ConstructionContext; // Allows to create<>() itself.\n\n  explicit SimpleVariableConstructionContext(const DeclStmt *DS)\n      : VariableConstructionContext(ConstructionContext::SimpleVariableKind,\n                                    DS) {}\n\npublic:\n  static bool classof(const ConstructionContext *CC) {\n    return CC->getKind() == SimpleVariableKind;\n  }\n};\n\n/// Represents construction into a simple variable with an initializer syntax,\n/// with a single constructor, eg. T var = makeT();. Such construction context\n/// may only appear in C++17 because previously it was split into a temporary\n/// object constructor and an elidable simple variable copy-constructor and\n/// we were producing separate construction contexts for these constructors.\n/// In C++17 we have a single construction context that combines both.\n/// Note that if the object has trivial destructor, then this code is\n/// indistinguishable from a simple variable constructor on the AST level;\n/// in this case we provide a simple variable construction context.\nclass CXX17ElidedCopyVariableConstructionContext\n    : public VariableConstructionContext {\n  const CXXBindTemporaryExpr *BTE;\n\n  friend class ConstructionContext; // Allows to create<>() itself.\n\n  explicit CXX17ElidedCopyVariableConstructionContext(\n      const DeclStmt *DS, const CXXBindTemporaryExpr *BTE)\n      : VariableConstructionContext(CXX17ElidedCopyVariableKind, DS), BTE(BTE) {\n    assert(BTE);\n  }\n\npublic:\n  const CXXBindTemporaryExpr *getCXXBindTemporaryExpr() const { return BTE; }\n\n  static bool classof(const ConstructionContext *CC) {\n    return CC->getKind() == CXX17ElidedCopyVariableKind;\n  }\n};\n\n// An abstract base class for constructor-initializer-based constructors.\nclass ConstructorInitializerConstructionContext : public ConstructionContext {\n  const CXXCtorInitializer *I;\n\nprotected:\n  explicit ConstructorInitializerConstructionContext(\n      ConstructionContext::Kind K, const CXXCtorInitializer *I)\n      : ConstructionContext(K), I(I) {\n    assert(classof(this));\n    assert(I);\n  }\n\npublic:\n  const CXXCtorInitializer *getCXXCtorInitializer() const { return I; }\n\n  static bool classof(const ConstructionContext *CC) {\n    return CC->getKind() >= INITIALIZER_BEGIN &&\n           CC->getKind() <= INITIALIZER_END;\n  }\n};\n\n/// Represents construction into a field or a base class within a bigger object\n/// via a constructor initializer, eg. T(): field(123) { ... }.\nclass SimpleConstructorInitializerConstructionContext\n    : public ConstructorInitializerConstructionContext {\n  friend class ConstructionContext; // Allows to create<>() itself.\n\n  explicit SimpleConstructorInitializerConstructionContext(\n      const CXXCtorInitializer *I)\n      : ConstructorInitializerConstructionContext(\n            ConstructionContext::SimpleConstructorInitializerKind, I) {}\n\npublic:\n  static bool classof(const ConstructionContext *CC) {\n    return CC->getKind() == SimpleConstructorInitializerKind;\n  }\n};\n\n/// Represents construction into a field or a base class within a bigger object\n/// via a constructor initializer, with a single constructor, eg.\n/// T(): field(Field(123)) { ... }. Such construction context may only appear\n/// in C++17 because previously it was split into a temporary object constructor\n/// and an elidable simple constructor-initializer copy-constructor and we were\n/// producing separate construction contexts for these constructors. In C++17\n/// we have a single construction context that combines both. Note that if the\n/// object has trivial destructor, then this code is indistinguishable from\n/// a simple constructor-initializer constructor on the AST level; in this case\n/// we provide a simple constructor-initializer construction context.\nclass CXX17ElidedCopyConstructorInitializerConstructionContext\n    : public ConstructorInitializerConstructionContext {\n  const CXXBindTemporaryExpr *BTE;\n\n  friend class ConstructionContext; // Allows to create<>() itself.\n\n  explicit CXX17ElidedCopyConstructorInitializerConstructionContext(\n      const CXXCtorInitializer *I, const CXXBindTemporaryExpr *BTE)\n      : ConstructorInitializerConstructionContext(\n            CXX17ElidedCopyConstructorInitializerKind, I),\n        BTE(BTE) {\n    assert(BTE);\n  }\n\npublic:\n  const CXXBindTemporaryExpr *getCXXBindTemporaryExpr() const { return BTE; }\n\n  static bool classof(const ConstructionContext *CC) {\n    return CC->getKind() == CXX17ElidedCopyConstructorInitializerKind;\n  }\n};\n\n/// Represents immediate initialization of memory allocated by operator new,\n/// eg. new T(123);.\nclass NewAllocatedObjectConstructionContext : public ConstructionContext {\n  const CXXNewExpr *NE;\n\n  friend class ConstructionContext; // Allows to create<>() itself.\n\n  explicit NewAllocatedObjectConstructionContext(const CXXNewExpr *NE)\n      : ConstructionContext(ConstructionContext::NewAllocatedObjectKind),\n        NE(NE) {\n    assert(NE);\n  }\n\npublic:\n  const CXXNewExpr *getCXXNewExpr() const { return NE; }\n\n  static bool classof(const ConstructionContext *CC) {\n    return CC->getKind() == NewAllocatedObjectKind;\n  }\n};\n\n/// Represents a temporary object, eg. T(123), that does not immediately cross\n/// function boundaries \"by value\"; constructors that construct function\n/// value-type arguments or values that are immediately returned from the\n/// function that returns a value receive separate construction context kinds.\nclass TemporaryObjectConstructionContext : public ConstructionContext {\n  const CXXBindTemporaryExpr *BTE;\n  const MaterializeTemporaryExpr *MTE;\n\nprotected:\n  explicit TemporaryObjectConstructionContext(\n      ConstructionContext::Kind K, const CXXBindTemporaryExpr *BTE,\n      const MaterializeTemporaryExpr *MTE)\n      : ConstructionContext(K), BTE(BTE), MTE(MTE) {\n    // Both BTE and MTE can be null here, all combinations possible.\n    // Even though for now at least one should be non-null, we simply haven't\n    // implemented the other case yet (this would be a temporary in the middle\n    // of nowhere that doesn't have a non-trivial destructor).\n  }\n\npublic:\n  /// CXXBindTemporaryExpr here is non-null as long as the temporary has\n  /// a non-trivial destructor.\n  const CXXBindTemporaryExpr *getCXXBindTemporaryExpr() const {\n    return BTE;\n  }\n\n  /// MaterializeTemporaryExpr is non-null as long as the temporary is actually\n  /// used after construction, eg. by binding to a reference (lifetime\n  /// extension), accessing a field, calling a method, or passing it into\n  /// a function (an elidable copy or move constructor would be a common\n  /// example) by reference.\n  const MaterializeTemporaryExpr *getMaterializedTemporaryExpr() const {\n    return MTE;\n  }\n\n  static bool classof(const ConstructionContext *CC) {\n    return CC->getKind() >= TEMPORARY_BEGIN && CC->getKind() <= TEMPORARY_END;\n  }\n};\n\n/// Represents a temporary object that is not constructed for the purpose of\n/// being immediately copied/moved by an elidable copy/move-constructor.\n/// This includes temporary objects \"in the middle of nowhere\" like T(123) and\n/// lifetime-extended temporaries.\nclass SimpleTemporaryObjectConstructionContext\n    : public TemporaryObjectConstructionContext {\n  friend class ConstructionContext; // Allows to create<>() itself.\n\n  explicit SimpleTemporaryObjectConstructionContext(\n      const CXXBindTemporaryExpr *BTE, const MaterializeTemporaryExpr *MTE)\n      : TemporaryObjectConstructionContext(\n            ConstructionContext::SimpleTemporaryObjectKind, BTE, MTE) {}\n\npublic:\n  static bool classof(const ConstructionContext *CC) {\n    return CC->getKind() == SimpleTemporaryObjectKind;\n  }\n};\n\n/// Represents a temporary object that is constructed for the sole purpose\n/// of being immediately copied by an elidable copy/move constructor.\n/// For example, T t = T(123); includes a temporary T(123) that is immediately\n/// copied to variable t. In such cases the elidable copy can (but not\n/// necessarily should) be omitted (\"elided\") accodring to the rules of the\n/// language; the constructor would then construct variable t directly.\n/// This construction context contains information of the elidable constructor\n/// and its respective construction context.\nclass ElidedTemporaryObjectConstructionContext\n    : public TemporaryObjectConstructionContext {\n  const CXXConstructExpr *ElidedCE;\n  const ConstructionContext *ElidedCC;\n\n  friend class ConstructionContext; // Allows to create<>() itself.\n\n  explicit ElidedTemporaryObjectConstructionContext(\n      const CXXBindTemporaryExpr *BTE, const MaterializeTemporaryExpr *MTE,\n      const CXXConstructExpr *ElidedCE, const ConstructionContext *ElidedCC)\n      : TemporaryObjectConstructionContext(\n            ConstructionContext::ElidedTemporaryObjectKind, BTE, MTE),\n        ElidedCE(ElidedCE), ElidedCC(ElidedCC) {\n    // Elided constructor and its context should be either both specified\n    // or both unspecified. In the former case, the constructor must be\n    // elidable.\n    assert(ElidedCE && ElidedCE->isElidable() && ElidedCC);\n  }\n\npublic:\n  const CXXConstructExpr *getConstructorAfterElision() const {\n    return ElidedCE;\n  }\n\n  const ConstructionContext *getConstructionContextAfterElision() const {\n    return ElidedCC;\n  }\n\n  static bool classof(const ConstructionContext *CC) {\n    return CC->getKind() == ElidedTemporaryObjectKind;\n  }\n};\n\nclass ReturnedValueConstructionContext : public ConstructionContext {\n  const ReturnStmt *RS;\n\nprotected:\n  explicit ReturnedValueConstructionContext(ConstructionContext::Kind K,\n                                            const ReturnStmt *RS)\n      : ConstructionContext(K), RS(RS) {\n    assert(classof(this));\n    assert(RS);\n  }\n\npublic:\n  const ReturnStmt *getReturnStmt() const { return RS; }\n\n  static bool classof(const ConstructionContext *CC) {\n    return CC->getKind() >= RETURNED_VALUE_BEGIN &&\n           CC->getKind() <= RETURNED_VALUE_END;\n  }\n};\n\n/// Represents a temporary object that is being immediately returned from a\n/// function by value, eg. return t; or return T(123);. In this case there is\n/// always going to be a constructor at the return site. However, the usual\n/// temporary-related bureaucracy (CXXBindTemporaryExpr,\n/// MaterializeTemporaryExpr) is normally located in the caller function's AST.\nclass SimpleReturnedValueConstructionContext\n    : public ReturnedValueConstructionContext {\n  friend class ConstructionContext; // Allows to create<>() itself.\n\n  explicit SimpleReturnedValueConstructionContext(const ReturnStmt *RS)\n      : ReturnedValueConstructionContext(\n            ConstructionContext::SimpleReturnedValueKind, RS) {}\n\npublic:\n  static bool classof(const ConstructionContext *CC) {\n    return CC->getKind() == SimpleReturnedValueKind;\n  }\n};\n\n/// Represents a temporary object that is being immediately returned from a\n/// function by value, eg. return t; or return T(123); in C++17.\n/// In C++17 there is not going to be an elidable copy constructor at the\n/// return site.  However, the usual temporary-related bureaucracy (CXXBindTemporaryExpr,\n/// MaterializeTemporaryExpr) is normally located in the caller function's AST.\n/// Note that if the object has trivial destructor, then this code is\n/// indistinguishable from a simple returned value constructor on the AST level;\n/// in this case we provide a simple returned value construction context.\nclass CXX17ElidedCopyReturnedValueConstructionContext\n    : public ReturnedValueConstructionContext {\n  const CXXBindTemporaryExpr *BTE;\n\n  friend class ConstructionContext; // Allows to create<>() itself.\n\n  explicit CXX17ElidedCopyReturnedValueConstructionContext(\n      const ReturnStmt *RS, const CXXBindTemporaryExpr *BTE)\n      : ReturnedValueConstructionContext(\n            ConstructionContext::CXX17ElidedCopyReturnedValueKind, RS),\n        BTE(BTE) {\n    assert(BTE);\n  }\n\npublic:\n  const CXXBindTemporaryExpr *getCXXBindTemporaryExpr() const { return BTE; }\n\n  static bool classof(const ConstructionContext *CC) {\n    return CC->getKind() == CXX17ElidedCopyReturnedValueKind;\n  }\n};\n\nclass ArgumentConstructionContext : public ConstructionContext {\n  // The call of which the context is an argument.\n  const Expr *CE;\n\n  // Which argument we're constructing. Note that when numbering between\n  // arguments and parameters is inconsistent (eg., operator calls),\n  // this is the index of the argument, not of the parameter.\n  unsigned Index;\n\n  // Whether the object needs to be destroyed.\n  const CXXBindTemporaryExpr *BTE;\n\n  friend class ConstructionContext; // Allows to create<>() itself.\n\n  explicit ArgumentConstructionContext(const Expr *CE, unsigned Index,\n                                       const CXXBindTemporaryExpr *BTE)\n      : ConstructionContext(ArgumentKind), CE(CE),\n        Index(Index), BTE(BTE) {\n    assert(isa<CallExpr>(CE) || isa<CXXConstructExpr>(CE) ||\n           isa<ObjCMessageExpr>(CE));\n    // BTE is optional.\n  }\n\npublic:\n  const Expr *getCallLikeExpr() const { return CE; }\n  unsigned getIndex() const { return Index; }\n  const CXXBindTemporaryExpr *getCXXBindTemporaryExpr() const { return BTE; }\n\n  static bool classof(const ConstructionContext *CC) {\n    return CC->getKind() == ArgumentKind;\n  }\n};\n\n} // end namespace clang\n\n#endif // LLVM_CLANG_ANALYSIS_CONSTRUCTIONCONTEXT_H\n"}, "22": {"id": 22, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/ProgramPoint.h", "content": "//==- ProgramPoint.h - Program Points for Path-Sensitive Analysis --*- C++ -*-//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the interface ProgramPoint, which identifies a\n//  distinct location in a function.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_ANALYSIS_PROGRAMPOINT_H\n#define LLVM_CLANG_ANALYSIS_PROGRAMPOINT_H\n\n#include \"clang/Analysis/AnalysisDeclContext.h\"\n#include \"clang/Analysis/CFG.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/DataTypes.h\"\n#include <cassert>\n#include <string>\n#include <utility>\n\nnamespace clang {\n\nclass AnalysisDeclContext;\nclass FunctionDecl;\nclass LocationContext;\n\n/// ProgramPoints can be \"tagged\" as representing points specific to a given\n/// analysis entity.  Tags are abstract annotations, with an associated\n/// description and potentially other information.\nclass ProgramPointTag {\npublic:\n  ProgramPointTag(void *tagKind = nullptr) : TagKind(tagKind) {}\n  virtual ~ProgramPointTag();\n  virtual StringRef getTagDescription() const = 0;\n\n  /// Used to implement 'isKind' in subclasses.\n  const void *getTagKind() const { return TagKind; }\n\nprivate:\n  const void *const TagKind;\n};\n\nclass SimpleProgramPointTag : public ProgramPointTag {\n  std::string Desc;\npublic:\n  SimpleProgramPointTag(StringRef MsgProvider, StringRef Msg);\n  StringRef getTagDescription() const override;\n};\n\nclass ProgramPoint {\npublic:\n  enum Kind { BlockEdgeKind,\n              BlockEntranceKind,\n              BlockExitKind,\n              PreStmtKind,\n              PreStmtPurgeDeadSymbolsKind,\n              PostStmtPurgeDeadSymbolsKind,\n              PostStmtKind,\n              PreLoadKind,\n              PostLoadKind,\n              PreStoreKind,\n              PostStoreKind,\n              PostConditionKind,\n              PostLValueKind,\n              PostAllocatorCallKind,\n              MinPostStmtKind = PostStmtKind,\n              MaxPostStmtKind = PostAllocatorCallKind,\n              PostInitializerKind,\n              CallEnterKind,\n              CallExitBeginKind,\n              CallExitEndKind,\n              FunctionExitKind,\n              PreImplicitCallKind,\n              PostImplicitCallKind,\n              MinImplicitCallKind = PreImplicitCallKind,\n              MaxImplicitCallKind = PostImplicitCallKind,\n              LoopExitKind,\n              EpsilonKind};\n\nprivate:\n  const void *Data1;\n  llvm::PointerIntPair<const void *, 2, unsigned> Data2;\n\n  // The LocationContext could be NULL to allow ProgramPoint to be used in\n  // context insensitive analysis.\n  llvm::PointerIntPair<const LocationContext *, 2, unsigned> L;\n\n  llvm::PointerIntPair<const ProgramPointTag *, 2, unsigned> Tag;\n\nprotected:\n  ProgramPoint() = default;\n  ProgramPoint(const void *P,\n               Kind k,\n               const LocationContext *l,\n               const ProgramPointTag *tag = nullptr)\n    : Data1(P),\n      Data2(nullptr, (((unsigned) k) >> 0) & 0x3),\n      L(l, (((unsigned) k) >> 2) & 0x3),\n      Tag(tag, (((unsigned) k) >> 4) & 0x3) {\n        assert(getKind() == k);\n        assert(getLocationContext() == l);\n        assert(getData1() == P);\n      }\n\n  ProgramPoint(const void *P1,\n               const void *P2,\n               Kind k,\n               const LocationContext *l,\n               const ProgramPointTag *tag = nullptr)\n    : Data1(P1),\n      Data2(P2, (((unsigned) k) >> 0) & 0x3),\n      L(l, (((unsigned) k) >> 2) & 0x3),\n      Tag(tag, (((unsigned) k) >> 4) & 0x3) {}\n\nprotected:\n  const void *getData1() const { return Data1; }\n  const void *getData2() const { return Data2.getPointer(); }\n  void setData2(const void *d) { Data2.setPointer(d); }\n\npublic:\n  /// Create a new ProgramPoint object that is the same as the original\n  /// except for using the specified tag value.\n  ProgramPoint withTag(const ProgramPointTag *tag) const {\n    return ProgramPoint(getData1(), getData2(), getKind(),\n                        getLocationContext(), tag);\n  }\n\n  /// Convert to the specified ProgramPoint type, asserting that this\n  /// ProgramPoint is of the desired type.\n  template<typename T>\n  T castAs() const {\n    assert(T::isKind(*this));\n    T t;\n    ProgramPoint& PP = t;\n    PP = *this;\n    return t;\n  }\n\n  /// Convert to the specified ProgramPoint type, returning None if this\n  /// ProgramPoint is not of the desired type.\n  template<typename T>\n  Optional<T> getAs() const {\n    if (!T::isKind(*this))\n      return None;\n    T t;\n    ProgramPoint& PP = t;\n    PP = *this;\n    return t;\n  }\n\n  Kind getKind() const {\n    unsigned x = Tag.getInt();\n    x <<= 2;\n    x |= L.getInt();\n    x <<= 2;\n    x |= Data2.getInt();\n    return (Kind) x;\n  }\n\n  /// Is this a program point corresponding to purge/removal of dead\n  /// symbols and bindings.\n  bool isPurgeKind() {\n    Kind K = getKind();\n    return (K == PostStmtPurgeDeadSymbolsKind ||\n            K == PreStmtPurgeDeadSymbolsKind);\n  }\n\n  const ProgramPointTag *getTag() const { return Tag.getPointer(); }\n\n  const LocationContext *getLocationContext() const {\n    return L.getPointer();\n  }\n\n  const StackFrameContext *getStackFrame() const {\n    return getLocationContext()->getStackFrame();\n  }\n\n  // For use with DenseMap.  This hash is probably slow.\n  unsigned getHashValue() const {\n    llvm::FoldingSetNodeID ID;\n    Profile(ID);\n    return ID.ComputeHash();\n  }\n\n  bool operator==(const ProgramPoint & RHS) const {\n    return Data1 == RHS.Data1 &&\n           Data2 == RHS.Data2 &&\n           L == RHS.L &&\n           Tag == RHS.Tag;\n  }\n\n  bool operator!=(const ProgramPoint &RHS) const {\n    return Data1 != RHS.Data1 ||\n           Data2 != RHS.Data2 ||\n           L != RHS.L ||\n           Tag != RHS.Tag;\n  }\n\n  void Profile(llvm::FoldingSetNodeID& ID) const {\n    ID.AddInteger((unsigned) getKind());\n    ID.AddPointer(getData1());\n    ID.AddPointer(getData2());\n    ID.AddPointer(getLocationContext());\n    ID.AddPointer(getTag());\n  }\n\n  void printJson(llvm::raw_ostream &Out, const char *NL = \"\\n\") const;\n\n  LLVM_DUMP_METHOD void dump() const;\n\n  static ProgramPoint getProgramPoint(const Stmt *S, ProgramPoint::Kind K,\n                                      const LocationContext *LC,\n                                      const ProgramPointTag *tag);\n};\n\nclass BlockEntrance : public ProgramPoint {\npublic:\n  BlockEntrance(const CFGBlock *B, const LocationContext *L,\n                const ProgramPointTag *tag = nullptr)\n    : ProgramPoint(B, BlockEntranceKind, L, tag) {\n    assert(B && \"BlockEntrance requires non-null block\");\n  }\n\n  const CFGBlock *getBlock() const {\n    return reinterpret_cast<const CFGBlock*>(getData1());\n  }\n\n  Optional<CFGElement> getFirstElement() const {\n    const CFGBlock *B = getBlock();\n    return B->empty() ? Optional<CFGElement>() : B->front();\n  }\n\nprivate:\n  friend class ProgramPoint;\n  BlockEntrance() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == BlockEntranceKind;\n  }\n};\n\nclass BlockExit : public ProgramPoint {\npublic:\n  BlockExit(const CFGBlock *B, const LocationContext *L)\n    : ProgramPoint(B, BlockExitKind, L) {}\n\n  const CFGBlock *getBlock() const {\n    return reinterpret_cast<const CFGBlock*>(getData1());\n  }\n\n  const Stmt *getTerminator() const {\n    return getBlock()->getTerminatorStmt();\n  }\n\nprivate:\n  friend class ProgramPoint;\n  BlockExit() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == BlockExitKind;\n  }\n};\n\nclass StmtPoint : public ProgramPoint {\npublic:\n  StmtPoint(const Stmt *S, const void *p2, Kind k, const LocationContext *L,\n            const ProgramPointTag *tag)\n    : ProgramPoint(S, p2, k, L, tag) {\n    assert(S);\n  }\n\n  const Stmt *getStmt() const { return (const Stmt*) getData1(); }\n\n  template <typename T>\n  const T* getStmtAs() const { return dyn_cast<T>(getStmt()); }\n\nprotected:\n  StmtPoint() = default;\nprivate:\n  friend class ProgramPoint;\n  static bool isKind(const ProgramPoint &Location) {\n    unsigned k = Location.getKind();\n    return k >= PreStmtKind && k <= MaxPostStmtKind;\n  }\n};\n\n\nclass PreStmt : public StmtPoint {\npublic:\n  PreStmt(const Stmt *S, const LocationContext *L, const ProgramPointTag *tag,\n          const Stmt *SubStmt = nullptr)\n    : StmtPoint(S, SubStmt, PreStmtKind, L, tag) {}\n\n  const Stmt *getSubStmt() const { return (const Stmt*) getData2(); }\n\nprivate:\n  friend class ProgramPoint;\n  PreStmt() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == PreStmtKind;\n  }\n};\n\nclass PostStmt : public StmtPoint {\nprotected:\n  PostStmt() = default;\n  PostStmt(const Stmt *S, const void *data, Kind k, const LocationContext *L,\n           const ProgramPointTag *tag = nullptr)\n    : StmtPoint(S, data, k, L, tag) {}\n\npublic:\n  explicit PostStmt(const Stmt *S, Kind k, const LocationContext *L,\n                    const ProgramPointTag *tag = nullptr)\n    : StmtPoint(S, nullptr, k, L, tag) {}\n\n  explicit PostStmt(const Stmt *S, const LocationContext *L,\n                    const ProgramPointTag *tag = nullptr)\n    : StmtPoint(S, nullptr, PostStmtKind, L, tag) {}\n\nprivate:\n  friend class ProgramPoint;\n  static bool isKind(const ProgramPoint &Location) {\n    unsigned k = Location.getKind();\n    return k >= MinPostStmtKind && k <= MaxPostStmtKind;\n  }\n};\n\nclass FunctionExitPoint : public ProgramPoint {\npublic:\n  explicit FunctionExitPoint(const ReturnStmt *S,\n                             const LocationContext *LC,\n                             const ProgramPointTag *tag = nullptr)\n      : ProgramPoint(S, FunctionExitKind, LC, tag) {}\n\n  const CFGBlock *getBlock() const {\n    return &getLocationContext()->getCFG()->getExit();\n  }\n\n  const ReturnStmt *getStmt() const {\n    return reinterpret_cast<const ReturnStmt *>(getData1());\n  }\n\nprivate:\n  friend class ProgramPoint;\n  FunctionExitPoint() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == FunctionExitKind;\n  }\n};\n\n// PostCondition represents the post program point of a branch condition.\nclass PostCondition : public PostStmt {\npublic:\n  PostCondition(const Stmt *S, const LocationContext *L,\n                const ProgramPointTag *tag = nullptr)\n    : PostStmt(S, PostConditionKind, L, tag) {}\n\nprivate:\n  friend class ProgramPoint;\n  PostCondition() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == PostConditionKind;\n  }\n};\n\nclass LocationCheck : public StmtPoint {\nprotected:\n  LocationCheck() = default;\n  LocationCheck(const Stmt *S, const LocationContext *L,\n                ProgramPoint::Kind K, const ProgramPointTag *tag)\n    : StmtPoint(S, nullptr, K, L, tag) {}\n\nprivate:\n  friend class ProgramPoint;\n  static bool isKind(const ProgramPoint &location) {\n    unsigned k = location.getKind();\n    return k == PreLoadKind || k == PreStoreKind;\n  }\n};\n\nclass PreLoad : public LocationCheck {\npublic:\n  PreLoad(const Stmt *S, const LocationContext *L,\n          const ProgramPointTag *tag = nullptr)\n    : LocationCheck(S, L, PreLoadKind, tag) {}\n\nprivate:\n  friend class ProgramPoint;\n  PreLoad() = default;\n  static bool isKind(const ProgramPoint &location) {\n    return location.getKind() == PreLoadKind;\n  }\n};\n\nclass PreStore : public LocationCheck {\npublic:\n  PreStore(const Stmt *S, const LocationContext *L,\n           const ProgramPointTag *tag = nullptr)\n  : LocationCheck(S, L, PreStoreKind, tag) {}\n\nprivate:\n  friend class ProgramPoint;\n  PreStore() = default;\n  static bool isKind(const ProgramPoint &location) {\n    return location.getKind() == PreStoreKind;\n  }\n};\n\nclass PostLoad : public PostStmt {\npublic:\n  PostLoad(const Stmt *S, const LocationContext *L,\n           const ProgramPointTag *tag = nullptr)\n    : PostStmt(S, PostLoadKind, L, tag) {}\n\nprivate:\n  friend class ProgramPoint;\n  PostLoad() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == PostLoadKind;\n  }\n};\n\n/// Represents a program point after a store evaluation.\nclass PostStore : public PostStmt {\npublic:\n  /// Construct the post store point.\n  /// \\param Loc can be used to store the information about the location\n  /// used in the form it was uttered in the code.\n  PostStore(const Stmt *S, const LocationContext *L, const void *Loc,\n            const ProgramPointTag *tag = nullptr)\n    : PostStmt(S, PostStoreKind, L, tag) {\n    assert(getData2() == nullptr);\n    setData2(Loc);\n  }\n\n  /// Returns the information about the location used in the store,\n  /// how it was uttered in the code.\n  const void *getLocationValue() const {\n    return getData2();\n  }\n\nprivate:\n  friend class ProgramPoint;\n  PostStore() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == PostStoreKind;\n  }\n};\n\nclass PostLValue : public PostStmt {\npublic:\n  PostLValue(const Stmt *S, const LocationContext *L,\n             const ProgramPointTag *tag = nullptr)\n    : PostStmt(S, PostLValueKind, L, tag) {}\n\nprivate:\n  friend class ProgramPoint;\n  PostLValue() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == PostLValueKind;\n  }\n};\n\n/// Represents a point after we ran remove dead bindings BEFORE\n/// processing the given statement.\nclass PreStmtPurgeDeadSymbols : public StmtPoint {\npublic:\n  PreStmtPurgeDeadSymbols(const Stmt *S, const LocationContext *L,\n                       const ProgramPointTag *tag = nullptr)\n    : StmtPoint(S, nullptr, PreStmtPurgeDeadSymbolsKind, L, tag) { }\n\nprivate:\n  friend class ProgramPoint;\n  PreStmtPurgeDeadSymbols() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == PreStmtPurgeDeadSymbolsKind;\n  }\n};\n\n/// Represents a point after we ran remove dead bindings AFTER\n/// processing the  given statement.\nclass PostStmtPurgeDeadSymbols : public StmtPoint {\npublic:\n  PostStmtPurgeDeadSymbols(const Stmt *S, const LocationContext *L,\n                       const ProgramPointTag *tag = nullptr)\n    : StmtPoint(S, nullptr, PostStmtPurgeDeadSymbolsKind, L, tag) { }\n\nprivate:\n  friend class ProgramPoint;\n  PostStmtPurgeDeadSymbols() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == PostStmtPurgeDeadSymbolsKind;\n  }\n};\n\nclass BlockEdge : public ProgramPoint {\npublic:\n  BlockEdge(const CFGBlock *B1, const CFGBlock *B2, const LocationContext *L)\n    : ProgramPoint(B1, B2, BlockEdgeKind, L) {\n    assert(B1 && \"BlockEdge: source block must be non-null\");\n    assert(B2 && \"BlockEdge: destination block must be non-null\");\n  }\n\n  const CFGBlock *getSrc() const {\n    return static_cast<const CFGBlock*>(getData1());\n  }\n\n  const CFGBlock *getDst() const {\n    return static_cast<const CFGBlock*>(getData2());\n  }\n\nprivate:\n  friend class ProgramPoint;\n  BlockEdge() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == BlockEdgeKind;\n  }\n};\n\nclass PostInitializer : public ProgramPoint {\npublic:\n  /// Construct a PostInitializer point that represents a location after\n  ///   CXXCtorInitializer expression evaluation.\n  ///\n  /// \\param I The initializer.\n  /// \\param Loc The location of the field being initialized.\n  PostInitializer(const CXXCtorInitializer *I,\n                  const void *Loc,\n                  const LocationContext *L)\n    : ProgramPoint(I, Loc, PostInitializerKind, L) {}\n\n  const CXXCtorInitializer *getInitializer() const {\n    return static_cast<const CXXCtorInitializer *>(getData1());\n  }\n\n  /// Returns the location of the field.\n  const void *getLocationValue() const {\n    return getData2();\n  }\n\nprivate:\n  friend class ProgramPoint;\n  PostInitializer() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == PostInitializerKind;\n  }\n};\n\n/// Represents an implicit call event.\n///\n/// The nearest statement is provided for diagnostic purposes.\nclass ImplicitCallPoint : public ProgramPoint {\npublic:\n  ImplicitCallPoint(const Decl *D, SourceLocation Loc, Kind K,\n                    const LocationContext *L, const ProgramPointTag *Tag)\n    : ProgramPoint(Loc.getPtrEncoding(), D, K, L, Tag) {}\n\n  const Decl *getDecl() const { return static_cast<const Decl *>(getData2()); }\n  SourceLocation getLocation() const {\n    return SourceLocation::getFromPtrEncoding(getData1());\n  }\n\nprotected:\n  ImplicitCallPoint() = default;\nprivate:\n  friend class ProgramPoint;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() >= MinImplicitCallKind &&\n           Location.getKind() <= MaxImplicitCallKind;\n  }\n};\n\n/// Represents a program point just before an implicit call event.\n///\n/// Explicit calls will appear as PreStmt program points.\nclass PreImplicitCall : public ImplicitCallPoint {\npublic:\n  PreImplicitCall(const Decl *D, SourceLocation Loc, const LocationContext *L,\n                  const ProgramPointTag *Tag = nullptr)\n    : ImplicitCallPoint(D, Loc, PreImplicitCallKind, L, Tag) {}\n\nprivate:\n  friend class ProgramPoint;\n  PreImplicitCall() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == PreImplicitCallKind;\n  }\n};\n\n/// Represents a program point just after an implicit call event.\n///\n/// Explicit calls will appear as PostStmt program points.\nclass PostImplicitCall : public ImplicitCallPoint {\npublic:\n  PostImplicitCall(const Decl *D, SourceLocation Loc, const LocationContext *L,\n                   const ProgramPointTag *Tag = nullptr)\n    : ImplicitCallPoint(D, Loc, PostImplicitCallKind, L, Tag) {}\n\nprivate:\n  friend class ProgramPoint;\n  PostImplicitCall() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == PostImplicitCallKind;\n  }\n};\n\nclass PostAllocatorCall : public StmtPoint {\npublic:\n  PostAllocatorCall(const Stmt *S, const LocationContext *L,\n                    const ProgramPointTag *Tag = nullptr)\n      : StmtPoint(S, nullptr, PostAllocatorCallKind, L, Tag) {}\n\nprivate:\n  friend class ProgramPoint;\n  PostAllocatorCall() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == PostAllocatorCallKind;\n  }\n};\n\n/// Represents a point when we begin processing an inlined call.\n/// CallEnter uses the caller's location context.\nclass CallEnter : public ProgramPoint {\npublic:\n  CallEnter(const Stmt *stmt, const StackFrameContext *calleeCtx,\n            const LocationContext *callerCtx)\n    : ProgramPoint(stmt, calleeCtx, CallEnterKind, callerCtx, nullptr) {}\n\n  const Stmt *getCallExpr() const {\n    return static_cast<const Stmt *>(getData1());\n  }\n\n  const StackFrameContext *getCalleeContext() const {\n    return static_cast<const StackFrameContext *>(getData2());\n  }\n\n  /// Returns the entry block in the CFG for the entered function.\n  const CFGBlock *getEntry() const {\n    const StackFrameContext *CalleeCtx = getCalleeContext();\n    const CFG *CalleeCFG = CalleeCtx->getCFG();\n    return &(CalleeCFG->getEntry());\n  }\n\nprivate:\n  friend class ProgramPoint;\n  CallEnter() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == CallEnterKind;\n  }\n};\n\n/// Represents a point when we start the call exit sequence (for inlined call).\n///\n/// The call exit is simulated with a sequence of nodes, which occur between\n/// CallExitBegin and CallExitEnd. The following operations occur between the\n/// two program points:\n/// - CallExitBegin\n/// - Bind the return value\n/// - Run Remove dead bindings (to clean up the dead symbols from the callee).\n/// - CallExitEnd\nclass CallExitBegin : public ProgramPoint {\npublic:\n  // CallExitBegin uses the callee's location context.\n  CallExitBegin(const StackFrameContext *L, const ReturnStmt *RS)\n    : ProgramPoint(RS, CallExitBeginKind, L, nullptr) { }\n\n  const ReturnStmt *getReturnStmt() const {\n    return static_cast<const ReturnStmt *>(getData1());\n  }\n\nprivate:\n  friend class ProgramPoint;\n  CallExitBegin() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == CallExitBeginKind;\n  }\n};\n\n/// Represents a point when we finish the call exit sequence (for inlined call).\n/// \\sa CallExitBegin\nclass CallExitEnd : public ProgramPoint {\npublic:\n  // CallExitEnd uses the caller's location context.\n  CallExitEnd(const StackFrameContext *CalleeCtx,\n              const LocationContext *CallerCtx)\n    : ProgramPoint(CalleeCtx, CallExitEndKind, CallerCtx, nullptr) {}\n\n  const StackFrameContext *getCalleeContext() const {\n    return static_cast<const StackFrameContext *>(getData1());\n  }\n\nprivate:\n  friend class ProgramPoint;\n  CallExitEnd() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == CallExitEndKind;\n  }\n};\n\n/// Represents a point when we exit a loop.\n/// When this ProgramPoint is encountered we can be sure that the symbolic\n/// execution of the corresponding LoopStmt is finished on the given path.\n/// Note: It is possible to encounter a LoopExit element when we haven't even\n/// encountered the loop itself. At the current state not all loop exits will\n/// result in a LoopExit program point.\nclass LoopExit : public ProgramPoint {\npublic:\n    LoopExit(const Stmt *LoopStmt, const LocationContext *LC)\n            : ProgramPoint(LoopStmt, nullptr, LoopExitKind, LC) {}\n\n    const Stmt *getLoopStmt() const {\n      return static_cast<const Stmt *>(getData1());\n    }\n\nprivate:\n    friend class ProgramPoint;\n    LoopExit() = default;\n    static bool isKind(const ProgramPoint &Location) {\n      return Location.getKind() == LoopExitKind;\n    }\n};\n\n/// This is a meta program point, which should be skipped by all the diagnostic\n/// reasoning etc.\nclass EpsilonPoint : public ProgramPoint {\npublic:\n  EpsilonPoint(const LocationContext *L, const void *Data1,\n               const void *Data2 = nullptr,\n               const ProgramPointTag *tag = nullptr)\n    : ProgramPoint(Data1, Data2, EpsilonKind, L, tag) {}\n\n  const void *getData() const { return getData1(); }\n\nprivate:\n  friend class ProgramPoint;\n  EpsilonPoint() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == EpsilonKind;\n  }\n};\n\n} // end namespace clang\n\n\nnamespace llvm { // Traits specialization for DenseMap\n\ntemplate <> struct DenseMapInfo<clang::ProgramPoint> {\n\nstatic inline clang::ProgramPoint getEmptyKey() {\n  uintptr_t x =\n   reinterpret_cast<uintptr_t>(DenseMapInfo<void*>::getEmptyKey()) & ~0x7;\n  return clang::BlockEntrance(reinterpret_cast<clang::CFGBlock*>(x), nullptr);\n}\n\nstatic inline clang::ProgramPoint getTombstoneKey() {\n  uintptr_t x =\n   reinterpret_cast<uintptr_t>(DenseMapInfo<void*>::getTombstoneKey()) & ~0x7;\n  return clang::BlockEntrance(reinterpret_cast<clang::CFGBlock*>(x), nullptr);\n}\n\nstatic unsigned getHashValue(const clang::ProgramPoint &Loc) {\n  return Loc.getHashValue();\n}\n\nstatic bool isEqual(const clang::ProgramPoint &L,\n                    const clang::ProgramPoint &R) {\n  return L == R;\n}\n\n};\n\n} // end namespace llvm\n\n#endif\n"}, "23": {"id": 23, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/Support/BumpVector.h", "content": "//===- BumpVector.h - Vector-like ADT that uses bump allocation -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file provides BumpVector, a vector-like ADT whose contents are\n//  allocated from a BumpPtrAllocator.\n//\n//===----------------------------------------------------------------------===//\n\n// FIXME: Most of this is copy-and-paste from SmallVector.h.  We can\n// refactor this core logic into something common that is shared between\n// the two.  The main thing that is different is the allocation strategy.\n\n#ifndef LLVM_CLANG_ANALYSIS_SUPPORT_BUMPVECTOR_H\n#define LLVM_CLANG_ANALYSIS_SUPPORT_BUMPVECTOR_H\n\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstring>\n#include <iterator>\n#include <memory>\n#include <type_traits>\n\nnamespace clang {\n\nclass BumpVectorContext {\n  llvm::PointerIntPair<llvm::BumpPtrAllocator*, 1> Alloc;\n\npublic:\n  /// Construct a new BumpVectorContext that creates a new BumpPtrAllocator\n  /// and destroys it when the BumpVectorContext object is destroyed.\n  BumpVectorContext() : Alloc(new llvm::BumpPtrAllocator(), 1) {}\n\n  BumpVectorContext(BumpVectorContext &&Other) : Alloc(Other.Alloc) {\n    Other.Alloc.setInt(false);\n    Other.Alloc.setPointer(nullptr);\n  }\n\n  /// Construct a new BumpVectorContext that reuses an existing\n  /// BumpPtrAllocator.  This BumpPtrAllocator is not destroyed when the\n  /// BumpVectorContext object is destroyed.\n  BumpVectorContext(llvm::BumpPtrAllocator &A) : Alloc(&A, 0) {}\n\n  ~BumpVectorContext() {\n    if (Alloc.getInt())\n      delete Alloc.getPointer();\n  }\n\n  llvm::BumpPtrAllocator &getAllocator() { return *Alloc.getPointer(); }\n};\n\ntemplate<typename T>\nclass BumpVector {\n  T *Begin = nullptr;\n  T *End = nullptr;\n  T *Capacity = nullptr;\n\npublic:\n  // Default ctor - Initialize to empty.\n  explicit BumpVector(BumpVectorContext &C, unsigned N) {\n    reserve(C, N);\n  }\n\n  ~BumpVector() {\n    if (std::is_class<T>::value) {\n      // Destroy the constructed elements in the vector.\n      destroy_range(Begin, End);\n    }\n  }\n\n  using size_type = size_t;\n  using difference_type = ptrdiff_t;\n  using value_type = T;\n  using iterator = T *;\n  using const_iterator = const T *;\n\n  using const_reverse_iterator = std::reverse_iterator<const_iterator>;\n  using reverse_iterator = std::reverse_iterator<iterator>;\n\n  using reference = T &;\n  using const_reference = const T &;\n  using pointer = T *;\n  using const_pointer = const T *;\n\n  // forward iterator creation methods.\n  iterator begin() { return Begin; }\n  const_iterator begin() const { return Begin; }\n  iterator end() { return End; }\n  const_iterator end() const { return End; }\n\n  // reverse iterator creation methods.\n  reverse_iterator rbegin() { return reverse_iterator(end()); }\n  const_reverse_iterator rbegin() const{ return const_reverse_iterator(end()); }\n  reverse_iterator rend() { return reverse_iterator(begin()); }\n  const_reverse_iterator rend() const {\n    return const_reverse_iterator(begin());\n  }\n\n  bool empty() const { return Begin == End; }\n  size_type size() const { return End-Begin; }\n\n  reference operator[](unsigned idx) {\n    assert(Begin + idx < End);\n    return Begin[idx];\n  }\n  const_reference operator[](unsigned idx) const {\n    assert(Begin + idx < End);\n    return Begin[idx];\n  }\n\n  reference front() {\n    return begin()[0];\n  }\n  const_reference front() const {\n    return begin()[0];\n  }\n\n  reference back() {\n    return end()[-1];\n  }\n  const_reference back() const {\n    return end()[-1];\n  }\n\n  void pop_back() {\n    --End;\n    End->~T();\n  }\n\n  T pop_back_val() {\n    T Result = back();\n    pop_back();\n    return Result;\n  }\n\n  void clear() {\n    if (std::is_class<T>::value) {\n      destroy_range(Begin, End);\n    }\n    End = Begin;\n  }\n\n  /// data - Return a pointer to the vector's buffer, even if empty().\n  pointer data() {\n    return pointer(Begin);\n  }\n\n  /// data - Return a pointer to the vector's buffer, even if empty().\n  const_pointer data() const {\n    return const_pointer(Begin);\n  }\n\n  void push_back(const_reference Elt, BumpVectorContext &C) {\n    if (End < Capacity) {\n    Retry:\n      new (End) T(Elt);\n      ++End;\n      return;\n    }\n    grow(C);\n    goto Retry;\n  }\n\n  /// insert - Insert some number of copies of element into a position. Return\n  /// iterator to position after last inserted copy.\n  iterator insert(iterator I, size_t Cnt, const_reference E,\n      BumpVectorContext &C) {\n    assert(I >= Begin && I <= End && \"Iterator out of bounds.\");\n    if (End + Cnt <= Capacity) {\n    Retry:\n      move_range_right(I, End, Cnt);\n      construct_range(I, I + Cnt, E);\n      End += Cnt;\n      return I + Cnt;\n    }\n    ptrdiff_t D = I - Begin;\n    grow(C, size() + Cnt);\n    I = Begin + D;\n    goto Retry;\n  }\n\n  void reserve(BumpVectorContext &C, unsigned N) {\n    if (unsigned(Capacity-Begin) < N)\n      grow(C, N);\n  }\n\n  /// capacity - Return the total number of elements in the currently allocated\n  /// buffer.\n  size_t capacity() const { return Capacity - Begin; }\n\nprivate:\n  /// grow - double the size of the allocated memory, guaranteeing space for at\n  /// least one more element or MinSize if specified.\n  void grow(BumpVectorContext &C, size_type MinSize = 1);\n\n  void construct_range(T *S, T *E, const T &Elt) {\n    for (; S != E; ++S)\n      new (S) T(Elt);\n  }\n\n  void destroy_range(T *S, T *E) {\n    while (S != E) {\n      --E;\n      E->~T();\n    }\n  }\n\n  void move_range_right(T *S, T *E, size_t D) {\n    for (T *I = E + D - 1, *IL = S + D - 1; I != IL; --I) {\n      --E;\n      new (I) T(*E);\n      E->~T();\n    }\n  }\n};\n\n// Define this out-of-line to dissuade the C++ compiler from inlining it.\ntemplate <typename T>\nvoid BumpVector<T>::grow(BumpVectorContext &C, size_t MinSize) {\n  size_t CurCapacity = Capacity-Begin;\n  size_t CurSize = size();\n  size_t NewCapacity = 2*CurCapacity;\n  if (NewCapacity < MinSize)\n    NewCapacity = MinSize;\n\n  // Allocate the memory from the BumpPtrAllocator.\n  T *NewElts = C.getAllocator().template Allocate<T>(NewCapacity);\n\n  // Copy the elements over.\n  if (Begin != End) {\n    if (std::is_class<T>::value) {\n      std::uninitialized_copy(Begin, End, NewElts);\n      // Destroy the original elements.\n      destroy_range(Begin, End);\n    } else {\n      // Use memcpy for PODs (std::uninitialized_copy optimizes to memmove).\n      memcpy(NewElts, Begin, CurSize * sizeof(T));\n    }\n  }\n\n  // For now, leak 'Begin'.  We can add it back to a freelist in\n  // BumpVectorContext.\n  Begin = NewElts;\n  End = NewElts+CurSize;\n  Capacity = Begin+NewCapacity;\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_ANALYSIS_SUPPORT_BUMPVECTOR_H\n"}, "24": {"id": 24, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/CodeGenOptions.h", "content": "//===--- CodeGenOptions.h ---------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the CodeGenOptions interface.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_CODEGENOPTIONS_H\n#define LLVM_CLANG_BASIC_CODEGENOPTIONS_H\n\n#include \"clang/Basic/DebugInfoOptions.h\"\n#include \"clang/Basic/Sanitizers.h\"\n#include \"clang/Basic/XRayInstr.h\"\n#include \"llvm/ADT/FloatingPointMode.h\"\n#include \"llvm/Support/CodeGen.h\"\n#include \"llvm/Support/Regex.h\"\n#include \"llvm/Target/TargetOptions.h\"\n#include \"llvm/Transforms/Instrumentation/AddressSanitizerOptions.h\"\n#include <map>\n#include <memory>\n#include <string>\n#include <vector>\n\nnamespace clang {\n\n/// Bitfields of CodeGenOptions, split out from CodeGenOptions to ensure\n/// that this large collection of bitfields is a trivial class type.\nclass CodeGenOptionsBase {\n  friend class CompilerInvocation;\n\npublic:\n#define CODEGENOPT(Name, Bits, Default) unsigned Name : Bits;\n#define ENUM_CODEGENOPT(Name, Type, Bits, Default)\n#include \"clang/Basic/CodeGenOptions.def\"\n\nprotected:\n#define CODEGENOPT(Name, Bits, Default)\n#define ENUM_CODEGENOPT(Name, Type, Bits, Default) unsigned Name : Bits;\n#include \"clang/Basic/CodeGenOptions.def\"\n};\n\n/// CodeGenOptions - Track various options which control how the code\n/// is optimized and passed to the backend.\nclass CodeGenOptions : public CodeGenOptionsBase {\npublic:\n  enum InliningMethod {\n    NormalInlining,     // Use the standard function inlining pass.\n    OnlyHintInlining,   // Inline only (implicitly) hinted functions.\n    OnlyAlwaysInlining  // Only run the always inlining pass.\n  };\n\n  enum VectorLibrary {\n    NoLibrary,  // Don't use any vector library.\n    Accelerate, // Use the Accelerate framework.\n    LIBMVEC,    // GLIBC vector math library.\n    MASSV,      // IBM MASS vector library.\n    SVML        // Intel short vector math library.\n  };\n\n  enum ObjCDispatchMethodKind {\n    Legacy = 0,\n    NonLegacy = 1,\n    Mixed = 2\n  };\n\n  enum TLSModel {\n    GeneralDynamicTLSModel,\n    LocalDynamicTLSModel,\n    InitialExecTLSModel,\n    LocalExecTLSModel\n  };\n\n  /// Clang versions with different platform ABI conformance.\n  enum class ClangABI {\n    /// Attempt to be ABI-compatible with code generated by Clang 3.8.x\n    /// (SVN r257626). This causes <1 x long long> to be passed in an\n    /// integer register instead of an SSE register on x64_64.\n    Ver3_8,\n\n    /// Attempt to be ABI-compatible with code generated by Clang 4.0.x\n    /// (SVN r291814). This causes move operations to be ignored when\n    /// determining whether a class type can be passed or returned directly.\n    Ver4,\n\n    /// Conform to the underlying platform's C and C++ ABIs as closely\n    /// as we can.\n    Latest\n  };\n\n  enum StructReturnConventionKind {\n    SRCK_Default,  // No special option was passed.\n    SRCK_OnStack,  // Small structs on the stack (-fpcc-struct-return).\n    SRCK_InRegs    // Small structs in registers (-freg-struct-return).\n  };\n\n  enum ProfileInstrKind {\n    ProfileNone,       // Profile instrumentation is turned off.\n    ProfileClangInstr, // Clang instrumentation to generate execution counts\n                       // to use with PGO.\n    ProfileIRInstr,    // IR level PGO instrumentation in LLVM.\n    ProfileCSIRInstr, // IR level PGO context sensitive instrumentation in LLVM.\n  };\n\n  enum EmbedBitcodeKind {\n    Embed_Off,      // No embedded bitcode.\n    Embed_All,      // Embed both bitcode and commandline in the output.\n    Embed_Bitcode,  // Embed just the bitcode in the output.\n    Embed_Marker    // Embed a marker as a placeholder for bitcode.\n  };\n\n  // This field stores one of the allowed values for the option\n  // -fbasic-block-sections=.  The allowed values with this option are:\n  // {\"labels\", \"all\", \"list=<file>\", \"none\"}.\n  //\n  // \"labels\":      Only generate basic block symbols (labels) for all basic\n  //                blocks, do not generate unique sections for basic blocks.\n  //                Use the machine basic block id in the symbol name to\n  //                associate profile info from virtual address to machine\n  //                basic block.\n  // \"all\" :        Generate basic block sections for all basic blocks.\n  // \"list=<file>\": Generate basic block sections for a subset of basic blocks.\n  //                The functions and the machine basic block ids are specified\n  //                in the file.\n  // \"none\":        Disable sections/labels for basic blocks.\n  std::string BBSections;\n\n  // If set, override the default value of MCAsmInfo::BinutilsVersion. If\n  // DisableIntegratedAS is specified, the assembly output will consider GNU as\n  // support. \"none\" means that all ELF features can be used, regardless of\n  // binutils support.\n  std::string BinutilsVersion;\n\n  enum class FramePointerKind {\n    None,        // Omit all frame pointers.\n    NonLeaf,     // Keep non-leaf frame pointers.\n    All,         // Keep all frame pointers.\n  };\n\n  enum FiniteLoopsKind {\n    Language, // Not specified, use language standard.\n    Always,   // All loops are assumed to be finite.\n    Never,    // No loop is assumed to be finite.\n  };\n\n  /// The code model to use (-mcmodel).\n  std::string CodeModel;\n\n  /// The filename with path we use for coverage data files. The runtime\n  /// allows further manipulation with the GCOV_PREFIX and GCOV_PREFIX_STRIP\n  /// environment variables.\n  std::string CoverageDataFile;\n\n  /// The filename with path we use for coverage notes files.\n  std::string CoverageNotesFile;\n\n  /// Regexes separated by a semi-colon to filter the files to instrument.\n  std::string ProfileFilterFiles;\n\n  /// Regexes separated by a semi-colon to filter the files to not instrument.\n  std::string ProfileExcludeFiles;\n\n  /// The version string to put into coverage files.\n  char CoverageVersion[4];\n\n  /// Enable additional debugging information.\n  std::string DebugPass;\n\n  /// The string to embed in debug information as the current working directory.\n  std::string DebugCompilationDir;\n\n  /// The string to embed in coverage mapping as the current working directory.\n  std::string CoverageCompilationDir;\n\n  /// The string to embed in the debug information for the compile unit, if\n  /// non-empty.\n  std::string DwarfDebugFlags;\n\n  /// The string containing the commandline for the llvm.commandline metadata,\n  /// if non-empty.\n  std::string RecordCommandLine;\n\n  std::map<std::string, std::string> DebugPrefixMap;\n  std::map<std::string, std::string> CoveragePrefixMap;\n\n  /// The ABI to use for passing floating point arguments.\n  std::string FloatABI;\n\n  /// The floating-point denormal mode to use.\n  llvm::DenormalMode FPDenormalMode = llvm::DenormalMode::getIEEE();\n\n  /// The floating-point denormal mode to use, for float.\n  llvm::DenormalMode FP32DenormalMode = llvm::DenormalMode::getIEEE();\n\n  /// The float precision limit to use, if non-empty.\n  std::string LimitFloatPrecision;\n\n  struct BitcodeFileToLink {\n    /// The filename of the bitcode file to link in.\n    std::string Filename;\n    /// If true, we set attributes functions in the bitcode library according to\n    /// our CodeGenOptions, much as we set attrs on functions that we generate\n    /// ourselves.\n    bool PropagateAttrs = false;\n    /// If true, we use LLVM module internalizer.\n    bool Internalize = false;\n    /// Bitwise combination of llvm::Linker::Flags, passed to the LLVM linker.\n    unsigned LinkFlags = 0;\n  };\n\n  /// The files specified here are linked in to the module before optimizations.\n  std::vector<BitcodeFileToLink> LinkBitcodeFiles;\n\n  /// The user provided name for the \"main file\", if non-empty. This is useful\n  /// in situations where the input file name does not match the original input\n  /// file, for example with -save-temps.\n  std::string MainFileName;\n\n  /// The name for the split debug info file used for the DW_AT_[GNU_]dwo_name\n  /// attribute in the skeleton CU.\n  std::string SplitDwarfFile;\n\n  /// Output filename for the split debug info, not used in the skeleton CU.\n  std::string SplitDwarfOutput;\n\n  /// The name of the relocation model to use.\n  llvm::Reloc::Model RelocationModel;\n\n  /// If not an empty string, trap intrinsics are lowered to calls to this\n  /// function instead of to trap instructions.\n  std::string TrapFuncName;\n\n  /// A list of dependent libraries.\n  std::vector<std::string> DependentLibraries;\n\n  /// A list of linker options to embed in the object file.\n  std::vector<std::string> LinkerOptions;\n\n  /// Name of the profile file to use as output for -fprofile-instr-generate,\n  /// -fprofile-generate, and -fcs-profile-generate.\n  std::string InstrProfileOutput;\n\n  /// Name of the profile file to use with -fprofile-sample-use.\n  std::string SampleProfileFile;\n\n  /// Name of the profile file to use as output for with -fmemory-profile.\n  std::string MemoryProfileOutput;\n\n  /// Name of the profile file to use as input for -fprofile-instr-use\n  std::string ProfileInstrumentUsePath;\n\n  /// Name of the profile remapping file to apply to the profile data supplied\n  /// by -fprofile-sample-use or -fprofile-instr-use.\n  std::string ProfileRemappingFile;\n\n  /// Name of the function summary index file to use for ThinLTO function\n  /// importing.\n  std::string ThinLTOIndexFile;\n\n  /// Name of a file that can optionally be written with minimized bitcode\n  /// to be used as input for the ThinLTO thin link step, which only needs\n  /// the summary and module symbol table (and not, e.g. any debug metadata).\n  std::string ThinLinkBitcodeFile;\n\n  /// Prefix to use for -save-temps output.\n  std::string SaveTempsFilePrefix;\n\n  /// Name of file passed with -fcuda-include-gpubinary option to forward to\n  /// CUDA runtime back-end for incorporating them into host-side object file.\n  std::string CudaGpuBinaryFileName;\n\n  /// The name of the file to which the backend should save YAML optimization\n  /// records.\n  std::string OptRecordFile;\n\n  /// The regex that filters the passes that should be saved to the optimization\n  /// records.\n  std::string OptRecordPasses;\n\n  /// The format used for serializing remarks (default: YAML)\n  std::string OptRecordFormat;\n\n  /// The name of the partition that symbols are assigned to, specified with\n  /// -fsymbol-partition (see https://lld.llvm.org/Partitions.html).\n  std::string SymbolPartition;\n\n  enum RemarkKind {\n    RK_Missing,            // Remark argument not present on the command line.\n    RK_Enabled,            // Remark enabled via '-Rgroup'.\n    RK_EnabledEverything,  // Remark enabled via '-Reverything'.\n    RK_Disabled,           // Remark disabled via '-Rno-group'.\n    RK_DisabledEverything, // Remark disabled via '-Rno-everything'.\n    RK_WithPattern,        // Remark pattern specified via '-Rgroup=regexp'.\n  };\n\n  /// Optimization remark with an optional regular expression pattern.\n  struct OptRemark {\n    RemarkKind Kind;\n    std::string Pattern;\n    std::shared_ptr<llvm::Regex> Regex;\n\n    /// By default, optimization remark is missing.\n    OptRemark() : Kind(RK_Missing), Pattern(\"\"), Regex(nullptr) {}\n\n    /// Returns true iff the optimization remark holds a valid regular\n    /// expression.\n    bool hasValidPattern() const { return Regex != nullptr; }\n\n    /// Matches the given string against the regex, if there is some.\n    bool patternMatches(StringRef String) const {\n      return hasValidPattern() && Regex->match(String);\n    }\n  };\n\n  /// Selected optimizations for which we should enable optimization remarks.\n  /// Transformation passes whose name matches the contained (optional) regular\n  /// expression (and support this feature), will emit a diagnostic whenever\n  /// they perform a transformation.\n  OptRemark OptimizationRemark;\n\n  /// Selected optimizations for which we should enable missed optimization\n  /// remarks. Transformation passes whose name matches the contained (optional)\n  /// regular expression (and support this feature), will emit a diagnostic\n  /// whenever they tried but failed to perform a transformation.\n  OptRemark OptimizationRemarkMissed;\n\n  /// Selected optimizations for which we should enable optimization analyses.\n  /// Transformation passes whose name matches the contained (optional) regular\n  /// expression (and support this feature), will emit a diagnostic whenever\n  /// they want to explain why they decided to apply or not apply a given\n  /// transformation.\n  OptRemark OptimizationRemarkAnalysis;\n\n  /// Set of files defining the rules for the symbol rewriting.\n  std::vector<std::string> RewriteMapFiles;\n\n  /// Set of sanitizer checks that are non-fatal (i.e. execution should be\n  /// continued when possible).\n  SanitizerSet SanitizeRecover;\n\n  /// Set of sanitizer checks that trap rather than diagnose.\n  SanitizerSet SanitizeTrap;\n\n  /// List of backend command-line options for -fembed-bitcode.\n  std::vector<uint8_t> CmdArgs;\n\n  /// A list of all -fno-builtin-* function names (e.g., memset).\n  std::vector<std::string> NoBuiltinFuncs;\n\n  std::vector<std::string> Reciprocals;\n\n  /// The preferred width for auto-vectorization transforms. This is intended to\n  /// override default transforms based on the width of the architected vector\n  /// registers.\n  std::string PreferVectorWidth;\n\n  /// Set of XRay instrumentation kinds to emit.\n  XRayInstrSet XRayInstrumentationBundle;\n\n  std::vector<std::string> DefaultFunctionAttrs;\n\n  /// List of dynamic shared object files to be loaded as pass plugins.\n  std::vector<std::string> PassPlugins;\n\n  /// Path to allowlist file specifying which objects\n  /// (files, functions) should exclusively be instrumented\n  /// by sanitizer coverage pass.\n  std::vector<std::string> SanitizeCoverageAllowlistFiles;\n\n  /// The guard style used for stack protector to get a initial value, this\n  /// value usually be gotten from TLS or get from __stack_chk_guard, or some\n  /// other styles we may implement in the future.\n  std::string StackProtectorGuard;\n\n  /// The TLS base register when StackProtectorGuard is \"tls\".\n  /// On x86 this can be \"fs\" or \"gs\".\n  std::string StackProtectorGuardReg;\n\n  /// Path to blocklist file specifying which objects\n  /// (files, functions) listed for instrumentation by sanitizer\n  /// coverage pass should actually not be instrumented.\n  std::vector<std::string> SanitizeCoverageBlocklistFiles;\n\n  /// Executable and command-line used to create a given CompilerInvocation.\n  /// Most of the time this will be the full -cc1 command.\n  const char *Argv0 = nullptr;\n  ArrayRef<const char *> CommandLineArgs;\n\n  /// The minimum hotness value a diagnostic needs in order to be included in\n  /// optimization diagnostics.\n  ///\n  /// The threshold is an Optional value, which maps to one of the 3 states:\n  /// 1. 0            => threshold disabled. All remarks will be printed.\n  /// 2. positive int => manual threshold by user. Remarks with hotness exceed\n  ///                    threshold will be printed.\n  /// 3. None         => 'auto' threshold by user. The actual value is not\n  ///                    available at command line, but will be synced with\n  ///                    hotness threshold from profile summary during\n  ///                    compilation.\n  ///\n  /// If threshold option is not specified, it is disabled by default.\n  Optional<uint64_t> DiagnosticsHotnessThreshold = 0;\n\npublic:\n  // Define accessors/mutators for code generation options of enumeration type.\n#define CODEGENOPT(Name, Bits, Default)\n#define ENUM_CODEGENOPT(Name, Type, Bits, Default) \\\n  Type get##Name() const { return static_cast<Type>(Name); } \\\n  void set##Name(Type Value) { Name = static_cast<unsigned>(Value); }\n#include \"clang/Basic/CodeGenOptions.def\"\n\n  CodeGenOptions();\n\n  const std::vector<std::string> &getNoBuiltinFuncs() const {\n    return NoBuiltinFuncs;\n  }\n\n  /// Check if Clang profile instrumenation is on.\n  bool hasProfileClangInstr() const {\n    return getProfileInstr() == ProfileClangInstr;\n  }\n\n  /// Check if IR level profile instrumentation is on.\n  bool hasProfileIRInstr() const {\n    return getProfileInstr() == ProfileIRInstr;\n  }\n\n  /// Check if CS IR level profile instrumentation is on.\n  bool hasProfileCSIRInstr() const {\n    return getProfileInstr() == ProfileCSIRInstr;\n  }\n\n  /// Check if Clang profile use is on.\n  bool hasProfileClangUse() const {\n    return getProfileUse() == ProfileClangInstr;\n  }\n\n  /// Check if IR level profile use is on.\n  bool hasProfileIRUse() const {\n    return getProfileUse() == ProfileIRInstr ||\n           getProfileUse() == ProfileCSIRInstr;\n  }\n\n  /// Check if CSIR profile use is on.\n  bool hasProfileCSIRUse() const { return getProfileUse() == ProfileCSIRInstr; }\n\n  /// Check if type and variable info should be emitted.\n  bool hasReducedDebugInfo() const {\n    return getDebugInfo() >= codegenoptions::DebugInfoConstructor;\n  }\n\n  /// Check if maybe unused type info should be emitted.\n  bool hasMaybeUnusedDebugInfo() const {\n    return getDebugInfo() >= codegenoptions::UnusedTypeInfo;\n  }\n};\n\n}  // end namespace clang\n\n#endif\n"}, "25": {"id": 25, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Diagnostic.h", "content": "//===- Diagnostic.h - C Language Family Diagnostic Handling -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the Diagnostic-related interfaces.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_DIAGNOSTIC_H\n#define LLVM_CLANG_BASIC_DIAGNOSTIC_H\n\n#include \"clang/Basic/DiagnosticIDs.h\"\n#include \"clang/Basic/DiagnosticOptions.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Compiler.h\"\n#include <cassert>\n#include <cstdint>\n#include <limits>\n#include <list>\n#include <map>\n#include <memory>\n#include <string>\n#include <type_traits>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\nclass Error;\n}\n\nnamespace clang {\n\nclass DeclContext;\nclass DiagnosticBuilder;\nclass DiagnosticConsumer;\nclass IdentifierInfo;\nclass LangOptions;\nclass Preprocessor;\nclass SourceManager;\nclass StoredDiagnostic;\n\nnamespace tok {\n\nenum TokenKind : unsigned short;\n\n} // namespace tok\n\n/// Annotates a diagnostic with some code that should be\n/// inserted, removed, or replaced to fix the problem.\n///\n/// This kind of hint should be used when we are certain that the\n/// introduction, removal, or modification of a particular (small!)\n/// amount of code will correct a compilation error. The compiler\n/// should also provide full recovery from such errors, such that\n/// suppressing the diagnostic output can still result in successful\n/// compilation.\nclass FixItHint {\npublic:\n  /// Code that should be replaced to correct the error. Empty for an\n  /// insertion hint.\n  CharSourceRange RemoveRange;\n\n  /// Code in the specific range that should be inserted in the insertion\n  /// location.\n  CharSourceRange InsertFromRange;\n\n  /// The actual code to insert at the insertion location, as a\n  /// string.\n  std::string CodeToInsert;\n\n  bool BeforePreviousInsertions = false;\n\n  /// Empty code modification hint, indicating that no code\n  /// modification is known.\n  FixItHint() = default;\n\n  bool isNull() const {\n    return !RemoveRange.isValid();\n  }\n\n  /// Create a code modification hint that inserts the given\n  /// code string at a specific location.\n  static FixItHint CreateInsertion(SourceLocation InsertionLoc,\n                                   StringRef Code,\n                                   bool BeforePreviousInsertions = false) {\n    FixItHint Hint;\n    Hint.RemoveRange =\n      CharSourceRange::getCharRange(InsertionLoc, InsertionLoc);\n    Hint.CodeToInsert = std::string(Code);\n    Hint.BeforePreviousInsertions = BeforePreviousInsertions;\n    return Hint;\n  }\n\n  /// Create a code modification hint that inserts the given\n  /// code from \\p FromRange at a specific location.\n  static FixItHint CreateInsertionFromRange(SourceLocation InsertionLoc,\n                                            CharSourceRange FromRange,\n                                        bool BeforePreviousInsertions = false) {\n    FixItHint Hint;\n    Hint.RemoveRange =\n      CharSourceRange::getCharRange(InsertionLoc, InsertionLoc);\n    Hint.InsertFromRange = FromRange;\n    Hint.BeforePreviousInsertions = BeforePreviousInsertions;\n    return Hint;\n  }\n\n  /// Create a code modification hint that removes the given\n  /// source range.\n  static FixItHint CreateRemoval(CharSourceRange RemoveRange) {\n    FixItHint Hint;\n    Hint.RemoveRange = RemoveRange;\n    return Hint;\n  }\n  static FixItHint CreateRemoval(SourceRange RemoveRange) {\n    return CreateRemoval(CharSourceRange::getTokenRange(RemoveRange));\n  }\n\n  /// Create a code modification hint that replaces the given\n  /// source range with the given code string.\n  static FixItHint CreateReplacement(CharSourceRange RemoveRange,\n                                     StringRef Code) {\n    FixItHint Hint;\n    Hint.RemoveRange = RemoveRange;\n    Hint.CodeToInsert = std::string(Code);\n    return Hint;\n  }\n\n  static FixItHint CreateReplacement(SourceRange RemoveRange,\n                                     StringRef Code) {\n    return CreateReplacement(CharSourceRange::getTokenRange(RemoveRange), Code);\n  }\n};\n\nstruct DiagnosticStorage {\n  enum {\n    /// The maximum number of arguments we can hold. We\n    /// currently only support up to 10 arguments (%0-%9).\n    ///\n    /// A single diagnostic with more than that almost certainly has to\n    /// be simplified anyway.\n    MaxArguments = 10\n  };\n\n  /// The number of entries in Arguments.\n  unsigned char NumDiagArgs = 0;\n\n  /// Specifies for each argument whether it is in DiagArgumentsStr\n  /// or in DiagArguments.\n  unsigned char DiagArgumentsKind[MaxArguments];\n\n  /// The values for the various substitution positions.\n  ///\n  /// This is used when the argument is not an std::string. The specific value\n  /// is mangled into an intptr_t and the interpretation depends on exactly\n  /// what sort of argument kind it is.\n  intptr_t DiagArgumentsVal[MaxArguments];\n\n  /// The values for the various substitution positions that have\n  /// string arguments.\n  std::string DiagArgumentsStr[MaxArguments];\n\n  /// The list of ranges added to this diagnostic.\n  SmallVector<CharSourceRange, 8> DiagRanges;\n\n  /// If valid, provides a hint with some code to insert, remove, or\n  /// modify at a particular position.\n  SmallVector<FixItHint, 6> FixItHints;\n\n  DiagnosticStorage() = default;\n};\n\n/// Concrete class used by the front-end to report problems and issues.\n///\n/// This massages the diagnostics (e.g. handling things like \"report warnings\n/// as errors\" and passes them off to the DiagnosticConsumer for reporting to\n/// the user. DiagnosticsEngine is tied to one translation unit and one\n/// SourceManager.\nclass DiagnosticsEngine : public RefCountedBase<DiagnosticsEngine> {\npublic:\n  /// The level of the diagnostic, after it has been through mapping.\n  enum Level {\n    Ignored = DiagnosticIDs::Ignored,\n    Note = DiagnosticIDs::Note,\n    Remark = DiagnosticIDs::Remark,\n    Warning = DiagnosticIDs::Warning,\n    Error = DiagnosticIDs::Error,\n    Fatal = DiagnosticIDs::Fatal\n  };\n\n  enum ArgumentKind {\n    /// std::string\n    ak_std_string,\n\n    /// const char *\n    ak_c_string,\n\n    /// int\n    ak_sint,\n\n    /// unsigned\n    ak_uint,\n\n    /// enum TokenKind : unsigned\n    ak_tokenkind,\n\n    /// IdentifierInfo\n    ak_identifierinfo,\n\n    /// address space\n    ak_addrspace,\n\n    /// Qualifiers\n    ak_qual,\n\n    /// QualType\n    ak_qualtype,\n\n    /// DeclarationName\n    ak_declarationname,\n\n    /// NamedDecl *\n    ak_nameddecl,\n\n    /// NestedNameSpecifier *\n    ak_nestednamespec,\n\n    /// DeclContext *\n    ak_declcontext,\n\n    /// pair<QualType, QualType>\n    ak_qualtype_pair,\n\n    /// Attr *\n    ak_attr\n  };\n\n  /// Represents on argument value, which is a union discriminated\n  /// by ArgumentKind, with a value.\n  using ArgumentValue = std::pair<ArgumentKind, intptr_t>;\n\nprivate:\n  // Used by __extension__\n  unsigned char AllExtensionsSilenced = 0;\n\n  // Treat fatal errors like errors.\n  bool FatalsAsError = false;\n\n  // Suppress all diagnostics.\n  bool SuppressAllDiagnostics = false;\n\n  // Elide common types of templates.\n  bool ElideType = true;\n\n  // Print a tree when comparing templates.\n  bool PrintTemplateTree = false;\n\n  // Color printing is enabled.\n  bool ShowColors = false;\n\n  // Which overload candidates to show.\n  OverloadsShown ShowOverloads = Ovl_All;\n\n  // With Ovl_Best, the number of overload candidates to show when we encounter\n  // an error.\n  //\n  // The value here is the number of candidates to show in the first nontrivial\n  // error.  Future errors may show a different number of candidates.\n  unsigned NumOverloadsToShow = 32;\n\n  // Cap of # errors emitted, 0 -> no limit.\n  unsigned ErrorLimit = 0;\n\n  // Cap on depth of template backtrace stack, 0 -> no limit.\n  unsigned TemplateBacktraceLimit = 0;\n\n  // Cap on depth of constexpr evaluation backtrace stack, 0 -> no limit.\n  unsigned ConstexprBacktraceLimit = 0;\n\n  IntrusiveRefCntPtr<DiagnosticIDs> Diags;\n  IntrusiveRefCntPtr<DiagnosticOptions> DiagOpts;\n  DiagnosticConsumer *Client = nullptr;\n  std::unique_ptr<DiagnosticConsumer> Owner;\n  SourceManager *SourceMgr = nullptr;\n\n  /// Mapping information for diagnostics.\n  ///\n  /// Mapping info is packed into four bits per diagnostic.  The low three\n  /// bits are the mapping (an instance of diag::Severity), or zero if unset.\n  /// The high bit is set when the mapping was established as a user mapping.\n  /// If the high bit is clear, then the low bits are set to the default\n  /// value, and should be mapped with -pedantic, -Werror, etc.\n  ///\n  /// A new DiagState is created and kept around when diagnostic pragmas modify\n  /// the state so that we know what is the diagnostic state at any given\n  /// source location.\n  class DiagState {\n    llvm::DenseMap<unsigned, DiagnosticMapping> DiagMap;\n\n  public:\n    // \"Global\" configuration state that can actually vary between modules.\n\n    // Ignore all warnings: -w\n    unsigned IgnoreAllWarnings : 1;\n\n    // Enable all warnings.\n    unsigned EnableAllWarnings : 1;\n\n    // Treat warnings like errors.\n    unsigned WarningsAsErrors : 1;\n\n    // Treat errors like fatal errors.\n    unsigned ErrorsAsFatal : 1;\n\n    // Suppress warnings in system headers.\n    unsigned SuppressSystemWarnings : 1;\n\n    // Map extensions to warnings or errors?\n    diag::Severity ExtBehavior = diag::Severity::Ignored;\n\n    DiagState()\n        : IgnoreAllWarnings(false), EnableAllWarnings(false),\n          WarningsAsErrors(false), ErrorsAsFatal(false),\n          SuppressSystemWarnings(false) {}\n\n    using iterator = llvm::DenseMap<unsigned, DiagnosticMapping>::iterator;\n    using const_iterator =\n        llvm::DenseMap<unsigned, DiagnosticMapping>::const_iterator;\n\n    void setMapping(diag::kind Diag, DiagnosticMapping Info) {\n      DiagMap[Diag] = Info;\n    }\n\n    DiagnosticMapping lookupMapping(diag::kind Diag) const {\n      return DiagMap.lookup(Diag);\n    }\n\n    DiagnosticMapping &getOrAddMapping(diag::kind Diag);\n\n    const_iterator begin() const { return DiagMap.begin(); }\n    const_iterator end() const { return DiagMap.end(); }\n  };\n\n  /// Keeps and automatically disposes all DiagStates that we create.\n  std::list<DiagState> DiagStates;\n\n  /// A mapping from files to the diagnostic states for those files. Lazily\n  /// built on demand for files in which the diagnostic state has not changed.\n  class DiagStateMap {\n  public:\n    /// Add an initial diagnostic state.\n    void appendFirst(DiagState *State);\n\n    /// Add a new latest state point.\n    void append(SourceManager &SrcMgr, SourceLocation Loc, DiagState *State);\n\n    /// Look up the diagnostic state at a given source location.\n    DiagState *lookup(SourceManager &SrcMgr, SourceLocation Loc) const;\n\n    /// Determine whether this map is empty.\n    bool empty() const { return Files.empty(); }\n\n    /// Clear out this map.\n    void clear() {\n      Files.clear();\n      FirstDiagState = CurDiagState = nullptr;\n      CurDiagStateLoc = SourceLocation();\n    }\n\n    /// Produce a debugging dump of the diagnostic state.\n    LLVM_DUMP_METHOD void dump(SourceManager &SrcMgr,\n                               StringRef DiagName = StringRef()) const;\n\n    /// Grab the most-recently-added state point.\n    DiagState *getCurDiagState() const { return CurDiagState; }\n\n    /// Get the location at which a diagnostic state was last added.\n    SourceLocation getCurDiagStateLoc() const { return CurDiagStateLoc; }\n\n  private:\n    friend class ASTReader;\n    friend class ASTWriter;\n\n    /// Represents a point in source where the diagnostic state was\n    /// modified because of a pragma.\n    ///\n    /// 'Loc' can be null if the point represents the diagnostic state\n    /// modifications done through the command-line.\n    struct DiagStatePoint {\n      DiagState *State;\n      unsigned Offset;\n\n      DiagStatePoint(DiagState *State, unsigned Offset)\n          : State(State), Offset(Offset) {}\n    };\n\n    /// Description of the diagnostic states and state transitions for a\n    /// particular FileID.\n    struct File {\n      /// The diagnostic state for the parent file. This is strictly redundant,\n      /// as looking up the DecomposedIncludedLoc for the FileID in the Files\n      /// map would give us this, but we cache it here for performance.\n      File *Parent = nullptr;\n\n      /// The offset of this file within its parent.\n      unsigned ParentOffset = 0;\n\n      /// Whether this file has any local (not imported from an AST file)\n      /// diagnostic state transitions.\n      bool HasLocalTransitions = false;\n\n      /// The points within the file where the state changes. There will always\n      /// be at least one of these (the state on entry to the file).\n      llvm::SmallVector<DiagStatePoint, 4> StateTransitions;\n\n      DiagState *lookup(unsigned Offset) const;\n    };\n\n    /// The diagnostic states for each file.\n    mutable std::map<FileID, File> Files;\n\n    /// The initial diagnostic state.\n    DiagState *FirstDiagState;\n\n    /// The current diagnostic state.\n    DiagState *CurDiagState;\n\n    /// The location at which the current diagnostic state was established.\n    SourceLocation CurDiagStateLoc;\n\n    /// Get the diagnostic state information for a file.\n    File *getFile(SourceManager &SrcMgr, FileID ID) const;\n  };\n\n  DiagStateMap DiagStatesByLoc;\n\n  /// Keeps the DiagState that was active during each diagnostic 'push'\n  /// so we can get back at it when we 'pop'.\n  std::vector<DiagState *> DiagStateOnPushStack;\n\n  DiagState *GetCurDiagState() const {\n    return DiagStatesByLoc.getCurDiagState();\n  }\n\n  void PushDiagStatePoint(DiagState *State, SourceLocation L);\n\n  /// Finds the DiagStatePoint that contains the diagnostic state of\n  /// the given source location.\n  DiagState *GetDiagStateForLoc(SourceLocation Loc) const {\n    return SourceMgr ? DiagStatesByLoc.lookup(*SourceMgr, Loc)\n                     : DiagStatesByLoc.getCurDiagState();\n  }\n\n  /// Sticky flag set to \\c true when an error is emitted.\n  bool ErrorOccurred;\n\n  /// Sticky flag set to \\c true when an \"uncompilable error\" occurs.\n  /// I.e. an error that was not upgraded from a warning by -Werror.\n  bool UncompilableErrorOccurred;\n\n  /// Sticky flag set to \\c true when a fatal error is emitted.\n  bool FatalErrorOccurred;\n\n  /// Indicates that an unrecoverable error has occurred.\n  bool UnrecoverableErrorOccurred;\n\n  /// Counts for DiagnosticErrorTrap to check whether an error occurred\n  /// during a parsing section, e.g. during parsing a function.\n  unsigned TrapNumErrorsOccurred;\n  unsigned TrapNumUnrecoverableErrorsOccurred;\n\n  /// The level of the last diagnostic emitted.\n  ///\n  /// This is used to emit continuation diagnostics with the same level as the\n  /// diagnostic that they follow.\n  DiagnosticIDs::Level LastDiagLevel;\n\n  /// Number of warnings reported\n  unsigned NumWarnings;\n\n  /// Number of errors reported\n  unsigned NumErrors;\n\n  /// A function pointer that converts an opaque diagnostic\n  /// argument to a strings.\n  ///\n  /// This takes the modifiers and argument that was present in the diagnostic.\n  ///\n  /// The PrevArgs array indicates the previous arguments formatted for this\n  /// diagnostic.  Implementations of this function can use this information to\n  /// avoid redundancy across arguments.\n  ///\n  /// This is a hack to avoid a layering violation between libbasic and libsema.\n  using ArgToStringFnTy = void (*)(\n      ArgumentKind Kind, intptr_t Val,\n      StringRef Modifier, StringRef Argument,\n      ArrayRef<ArgumentValue> PrevArgs,\n      SmallVectorImpl<char> &Output,\n      void *Cookie,\n      ArrayRef<intptr_t> QualTypeVals);\n\n  void *ArgToStringCookie = nullptr;\n  ArgToStringFnTy ArgToStringFn;\n\n  /// ID of the \"delayed\" diagnostic, which is a (typically\n  /// fatal) diagnostic that had to be delayed because it was found\n  /// while emitting another diagnostic.\n  unsigned DelayedDiagID;\n\n  /// First string argument for the delayed diagnostic.\n  std::string DelayedDiagArg1;\n\n  /// Second string argument for the delayed diagnostic.\n  std::string DelayedDiagArg2;\n\n  /// Third string argument for the delayed diagnostic.\n  std::string DelayedDiagArg3;\n\n  /// Optional flag value.\n  ///\n  /// Some flags accept values, for instance: -Wframe-larger-than=<value> and\n  /// -Rpass=<value>. The content of this string is emitted after the flag name\n  /// and '='.\n  std::string FlagValue;\n\npublic:\n  explicit DiagnosticsEngine(IntrusiveRefCntPtr<DiagnosticIDs> Diags,\n                             IntrusiveRefCntPtr<DiagnosticOptions> DiagOpts,\n                             DiagnosticConsumer *client = nullptr,\n                             bool ShouldOwnClient = true);\n  DiagnosticsEngine(const DiagnosticsEngine &) = delete;\n  DiagnosticsEngine &operator=(const DiagnosticsEngine &) = delete;\n  ~DiagnosticsEngine();\n\n  LLVM_DUMP_METHOD void dump() const;\n  LLVM_DUMP_METHOD void dump(StringRef DiagName) const;\n\n  const IntrusiveRefCntPtr<DiagnosticIDs> &getDiagnosticIDs() const {\n    return Diags;\n  }\n\n  /// Retrieve the diagnostic options.\n  DiagnosticOptions &getDiagnosticOptions() const { return *DiagOpts; }\n\n  using diag_mapping_range = llvm::iterator_range<DiagState::const_iterator>;\n\n  /// Get the current set of diagnostic mappings.\n  diag_mapping_range getDiagnosticMappings() const {\n    const DiagState &DS = *GetCurDiagState();\n    return diag_mapping_range(DS.begin(), DS.end());\n  }\n\n  DiagnosticConsumer *getClient() { return Client; }\n  const DiagnosticConsumer *getClient() const { return Client; }\n\n  /// Determine whether this \\c DiagnosticsEngine object own its client.\n  bool ownsClient() const { return Owner != nullptr; }\n\n  /// Return the current diagnostic client along with ownership of that\n  /// client.\n  std::unique_ptr<DiagnosticConsumer> takeClient() { return std::move(Owner); }\n\n  bool hasSourceManager() const { return SourceMgr != nullptr; }\n\n  SourceManager &getSourceManager() const {\n    assert(SourceMgr && \"SourceManager not set!\");\n    return *SourceMgr;\n  }\n\n  void setSourceManager(SourceManager *SrcMgr) {\n    assert(DiagStatesByLoc.empty() &&\n           \"Leftover diag state from a different SourceManager.\");\n    SourceMgr = SrcMgr;\n  }\n\n  //===--------------------------------------------------------------------===//\n  //  DiagnosticsEngine characterization methods, used by a client to customize\n  //  how diagnostics are emitted.\n  //\n\n  /// Copies the current DiagMappings and pushes the new copy\n  /// onto the top of the stack.\n  void pushMappings(SourceLocation Loc);\n\n  /// Pops the current DiagMappings off the top of the stack,\n  /// causing the new top of the stack to be the active mappings.\n  ///\n  /// \\returns \\c true if the pop happens, \\c false if there is only one\n  /// DiagMapping on the stack.\n  bool popMappings(SourceLocation Loc);\n\n  /// Set the diagnostic client associated with this diagnostic object.\n  ///\n  /// \\param ShouldOwnClient true if the diagnostic object should take\n  /// ownership of \\c client.\n  void setClient(DiagnosticConsumer *client, bool ShouldOwnClient = true);\n\n  /// Specify a limit for the number of errors we should\n  /// emit before giving up.\n  ///\n  /// Zero disables the limit.\n  void setErrorLimit(unsigned Limit) { ErrorLimit = Limit; }\n\n  /// Specify the maximum number of template instantiation\n  /// notes to emit along with a given diagnostic.\n  void setTemplateBacktraceLimit(unsigned Limit) {\n    TemplateBacktraceLimit = Limit;\n  }\n\n  /// Retrieve the maximum number of template instantiation\n  /// notes to emit along with a given diagnostic.\n  unsigned getTemplateBacktraceLimit() const {\n    return TemplateBacktraceLimit;\n  }\n\n  /// Specify the maximum number of constexpr evaluation\n  /// notes to emit along with a given diagnostic.\n  void setConstexprBacktraceLimit(unsigned Limit) {\n    ConstexprBacktraceLimit = Limit;\n  }\n\n  /// Retrieve the maximum number of constexpr evaluation\n  /// notes to emit along with a given diagnostic.\n  unsigned getConstexprBacktraceLimit() const {\n    return ConstexprBacktraceLimit;\n  }\n\n  /// When set to true, any unmapped warnings are ignored.\n  ///\n  /// If this and WarningsAsErrors are both set, then this one wins.\n  void setIgnoreAllWarnings(bool Val) {\n    GetCurDiagState()->IgnoreAllWarnings = Val;\n  }\n  bool getIgnoreAllWarnings() const {\n    return GetCurDiagState()->IgnoreAllWarnings;\n  }\n\n  /// When set to true, any unmapped ignored warnings are no longer\n  /// ignored.\n  ///\n  /// If this and IgnoreAllWarnings are both set, then that one wins.\n  void setEnableAllWarnings(bool Val) {\n    GetCurDiagState()->EnableAllWarnings = Val;\n  }\n  bool getEnableAllWarnings() const {\n    return GetCurDiagState()->EnableAllWarnings;\n  }\n\n  /// When set to true, any warnings reported are issued as errors.\n  void setWarningsAsErrors(bool Val) {\n    GetCurDiagState()->WarningsAsErrors = Val;\n  }\n  bool getWarningsAsErrors() const {\n    return GetCurDiagState()->WarningsAsErrors;\n  }\n\n  /// When set to true, any error reported is made a fatal error.\n  void setErrorsAsFatal(bool Val) { GetCurDiagState()->ErrorsAsFatal = Val; }\n  bool getErrorsAsFatal() const { return GetCurDiagState()->ErrorsAsFatal; }\n\n  /// \\brief When set to true, any fatal error reported is made an error.\n  ///\n  /// This setting takes precedence over the setErrorsAsFatal setting above.\n  void setFatalsAsError(bool Val) { FatalsAsError = Val; }\n  bool getFatalsAsError() const { return FatalsAsError; }\n\n  /// When set to true mask warnings that come from system headers.\n  void setSuppressSystemWarnings(bool Val) {\n    GetCurDiagState()->SuppressSystemWarnings = Val;\n  }\n  bool getSuppressSystemWarnings() const {\n    return GetCurDiagState()->SuppressSystemWarnings;\n  }\n\n  /// Suppress all diagnostics, to silence the front end when we\n  /// know that we don't want any more diagnostics to be passed along to the\n  /// client\n  void setSuppressAllDiagnostics(bool Val) { SuppressAllDiagnostics = Val; }\n  bool getSuppressAllDiagnostics() const { return SuppressAllDiagnostics; }\n\n  /// Set type eliding, to skip outputting same types occurring in\n  /// template types.\n  void setElideType(bool Val) { ElideType = Val; }\n  bool getElideType() { return ElideType; }\n\n  /// Set tree printing, to outputting the template difference in a\n  /// tree format.\n  void setPrintTemplateTree(bool Val) { PrintTemplateTree = Val; }\n  bool getPrintTemplateTree() { return PrintTemplateTree; }\n\n  /// Set color printing, so the type diffing will inject color markers\n  /// into the output.\n  void setShowColors(bool Val) { ShowColors = Val; }\n  bool getShowColors() { return ShowColors; }\n\n  /// Specify which overload candidates to show when overload resolution\n  /// fails.\n  ///\n  /// By default, we show all candidates.\n  void setShowOverloads(OverloadsShown Val) {\n    ShowOverloads = Val;\n  }\n  OverloadsShown getShowOverloads() const { return ShowOverloads; }\n\n  /// When a call or operator fails, print out up to this many candidate\n  /// overloads as suggestions.\n  ///\n  /// With Ovl_Best, we set a high limit for the first nontrivial overload set\n  /// we print, and a lower limit for later sets.  This way the user has a\n  /// chance of diagnosing at least one callsite in their program without\n  /// having to recompile with -fshow-overloads=all.\n  unsigned getNumOverloadCandidatesToShow() const {\n    switch (getShowOverloads()) {\n    case Ovl_All:\n      // INT_MAX rather than UINT_MAX so that we don't have to think about the\n      // effect of implicit conversions on this value. In practice we'll never\n      // hit 2^31 candidates anyway.\n      return std::numeric_limits<int>::max();\n    case Ovl_Best:\n      return NumOverloadsToShow;\n    }\n    llvm_unreachable(\"invalid OverloadsShown kind\");\n  }\n\n  /// Call this after showing N overload candidates.  This influences the value\n  /// returned by later calls to getNumOverloadCandidatesToShow().\n  void overloadCandidatesShown(unsigned N) {\n    // Current heuristic: Start out with a large value for NumOverloadsToShow,\n    // and then once we print one nontrivially-large overload set, decrease it\n    // for future calls.\n    if (N > 4) {\n      NumOverloadsToShow = 4;\n    }\n  }\n\n  /// Pretend that the last diagnostic issued was ignored, so any\n  /// subsequent notes will be suppressed, or restore a prior ignoring\n  /// state after ignoring some diagnostics and their notes, possibly in\n  /// the middle of another diagnostic.\n  ///\n  /// This can be used by clients who suppress diagnostics themselves.\n  void setLastDiagnosticIgnored(bool Ignored) {\n    if (LastDiagLevel == DiagnosticIDs::Fatal)\n      FatalErrorOccurred = true;\n    LastDiagLevel = Ignored ? DiagnosticIDs::Ignored : DiagnosticIDs::Warning;\n  }\n\n  /// Determine whether the previous diagnostic was ignored. This can\n  /// be used by clients that want to determine whether notes attached to a\n  /// diagnostic will be suppressed.\n  bool isLastDiagnosticIgnored() const {\n    return LastDiagLevel == DiagnosticIDs::Ignored;\n  }\n\n  /// Controls whether otherwise-unmapped extension diagnostics are\n  /// mapped onto ignore/warning/error.\n  ///\n  /// This corresponds to the GCC -pedantic and -pedantic-errors option.\n  void setExtensionHandlingBehavior(diag::Severity H) {\n    GetCurDiagState()->ExtBehavior = H;\n  }\n  diag::Severity getExtensionHandlingBehavior() const {\n    return GetCurDiagState()->ExtBehavior;\n  }\n\n  /// Counter bumped when an __extension__  block is/ encountered.\n  ///\n  /// When non-zero, all extension diagnostics are entirely silenced, no\n  /// matter how they are mapped.\n  void IncrementAllExtensionsSilenced() { ++AllExtensionsSilenced; }\n  void DecrementAllExtensionsSilenced() { --AllExtensionsSilenced; }\n  bool hasAllExtensionsSilenced() { return AllExtensionsSilenced != 0; }\n\n  /// This allows the client to specify that certain warnings are\n  /// ignored.\n  ///\n  /// Notes can never be mapped, errors can only be mapped to fatal, and\n  /// WARNINGs and EXTENSIONs can be mapped arbitrarily.\n  ///\n  /// \\param Loc The source location that this change of diagnostic state should\n  /// take affect. It can be null if we are setting the latest state.\n  void setSeverity(diag::kind Diag, diag::Severity Map, SourceLocation Loc);\n\n  /// Change an entire diagnostic group (e.g. \"unknown-pragmas\") to\n  /// have the specified mapping.\n  ///\n  /// \\returns true (and ignores the request) if \"Group\" was unknown, false\n  /// otherwise.\n  ///\n  /// \\param Flavor The flavor of group to affect. -Rfoo does not affect the\n  /// state of the -Wfoo group and vice versa.\n  ///\n  /// \\param Loc The source location that this change of diagnostic state should\n  /// take affect. It can be null if we are setting the state from command-line.\n  bool setSeverityForGroup(diag::Flavor Flavor, StringRef Group,\n                           diag::Severity Map,\n                           SourceLocation Loc = SourceLocation());\n\n  /// Set the warning-as-error flag for the given diagnostic group.\n  ///\n  /// This function always only operates on the current diagnostic state.\n  ///\n  /// \\returns True if the given group is unknown, false otherwise.\n  bool setDiagnosticGroupWarningAsError(StringRef Group, bool Enabled);\n\n  /// Set the error-as-fatal flag for the given diagnostic group.\n  ///\n  /// This function always only operates on the current diagnostic state.\n  ///\n  /// \\returns True if the given group is unknown, false otherwise.\n  bool setDiagnosticGroupErrorAsFatal(StringRef Group, bool Enabled);\n\n  /// Add the specified mapping to all diagnostics of the specified\n  /// flavor.\n  ///\n  /// Mainly to be used by -Wno-everything to disable all warnings but allow\n  /// subsequent -W options to enable specific warnings.\n  void setSeverityForAll(diag::Flavor Flavor, diag::Severity Map,\n                         SourceLocation Loc = SourceLocation());\n\n  bool hasErrorOccurred() const { return ErrorOccurred; }\n\n  /// Errors that actually prevent compilation, not those that are\n  /// upgraded from a warning by -Werror.\n  bool hasUncompilableErrorOccurred() const {\n    return UncompilableErrorOccurred;\n  }\n  bool hasFatalErrorOccurred() const { return FatalErrorOccurred; }\n\n  /// Determine whether any kind of unrecoverable error has occurred.\n  bool hasUnrecoverableErrorOccurred() const {\n    return FatalErrorOccurred || UnrecoverableErrorOccurred;\n  }\n\n  unsigned getNumErrors() const { return NumErrors; }\n  unsigned getNumWarnings() const { return NumWarnings; }\n\n  void setNumWarnings(unsigned NumWarnings) {\n    this->NumWarnings = NumWarnings;\n  }\n\n  /// Return an ID for a diagnostic with the specified format string and\n  /// level.\n  ///\n  /// If this is the first request for this diagnostic, it is registered and\n  /// created, otherwise the existing ID is returned.\n  ///\n  /// \\param FormatString A fixed diagnostic format string that will be hashed\n  /// and mapped to a unique DiagID.\n  template <unsigned N>\n  unsigned getCustomDiagID(Level L, const char (&FormatString)[N]) {\n    return Diags->getCustomDiagID((DiagnosticIDs::Level)L,\n                                  StringRef(FormatString, N - 1));\n  }\n\n  /// Converts a diagnostic argument (as an intptr_t) into the string\n  /// that represents it.\n  void ConvertArgToString(ArgumentKind Kind, intptr_t Val,\n                          StringRef Modifier, StringRef Argument,\n                          ArrayRef<ArgumentValue> PrevArgs,\n                          SmallVectorImpl<char> &Output,\n                          ArrayRef<intptr_t> QualTypeVals) const {\n    ArgToStringFn(Kind, Val, Modifier, Argument, PrevArgs, Output,\n                  ArgToStringCookie, QualTypeVals);\n  }\n\n  void SetArgToStringFn(ArgToStringFnTy Fn, void *Cookie) {\n    ArgToStringFn = Fn;\n    ArgToStringCookie = Cookie;\n  }\n\n  /// Note that the prior diagnostic was emitted by some other\n  /// \\c DiagnosticsEngine, and we may be attaching a note to that diagnostic.\n  void notePriorDiagnosticFrom(const DiagnosticsEngine &Other) {\n    LastDiagLevel = Other.LastDiagLevel;\n  }\n\n  /// Reset the state of the diagnostic object to its initial\n  /// configuration.\n  void Reset();\n\n  //===--------------------------------------------------------------------===//\n  // DiagnosticsEngine classification and reporting interfaces.\n  //\n\n  /// Determine whether the diagnostic is known to be ignored.\n  ///\n  /// This can be used to opportunistically avoid expensive checks when it's\n  /// known for certain that the diagnostic has been suppressed at the\n  /// specified location \\p Loc.\n  ///\n  /// \\param Loc The source location we are interested in finding out the\n  /// diagnostic state. Can be null in order to query the latest state.\n  bool isIgnored(unsigned DiagID, SourceLocation Loc) const {\n    return Diags->getDiagnosticSeverity(DiagID, Loc, *this) ==\n           diag::Severity::Ignored;\n  }\n\n  /// Based on the way the client configured the DiagnosticsEngine\n  /// object, classify the specified diagnostic ID into a Level, consumable by\n  /// the DiagnosticConsumer.\n  ///\n  /// To preserve invariant assumptions, this function should not be used to\n  /// influence parse or semantic analysis actions. Instead consider using\n  /// \\c isIgnored().\n  ///\n  /// \\param Loc The source location we are interested in finding out the\n  /// diagnostic state. Can be null in order to query the latest state.\n  Level getDiagnosticLevel(unsigned DiagID, SourceLocation Loc) const {\n    return (Level)Diags->getDiagnosticLevel(DiagID, Loc, *this);\n  }\n\n  /// Issue the message to the client.\n  ///\n  /// This actually returns an instance of DiagnosticBuilder which emits the\n  /// diagnostics (through @c ProcessDiag) when it is destroyed.\n  ///\n  /// \\param DiagID A member of the @c diag::kind enum.\n  /// \\param Loc Represents the source location associated with the diagnostic,\n  /// which can be an invalid location if no position information is available.\n  inline DiagnosticBuilder Report(SourceLocation Loc, unsigned DiagID);\n  inline DiagnosticBuilder Report(unsigned DiagID);\n\n  void Report(const StoredDiagnostic &storedDiag);\n\n  /// Determine whethere there is already a diagnostic in flight.\n  bool isDiagnosticInFlight() const {\n    return CurDiagID != std::numeric_limits<unsigned>::max();\n  }\n\n  /// Set the \"delayed\" diagnostic that will be emitted once\n  /// the current diagnostic completes.\n  ///\n  ///  If a diagnostic is already in-flight but the front end must\n  ///  report a problem (e.g., with an inconsistent file system\n  ///  state), this routine sets a \"delayed\" diagnostic that will be\n  ///  emitted after the current diagnostic completes. This should\n  ///  only be used for fatal errors detected at inconvenient\n  ///  times. If emitting a delayed diagnostic causes a second delayed\n  ///  diagnostic to be introduced, that second delayed diagnostic\n  ///  will be ignored.\n  ///\n  /// \\param DiagID The ID of the diagnostic being delayed.\n  ///\n  /// \\param Arg1 A string argument that will be provided to the\n  /// diagnostic. A copy of this string will be stored in the\n  /// DiagnosticsEngine object itself.\n  ///\n  /// \\param Arg2 A string argument that will be provided to the\n  /// diagnostic. A copy of this string will be stored in the\n  /// DiagnosticsEngine object itself.\n  ///\n  /// \\param Arg3 A string argument that will be provided to the\n  /// diagnostic. A copy of this string will be stored in the\n  /// DiagnosticsEngine object itself.\n  void SetDelayedDiagnostic(unsigned DiagID, StringRef Arg1 = \"\",\n                            StringRef Arg2 = \"\", StringRef Arg3 = \"\");\n\n  /// Clear out the current diagnostic.\n  void Clear() { CurDiagID = std::numeric_limits<unsigned>::max(); }\n\n  /// Return the value associated with this diagnostic flag.\n  StringRef getFlagValue() const { return FlagValue; }\n\nprivate:\n  // This is private state used by DiagnosticBuilder.  We put it here instead of\n  // in DiagnosticBuilder in order to keep DiagnosticBuilder a small lightweight\n  // object.  This implementation choice means that we can only have one\n  // diagnostic \"in flight\" at a time, but this seems to be a reasonable\n  // tradeoff to keep these objects small.  Assertions verify that only one\n  // diagnostic is in flight at a time.\n  friend class Diagnostic;\n  friend class DiagnosticBuilder;\n  friend class DiagnosticErrorTrap;\n  friend class DiagnosticIDs;\n  friend class PartialDiagnostic;\n\n  /// Report the delayed diagnostic.\n  void ReportDelayed();\n\n  /// The location of the current diagnostic that is in flight.\n  SourceLocation CurDiagLoc;\n\n  /// The ID of the current diagnostic that is in flight.\n  ///\n  /// This is set to std::numeric_limits<unsigned>::max() when there is no\n  /// diagnostic in flight.\n  unsigned CurDiagID;\n\n  enum {\n    /// The maximum number of arguments we can hold.\n    ///\n    /// We currently only support up to 10 arguments (%0-%9).  A single\n    /// diagnostic with more than that almost certainly has to be simplified\n    /// anyway.\n    MaxArguments = DiagnosticStorage::MaxArguments,\n  };\n\n  DiagnosticStorage DiagStorage;\n\n  DiagnosticMapping makeUserMapping(diag::Severity Map, SourceLocation L) {\n    bool isPragma = L.isValid();\n    DiagnosticMapping Mapping =\n        DiagnosticMapping::Make(Map, /*IsUser=*/true, isPragma);\n\n    // If this is a pragma mapping, then set the diagnostic mapping flags so\n    // that we override command line options.\n    if (isPragma) {\n      Mapping.setNoWarningAsError(true);\n      Mapping.setNoErrorAsFatal(true);\n    }\n\n    return Mapping;\n  }\n\n  /// Used to report a diagnostic that is finally fully formed.\n  ///\n  /// \\returns true if the diagnostic was emitted, false if it was suppressed.\n  bool ProcessDiag() {\n    return Diags->ProcessDiag(*this);\n  }\n\n  /// @name Diagnostic Emission\n  /// @{\nprotected:\n  friend class ASTReader;\n  friend class ASTWriter;\n\n  // Sema requires access to the following functions because the current design\n  // of SFINAE requires it to use its own SemaDiagnosticBuilder, which needs to\n  // access us directly to ensure we minimize the emitted code for the common\n  // Sema::Diag() patterns.\n  friend class Sema;\n\n  /// Emit the current diagnostic and clear the diagnostic state.\n  ///\n  /// \\param Force Emit the diagnostic regardless of suppression settings.\n  bool EmitCurrentDiagnostic(bool Force = false);\n\n  unsigned getCurrentDiagID() const { return CurDiagID; }\n\n  SourceLocation getCurrentDiagLoc() const { return CurDiagLoc; }\n\n  /// @}\n};\n\n/// RAII class that determines when any errors have occurred\n/// between the time the instance was created and the time it was\n/// queried.\n///\n/// Note that you almost certainly do not want to use this. It's usually\n/// meaningless to ask whether a particular scope triggered an error message,\n/// because error messages outside that scope can mark things invalid (or cause\n/// us to reach an error limit), which can suppress errors within that scope.\nclass DiagnosticErrorTrap {\n  DiagnosticsEngine &Diag;\n  unsigned NumErrors;\n  unsigned NumUnrecoverableErrors;\n\npublic:\n  explicit DiagnosticErrorTrap(DiagnosticsEngine &Diag)\n      : Diag(Diag) { reset(); }\n\n  /// Determine whether any errors have occurred since this\n  /// object instance was created.\n  bool hasErrorOccurred() const {\n    return Diag.TrapNumErrorsOccurred > NumErrors;\n  }\n\n  /// Determine whether any unrecoverable errors have occurred since this\n  /// object instance was created.\n  bool hasUnrecoverableErrorOccurred() const {\n    return Diag.TrapNumUnrecoverableErrorsOccurred > NumUnrecoverableErrors;\n  }\n\n  /// Set to initial state of \"no errors occurred\".\n  void reset() {\n    NumErrors = Diag.TrapNumErrorsOccurred;\n    NumUnrecoverableErrors = Diag.TrapNumUnrecoverableErrorsOccurred;\n  }\n};\n\n/// The streaming interface shared between DiagnosticBuilder and\n/// PartialDiagnostic. This class is not intended to be constructed directly\n/// but only as base class of DiagnosticBuilder and PartialDiagnostic builder.\n///\n/// Any new type of argument accepted by DiagnosticBuilder and PartialDiagnostic\n/// should be implemented as a '<<' operator of StreamingDiagnostic, e.g.\n///\n/// const StreamingDiagnostic&\n/// operator<<(const StreamingDiagnostic&, NewArgType);\n///\nclass StreamingDiagnostic {\npublic:\n  /// An allocator for DiagnosticStorage objects, which uses a small cache to\n  /// objects, used to reduce malloc()/free() traffic for partial diagnostics.\n  class DiagStorageAllocator {\n    static const unsigned NumCached = 16;\n    DiagnosticStorage Cached[NumCached];\n    DiagnosticStorage *FreeList[NumCached];\n    unsigned NumFreeListEntries;\n\n  public:\n    DiagStorageAllocator();\n    ~DiagStorageAllocator();\n\n    /// Allocate new storage.\n    DiagnosticStorage *Allocate() {\n      if (NumFreeListEntries == 0)\n        return new DiagnosticStorage;\n\n      DiagnosticStorage *Result = FreeList[--NumFreeListEntries];\n      Result->NumDiagArgs = 0;\n      Result->DiagRanges.clear();\n      Result->FixItHints.clear();\n      return Result;\n    }\n\n    /// Free the given storage object.\n    void Deallocate(DiagnosticStorage *S) {\n      if (S >= Cached && S <= Cached + NumCached) {\n        FreeList[NumFreeListEntries++] = S;\n        return;\n      }\n\n      delete S;\n    }\n  };\n\nprotected:\n  mutable DiagnosticStorage *DiagStorage = nullptr;\n\n  /// Allocator used to allocate storage for this diagnostic.\n  DiagStorageAllocator *Allocator = nullptr;\n\npublic:\n  /// Retrieve storage for this particular diagnostic.\n  DiagnosticStorage *getStorage() const {\n    if (DiagStorage)\n      return DiagStorage;\n\n    assert(Allocator);\n    DiagStorage = Allocator->Allocate();\n    return DiagStorage;\n  }\n\n  void freeStorage() {\n    if (!DiagStorage)\n      return;\n\n    // The hot path for PartialDiagnostic is when we just used it to wrap an ID\n    // (typically so we have the flexibility of passing a more complex\n    // diagnostic into the callee, but that does not commonly occur).\n    //\n    // Split this out into a slow function for silly compilers (*cough*) which\n    // can't do decent partial inlining.\n    freeStorageSlow();\n  }\n\n  void freeStorageSlow() {\n    if (!Allocator)\n      return;\n    Allocator->Deallocate(DiagStorage);\n    DiagStorage = nullptr;\n  }\n\n  void AddTaggedVal(intptr_t V, DiagnosticsEngine::ArgumentKind Kind) const {\n    if (!DiagStorage)\n      DiagStorage = getStorage();\n\n    assert(DiagStorage->NumDiagArgs < DiagnosticStorage::MaxArguments &&\n           \"Too many arguments to diagnostic!\");\n    DiagStorage->DiagArgumentsKind[DiagStorage->NumDiagArgs] = Kind;\n    DiagStorage->DiagArgumentsVal[DiagStorage->NumDiagArgs++] = V;\n  }\n\n  void AddString(StringRef V) const {\n    if (!DiagStorage)\n      DiagStorage = getStorage();\n\n    assert(DiagStorage->NumDiagArgs < DiagnosticStorage::MaxArguments &&\n           \"Too many arguments to diagnostic!\");\n    DiagStorage->DiagArgumentsKind[DiagStorage->NumDiagArgs] =\n        DiagnosticsEngine::ak_std_string;\n    DiagStorage->DiagArgumentsStr[DiagStorage->NumDiagArgs++] = std::string(V);\n  }\n\n  void AddSourceRange(const CharSourceRange &R) const {\n    if (!DiagStorage)\n      DiagStorage = getStorage();\n\n    DiagStorage->DiagRanges.push_back(R);\n  }\n\n  void AddFixItHint(const FixItHint &Hint) const {\n    if (Hint.isNull())\n      return;\n\n    if (!DiagStorage)\n      DiagStorage = getStorage();\n\n    DiagStorage->FixItHints.push_back(Hint);\n  }\n\n  /// Conversion of StreamingDiagnostic to bool always returns \\c true.\n  ///\n  /// This allows is to be used in boolean error contexts (where \\c true is\n  /// used to indicate that an error has occurred), like:\n  /// \\code\n  /// return Diag(...);\n  /// \\endcode\n  operator bool() const { return true; }\n\nprotected:\n  StreamingDiagnostic() = default;\n\n  /// Construct with an external storage not owned by itself. The allocator\n  /// is a null pointer in this case.\n  explicit StreamingDiagnostic(DiagnosticStorage *Storage)\n      : DiagStorage(Storage) {}\n\n  /// Construct with a storage allocator which will manage the storage. The\n  /// allocator is not a null pointer in this case.\n  explicit StreamingDiagnostic(DiagStorageAllocator &Alloc)\n      : Allocator(&Alloc) {}\n\n  StreamingDiagnostic(const StreamingDiagnostic &Diag) = default;\n  StreamingDiagnostic(StreamingDiagnostic &&Diag) = default;\n\n  ~StreamingDiagnostic() { freeStorage(); }\n};\n\n//===----------------------------------------------------------------------===//\n// DiagnosticBuilder\n//===----------------------------------------------------------------------===//\n\n/// A little helper class used to produce diagnostics.\n///\n/// This is constructed by the DiagnosticsEngine::Report method, and\n/// allows insertion of extra information (arguments and source ranges) into\n/// the currently \"in flight\" diagnostic.  When the temporary for the builder\n/// is destroyed, the diagnostic is issued.\n///\n/// Note that many of these will be created as temporary objects (many call\n/// sites), so we want them to be small and we never want their address taken.\n/// This ensures that compilers with somewhat reasonable optimizers will promote\n/// the common fields to registers, eliminating increments of the NumArgs field,\n/// for example.\nclass DiagnosticBuilder : public StreamingDiagnostic {\n  friend class DiagnosticsEngine;\n  friend class PartialDiagnostic;\n\n  mutable DiagnosticsEngine *DiagObj = nullptr;\n\n  /// Status variable indicating if this diagnostic is still active.\n  ///\n  // NOTE: This field is redundant with DiagObj (IsActive iff (DiagObj == 0)),\n  // but LLVM is not currently smart enough to eliminate the null check that\n  // Emit() would end up with if we used that as our status variable.\n  mutable bool IsActive = false;\n\n  /// Flag indicating that this diagnostic is being emitted via a\n  /// call to ForceEmit.\n  mutable bool IsForceEmit = false;\n\n  DiagnosticBuilder() = default;\n\n  explicit DiagnosticBuilder(DiagnosticsEngine *diagObj)\n      : StreamingDiagnostic(&diagObj->DiagStorage), DiagObj(diagObj),\n        IsActive(true) {\n    assert(diagObj && \"DiagnosticBuilder requires a valid DiagnosticsEngine!\");\n    assert(DiagStorage &&\n           \"DiagnosticBuilder requires a valid DiagnosticStorage!\");\n    DiagStorage->NumDiagArgs = 0;\n    DiagStorage->DiagRanges.clear();\n    DiagStorage->FixItHints.clear();\n  }\n\nprotected:\n  /// Clear out the current diagnostic.\n  void Clear() const {\n    DiagObj = nullptr;\n    IsActive = false;\n    IsForceEmit = false;\n  }\n\n  /// Determine whether this diagnostic is still active.\n  bool isActive() const { return IsActive; }\n\n  /// Force the diagnostic builder to emit the diagnostic now.\n  ///\n  /// Once this function has been called, the DiagnosticBuilder object\n  /// should not be used again before it is destroyed.\n  ///\n  /// \\returns true if a diagnostic was emitted, false if the\n  /// diagnostic was suppressed.\n  bool Emit() {\n    // If this diagnostic is inactive, then its soul was stolen by the copy ctor\n    // (or by a subclass, as in SemaDiagnosticBuilder).\n    if (!isActive()) return false;\n\n    // Process the diagnostic.\n    bool Result = DiagObj->EmitCurrentDiagnostic(IsForceEmit);\n\n    // This diagnostic is dead.\n    Clear();\n\n    return Result;\n  }\n\npublic:\n  /// Copy constructor.  When copied, this \"takes\" the diagnostic info from the\n  /// input and neuters it.\n  DiagnosticBuilder(const DiagnosticBuilder &D) : StreamingDiagnostic() {\n    DiagObj = D.DiagObj;\n    DiagStorage = D.DiagStorage;\n    IsActive = D.IsActive;\n    IsForceEmit = D.IsForceEmit;\n    D.Clear();\n  }\n\n  template <typename T> const DiagnosticBuilder &operator<<(const T &V) const {\n    assert(isActive() && \"Clients must not add to cleared diagnostic!\");\n    const StreamingDiagnostic &DB = *this;\n    DB << V;\n    return *this;\n  }\n\n  // It is necessary to limit this to rvalue reference to avoid calling this\n  // function with a bitfield lvalue argument since non-const reference to\n  // bitfield is not allowed.\n  template <typename T, typename = typename std::enable_if<\n                            !std::is_lvalue_reference<T>::value>::type>\n  const DiagnosticBuilder &operator<<(T &&V) const {\n    assert(isActive() && \"Clients must not add to cleared diagnostic!\");\n    const StreamingDiagnostic &DB = *this;\n    DB << std::move(V);\n    return *this;\n  }\n\n  DiagnosticBuilder &operator=(const DiagnosticBuilder &) = delete;\n\n  /// Emits the diagnostic.\n  ~DiagnosticBuilder() { Emit(); }\n\n  /// Forces the diagnostic to be emitted.\n  const DiagnosticBuilder &setForceEmit() const {\n    IsForceEmit = true;\n    return *this;\n  }\n\n  void addFlagValue(StringRef V) const { DiagObj->FlagValue = std::string(V); }\n};\n\nstruct AddFlagValue {\n  StringRef Val;\n\n  explicit AddFlagValue(StringRef V) : Val(V) {}\n};\n\n/// Register a value for the flag in the current diagnostic. This\n/// value will be shown as the suffix \"=value\" after the flag name. It is\n/// useful in cases where the diagnostic flag accepts values (e.g.,\n/// -Rpass or -Wframe-larger-than).\ninline const DiagnosticBuilder &operator<<(const DiagnosticBuilder &DB,\n                                           const AddFlagValue V) {\n  DB.addFlagValue(V.Val);\n  return DB;\n}\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             StringRef S) {\n  DB.AddString(S);\n  return DB;\n}\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             const char *Str) {\n  DB.AddTaggedVal(reinterpret_cast<intptr_t>(Str),\n                  DiagnosticsEngine::ak_c_string);\n  return DB;\n}\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             int I) {\n  DB.AddTaggedVal(I, DiagnosticsEngine::ak_sint);\n  return DB;\n}\n\n// We use enable_if here to prevent that this overload is selected for\n// pointers or other arguments that are implicitly convertible to bool.\ntemplate <typename T>\ninline std::enable_if_t<std::is_same<T, bool>::value,\n                        const StreamingDiagnostic &>\noperator<<(const StreamingDiagnostic &DB, T I) {\n  DB.AddTaggedVal(I, DiagnosticsEngine::ak_sint);\n  return DB;\n}\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             unsigned I) {\n  DB.AddTaggedVal(I, DiagnosticsEngine::ak_uint);\n  return DB;\n}\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             tok::TokenKind I) {\n  DB.AddTaggedVal(static_cast<unsigned>(I), DiagnosticsEngine::ak_tokenkind);\n  return DB;\n}\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             const IdentifierInfo *II) {\n  DB.AddTaggedVal(reinterpret_cast<intptr_t>(II),\n                  DiagnosticsEngine::ak_identifierinfo);\n  return DB;\n}\n\n// Adds a DeclContext to the diagnostic. The enable_if template magic is here\n// so that we only match those arguments that are (statically) DeclContexts;\n// other arguments that derive from DeclContext (e.g., RecordDecls) will not\n// match.\ntemplate <typename T>\ninline std::enable_if_t<\n    std::is_same<std::remove_const_t<T>, DeclContext>::value,\n    const StreamingDiagnostic &>\noperator<<(const StreamingDiagnostic &DB, T *DC) {\n  DB.AddTaggedVal(reinterpret_cast<intptr_t>(DC),\n                  DiagnosticsEngine::ak_declcontext);\n  return DB;\n}\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             SourceRange R) {\n  DB.AddSourceRange(CharSourceRange::getTokenRange(R));\n  return DB;\n}\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             ArrayRef<SourceRange> Ranges) {\n  for (SourceRange R : Ranges)\n    DB.AddSourceRange(CharSourceRange::getTokenRange(R));\n  return DB;\n}\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             const CharSourceRange &R) {\n  DB.AddSourceRange(R);\n  return DB;\n}\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             const FixItHint &Hint) {\n  DB.AddFixItHint(Hint);\n  return DB;\n}\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             ArrayRef<FixItHint> Hints) {\n  for (const FixItHint &Hint : Hints)\n    DB.AddFixItHint(Hint);\n  return DB;\n}\n\ninline const StreamingDiagnostic &\noperator<<(const StreamingDiagnostic &DB,\n           const llvm::Optional<SourceRange> &Opt) {\n  if (Opt)\n    DB << *Opt;\n  return DB;\n}\n\ninline const StreamingDiagnostic &\noperator<<(const StreamingDiagnostic &DB,\n           const llvm::Optional<CharSourceRange> &Opt) {\n  if (Opt)\n    DB << *Opt;\n  return DB;\n}\n\ninline const StreamingDiagnostic &\noperator<<(const StreamingDiagnostic &DB,\n           const llvm::Optional<FixItHint> &Opt) {\n  if (Opt)\n    DB << *Opt;\n  return DB;\n}\n\n/// A nullability kind paired with a bit indicating whether it used a\n/// context-sensitive keyword.\nusing DiagNullabilityKind = std::pair<NullabilityKind, bool>;\n\nconst StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                      DiagNullabilityKind nullability);\n\ninline DiagnosticBuilder DiagnosticsEngine::Report(SourceLocation Loc,\n                                                   unsigned DiagID) {\n  assert(CurDiagID == std::numeric_limits<unsigned>::max() &&\n         \"Multiple diagnostics in flight at once!\");\n  CurDiagLoc = Loc;\n  CurDiagID = DiagID;\n  FlagValue.clear();\n  return DiagnosticBuilder(this);\n}\n\nconst StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                      llvm::Error &&E);\n\ninline DiagnosticBuilder DiagnosticsEngine::Report(unsigned DiagID) {\n  return Report(SourceLocation(), DiagID);\n}\n\n//===----------------------------------------------------------------------===//\n// Diagnostic\n//===----------------------------------------------------------------------===//\n\n/// A little helper class (which is basically a smart pointer that forwards\n/// info from DiagnosticsEngine) that allows clients to enquire about the\n/// currently in-flight diagnostic.\nclass Diagnostic {\n  const DiagnosticsEngine *DiagObj;\n  StringRef StoredDiagMessage;\n\npublic:\n  explicit Diagnostic(const DiagnosticsEngine *DO) : DiagObj(DO) {}\n  Diagnostic(const DiagnosticsEngine *DO, StringRef storedDiagMessage)\n      : DiagObj(DO), StoredDiagMessage(storedDiagMessage) {}\n\n  const DiagnosticsEngine *getDiags() const { return DiagObj; }\n  unsigned getID() const { return DiagObj->CurDiagID; }\n  const SourceLocation &getLocation() const { return DiagObj->CurDiagLoc; }\n  bool hasSourceManager() const { return DiagObj->hasSourceManager(); }\n  SourceManager &getSourceManager() const { return DiagObj->getSourceManager();}\n\n  unsigned getNumArgs() const { return DiagObj->DiagStorage.NumDiagArgs; }\n\n  /// Return the kind of the specified index.\n  ///\n  /// Based on the kind of argument, the accessors below can be used to get\n  /// the value.\n  ///\n  /// \\pre Idx < getNumArgs()\n  DiagnosticsEngine::ArgumentKind getArgKind(unsigned Idx) const {\n    assert(Idx < getNumArgs() && \"Argument index out of range!\");\n    return (DiagnosticsEngine::ArgumentKind)\n        DiagObj->DiagStorage.DiagArgumentsKind[Idx];\n  }\n\n  /// Return the provided argument string specified by \\p Idx.\n  /// \\pre getArgKind(Idx) == DiagnosticsEngine::ak_std_string\n  const std::string &getArgStdStr(unsigned Idx) const {\n    assert(getArgKind(Idx) == DiagnosticsEngine::ak_std_string &&\n           \"invalid argument accessor!\");\n    return DiagObj->DiagStorage.DiagArgumentsStr[Idx];\n  }\n\n  /// Return the specified C string argument.\n  /// \\pre getArgKind(Idx) == DiagnosticsEngine::ak_c_string\n  const char *getArgCStr(unsigned Idx) const {\n    assert(getArgKind(Idx) == DiagnosticsEngine::ak_c_string &&\n           \"invalid argument accessor!\");\n    return reinterpret_cast<const char *>(\n        DiagObj->DiagStorage.DiagArgumentsVal[Idx]);\n  }\n\n  /// Return the specified signed integer argument.\n  /// \\pre getArgKind(Idx) == DiagnosticsEngine::ak_sint\n  int getArgSInt(unsigned Idx) const {\n    assert(getArgKind(Idx) == DiagnosticsEngine::ak_sint &&\n           \"invalid argument accessor!\");\n    return (int)DiagObj->DiagStorage.DiagArgumentsVal[Idx];\n  }\n\n  /// Return the specified unsigned integer argument.\n  /// \\pre getArgKind(Idx) == DiagnosticsEngine::ak_uint\n  unsigned getArgUInt(unsigned Idx) const {\n    assert(getArgKind(Idx) == DiagnosticsEngine::ak_uint &&\n           \"invalid argument accessor!\");\n    return (unsigned)DiagObj->DiagStorage.DiagArgumentsVal[Idx];\n  }\n\n  /// Return the specified IdentifierInfo argument.\n  /// \\pre getArgKind(Idx) == DiagnosticsEngine::ak_identifierinfo\n  const IdentifierInfo *getArgIdentifier(unsigned Idx) const {\n    assert(getArgKind(Idx) == DiagnosticsEngine::ak_identifierinfo &&\n           \"invalid argument accessor!\");\n    return reinterpret_cast<IdentifierInfo *>(\n        DiagObj->DiagStorage.DiagArgumentsVal[Idx]);\n  }\n\n  /// Return the specified non-string argument in an opaque form.\n  /// \\pre getArgKind(Idx) != DiagnosticsEngine::ak_std_string\n  intptr_t getRawArg(unsigned Idx) const {\n    assert(getArgKind(Idx) != DiagnosticsEngine::ak_std_string &&\n           \"invalid argument accessor!\");\n    return DiagObj->DiagStorage.DiagArgumentsVal[Idx];\n  }\n\n  /// Return the number of source ranges associated with this diagnostic.\n  unsigned getNumRanges() const {\n    return DiagObj->DiagStorage.DiagRanges.size();\n  }\n\n  /// \\pre Idx < getNumRanges()\n  const CharSourceRange &getRange(unsigned Idx) const {\n    assert(Idx < getNumRanges() && \"Invalid diagnostic range index!\");\n    return DiagObj->DiagStorage.DiagRanges[Idx];\n  }\n\n  /// Return an array reference for this diagnostic's ranges.\n  ArrayRef<CharSourceRange> getRanges() const {\n    return DiagObj->DiagStorage.DiagRanges;\n  }\n\n  unsigned getNumFixItHints() const {\n    return DiagObj->DiagStorage.FixItHints.size();\n  }\n\n  const FixItHint &getFixItHint(unsigned Idx) const {\n    assert(Idx < getNumFixItHints() && \"Invalid index!\");\n    return DiagObj->DiagStorage.FixItHints[Idx];\n  }\n\n  ArrayRef<FixItHint> getFixItHints() const {\n    return DiagObj->DiagStorage.FixItHints;\n  }\n\n  /// Format this diagnostic into a string, substituting the\n  /// formal arguments into the %0 slots.\n  ///\n  /// The result is appended onto the \\p OutStr array.\n  void FormatDiagnostic(SmallVectorImpl<char> &OutStr) const;\n\n  /// Format the given format-string into the output buffer using the\n  /// arguments stored in this diagnostic.\n  void FormatDiagnostic(const char *DiagStr, const char *DiagEnd,\n                        SmallVectorImpl<char> &OutStr) const;\n};\n\n/**\n * Represents a diagnostic in a form that can be retained until its\n * corresponding source manager is destroyed.\n */\nclass StoredDiagnostic {\n  unsigned ID;\n  DiagnosticsEngine::Level Level;\n  FullSourceLoc Loc;\n  std::string Message;\n  std::vector<CharSourceRange> Ranges;\n  std::vector<FixItHint> FixIts;\n\npublic:\n  StoredDiagnostic() = default;\n  StoredDiagnostic(DiagnosticsEngine::Level Level, const Diagnostic &Info);\n  StoredDiagnostic(DiagnosticsEngine::Level Level, unsigned ID,\n                   StringRef Message);\n  StoredDiagnostic(DiagnosticsEngine::Level Level, unsigned ID,\n                   StringRef Message, FullSourceLoc Loc,\n                   ArrayRef<CharSourceRange> Ranges,\n                   ArrayRef<FixItHint> Fixits);\n\n  /// Evaluates true when this object stores a diagnostic.\n  explicit operator bool() const { return !Message.empty(); }\n\n  unsigned getID() const { return ID; }\n  DiagnosticsEngine::Level getLevel() const { return Level; }\n  const FullSourceLoc &getLocation() const { return Loc; }\n  StringRef getMessage() const { return Message; }\n\n  void setLocation(FullSourceLoc Loc) { this->Loc = Loc; }\n\n  using range_iterator = std::vector<CharSourceRange>::const_iterator;\n\n  range_iterator range_begin() const { return Ranges.begin(); }\n  range_iterator range_end() const { return Ranges.end(); }\n  unsigned range_size() const { return Ranges.size(); }\n\n  ArrayRef<CharSourceRange> getRanges() const {\n    return llvm::makeArrayRef(Ranges);\n  }\n\n  using fixit_iterator = std::vector<FixItHint>::const_iterator;\n\n  fixit_iterator fixit_begin() const { return FixIts.begin(); }\n  fixit_iterator fixit_end() const { return FixIts.end(); }\n  unsigned fixit_size() const { return FixIts.size(); }\n\n  ArrayRef<FixItHint> getFixIts() const {\n    return llvm::makeArrayRef(FixIts);\n  }\n};\n\n/// Abstract interface, implemented by clients of the front-end, which\n/// formats and prints fully processed diagnostics.\nclass DiagnosticConsumer {\nprotected:\n  unsigned NumWarnings = 0;       ///< Number of warnings reported\n  unsigned NumErrors = 0;         ///< Number of errors reported\n\npublic:\n  DiagnosticConsumer() = default;\n  virtual ~DiagnosticConsumer();\n\n  unsigned getNumErrors() const { return NumErrors; }\n  unsigned getNumWarnings() const { return NumWarnings; }\n  virtual void clear() { NumWarnings = NumErrors = 0; }\n\n  /// Callback to inform the diagnostic client that processing\n  /// of a source file is beginning.\n  ///\n  /// Note that diagnostics may be emitted outside the processing of a source\n  /// file, for example during the parsing of command line options. However,\n  /// diagnostics with source range information are required to only be emitted\n  /// in between BeginSourceFile() and EndSourceFile().\n  ///\n  /// \\param LangOpts The language options for the source file being processed.\n  /// \\param PP The preprocessor object being used for the source; this is\n  /// optional, e.g., it may not be present when processing AST source files.\n  virtual void BeginSourceFile(const LangOptions &LangOpts,\n                               const Preprocessor *PP = nullptr) {}\n\n  /// Callback to inform the diagnostic client that processing\n  /// of a source file has ended.\n  ///\n  /// The diagnostic client should assume that any objects made available via\n  /// BeginSourceFile() are inaccessible.\n  virtual void EndSourceFile() {}\n\n  /// Callback to inform the diagnostic client that processing of all\n  /// source files has ended.\n  virtual void finish() {}\n\n  /// Indicates whether the diagnostics handled by this\n  /// DiagnosticConsumer should be included in the number of diagnostics\n  /// reported by DiagnosticsEngine.\n  ///\n  /// The default implementation returns true.\n  virtual bool IncludeInDiagnosticCounts() const;\n\n  /// Handle this diagnostic, reporting it to the user or\n  /// capturing it to a log as needed.\n  ///\n  /// The default implementation just keeps track of the total number of\n  /// warnings and errors.\n  virtual void HandleDiagnostic(DiagnosticsEngine::Level DiagLevel,\n                                const Diagnostic &Info);\n};\n\n/// A diagnostic client that ignores all diagnostics.\nclass IgnoringDiagConsumer : public DiagnosticConsumer {\n  virtual void anchor();\n\n  void HandleDiagnostic(DiagnosticsEngine::Level DiagLevel,\n                        const Diagnostic &Info) override {\n    // Just ignore it.\n  }\n};\n\n/// Diagnostic consumer that forwards diagnostics along to an\n/// existing, already-initialized diagnostic consumer.\n///\nclass ForwardingDiagnosticConsumer : public DiagnosticConsumer {\n  DiagnosticConsumer &Target;\n\npublic:\n  ForwardingDiagnosticConsumer(DiagnosticConsumer &Target) : Target(Target) {}\n  ~ForwardingDiagnosticConsumer() override;\n\n  void HandleDiagnostic(DiagnosticsEngine::Level DiagLevel,\n                        const Diagnostic &Info) override;\n  void clear() override;\n\n  bool IncludeInDiagnosticCounts() const override;\n};\n\n// Struct used for sending info about how a type should be printed.\nstruct TemplateDiffTypes {\n  intptr_t FromType;\n  intptr_t ToType;\n  unsigned PrintTree : 1;\n  unsigned PrintFromType : 1;\n  unsigned ElideType : 1;\n  unsigned ShowColors : 1;\n\n  // The printer sets this variable to true if the template diff was used.\n  unsigned TemplateDiffUsed : 1;\n};\n\n/// Special character that the diagnostic printer will use to toggle the bold\n/// attribute.  The character itself will be not be printed.\nconst char ToggleHighlight = 127;\n\n/// ProcessWarningOptions - Initialize the diagnostic client and process the\n/// warning options specified on the command line.\nvoid ProcessWarningOptions(DiagnosticsEngine &Diags,\n                           const DiagnosticOptions &Opts,\n                           bool ReportDiags = true);\n\n} // namespace clang\n\n#endif // LLVM_CLANG_BASIC_DIAGNOSTIC_H\n"}, "26": {"id": 26, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h", "content": "//===--- DiagnosticIDs.h - Diagnostic IDs Handling --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Defines the Diagnostic IDs-related interfaces.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_DIAGNOSTICIDS_H\n#define LLVM_CLANG_BASIC_DIAGNOSTICIDS_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <vector>\n\nnamespace clang {\n  class DiagnosticsEngine;\n  class SourceLocation;\n\n  // Import the diagnostic enums themselves.\n  namespace diag {\n    // Size of each of the diagnostic categories.\n    enum {\n      DIAG_SIZE_COMMON        =  300,\n      DIAG_SIZE_DRIVER        =  250,\n      DIAG_SIZE_FRONTEND      =  150,\n      DIAG_SIZE_SERIALIZATION =  120,\n      DIAG_SIZE_LEX           =  400,\n      DIAG_SIZE_PARSE         =  600,\n      DIAG_SIZE_AST           =  250,\n      DIAG_SIZE_COMMENT       =  100,\n      DIAG_SIZE_CROSSTU       =  100,\n      DIAG_SIZE_SEMA          = 4500,\n      DIAG_SIZE_ANALYSIS      =  100,\n      DIAG_SIZE_REFACTORING   = 1000,\n    };\n    // Start position for diagnostics.\n    enum {\n      DIAG_START_COMMON        =                          0,\n      DIAG_START_DRIVER        = DIAG_START_COMMON        + DIAG_SIZE_COMMON,\n      DIAG_START_FRONTEND      = DIAG_START_DRIVER        + DIAG_SIZE_DRIVER,\n      DIAG_START_SERIALIZATION = DIAG_START_FRONTEND      + DIAG_SIZE_FRONTEND,\n      DIAG_START_LEX           = DIAG_START_SERIALIZATION + DIAG_SIZE_SERIALIZATION,\n      DIAG_START_PARSE         = DIAG_START_LEX           + DIAG_SIZE_LEX,\n      DIAG_START_AST           = DIAG_START_PARSE         + DIAG_SIZE_PARSE,\n      DIAG_START_COMMENT       = DIAG_START_AST           + DIAG_SIZE_AST,\n      DIAG_START_CROSSTU       = DIAG_START_COMMENT       + DIAG_SIZE_COMMENT,\n      DIAG_START_SEMA          = DIAG_START_CROSSTU       + DIAG_SIZE_CROSSTU,\n      DIAG_START_ANALYSIS      = DIAG_START_SEMA          + DIAG_SIZE_SEMA,\n      DIAG_START_REFACTORING   = DIAG_START_ANALYSIS      + DIAG_SIZE_ANALYSIS,\n      DIAG_UPPER_LIMIT         = DIAG_START_REFACTORING   + DIAG_SIZE_REFACTORING\n    };\n\n    class CustomDiagInfo;\n\n    /// All of the diagnostics that can be emitted by the frontend.\n    typedef unsigned kind;\n\n    // Get typedefs for common diagnostics.\n    enum {\n#define DIAG(ENUM, FLAGS, DEFAULT_MAPPING, DESC, GROUP, SFINAE, CATEGORY,      \\\n             NOWERROR, SHOWINSYSHEADER, DEFFERABLE)                            \\\n  ENUM,\n#define COMMONSTART\n#include \"clang/Basic/DiagnosticCommonKinds.inc\"\n      NUM_BUILTIN_COMMON_DIAGNOSTICS\n#undef DIAG\n    };\n\n    /// Enum values that allow the client to map NOTEs, WARNINGs, and EXTENSIONs\n    /// to either Ignore (nothing), Remark (emit a remark), Warning\n    /// (emit a warning) or Error (emit as an error).  It allows clients to\n    /// map ERRORs to Error or Fatal (stop emitting diagnostics after this one).\n    enum class Severity {\n      // NOTE: 0 means \"uncomputed\".\n      Ignored = 1, ///< Do not present this diagnostic, ignore it.\n      Remark = 2,  ///< Present this diagnostic as a remark.\n      Warning = 3, ///< Present this diagnostic as a warning.\n      Error = 4,   ///< Present this diagnostic as an error.\n      Fatal = 5    ///< Present this diagnostic as a fatal error.\n    };\n\n    /// Flavors of diagnostics we can emit. Used to filter for a particular\n    /// kind of diagnostic (for instance, for -W/-R flags).\n    enum class Flavor {\n      WarningOrError, ///< A diagnostic that indicates a problem or potential\n                      ///< problem. Can be made fatal by -Werror.\n      Remark          ///< A diagnostic that indicates normal progress through\n                      ///< compilation.\n    };\n  }\n\nclass DiagnosticMapping {\n  unsigned Severity : 3;\n  unsigned IsUser : 1;\n  unsigned IsPragma : 1;\n  unsigned HasNoWarningAsError : 1;\n  unsigned HasNoErrorAsFatal : 1;\n  unsigned WasUpgradedFromWarning : 1;\n\npublic:\n  static DiagnosticMapping Make(diag::Severity Severity, bool IsUser,\n                                bool IsPragma) {\n    DiagnosticMapping Result;\n    Result.Severity = (unsigned)Severity;\n    Result.IsUser = IsUser;\n    Result.IsPragma = IsPragma;\n    Result.HasNoWarningAsError = 0;\n    Result.HasNoErrorAsFatal = 0;\n    Result.WasUpgradedFromWarning = 0;\n    return Result;\n  }\n\n  diag::Severity getSeverity() const { return (diag::Severity)Severity; }\n  void setSeverity(diag::Severity Value) { Severity = (unsigned)Value; }\n\n  bool isUser() const { return IsUser; }\n  bool isPragma() const { return IsPragma; }\n\n  bool isErrorOrFatal() const {\n    return getSeverity() == diag::Severity::Error ||\n           getSeverity() == diag::Severity::Fatal;\n  }\n\n  bool hasNoWarningAsError() const { return HasNoWarningAsError; }\n  void setNoWarningAsError(bool Value) { HasNoWarningAsError = Value; }\n\n  bool hasNoErrorAsFatal() const { return HasNoErrorAsFatal; }\n  void setNoErrorAsFatal(bool Value) { HasNoErrorAsFatal = Value; }\n\n  /// Whether this mapping attempted to map the diagnostic to a warning, but\n  /// was overruled because the diagnostic was already mapped to an error or\n  /// fatal error.\n  bool wasUpgradedFromWarning() const { return WasUpgradedFromWarning; }\n  void setUpgradedFromWarning(bool Value) { WasUpgradedFromWarning = Value; }\n\n  /// Serialize this mapping as a raw integer.\n  unsigned serialize() const {\n    return (IsUser << 7) | (IsPragma << 6) | (HasNoWarningAsError << 5) |\n           (HasNoErrorAsFatal << 4) | (WasUpgradedFromWarning << 3) | Severity;\n  }\n  /// Deserialize a mapping.\n  static DiagnosticMapping deserialize(unsigned Bits) {\n    DiagnosticMapping Result;\n    Result.IsUser = (Bits >> 7) & 1;\n    Result.IsPragma = (Bits >> 6) & 1;\n    Result.HasNoWarningAsError = (Bits >> 5) & 1;\n    Result.HasNoErrorAsFatal = (Bits >> 4) & 1;\n    Result.WasUpgradedFromWarning = (Bits >> 3) & 1;\n    Result.Severity = Bits & 0x7;\n    return Result;\n  }\n};\n\n/// Used for handling and querying diagnostic IDs.\n///\n/// Can be used and shared by multiple Diagnostics for multiple translation units.\nclass DiagnosticIDs : public RefCountedBase<DiagnosticIDs> {\npublic:\n  /// The level of the diagnostic, after it has been through mapping.\n  enum Level {\n    Ignored, Note, Remark, Warning, Error, Fatal\n  };\n\nprivate:\n  /// Information for uniquing and looking up custom diags.\n  std::unique_ptr<diag::CustomDiagInfo> CustomDiagInfo;\n\npublic:\n  DiagnosticIDs();\n  ~DiagnosticIDs();\n\n  /// Return an ID for a diagnostic with the specified format string and\n  /// level.\n  ///\n  /// If this is the first request for this diagnostic, it is registered and\n  /// created, otherwise the existing ID is returned.\n\n  // FIXME: Replace this function with a create-only facilty like\n  // createCustomDiagIDFromFormatString() to enforce safe usage. At the time of\n  // writing, nearly all callers of this function were invalid.\n  unsigned getCustomDiagID(Level L, StringRef FormatString);\n\n  //===--------------------------------------------------------------------===//\n  // Diagnostic classification and reporting interfaces.\n  //\n\n  /// Given a diagnostic ID, return a description of the issue.\n  StringRef getDescription(unsigned DiagID) const;\n\n  /// Return true if the unmapped diagnostic levelof the specified\n  /// diagnostic ID is a Warning or Extension.\n  ///\n  /// This only works on builtin diagnostics, not custom ones, and is not\n  /// legal to call on NOTEs.\n  static bool isBuiltinWarningOrExtension(unsigned DiagID);\n\n  /// Return true if the specified diagnostic is mapped to errors by\n  /// default.\n  static bool isDefaultMappingAsError(unsigned DiagID);\n\n  /// Determine whether the given built-in diagnostic ID is a Note.\n  static bool isBuiltinNote(unsigned DiagID);\n\n  /// Determine whether the given built-in diagnostic ID is for an\n  /// extension of some sort.\n  static bool isBuiltinExtensionDiag(unsigned DiagID) {\n    bool ignored;\n    return isBuiltinExtensionDiag(DiagID, ignored);\n  }\n\n  /// Determine whether the given built-in diagnostic ID is for an\n  /// extension of some sort, and whether it is enabled by default.\n  ///\n  /// This also returns EnabledByDefault, which is set to indicate whether the\n  /// diagnostic is ignored by default (in which case -pedantic enables it) or\n  /// treated as a warning/error by default.\n  ///\n  static bool isBuiltinExtensionDiag(unsigned DiagID, bool &EnabledByDefault);\n\n\n  /// Return the lowest-level warning option that enables the specified\n  /// diagnostic.\n  ///\n  /// If there is no -Wfoo flag that controls the diagnostic, this returns null.\n  static StringRef getWarningOptionForDiag(unsigned DiagID);\n\n  /// Return the category number that a specified \\p DiagID belongs to,\n  /// or 0 if no category.\n  static unsigned getCategoryNumberForDiag(unsigned DiagID);\n\n  /// Return the number of diagnostic categories.\n  static unsigned getNumberOfCategories();\n\n  /// Given a category ID, return the name of the category.\n  static StringRef getCategoryNameFromID(unsigned CategoryID);\n\n  /// Return true if a given diagnostic falls into an ARC diagnostic\n  /// category.\n  static bool isARCDiagnostic(unsigned DiagID);\n\n  /// Enumeration describing how the emission of a diagnostic should\n  /// be treated when it occurs during C++ template argument deduction.\n  enum SFINAEResponse {\n    /// The diagnostic should not be reported, but it should cause\n    /// template argument deduction to fail.\n    ///\n    /// The vast majority of errors that occur during template argument\n    /// deduction fall into this category.\n    SFINAE_SubstitutionFailure,\n\n    /// The diagnostic should be suppressed entirely.\n    ///\n    /// Warnings generally fall into this category.\n    SFINAE_Suppress,\n\n    /// The diagnostic should be reported.\n    ///\n    /// The diagnostic should be reported. Various fatal errors (e.g.,\n    /// template instantiation depth exceeded) fall into this category.\n    SFINAE_Report,\n\n    /// The diagnostic is an access-control diagnostic, which will be\n    /// substitution failures in some contexts and reported in others.\n    SFINAE_AccessControl\n  };\n\n  /// Determines whether the given built-in diagnostic ID is\n  /// for an error that is suppressed if it occurs during C++ template\n  /// argument deduction.\n  ///\n  /// When an error is suppressed due to SFINAE, the template argument\n  /// deduction fails but no diagnostic is emitted. Certain classes of\n  /// errors, such as those errors that involve C++ access control,\n  /// are not SFINAE errors.\n  static SFINAEResponse getDiagnosticSFINAEResponse(unsigned DiagID);\n\n  /// Whether the diagnostic message can be deferred.\n  ///\n  /// For single source offloading languages, a diagnostic message occurred\n  /// in a device host function may be deferred until the function is sure\n  /// to be emitted.\n  static bool isDeferrable(unsigned DiagID);\n\n  /// Get the string of all diagnostic flags.\n  ///\n  /// \\returns A list of all diagnostics flags as they would be written in a\n  /// command line invocation including their `no-` variants. For example:\n  /// `{\"-Wempty-body\", \"-Wno-empty-body\", ...}`\n  static std::vector<std::string> getDiagnosticFlags();\n\n  /// Get the set of all diagnostic IDs in the group with the given name.\n  ///\n  /// \\param[out] Diags - On return, the diagnostics in the group.\n  /// \\returns \\c true if the given group is unknown, \\c false otherwise.\n  bool getDiagnosticsInGroup(diag::Flavor Flavor, StringRef Group,\n                             SmallVectorImpl<diag::kind> &Diags) const;\n\n  /// Get the set of all diagnostic IDs.\n  static void getAllDiagnostics(diag::Flavor Flavor,\n                                std::vector<diag::kind> &Diags);\n\n  /// Get the diagnostic option with the closest edit distance to the\n  /// given group name.\n  static StringRef getNearestOption(diag::Flavor Flavor, StringRef Group);\n\nprivate:\n  /// Classify the specified diagnostic ID into a Level, consumable by\n  /// the DiagnosticClient.\n  ///\n  /// The classification is based on the way the client configured the\n  /// DiagnosticsEngine object.\n  ///\n  /// \\param Loc The source location for which we are interested in finding out\n  /// the diagnostic state. Can be null in order to query the latest state.\n  DiagnosticIDs::Level\n  getDiagnosticLevel(unsigned DiagID, SourceLocation Loc,\n                     const DiagnosticsEngine &Diag) const LLVM_READONLY;\n\n  diag::Severity\n  getDiagnosticSeverity(unsigned DiagID, SourceLocation Loc,\n                        const DiagnosticsEngine &Diag) const LLVM_READONLY;\n\n  /// Used to report a diagnostic that is finally fully formed.\n  ///\n  /// \\returns \\c true if the diagnostic was emitted, \\c false if it was\n  /// suppressed.\n  bool ProcessDiag(DiagnosticsEngine &Diag) const;\n\n  /// Used to emit a diagnostic that is finally fully formed,\n  /// ignoring suppression.\n  void EmitDiag(DiagnosticsEngine &Diag, Level DiagLevel) const;\n\n  /// Whether the diagnostic may leave the AST in a state where some\n  /// invariants can break.\n  bool isUnrecoverable(unsigned DiagID) const;\n\n  friend class DiagnosticsEngine;\n};\n\n}  // end namespace clang\n\n#endif\n"}, "27": {"id": 27, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/DiagnosticOptions.h", "content": "//===- DiagnosticOptions.h --------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_DIAGNOSTICOPTIONS_H\n#define LLVM_CLANG_BASIC_DIAGNOSTICOPTIONS_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include <string>\n#include <type_traits>\n#include <vector>\n\nnamespace llvm {\nnamespace opt {\nclass ArgList;\n} // namespace opt\n} // namespace llvm\n\nnamespace clang {\nclass DiagnosticsEngine;\n\n/// Specifies which overload candidates to display when overload\n/// resolution fails.\nenum OverloadsShown : unsigned {\n  /// Show all overloads.\n  Ovl_All,\n\n  /// Show just the \"best\" overload candidates.\n  Ovl_Best\n};\n\n/// A bitmask representing the diagnostic levels used by\n/// VerifyDiagnosticConsumer.\nenum class DiagnosticLevelMask : unsigned {\n  None    = 0,\n  Note    = 1 << 0,\n  Remark  = 1 << 1,\n  Warning = 1 << 2,\n  Error   = 1 << 3,\n  All     = Note | Remark | Warning | Error\n};\n\ninline DiagnosticLevelMask operator~(DiagnosticLevelMask M) {\n  using UT = std::underlying_type<DiagnosticLevelMask>::type;\n  return static_cast<DiagnosticLevelMask>(~static_cast<UT>(M));\n}\n\ninline DiagnosticLevelMask operator|(DiagnosticLevelMask LHS,\n                                     DiagnosticLevelMask RHS) {\n  using UT = std::underlying_type<DiagnosticLevelMask>::type;\n  return static_cast<DiagnosticLevelMask>(\n    static_cast<UT>(LHS) | static_cast<UT>(RHS));\n}\n\ninline DiagnosticLevelMask operator&(DiagnosticLevelMask LHS,\n                                     DiagnosticLevelMask RHS) {\n  using UT = std::underlying_type<DiagnosticLevelMask>::type;\n  return static_cast<DiagnosticLevelMask>(\n    static_cast<UT>(LHS) & static_cast<UT>(RHS));\n}\n\nraw_ostream& operator<<(raw_ostream& Out, DiagnosticLevelMask M);\n\n/// Options for controlling the compiler diagnostics engine.\nclass DiagnosticOptions : public RefCountedBase<DiagnosticOptions>{\n  friend bool ParseDiagnosticArgs(DiagnosticOptions &, llvm::opt::ArgList &,\n                                  clang::DiagnosticsEngine *, bool);\n\n  friend class CompilerInvocation;\n\npublic:\n  enum TextDiagnosticFormat { Clang, MSVC, Vi };\n\n  // Default values.\n  enum {\n    DefaultTabStop = 8,\n    MaxTabStop = 100,\n    DefaultMacroBacktraceLimit = 6,\n    DefaultTemplateBacktraceLimit = 10,\n    DefaultConstexprBacktraceLimit = 10,\n    DefaultSpellCheckingLimit = 50,\n    DefaultSnippetLineLimit = 1,\n  };\n\n  // Define simple diagnostic options (with no accessors).\n#define DIAGOPT(Name, Bits, Default) unsigned Name : Bits;\n#define ENUM_DIAGOPT(Name, Type, Bits, Default)\n#include \"clang/Basic/DiagnosticOptions.def\"\n\nprotected:\n  // Define diagnostic options of enumeration type. These are private, and will\n  // have accessors (below).\n#define DIAGOPT(Name, Bits, Default)\n#define ENUM_DIAGOPT(Name, Type, Bits, Default) unsigned Name : Bits;\n#include \"clang/Basic/DiagnosticOptions.def\"\n\npublic:\n  /// The file to log diagnostic output to.\n  std::string DiagnosticLogFile;\n\n  /// The file to serialize diagnostics to (non-appending).\n  std::string DiagnosticSerializationFile;\n\n  /// The list of -W... options used to alter the diagnostic mappings, with the\n  /// prefixes removed.\n  std::vector<std::string> Warnings;\n\n  /// The list of prefixes from -Wundef-prefix=... used to generate warnings\n  /// for undefined macros.\n  std::vector<std::string> UndefPrefixes;\n\n  /// The list of -R... options used to alter the diagnostic mappings, with the\n  /// prefixes removed.\n  std::vector<std::string> Remarks;\n\n  /// The prefixes for comment directives sought by -verify (\"expected\" by\n  /// default).\n  std::vector<std::string> VerifyPrefixes;\n\npublic:\n  // Define accessors/mutators for diagnostic options of enumeration type.\n#define DIAGOPT(Name, Bits, Default)\n#define ENUM_DIAGOPT(Name, Type, Bits, Default) \\\n  Type get##Name() const { return static_cast<Type>(Name); } \\\n  void set##Name(Type Value) { Name = static_cast<unsigned>(Value); }\n#include \"clang/Basic/DiagnosticOptions.def\"\n\n  DiagnosticOptions() {\n#define DIAGOPT(Name, Bits, Default) Name = Default;\n#define ENUM_DIAGOPT(Name, Type, Bits, Default) set##Name(Default);\n#include \"clang/Basic/DiagnosticOptions.def\"\n  }\n};\n\nusing TextDiagnosticFormat = DiagnosticOptions::TextDiagnosticFormat;\n\n} // namespace clang\n\n#endif // LLVM_CLANG_BASIC_DIAGNOSTICOPTIONS_H\n"}, "28": {"id": 28, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/IdentifierTable.h", "content": "//===- IdentifierTable.h - Hash table for identifier lookup -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the clang::IdentifierInfo, clang::IdentifierTable, and\n/// clang::Selector interfaces.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_IDENTIFIERTABLE_H\n#define LLVM_CLANG_BASIC_IDENTIFIERTABLE_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/TokenKinds.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <cstring>\n#include <string>\n#include <utility>\n\nnamespace clang {\n\nclass DeclarationName;\nclass DeclarationNameTable;\nclass IdentifierInfo;\nclass LangOptions;\nclass MultiKeywordSelector;\nclass SourceLocation;\n\n/// A simple pair of identifier info and location.\nusing IdentifierLocPair = std::pair<IdentifierInfo *, SourceLocation>;\n\n/// IdentifierInfo and other related classes are aligned to\n/// 8 bytes so that DeclarationName can use the lower 3 bits\n/// of a pointer to one of these classes.\nenum { IdentifierInfoAlignment = 8 };\n\nstatic constexpr int ObjCOrBuiltinIDBits = 15;\n\n/// One of these records is kept for each identifier that\n/// is lexed.  This contains information about whether the token was \\#define'd,\n/// is a language keyword, or if it is a front-end token of some sort (e.g. a\n/// variable or function name).  The preprocessor keeps this information in a\n/// set, and all tok::identifier tokens have a pointer to one of these.\n/// It is aligned to 8 bytes because DeclarationName needs the lower 3 bits.\nclass alignas(IdentifierInfoAlignment) IdentifierInfo {\n  friend class IdentifierTable;\n\n  // Front-end token ID or tok::identifier.\n  unsigned TokenID : 9;\n\n  // ObjC keyword ('protocol' in '@protocol') or builtin (__builtin_inf).\n  // First NUM_OBJC_KEYWORDS values are for Objective-C,\n  // the remaining values are for builtins.\n  unsigned ObjCOrBuiltinID : ObjCOrBuiltinIDBits;\n\n  // True if there is a #define for this.\n  unsigned HasMacro : 1;\n\n  // True if there was a #define for this.\n  unsigned HadMacro : 1;\n\n  // True if the identifier is a language extension.\n  unsigned IsExtension : 1;\n\n  // True if the identifier is a keyword in a newer or proposed Standard.\n  unsigned IsFutureCompatKeyword : 1;\n\n  // True if the identifier is poisoned.\n  unsigned IsPoisoned : 1;\n\n  // True if the identifier is a C++ operator keyword.\n  unsigned IsCPPOperatorKeyword : 1;\n\n  // Internal bit set by the member function RecomputeNeedsHandleIdentifier.\n  // See comment about RecomputeNeedsHandleIdentifier for more info.\n  unsigned NeedsHandleIdentifier : 1;\n\n  // True if the identifier was loaded (at least partially) from an AST file.\n  unsigned IsFromAST : 1;\n\n  // True if the identifier has changed from the definition\n  // loaded from an AST file.\n  unsigned ChangedAfterLoad : 1;\n\n  // True if the identifier's frontend information has changed from the\n  // definition loaded from an AST file.\n  unsigned FEChangedAfterLoad : 1;\n\n  // True if revertTokenIDToIdentifier was called.\n  unsigned RevertedTokenID : 1;\n\n  // True if there may be additional information about\n  // this identifier stored externally.\n  unsigned OutOfDate : 1;\n\n  // True if this is the 'import' contextual keyword.\n  unsigned IsModulesImport : 1;\n\n  // True if this is a mangled OpenMP variant name.\n  unsigned IsMangledOpenMPVariantName : 1;\n\n  // 28 bits left in a 64-bit word.\n\n  // Managed by the language front-end.\n  void *FETokenInfo = nullptr;\n\n  llvm::StringMapEntry<IdentifierInfo *> *Entry = nullptr;\n\n  IdentifierInfo()\n      : TokenID(tok::identifier), ObjCOrBuiltinID(0), HasMacro(false),\n        HadMacro(false), IsExtension(false), IsFutureCompatKeyword(false),\n        IsPoisoned(false), IsCPPOperatorKeyword(false),\n        NeedsHandleIdentifier(false), IsFromAST(false), ChangedAfterLoad(false),\n        FEChangedAfterLoad(false), RevertedTokenID(false), OutOfDate(false),\n        IsModulesImport(false), IsMangledOpenMPVariantName(false) {}\n\npublic:\n  IdentifierInfo(const IdentifierInfo &) = delete;\n  IdentifierInfo &operator=(const IdentifierInfo &) = delete;\n  IdentifierInfo(IdentifierInfo &&) = delete;\n  IdentifierInfo &operator=(IdentifierInfo &&) = delete;\n\n  /// Return true if this is the identifier for the specified string.\n  ///\n  /// This is intended to be used for string literals only: II->isStr(\"foo\").\n  template <std::size_t StrLen>\n  bool isStr(const char (&Str)[StrLen]) const {\n    return getLength() == StrLen-1 &&\n           memcmp(getNameStart(), Str, StrLen-1) == 0;\n  }\n\n  /// Return true if this is the identifier for the specified StringRef.\n  bool isStr(llvm::StringRef Str) const {\n    llvm::StringRef ThisStr(getNameStart(), getLength());\n    return ThisStr == Str;\n  }\n\n  /// Return the beginning of the actual null-terminated string for this\n  /// identifier.\n  const char *getNameStart() const { return Entry->getKeyData(); }\n\n  /// Efficiently return the length of this identifier info.\n  unsigned getLength() const { return Entry->getKeyLength(); }\n\n  /// Return the actual identifier string.\n  StringRef getName() const {\n    return StringRef(getNameStart(), getLength());\n  }\n\n  /// Return true if this identifier is \\#defined to some other value.\n  /// \\note The current definition may be in a module and not currently visible.\n  bool hasMacroDefinition() const {\n    return HasMacro;\n  }\n  void setHasMacroDefinition(bool Val) {\n    if (HasMacro == Val) return;\n\n    HasMacro = Val;\n    if (Val) {\n      NeedsHandleIdentifier = true;\n      HadMacro = true;\n    } else {\n      RecomputeNeedsHandleIdentifier();\n    }\n  }\n  /// Returns true if this identifier was \\#defined to some value at any\n  /// moment. In this case there should be an entry for the identifier in the\n  /// macro history table in Preprocessor.\n  bool hadMacroDefinition() const {\n    return HadMacro;\n  }\n\n  /// If this is a source-language token (e.g. 'for'), this API\n  /// can be used to cause the lexer to map identifiers to source-language\n  /// tokens.\n  tok::TokenKind getTokenID() const { return (tok::TokenKind)TokenID; }\n\n  /// True if revertTokenIDToIdentifier() was called.\n  bool hasRevertedTokenIDToIdentifier() const { return RevertedTokenID; }\n\n  /// Revert TokenID to tok::identifier; used for GNU libstdc++ 4.2\n  /// compatibility.\n  ///\n  /// TokenID is normally read-only but there are 2 instances where we revert it\n  /// to tok::identifier for libstdc++ 4.2. Keep track of when this happens\n  /// using this method so we can inform serialization about it.\n  void revertTokenIDToIdentifier() {\n    assert(TokenID != tok::identifier && \"Already at tok::identifier\");\n    TokenID = tok::identifier;\n    RevertedTokenID = true;\n  }\n  void revertIdentifierToTokenID(tok::TokenKind TK) {\n    assert(TokenID == tok::identifier && \"Should be at tok::identifier\");\n    TokenID = TK;\n    RevertedTokenID = false;\n  }\n\n  /// Return the preprocessor keyword ID for this identifier.\n  ///\n  /// For example, \"define\" will return tok::pp_define.\n  tok::PPKeywordKind getPPKeywordID() const;\n\n  /// Return the Objective-C keyword ID for the this identifier.\n  ///\n  /// For example, 'class' will return tok::objc_class if ObjC is enabled.\n  tok::ObjCKeywordKind getObjCKeywordID() const {\n    if (ObjCOrBuiltinID < tok::NUM_OBJC_KEYWORDS)\n      return tok::ObjCKeywordKind(ObjCOrBuiltinID);\n    else\n      return tok::objc_not_keyword;\n  }\n  void setObjCKeywordID(tok::ObjCKeywordKind ID) { ObjCOrBuiltinID = ID; }\n\n  /// Return a value indicating whether this is a builtin function.\n  ///\n  /// 0 is not-built-in. 1+ are specific builtin functions.\n  unsigned getBuiltinID() const {\n    if (ObjCOrBuiltinID >= tok::NUM_OBJC_KEYWORDS)\n      return ObjCOrBuiltinID - tok::NUM_OBJC_KEYWORDS;\n    else\n      return 0;\n  }\n  void setBuiltinID(unsigned ID) {\n    ObjCOrBuiltinID = ID + tok::NUM_OBJC_KEYWORDS;\n    assert(ObjCOrBuiltinID - unsigned(tok::NUM_OBJC_KEYWORDS) == ID\n           && \"ID too large for field!\");\n  }\n\n  unsigned getObjCOrBuiltinID() const { return ObjCOrBuiltinID; }\n  void setObjCOrBuiltinID(unsigned ID) { ObjCOrBuiltinID = ID; }\n\n  /// get/setExtension - Initialize information about whether or not this\n  /// language token is an extension.  This controls extension warnings, and is\n  /// only valid if a custom token ID is set.\n  bool isExtensionToken() const { return IsExtension; }\n  void setIsExtensionToken(bool Val) {\n    IsExtension = Val;\n    if (Val)\n      NeedsHandleIdentifier = true;\n    else\n      RecomputeNeedsHandleIdentifier();\n  }\n\n  /// is/setIsFutureCompatKeyword - Initialize information about whether or not\n  /// this language token is a keyword in a newer or proposed Standard. This\n  /// controls compatibility warnings, and is only true when not parsing the\n  /// corresponding Standard. Once a compatibility problem has been diagnosed\n  /// with this keyword, the flag will be cleared.\n  bool isFutureCompatKeyword() const { return IsFutureCompatKeyword; }\n  void setIsFutureCompatKeyword(bool Val) {\n    IsFutureCompatKeyword = Val;\n    if (Val)\n      NeedsHandleIdentifier = true;\n    else\n      RecomputeNeedsHandleIdentifier();\n  }\n\n  /// setIsPoisoned - Mark this identifier as poisoned.  After poisoning, the\n  /// Preprocessor will emit an error every time this token is used.\n  void setIsPoisoned(bool Value = true) {\n    IsPoisoned = Value;\n    if (Value)\n      NeedsHandleIdentifier = true;\n    else\n      RecomputeNeedsHandleIdentifier();\n  }\n\n  /// Return true if this token has been poisoned.\n  bool isPoisoned() const { return IsPoisoned; }\n\n  /// isCPlusPlusOperatorKeyword/setIsCPlusPlusOperatorKeyword controls whether\n  /// this identifier is a C++ alternate representation of an operator.\n  void setIsCPlusPlusOperatorKeyword(bool Val = true) {\n    IsCPPOperatorKeyword = Val;\n  }\n  bool isCPlusPlusOperatorKeyword() const { return IsCPPOperatorKeyword; }\n\n  /// Return true if this token is a keyword in the specified language.\n  bool isKeyword(const LangOptions &LangOpts) const;\n\n  /// Return true if this token is a C++ keyword in the specified\n  /// language.\n  bool isCPlusPlusKeyword(const LangOptions &LangOpts) const;\n\n  /// Get and set FETokenInfo. The language front-end is allowed to associate\n  /// arbitrary metadata with this token.\n  void *getFETokenInfo() const { return FETokenInfo; }\n  void setFETokenInfo(void *T) { FETokenInfo = T; }\n\n  /// Return true if the Preprocessor::HandleIdentifier must be called\n  /// on a token of this identifier.\n  ///\n  /// If this returns false, we know that HandleIdentifier will not affect\n  /// the token.\n  bool isHandleIdentifierCase() const { return NeedsHandleIdentifier; }\n\n  /// Return true if the identifier in its current state was loaded\n  /// from an AST file.\n  bool isFromAST() const { return IsFromAST; }\n\n  void setIsFromAST() { IsFromAST = true; }\n\n  /// Determine whether this identifier has changed since it was loaded\n  /// from an AST file.\n  bool hasChangedSinceDeserialization() const {\n    return ChangedAfterLoad;\n  }\n\n  /// Note that this identifier has changed since it was loaded from\n  /// an AST file.\n  void setChangedSinceDeserialization() {\n    ChangedAfterLoad = true;\n  }\n\n  /// Determine whether the frontend token information for this\n  /// identifier has changed since it was loaded from an AST file.\n  bool hasFETokenInfoChangedSinceDeserialization() const {\n    return FEChangedAfterLoad;\n  }\n\n  /// Note that the frontend token information for this identifier has\n  /// changed since it was loaded from an AST file.\n  void setFETokenInfoChangedSinceDeserialization() {\n    FEChangedAfterLoad = true;\n  }\n\n  /// Determine whether the information for this identifier is out of\n  /// date with respect to the external source.\n  bool isOutOfDate() const { return OutOfDate; }\n\n  /// Set whether the information for this identifier is out of\n  /// date with respect to the external source.\n  void setOutOfDate(bool OOD) {\n    OutOfDate = OOD;\n    if (OOD)\n      NeedsHandleIdentifier = true;\n    else\n      RecomputeNeedsHandleIdentifier();\n  }\n\n  /// Determine whether this is the contextual keyword \\c import.\n  bool isModulesImport() const { return IsModulesImport; }\n\n  /// Set whether this identifier is the contextual keyword \\c import.\n  void setModulesImport(bool I) {\n    IsModulesImport = I;\n    if (I)\n      NeedsHandleIdentifier = true;\n    else\n      RecomputeNeedsHandleIdentifier();\n  }\n\n  /// Determine whether this is the mangled name of an OpenMP variant.\n  bool isMangledOpenMPVariantName() const { return IsMangledOpenMPVariantName; }\n\n  /// Set whether this is the mangled name of an OpenMP variant.\n  void setMangledOpenMPVariantName(bool I) { IsMangledOpenMPVariantName = I; }\n\n  /// Return true if this identifier is an editor placeholder.\n  ///\n  /// Editor placeholders are produced by the code-completion engine and are\n  /// represented as characters between '<#' and '#>' in the source code. An\n  /// example of auto-completed call with a placeholder parameter is shown\n  /// below:\n  /// \\code\n  ///   function(<#int x#>);\n  /// \\endcode\n  bool isEditorPlaceholder() const {\n    return getName().startswith(\"<#\") && getName().endswith(\"#>\");\n  }\n\n  /// Determine whether \\p this is a name reserved for the implementation (C99\n  /// 7.1.3, C++ [lib.global.names]).\n  bool isReservedName(bool doubleUnderscoreOnly = false) const {\n    if (getLength() < 2)\n      return false;\n    const char *Name = getNameStart();\n    return Name[0] == '_' &&\n           (Name[1] == '_' ||\n            (Name[1] >= 'A' && Name[1] <= 'Z' && !doubleUnderscoreOnly));\n  }\n\n  /// Provide less than operator for lexicographical sorting.\n  bool operator<(const IdentifierInfo &RHS) const {\n    return getName() < RHS.getName();\n  }\n\nprivate:\n  /// The Preprocessor::HandleIdentifier does several special (but rare)\n  /// things to identifiers of various sorts.  For example, it changes the\n  /// \\c for keyword token from tok::identifier to tok::for.\n  ///\n  /// This method is very tied to the definition of HandleIdentifier.  Any\n  /// change to it should be reflected here.\n  void RecomputeNeedsHandleIdentifier() {\n    NeedsHandleIdentifier = isPoisoned() || hasMacroDefinition() ||\n                            isExtensionToken() || isFutureCompatKeyword() ||\n                            isOutOfDate() || isModulesImport();\n  }\n};\n\n/// An RAII object for [un]poisoning an identifier within a scope.\n///\n/// \\p II is allowed to be null, in which case objects of this type have\n/// no effect.\nclass PoisonIdentifierRAIIObject {\n  IdentifierInfo *const II;\n  const bool OldValue;\n\npublic:\n  PoisonIdentifierRAIIObject(IdentifierInfo *II, bool NewValue)\n    : II(II), OldValue(II ? II->isPoisoned() : false) {\n    if(II)\n      II->setIsPoisoned(NewValue);\n  }\n\n  ~PoisonIdentifierRAIIObject() {\n    if(II)\n      II->setIsPoisoned(OldValue);\n  }\n};\n\n/// An iterator that walks over all of the known identifiers\n/// in the lookup table.\n///\n/// Since this iterator uses an abstract interface via virtual\n/// functions, it uses an object-oriented interface rather than the\n/// more standard C++ STL iterator interface. In this OO-style\n/// iteration, the single function \\c Next() provides dereference,\n/// advance, and end-of-sequence checking in a single\n/// operation. Subclasses of this iterator type will provide the\n/// actual functionality.\nclass IdentifierIterator {\nprotected:\n  IdentifierIterator() = default;\n\npublic:\n  IdentifierIterator(const IdentifierIterator &) = delete;\n  IdentifierIterator &operator=(const IdentifierIterator &) = delete;\n\n  virtual ~IdentifierIterator();\n\n  /// Retrieve the next string in the identifier table and\n  /// advances the iterator for the following string.\n  ///\n  /// \\returns The next string in the identifier table. If there is\n  /// no such string, returns an empty \\c StringRef.\n  virtual StringRef Next() = 0;\n};\n\n/// Provides lookups to, and iteration over, IdentiferInfo objects.\nclass IdentifierInfoLookup {\npublic:\n  virtual ~IdentifierInfoLookup();\n\n  /// Return the IdentifierInfo for the specified named identifier.\n  ///\n  /// Unlike the version in IdentifierTable, this returns a pointer instead\n  /// of a reference.  If the pointer is null then the IdentifierInfo cannot\n  /// be found.\n  virtual IdentifierInfo* get(StringRef Name) = 0;\n\n  /// Retrieve an iterator into the set of all identifiers\n  /// known to this identifier lookup source.\n  ///\n  /// This routine provides access to all of the identifiers known to\n  /// the identifier lookup, allowing access to the contents of the\n  /// identifiers without introducing the overhead of constructing\n  /// IdentifierInfo objects for each.\n  ///\n  /// \\returns A new iterator into the set of known identifiers. The\n  /// caller is responsible for deleting this iterator.\n  virtual IdentifierIterator *getIdentifiers();\n};\n\n/// Implements an efficient mapping from strings to IdentifierInfo nodes.\n///\n/// This has no other purpose, but this is an extremely performance-critical\n/// piece of the code, as each occurrence of every identifier goes through\n/// here when lexed.\nclass IdentifierTable {\n  // Shark shows that using MallocAllocator is *much* slower than using this\n  // BumpPtrAllocator!\n  using HashTableTy = llvm::StringMap<IdentifierInfo *, llvm::BumpPtrAllocator>;\n  HashTableTy HashTable;\n\n  IdentifierInfoLookup* ExternalLookup;\n\npublic:\n  /// Create the identifier table.\n  explicit IdentifierTable(IdentifierInfoLookup *ExternalLookup = nullptr);\n\n  /// Create the identifier table, populating it with info about the\n  /// language keywords for the language specified by \\p LangOpts.\n  explicit IdentifierTable(const LangOptions &LangOpts,\n                           IdentifierInfoLookup *ExternalLookup = nullptr);\n\n  /// Set the external identifier lookup mechanism.\n  void setExternalIdentifierLookup(IdentifierInfoLookup *IILookup) {\n    ExternalLookup = IILookup;\n  }\n\n  /// Retrieve the external identifier lookup object, if any.\n  IdentifierInfoLookup *getExternalIdentifierLookup() const {\n    return ExternalLookup;\n  }\n\n  llvm::BumpPtrAllocator& getAllocator() {\n    return HashTable.getAllocator();\n  }\n\n  /// Return the identifier token info for the specified named\n  /// identifier.\n  IdentifierInfo &get(StringRef Name) {\n    auto &Entry = *HashTable.insert(std::make_pair(Name, nullptr)).first;\n\n    IdentifierInfo *&II = Entry.second;\n    if (II) return *II;\n\n    // No entry; if we have an external lookup, look there first.\n    if (ExternalLookup) {\n      II = ExternalLookup->get(Name);\n      if (II)\n        return *II;\n    }\n\n    // Lookups failed, make a new IdentifierInfo.\n    void *Mem = getAllocator().Allocate<IdentifierInfo>();\n    II = new (Mem) IdentifierInfo();\n\n    // Make sure getName() knows how to find the IdentifierInfo\n    // contents.\n    II->Entry = &Entry;\n\n    return *II;\n  }\n\n  IdentifierInfo &get(StringRef Name, tok::TokenKind TokenCode) {\n    IdentifierInfo &II = get(Name);\n    II.TokenID = TokenCode;\n    assert(II.TokenID == (unsigned) TokenCode && \"TokenCode too large\");\n    return II;\n  }\n\n  /// Gets an IdentifierInfo for the given name without consulting\n  ///        external sources.\n  ///\n  /// This is a version of get() meant for external sources that want to\n  /// introduce or modify an identifier. If they called get(), they would\n  /// likely end up in a recursion.\n  IdentifierInfo &getOwn(StringRef Name) {\n    auto &Entry = *HashTable.insert(std::make_pair(Name, nullptr)).first;\n\n    IdentifierInfo *&II = Entry.second;\n    if (II)\n      return *II;\n\n    // Lookups failed, make a new IdentifierInfo.\n    void *Mem = getAllocator().Allocate<IdentifierInfo>();\n    II = new (Mem) IdentifierInfo();\n\n    // Make sure getName() knows how to find the IdentifierInfo\n    // contents.\n    II->Entry = &Entry;\n\n    // If this is the 'import' contextual keyword, mark it as such.\n    if (Name.equals(\"import\"))\n      II->setModulesImport(true);\n\n    return *II;\n  }\n\n  using iterator = HashTableTy::const_iterator;\n  using const_iterator = HashTableTy::const_iterator;\n\n  iterator begin() const { return HashTable.begin(); }\n  iterator end() const   { return HashTable.end(); }\n  unsigned size() const  { return HashTable.size(); }\n\n  iterator find(StringRef Name) const { return HashTable.find(Name); }\n\n  /// Print some statistics to stderr that indicate how well the\n  /// hashing is doing.\n  void PrintStats() const;\n\n  /// Populate the identifier table with info about the language keywords\n  /// for the language specified by \\p LangOpts.\n  void AddKeywords(const LangOptions &LangOpts);\n};\n\n/// A family of Objective-C methods.\n///\n/// These families have no inherent meaning in the language, but are\n/// nonetheless central enough in the existing implementations to\n/// merit direct AST support.  While, in theory, arbitrary methods can\n/// be considered to form families, we focus here on the methods\n/// involving allocation and retain-count management, as these are the\n/// most \"core\" and the most likely to be useful to diverse clients\n/// without extra information.\n///\n/// Both selectors and actual method declarations may be classified\n/// into families.  Method families may impose additional restrictions\n/// beyond their selector name; for example, a method called '_init'\n/// that returns void is not considered to be in the 'init' family\n/// (but would be if it returned 'id').  It is also possible to\n/// explicitly change or remove a method's family.  Therefore the\n/// method's family should be considered the single source of truth.\nenum ObjCMethodFamily {\n  /// No particular method family.\n  OMF_None,\n\n  // Selectors in these families may have arbitrary arity, may be\n  // written with arbitrary leading underscores, and may have\n  // additional CamelCase \"words\" in their first selector chunk\n  // following the family name.\n  OMF_alloc,\n  OMF_copy,\n  OMF_init,\n  OMF_mutableCopy,\n  OMF_new,\n\n  // These families are singletons consisting only of the nullary\n  // selector with the given name.\n  OMF_autorelease,\n  OMF_dealloc,\n  OMF_finalize,\n  OMF_release,\n  OMF_retain,\n  OMF_retainCount,\n  OMF_self,\n  OMF_initialize,\n\n  // performSelector families\n  OMF_performSelector\n};\n\n/// Enough bits to store any enumerator in ObjCMethodFamily or\n/// InvalidObjCMethodFamily.\nenum { ObjCMethodFamilyBitWidth = 4 };\n\n/// An invalid value of ObjCMethodFamily.\nenum { InvalidObjCMethodFamily = (1 << ObjCMethodFamilyBitWidth) - 1 };\n\n/// A family of Objective-C methods.\n///\n/// These are family of methods whose result type is initially 'id', but\n/// but are candidate for the result type to be changed to 'instancetype'.\nenum ObjCInstanceTypeFamily {\n  OIT_None,\n  OIT_Array,\n  OIT_Dictionary,\n  OIT_Singleton,\n  OIT_Init,\n  OIT_ReturnsSelf\n};\n\nenum ObjCStringFormatFamily {\n  SFF_None,\n  SFF_NSString,\n  SFF_CFString\n};\n\n/// Smart pointer class that efficiently represents Objective-C method\n/// names.\n///\n/// This class will either point to an IdentifierInfo or a\n/// MultiKeywordSelector (which is private). This enables us to optimize\n/// selectors that take no arguments and selectors that take 1 argument, which\n/// accounts for 78% of all selectors in Cocoa.h.\nclass Selector {\n  friend class Diagnostic;\n  friend class SelectorTable; // only the SelectorTable can create these\n  friend class DeclarationName; // and the AST's DeclarationName.\n\n  enum IdentifierInfoFlag {\n    // Empty selector = 0. Note that these enumeration values must\n    // correspond to the enumeration values of DeclarationName::StoredNameKind\n    ZeroArg  = 0x01,\n    OneArg   = 0x02,\n    MultiArg = 0x07,\n    ArgFlags = 0x07\n  };\n\n  /// A pointer to the MultiKeywordSelector or IdentifierInfo. We use the low\n  /// three bits of InfoPtr to store an IdentifierInfoFlag. Note that in any\n  /// case IdentifierInfo and MultiKeywordSelector are already aligned to\n  /// 8 bytes even on 32 bits archs because of DeclarationName.\n  uintptr_t InfoPtr = 0;\n\n  Selector(IdentifierInfo *II, unsigned nArgs) {\n    InfoPtr = reinterpret_cast<uintptr_t>(II);\n    assert((InfoPtr & ArgFlags) == 0 &&\"Insufficiently aligned IdentifierInfo\");\n    assert(nArgs < 2 && \"nArgs not equal to 0/1\");\n    InfoPtr |= nArgs+1;\n  }\n\n  Selector(MultiKeywordSelector *SI) {\n    InfoPtr = reinterpret_cast<uintptr_t>(SI);\n    assert((InfoPtr & ArgFlags) == 0 &&\"Insufficiently aligned IdentifierInfo\");\n    InfoPtr |= MultiArg;\n  }\n\n  IdentifierInfo *getAsIdentifierInfo() const {\n    if (getIdentifierInfoFlag() < MultiArg)\n      return reinterpret_cast<IdentifierInfo *>(InfoPtr & ~ArgFlags);\n    return nullptr;\n  }\n\n  MultiKeywordSelector *getMultiKeywordSelector() const {\n    return reinterpret_cast<MultiKeywordSelector *>(InfoPtr & ~ArgFlags);\n  }\n\n  unsigned getIdentifierInfoFlag() const {\n    return InfoPtr & ArgFlags;\n  }\n\n  static ObjCMethodFamily getMethodFamilyImpl(Selector sel);\n\n  static ObjCStringFormatFamily getStringFormatFamilyImpl(Selector sel);\n\npublic:\n  /// The default ctor should only be used when creating data structures that\n  ///  will contain selectors.\n  Selector() = default;\n  explicit Selector(uintptr_t V) : InfoPtr(V) {}\n\n  /// operator==/!= - Indicate whether the specified selectors are identical.\n  bool operator==(Selector RHS) const {\n    return InfoPtr == RHS.InfoPtr;\n  }\n  bool operator!=(Selector RHS) const {\n    return InfoPtr != RHS.InfoPtr;\n  }\n\n  void *getAsOpaquePtr() const {\n    return reinterpret_cast<void*>(InfoPtr);\n  }\n\n  /// Determine whether this is the empty selector.\n  bool isNull() const { return InfoPtr == 0; }\n\n  // Predicates to identify the selector type.\n  bool isKeywordSelector() const {\n    return getIdentifierInfoFlag() != ZeroArg;\n  }\n\n  bool isUnarySelector() const {\n    return getIdentifierInfoFlag() == ZeroArg;\n  }\n\n  /// If this selector is the specific keyword selector described by Names.\n  bool isKeywordSelector(ArrayRef<StringRef> Names) const;\n\n  /// If this selector is the specific unary selector described by Name.\n  bool isUnarySelector(StringRef Name) const;\n\n  unsigned getNumArgs() const;\n\n  /// Retrieve the identifier at a given position in the selector.\n  ///\n  /// Note that the identifier pointer returned may be NULL. Clients that only\n  /// care about the text of the identifier string, and not the specific,\n  /// uniqued identifier pointer, should use \\c getNameForSlot(), which returns\n  /// an empty string when the identifier pointer would be NULL.\n  ///\n  /// \\param argIndex The index for which we want to retrieve the identifier.\n  /// This index shall be less than \\c getNumArgs() unless this is a keyword\n  /// selector, in which case 0 is the only permissible value.\n  ///\n  /// \\returns the uniqued identifier for this slot, or NULL if this slot has\n  /// no corresponding identifier.\n  IdentifierInfo *getIdentifierInfoForSlot(unsigned argIndex) const;\n\n  /// Retrieve the name at a given position in the selector.\n  ///\n  /// \\param argIndex The index for which we want to retrieve the name.\n  /// This index shall be less than \\c getNumArgs() unless this is a keyword\n  /// selector, in which case 0 is the only permissible value.\n  ///\n  /// \\returns the name for this slot, which may be the empty string if no\n  /// name was supplied.\n  StringRef getNameForSlot(unsigned argIndex) const;\n\n  /// Derive the full selector name (e.g. \"foo:bar:\") and return\n  /// it as an std::string.\n  std::string getAsString() const;\n\n  /// Prints the full selector name (e.g. \"foo:bar:\").\n  void print(llvm::raw_ostream &OS) const;\n\n  void dump() const;\n\n  /// Derive the conventional family of this method.\n  ObjCMethodFamily getMethodFamily() const {\n    return getMethodFamilyImpl(*this);\n  }\n\n  ObjCStringFormatFamily getStringFormatFamily() const {\n    return getStringFormatFamilyImpl(*this);\n  }\n\n  static Selector getEmptyMarker() {\n    return Selector(uintptr_t(-1));\n  }\n\n  static Selector getTombstoneMarker() {\n    return Selector(uintptr_t(-2));\n  }\n\n  static ObjCInstanceTypeFamily getInstTypeMethodFamily(Selector sel);\n};\n\n/// This table allows us to fully hide how we implement\n/// multi-keyword caching.\nclass SelectorTable {\n  // Actually a SelectorTableImpl\n  void *Impl;\n\npublic:\n  SelectorTable();\n  SelectorTable(const SelectorTable &) = delete;\n  SelectorTable &operator=(const SelectorTable &) = delete;\n  ~SelectorTable();\n\n  /// Can create any sort of selector.\n  ///\n  /// \\p NumArgs indicates whether this is a no argument selector \"foo\", a\n  /// single argument selector \"foo:\" or multi-argument \"foo:bar:\".\n  Selector getSelector(unsigned NumArgs, IdentifierInfo **IIV);\n\n  Selector getUnarySelector(IdentifierInfo *ID) {\n    return Selector(ID, 1);\n  }\n\n  Selector getNullarySelector(IdentifierInfo *ID) {\n    return Selector(ID, 0);\n  }\n\n  /// Return the total amount of memory allocated for managing selectors.\n  size_t getTotalMemory() const;\n\n  /// Return the default setter name for the given identifier.\n  ///\n  /// This is \"set\" + \\p Name where the initial character of \\p Name\n  /// has been capitalized.\n  static SmallString<64> constructSetterName(StringRef Name);\n\n  /// Return the default setter selector for the given identifier.\n  ///\n  /// This is \"set\" + \\p Name where the initial character of \\p Name\n  /// has been capitalized.\n  static Selector constructSetterSelector(IdentifierTable &Idents,\n                                          SelectorTable &SelTable,\n                                          const IdentifierInfo *Name);\n\n  /// Return the property name for the given setter selector.\n  static std::string getPropertyNameFromSetterSelector(Selector Sel);\n};\n\nnamespace detail {\n\n/// DeclarationNameExtra is used as a base of various uncommon special names.\n/// This class is needed since DeclarationName has not enough space to store\n/// the kind of every possible names. Therefore the kind of common names is\n/// stored directly in DeclarationName, and the kind of uncommon names is\n/// stored in DeclarationNameExtra. It is aligned to 8 bytes because\n/// DeclarationName needs the lower 3 bits to store the kind of common names.\n/// DeclarationNameExtra is tightly coupled to DeclarationName and any change\n/// here is very likely to require changes in DeclarationName(Table).\nclass alignas(IdentifierInfoAlignment) DeclarationNameExtra {\n  friend class clang::DeclarationName;\n  friend class clang::DeclarationNameTable;\n\nprotected:\n  /// The kind of \"extra\" information stored in the DeclarationName. See\n  /// @c ExtraKindOrNumArgs for an explanation of how these enumerator values\n  /// are used. Note that DeclarationName depends on the numerical values\n  /// of the enumerators in this enum. See DeclarationName::StoredNameKind\n  /// for more info.\n  enum ExtraKind {\n    CXXDeductionGuideName,\n    CXXLiteralOperatorName,\n    CXXUsingDirective,\n    ObjCMultiArgSelector\n  };\n\n  /// ExtraKindOrNumArgs has one of the following meaning:\n  ///  * The kind of an uncommon C++ special name. This DeclarationNameExtra\n  ///    is in this case in fact either a CXXDeductionGuideNameExtra or\n  ///    a CXXLiteralOperatorIdName.\n  ///\n  ///  * It may be also name common to C++ using-directives (CXXUsingDirective),\n  ///\n  ///  * Otherwise it is ObjCMultiArgSelector+NumArgs, where NumArgs is\n  ///    the number of arguments in the Objective-C selector, in which\n  ///    case the DeclarationNameExtra is also a MultiKeywordSelector.\n  unsigned ExtraKindOrNumArgs;\n\n  DeclarationNameExtra(ExtraKind Kind) : ExtraKindOrNumArgs(Kind) {}\n  DeclarationNameExtra(unsigned NumArgs)\n      : ExtraKindOrNumArgs(ObjCMultiArgSelector + NumArgs) {}\n\n  /// Return the corresponding ExtraKind.\n  ExtraKind getKind() const {\n    return static_cast<ExtraKind>(ExtraKindOrNumArgs >\n                                          (unsigned)ObjCMultiArgSelector\n                                      ? (unsigned)ObjCMultiArgSelector\n                                      : ExtraKindOrNumArgs);\n  }\n\n  /// Return the number of arguments in an ObjC selector. Only valid when this\n  /// is indeed an ObjCMultiArgSelector.\n  unsigned getNumArgs() const {\n    assert(ExtraKindOrNumArgs >= (unsigned)ObjCMultiArgSelector &&\n           \"getNumArgs called but this is not an ObjC selector!\");\n    return ExtraKindOrNumArgs - (unsigned)ObjCMultiArgSelector;\n  }\n};\n\n} // namespace detail\n\n}  // namespace clang\n\nnamespace llvm {\n\n/// Define DenseMapInfo so that Selectors can be used as keys in DenseMap and\n/// DenseSets.\ntemplate <>\nstruct DenseMapInfo<clang::Selector> {\n  static clang::Selector getEmptyKey() {\n    return clang::Selector::getEmptyMarker();\n  }\n\n  static clang::Selector getTombstoneKey() {\n    return clang::Selector::getTombstoneMarker();\n  }\n\n  static unsigned getHashValue(clang::Selector S);\n\n  static bool isEqual(clang::Selector LHS, clang::Selector RHS) {\n    return LHS == RHS;\n  }\n};\n\ntemplate<>\nstruct PointerLikeTypeTraits<clang::Selector> {\n  static const void *getAsVoidPointer(clang::Selector P) {\n    return P.getAsOpaquePtr();\n  }\n\n  static clang::Selector getFromVoidPointer(const void *P) {\n    return clang::Selector(reinterpret_cast<uintptr_t>(P));\n  }\n\n  static constexpr int NumLowBitsAvailable = 0;\n};\n\n// Provide PointerLikeTypeTraits for IdentifierInfo pointers, which\n// are not guaranteed to be 8-byte aligned.\ntemplate<>\nstruct PointerLikeTypeTraits<clang::IdentifierInfo*> {\n  static void *getAsVoidPointer(clang::IdentifierInfo* P) {\n    return P;\n  }\n\n  static clang::IdentifierInfo *getFromVoidPointer(void *P) {\n    return static_cast<clang::IdentifierInfo*>(P);\n  }\n\n  static constexpr int NumLowBitsAvailable = 1;\n};\n\ntemplate<>\nstruct PointerLikeTypeTraits<const clang::IdentifierInfo*> {\n  static const void *getAsVoidPointer(const clang::IdentifierInfo* P) {\n    return P;\n  }\n\n  static const clang::IdentifierInfo *getFromVoidPointer(const void *P) {\n    return static_cast<const clang::IdentifierInfo*>(P);\n  }\n\n  static constexpr int NumLowBitsAvailable = 1;\n};\n\n} // namespace llvm\n\n#endif // LLVM_CLANG_BASIC_IDENTIFIERTABLE_H\n"}, "29": {"id": 29, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/LangOptions.h", "content": "//===- LangOptions.h - C Language Family Language Options -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the clang::LangOptions interface.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_LANGOPTIONS_H\n#define LLVM_CLANG_BASIC_LANGOPTIONS_H\n\n#include \"clang/Basic/CommentOptions.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/LangStandard.h\"\n#include \"clang/Basic/ObjCRuntime.h\"\n#include \"clang/Basic/Sanitizers.h\"\n#include \"clang/Basic/Visibility.h\"\n#include \"llvm/ADT/FloatingPointMode.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/MC/MCTargetOptions.h\"\n#include <string>\n#include <vector>\n\nnamespace clang {\n\n/// Bitfields of LangOptions, split out from LangOptions in order to ensure that\n/// this large collection of bitfields is a trivial class type.\nclass LangOptionsBase {\n  friend class CompilerInvocation;\n\npublic:\n  // Define simple language options (with no accessors).\n#define LANGOPT(Name, Bits, Default, Description) unsigned Name : Bits;\n#define ENUM_LANGOPT(Name, Type, Bits, Default, Description)\n#include \"clang/Basic/LangOptions.def\"\n\nprotected:\n  // Define language options of enumeration type. These are private, and will\n  // have accessors (below).\n#define LANGOPT(Name, Bits, Default, Description)\n#define ENUM_LANGOPT(Name, Type, Bits, Default, Description) \\\n  unsigned Name : Bits;\n#include \"clang/Basic/LangOptions.def\"\n};\n\n/// In the Microsoft ABI, this controls the placement of virtual displacement\n/// members used to implement virtual inheritance.\nenum class MSVtorDispMode { Never, ForVBaseOverride, ForVFTable };\n\n/// Keeps track of the various options that can be\n/// enabled, which controls the dialect of C or C++ that is accepted.\nclass LangOptions : public LangOptionsBase {\npublic:\n  using Visibility = clang::Visibility;\n  using RoundingMode = llvm::RoundingMode;\n\n  enum GCMode { NonGC, GCOnly, HybridGC };\n  enum StackProtectorMode { SSPOff, SSPOn, SSPStrong, SSPReq };\n\n  // Automatic variables live on the stack, and when trivial they're usually\n  // uninitialized because it's undefined behavior to use them without\n  // initializing them.\n  enum class TrivialAutoVarInitKind { Uninitialized, Zero, Pattern };\n\n  enum SignedOverflowBehaviorTy {\n    // Default C standard behavior.\n    SOB_Undefined,\n\n    // -fwrapv\n    SOB_Defined,\n\n    // -ftrapv\n    SOB_Trapping\n  };\n\n  // FIXME: Unify with TUKind.\n  enum CompilingModuleKind {\n    /// Not compiling a module interface at all.\n    CMK_None,\n\n    /// Compiling a module from a module map.\n    CMK_ModuleMap,\n\n    /// Compiling a module from a list of header files.\n    CMK_HeaderModule,\n\n    /// Compiling a C++ modules TS module interface unit.\n    CMK_ModuleInterface,\n  };\n\n  enum PragmaMSPointersToMembersKind {\n    PPTMK_BestCase,\n    PPTMK_FullGeneralitySingleInheritance,\n    PPTMK_FullGeneralityMultipleInheritance,\n    PPTMK_FullGeneralityVirtualInheritance\n  };\n\n  using MSVtorDispMode = clang::MSVtorDispMode;\n\n  enum DefaultCallingConvention {\n    DCC_None,\n    DCC_CDecl,\n    DCC_FastCall,\n    DCC_StdCall,\n    DCC_VectorCall,\n    DCC_RegCall\n  };\n\n  enum AddrSpaceMapMangling { ASMM_Target, ASMM_On, ASMM_Off };\n\n  // Corresponds to _MSC_VER\n  enum MSVCMajorVersion {\n    MSVC2010 = 1600,\n    MSVC2012 = 1700,\n    MSVC2013 = 1800,\n    MSVC2015 = 1900,\n    MSVC2017 = 1910,\n    MSVC2017_5 = 1912,\n    MSVC2017_7 = 1914,\n    MSVC2019 = 1920,\n  };\n\n  enum SYCLMajorVersion {\n    SYCL_None,\n    SYCL_2017,\n  };\n\n  /// Clang versions with different platform ABI conformance.\n  enum class ClangABI {\n    /// Attempt to be ABI-compatible with code generated by Clang 3.8.x\n    /// (SVN r257626). This causes <1 x long long> to be passed in an\n    /// integer register instead of an SSE register on x64_64.\n    Ver3_8,\n\n    /// Attempt to be ABI-compatible with code generated by Clang 4.0.x\n    /// (SVN r291814). This causes move operations to be ignored when\n    /// determining whether a class type can be passed or returned directly.\n    Ver4,\n\n    /// Attempt to be ABI-compatible with code generated by Clang 6.0.x\n    /// (SVN r321711). This causes determination of whether a type is\n    /// standard-layout to ignore collisions between empty base classes\n    /// and between base classes and member subobjects, which affects\n    /// whether we reuse base class tail padding in some ABIs.\n    Ver6,\n\n    /// Attempt to be ABI-compatible with code generated by Clang 7.0.x\n    /// (SVN r338536). This causes alignof (C++) and _Alignof (C11) to be\n    /// compatible with __alignof (i.e., return the preferred alignment)\n    /// rather than returning the required alignment.\n    Ver7,\n\n    /// Attempt to be ABI-compatible with code generated by Clang 9.0.x\n    /// (SVN r351319). This causes vectors of __int128 to be passed in memory\n    /// instead of passing in multiple scalar registers on x86_64 on Linux and\n    /// NetBSD.\n    Ver9,\n\n    /// Attempt to be ABI-compatible with code generated by Clang 11.0.x\n    /// (git  2e10b7a39b93). This causes clang to pass unions with a 256-bit\n    /// vector member on the stack instead of using registers, to not properly\n    /// mangle substitutions for template names in some cases, and to mangle\n    /// declaration template arguments without a cast to the parameter type\n    /// even when that can lead to mangling collisions.\n    Ver11,\n\n    /// Conform to the underlying platform's C and C++ ABIs as closely\n    /// as we can.\n    Latest\n  };\n\n  enum class CoreFoundationABI {\n    /// No interoperability ABI has been specified\n    Unspecified,\n    /// CoreFoundation does not have any language interoperability\n    Standalone,\n    /// Interoperability with the ObjectiveC runtime\n    ObjectiveC,\n    /// Interoperability with the latest known version of the Swift runtime\n    Swift,\n    /// Interoperability with the Swift 5.0 runtime\n    Swift5_0,\n    /// Interoperability with the Swift 4.2 runtime\n    Swift4_2,\n    /// Interoperability with the Swift 4.1 runtime\n    Swift4_1,\n  };\n\n  enum FPModeKind {\n    // Disable the floating point pragma\n    FPM_Off,\n\n    // Enable the floating point pragma\n    FPM_On,\n\n    // Aggressively fuse FP ops (E.g. FMA) disregarding pragmas.\n    FPM_Fast,\n\n    // Aggressively fuse FP ops and honor pragmas.\n    FPM_FastHonorPragmas\n  };\n\n  /// Alias for RoundingMode::NearestTiesToEven.\n  static constexpr unsigned FPR_ToNearest =\n      static_cast<unsigned>(llvm::RoundingMode::NearestTiesToEven);\n\n  /// Possible floating point exception behavior.\n  enum FPExceptionModeKind {\n    /// Assume that floating-point exceptions are masked.\n    FPE_Ignore,\n    /// Transformations do not cause new exceptions but may hide some.\n    FPE_MayTrap,\n    /// Strictly preserve the floating-point exception semantics.\n    FPE_Strict\n  };\n\n  /// Possible exception handling behavior.\n  using ExceptionHandlingKind = llvm::ExceptionHandling;\n\n  enum class LaxVectorConversionKind {\n    /// Permit no implicit vector bitcasts.\n    None,\n    /// Permit vector bitcasts between integer vectors with different numbers\n    /// of elements but the same total bit-width.\n    Integer,\n    /// Permit vector bitcasts between all vectors with the same total\n    /// bit-width.\n    All,\n  };\n\n  enum class SignReturnAddressScopeKind {\n    /// No signing for any function.\n    None,\n    /// Sign the return address of functions that spill LR.\n    NonLeaf,\n    /// Sign the return address of all functions,\n    All\n  };\n\n  enum class SignReturnAddressKeyKind {\n    /// Return address signing uses APIA key.\n    AKey,\n    /// Return address signing uses APIB key.\n    BKey\n  };\n\n  enum class ThreadModelKind {\n    /// POSIX Threads.\n    POSIX,\n    /// Single Threaded Environment.\n    Single\n  };\n\npublic:\n  /// The used language standard.\n  LangStandard::Kind LangStd;\n\n  /// Set of enabled sanitizers.\n  SanitizerSet Sanitize;\n\n  /// Paths to files specifying which objects\n  /// (files, functions, variables) should not be instrumented.\n  std::vector<std::string> NoSanitizeFiles;\n\n  /// Paths to the XRay \"always instrument\" files specifying which\n  /// objects (files, functions, variables) should be imbued with the XRay\n  /// \"always instrument\" attribute.\n  /// WARNING: This is a deprecated field and will go away in the future.\n  std::vector<std::string> XRayAlwaysInstrumentFiles;\n\n  /// Paths to the XRay \"never instrument\" files specifying which\n  /// objects (files, functions, variables) should be imbued with the XRay\n  /// \"never instrument\" attribute.\n  /// WARNING: This is a deprecated field and will go away in the future.\n  std::vector<std::string> XRayNeverInstrumentFiles;\n\n  /// Paths to the XRay attribute list files, specifying which objects\n  /// (files, functions, variables) should be imbued with the appropriate XRay\n  /// attribute(s).\n  std::vector<std::string> XRayAttrListFiles;\n\n  /// Paths to special case list files specifying which entities\n  /// (files, functions) should or should not be instrumented.\n  std::vector<std::string> ProfileListFiles;\n\n  clang::ObjCRuntime ObjCRuntime;\n\n  CoreFoundationABI CFRuntime = CoreFoundationABI::Unspecified;\n\n  std::string ObjCConstantStringClass;\n\n  /// The name of the handler function to be called when -ftrapv is\n  /// specified.\n  ///\n  /// If none is specified, abort (GCC-compatible behaviour).\n  std::string OverflowHandler;\n\n  /// The module currently being compiled as specified by -fmodule-name.\n  std::string ModuleName;\n\n  /// The name of the current module, of which the main source file\n  /// is a part. If CompilingModule is set, we are compiling the interface\n  /// of this module, otherwise we are compiling an implementation file of\n  /// it. This starts as ModuleName in case -fmodule-name is provided and\n  /// changes during compilation to reflect the current module.\n  std::string CurrentModule;\n\n  /// The names of any features to enable in module 'requires' decls\n  /// in addition to the hard-coded list in Module.cpp and the target features.\n  ///\n  /// This list is sorted.\n  std::vector<std::string> ModuleFeatures;\n\n  /// Options for parsing comments.\n  CommentOptions CommentOpts;\n\n  /// A list of all -fno-builtin-* function names (e.g., memset).\n  std::vector<std::string> NoBuiltinFuncs;\n\n  /// Triples of the OpenMP targets that the host code codegen should\n  /// take into account in order to generate accurate offloading descriptors.\n  std::vector<llvm::Triple> OMPTargetTriples;\n\n  /// Name of the IR file that contains the result of the OpenMP target\n  /// host code generation.\n  std::string OMPHostIRFile;\n\n  /// The user provided compilation unit ID, if non-empty. This is used to\n  /// externalize static variables which is needed to support accessing static\n  /// device variables in host code for single source offloading languages\n  /// like CUDA/HIP.\n  std::string CUID;\n\n  /// Indicates whether the front-end is explicitly told that the\n  /// input is a header file (i.e. -x c-header).\n  bool IsHeaderFile = false;\n\n  LangOptions();\n\n  // Define accessors/mutators for language options of enumeration type.\n#define LANGOPT(Name, Bits, Default, Description)\n#define ENUM_LANGOPT(Name, Type, Bits, Default, Description) \\\n  Type get##Name() const { return static_cast<Type>(Name); } \\\n  void set##Name(Type Value) { Name = static_cast<unsigned>(Value); }\n#include \"clang/Basic/LangOptions.def\"\n\n  /// Are we compiling a module interface (.cppm or module map)?\n  bool isCompilingModule() const {\n    return getCompilingModule() != CMK_None;\n  }\n\n  /// Do we need to track the owning module for a local declaration?\n  bool trackLocalOwningModule() const {\n    return isCompilingModule() || ModulesLocalVisibility;\n  }\n\n  bool isSignedOverflowDefined() const {\n    return getSignedOverflowBehavior() == SOB_Defined;\n  }\n\n  bool isSubscriptPointerArithmetic() const {\n    return ObjCRuntime.isSubscriptPointerArithmetic() &&\n           !ObjCSubscriptingLegacyRuntime;\n  }\n\n  bool isCompatibleWithMSVC(MSVCMajorVersion MajorVersion) const {\n    return MSCompatibilityVersion >= MajorVersion * 100000U;\n  }\n\n  /// Reset all of the options that are not considered when building a\n  /// module.\n  void resetNonModularOptions();\n\n  /// Is this a libc/libm function that is no longer recognized as a\n  /// builtin because a -fno-builtin-* option has been specified?\n  bool isNoBuiltinFunc(StringRef Name) const;\n\n  /// True if any ObjC types may have non-trivial lifetime qualifiers.\n  bool allowsNonTrivialObjCLifetimeQualifiers() const {\n    return ObjCAutoRefCount || ObjCWeak;\n  }\n\n  bool assumeFunctionsAreConvergent() const {\n    return ConvergentFunctions;\n  }\n\n  /// Return the OpenCL C or C++ version as a VersionTuple.\n  VersionTuple getOpenCLVersionTuple() const;\n\n  /// Check if return address signing is enabled.\n  bool hasSignReturnAddress() const {\n    return getSignReturnAddressScope() != SignReturnAddressScopeKind::None;\n  }\n\n  /// Check if return address signing uses AKey.\n  bool isSignReturnAddressWithAKey() const {\n    return getSignReturnAddressKey() == SignReturnAddressKeyKind::AKey;\n  }\n\n  /// Check if leaf functions are also signed.\n  bool isSignReturnAddressScopeAll() const {\n    return getSignReturnAddressScope() == SignReturnAddressScopeKind::All;\n  }\n\n  bool hasSjLjExceptions() const {\n    return getExceptionHandling() == llvm::ExceptionHandling::SjLj;\n  }\n\n  bool hasSEHExceptions() const {\n    return getExceptionHandling() == llvm::ExceptionHandling::WinEH;\n  }\n\n  bool hasDWARFExceptions() const {\n    return getExceptionHandling() == llvm::ExceptionHandling::DwarfCFI;\n  }\n\n  bool hasWasmExceptions() const {\n    return getExceptionHandling() == llvm::ExceptionHandling::Wasm;\n  }\n};\n\n/// Floating point control options\nclass FPOptionsOverride;\nclass FPOptions {\npublic:\n  // We start by defining the layout.\n  using storage_type = uint16_t;\n\n  using RoundingMode = llvm::RoundingMode;\n\n  static constexpr unsigned StorageBitSize = 8 * sizeof(storage_type);\n\n  // Define a fake option named \"First\" so that we have a PREVIOUS even for the\n  // real first option.\n  static constexpr storage_type FirstShift = 0, FirstWidth = 0;\n#define OPTION(NAME, TYPE, WIDTH, PREVIOUS)                                    \\\n  static constexpr storage_type NAME##Shift =                                  \\\n      PREVIOUS##Shift + PREVIOUS##Width;                                       \\\n  static constexpr storage_type NAME##Width = WIDTH;                           \\\n  static constexpr storage_type NAME##Mask = ((1 << NAME##Width) - 1)          \\\n                                             << NAME##Shift;\n#include \"clang/Basic/FPOptions.def\"\n\n  static constexpr storage_type TotalWidth = 0\n#define OPTION(NAME, TYPE, WIDTH, PREVIOUS) +WIDTH\n#include \"clang/Basic/FPOptions.def\"\n      ;\n  static_assert(TotalWidth <= StorageBitSize, \"Too short type for FPOptions\");\n\nprivate:\n  storage_type Value;\n\npublic:\n  FPOptions() : Value(0) {\n    setFPContractMode(LangOptions::FPM_Off);\n    setRoundingMode(static_cast<RoundingMode>(LangOptions::FPR_ToNearest));\n    setFPExceptionMode(LangOptions::FPE_Ignore);\n  }\n  explicit FPOptions(const LangOptions &LO) {\n    Value = 0;\n    // The language fp contract option FPM_FastHonorPragmas has the same effect\n    // as FPM_Fast in frontend. For simplicity, use FPM_Fast uniformly in\n    // frontend.\n    auto LangOptContractMode = LO.getDefaultFPContractMode();\n    if (LangOptContractMode == LangOptions::FPM_FastHonorPragmas)\n      LangOptContractMode = LangOptions::FPM_Fast;\n    setFPContractMode(LangOptContractMode);\n    setRoundingMode(LO.getFPRoundingMode());\n    setFPExceptionMode(LO.getFPExceptionMode());\n    setAllowFPReassociate(LO.AllowFPReassoc);\n    setNoHonorNaNs(LO.NoHonorNaNs);\n    setNoHonorInfs(LO.NoHonorInfs);\n    setNoSignedZero(LO.NoSignedZero);\n    setAllowReciprocal(LO.AllowRecip);\n    setAllowApproxFunc(LO.ApproxFunc);\n    if (getFPContractMode() == LangOptions::FPM_On &&\n        getRoundingMode() == llvm::RoundingMode::Dynamic &&\n        getFPExceptionMode() == LangOptions::FPE_Strict)\n      // If the FP settings are set to the \"strict\" model, then\n      // FENV access is set to true. (ffp-model=strict)\n      setAllowFEnvAccess(true);\n    else\n      setAllowFEnvAccess(LangOptions::FPM_Off);\n  }\n\n  bool allowFPContractWithinStatement() const {\n    return getFPContractMode() == LangOptions::FPM_On;\n  }\n  void setAllowFPContractWithinStatement() {\n    setFPContractMode(LangOptions::FPM_On);\n  }\n\n  bool allowFPContractAcrossStatement() const {\n    return getFPContractMode() == LangOptions::FPM_Fast;\n  }\n  void setAllowFPContractAcrossStatement() {\n    setFPContractMode(LangOptions::FPM_Fast);\n  }\n\n  bool isFPConstrained() const {\n    return getRoundingMode() != llvm::RoundingMode::NearestTiesToEven ||\n           getFPExceptionMode() != LangOptions::FPE_Ignore ||\n           getAllowFEnvAccess();\n  }\n\n  bool operator==(FPOptions other) const { return Value == other.Value; }\n\n  /// Return the default value of FPOptions that's used when trailing\n  /// storage isn't required.\n  static FPOptions defaultWithoutTrailingStorage(const LangOptions &LO);\n\n  storage_type getAsOpaqueInt() const { return Value; }\n  static FPOptions getFromOpaqueInt(storage_type Value) {\n    FPOptions Opts;\n    Opts.Value = Value;\n    return Opts;\n  }\n\n  // We can define most of the accessors automatically:\n#define OPTION(NAME, TYPE, WIDTH, PREVIOUS)                                    \\\n  TYPE get##NAME() const {                                                     \\\n    return static_cast<TYPE>((Value & NAME##Mask) >> NAME##Shift);             \\\n  }                                                                            \\\n  void set##NAME(TYPE value) {                                                 \\\n    Value = (Value & ~NAME##Mask) | (storage_type(value) << NAME##Shift);      \\\n  }\n#include \"clang/Basic/FPOptions.def\"\n  LLVM_DUMP_METHOD void dump();\n};\n\n/// Represents difference between two FPOptions values.\n///\n/// The effect of language constructs changing the set of floating point options\n/// is usually a change of some FP properties while leaving others intact. This\n/// class describes such changes by keeping information about what FP options\n/// are overridden.\n///\n/// The integral set of FP options, described by the class FPOptions, may be\n/// represented as a default FP option set, defined by language standard and\n/// command line options, with the overrides introduced by pragmas.\n///\n/// The is implemented as a value of the new FPOptions plus a mask showing which\n/// fields are actually set in it.\nclass FPOptionsOverride {\n  FPOptions Options = FPOptions::getFromOpaqueInt(0);\n  FPOptions::storage_type OverrideMask = 0;\n\npublic:\n  using RoundingMode = llvm::RoundingMode;\n\n  /// The type suitable for storing values of FPOptionsOverride. Must be twice\n  /// as wide as bit size of FPOption.\n  using storage_type = uint32_t;\n  static_assert(sizeof(storage_type) >= 2 * sizeof(FPOptions::storage_type),\n                \"Too short type for FPOptionsOverride\");\n\n  /// Bit mask selecting bits of OverrideMask in serialized representation of\n  /// FPOptionsOverride.\n  static constexpr storage_type OverrideMaskBits =\n      (static_cast<storage_type>(1) << FPOptions::StorageBitSize) - 1;\n\n  FPOptionsOverride() {}\n  FPOptionsOverride(const LangOptions &LO)\n      : Options(LO), OverrideMask(OverrideMaskBits) {}\n  FPOptionsOverride(FPOptions FPO)\n      : Options(FPO), OverrideMask(OverrideMaskBits) {}\n\n  bool requiresTrailingStorage() const { return OverrideMask != 0; }\n\n  void setAllowFPContractWithinStatement() {\n    setFPContractModeOverride(LangOptions::FPM_On);\n  }\n\n  void setAllowFPContractAcrossStatement() {\n    setFPContractModeOverride(LangOptions::FPM_Fast);\n  }\n\n  void setDisallowFPContract() {\n    setFPContractModeOverride(LangOptions::FPM_Off);\n  }\n\n  void setFPPreciseEnabled(bool Value) {\n    setAllowFPReassociateOverride(!Value);\n    setNoHonorNaNsOverride(!Value);\n    setNoHonorInfsOverride(!Value);\n    setNoSignedZeroOverride(!Value);\n    setAllowReciprocalOverride(!Value);\n    setAllowApproxFuncOverride(!Value);\n    if (Value)\n      /* Precise mode implies fp_contract=on and disables ffast-math */\n      setAllowFPContractWithinStatement();\n    else\n      /* Precise mode disabled sets fp_contract=fast and enables ffast-math */\n      setAllowFPContractAcrossStatement();\n  }\n\n  storage_type getAsOpaqueInt() const {\n    return (static_cast<storage_type>(Options.getAsOpaqueInt())\n            << FPOptions::StorageBitSize) |\n           OverrideMask;\n  }\n  static FPOptionsOverride getFromOpaqueInt(storage_type I) {\n    FPOptionsOverride Opts;\n    Opts.OverrideMask = I & OverrideMaskBits;\n    Opts.Options = FPOptions::getFromOpaqueInt(I >> FPOptions::StorageBitSize);\n    return Opts;\n  }\n\n  FPOptions applyOverrides(FPOptions Base) {\n    FPOptions Result =\n        FPOptions::getFromOpaqueInt((Base.getAsOpaqueInt() & ~OverrideMask) |\n                                     (Options.getAsOpaqueInt() & OverrideMask));\n    return Result;\n  }\n\n  FPOptions applyOverrides(const LangOptions &LO) {\n    return applyOverrides(FPOptions(LO));\n  }\n\n  bool operator==(FPOptionsOverride other) const {\n    return Options == other.Options && OverrideMask == other.OverrideMask;\n  }\n  bool operator!=(FPOptionsOverride other) const { return !(*this == other); }\n\n#define OPTION(NAME, TYPE, WIDTH, PREVIOUS)                                    \\\n  bool has##NAME##Override() const {                                           \\\n    return OverrideMask & FPOptions::NAME##Mask;                               \\\n  }                                                                            \\\n  TYPE get##NAME##Override() const {                                           \\\n    assert(has##NAME##Override());                                             \\\n    return Options.get##NAME();                                                \\\n  }                                                                            \\\n  void clear##NAME##Override() {                                               \\\n    /* Clear the actual value so that we don't have spurious differences when  \\\n     * testing equality. */                                                    \\\n    Options.set##NAME(TYPE(0));                                                \\\n    OverrideMask &= ~FPOptions::NAME##Mask;                                    \\\n  }                                                                            \\\n  void set##NAME##Override(TYPE value) {                                       \\\n    Options.set##NAME(value);                                                  \\\n    OverrideMask |= FPOptions::NAME##Mask;                                     \\\n  }\n#include \"clang/Basic/FPOptions.def\"\n  LLVM_DUMP_METHOD void dump();\n};\n\n/// Describes the kind of translation unit being processed.\nenum TranslationUnitKind {\n  /// The translation unit is a complete translation unit.\n  TU_Complete,\n\n  /// The translation unit is a prefix to a translation unit, and is\n  /// not complete.\n  TU_Prefix,\n\n  /// The translation unit is a module.\n  TU_Module\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_BASIC_LANGOPTIONS_H\n"}, "30": {"id": 30, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/ObjCRuntime.h", "content": "//===- ObjCRuntime.h - Objective-C Runtime Configuration --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines types useful for describing an Objective-C runtime.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_OBJCRUNTIME_H\n#define LLVM_CLANG_BASIC_OBJCRUNTIME_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/VersionTuple.h\"\n#include <string>\n\nnamespace clang {\n\n/// The basic abstraction for the target Objective-C runtime.\nclass ObjCRuntime {\npublic:\n  /// The basic Objective-C runtimes that we know about.\n  enum Kind {\n    /// 'macosx' is the Apple-provided NeXT-derived runtime on Mac OS\n    /// X platforms that use the non-fragile ABI; the version is a\n    /// release of that OS.\n    MacOSX,\n\n    /// 'macosx-fragile' is the Apple-provided NeXT-derived runtime on\n    /// Mac OS X platforms that use the fragile ABI; the version is a\n    /// release of that OS.\n    FragileMacOSX,\n\n    /// 'ios' is the Apple-provided NeXT-derived runtime on iOS or the iOS\n    /// simulator;  it is always non-fragile.  The version is a release\n    /// version of iOS.\n    iOS,\n\n    /// 'watchos' is a variant of iOS for Apple's watchOS. The version\n    /// is a release version of watchOS.\n    WatchOS,\n\n    /// 'gcc' is the Objective-C runtime shipped with GCC, implementing a\n    /// fragile Objective-C ABI\n    GCC,\n\n    /// 'gnustep' is the modern non-fragile GNUstep runtime.\n    GNUstep,\n\n    /// 'objfw' is the Objective-C runtime included in ObjFW\n    ObjFW\n  };\n\nprivate:\n  Kind TheKind = MacOSX;\n  VersionTuple Version;\n\npublic:\n  /// A bogus initialization of the runtime.\n  ObjCRuntime() = default;\n  ObjCRuntime(Kind kind, const VersionTuple &version)\n      : TheKind(kind), Version(version) {}\n\n  void set(Kind kind, VersionTuple version) {\n    TheKind = kind;\n    Version = version;\n  }\n\n  Kind getKind() const { return TheKind; }\n  const VersionTuple &getVersion() const { return Version; }\n\n  /// Does this runtime follow the set of implied behaviors for a\n  /// \"non-fragile\" ABI?\n  bool isNonFragile() const {\n    switch (getKind()) {\n    case FragileMacOSX: return false;\n    case GCC: return false;\n    case MacOSX: return true;\n    case GNUstep: return true;\n    case ObjFW: return true;\n    case iOS: return true;\n    case WatchOS: return true;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// The inverse of isNonFragile():  does this runtime follow the set of\n  /// implied behaviors for a \"fragile\" ABI?\n  bool isFragile() const { return !isNonFragile(); }\n\n  /// The default dispatch mechanism to use for the specified architecture\n  bool isLegacyDispatchDefaultForArch(llvm::Triple::ArchType Arch) {\n    // The GNUstep runtime uses a newer dispatch method by default from\n    // version 1.6 onwards\n    if (getKind() == GNUstep && getVersion() >= VersionTuple(1, 6)) {\n      if (Arch == llvm::Triple::arm ||\n          Arch == llvm::Triple::x86 ||\n          Arch == llvm::Triple::x86_64)\n        return false;\n    }\n    else if ((getKind() ==  MacOSX) && isNonFragile() &&\n             (getVersion() >= VersionTuple(10, 0)) &&\n             (getVersion() < VersionTuple(10, 6)))\n        return Arch != llvm::Triple::x86_64;\n    // Except for deployment target of 10.5 or less,\n    // Mac runtimes use legacy dispatch everywhere now.\n    return true;\n  }\n\n  /// Is this runtime basically of the GNU family of runtimes?\n  bool isGNUFamily() const {\n    switch (getKind()) {\n    case FragileMacOSX:\n    case MacOSX:\n    case iOS:\n    case WatchOS:\n      return false;\n    case GCC:\n    case GNUstep:\n    case ObjFW:\n      return true;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// Is this runtime basically of the NeXT family of runtimes?\n  bool isNeXTFamily() const {\n    // For now, this is just the inverse of isGNUFamily(), but that's\n    // not inherently true.\n    return !isGNUFamily();\n  }\n\n  /// Does this runtime allow ARC at all?\n  bool allowsARC() const {\n    switch (getKind()) {\n    case FragileMacOSX:\n      // No stub library for the fragile runtime.\n      return getVersion() >= VersionTuple(10, 7);\n    case MacOSX: return true;\n    case iOS: return true;\n    case WatchOS: return true;\n    case GCC: return false;\n    case GNUstep: return true;\n    case ObjFW: return true;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// Does this runtime natively provide the ARC entrypoints?\n  ///\n  /// ARC cannot be directly supported on a platform that does not provide\n  /// these entrypoints, although it may be supportable via a stub\n  /// library.\n  bool hasNativeARC() const {\n    switch (getKind()) {\n    case FragileMacOSX: return getVersion() >= VersionTuple(10, 7);\n    case MacOSX: return getVersion() >= VersionTuple(10, 7);\n    case iOS: return getVersion() >= VersionTuple(5);\n    case WatchOS: return true;\n\n    case GCC: return false;\n    case GNUstep: return getVersion() >= VersionTuple(1, 6);\n    case ObjFW: return true;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// Does this runtime provide ARC entrypoints that are likely to be faster\n  /// than an ordinary message send of the appropriate selector?\n  ///\n  /// The ARC entrypoints are guaranteed to be equivalent to just sending the\n  /// corresponding message.  If the entrypoint is implemented naively as just a\n  /// message send, using it is a trade-off: it sacrifices a few cycles of\n  /// overhead to save a small amount of code.  However, it's possible for\n  /// runtimes to detect and special-case classes that use \"standard\"\n  /// retain/release behavior; if that's dynamically a large proportion of all\n  /// retained objects, using the entrypoint will also be faster than using a\n  /// message send.\n  ///\n  /// When this method returns true, Clang will turn non-super message sends of\n  /// certain selectors into calls to the correspond entrypoint:\n  ///   retain => objc_retain\n  ///   release => objc_release\n  ///   autorelease => objc_autorelease\n  bool shouldUseARCFunctionsForRetainRelease() const {\n    switch (getKind()) {\n    case FragileMacOSX:\n      return false;\n    case MacOSX:\n      return getVersion() >= VersionTuple(10, 10);\n    case iOS:\n      return getVersion() >= VersionTuple(8);\n    case WatchOS:\n      return true;\n    case GCC:\n      return false;\n    case GNUstep:\n      return false;\n    case ObjFW:\n      return false;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// Does this runtime provide entrypoints that are likely to be faster\n  /// than an ordinary message send of the \"alloc\" selector?\n  ///\n  /// The \"alloc\" entrypoint is guaranteed to be equivalent to just sending the\n  /// corresponding message.  If the entrypoint is implemented naively as just a\n  /// message send, using it is a trade-off: it sacrifices a few cycles of\n  /// overhead to save a small amount of code.  However, it's possible for\n  /// runtimes to detect and special-case classes that use \"standard\"\n  /// alloc behavior; if that's dynamically a large proportion of all\n  /// objects, using the entrypoint will also be faster than using a message\n  /// send.\n  ///\n  /// When this method returns true, Clang will turn non-super message sends of\n  /// certain selectors into calls to the corresponding entrypoint:\n  ///   alloc => objc_alloc\n  ///   allocWithZone:nil => objc_allocWithZone\n  bool shouldUseRuntimeFunctionsForAlloc() const {\n    switch (getKind()) {\n    case FragileMacOSX:\n      return false;\n    case MacOSX:\n      return getVersion() >= VersionTuple(10, 10);\n    case iOS:\n      return getVersion() >= VersionTuple(8);\n    case WatchOS:\n      return true;\n\n    case GCC:\n      return false;\n    case GNUstep:\n      return false;\n    case ObjFW:\n      return false;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// Does this runtime provide the objc_alloc_init entrypoint? This can apply\n  /// the same optimization as objc_alloc, but also sends an -init message,\n  /// reducing code size on the caller.\n  bool shouldUseRuntimeFunctionForCombinedAllocInit() const {\n    switch (getKind()) {\n    case MacOSX:\n      return getVersion() >= VersionTuple(10, 14, 4);\n    case iOS:\n      return getVersion() >= VersionTuple(12, 2);\n    case WatchOS:\n      return getVersion() >= VersionTuple(5, 2);\n    default:\n      return false;\n    }\n  }\n\n  /// Does this runtime supports optimized setter entrypoints?\n  bool hasOptimizedSetter() const {\n    switch (getKind()) {\n      case MacOSX:\n        return getVersion() >= VersionTuple(10, 8);\n      case iOS:\n        return (getVersion() >= VersionTuple(6));\n      case WatchOS:\n        return true;\n      case GNUstep:\n        return getVersion() >= VersionTuple(1, 7);\n      default:\n        return false;\n    }\n  }\n\n  /// Does this runtime allow the use of __weak?\n  bool allowsWeak() const {\n    return hasNativeWeak();\n  }\n\n  /// Does this runtime natively provide ARC-compliant 'weak'\n  /// entrypoints?\n  bool hasNativeWeak() const {\n    // Right now, this is always equivalent to whether the runtime\n    // natively supports ARC decision.\n    return hasNativeARC();\n  }\n\n  /// Does this runtime directly support the subscripting methods?\n  ///\n  /// This is really a property of the library, not the runtime.\n  bool hasSubscripting() const {\n    switch (getKind()) {\n    case FragileMacOSX: return false;\n    case MacOSX: return getVersion() >= VersionTuple(10, 11);\n    case iOS: return getVersion() >= VersionTuple(9);\n    case WatchOS: return true;\n\n    // This is really a lie, because some implementations and versions\n    // of the runtime do not support ARC.  Probably -fgnu-runtime\n    // should imply a \"maximal\" runtime or something?\n    case GCC: return true;\n    case GNUstep: return true;\n    case ObjFW: return true;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// Does this runtime allow sizeof or alignof on object types?\n  bool allowsSizeofAlignof() const {\n    return isFragile();\n  }\n\n  /// Does this runtime allow pointer arithmetic on objects?\n  ///\n  /// This covers +, -, ++, --, and (if isSubscriptPointerArithmetic()\n  /// yields true) [].\n  bool allowsPointerArithmetic() const {\n    switch (getKind()) {\n    case FragileMacOSX:\n    case GCC:\n      return true;\n    case MacOSX:\n    case iOS:\n    case WatchOS:\n    case GNUstep:\n    case ObjFW:\n      return false;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// Is subscripting pointer arithmetic?\n  bool isSubscriptPointerArithmetic() const {\n    return allowsPointerArithmetic();\n  }\n\n  /// Does this runtime provide an objc_terminate function?\n  ///\n  /// This is used in handlers for exceptions during the unwind process;\n  /// without it, abort() must be used in pure ObjC files.\n  bool hasTerminate() const {\n    switch (getKind()) {\n    case FragileMacOSX: return getVersion() >= VersionTuple(10, 8);\n    case MacOSX: return getVersion() >= VersionTuple(10, 8);\n    case iOS: return getVersion() >= VersionTuple(5);\n    case WatchOS: return true;\n    case GCC: return false;\n    case GNUstep: return false;\n    case ObjFW: return false;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// Does this runtime support weakly importing classes?\n  bool hasWeakClassImport() const {\n    switch (getKind()) {\n    case MacOSX: return true;\n    case iOS: return true;\n    case WatchOS: return true;\n    case FragileMacOSX: return false;\n    case GCC: return true;\n    case GNUstep: return true;\n    case ObjFW: return true;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// Does this runtime use zero-cost exceptions?\n  bool hasUnwindExceptions() const {\n    switch (getKind()) {\n    case MacOSX: return true;\n    case iOS: return true;\n    case WatchOS: return true;\n    case FragileMacOSX: return false;\n    case GCC: return true;\n    case GNUstep: return true;\n    case ObjFW: return true;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  bool hasAtomicCopyHelper() const {\n    switch (getKind()) {\n    case FragileMacOSX:\n    case MacOSX:\n    case iOS:\n    case WatchOS:\n      return true;\n    case GNUstep:\n      return getVersion() >= VersionTuple(1, 7);\n    default: return false;\n    }\n  }\n\n  /// Is objc_unsafeClaimAutoreleasedReturnValue available?\n  bool hasARCUnsafeClaimAutoreleasedReturnValue() const {\n    switch (getKind()) {\n    case MacOSX:\n    case FragileMacOSX:\n      return getVersion() >= VersionTuple(10, 11);\n    case iOS:\n      return getVersion() >= VersionTuple(9);\n    case WatchOS:\n      return getVersion() >= VersionTuple(2);\n    case GNUstep:\n      return false;\n    default:\n      return false;\n    }\n  }\n\n  /// Are the empty collection symbols available?\n  bool hasEmptyCollections() const {\n    switch (getKind()) {\n    default:\n      return false;\n    case MacOSX:\n      return getVersion() >= VersionTuple(10, 11);\n    case iOS:\n      return getVersion() >= VersionTuple(9);\n    case WatchOS:\n      return getVersion() >= VersionTuple(2);\n    }\n  }\n\n  /// Returns true if this Objective-C runtime supports Objective-C class\n  /// stubs.\n  bool allowsClassStubs() const {\n    switch (getKind()) {\n    case FragileMacOSX:\n    case GCC:\n    case GNUstep:\n    case ObjFW:\n      return false;\n    case MacOSX:\n    case iOS:\n    case WatchOS:\n      return true;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// Does this runtime supports direct dispatch\n  bool allowsDirectDispatch() const {\n    switch (getKind()) {\n    case FragileMacOSX: return false;\n    case MacOSX: return true;\n    case iOS: return true;\n    case WatchOS: return true;\n    case GCC: return false;\n    case GNUstep: return false;\n    case ObjFW: return false;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// Try to parse an Objective-C runtime specification from the given\n  /// string.\n  ///\n  /// \\return true on error.\n  bool tryParse(StringRef input);\n\n  std::string getAsString() const;\n\n  friend bool operator==(const ObjCRuntime &left, const ObjCRuntime &right) {\n    return left.getKind() == right.getKind() &&\n           left.getVersion() == right.getVersion();\n  }\n\n  friend bool operator!=(const ObjCRuntime &left, const ObjCRuntime &right) {\n    return !(left == right);\n  }\n\n  friend llvm::hash_code hash_value(const ObjCRuntime &OCR) {\n    return llvm::hash_combine(OCR.getKind(), OCR.getVersion());\n  }\n};\n\nraw_ostream &operator<<(raw_ostream &out, const ObjCRuntime &value);\n\n} // namespace clang\n\n#endif // LLVM_CLANG_BASIC_OBJCRUNTIME_H\n"}, "31": {"id": 31, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/PartialDiagnostic.h", "content": "//===- PartialDiagnostic.h - Diagnostic \"closures\" --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Implements a partial diagnostic that can be emitted anwyhere\n/// in a DiagnosticBuilder stream.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_PARTIALDIAGNOSTIC_H\n#define LLVM_CLANG_BASIC_PARTIALDIAGNOSTIC_H\n\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <cassert>\n#include <cstdint>\n#include <string>\n#include <type_traits>\n#include <utility>\n\nnamespace clang {\n\nclass DeclContext;\nclass IdentifierInfo;\n\nclass PartialDiagnostic : public StreamingDiagnostic {\nprivate:\n  // NOTE: Sema assumes that PartialDiagnostic is location-invariant\n  // in the sense that its bits can be safely memcpy'ed and destructed\n  // in the new location.\n\n  /// The diagnostic ID.\n  mutable unsigned DiagID = 0;\npublic:\n  struct NullDiagnostic {};\n\n  /// Create a null partial diagnostic, which cannot carry a payload,\n  /// and only exists to be swapped with a real partial diagnostic.\n  PartialDiagnostic(NullDiagnostic) {}\n\n  PartialDiagnostic(unsigned DiagID, DiagStorageAllocator &Allocator_)\n      : StreamingDiagnostic(Allocator_), DiagID(DiagID) {}\n\n  PartialDiagnostic(const PartialDiagnostic &Other)\n      : StreamingDiagnostic(), DiagID(Other.DiagID) {\n    Allocator = Other.Allocator;\n    if (Other.DiagStorage) {\n      DiagStorage = getStorage();\n      *DiagStorage = *Other.DiagStorage;\n    }\n  }\n\n  template <typename T> const PartialDiagnostic &operator<<(const T &V) const {\n    const StreamingDiagnostic &DB = *this;\n    DB << V;\n    return *this;\n  }\n\n  // It is necessary to limit this to rvalue reference to avoid calling this\n  // function with a bitfield lvalue argument since non-const reference to\n  // bitfield is not allowed.\n  template <typename T, typename = typename std::enable_if<\n                            !std::is_lvalue_reference<T>::value>::type>\n  const PartialDiagnostic &operator<<(T &&V) const {\n    const StreamingDiagnostic &DB = *this;\n    DB << std::move(V);\n    return *this;\n  }\n\n  PartialDiagnostic(PartialDiagnostic &&Other) : DiagID(Other.DiagID) {\n    Allocator = Other.Allocator;\n    DiagStorage = Other.DiagStorage;\n    Other.DiagStorage = nullptr;\n  }\n\n  PartialDiagnostic(const PartialDiagnostic &Other,\n                    DiagnosticStorage *DiagStorage_)\n      : DiagID(Other.DiagID) {\n    Allocator = reinterpret_cast<DiagStorageAllocator *>(~uintptr_t(0));\n    DiagStorage = DiagStorage_;\n    if (Other.DiagStorage)\n      *this->DiagStorage = *Other.DiagStorage;\n  }\n\n  PartialDiagnostic(const Diagnostic &Other, DiagStorageAllocator &Allocator_)\n      : DiagID(Other.getID()) {\n    Allocator = &Allocator_;\n    // Copy arguments.\n    for (unsigned I = 0, N = Other.getNumArgs(); I != N; ++I) {\n      if (Other.getArgKind(I) == DiagnosticsEngine::ak_std_string)\n        AddString(Other.getArgStdStr(I));\n      else\n        AddTaggedVal(Other.getRawArg(I), Other.getArgKind(I));\n    }\n\n    // Copy source ranges.\n    for (unsigned I = 0, N = Other.getNumRanges(); I != N; ++I)\n      AddSourceRange(Other.getRange(I));\n\n    // Copy fix-its.\n    for (unsigned I = 0, N = Other.getNumFixItHints(); I != N; ++I)\n      AddFixItHint(Other.getFixItHint(I));\n  }\n\n  PartialDiagnostic &operator=(const PartialDiagnostic &Other) {\n    DiagID = Other.DiagID;\n    if (Other.DiagStorage) {\n      if (!DiagStorage)\n        DiagStorage = getStorage();\n\n      *DiagStorage = *Other.DiagStorage;\n    } else {\n      freeStorage();\n    }\n\n    return *this;\n  }\n\n  PartialDiagnostic &operator=(PartialDiagnostic &&Other) {\n    freeStorage();\n\n    DiagID = Other.DiagID;\n    DiagStorage = Other.DiagStorage;\n    Allocator = Other.Allocator;\n\n    Other.DiagStorage = nullptr;\n    return *this;\n  }\n\n  void swap(PartialDiagnostic &PD) {\n    std::swap(DiagID, PD.DiagID);\n    std::swap(DiagStorage, PD.DiagStorage);\n    std::swap(Allocator, PD.Allocator);\n  }\n\n  unsigned getDiagID() const { return DiagID; }\n  void setDiagID(unsigned ID) { DiagID = ID; }\n\n  void Emit(const DiagnosticBuilder &DB) const {\n    if (!DiagStorage)\n      return;\n\n    // Add all arguments.\n    for (unsigned i = 0, e = DiagStorage->NumDiagArgs; i != e; ++i) {\n      if ((DiagnosticsEngine::ArgumentKind)DiagStorage->DiagArgumentsKind[i]\n            == DiagnosticsEngine::ak_std_string)\n        DB.AddString(DiagStorage->DiagArgumentsStr[i]);\n      else\n        DB.AddTaggedVal(DiagStorage->DiagArgumentsVal[i],\n            (DiagnosticsEngine::ArgumentKind)DiagStorage->DiagArgumentsKind[i]);\n    }\n\n    // Add all ranges.\n    for (const CharSourceRange &Range : DiagStorage->DiagRanges)\n      DB.AddSourceRange(Range);\n\n    // Add all fix-its.\n    for (const FixItHint &Fix : DiagStorage->FixItHints)\n      DB.AddFixItHint(Fix);\n  }\n\n  void EmitToString(DiagnosticsEngine &Diags,\n                    SmallVectorImpl<char> &Buf) const {\n    // FIXME: It should be possible to render a diagnostic to a string without\n    //        messing with the state of the diagnostics engine.\n    DiagnosticBuilder DB(Diags.Report(getDiagID()));\n    Emit(DB);\n    Diagnostic(&Diags).FormatDiagnostic(Buf);\n    DB.Clear();\n    Diags.Clear();\n  }\n\n  /// Clear out this partial diagnostic, giving it a new diagnostic ID\n  /// and removing all of its arguments, ranges, and fix-it hints.\n  void Reset(unsigned DiagID = 0) {\n    this->DiagID = DiagID;\n    freeStorage();\n  }\n\n  bool hasStorage() const { return DiagStorage != nullptr; }\n\n  /// Retrieve the string argument at the given index.\n  StringRef getStringArg(unsigned I) {\n    assert(DiagStorage && \"No diagnostic storage?\");\n    assert(I < DiagStorage->NumDiagArgs && \"Not enough diagnostic args\");\n    assert(DiagStorage->DiagArgumentsKind[I]\n             == DiagnosticsEngine::ak_std_string && \"Not a string arg\");\n    return DiagStorage->DiagArgumentsStr[I];\n  }\n};\n\ninline const DiagnosticBuilder &operator<<(const DiagnosticBuilder &DB,\n                                           const PartialDiagnostic &PD) {\n  PD.Emit(DB);\n  return DB;\n}\n\n/// A partial diagnostic along with the source location where this\n/// diagnostic occurs.\nusing PartialDiagnosticAt = std::pair<SourceLocation, PartialDiagnostic>;\n\n} // namespace clang\n\n#endif // LLVM_CLANG_BASIC_PARTIALDIAGNOSTIC_H\n"}, "32": {"id": 32, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Sanitizers.h", "content": "//===- Sanitizers.h - C Language Family Language Options --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the clang::SanitizerKind enum.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_SANITIZERS_H\n#define LLVM_CLANG_BASIC_SANITIZERS_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Transforms/Instrumentation/AddressSanitizerOptions.h\"\n#include <cassert>\n#include <cstdint>\n\nnamespace llvm {\nclass hash_code;\n}\n\nnamespace clang {\n\nclass SanitizerMask {\n  // NOTE: this class assumes kNumElem == 2 in most of the constexpr functions,\n  // in order to work within the C++11 constexpr function constraints. If you\n  // change kNumElem, you'll need to update those member functions as well.\n\n  /// Number of array elements.\n  static constexpr unsigned kNumElem = 2;\n  /// Mask value initialized to 0.\n  uint64_t maskLoToHigh[kNumElem]{};\n  /// Number of bits in a mask.\n  static constexpr unsigned kNumBits = sizeof(decltype(maskLoToHigh)) * 8;\n  /// Number of bits in a mask element.\n  static constexpr unsigned kNumBitElem = sizeof(decltype(maskLoToHigh[0])) * 8;\n\n  constexpr SanitizerMask(uint64_t mask1, uint64_t mask2)\n      : maskLoToHigh{mask1, mask2} {}\n\npublic:\n  SanitizerMask() = default;\n\n  static constexpr bool checkBitPos(const unsigned Pos) {\n    return Pos < kNumBits;\n  }\n\n  /// Create a mask with a bit enabled at position Pos.\n  static constexpr SanitizerMask bitPosToMask(const unsigned Pos) {\n    uint64_t mask1 = (Pos < kNumBitElem) ? 1ULL << (Pos % kNumBitElem) : 0;\n    uint64_t mask2 = (Pos >= kNumBitElem && Pos < (kNumBitElem * 2))\n                         ? 1ULL << (Pos % kNumBitElem)\n                         : 0;\n    return SanitizerMask(mask1, mask2);\n  }\n\n  unsigned countPopulation() const {\n    unsigned total = 0;\n    for (const auto &Val : maskLoToHigh)\n      total += llvm::countPopulation(Val);\n    return total;\n  }\n\n  void flipAllBits() {\n    for (auto &Val : maskLoToHigh)\n      Val = ~Val;\n  }\n\n  bool isPowerOf2() const {\n    return countPopulation() == 1;\n  }\n\n  llvm::hash_code hash_value() const;\n\n  constexpr explicit operator bool() const {\n    return maskLoToHigh[0] || maskLoToHigh[1];\n  }\n\n  constexpr bool operator==(const SanitizerMask &V) const {\n    return maskLoToHigh[0] == V.maskLoToHigh[0] &&\n           maskLoToHigh[1] == V.maskLoToHigh[1];\n  }\n\n  SanitizerMask &operator&=(const SanitizerMask &RHS) {\n    for (unsigned k = 0; k < kNumElem; k++)\n      maskLoToHigh[k] &= RHS.maskLoToHigh[k];\n    return *this;\n  }\n\n  SanitizerMask &operator|=(const SanitizerMask &RHS) {\n    for (unsigned k = 0; k < kNumElem; k++)\n      maskLoToHigh[k] |= RHS.maskLoToHigh[k];\n    return *this;\n  }\n\n  constexpr bool operator!() const { return !bool(*this); }\n\n  constexpr bool operator!=(const SanitizerMask &RHS) const {\n    return !((*this) == RHS);\n  }\n\n  friend constexpr inline SanitizerMask operator~(SanitizerMask v) {\n    return SanitizerMask(~v.maskLoToHigh[0], ~v.maskLoToHigh[1]);\n  }\n\n  friend constexpr inline SanitizerMask operator&(SanitizerMask a,\n                                                  const SanitizerMask &b) {\n    return SanitizerMask(a.maskLoToHigh[0] & b.maskLoToHigh[0],\n                         a.maskLoToHigh[1] & b.maskLoToHigh[1]);\n  }\n\n  friend constexpr inline SanitizerMask operator|(SanitizerMask a,\n                                                  const SanitizerMask &b) {\n    return SanitizerMask(a.maskLoToHigh[0] | b.maskLoToHigh[0],\n                         a.maskLoToHigh[1] | b.maskLoToHigh[1]);\n  }\n};\n\n// Declaring in clang namespace so that it can be found by ADL.\nllvm::hash_code hash_value(const clang::SanitizerMask &Arg);\n\n// Define the set of sanitizer kinds, as well as the set of sanitizers each\n// sanitizer group expands into.\nstruct SanitizerKind {\n  // Assign ordinals to possible values of -fsanitize= flag, which we will use\n  // as bit positions.\n  enum SanitizerOrdinal : uint64_t {\n#define SANITIZER(NAME, ID) SO_##ID,\n#define SANITIZER_GROUP(NAME, ID, ALIAS) SO_##ID##Group,\n#include \"clang/Basic/Sanitizers.def\"\n    SO_Count\n  };\n\n#define SANITIZER(NAME, ID)                                                    \\\n  static constexpr SanitizerMask ID = SanitizerMask::bitPosToMask(SO_##ID);    \\\n  static_assert(SanitizerMask::checkBitPos(SO_##ID), \"Bit position too big.\");\n#define SANITIZER_GROUP(NAME, ID, ALIAS)                                       \\\n  static constexpr SanitizerMask ID = SanitizerMask(ALIAS);                    \\\n  static constexpr SanitizerMask ID##Group =                                   \\\n      SanitizerMask::bitPosToMask(SO_##ID##Group);                             \\\n  static_assert(SanitizerMask::checkBitPos(SO_##ID##Group),                    \\\n                \"Bit position too big.\");\n#include \"clang/Basic/Sanitizers.def\"\n}; // SanitizerKind\n\nstruct SanitizerSet {\n  /// Check if a certain (single) sanitizer is enabled.\n  bool has(SanitizerMask K) const {\n    assert(K.isPowerOf2() && \"Has to be a single sanitizer.\");\n    return static_cast<bool>(Mask & K);\n  }\n\n  /// Check if one or more sanitizers are enabled.\n  bool hasOneOf(SanitizerMask K) const { return static_cast<bool>(Mask & K); }\n\n  /// Enable or disable a certain (single) sanitizer.\n  void set(SanitizerMask K, bool Value) {\n    assert(K.isPowerOf2() && \"Has to be a single sanitizer.\");\n    Mask = Value ? (Mask | K) : (Mask & ~K);\n  }\n\n  /// Disable the sanitizers specified in \\p K.\n  void clear(SanitizerMask K = SanitizerKind::All) { Mask &= ~K; }\n\n  /// Returns true if no sanitizers are enabled.\n  bool empty() const { return !Mask; }\n\n  /// Bitmask of enabled sanitizers.\n  SanitizerMask Mask;\n};\n\n/// Parse a single value from a -fsanitize= or -fno-sanitize= value list.\n/// Returns a non-zero SanitizerMask, or \\c 0 if \\p Value is not known.\nSanitizerMask parseSanitizerValue(StringRef Value, bool AllowGroups);\n\n/// Serialize a SanitizerSet into values for -fsanitize= or -fno-sanitize=.\nvoid serializeSanitizerSet(SanitizerSet Set,\n                           SmallVectorImpl<StringRef> &Values);\n\n/// For each sanitizer group bit set in \\p Kinds, set the bits for sanitizers\n/// this group enables.\nSanitizerMask expandSanitizerGroups(SanitizerMask Kinds);\n\n/// Return the sanitizers which do not affect preprocessing.\ninline SanitizerMask getPPTransparentSanitizers() {\n  return SanitizerKind::CFI | SanitizerKind::Integer |\n         SanitizerKind::ImplicitConversion | SanitizerKind::Nullability |\n         SanitizerKind::Undefined | SanitizerKind::FloatDivideByZero;\n}\n\nStringRef AsanDtorKindToString(llvm::AsanDtorKind kind);\n\nllvm::AsanDtorKind AsanDtorKindFromString(StringRef kind);\n\n} // namespace clang\n\n#endif // LLVM_CLANG_BASIC_SANITIZERS_H\n"}, "33": {"id": 33, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SyncScope.h", "content": "//===--- SyncScope.h - Atomic synchronization scopes ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Provides definitions for the atomic synchronization scopes.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_SYNCSCOPE_H\n#define LLVM_CLANG_BASIC_SYNCSCOPE_H\n\n#include \"clang/Basic/LangOptions.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <memory>\n\nnamespace clang {\n\n/// Defines synch scope values used internally by clang.\n///\n/// The enum values start from 0 and are contiguous. They are mainly used for\n/// enumerating all supported synch scope values and mapping them to LLVM\n/// synch scopes. Their numerical values may be different from the corresponding\n/// synch scope enums used in source languages.\n///\n/// In atomic builtin and expressions, language-specific synch scope enums are\n/// used. Currently only OpenCL memory scope enums are supported and assumed\n/// to be used by all languages. However, in the future, other languages may\n/// define their own set of synch scope enums. The language-specific synch scope\n/// values are represented by class AtomicScopeModel and its derived classes.\n///\n/// To add a new enum value:\n///   Add the enum value to enum class SyncScope.\n///   Update enum value Last if necessary.\n///   Update getAsString.\n///\nenum class SyncScope {\n  OpenCLWorkGroup,\n  OpenCLDevice,\n  OpenCLAllSVMDevices,\n  OpenCLSubGroup,\n  Last = OpenCLSubGroup\n};\n\ninline llvm::StringRef getAsString(SyncScope S) {\n  switch (S) {\n  case SyncScope::OpenCLWorkGroup:\n    return \"opencl_workgroup\";\n  case SyncScope::OpenCLDevice:\n    return \"opencl_device\";\n  case SyncScope::OpenCLAllSVMDevices:\n    return \"opencl_allsvmdevices\";\n  case SyncScope::OpenCLSubGroup:\n    return \"opencl_subgroup\";\n  }\n  llvm_unreachable(\"Invalid synch scope\");\n}\n\n/// Defines the kind of atomic scope models.\nenum class AtomicScopeModelKind { None, OpenCL };\n\n/// Defines the interface for synch scope model.\nclass AtomicScopeModel {\npublic:\n  virtual ~AtomicScopeModel() {}\n  /// Maps language specific synch scope values to internal\n  /// SyncScope enum.\n  virtual SyncScope map(unsigned S) const = 0;\n\n  /// Check if the compile-time constant synch scope value\n  /// is valid.\n  virtual bool isValid(unsigned S) const = 0;\n\n  /// Get all possible synch scope values that might be\n  /// encountered at runtime for the current language.\n  virtual ArrayRef<unsigned> getRuntimeValues() const = 0;\n\n  /// If atomic builtin function is called with invalid\n  /// synch scope value at runtime, it will fall back to a valid\n  /// synch scope value returned by this function.\n  virtual unsigned getFallBackValue() const = 0;\n\n  /// Create an atomic scope model by AtomicScopeModelKind.\n  /// \\return an empty std::unique_ptr for AtomicScopeModelKind::None.\n  static std::unique_ptr<AtomicScopeModel> create(AtomicScopeModelKind K);\n};\n\n/// Defines the synch scope model for OpenCL.\nclass AtomicScopeOpenCLModel : public AtomicScopeModel {\npublic:\n  /// The enum values match the pre-defined macros\n  /// __OPENCL_MEMORY_SCOPE_*, which are used to define memory_scope_*\n  /// enums in opencl-c-base.h.\n  enum ID {\n    WorkGroup = 1,\n    Device = 2,\n    AllSVMDevices = 3,\n    SubGroup = 4,\n    Last = SubGroup\n  };\n\n  AtomicScopeOpenCLModel() {}\n\n  SyncScope map(unsigned S) const override {\n    switch (static_cast<ID>(S)) {\n    case WorkGroup:\n      return SyncScope::OpenCLWorkGroup;\n    case Device:\n      return SyncScope::OpenCLDevice;\n    case AllSVMDevices:\n      return SyncScope::OpenCLAllSVMDevices;\n    case SubGroup:\n      return SyncScope::OpenCLSubGroup;\n    }\n    llvm_unreachable(\"Invalid language synch scope value\");\n  }\n\n  bool isValid(unsigned S) const override {\n    return S >= static_cast<unsigned>(WorkGroup) &&\n           S <= static_cast<unsigned>(Last);\n  }\n\n  ArrayRef<unsigned> getRuntimeValues() const override {\n    static_assert(Last == SubGroup, \"Does not include all synch scopes\");\n    static const unsigned Scopes[] = {\n        static_cast<unsigned>(WorkGroup), static_cast<unsigned>(Device),\n        static_cast<unsigned>(AllSVMDevices), static_cast<unsigned>(SubGroup)};\n    return llvm::makeArrayRef(Scopes);\n  }\n\n  unsigned getFallBackValue() const override {\n    return static_cast<unsigned>(AllSVMDevices);\n  }\n};\n\ninline std::unique_ptr<AtomicScopeModel>\nAtomicScopeModel::create(AtomicScopeModelKind K) {\n  switch (K) {\n  case AtomicScopeModelKind::None:\n    return std::unique_ptr<AtomicScopeModel>{};\n  case AtomicScopeModelKind::OpenCL:\n    return std::make_unique<AtomicScopeOpenCLModel>();\n  }\n  llvm_unreachable(\"Invalid atomic scope model kind\");\n}\n}\n\n#endif\n"}, "34": {"id": 34, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ConstraintManager.h", "content": "//===- ConstraintManager.h - Constraints on symbolic values. ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defined the interface to manage constraints on symbolic values.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_CONSTRAINTMANAGER_H\n#define LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_CONSTRAINTMANAGER_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState_Fwd.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SVals.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/Support/SaveAndRestore.h\"\n#include <memory>\n#include <utility>\n\nnamespace llvm {\n\nclass APSInt;\n\n} // namespace llvm\n\nnamespace clang {\nnamespace ento {\n\nclass ProgramStateManager;\nclass ExprEngine;\nclass SymbolReaper;\n\nclass ConditionTruthVal {\n  Optional<bool> Val;\n\npublic:\n  /// Construct a ConditionTruthVal indicating the constraint is constrained\n  /// to either true or false, depending on the boolean value provided.\n  ConditionTruthVal(bool constraint) : Val(constraint) {}\n\n  /// Construct a ConstraintVal indicating the constraint is underconstrained.\n  ConditionTruthVal() = default;\n\n  /// \\return Stored value, assuming that the value is known.\n  /// Crashes otherwise.\n  bool getValue() const {\n    return *Val;\n  }\n\n  /// Return true if the constraint is perfectly constrained to 'true'.\n  bool isConstrainedTrue() const {\n    return Val.hasValue() && Val.getValue();\n  }\n\n  /// Return true if the constraint is perfectly constrained to 'false'.\n  bool isConstrainedFalse() const {\n    return Val.hasValue() && !Val.getValue();\n  }\n\n  /// Return true if the constrained is perfectly constrained.\n  bool isConstrained() const {\n    return Val.hasValue();\n  }\n\n  /// Return true if the constrained is underconstrained and we do not know\n  /// if the constraint is true of value.\n  bool isUnderconstrained() const {\n    return !Val.hasValue();\n  }\n};\n\nclass ConstraintManager {\npublic:\n  ConstraintManager() = default;\n  virtual ~ConstraintManager();\n\n  virtual bool haveEqualConstraints(ProgramStateRef S1,\n                                    ProgramStateRef S2) const = 0;\n\n  virtual ProgramStateRef assume(ProgramStateRef state,\n                                 DefinedSVal Cond,\n                                 bool Assumption) = 0;\n\n  using ProgramStatePair = std::pair<ProgramStateRef, ProgramStateRef>;\n\n  /// Returns a pair of states (StTrue, StFalse) where the given condition is\n  /// assumed to be true or false, respectively.\n  ProgramStatePair assumeDual(ProgramStateRef State, DefinedSVal Cond) {\n    ProgramStateRef StTrue = assume(State, Cond, true);\n\n    // If StTrue is infeasible, asserting the falseness of Cond is unnecessary\n    // because the existing constraints already establish this.\n    if (!StTrue) {\n#ifdef EXPENSIVE_CHECKS\n      assert(assume(State, Cond, false) && \"System is over constrained.\");\n#endif\n      return ProgramStatePair((ProgramStateRef)nullptr, State);\n    }\n\n    ProgramStateRef StFalse = assume(State, Cond, false);\n    if (!StFalse) {\n      // We are careful to return the original state, /not/ StTrue,\n      // because we want to avoid having callers generate a new node\n      // in the ExplodedGraph.\n      return ProgramStatePair(State, (ProgramStateRef)nullptr);\n    }\n\n    return ProgramStatePair(StTrue, StFalse);\n  }\n\n  virtual ProgramStateRef assumeInclusiveRange(ProgramStateRef State,\n                                               NonLoc Value,\n                                               const llvm::APSInt &From,\n                                               const llvm::APSInt &To,\n                                               bool InBound) = 0;\n\n  virtual ProgramStatePair assumeInclusiveRangeDual(ProgramStateRef State,\n                                                    NonLoc Value,\n                                                    const llvm::APSInt &From,\n                                                    const llvm::APSInt &To) {\n    ProgramStateRef StInRange =\n        assumeInclusiveRange(State, Value, From, To, true);\n\n    // If StTrue is infeasible, asserting the falseness of Cond is unnecessary\n    // because the existing constraints already establish this.\n    if (!StInRange)\n      return ProgramStatePair((ProgramStateRef)nullptr, State);\n\n    ProgramStateRef StOutOfRange =\n        assumeInclusiveRange(State, Value, From, To, false);\n    if (!StOutOfRange) {\n      // We are careful to return the original state, /not/ StTrue,\n      // because we want to avoid having callers generate a new node\n      // in the ExplodedGraph.\n      return ProgramStatePair(State, (ProgramStateRef)nullptr);\n    }\n\n    return ProgramStatePair(StInRange, StOutOfRange);\n  }\n\n  /// If a symbol is perfectly constrained to a constant, attempt\n  /// to return the concrete value.\n  ///\n  /// Note that a ConstraintManager is not obligated to return a concretized\n  /// value for a symbol, even if it is perfectly constrained.\n  virtual const llvm::APSInt* getSymVal(ProgramStateRef state,\n                                        SymbolRef sym) const {\n    return nullptr;\n  }\n\n  /// Scan all symbols referenced by the constraints. If the symbol is not\n  /// alive, remove it.\n  virtual ProgramStateRef removeDeadBindings(ProgramStateRef state,\n                                                 SymbolReaper& SymReaper) = 0;\n\n  virtual void printJson(raw_ostream &Out, ProgramStateRef State,\n                         const char *NL, unsigned int Space,\n                         bool IsDot) const = 0;\n\n  /// Convenience method to query the state to see if a symbol is null or\n  /// not null, or if neither assumption can be made.\n  ConditionTruthVal isNull(ProgramStateRef State, SymbolRef Sym) {\n    SaveAndRestore<bool> DisableNotify(NotifyAssumeClients, false);\n\n    return checkNull(State, Sym);\n  }\n\nprotected:\n  /// A flag to indicate that clients should be notified of assumptions.\n  /// By default this is the case, but sometimes this needs to be restricted\n  /// to avoid infinite recursions within the ConstraintManager.\n  ///\n  /// Note that this flag allows the ConstraintManager to be re-entrant,\n  /// but not thread-safe.\n  bool NotifyAssumeClients = true;\n\n  /// canReasonAbout - Not all ConstraintManagers can accurately reason about\n  ///  all SVal values.  This method returns true if the ConstraintManager can\n  ///  reasonably handle a given SVal value.  This is typically queried by\n  ///  ExprEngine to determine if the value should be replaced with a\n  ///  conjured symbolic value in order to recover some precision.\n  virtual bool canReasonAbout(SVal X) const = 0;\n\n  /// Returns whether or not a symbol is known to be null (\"true\"), known to be\n  /// non-null (\"false\"), or may be either (\"underconstrained\").\n  virtual ConditionTruthVal checkNull(ProgramStateRef State, SymbolRef Sym);\n};\n\nstd::unique_ptr<ConstraintManager>\nCreateRangeConstraintManager(ProgramStateManager &statemgr,\n                             ExprEngine *exprengine);\n\nstd::unique_ptr<ConstraintManager>\nCreateZ3ConstraintManager(ProgramStateManager &statemgr,\n                          ExprEngine *exprengine);\n\n} // namespace ento\n} // namespace clang\n\n#endif // LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_CONSTRAINTMANAGER_H\n"}, "35": {"id": 35, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SVals.h", "content": "//===- SVals.h - Abstract Values for Static Analysis ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines SVal, Loc, and NonLoc, classes that represent\n//  abstract r-values for use with path-sensitive value tracking.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_SVALS_H\n#define LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_SVALS_H\n\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/ImmutableList.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/Support/Casting.h\"\n#include <cassert>\n#include <cstdint>\n#include <utility>\n\n//==------------------------------------------------------------------------==//\n//  Base SVal types.\n//==------------------------------------------------------------------------==//\n\nnamespace clang {\n\nclass CXXBaseSpecifier;\nclass DeclaratorDecl;\nclass FunctionDecl;\nclass LabelDecl;\n\nnamespace ento {\n\nclass BasicValueFactory;\nclass CompoundValData;\nclass LazyCompoundValData;\nclass MemRegion;\nclass PointerToMemberData;\nclass SValBuilder;\nclass TypedValueRegion;\n\nnamespace nonloc {\n\n/// Sub-kinds for NonLoc values.\nenum Kind {\n#define NONLOC_SVAL(Id, Parent) Id ## Kind,\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SVals.def\"\n};\n\n} // namespace nonloc\n\nnamespace loc {\n\n/// Sub-kinds for Loc values.\nenum Kind {\n#define LOC_SVAL(Id, Parent) Id ## Kind,\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SVals.def\"\n};\n\n} // namespace loc\n\n/// SVal - This represents a symbolic expression, which can be either\n///  an L-value or an R-value.\n///\nclass SVal {\npublic:\n  enum BaseKind {\n    // The enumerators must be representable using 2 bits.\n#define BASIC_SVAL(Id, Parent) Id ## Kind,\n#define ABSTRACT_SVAL_WITH_KIND(Id, Parent) Id ## Kind,\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SVals.def\"\n  };\n  enum { BaseBits = 2, BaseMask = 0b11 };\n\nprotected:\n  const void *Data = nullptr;\n\n  /// The lowest 2 bits are a BaseKind (0 -- 3).\n  ///  The higher bits are an unsigned \"kind\" value.\n  unsigned Kind = 0;\n\n  explicit SVal(const void *d, bool isLoc, unsigned ValKind)\n      : Data(d), Kind((isLoc ? LocKind : NonLocKind) | (ValKind << BaseBits)) {}\n\n  explicit SVal(BaseKind k, const void *D = nullptr) : Data(D), Kind(k) {}\n\npublic:\n  explicit SVal() = default;\n\n  /// Convert to the specified SVal type, asserting that this SVal is of\n  /// the desired type.\n  template<typename T>\n  T castAs() const {\n    assert(T::isKind(*this));\n    return *static_cast<const T *>(this);\n  }\n\n  /// Convert to the specified SVal type, returning None if this SVal is\n  /// not of the desired type.\n  template<typename T>\n  Optional<T> getAs() const {\n    if (!T::isKind(*this))\n      return None;\n    return *static_cast<const T *>(this);\n  }\n\n  unsigned getRawKind() const { return Kind; }\n  BaseKind getBaseKind() const { return (BaseKind) (Kind & BaseMask); }\n  unsigned getSubKind() const { return Kind >> BaseBits; }\n\n  // This method is required for using SVal in a FoldingSetNode.  It\n  // extracts a unique signature for this SVal object.\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    ID.AddInteger((unsigned) getRawKind());\n    ID.AddPointer(Data);\n  }\n\n  bool operator==(const SVal &R) const {\n    return getRawKind() == R.getRawKind() && Data == R.Data;\n  }\n\n  bool operator!=(const SVal &R) const {\n    return !(*this == R);\n  }\n\n  bool isUnknown() const {\n    return getRawKind() == UnknownValKind;\n  }\n\n  bool isUndef() const {\n    return getRawKind() == UndefinedValKind;\n  }\n\n  bool isUnknownOrUndef() const {\n    return getRawKind() <= UnknownValKind;\n  }\n\n  bool isValid() const {\n    return getRawKind() > UnknownValKind;\n  }\n\n  bool isConstant() const;\n\n  bool isConstant(int I) const;\n\n  bool isZeroConstant() const;\n\n  /// hasConjuredSymbol - If this SVal wraps a conjured symbol, return true;\n  bool hasConjuredSymbol() const;\n\n  /// getAsFunctionDecl - If this SVal is a MemRegionVal and wraps a\n  /// CodeTextRegion wrapping a FunctionDecl, return that FunctionDecl.\n  /// Otherwise return 0.\n  const FunctionDecl *getAsFunctionDecl() const;\n\n  /// If this SVal is a location and wraps a symbol, return that\n  ///  SymbolRef. Otherwise return 0.\n  ///\n  /// Casts are ignored during lookup.\n  /// \\param IncludeBaseRegions The boolean that controls whether the search\n  /// should continue to the base regions if the region is not symbolic.\n  SymbolRef getAsLocSymbol(bool IncludeBaseRegions = false) const;\n\n  /// Get the symbol in the SVal or its base region.\n  SymbolRef getLocSymbolInBase() const;\n\n  /// If this SVal wraps a symbol return that SymbolRef.\n  /// Otherwise, return 0.\n  ///\n  /// Casts are ignored during lookup.\n  /// \\param IncludeBaseRegions The boolean that controls whether the search\n  /// should continue to the base regions if the region is not symbolic.\n  SymbolRef getAsSymbol(bool IncludeBaseRegions = false) const;\n\n  const MemRegion *getAsRegion() const;\n\n  /// printJson - Pretty-prints in JSON format.\n  void printJson(raw_ostream &Out, bool AddQuotes) const;\n\n  void dumpToStream(raw_ostream &OS) const;\n  void dump() const;\n\n  SymExpr::symbol_iterator symbol_begin() const {\n    const SymExpr *SE = getAsSymbol(/*IncludeBaseRegions=*/true);\n    if (SE)\n      return SE->symbol_begin();\n    else\n      return SymExpr::symbol_iterator();\n  }\n\n  SymExpr::symbol_iterator symbol_end() const {\n    return SymExpr::symbol_end();\n  }\n};\n\ninline raw_ostream &operator<<(raw_ostream &os, clang::ento::SVal V) {\n  V.dumpToStream(os);\n  return os;\n}\n\nclass UndefinedVal : public SVal {\npublic:\n  UndefinedVal() : SVal(UndefinedValKind) {}\n\nprivate:\n  friend class SVal;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == UndefinedValKind;\n  }\n};\n\nclass DefinedOrUnknownSVal : public SVal {\npublic:\n  // We want calling these methods to be a compiler error since they are\n  // tautologically false.\n  bool isUndef() const = delete;\n  bool isValid() const = delete;\n\nprotected:\n  DefinedOrUnknownSVal() = default;\n  explicit DefinedOrUnknownSVal(const void *d, bool isLoc, unsigned ValKind)\n      : SVal(d, isLoc, ValKind) {}\n  explicit DefinedOrUnknownSVal(BaseKind k, void *D = nullptr) : SVal(k, D) {}\n\nprivate:\n  friend class SVal;\n\n  static bool isKind(const SVal& V) {\n    return !V.isUndef();\n  }\n};\n\nclass UnknownVal : public DefinedOrUnknownSVal {\npublic:\n  explicit UnknownVal() : DefinedOrUnknownSVal(UnknownValKind) {}\n\nprivate:\n  friend class SVal;\n\n  static bool isKind(const SVal &V) {\n    return V.getBaseKind() == UnknownValKind;\n  }\n};\n\nclass DefinedSVal : public DefinedOrUnknownSVal {\npublic:\n  // We want calling these methods to be a compiler error since they are\n  // tautologically true/false.\n  bool isUnknown() const = delete;\n  bool isUnknownOrUndef() const = delete;\n  bool isValid() const = delete;\n\nprotected:\n  DefinedSVal() = default;\n  explicit DefinedSVal(const void *d, bool isLoc, unsigned ValKind)\n      : DefinedOrUnknownSVal(d, isLoc, ValKind) {}\n\nprivate:\n  friend class SVal;\n\n  static bool isKind(const SVal& V) {\n    return !V.isUnknownOrUndef();\n  }\n};\n\n/// Represents an SVal that is guaranteed to not be UnknownVal.\nclass KnownSVal : public SVal {\n  friend class SVal;\n\n  KnownSVal() = default;\n\n  static bool isKind(const SVal &V) {\n    return !V.isUnknown();\n  }\n\npublic:\n  KnownSVal(const DefinedSVal &V) : SVal(V) {}\n  KnownSVal(const UndefinedVal &V) : SVal(V) {}\n};\n\nclass NonLoc : public DefinedSVal {\nprotected:\n  NonLoc() = default;\n  explicit NonLoc(unsigned SubKind, const void *d)\n      : DefinedSVal(d, false, SubKind) {}\n\npublic:\n  void dumpToStream(raw_ostream &Out) const;\n\n  static bool isCompoundType(QualType T) {\n    return T->isArrayType() || T->isRecordType() ||\n           T->isAnyComplexType() || T->isVectorType();\n  }\n\nprivate:\n  friend class SVal;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == NonLocKind;\n  }\n};\n\nclass Loc : public DefinedSVal {\nprotected:\n  Loc() = default;\n  explicit Loc(unsigned SubKind, const void *D)\n      : DefinedSVal(const_cast<void *>(D), true, SubKind) {}\n\npublic:\n  void dumpToStream(raw_ostream &Out) const;\n\n  static bool isLocType(QualType T) {\n    return T->isAnyPointerType() || T->isBlockPointerType() ||\n           T->isReferenceType() || T->isNullPtrType();\n  }\n\nprivate:\n  friend class SVal;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == LocKind;\n  }\n};\n\n//==------------------------------------------------------------------------==//\n//  Subclasses of NonLoc.\n//==------------------------------------------------------------------------==//\n\nnamespace nonloc {\n\n/// Represents symbolic expression that isn't a location.\nclass SymbolVal : public NonLoc {\npublic:\n  SymbolVal() = delete;\n  SymbolVal(SymbolRef sym) : NonLoc(SymbolValKind, sym) {\n    assert(sym);\n    assert(!Loc::isLocType(sym->getType()));\n  }\n\n  SymbolRef getSymbol() const {\n    return (const SymExpr *) Data;\n  }\n\n  bool isExpression() const {\n    return !isa<SymbolData>(getSymbol());\n  }\n\nprivate:\n  friend class SVal;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == NonLocKind &&\n           V.getSubKind() == SymbolValKind;\n  }\n\n  static bool isKind(const NonLoc& V) {\n    return V.getSubKind() == SymbolValKind;\n  }\n};\n\n/// Value representing integer constant.\nclass ConcreteInt : public NonLoc {\npublic:\n  explicit ConcreteInt(const llvm::APSInt& V) : NonLoc(ConcreteIntKind, &V) {}\n\n  const llvm::APSInt& getValue() const {\n    return *static_cast<const llvm::APSInt *>(Data);\n  }\n\n  // Transfer functions for binary/unary operations on ConcreteInts.\n  SVal evalBinOp(SValBuilder &svalBuilder, BinaryOperator::Opcode Op,\n                 const ConcreteInt& R) const;\n\n  ConcreteInt evalComplement(SValBuilder &svalBuilder) const;\n\n  ConcreteInt evalMinus(SValBuilder &svalBuilder) const;\n\nprivate:\n  friend class SVal;\n\n  ConcreteInt() = default;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == NonLocKind &&\n           V.getSubKind() == ConcreteIntKind;\n  }\n\n  static bool isKind(const NonLoc& V) {\n    return V.getSubKind() == ConcreteIntKind;\n  }\n};\n\nclass LocAsInteger : public NonLoc {\n  friend class ento::SValBuilder;\n\n  explicit LocAsInteger(const std::pair<SVal, uintptr_t> &data)\n      : NonLoc(LocAsIntegerKind, &data) {\n    // We do not need to represent loc::ConcreteInt as LocAsInteger,\n    // as it'd collapse into a nonloc::ConcreteInt instead.\n    assert(data.first.getBaseKind() == LocKind &&\n           (data.first.getSubKind() == loc::MemRegionValKind ||\n            data.first.getSubKind() == loc::GotoLabelKind));\n  }\n\npublic:\n  Loc getLoc() const {\n    const std::pair<SVal, uintptr_t> *D =\n      static_cast<const std::pair<SVal, uintptr_t> *>(Data);\n    return D->first.castAs<Loc>();\n  }\n\n  Loc getPersistentLoc() const {\n    const std::pair<SVal, uintptr_t> *D =\n      static_cast<const std::pair<SVal, uintptr_t> *>(Data);\n    const SVal& V = D->first;\n    return V.castAs<Loc>();\n  }\n\n  unsigned getNumBits() const {\n    const std::pair<SVal, uintptr_t> *D =\n      static_cast<const std::pair<SVal, uintptr_t> *>(Data);\n    return D->second;\n  }\n\nprivate:\n  friend class SVal;\n\n  LocAsInteger() = default;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == NonLocKind &&\n           V.getSubKind() == LocAsIntegerKind;\n  }\n\n  static bool isKind(const NonLoc& V) {\n    return V.getSubKind() == LocAsIntegerKind;\n  }\n};\n\nclass CompoundVal : public NonLoc {\n  friend class ento::SValBuilder;\n\n  explicit CompoundVal(const CompoundValData* D) : NonLoc(CompoundValKind, D) {}\n\npublic:\n  const CompoundValData* getValue() const {\n    return static_cast<const CompoundValData *>(Data);\n  }\n\n  using iterator = llvm::ImmutableList<SVal>::iterator;\n\n  iterator begin() const;\n  iterator end() const;\n\nprivate:\n  friend class SVal;\n\n  CompoundVal() = default;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == NonLocKind && V.getSubKind() == CompoundValKind;\n  }\n\n  static bool isKind(const NonLoc& V) {\n    return V.getSubKind() == CompoundValKind;\n  }\n};\n\nclass LazyCompoundVal : public NonLoc {\n  friend class ento::SValBuilder;\n\n  explicit LazyCompoundVal(const LazyCompoundValData *D)\n      : NonLoc(LazyCompoundValKind, D) {}\n\npublic:\n  const LazyCompoundValData *getCVData() const {\n    return static_cast<const LazyCompoundValData *>(Data);\n  }\n\n  const void *getStore() const;\n  const TypedValueRegion *getRegion() const;\n\nprivate:\n  friend class SVal;\n\n  LazyCompoundVal() = default;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == NonLocKind &&\n           V.getSubKind() == LazyCompoundValKind;\n  }\n\n  static bool isKind(const NonLoc& V) {\n    return V.getSubKind() == LazyCompoundValKind;\n  }\n};\n\n/// Value representing pointer-to-member.\n///\n/// This value is qualified as NonLoc because neither loading nor storing\n/// operations are applied to it. Instead, the analyzer uses the L-value coming\n/// from pointer-to-member applied to an object.\n/// This SVal is represented by a NamedDecl which can be a member function\n/// pointer or a member data pointer and an optional list of CXXBaseSpecifiers.\n/// This list is required to accumulate the pointer-to-member cast history to\n/// figure out the correct subobject field. In particular, implicit casts grow\n/// this list and explicit casts like static_cast shrink this list.\nclass PointerToMember : public NonLoc {\n  friend class ento::SValBuilder;\n\npublic:\n  using PTMDataType =\n      llvm::PointerUnion<const NamedDecl *, const PointerToMemberData *>;\n\n  const PTMDataType getPTMData() const {\n    return PTMDataType::getFromOpaqueValue(const_cast<void *>(Data));\n  }\n\n  bool isNullMemberPointer() const;\n\n  const NamedDecl *getDecl() const;\n\n  template<typename AdjustedDecl>\n  const AdjustedDecl *getDeclAs() const {\n    return dyn_cast_or_null<AdjustedDecl>(getDecl());\n  }\n\n  using iterator = llvm::ImmutableList<const CXXBaseSpecifier *>::iterator;\n\n  iterator begin() const;\n  iterator end() const;\n\nprivate:\n  friend class SVal;\n\n  PointerToMember() = default;\n  explicit PointerToMember(const PTMDataType D)\n      : NonLoc(PointerToMemberKind, D.getOpaqueValue()) {}\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == NonLocKind &&\n           V.getSubKind() == PointerToMemberKind;\n  }\n\n  static bool isKind(const NonLoc& V) {\n    return V.getSubKind() == PointerToMemberKind;\n  }\n};\n\n} // namespace nonloc\n\n//==------------------------------------------------------------------------==//\n//  Subclasses of Loc.\n//==------------------------------------------------------------------------==//\n\nnamespace loc {\n\nclass GotoLabel : public Loc {\npublic:\n  explicit GotoLabel(const LabelDecl *Label) : Loc(GotoLabelKind, Label) {\n    assert(Label);\n  }\n\n  const LabelDecl *getLabel() const {\n    return static_cast<const LabelDecl *>(Data);\n  }\n\nprivate:\n  friend class SVal;\n\n  GotoLabel() = default;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == LocKind && V.getSubKind() == GotoLabelKind;\n  }\n\n  static bool isKind(const Loc& V) {\n    return V.getSubKind() == GotoLabelKind;\n  }\n};\n\nclass MemRegionVal : public Loc {\npublic:\n  explicit MemRegionVal(const MemRegion* r) : Loc(MemRegionValKind, r) {\n    assert(r);\n  }\n\n  /// Get the underlining region.\n  const MemRegion *getRegion() const {\n    return static_cast<const MemRegion *>(Data);\n  }\n\n  /// Get the underlining region and strip casts.\n  const MemRegion* stripCasts(bool StripBaseCasts = true) const;\n\n  template <typename REGION>\n  const REGION* getRegionAs() const {\n    return dyn_cast<REGION>(getRegion());\n  }\n\n  bool operator==(const MemRegionVal &R) const {\n    return getRegion() == R.getRegion();\n  }\n\n  bool operator!=(const MemRegionVal &R) const {\n    return getRegion() != R.getRegion();\n  }\n\nprivate:\n  friend class SVal;\n\n  MemRegionVal() = default;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == LocKind &&\n           V.getSubKind() == MemRegionValKind;\n  }\n\n  static bool isKind(const Loc& V) {\n    return V.getSubKind() == MemRegionValKind;\n  }\n};\n\nclass ConcreteInt : public Loc {\npublic:\n  explicit ConcreteInt(const llvm::APSInt& V) : Loc(ConcreteIntKind, &V) {}\n\n  const llvm::APSInt &getValue() const {\n    return *static_cast<const llvm::APSInt *>(Data);\n  }\n\n  // Transfer functions for binary/unary operations on ConcreteInts.\n  SVal evalBinOp(BasicValueFactory& BasicVals, BinaryOperator::Opcode Op,\n                 const ConcreteInt& R) const;\n\nprivate:\n  friend class SVal;\n\n  ConcreteInt() = default;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == LocKind &&\n           V.getSubKind() == ConcreteIntKind;\n  }\n\n  static bool isKind(const Loc& V) {\n    return V.getSubKind() == ConcreteIntKind;\n  }\n};\n\n} // namespace loc\n\n} // namespace ento\n\n} // namespace clang\n\n#endif // LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_SVALS_H\n"}, "36": {"id": 36, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h", "content": "//===- APFixedPoint.h - Fixed point constant handling -----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the fixed point number interface.\n/// This is a class for abstracting various operations performed on fixed point\n/// types.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_APFIXEDPOINT_H\n#define LLVM_ADT_APFIXEDPOINT_H\n\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\nnamespace llvm {\n\nclass APFloat;\nstruct fltSemantics;\n\n/// The fixed point semantics work similarly to fltSemantics. The width\n/// specifies the whole bit width of the underlying scaled integer (with padding\n/// if any). The scale represents the number of fractional bits in this type.\n/// When HasUnsignedPadding is true and this type is unsigned, the first bit\n/// in the value this represents is treated as padding.\nclass FixedPointSemantics {\npublic:\n  FixedPointSemantics(unsigned Width, unsigned Scale, bool IsSigned,\n                      bool IsSaturated, bool HasUnsignedPadding)\n      : Width(Width), Scale(Scale), IsSigned(IsSigned),\n        IsSaturated(IsSaturated), HasUnsignedPadding(HasUnsignedPadding) {\n    assert(Width >= Scale && \"Not enough room for the scale\");\n    assert(!(IsSigned && HasUnsignedPadding) &&\n           \"Cannot have unsigned padding on a signed type.\");\n  }\n\n  unsigned getWidth() const { return Width; }\n  unsigned getScale() const { return Scale; }\n  bool isSigned() const { return IsSigned; }\n  bool isSaturated() const { return IsSaturated; }\n  bool hasUnsignedPadding() const { return HasUnsignedPadding; }\n\n  void setSaturated(bool Saturated) { IsSaturated = Saturated; }\n\n  /// Return the number of integral bits represented by these semantics. These\n  /// are separate from the fractional bits and do not include the sign or\n  /// padding bit.\n  unsigned getIntegralBits() const {\n    if (IsSigned || (!IsSigned && HasUnsignedPadding))\n      return Width - Scale - 1;\n    else\n      return Width - Scale;\n  }\n\n  /// Return the FixedPointSemantics that allows for calculating the full\n  /// precision semantic that can precisely represent the precision and ranges\n  /// of both input values. This does not compute the resulting semantics for a\n  /// given binary operation.\n  FixedPointSemantics\n  getCommonSemantics(const FixedPointSemantics &Other) const;\n\n  /// Returns true if this fixed-point semantic with its value bits interpreted\n  /// as an integer can fit in the given floating point semantic without\n  /// overflowing to infinity.\n  /// For example, a signed 8-bit fixed-point semantic has a maximum and\n  /// minimum integer representation of 127 and -128, respectively. If both of\n  /// these values can be represented (possibly inexactly) in the floating\n  /// point semantic without overflowing, this returns true.\n  bool fitsInFloatSemantics(const fltSemantics &FloatSema) const;\n\n  /// Return the FixedPointSemantics for an integer type.\n  static FixedPointSemantics GetIntegerSemantics(unsigned Width,\n                                                 bool IsSigned) {\n    return FixedPointSemantics(Width, /*Scale=*/0, IsSigned,\n                               /*IsSaturated=*/false,\n                               /*HasUnsignedPadding=*/false);\n  }\n\nprivate:\n  unsigned Width          : 16;\n  unsigned Scale          : 13;\n  unsigned IsSigned       : 1;\n  unsigned IsSaturated    : 1;\n  unsigned HasUnsignedPadding : 1;\n};\n\n/// The APFixedPoint class works similarly to APInt/APSInt in that it is a\n/// functional replacement for a scaled integer. It is meant to replicate the\n/// fixed point types proposed in ISO/IEC JTC1 SC22 WG14 N1169. The class carries\n/// info about the fixed point type's width, sign, scale, and saturation, and\n/// provides different operations that would normally be performed on fixed point\n/// types.\nclass APFixedPoint {\npublic:\n  APFixedPoint(const APInt &Val, const FixedPointSemantics &Sema)\n      : Val(Val, !Sema.isSigned()), Sema(Sema) {\n    assert(Val.getBitWidth() == Sema.getWidth() &&\n           \"The value should have a bit width that matches the Sema width\");\n  }\n\n  APFixedPoint(uint64_t Val, const FixedPointSemantics &Sema)\n      : APFixedPoint(APInt(Sema.getWidth(), Val, Sema.isSigned()), Sema) {}\n\n  // Zero initialization.\n  APFixedPoint(const FixedPointSemantics &Sema) : APFixedPoint(0, Sema) {}\n\n  APSInt getValue() const { return APSInt(Val, !Sema.isSigned()); }\n  inline unsigned getWidth() const { return Sema.getWidth(); }\n  inline unsigned getScale() const { return Sema.getScale(); }\n  inline bool isSaturated() const { return Sema.isSaturated(); }\n  inline bool isSigned() const { return Sema.isSigned(); }\n  inline bool hasPadding() const { return Sema.hasUnsignedPadding(); }\n  FixedPointSemantics getSemantics() const { return Sema; }\n\n  bool getBoolValue() const { return Val.getBoolValue(); }\n\n  // Convert this number to match the semantics provided. If the overflow\n  // parameter is provided, set this value to true or false to indicate if this\n  // operation results in an overflow.\n  APFixedPoint convert(const FixedPointSemantics &DstSema,\n                       bool *Overflow = nullptr) const;\n\n  // Perform binary operations on a fixed point type. The resulting fixed point\n  // value will be in the common, full precision semantics that can represent\n  // the precision and ranges of both input values. See convert() for an\n  // explanation of the Overflow parameter.\n  APFixedPoint add(const APFixedPoint &Other, bool *Overflow = nullptr) const;\n  APFixedPoint sub(const APFixedPoint &Other, bool *Overflow = nullptr) const;\n  APFixedPoint mul(const APFixedPoint &Other, bool *Overflow = nullptr) const;\n  APFixedPoint div(const APFixedPoint &Other, bool *Overflow = nullptr) const;\n\n  // Perform shift operations on a fixed point type. Unlike the other binary\n  // operations, the resulting fixed point value will be in the original\n  // semantic.\n  APFixedPoint shl(unsigned Amt, bool *Overflow = nullptr) const;\n  APFixedPoint shr(unsigned Amt, bool *Overflow = nullptr) const {\n    // Right shift cannot overflow.\n    if (Overflow)\n      *Overflow = false;\n    return APFixedPoint(Val >> Amt, Sema);\n  }\n\n  /// Perform a unary negation (-X) on this fixed point type, taking into\n  /// account saturation if applicable.\n  APFixedPoint negate(bool *Overflow = nullptr) const;\n\n  /// Return the integral part of this fixed point number, rounded towards\n  /// zero. (-2.5k -> -2)\n  APSInt getIntPart() const {\n    if (Val < 0 && Val != -Val) // Cover the case when we have the min val\n      return -(-Val >> getScale());\n    else\n      return Val >> getScale();\n  }\n\n  /// Return the integral part of this fixed point number, rounded towards\n  /// zero. The value is stored into an APSInt with the provided width and sign.\n  /// If the overflow parameter is provided, and the integral value is not able\n  /// to be fully stored in the provided width and sign, the overflow parameter\n  /// is set to true.\n  APSInt convertToInt(unsigned DstWidth, bool DstSign,\n                      bool *Overflow = nullptr) const;\n\n  /// Convert this fixed point number to a floating point value with the\n  /// provided semantics.\n  APFloat convertToFloat(const fltSemantics &FloatSema) const;\n\n  void toString(SmallVectorImpl<char> &Str) const;\n  std::string toString() const {\n    SmallString<40> S;\n    toString(S);\n    return std::string(S.str());\n  }\n\n  // If LHS > RHS, return 1. If LHS == RHS, return 0. If LHS < RHS, return -1.\n  int compare(const APFixedPoint &Other) const;\n  bool operator==(const APFixedPoint &Other) const {\n    return compare(Other) == 0;\n  }\n  bool operator!=(const APFixedPoint &Other) const {\n    return compare(Other) != 0;\n  }\n  bool operator>(const APFixedPoint &Other) const { return compare(Other) > 0; }\n  bool operator<(const APFixedPoint &Other) const { return compare(Other) < 0; }\n  bool operator>=(const APFixedPoint &Other) const {\n    return compare(Other) >= 0;\n  }\n  bool operator<=(const APFixedPoint &Other) const {\n    return compare(Other) <= 0;\n  }\n\n  static APFixedPoint getMax(const FixedPointSemantics &Sema);\n  static APFixedPoint getMin(const FixedPointSemantics &Sema);\n\n  /// Given a floating point semantic, return the next floating point semantic\n  /// with a larger exponent and larger or equal mantissa.\n  static const fltSemantics *promoteFloatSemantics(const fltSemantics *S);\n\n  /// Create an APFixedPoint with a value equal to that of the provided integer,\n  /// and in the same semantics as the provided target semantics. If the value\n  /// is not able to fit in the specified fixed point semantics, and the\n  /// overflow parameter is provided, it is set to true.\n  static APFixedPoint getFromIntValue(const APSInt &Value,\n                                      const FixedPointSemantics &DstFXSema,\n                                      bool *Overflow = nullptr);\n\n  /// Create an APFixedPoint with a value equal to that of the provided\n  /// floating point value, in the provided target semantics. If the value is\n  /// not able to fit in the specified fixed point semantics and the overflow\n  /// parameter is specified, it is set to true.\n  /// For NaN, the Overflow flag is always set. For +inf and -inf, if the\n  /// semantic is saturating, the value saturates. Otherwise, the Overflow flag\n  /// is set.\n  static APFixedPoint getFromFloatValue(const APFloat &Value,\n                                        const FixedPointSemantics &DstFXSema,\n                                        bool *Overflow = nullptr);\n\nprivate:\n  APSInt Val;\n  FixedPointSemantics Sema;\n};\n\ninline raw_ostream &operator<<(raw_ostream &OS, const APFixedPoint &FX) {\n  OS << FX.toString();\n  return OS;\n}\n\n} // namespace llvm\n\n#endif\n"}, "37": {"id": 37, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFloat.h", "content": "//===- llvm/ADT/APFloat.h - Arbitrary Precision Floating Point ---*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// \\brief\n/// This file declares a class to represent arbitrary precision floating point\n/// values and provide a variety of arithmetic operations on them.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_APFLOAT_H\n#define LLVM_ADT_APFLOAT_H\n\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/FloatingPointMode.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <memory>\n\n#define APFLOAT_DISPATCH_ON_SEMANTICS(METHOD_CALL)                             \\\n  do {                                                                         \\\n    if (usesLayout<IEEEFloat>(getSemantics()))                                 \\\n      return U.IEEE.METHOD_CALL;                                               \\\n    if (usesLayout<DoubleAPFloat>(getSemantics()))                             \\\n      return U.Double.METHOD_CALL;                                             \\\n    llvm_unreachable(\"Unexpected semantics\");                                  \\\n  } while (false)\n\nnamespace llvm {\n\nstruct fltSemantics;\nclass APSInt;\nclass StringRef;\nclass APFloat;\nclass raw_ostream;\n\ntemplate <typename T> class Expected;\ntemplate <typename T> class SmallVectorImpl;\n\n/// Enum that represents what fraction of the LSB truncated bits of an fp number\n/// represent.\n///\n/// This essentially combines the roles of guard and sticky bits.\nenum lostFraction { // Example of truncated bits:\n  lfExactlyZero,    // 000000\n  lfLessThanHalf,   // 0xxxxx  x's not all zero\n  lfExactlyHalf,    // 100000\n  lfMoreThanHalf    // 1xxxxx  x's not all zero\n};\n\n/// A self-contained host- and target-independent arbitrary-precision\n/// floating-point software implementation.\n///\n/// APFloat uses bignum integer arithmetic as provided by static functions in\n/// the APInt class.  The library will work with bignum integers whose parts are\n/// any unsigned type at least 16 bits wide, but 64 bits is recommended.\n///\n/// Written for clarity rather than speed, in particular with a view to use in\n/// the front-end of a cross compiler so that target arithmetic can be correctly\n/// performed on the host.  Performance should nonetheless be reasonable,\n/// particularly for its intended use.  It may be useful as a base\n/// implementation for a run-time library during development of a faster\n/// target-specific one.\n///\n/// All 5 rounding modes in the IEEE-754R draft are handled correctly for all\n/// implemented operations.  Currently implemented operations are add, subtract,\n/// multiply, divide, fused-multiply-add, conversion-to-float,\n/// conversion-to-integer and conversion-from-integer.  New rounding modes\n/// (e.g. away from zero) can be added with three or four lines of code.\n///\n/// Four formats are built-in: IEEE single precision, double precision,\n/// quadruple precision, and x87 80-bit extended double (when operating with\n/// full extended precision).  Adding a new format that obeys IEEE semantics\n/// only requires adding two lines of code: a declaration and definition of the\n/// format.\n///\n/// All operations return the status of that operation as an exception bit-mask,\n/// so multiple operations can be done consecutively with their results or-ed\n/// together.  The returned status can be useful for compiler diagnostics; e.g.,\n/// inexact, underflow and overflow can be easily diagnosed on constant folding,\n/// and compiler optimizers can determine what exceptions would be raised by\n/// folding operations and optimize, or perhaps not optimize, accordingly.\n///\n/// At present, underflow tininess is detected after rounding; it should be\n/// straight forward to add support for the before-rounding case too.\n///\n/// The library reads hexadecimal floating point numbers as per C99, and\n/// correctly rounds if necessary according to the specified rounding mode.\n/// Syntax is required to have been validated by the caller.  It also converts\n/// floating point numbers to hexadecimal text as per the C99 %a and %A\n/// conversions.  The output precision (or alternatively the natural minimal\n/// precision) can be specified; if the requested precision is less than the\n/// natural precision the output is correctly rounded for the specified rounding\n/// mode.\n///\n/// It also reads decimal floating point numbers and correctly rounds according\n/// to the specified rounding mode.\n///\n/// Conversion to decimal text is not currently implemented.\n///\n/// Non-zero finite numbers are represented internally as a sign bit, a 16-bit\n/// signed exponent, and the significand as an array of integer parts.  After\n/// normalization of a number of precision P the exponent is within the range of\n/// the format, and if the number is not denormal the P-th bit of the\n/// significand is set as an explicit integer bit.  For denormals the most\n/// significant bit is shifted right so that the exponent is maintained at the\n/// format's minimum, so that the smallest denormal has just the least\n/// significant bit of the significand set.  The sign of zeroes and infinities\n/// is significant; the exponent and significand of such numbers is not stored,\n/// but has a known implicit (deterministic) value: 0 for the significands, 0\n/// for zero exponent, all 1 bits for infinity exponent.  For NaNs the sign and\n/// significand are deterministic, although not really meaningful, and preserved\n/// in non-conversion operations.  The exponent is implicitly all 1 bits.\n///\n/// APFloat does not provide any exception handling beyond default exception\n/// handling. We represent Signaling NaNs via IEEE-754R 2008 6.2.1 should clause\n/// by encoding Signaling NaNs with the first bit of its trailing significand as\n/// 0.\n///\n/// TODO\n/// ====\n///\n/// Some features that may or may not be worth adding:\n///\n/// Binary to decimal conversion (hard).\n///\n/// Optional ability to detect underflow tininess before rounding.\n///\n/// New formats: x87 in single and double precision mode (IEEE apart from\n/// extended exponent range) (hard).\n///\n/// New operations: sqrt, IEEE remainder, C90 fmod, nexttoward.\n///\n\n// This is the common type definitions shared by APFloat and its internal\n// implementation classes. This struct should not define any non-static data\n// members.\nstruct APFloatBase {\n  typedef APInt::WordType integerPart;\n  static constexpr unsigned integerPartWidth = APInt::APINT_BITS_PER_WORD;\n\n  /// A signed type to represent a floating point numbers unbiased exponent.\n  typedef int32_t ExponentType;\n\n  /// \\name Floating Point Semantics.\n  /// @{\n  enum Semantics {\n    S_IEEEhalf,\n    S_BFloat,\n    S_IEEEsingle,\n    S_IEEEdouble,\n    S_x87DoubleExtended,\n    S_IEEEquad,\n    S_PPCDoubleDouble\n  };\n\n  static const llvm::fltSemantics &EnumToSemantics(Semantics S);\n  static Semantics SemanticsToEnum(const llvm::fltSemantics &Sem);\n\n  static const fltSemantics &IEEEhalf() LLVM_READNONE;\n  static const fltSemantics &BFloat() LLVM_READNONE;\n  static const fltSemantics &IEEEsingle() LLVM_READNONE;\n  static const fltSemantics &IEEEdouble() LLVM_READNONE;\n  static const fltSemantics &IEEEquad() LLVM_READNONE;\n  static const fltSemantics &PPCDoubleDouble() LLVM_READNONE;\n  static const fltSemantics &x87DoubleExtended() LLVM_READNONE;\n\n  /// A Pseudo fltsemantic used to construct APFloats that cannot conflict with\n  /// anything real.\n  static const fltSemantics &Bogus() LLVM_READNONE;\n\n  /// @}\n\n  /// IEEE-754R 5.11: Floating Point Comparison Relations.\n  enum cmpResult {\n    cmpLessThan,\n    cmpEqual,\n    cmpGreaterThan,\n    cmpUnordered\n  };\n\n  /// IEEE-754R 4.3: Rounding-direction attributes.\n  using roundingMode = llvm::RoundingMode;\n\n  static constexpr roundingMode rmNearestTiesToEven =\n                                                RoundingMode::NearestTiesToEven;\n  static constexpr roundingMode rmTowardPositive = RoundingMode::TowardPositive;\n  static constexpr roundingMode rmTowardNegative = RoundingMode::TowardNegative;\n  static constexpr roundingMode rmTowardZero     = RoundingMode::TowardZero;\n  static constexpr roundingMode rmNearestTiesToAway =\n                                                RoundingMode::NearestTiesToAway;\n\n  /// IEEE-754R 7: Default exception handling.\n  ///\n  /// opUnderflow or opOverflow are always returned or-ed with opInexact.\n  ///\n  /// APFloat models this behavior specified by IEEE-754:\n  ///   \"For operations producing results in floating-point format, the default\n  ///    result of an operation that signals the invalid operation exception\n  ///    shall be a quiet NaN.\"\n  enum opStatus {\n    opOK = 0x00,\n    opInvalidOp = 0x01,\n    opDivByZero = 0x02,\n    opOverflow = 0x04,\n    opUnderflow = 0x08,\n    opInexact = 0x10\n  };\n\n  /// Category of internally-represented number.\n  enum fltCategory {\n    fcInfinity,\n    fcNaN,\n    fcNormal,\n    fcZero\n  };\n\n  /// Convenience enum used to construct an uninitialized APFloat.\n  enum uninitializedTag {\n    uninitialized\n  };\n\n  /// Enumeration of \\c ilogb error results.\n  enum IlogbErrorKinds {\n    IEK_Zero = INT_MIN + 1,\n    IEK_NaN = INT_MIN,\n    IEK_Inf = INT_MAX\n  };\n\n  static unsigned int semanticsPrecision(const fltSemantics &);\n  static ExponentType semanticsMinExponent(const fltSemantics &);\n  static ExponentType semanticsMaxExponent(const fltSemantics &);\n  static unsigned int semanticsSizeInBits(const fltSemantics &);\n\n  /// Returns the size of the floating point number (in bits) in the given\n  /// semantics.\n  static unsigned getSizeInBits(const fltSemantics &Sem);\n};\n\nnamespace detail {\n\nclass IEEEFloat final : public APFloatBase {\npublic:\n  /// \\name Constructors\n  /// @{\n\n  IEEEFloat(const fltSemantics &); // Default construct to +0.0\n  IEEEFloat(const fltSemantics &, integerPart);\n  IEEEFloat(const fltSemantics &, uninitializedTag);\n  IEEEFloat(const fltSemantics &, const APInt &);\n  explicit IEEEFloat(double d);\n  explicit IEEEFloat(float f);\n  IEEEFloat(const IEEEFloat &);\n  IEEEFloat(IEEEFloat &&);\n  ~IEEEFloat();\n\n  /// @}\n\n  /// Returns whether this instance allocated memory.\n  bool needsCleanup() const { return partCount() > 1; }\n\n  /// \\name Convenience \"constructors\"\n  /// @{\n\n  /// @}\n\n  /// \\name Arithmetic\n  /// @{\n\n  opStatus add(const IEEEFloat &, roundingMode);\n  opStatus subtract(const IEEEFloat &, roundingMode);\n  opStatus multiply(const IEEEFloat &, roundingMode);\n  opStatus divide(const IEEEFloat &, roundingMode);\n  /// IEEE remainder.\n  opStatus remainder(const IEEEFloat &);\n  /// C fmod, or llvm frem.\n  opStatus mod(const IEEEFloat &);\n  opStatus fusedMultiplyAdd(const IEEEFloat &, const IEEEFloat &, roundingMode);\n  opStatus roundToIntegral(roundingMode);\n  /// IEEE-754R 5.3.1: nextUp/nextDown.\n  opStatus next(bool nextDown);\n\n  /// @}\n\n  /// \\name Sign operations.\n  /// @{\n\n  void changeSign();\n\n  /// @}\n\n  /// \\name Conversions\n  /// @{\n\n  opStatus convert(const fltSemantics &, roundingMode, bool *);\n  opStatus convertToInteger(MutableArrayRef<integerPart>, unsigned int, bool,\n                            roundingMode, bool *) const;\n  opStatus convertFromAPInt(const APInt &, bool, roundingMode);\n  opStatus convertFromSignExtendedInteger(const integerPart *, unsigned int,\n                                          bool, roundingMode);\n  opStatus convertFromZeroExtendedInteger(const integerPart *, unsigned int,\n                                          bool, roundingMode);\n  Expected<opStatus> convertFromString(StringRef, roundingMode);\n  APInt bitcastToAPInt() const;\n  double convertToDouble() const;\n  float convertToFloat() const;\n\n  /// @}\n\n  /// The definition of equality is not straightforward for floating point, so\n  /// we won't use operator==.  Use one of the following, or write whatever it\n  /// is you really mean.\n  bool operator==(const IEEEFloat &) const = delete;\n\n  /// IEEE comparison with another floating point number (NaNs compare\n  /// unordered, 0==-0).\n  cmpResult compare(const IEEEFloat &) const;\n\n  /// Bitwise comparison for equality (QNaNs compare equal, 0!=-0).\n  bool bitwiseIsEqual(const IEEEFloat &) const;\n\n  /// Write out a hexadecimal representation of the floating point value to DST,\n  /// which must be of sufficient size, in the C99 form [-]0xh.hhhhp[+-]d.\n  /// Return the number of characters written, excluding the terminating NUL.\n  unsigned int convertToHexString(char *dst, unsigned int hexDigits,\n                                  bool upperCase, roundingMode) const;\n\n  /// \\name IEEE-754R 5.7.2 General operations.\n  /// @{\n\n  /// IEEE-754R isSignMinus: Returns true if and only if the current value is\n  /// negative.\n  ///\n  /// This applies to zeros and NaNs as well.\n  bool isNegative() const { return sign; }\n\n  /// IEEE-754R isNormal: Returns true if and only if the current value is normal.\n  ///\n  /// This implies that the current value of the float is not zero, subnormal,\n  /// infinite, or NaN following the definition of normality from IEEE-754R.\n  bool isNormal() const { return !isDenormal() && isFiniteNonZero(); }\n\n  /// Returns true if and only if the current value is zero, subnormal, or\n  /// normal.\n  ///\n  /// This means that the value is not infinite or NaN.\n  bool isFinite() const { return !isNaN() && !isInfinity(); }\n\n  /// Returns true if and only if the float is plus or minus zero.\n  bool isZero() const { return category == fcZero; }\n\n  /// IEEE-754R isSubnormal(): Returns true if and only if the float is a\n  /// denormal.\n  bool isDenormal() const;\n\n  /// IEEE-754R isInfinite(): Returns true if and only if the float is infinity.\n  bool isInfinity() const { return category == fcInfinity; }\n\n  /// Returns true if and only if the float is a quiet or signaling NaN.\n  bool isNaN() const { return category == fcNaN; }\n\n  /// Returns true if and only if the float is a signaling NaN.\n  bool isSignaling() const;\n\n  /// @}\n\n  /// \\name Simple Queries\n  /// @{\n\n  fltCategory getCategory() const { return category; }\n  const fltSemantics &getSemantics() const { return *semantics; }\n  bool isNonZero() const { return category != fcZero; }\n  bool isFiniteNonZero() const { return isFinite() && !isZero(); }\n  bool isPosZero() const { return isZero() && !isNegative(); }\n  bool isNegZero() const { return isZero() && isNegative(); }\n\n  /// Returns true if and only if the number has the smallest possible non-zero\n  /// magnitude in the current semantics.\n  bool isSmallest() const;\n\n  /// Returns true if and only if the number has the largest possible finite\n  /// magnitude in the current semantics.\n  bool isLargest() const;\n\n  /// Returns true if and only if the number is an exact integer.\n  bool isInteger() const;\n\n  /// @}\n\n  IEEEFloat &operator=(const IEEEFloat &);\n  IEEEFloat &operator=(IEEEFloat &&);\n\n  /// Overload to compute a hash code for an APFloat value.\n  ///\n  /// Note that the use of hash codes for floating point values is in general\n  /// frought with peril. Equality is hard to define for these values. For\n  /// example, should negative and positive zero hash to different codes? Are\n  /// they equal or not? This hash value implementation specifically\n  /// emphasizes producing different codes for different inputs in order to\n  /// be used in canonicalization and memoization. As such, equality is\n  /// bitwiseIsEqual, and 0 != -0.\n  friend hash_code hash_value(const IEEEFloat &Arg);\n\n  /// Converts this value into a decimal string.\n  ///\n  /// \\param FormatPrecision The maximum number of digits of\n  ///   precision to output.  If there are fewer digits available,\n  ///   zero padding will not be used unless the value is\n  ///   integral and small enough to be expressed in\n  ///   FormatPrecision digits.  0 means to use the natural\n  ///   precision of the number.\n  /// \\param FormatMaxPadding The maximum number of zeros to\n  ///   consider inserting before falling back to scientific\n  ///   notation.  0 means to always use scientific notation.\n  ///\n  /// \\param TruncateZero Indicate whether to remove the trailing zero in\n  ///   fraction part or not. Also setting this parameter to false forcing\n  ///   producing of output more similar to default printf behavior.\n  ///   Specifically the lower e is used as exponent delimiter and exponent\n  ///   always contains no less than two digits.\n  ///\n  /// Number       Precision    MaxPadding      Result\n  /// ------       ---------    ----------      ------\n  /// 1.01E+4              5             2       10100\n  /// 1.01E+4              4             2       1.01E+4\n  /// 1.01E+4              5             1       1.01E+4\n  /// 1.01E-2              5             2       0.0101\n  /// 1.01E-2              4             2       0.0101\n  /// 1.01E-2              4             1       1.01E-2\n  void toString(SmallVectorImpl<char> &Str, unsigned FormatPrecision = 0,\n                unsigned FormatMaxPadding = 3, bool TruncateZero = true) const;\n\n  /// If this value has an exact multiplicative inverse, store it in inv and\n  /// return true.\n  bool getExactInverse(APFloat *inv) const;\n\n  /// Returns the exponent of the internal representation of the APFloat.\n  ///\n  /// Because the radix of APFloat is 2, this is equivalent to floor(log2(x)).\n  /// For special APFloat values, this returns special error codes:\n  ///\n  ///   NaN -> \\c IEK_NaN\n  ///   0   -> \\c IEK_Zero\n  ///   Inf -> \\c IEK_Inf\n  ///\n  friend int ilogb(const IEEEFloat &Arg);\n\n  /// Returns: X * 2^Exp for integral exponents.\n  friend IEEEFloat scalbn(IEEEFloat X, int Exp, roundingMode);\n\n  friend IEEEFloat frexp(const IEEEFloat &X, int &Exp, roundingMode);\n\n  /// \\name Special value setters.\n  /// @{\n\n  void makeLargest(bool Neg = false);\n  void makeSmallest(bool Neg = false);\n  void makeNaN(bool SNaN = false, bool Neg = false,\n               const APInt *fill = nullptr);\n  void makeInf(bool Neg = false);\n  void makeZero(bool Neg = false);\n  void makeQuiet();\n\n  /// Returns the smallest (by magnitude) normalized finite number in the given\n  /// semantics.\n  ///\n  /// \\param Negative - True iff the number should be negative\n  void makeSmallestNormalized(bool Negative = false);\n\n  /// @}\n\n  cmpResult compareAbsoluteValue(const IEEEFloat &) const;\n\nprivate:\n  /// \\name Simple Queries\n  /// @{\n\n  integerPart *significandParts();\n  const integerPart *significandParts() const;\n  unsigned int partCount() const;\n\n  /// @}\n\n  /// \\name Significand operations.\n  /// @{\n\n  integerPart addSignificand(const IEEEFloat &);\n  integerPart subtractSignificand(const IEEEFloat &, integerPart);\n  lostFraction addOrSubtractSignificand(const IEEEFloat &, bool subtract);\n  lostFraction multiplySignificand(const IEEEFloat &, IEEEFloat);\n  lostFraction multiplySignificand(const IEEEFloat&);\n  lostFraction divideSignificand(const IEEEFloat &);\n  void incrementSignificand();\n  void initialize(const fltSemantics *);\n  void shiftSignificandLeft(unsigned int);\n  lostFraction shiftSignificandRight(unsigned int);\n  unsigned int significandLSB() const;\n  unsigned int significandMSB() const;\n  void zeroSignificand();\n  /// Return true if the significand excluding the integral bit is all ones.\n  bool isSignificandAllOnes() const;\n  /// Return true if the significand excluding the integral bit is all zeros.\n  bool isSignificandAllZeros() const;\n\n  /// @}\n\n  /// \\name Arithmetic on special values.\n  /// @{\n\n  opStatus addOrSubtractSpecials(const IEEEFloat &, bool subtract);\n  opStatus divideSpecials(const IEEEFloat &);\n  opStatus multiplySpecials(const IEEEFloat &);\n  opStatus modSpecials(const IEEEFloat &);\n  opStatus remainderSpecials(const IEEEFloat&);\n\n  /// @}\n\n  /// \\name Miscellany\n  /// @{\n\n  bool convertFromStringSpecials(StringRef str);\n  opStatus normalize(roundingMode, lostFraction);\n  opStatus addOrSubtract(const IEEEFloat &, roundingMode, bool subtract);\n  opStatus handleOverflow(roundingMode);\n  bool roundAwayFromZero(roundingMode, lostFraction, unsigned int) const;\n  opStatus convertToSignExtendedInteger(MutableArrayRef<integerPart>,\n                                        unsigned int, bool, roundingMode,\n                                        bool *) const;\n  opStatus convertFromUnsignedParts(const integerPart *, unsigned int,\n                                    roundingMode);\n  Expected<opStatus> convertFromHexadecimalString(StringRef, roundingMode);\n  Expected<opStatus> convertFromDecimalString(StringRef, roundingMode);\n  char *convertNormalToHexString(char *, unsigned int, bool,\n                                 roundingMode) const;\n  opStatus roundSignificandWithExponent(const integerPart *, unsigned int, int,\n                                        roundingMode);\n  ExponentType exponentNaN() const;\n  ExponentType exponentInf() const;\n  ExponentType exponentZero() const;\n\n  /// @}\n\n  APInt convertHalfAPFloatToAPInt() const;\n  APInt convertBFloatAPFloatToAPInt() const;\n  APInt convertFloatAPFloatToAPInt() const;\n  APInt convertDoubleAPFloatToAPInt() const;\n  APInt convertQuadrupleAPFloatToAPInt() const;\n  APInt convertF80LongDoubleAPFloatToAPInt() const;\n  APInt convertPPCDoubleDoubleAPFloatToAPInt() const;\n  void initFromAPInt(const fltSemantics *Sem, const APInt &api);\n  void initFromHalfAPInt(const APInt &api);\n  void initFromBFloatAPInt(const APInt &api);\n  void initFromFloatAPInt(const APInt &api);\n  void initFromDoubleAPInt(const APInt &api);\n  void initFromQuadrupleAPInt(const APInt &api);\n  void initFromF80LongDoubleAPInt(const APInt &api);\n  void initFromPPCDoubleDoubleAPInt(const APInt &api);\n\n  void assign(const IEEEFloat &);\n  void copySignificand(const IEEEFloat &);\n  void freeSignificand();\n\n  /// Note: this must be the first data member.\n  /// The semantics that this value obeys.\n  const fltSemantics *semantics;\n\n  /// A binary fraction with an explicit integer bit.\n  ///\n  /// The significand must be at least one bit wider than the target precision.\n  union Significand {\n    integerPart part;\n    integerPart *parts;\n  } significand;\n\n  /// The signed unbiased exponent of the value.\n  ExponentType exponent;\n\n  /// What kind of floating point number this is.\n  ///\n  /// Only 2 bits are required, but VisualStudio incorrectly sign extends it.\n  /// Using the extra bit keeps it from failing under VisualStudio.\n  fltCategory category : 3;\n\n  /// Sign bit of the number.\n  unsigned int sign : 1;\n};\n\nhash_code hash_value(const IEEEFloat &Arg);\nint ilogb(const IEEEFloat &Arg);\nIEEEFloat scalbn(IEEEFloat X, int Exp, IEEEFloat::roundingMode);\nIEEEFloat frexp(const IEEEFloat &Val, int &Exp, IEEEFloat::roundingMode RM);\n\n// This mode implements more precise float in terms of two APFloats.\n// The interface and layout is designed for arbitrary underlying semantics,\n// though currently only PPCDoubleDouble semantics are supported, whose\n// corresponding underlying semantics are IEEEdouble.\nclass DoubleAPFloat final : public APFloatBase {\n  // Note: this must be the first data member.\n  const fltSemantics *Semantics;\n  std::unique_ptr<APFloat[]> Floats;\n\n  opStatus addImpl(const APFloat &a, const APFloat &aa, const APFloat &c,\n                   const APFloat &cc, roundingMode RM);\n\n  opStatus addWithSpecial(const DoubleAPFloat &LHS, const DoubleAPFloat &RHS,\n                          DoubleAPFloat &Out, roundingMode RM);\n\npublic:\n  DoubleAPFloat(const fltSemantics &S);\n  DoubleAPFloat(const fltSemantics &S, uninitializedTag);\n  DoubleAPFloat(const fltSemantics &S, integerPart);\n  DoubleAPFloat(const fltSemantics &S, const APInt &I);\n  DoubleAPFloat(const fltSemantics &S, APFloat &&First, APFloat &&Second);\n  DoubleAPFloat(const DoubleAPFloat &RHS);\n  DoubleAPFloat(DoubleAPFloat &&RHS);\n\n  DoubleAPFloat &operator=(const DoubleAPFloat &RHS);\n\n  DoubleAPFloat &operator=(DoubleAPFloat &&RHS) {\n    if (this != &RHS) {\n      this->~DoubleAPFloat();\n      new (this) DoubleAPFloat(std::move(RHS));\n    }\n    return *this;\n  }\n\n  bool needsCleanup() const { return Floats != nullptr; }\n\n  APFloat &getFirst() { return Floats[0]; }\n  const APFloat &getFirst() const { return Floats[0]; }\n  APFloat &getSecond() { return Floats[1]; }\n  const APFloat &getSecond() const { return Floats[1]; }\n\n  opStatus add(const DoubleAPFloat &RHS, roundingMode RM);\n  opStatus subtract(const DoubleAPFloat &RHS, roundingMode RM);\n  opStatus multiply(const DoubleAPFloat &RHS, roundingMode RM);\n  opStatus divide(const DoubleAPFloat &RHS, roundingMode RM);\n  opStatus remainder(const DoubleAPFloat &RHS);\n  opStatus mod(const DoubleAPFloat &RHS);\n  opStatus fusedMultiplyAdd(const DoubleAPFloat &Multiplicand,\n                            const DoubleAPFloat &Addend, roundingMode RM);\n  opStatus roundToIntegral(roundingMode RM);\n  void changeSign();\n  cmpResult compareAbsoluteValue(const DoubleAPFloat &RHS) const;\n\n  fltCategory getCategory() const;\n  bool isNegative() const;\n\n  void makeInf(bool Neg);\n  void makeZero(bool Neg);\n  void makeLargest(bool Neg);\n  void makeSmallest(bool Neg);\n  void makeSmallestNormalized(bool Neg);\n  void makeNaN(bool SNaN, bool Neg, const APInt *fill);\n\n  cmpResult compare(const DoubleAPFloat &RHS) const;\n  bool bitwiseIsEqual(const DoubleAPFloat &RHS) const;\n  APInt bitcastToAPInt() const;\n  Expected<opStatus> convertFromString(StringRef, roundingMode);\n  opStatus next(bool nextDown);\n\n  opStatus convertToInteger(MutableArrayRef<integerPart> Input,\n                            unsigned int Width, bool IsSigned, roundingMode RM,\n                            bool *IsExact) const;\n  opStatus convertFromAPInt(const APInt &Input, bool IsSigned, roundingMode RM);\n  opStatus convertFromSignExtendedInteger(const integerPart *Input,\n                                          unsigned int InputSize, bool IsSigned,\n                                          roundingMode RM);\n  opStatus convertFromZeroExtendedInteger(const integerPart *Input,\n                                          unsigned int InputSize, bool IsSigned,\n                                          roundingMode RM);\n  unsigned int convertToHexString(char *DST, unsigned int HexDigits,\n                                  bool UpperCase, roundingMode RM) const;\n\n  bool isDenormal() const;\n  bool isSmallest() const;\n  bool isLargest() const;\n  bool isInteger() const;\n\n  void toString(SmallVectorImpl<char> &Str, unsigned FormatPrecision,\n                unsigned FormatMaxPadding, bool TruncateZero = true) const;\n\n  bool getExactInverse(APFloat *inv) const;\n\n  friend DoubleAPFloat scalbn(const DoubleAPFloat &X, int Exp, roundingMode);\n  friend DoubleAPFloat frexp(const DoubleAPFloat &X, int &Exp, roundingMode);\n  friend hash_code hash_value(const DoubleAPFloat &Arg);\n};\n\nhash_code hash_value(const DoubleAPFloat &Arg);\n\n} // End detail namespace\n\n// This is a interface class that is currently forwarding functionalities from\n// detail::IEEEFloat.\nclass APFloat : public APFloatBase {\n  typedef detail::IEEEFloat IEEEFloat;\n  typedef detail::DoubleAPFloat DoubleAPFloat;\n\n  static_assert(std::is_standard_layout<IEEEFloat>::value, \"\");\n\n  union Storage {\n    const fltSemantics *semantics;\n    IEEEFloat IEEE;\n    DoubleAPFloat Double;\n\n    explicit Storage(IEEEFloat F, const fltSemantics &S);\n    explicit Storage(DoubleAPFloat F, const fltSemantics &S)\n        : Double(std::move(F)) {\n      assert(&S == &PPCDoubleDouble());\n    }\n\n    template <typename... ArgTypes>\n    Storage(const fltSemantics &Semantics, ArgTypes &&... Args) {\n      if (usesLayout<IEEEFloat>(Semantics)) {\n        new (&IEEE) IEEEFloat(Semantics, std::forward<ArgTypes>(Args)...);\n        return;\n      }\n      if (usesLayout<DoubleAPFloat>(Semantics)) {\n        new (&Double) DoubleAPFloat(Semantics, std::forward<ArgTypes>(Args)...);\n        return;\n      }\n      llvm_unreachable(\"Unexpected semantics\");\n    }\n\n    ~Storage() {\n      if (usesLayout<IEEEFloat>(*semantics)) {\n        IEEE.~IEEEFloat();\n        return;\n      }\n      if (usesLayout<DoubleAPFloat>(*semantics)) {\n        Double.~DoubleAPFloat();\n        return;\n      }\n      llvm_unreachable(\"Unexpected semantics\");\n    }\n\n    Storage(const Storage &RHS) {\n      if (usesLayout<IEEEFloat>(*RHS.semantics)) {\n        new (this) IEEEFloat(RHS.IEEE);\n        return;\n      }\n      if (usesLayout<DoubleAPFloat>(*RHS.semantics)) {\n        new (this) DoubleAPFloat(RHS.Double);\n        return;\n      }\n      llvm_unreachable(\"Unexpected semantics\");\n    }\n\n    Storage(Storage &&RHS) {\n      if (usesLayout<IEEEFloat>(*RHS.semantics)) {\n        new (this) IEEEFloat(std::move(RHS.IEEE));\n        return;\n      }\n      if (usesLayout<DoubleAPFloat>(*RHS.semantics)) {\n        new (this) DoubleAPFloat(std::move(RHS.Double));\n        return;\n      }\n      llvm_unreachable(\"Unexpected semantics\");\n    }\n\n    Storage &operator=(const Storage &RHS) {\n      if (usesLayout<IEEEFloat>(*semantics) &&\n          usesLayout<IEEEFloat>(*RHS.semantics)) {\n        IEEE = RHS.IEEE;\n      } else if (usesLayout<DoubleAPFloat>(*semantics) &&\n                 usesLayout<DoubleAPFloat>(*RHS.semantics)) {\n        Double = RHS.Double;\n      } else if (this != &RHS) {\n        this->~Storage();\n        new (this) Storage(RHS);\n      }\n      return *this;\n    }\n\n    Storage &operator=(Storage &&RHS) {\n      if (usesLayout<IEEEFloat>(*semantics) &&\n          usesLayout<IEEEFloat>(*RHS.semantics)) {\n        IEEE = std::move(RHS.IEEE);\n      } else if (usesLayout<DoubleAPFloat>(*semantics) &&\n                 usesLayout<DoubleAPFloat>(*RHS.semantics)) {\n        Double = std::move(RHS.Double);\n      } else if (this != &RHS) {\n        this->~Storage();\n        new (this) Storage(std::move(RHS));\n      }\n      return *this;\n    }\n  } U;\n\n  template <typename T> static bool usesLayout(const fltSemantics &Semantics) {\n    static_assert(std::is_same<T, IEEEFloat>::value ||\n                  std::is_same<T, DoubleAPFloat>::value, \"\");\n    if (std::is_same<T, DoubleAPFloat>::value) {\n      return &Semantics == &PPCDoubleDouble();\n    }\n    return &Semantics != &PPCDoubleDouble();\n  }\n\n  IEEEFloat &getIEEE() {\n    if (usesLayout<IEEEFloat>(*U.semantics))\n      return U.IEEE;\n    if (usesLayout<DoubleAPFloat>(*U.semantics))\n      return U.Double.getFirst().U.IEEE;\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n\n  const IEEEFloat &getIEEE() const {\n    if (usesLayout<IEEEFloat>(*U.semantics))\n      return U.IEEE;\n    if (usesLayout<DoubleAPFloat>(*U.semantics))\n      return U.Double.getFirst().U.IEEE;\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n\n  void makeZero(bool Neg) { APFLOAT_DISPATCH_ON_SEMANTICS(makeZero(Neg)); }\n\n  void makeInf(bool Neg) { APFLOAT_DISPATCH_ON_SEMANTICS(makeInf(Neg)); }\n\n  void makeNaN(bool SNaN, bool Neg, const APInt *fill) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(makeNaN(SNaN, Neg, fill));\n  }\n\n  void makeLargest(bool Neg) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(makeLargest(Neg));\n  }\n\n  void makeSmallest(bool Neg) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(makeSmallest(Neg));\n  }\n\n  void makeSmallestNormalized(bool Neg) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(makeSmallestNormalized(Neg));\n  }\n\n  // FIXME: This is due to clang 3.3 (or older version) always checks for the\n  // default constructor in an array aggregate initialization, even if no\n  // elements in the array is default initialized.\n  APFloat() : U(IEEEdouble()) {\n    llvm_unreachable(\"This is a workaround for old clang.\");\n  }\n\n  explicit APFloat(IEEEFloat F, const fltSemantics &S) : U(std::move(F), S) {}\n  explicit APFloat(DoubleAPFloat F, const fltSemantics &S)\n      : U(std::move(F), S) {}\n\n  cmpResult compareAbsoluteValue(const APFloat &RHS) const {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only compare APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.compareAbsoluteValue(RHS.U.IEEE);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.compareAbsoluteValue(RHS.U.Double);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n\npublic:\n  APFloat(const fltSemantics &Semantics) : U(Semantics) {}\n  APFloat(const fltSemantics &Semantics, StringRef S);\n  APFloat(const fltSemantics &Semantics, integerPart I) : U(Semantics, I) {}\n  template <typename T,\n            typename = std::enable_if_t<std::is_floating_point<T>::value>>\n  APFloat(const fltSemantics &Semantics, T V) = delete;\n  // TODO: Remove this constructor. This isn't faster than the first one.\n  APFloat(const fltSemantics &Semantics, uninitializedTag)\n      : U(Semantics, uninitialized) {}\n  APFloat(const fltSemantics &Semantics, const APInt &I) : U(Semantics, I) {}\n  explicit APFloat(double d) : U(IEEEFloat(d), IEEEdouble()) {}\n  explicit APFloat(float f) : U(IEEEFloat(f), IEEEsingle()) {}\n  APFloat(const APFloat &RHS) = default;\n  APFloat(APFloat &&RHS) = default;\n\n  ~APFloat() = default;\n\n  bool needsCleanup() const { APFLOAT_DISPATCH_ON_SEMANTICS(needsCleanup()); }\n\n  /// Factory for Positive and Negative Zero.\n  ///\n  /// \\param Negative True iff the number should be negative.\n  static APFloat getZero(const fltSemantics &Sem, bool Negative = false) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeZero(Negative);\n    return Val;\n  }\n\n  /// Factory for Positive and Negative Infinity.\n  ///\n  /// \\param Negative True iff the number should be negative.\n  static APFloat getInf(const fltSemantics &Sem, bool Negative = false) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeInf(Negative);\n    return Val;\n  }\n\n  /// Factory for NaN values.\n  ///\n  /// \\param Negative - True iff the NaN generated should be negative.\n  /// \\param payload - The unspecified fill bits for creating the NaN, 0 by\n  /// default.  The value is truncated as necessary.\n  static APFloat getNaN(const fltSemantics &Sem, bool Negative = false,\n                        uint64_t payload = 0) {\n    if (payload) {\n      APInt intPayload(64, payload);\n      return getQNaN(Sem, Negative, &intPayload);\n    } else {\n      return getQNaN(Sem, Negative, nullptr);\n    }\n  }\n\n  /// Factory for QNaN values.\n  static APFloat getQNaN(const fltSemantics &Sem, bool Negative = false,\n                         const APInt *payload = nullptr) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeNaN(false, Negative, payload);\n    return Val;\n  }\n\n  /// Factory for SNaN values.\n  static APFloat getSNaN(const fltSemantics &Sem, bool Negative = false,\n                         const APInt *payload = nullptr) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeNaN(true, Negative, payload);\n    return Val;\n  }\n\n  /// Returns the largest finite number in the given semantics.\n  ///\n  /// \\param Negative - True iff the number should be negative\n  static APFloat getLargest(const fltSemantics &Sem, bool Negative = false) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeLargest(Negative);\n    return Val;\n  }\n\n  /// Returns the smallest (by magnitude) finite number in the given semantics.\n  /// Might be denormalized, which implies a relative loss of precision.\n  ///\n  /// \\param Negative - True iff the number should be negative\n  static APFloat getSmallest(const fltSemantics &Sem, bool Negative = false) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeSmallest(Negative);\n    return Val;\n  }\n\n  /// Returns the smallest (by magnitude) normalized finite number in the given\n  /// semantics.\n  ///\n  /// \\param Negative - True iff the number should be negative\n  static APFloat getSmallestNormalized(const fltSemantics &Sem,\n                                       bool Negative = false) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeSmallestNormalized(Negative);\n    return Val;\n  }\n\n  /// Returns a float which is bitcasted from an all one value int.\n  ///\n  /// \\param Semantics - type float semantics\n  /// \\param BitWidth - Select float type\n  static APFloat getAllOnesValue(const fltSemantics &Semantics,\n                                 unsigned BitWidth);\n\n  /// Used to insert APFloat objects, or objects that contain APFloat objects,\n  /// into FoldingSets.\n  void Profile(FoldingSetNodeID &NID) const;\n\n  opStatus add(const APFloat &RHS, roundingMode RM) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.add(RHS.U.IEEE, RM);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.add(RHS.U.Double, RM);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus subtract(const APFloat &RHS, roundingMode RM) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.subtract(RHS.U.IEEE, RM);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.subtract(RHS.U.Double, RM);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus multiply(const APFloat &RHS, roundingMode RM) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.multiply(RHS.U.IEEE, RM);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.multiply(RHS.U.Double, RM);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus divide(const APFloat &RHS, roundingMode RM) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.divide(RHS.U.IEEE, RM);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.divide(RHS.U.Double, RM);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus remainder(const APFloat &RHS) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.remainder(RHS.U.IEEE);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.remainder(RHS.U.Double);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus mod(const APFloat &RHS) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.mod(RHS.U.IEEE);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.mod(RHS.U.Double);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus fusedMultiplyAdd(const APFloat &Multiplicand, const APFloat &Addend,\n                            roundingMode RM) {\n    assert(&getSemantics() == &Multiplicand.getSemantics() &&\n           \"Should only call on APFloats with the same semantics\");\n    assert(&getSemantics() == &Addend.getSemantics() &&\n           \"Should only call on APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.fusedMultiplyAdd(Multiplicand.U.IEEE, Addend.U.IEEE, RM);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.fusedMultiplyAdd(Multiplicand.U.Double, Addend.U.Double,\n                                       RM);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus roundToIntegral(roundingMode RM) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(roundToIntegral(RM));\n  }\n\n  // TODO: bool parameters are not readable and a source of bugs.\n  // Do something.\n  opStatus next(bool nextDown) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(next(nextDown));\n  }\n\n  /// Negate an APFloat.\n  APFloat operator-() const {\n    APFloat Result(*this);\n    Result.changeSign();\n    return Result;\n  }\n\n  /// Add two APFloats, rounding ties to the nearest even.\n  /// No error checking.\n  APFloat operator+(const APFloat &RHS) const {\n    APFloat Result(*this);\n    (void)Result.add(RHS, rmNearestTiesToEven);\n    return Result;\n  }\n\n  /// Subtract two APFloats, rounding ties to the nearest even.\n  /// No error checking.\n  APFloat operator-(const APFloat &RHS) const {\n    APFloat Result(*this);\n    (void)Result.subtract(RHS, rmNearestTiesToEven);\n    return Result;\n  }\n\n  /// Multiply two APFloats, rounding ties to the nearest even.\n  /// No error checking.\n  APFloat operator*(const APFloat &RHS) const {\n    APFloat Result(*this);\n    (void)Result.multiply(RHS, rmNearestTiesToEven);\n    return Result;\n  }\n\n  /// Divide the first APFloat by the second, rounding ties to the nearest even.\n  /// No error checking.\n  APFloat operator/(const APFloat &RHS) const {\n    APFloat Result(*this);\n    (void)Result.divide(RHS, rmNearestTiesToEven);\n    return Result;\n  }\n\n  void changeSign() { APFLOAT_DISPATCH_ON_SEMANTICS(changeSign()); }\n  void clearSign() {\n    if (isNegative())\n      changeSign();\n  }\n  void copySign(const APFloat &RHS) {\n    if (isNegative() != RHS.isNegative())\n      changeSign();\n  }\n\n  /// A static helper to produce a copy of an APFloat value with its sign\n  /// copied from some other APFloat.\n  static APFloat copySign(APFloat Value, const APFloat &Sign) {\n    Value.copySign(Sign);\n    return Value;\n  }\n\n  opStatus convert(const fltSemantics &ToSemantics, roundingMode RM,\n                   bool *losesInfo);\n  opStatus convertToInteger(MutableArrayRef<integerPart> Input,\n                            unsigned int Width, bool IsSigned, roundingMode RM,\n                            bool *IsExact) const {\n    APFLOAT_DISPATCH_ON_SEMANTICS(\n        convertToInteger(Input, Width, IsSigned, RM, IsExact));\n  }\n  opStatus convertToInteger(APSInt &Result, roundingMode RM,\n                            bool *IsExact) const;\n  opStatus convertFromAPInt(const APInt &Input, bool IsSigned,\n                            roundingMode RM) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(convertFromAPInt(Input, IsSigned, RM));\n  }\n  opStatus convertFromSignExtendedInteger(const integerPart *Input,\n                                          unsigned int InputSize, bool IsSigned,\n                                          roundingMode RM) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(\n        convertFromSignExtendedInteger(Input, InputSize, IsSigned, RM));\n  }\n  opStatus convertFromZeroExtendedInteger(const integerPart *Input,\n                                          unsigned int InputSize, bool IsSigned,\n                                          roundingMode RM) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(\n        convertFromZeroExtendedInteger(Input, InputSize, IsSigned, RM));\n  }\n  Expected<opStatus> convertFromString(StringRef, roundingMode);\n  APInt bitcastToAPInt() const {\n    APFLOAT_DISPATCH_ON_SEMANTICS(bitcastToAPInt());\n  }\n  double convertToDouble() const { return getIEEE().convertToDouble(); }\n  float convertToFloat() const { return getIEEE().convertToFloat(); }\n\n  bool operator==(const APFloat &RHS) const { return compare(RHS) == cmpEqual; }\n\n  bool operator!=(const APFloat &RHS) const { return compare(RHS) != cmpEqual; }\n\n  bool operator<(const APFloat &RHS) const {\n    return compare(RHS) == cmpLessThan;\n  }\n\n  bool operator>(const APFloat &RHS) const {\n    return compare(RHS) == cmpGreaterThan;\n  }\n\n  bool operator<=(const APFloat &RHS) const {\n    cmpResult Res = compare(RHS);\n    return Res == cmpLessThan || Res == cmpEqual;\n  }\n\n  bool operator>=(const APFloat &RHS) const {\n    cmpResult Res = compare(RHS);\n    return Res == cmpGreaterThan || Res == cmpEqual;\n  }\n\n  cmpResult compare(const APFloat &RHS) const {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only compare APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.compare(RHS.U.IEEE);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.compare(RHS.U.Double);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n\n  bool bitwiseIsEqual(const APFloat &RHS) const {\n    if (&getSemantics() != &RHS.getSemantics())\n      return false;\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.bitwiseIsEqual(RHS.U.IEEE);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.bitwiseIsEqual(RHS.U.Double);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n\n  /// We don't rely on operator== working on double values, as\n  /// it returns true for things that are clearly not equal, like -0.0 and 0.0.\n  /// As such, this method can be used to do an exact bit-for-bit comparison of\n  /// two floating point values.\n  ///\n  /// We leave the version with the double argument here because it's just so\n  /// convenient to write \"2.0\" and the like.  Without this function we'd\n  /// have to duplicate its logic everywhere it's called.\n  bool isExactlyValue(double V) const {\n    bool ignored;\n    APFloat Tmp(V);\n    Tmp.convert(getSemantics(), APFloat::rmNearestTiesToEven, &ignored);\n    return bitwiseIsEqual(Tmp);\n  }\n\n  unsigned int convertToHexString(char *DST, unsigned int HexDigits,\n                                  bool UpperCase, roundingMode RM) const {\n    APFLOAT_DISPATCH_ON_SEMANTICS(\n        convertToHexString(DST, HexDigits, UpperCase, RM));\n  }\n\n  bool isZero() const { return getCategory() == fcZero; }\n  bool isInfinity() const { return getCategory() == fcInfinity; }\n  bool isNaN() const { return getCategory() == fcNaN; }\n\n  bool isNegative() const { return getIEEE().isNegative(); }\n  bool isDenormal() const { APFLOAT_DISPATCH_ON_SEMANTICS(isDenormal()); }\n  bool isSignaling() const { return getIEEE().isSignaling(); }\n\n  bool isNormal() const { return !isDenormal() && isFiniteNonZero(); }\n  bool isFinite() const { return !isNaN() && !isInfinity(); }\n\n  fltCategory getCategory() const { return getIEEE().getCategory(); }\n  const fltSemantics &getSemantics() const { return *U.semantics; }\n  bool isNonZero() const { return !isZero(); }\n  bool isFiniteNonZero() const { return isFinite() && !isZero(); }\n  bool isPosZero() const { return isZero() && !isNegative(); }\n  bool isNegZero() const { return isZero() && isNegative(); }\n  bool isSmallest() const { APFLOAT_DISPATCH_ON_SEMANTICS(isSmallest()); }\n  bool isLargest() const { APFLOAT_DISPATCH_ON_SEMANTICS(isLargest()); }\n  bool isInteger() const { APFLOAT_DISPATCH_ON_SEMANTICS(isInteger()); }\n  bool isIEEE() const { return usesLayout<IEEEFloat>(getSemantics()); }\n\n  APFloat &operator=(const APFloat &RHS) = default;\n  APFloat &operator=(APFloat &&RHS) = default;\n\n  void toString(SmallVectorImpl<char> &Str, unsigned FormatPrecision = 0,\n                unsigned FormatMaxPadding = 3, bool TruncateZero = true) const {\n    APFLOAT_DISPATCH_ON_SEMANTICS(\n        toString(Str, FormatPrecision, FormatMaxPadding, TruncateZero));\n  }\n\n  void print(raw_ostream &) const;\n  void dump() const;\n\n  bool getExactInverse(APFloat *inv) const {\n    APFLOAT_DISPATCH_ON_SEMANTICS(getExactInverse(inv));\n  }\n\n  friend hash_code hash_value(const APFloat &Arg);\n  friend int ilogb(const APFloat &Arg) { return ilogb(Arg.getIEEE()); }\n  friend APFloat scalbn(APFloat X, int Exp, roundingMode RM);\n  friend APFloat frexp(const APFloat &X, int &Exp, roundingMode RM);\n  friend IEEEFloat;\n  friend DoubleAPFloat;\n};\n\n/// See friend declarations above.\n///\n/// These additional declarations are required in order to compile LLVM with IBM\n/// xlC compiler.\nhash_code hash_value(const APFloat &Arg);\ninline APFloat scalbn(APFloat X, int Exp, APFloat::roundingMode RM) {\n  if (APFloat::usesLayout<detail::IEEEFloat>(X.getSemantics()))\n    return APFloat(scalbn(X.U.IEEE, Exp, RM), X.getSemantics());\n  if (APFloat::usesLayout<detail::DoubleAPFloat>(X.getSemantics()))\n    return APFloat(scalbn(X.U.Double, Exp, RM), X.getSemantics());\n  llvm_unreachable(\"Unexpected semantics\");\n}\n\n/// Equivalent of C standard library function.\n///\n/// While the C standard says Exp is an unspecified value for infinity and nan,\n/// this returns INT_MAX for infinities, and INT_MIN for NaNs.\ninline APFloat frexp(const APFloat &X, int &Exp, APFloat::roundingMode RM) {\n  if (APFloat::usesLayout<detail::IEEEFloat>(X.getSemantics()))\n    return APFloat(frexp(X.U.IEEE, Exp, RM), X.getSemantics());\n  if (APFloat::usesLayout<detail::DoubleAPFloat>(X.getSemantics()))\n    return APFloat(frexp(X.U.Double, Exp, RM), X.getSemantics());\n  llvm_unreachable(\"Unexpected semantics\");\n}\n/// Returns the absolute value of the argument.\ninline APFloat abs(APFloat X) {\n  X.clearSign();\n  return X;\n}\n\n/// Returns the negated value of the argument.\ninline APFloat neg(APFloat X) {\n  X.changeSign();\n  return X;\n}\n\n/// Implements IEEE minNum semantics. Returns the smaller of the 2 arguments if\n/// both are not NaN. If either argument is a NaN, returns the other argument.\nLLVM_READONLY\ninline APFloat minnum(const APFloat &A, const APFloat &B) {\n  if (A.isNaN())\n    return B;\n  if (B.isNaN())\n    return A;\n  return B < A ? B : A;\n}\n\n/// Implements IEEE maxNum semantics. Returns the larger of the 2 arguments if\n/// both are not NaN. If either argument is a NaN, returns the other argument.\nLLVM_READONLY\ninline APFloat maxnum(const APFloat &A, const APFloat &B) {\n  if (A.isNaN())\n    return B;\n  if (B.isNaN())\n    return A;\n  return A < B ? B : A;\n}\n\n/// Implements IEEE 754-2018 minimum semantics. Returns the smaller of 2\n/// arguments, propagating NaNs and treating -0 as less than +0.\nLLVM_READONLY\ninline APFloat minimum(const APFloat &A, const APFloat &B) {\n  if (A.isNaN())\n    return A;\n  if (B.isNaN())\n    return B;\n  if (A.isZero() && B.isZero() && (A.isNegative() != B.isNegative()))\n    return A.isNegative() ? A : B;\n  return B < A ? B : A;\n}\n\n/// Implements IEEE 754-2018 maximum semantics. Returns the larger of 2\n/// arguments, propagating NaNs and treating -0 as less than +0.\nLLVM_READONLY\ninline APFloat maximum(const APFloat &A, const APFloat &B) {\n  if (A.isNaN())\n    return A;\n  if (B.isNaN())\n    return B;\n  if (A.isZero() && B.isZero() && (A.isNegative() != B.isNegative()))\n    return A.isNegative() ? B : A;\n  return A < B ? B : A;\n}\n\n} // namespace llvm\n\n#undef APFLOAT_DISPATCH_ON_SEMANTICS\n#endif // LLVM_ADT_APFLOAT_H\n"}, "42": {"id": 42, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseSet.h", "content": "//===- llvm/ADT/DenseSet.h - Dense probed hash table ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the DenseSet and SmallDenseSet classes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_DENSESET_H\n#define LLVM_ADT_DENSESET_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <algorithm>\n#include <cstddef>\n#include <initializer_list>\n#include <iterator>\n#include <utility>\n\nnamespace llvm {\n\nnamespace detail {\n\nstruct DenseSetEmpty {};\n\n// Use the empty base class trick so we can create a DenseMap where the buckets\n// contain only a single item.\ntemplate <typename KeyT> class DenseSetPair : public DenseSetEmpty {\n  KeyT key;\n\npublic:\n  KeyT &getFirst() { return key; }\n  const KeyT &getFirst() const { return key; }\n  DenseSetEmpty &getSecond() { return *this; }\n  const DenseSetEmpty &getSecond() const { return *this; }\n};\n\n/// Base class for DenseSet and DenseSmallSet.\n///\n/// MapTy should be either\n///\n///   DenseMap<ValueT, detail::DenseSetEmpty, ValueInfoT,\n///            detail::DenseSetPair<ValueT>>\n///\n/// or the equivalent SmallDenseMap type.  ValueInfoT must implement the\n/// DenseMapInfo \"concept\".\ntemplate <typename ValueT, typename MapTy, typename ValueInfoT>\nclass DenseSetImpl {\n  static_assert(sizeof(typename MapTy::value_type) == sizeof(ValueT),\n                \"DenseMap buckets unexpectedly large!\");\n  MapTy TheMap;\n\n  template <typename T>\n  using const_arg_type_t = typename const_pointer_or_const_ref<T>::type;\n\npublic:\n  using key_type = ValueT;\n  using value_type = ValueT;\n  using size_type = unsigned;\n\n  explicit DenseSetImpl(unsigned InitialReserve = 0) : TheMap(InitialReserve) {}\n\n  template <typename InputIt>\n  DenseSetImpl(const InputIt &I, const InputIt &E)\n      : DenseSetImpl(PowerOf2Ceil(std::distance(I, E))) {\n    insert(I, E);\n  }\n\n  DenseSetImpl(std::initializer_list<ValueT> Elems)\n      : DenseSetImpl(PowerOf2Ceil(Elems.size())) {\n    insert(Elems.begin(), Elems.end());\n  }\n\n  bool empty() const { return TheMap.empty(); }\n  size_type size() const { return TheMap.size(); }\n  size_t getMemorySize() const { return TheMap.getMemorySize(); }\n\n  /// Grow the DenseSet so that it has at least Size buckets. Will not shrink\n  /// the Size of the set.\n  void resize(size_t Size) { TheMap.resize(Size); }\n\n  /// Grow the DenseSet so that it can contain at least \\p NumEntries items\n  /// before resizing again.\n  void reserve(size_t Size) { TheMap.reserve(Size); }\n\n  void clear() {\n    TheMap.clear();\n  }\n\n  /// Return 1 if the specified key is in the set, 0 otherwise.\n  size_type count(const_arg_type_t<ValueT> V) const {\n    return TheMap.count(V);\n  }\n\n  bool erase(const ValueT &V) {\n    return TheMap.erase(V);\n  }\n\n  void swap(DenseSetImpl &RHS) { TheMap.swap(RHS.TheMap); }\n\n  // Iterators.\n\n  class ConstIterator;\n\n  class Iterator {\n    typename MapTy::iterator I;\n    friend class DenseSetImpl;\n    friend class ConstIterator;\n\n  public:\n    using difference_type = typename MapTy::iterator::difference_type;\n    using value_type = ValueT;\n    using pointer = value_type *;\n    using reference = value_type &;\n    using iterator_category = std::forward_iterator_tag;\n\n    Iterator() = default;\n    Iterator(const typename MapTy::iterator &i) : I(i) {}\n\n    ValueT &operator*() { return I->getFirst(); }\n    const ValueT &operator*() const { return I->getFirst(); }\n    ValueT *operator->() { return &I->getFirst(); }\n    const ValueT *operator->() const { return &I->getFirst(); }\n\n    Iterator& operator++() { ++I; return *this; }\n    Iterator operator++(int) { auto T = *this; ++I; return T; }\n    friend bool operator==(const Iterator &X, const Iterator &Y) {\n      return X.I == Y.I;\n    }\n    friend bool operator!=(const Iterator &X, const Iterator &Y) {\n      return X.I != Y.I;\n    }\n  };\n\n  class ConstIterator {\n    typename MapTy::const_iterator I;\n    friend class DenseSetImpl;\n    friend class Iterator;\n\n  public:\n    using difference_type = typename MapTy::const_iterator::difference_type;\n    using value_type = ValueT;\n    using pointer = const value_type *;\n    using reference = const value_type &;\n    using iterator_category = std::forward_iterator_tag;\n\n    ConstIterator() = default;\n    ConstIterator(const Iterator &B) : I(B.I) {}\n    ConstIterator(const typename MapTy::const_iterator &i) : I(i) {}\n\n    const ValueT &operator*() const { return I->getFirst(); }\n    const ValueT *operator->() const { return &I->getFirst(); }\n\n    ConstIterator& operator++() { ++I; return *this; }\n    ConstIterator operator++(int) { auto T = *this; ++I; return T; }\n    friend bool operator==(const ConstIterator &X, const ConstIterator &Y) {\n      return X.I == Y.I;\n    }\n    friend bool operator!=(const ConstIterator &X, const ConstIterator &Y) {\n      return X.I != Y.I;\n    }\n  };\n\n  using iterator = Iterator;\n  using const_iterator = ConstIterator;\n\n  iterator begin() { return Iterator(TheMap.begin()); }\n  iterator end() { return Iterator(TheMap.end()); }\n\n  const_iterator begin() const { return ConstIterator(TheMap.begin()); }\n  const_iterator end() const { return ConstIterator(TheMap.end()); }\n\n  iterator find(const_arg_type_t<ValueT> V) { return Iterator(TheMap.find(V)); }\n  const_iterator find(const_arg_type_t<ValueT> V) const {\n    return ConstIterator(TheMap.find(V));\n  }\n\n  /// Check if the set contains the given element.\n  bool contains(const_arg_type_t<ValueT> V) const {\n    return TheMap.find(V) != TheMap.end();\n  }\n\n  /// Alternative version of find() which allows a different, and possibly less\n  /// expensive, key type.\n  /// The DenseMapInfo is responsible for supplying methods\n  /// getHashValue(LookupKeyT) and isEqual(LookupKeyT, KeyT) for each key type\n  /// used.\n  template <class LookupKeyT>\n  iterator find_as(const LookupKeyT &Val) {\n    return Iterator(TheMap.find_as(Val));\n  }\n  template <class LookupKeyT>\n  const_iterator find_as(const LookupKeyT &Val) const {\n    return ConstIterator(TheMap.find_as(Val));\n  }\n\n  void erase(Iterator I) { return TheMap.erase(I.I); }\n  void erase(ConstIterator CI) { return TheMap.erase(CI.I); }\n\n  std::pair<iterator, bool> insert(const ValueT &V) {\n    detail::DenseSetEmpty Empty;\n    return TheMap.try_emplace(V, Empty);\n  }\n\n  std::pair<iterator, bool> insert(ValueT &&V) {\n    detail::DenseSetEmpty Empty;\n    return TheMap.try_emplace(std::move(V), Empty);\n  }\n\n  /// Alternative version of insert that uses a different (and possibly less\n  /// expensive) key type.\n  template <typename LookupKeyT>\n  std::pair<iterator, bool> insert_as(const ValueT &V,\n                                      const LookupKeyT &LookupKey) {\n    return TheMap.insert_as({V, detail::DenseSetEmpty()}, LookupKey);\n  }\n  template <typename LookupKeyT>\n  std::pair<iterator, bool> insert_as(ValueT &&V, const LookupKeyT &LookupKey) {\n    return TheMap.insert_as({std::move(V), detail::DenseSetEmpty()}, LookupKey);\n  }\n\n  // Range insertion of values.\n  template<typename InputIt>\n  void insert(InputIt I, InputIt E) {\n    for (; I != E; ++I)\n      insert(*I);\n  }\n};\n\n/// Equality comparison for DenseSet.\n///\n/// Iterates over elements of LHS confirming that each element is also a member\n/// of RHS, and that RHS contains no additional values.\n/// Equivalent to N calls to RHS.count. Amortized complexity is linear, worst\n/// case is O(N^2) (if every hash collides).\ntemplate <typename ValueT, typename MapTy, typename ValueInfoT>\nbool operator==(const DenseSetImpl<ValueT, MapTy, ValueInfoT> &LHS,\n                const DenseSetImpl<ValueT, MapTy, ValueInfoT> &RHS) {\n  if (LHS.size() != RHS.size())\n    return false;\n\n  for (auto &E : LHS)\n    if (!RHS.count(E))\n      return false;\n\n  return true;\n}\n\n/// Inequality comparison for DenseSet.\n///\n/// Equivalent to !(LHS == RHS). See operator== for performance notes.\ntemplate <typename ValueT, typename MapTy, typename ValueInfoT>\nbool operator!=(const DenseSetImpl<ValueT, MapTy, ValueInfoT> &LHS,\n                const DenseSetImpl<ValueT, MapTy, ValueInfoT> &RHS) {\n  return !(LHS == RHS);\n}\n\n} // end namespace detail\n\n/// Implements a dense probed hash-table based set.\ntemplate <typename ValueT, typename ValueInfoT = DenseMapInfo<ValueT>>\nclass DenseSet : public detail::DenseSetImpl<\n                     ValueT, DenseMap<ValueT, detail::DenseSetEmpty, ValueInfoT,\n                                      detail::DenseSetPair<ValueT>>,\n                     ValueInfoT> {\n  using BaseT =\n      detail::DenseSetImpl<ValueT,\n                           DenseMap<ValueT, detail::DenseSetEmpty, ValueInfoT,\n                                    detail::DenseSetPair<ValueT>>,\n                           ValueInfoT>;\n\npublic:\n  using BaseT::BaseT;\n};\n\n/// Implements a dense probed hash-table based set with some number of buckets\n/// stored inline.\ntemplate <typename ValueT, unsigned InlineBuckets = 4,\n          typename ValueInfoT = DenseMapInfo<ValueT>>\nclass SmallDenseSet\n    : public detail::DenseSetImpl<\n          ValueT, SmallDenseMap<ValueT, detail::DenseSetEmpty, InlineBuckets,\n                                ValueInfoT, detail::DenseSetPair<ValueT>>,\n          ValueInfoT> {\n  using BaseT = detail::DenseSetImpl<\n      ValueT, SmallDenseMap<ValueT, detail::DenseSetEmpty, InlineBuckets,\n                            ValueInfoT, detail::DenseSetPair<ValueT>>,\n      ValueInfoT>;\n\npublic:\n  using BaseT::BaseT;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_DENSESET_H\n"}, "44": {"id": 44, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "content": "//===- llvm/ADT/FoldingSet.h - Uniquing Hash Set ----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines a hash set that can be used to remove duplication of nodes\n// in a graph.  This code was originally created by Chris Lattner for use with\n// SelectionDAGCSEMap, but was isolated to provide use across the llvm code set.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_FOLDINGSET_H\n#define LLVM_ADT_FOLDINGSET_H\n\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <utility>\n\nnamespace llvm {\n\n/// This folding set used for two purposes:\n///   1. Given information about a node we want to create, look up the unique\n///      instance of the node in the set.  If the node already exists, return\n///      it, otherwise return the bucket it should be inserted into.\n///   2. Given a node that has already been created, remove it from the set.\n///\n/// This class is implemented as a single-link chained hash table, where the\n/// \"buckets\" are actually the nodes themselves (the next pointer is in the\n/// node).  The last node points back to the bucket to simplify node removal.\n///\n/// Any node that is to be included in the folding set must be a subclass of\n/// FoldingSetNode.  The node class must also define a Profile method used to\n/// establish the unique bits of data for the node.  The Profile method is\n/// passed a FoldingSetNodeID object which is used to gather the bits.  Just\n/// call one of the Add* functions defined in the FoldingSetBase::NodeID class.\n/// NOTE: That the folding set does not own the nodes and it is the\n/// responsibility of the user to dispose of the nodes.\n///\n/// Eg.\n///    class MyNode : public FoldingSetNode {\n///    private:\n///      std::string Name;\n///      unsigned Value;\n///    public:\n///      MyNode(const char *N, unsigned V) : Name(N), Value(V) {}\n///       ...\n///      void Profile(FoldingSetNodeID &ID) const {\n///        ID.AddString(Name);\n///        ID.AddInteger(Value);\n///      }\n///      ...\n///    };\n///\n/// To define the folding set itself use the FoldingSet template;\n///\n/// Eg.\n///    FoldingSet<MyNode> MyFoldingSet;\n///\n/// Four public methods are available to manipulate the folding set;\n///\n/// 1) If you have an existing node that you want add to the set but unsure\n/// that the node might already exist then call;\n///\n///    MyNode *M = MyFoldingSet.GetOrInsertNode(N);\n///\n/// If The result is equal to the input then the node has been inserted.\n/// Otherwise, the result is the node existing in the folding set, and the\n/// input can be discarded (use the result instead.)\n///\n/// 2) If you are ready to construct a node but want to check if it already\n/// exists, then call FindNodeOrInsertPos with a FoldingSetNodeID of the bits to\n/// check;\n///\n///   FoldingSetNodeID ID;\n///   ID.AddString(Name);\n///   ID.AddInteger(Value);\n///   void *InsertPoint;\n///\n///    MyNode *M = MyFoldingSet.FindNodeOrInsertPos(ID, InsertPoint);\n///\n/// If found then M will be non-NULL, else InsertPoint will point to where it\n/// should be inserted using InsertNode.\n///\n/// 3) If you get a NULL result from FindNodeOrInsertPos then you can insert a\n/// new node with InsertNode;\n///\n///    MyFoldingSet.InsertNode(M, InsertPoint);\n///\n/// 4) Finally, if you want to remove a node from the folding set call;\n///\n///    bool WasRemoved = MyFoldingSet.RemoveNode(M);\n///\n/// The result indicates whether the node existed in the folding set.\n\nclass FoldingSetNodeID;\nclass StringRef;\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetBase - Implements the folding set functionality.  The main\n/// structure is an array of buckets.  Each bucket is indexed by the hash of\n/// the nodes it contains.  The bucket itself points to the nodes contained\n/// in the bucket via a singly linked list.  The last node in the list points\n/// back to the bucket to facilitate node removal.\n///\nclass FoldingSetBase {\nprotected:\n  /// Buckets - Array of bucket chains.\n  void **Buckets;\n\n  /// NumBuckets - Length of the Buckets array.  Always a power of 2.\n  unsigned NumBuckets;\n\n  /// NumNodes - Number of nodes in the folding set. Growth occurs when NumNodes\n  /// is greater than twice the number of buckets.\n  unsigned NumNodes;\n\n  explicit FoldingSetBase(unsigned Log2InitSize = 6);\n  FoldingSetBase(FoldingSetBase &&Arg);\n  FoldingSetBase &operator=(FoldingSetBase &&RHS);\n  ~FoldingSetBase();\n\npublic:\n  //===--------------------------------------------------------------------===//\n  /// Node - This class is used to maintain the singly linked bucket list in\n  /// a folding set.\n  class Node {\n  private:\n    // NextInFoldingSetBucket - next link in the bucket list.\n    void *NextInFoldingSetBucket = nullptr;\n\n  public:\n    Node() = default;\n\n    // Accessors\n    void *getNextInBucket() const { return NextInFoldingSetBucket; }\n    void SetNextInBucket(void *N) { NextInFoldingSetBucket = N; }\n  };\n\n  /// clear - Remove all nodes from the folding set.\n  void clear();\n\n  /// size - Returns the number of nodes in the folding set.\n  unsigned size() const { return NumNodes; }\n\n  /// empty - Returns true if there are no nodes in the folding set.\n  bool empty() const { return NumNodes == 0; }\n\n  /// capacity - Returns the number of nodes permitted in the folding set\n  /// before a rebucket operation is performed.\n  unsigned capacity() {\n    // We allow a load factor of up to 2.0,\n    // so that means our capacity is NumBuckets * 2\n    return NumBuckets * 2;\n  }\n\nprotected:\n  /// Functions provided by the derived class to compute folding properties.\n  /// This is effectively a vtable for FoldingSetBase, except that we don't\n  /// actually store a pointer to it in the object.\n  struct FoldingSetInfo {\n    /// GetNodeProfile - Instantiations of the FoldingSet template implement\n    /// this function to gather data bits for the given node.\n    void (*GetNodeProfile)(const FoldingSetBase *Self, Node *N,\n                           FoldingSetNodeID &ID);\n\n    /// NodeEquals - Instantiations of the FoldingSet template implement\n    /// this function to compare the given node with the given ID.\n    bool (*NodeEquals)(const FoldingSetBase *Self, Node *N,\n                       const FoldingSetNodeID &ID, unsigned IDHash,\n                       FoldingSetNodeID &TempID);\n\n    /// ComputeNodeHash - Instantiations of the FoldingSet template implement\n    /// this function to compute a hash value for the given node.\n    unsigned (*ComputeNodeHash)(const FoldingSetBase *Self, Node *N,\n                                FoldingSetNodeID &TempID);\n  };\n\nprivate:\n  /// GrowHashTable - Double the size of the hash table and rehash everything.\n  void GrowHashTable(const FoldingSetInfo &Info);\n\n  /// GrowBucketCount - resize the hash table and rehash everything.\n  /// NewBucketCount must be a power of two, and must be greater than the old\n  /// bucket count.\n  void GrowBucketCount(unsigned NewBucketCount, const FoldingSetInfo &Info);\n\nprotected:\n  // The below methods are protected to encourage subclasses to provide a more\n  // type-safe API.\n\n  /// reserve - Increase the number of buckets such that adding the\n  /// EltCount-th node won't cause a rebucket operation. reserve is permitted\n  /// to allocate more space than requested by EltCount.\n  void reserve(unsigned EltCount, const FoldingSetInfo &Info);\n\n  /// RemoveNode - Remove a node from the folding set, returning true if one\n  /// was removed or false if the node was not in the folding set.\n  bool RemoveNode(Node *N);\n\n  /// GetOrInsertNode - If there is an existing simple Node exactly\n  /// equal to the specified node, return it.  Otherwise, insert 'N' and return\n  /// it instead.\n  Node *GetOrInsertNode(Node *N, const FoldingSetInfo &Info);\n\n  /// FindNodeOrInsertPos - Look up the node specified by ID.  If it exists,\n  /// return it.  If not, return the insertion token that will make insertion\n  /// faster.\n  Node *FindNodeOrInsertPos(const FoldingSetNodeID &ID, void *&InsertPos,\n                            const FoldingSetInfo &Info);\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.  InsertPos must be obtained from\n  /// FindNodeOrInsertPos.\n  void InsertNode(Node *N, void *InsertPos, const FoldingSetInfo &Info);\n};\n\n//===----------------------------------------------------------------------===//\n\n/// DefaultFoldingSetTrait - This class provides default implementations\n/// for FoldingSetTrait implementations.\ntemplate<typename T> struct DefaultFoldingSetTrait {\n  static void Profile(const T &X, FoldingSetNodeID &ID) {\n    X.Profile(ID);\n  }\n  static void Profile(T &X, FoldingSetNodeID &ID) {\n    X.Profile(ID);\n  }\n\n  // Equals - Test if the profile for X would match ID, using TempID\n  // to compute a temporary ID if necessary. The default implementation\n  // just calls Profile and does a regular comparison. Implementations\n  // can override this to provide more efficient implementations.\n  static inline bool Equals(T &X, const FoldingSetNodeID &ID, unsigned IDHash,\n                            FoldingSetNodeID &TempID);\n\n  // ComputeHash - Compute a hash value for X, using TempID to\n  // compute a temporary ID if necessary. The default implementation\n  // just calls Profile and does a regular hash computation.\n  // Implementations can override this to provide more efficient\n  // implementations.\n  static inline unsigned ComputeHash(T &X, FoldingSetNodeID &TempID);\n};\n\n/// FoldingSetTrait - This trait class is used to define behavior of how\n/// to \"profile\" (in the FoldingSet parlance) an object of a given type.\n/// The default behavior is to invoke a 'Profile' method on an object, but\n/// through template specialization the behavior can be tailored for specific\n/// types.  Combined with the FoldingSetNodeWrapper class, one can add objects\n/// to FoldingSets that were not originally designed to have that behavior.\ntemplate<typename T> struct FoldingSetTrait\n  : public DefaultFoldingSetTrait<T> {};\n\n/// DefaultContextualFoldingSetTrait - Like DefaultFoldingSetTrait, but\n/// for ContextualFoldingSets.\ntemplate<typename T, typename Ctx>\nstruct DefaultContextualFoldingSetTrait {\n  static void Profile(T &X, FoldingSetNodeID &ID, Ctx Context) {\n    X.Profile(ID, Context);\n  }\n\n  static inline bool Equals(T &X, const FoldingSetNodeID &ID, unsigned IDHash,\n                            FoldingSetNodeID &TempID, Ctx Context);\n  static inline unsigned ComputeHash(T &X, FoldingSetNodeID &TempID,\n                                     Ctx Context);\n};\n\n/// ContextualFoldingSetTrait - Like FoldingSetTrait, but for\n/// ContextualFoldingSets.\ntemplate<typename T, typename Ctx> struct ContextualFoldingSetTrait\n  : public DefaultContextualFoldingSetTrait<T, Ctx> {};\n\n//===--------------------------------------------------------------------===//\n/// FoldingSetNodeIDRef - This class describes a reference to an interned\n/// FoldingSetNodeID, which can be a useful to store node id data rather\n/// than using plain FoldingSetNodeIDs, since the 32-element SmallVector\n/// is often much larger than necessary, and the possibility of heap\n/// allocation means it requires a non-trivial destructor call.\nclass FoldingSetNodeIDRef {\n  const unsigned *Data = nullptr;\n  size_t Size = 0;\n\npublic:\n  FoldingSetNodeIDRef() = default;\n  FoldingSetNodeIDRef(const unsigned *D, size_t S) : Data(D), Size(S) {}\n\n  /// ComputeHash - Compute a strong hash value for this FoldingSetNodeIDRef,\n  /// used to lookup the node in the FoldingSetBase.\n  unsigned ComputeHash() const;\n\n  bool operator==(FoldingSetNodeIDRef) const;\n\n  bool operator!=(FoldingSetNodeIDRef RHS) const { return !(*this == RHS); }\n\n  /// Used to compare the \"ordering\" of two nodes as defined by the\n  /// profiled bits and their ordering defined by memcmp().\n  bool operator<(FoldingSetNodeIDRef) const;\n\n  const unsigned *getData() const { return Data; }\n  size_t getSize() const { return Size; }\n};\n\n//===--------------------------------------------------------------------===//\n/// FoldingSetNodeID - This class is used to gather all the unique data bits of\n/// a node.  When all the bits are gathered this class is used to produce a\n/// hash value for the node.\nclass FoldingSetNodeID {\n  /// Bits - Vector of all the data bits that make the node unique.\n  /// Use a SmallVector to avoid a heap allocation in the common case.\n  SmallVector<unsigned, 32> Bits;\n\npublic:\n  FoldingSetNodeID() = default;\n\n  FoldingSetNodeID(FoldingSetNodeIDRef Ref)\n    : Bits(Ref.getData(), Ref.getData() + Ref.getSize()) {}\n\n  /// Add* - Add various data types to Bit data.\n  void AddPointer(const void *Ptr);\n  void AddInteger(signed I);\n  void AddInteger(unsigned I);\n  void AddInteger(long I);\n  void AddInteger(unsigned long I);\n  void AddInteger(long long I);\n  void AddInteger(unsigned long long I);\n  void AddBoolean(bool B) { AddInteger(B ? 1U : 0U); }\n  void AddString(StringRef String);\n  void AddNodeID(const FoldingSetNodeID &ID);\n\n  template <typename T>\n  inline void Add(const T &x) { FoldingSetTrait<T>::Profile(x, *this); }\n\n  /// clear - Clear the accumulated profile, allowing this FoldingSetNodeID\n  /// object to be used to compute a new profile.\n  inline void clear() { Bits.clear(); }\n\n  /// ComputeHash - Compute a strong hash value for this FoldingSetNodeID, used\n  /// to lookup the node in the FoldingSetBase.\n  unsigned ComputeHash() const;\n\n  /// operator== - Used to compare two nodes to each other.\n  bool operator==(const FoldingSetNodeID &RHS) const;\n  bool operator==(const FoldingSetNodeIDRef RHS) const;\n\n  bool operator!=(const FoldingSetNodeID &RHS) const { return !(*this == RHS); }\n  bool operator!=(const FoldingSetNodeIDRef RHS) const { return !(*this ==RHS);}\n\n  /// Used to compare the \"ordering\" of two nodes as defined by the\n  /// profiled bits and their ordering defined by memcmp().\n  bool operator<(const FoldingSetNodeID &RHS) const;\n  bool operator<(const FoldingSetNodeIDRef RHS) const;\n\n  /// Intern - Copy this node's data to a memory region allocated from the\n  /// given allocator and return a FoldingSetNodeIDRef describing the\n  /// interned data.\n  FoldingSetNodeIDRef Intern(BumpPtrAllocator &Allocator) const;\n};\n\n// Convenience type to hide the implementation of the folding set.\nusing FoldingSetNode = FoldingSetBase::Node;\ntemplate<class T> class FoldingSetIterator;\ntemplate<class T> class FoldingSetBucketIterator;\n\n// Definitions of FoldingSetTrait and ContextualFoldingSetTrait functions, which\n// require the definition of FoldingSetNodeID.\ntemplate<typename T>\ninline bool\nDefaultFoldingSetTrait<T>::Equals(T &X, const FoldingSetNodeID &ID,\n                                  unsigned /*IDHash*/,\n                                  FoldingSetNodeID &TempID) {\n  FoldingSetTrait<T>::Profile(X, TempID);\n  return TempID == ID;\n}\ntemplate<typename T>\ninline unsigned\nDefaultFoldingSetTrait<T>::ComputeHash(T &X, FoldingSetNodeID &TempID) {\n  FoldingSetTrait<T>::Profile(X, TempID);\n  return TempID.ComputeHash();\n}\ntemplate<typename T, typename Ctx>\ninline bool\nDefaultContextualFoldingSetTrait<T, Ctx>::Equals(T &X,\n                                                 const FoldingSetNodeID &ID,\n                                                 unsigned /*IDHash*/,\n                                                 FoldingSetNodeID &TempID,\n                                                 Ctx Context) {\n  ContextualFoldingSetTrait<T, Ctx>::Profile(X, TempID, Context);\n  return TempID == ID;\n}\ntemplate<typename T, typename Ctx>\ninline unsigned\nDefaultContextualFoldingSetTrait<T, Ctx>::ComputeHash(T &X,\n                                                      FoldingSetNodeID &TempID,\n                                                      Ctx Context) {\n  ContextualFoldingSetTrait<T, Ctx>::Profile(X, TempID, Context);\n  return TempID.ComputeHash();\n}\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetImpl - An implementation detail that lets us share code between\n/// FoldingSet and ContextualFoldingSet.\ntemplate <class Derived, class T> class FoldingSetImpl : public FoldingSetBase {\nprotected:\n  explicit FoldingSetImpl(unsigned Log2InitSize)\n      : FoldingSetBase(Log2InitSize) {}\n\n  FoldingSetImpl(FoldingSetImpl &&Arg) = default;\n  FoldingSetImpl &operator=(FoldingSetImpl &&RHS) = default;\n  ~FoldingSetImpl() = default;\n\npublic:\n  using iterator = FoldingSetIterator<T>;\n\n  iterator begin() { return iterator(Buckets); }\n  iterator end() { return iterator(Buckets+NumBuckets); }\n\n  using const_iterator = FoldingSetIterator<const T>;\n\n  const_iterator begin() const { return const_iterator(Buckets); }\n  const_iterator end() const { return const_iterator(Buckets+NumBuckets); }\n\n  using bucket_iterator = FoldingSetBucketIterator<T>;\n\n  bucket_iterator bucket_begin(unsigned hash) {\n    return bucket_iterator(Buckets + (hash & (NumBuckets-1)));\n  }\n\n  bucket_iterator bucket_end(unsigned hash) {\n    return bucket_iterator(Buckets + (hash & (NumBuckets-1)), true);\n  }\n\n  /// reserve - Increase the number of buckets such that adding the\n  /// EltCount-th node won't cause a rebucket operation. reserve is permitted\n  /// to allocate more space than requested by EltCount.\n  void reserve(unsigned EltCount) {\n    return FoldingSetBase::reserve(EltCount, Derived::getFoldingSetInfo());\n  }\n\n  /// RemoveNode - Remove a node from the folding set, returning true if one\n  /// was removed or false if the node was not in the folding set.\n  bool RemoveNode(T *N) {\n    return FoldingSetBase::RemoveNode(N);\n  }\n\n  /// GetOrInsertNode - If there is an existing simple Node exactly\n  /// equal to the specified node, return it.  Otherwise, insert 'N' and\n  /// return it instead.\n  T *GetOrInsertNode(T *N) {\n    return static_cast<T *>(\n        FoldingSetBase::GetOrInsertNode(N, Derived::getFoldingSetInfo()));\n  }\n\n  /// FindNodeOrInsertPos - Look up the node specified by ID.  If it exists,\n  /// return it.  If not, return the insertion token that will make insertion\n  /// faster.\n  T *FindNodeOrInsertPos(const FoldingSetNodeID &ID, void *&InsertPos) {\n    return static_cast<T *>(FoldingSetBase::FindNodeOrInsertPos(\n        ID, InsertPos, Derived::getFoldingSetInfo()));\n  }\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.  InsertPos must be obtained from\n  /// FindNodeOrInsertPos.\n  void InsertNode(T *N, void *InsertPos) {\n    FoldingSetBase::InsertNode(N, InsertPos, Derived::getFoldingSetInfo());\n  }\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.\n  void InsertNode(T *N) {\n    T *Inserted = GetOrInsertNode(N);\n    (void)Inserted;\n    assert(Inserted == N && \"Node already inserted!\");\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSet - This template class is used to instantiate a specialized\n/// implementation of the folding set to the node class T.  T must be a\n/// subclass of FoldingSetNode and implement a Profile function.\n///\n/// Note that this set type is movable and move-assignable. However, its\n/// moved-from state is not a valid state for anything other than\n/// move-assigning and destroying. This is primarily to enable movable APIs\n/// that incorporate these objects.\ntemplate <class T>\nclass FoldingSet : public FoldingSetImpl<FoldingSet<T>, T> {\n  using Super = FoldingSetImpl<FoldingSet, T>;\n  using Node = typename Super::Node;\n\n  /// GetNodeProfile - Each instantiation of the FoldingSet needs to provide a\n  /// way to convert nodes into a unique specifier.\n  static void GetNodeProfile(const FoldingSetBase *, Node *N,\n                             FoldingSetNodeID &ID) {\n    T *TN = static_cast<T *>(N);\n    FoldingSetTrait<T>::Profile(*TN, ID);\n  }\n\n  /// NodeEquals - Instantiations may optionally provide a way to compare a\n  /// node with a specified ID.\n  static bool NodeEquals(const FoldingSetBase *, Node *N,\n                         const FoldingSetNodeID &ID, unsigned IDHash,\n                         FoldingSetNodeID &TempID) {\n    T *TN = static_cast<T *>(N);\n    return FoldingSetTrait<T>::Equals(*TN, ID, IDHash, TempID);\n  }\n\n  /// ComputeNodeHash - Instantiations may optionally provide a way to compute a\n  /// hash value directly from a node.\n  static unsigned ComputeNodeHash(const FoldingSetBase *, Node *N,\n                                  FoldingSetNodeID &TempID) {\n    T *TN = static_cast<T *>(N);\n    return FoldingSetTrait<T>::ComputeHash(*TN, TempID);\n  }\n\n  static const FoldingSetBase::FoldingSetInfo &getFoldingSetInfo() {\n    static constexpr FoldingSetBase::FoldingSetInfo Info = {\n        GetNodeProfile, NodeEquals, ComputeNodeHash};\n    return Info;\n  }\n  friend Super;\n\npublic:\n  explicit FoldingSet(unsigned Log2InitSize = 6) : Super(Log2InitSize) {}\n  FoldingSet(FoldingSet &&Arg) = default;\n  FoldingSet &operator=(FoldingSet &&RHS) = default;\n};\n\n//===----------------------------------------------------------------------===//\n/// ContextualFoldingSet - This template class is a further refinement\n/// of FoldingSet which provides a context argument when calling\n/// Profile on its nodes.  Currently, that argument is fixed at\n/// initialization time.\n///\n/// T must be a subclass of FoldingSetNode and implement a Profile\n/// function with signature\n///   void Profile(FoldingSetNodeID &, Ctx);\ntemplate <class T, class Ctx>\nclass ContextualFoldingSet\n    : public FoldingSetImpl<ContextualFoldingSet<T, Ctx>, T> {\n  // Unfortunately, this can't derive from FoldingSet<T> because the\n  // construction of the vtable for FoldingSet<T> requires\n  // FoldingSet<T>::GetNodeProfile to be instantiated, which in turn\n  // requires a single-argument T::Profile().\n\n  using Super = FoldingSetImpl<ContextualFoldingSet, T>;\n  using Node = typename Super::Node;\n\n  Ctx Context;\n\n  static const Ctx &getContext(const FoldingSetBase *Base) {\n    return static_cast<const ContextualFoldingSet*>(Base)->Context;\n  }\n\n  /// GetNodeProfile - Each instantiatation of the FoldingSet needs to provide a\n  /// way to convert nodes into a unique specifier.\n  static void GetNodeProfile(const FoldingSetBase *Base, Node *N,\n                             FoldingSetNodeID &ID) {\n    T *TN = static_cast<T *>(N);\n    ContextualFoldingSetTrait<T, Ctx>::Profile(*TN, ID, getContext(Base));\n  }\n\n  static bool NodeEquals(const FoldingSetBase *Base, Node *N,\n                         const FoldingSetNodeID &ID, unsigned IDHash,\n                         FoldingSetNodeID &TempID) {\n    T *TN = static_cast<T *>(N);\n    return ContextualFoldingSetTrait<T, Ctx>::Equals(*TN, ID, IDHash, TempID,\n                                                     getContext(Base));\n  }\n\n  static unsigned ComputeNodeHash(const FoldingSetBase *Base, Node *N,\n                                  FoldingSetNodeID &TempID) {\n    T *TN = static_cast<T *>(N);\n    return ContextualFoldingSetTrait<T, Ctx>::ComputeHash(*TN, TempID,\n                                                          getContext(Base));\n  }\n\n  static const FoldingSetBase::FoldingSetInfo &getFoldingSetInfo() {\n    static constexpr FoldingSetBase::FoldingSetInfo Info = {\n        GetNodeProfile, NodeEquals, ComputeNodeHash};\n    return Info;\n  }\n  friend Super;\n\npublic:\n  explicit ContextualFoldingSet(Ctx Context, unsigned Log2InitSize = 6)\n      : Super(Log2InitSize), Context(Context) {}\n\n  Ctx getContext() const { return Context; }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetVector - This template class combines a FoldingSet and a vector\n/// to provide the interface of FoldingSet but with deterministic iteration\n/// order based on the insertion order. T must be a subclass of FoldingSetNode\n/// and implement a Profile function.\ntemplate <class T, class VectorT = SmallVector<T*, 8>>\nclass FoldingSetVector {\n  FoldingSet<T> Set;\n  VectorT Vector;\n\npublic:\n  explicit FoldingSetVector(unsigned Log2InitSize = 6) : Set(Log2InitSize) {}\n\n  using iterator = pointee_iterator<typename VectorT::iterator>;\n\n  iterator begin() { return Vector.begin(); }\n  iterator end()   { return Vector.end(); }\n\n  using const_iterator = pointee_iterator<typename VectorT::const_iterator>;\n\n  const_iterator begin() const { return Vector.begin(); }\n  const_iterator end()   const { return Vector.end(); }\n\n  /// clear - Remove all nodes from the folding set.\n  void clear() { Set.clear(); Vector.clear(); }\n\n  /// FindNodeOrInsertPos - Look up the node specified by ID.  If it exists,\n  /// return it.  If not, return the insertion token that will make insertion\n  /// faster.\n  T *FindNodeOrInsertPos(const FoldingSetNodeID &ID, void *&InsertPos) {\n    return Set.FindNodeOrInsertPos(ID, InsertPos);\n  }\n\n  /// GetOrInsertNode - If there is an existing simple Node exactly\n  /// equal to the specified node, return it.  Otherwise, insert 'N' and\n  /// return it instead.\n  T *GetOrInsertNode(T *N) {\n    T *Result = Set.GetOrInsertNode(N);\n    if (Result == N) Vector.push_back(N);\n    return Result;\n  }\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.  InsertPos must be obtained from\n  /// FindNodeOrInsertPos.\n  void InsertNode(T *N, void *InsertPos) {\n    Set.InsertNode(N, InsertPos);\n    Vector.push_back(N);\n  }\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.\n  void InsertNode(T *N) {\n    Set.InsertNode(N);\n    Vector.push_back(N);\n  }\n\n  /// size - Returns the number of nodes in the folding set.\n  unsigned size() const { return Set.size(); }\n\n  /// empty - Returns true if there are no nodes in the folding set.\n  bool empty() const { return Set.empty(); }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetIteratorImpl - This is the common iterator support shared by all\n/// folding sets, which knows how to walk the folding set hash table.\nclass FoldingSetIteratorImpl {\nprotected:\n  FoldingSetNode *NodePtr;\n\n  FoldingSetIteratorImpl(void **Bucket);\n\n  void advance();\n\npublic:\n  bool operator==(const FoldingSetIteratorImpl &RHS) const {\n    return NodePtr == RHS.NodePtr;\n  }\n  bool operator!=(const FoldingSetIteratorImpl &RHS) const {\n    return NodePtr != RHS.NodePtr;\n  }\n};\n\ntemplate <class T> class FoldingSetIterator : public FoldingSetIteratorImpl {\npublic:\n  explicit FoldingSetIterator(void **Bucket) : FoldingSetIteratorImpl(Bucket) {}\n\n  T &operator*() const {\n    return *static_cast<T*>(NodePtr);\n  }\n\n  T *operator->() const {\n    return static_cast<T*>(NodePtr);\n  }\n\n  inline FoldingSetIterator &operator++() {          // Preincrement\n    advance();\n    return *this;\n  }\n  FoldingSetIterator operator++(int) {        // Postincrement\n    FoldingSetIterator tmp = *this; ++*this; return tmp;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetBucketIteratorImpl - This is the common bucket iterator support\n/// shared by all folding sets, which knows how to walk a particular bucket\n/// of a folding set hash table.\nclass FoldingSetBucketIteratorImpl {\nprotected:\n  void *Ptr;\n\n  explicit FoldingSetBucketIteratorImpl(void **Bucket);\n\n  FoldingSetBucketIteratorImpl(void **Bucket, bool) : Ptr(Bucket) {}\n\n  void advance() {\n    void *Probe = static_cast<FoldingSetNode*>(Ptr)->getNextInBucket();\n    uintptr_t x = reinterpret_cast<uintptr_t>(Probe) & ~0x1;\n    Ptr = reinterpret_cast<void*>(x);\n  }\n\npublic:\n  bool operator==(const FoldingSetBucketIteratorImpl &RHS) const {\n    return Ptr == RHS.Ptr;\n  }\n  bool operator!=(const FoldingSetBucketIteratorImpl &RHS) const {\n    return Ptr != RHS.Ptr;\n  }\n};\n\ntemplate <class T>\nclass FoldingSetBucketIterator : public FoldingSetBucketIteratorImpl {\npublic:\n  explicit FoldingSetBucketIterator(void **Bucket) :\n    FoldingSetBucketIteratorImpl(Bucket) {}\n\n  FoldingSetBucketIterator(void **Bucket, bool) :\n    FoldingSetBucketIteratorImpl(Bucket, true) {}\n\n  T &operator*() const { return *static_cast<T*>(Ptr); }\n  T *operator->() const { return static_cast<T*>(Ptr); }\n\n  inline FoldingSetBucketIterator &operator++() { // Preincrement\n    advance();\n    return *this;\n  }\n  FoldingSetBucketIterator operator++(int) {      // Postincrement\n    FoldingSetBucketIterator tmp = *this; ++*this; return tmp;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetNodeWrapper - This template class is used to \"wrap\" arbitrary\n/// types in an enclosing object so that they can be inserted into FoldingSets.\ntemplate <typename T>\nclass FoldingSetNodeWrapper : public FoldingSetNode {\n  T data;\n\npublic:\n  template <typename... Ts>\n  explicit FoldingSetNodeWrapper(Ts &&... Args)\n      : data(std::forward<Ts>(Args)...) {}\n\n  void Profile(FoldingSetNodeID &ID) { FoldingSetTrait<T>::Profile(data, ID); }\n\n  T &getValue() { return data; }\n  const T &getValue() const { return data; }\n\n  operator T&() { return data; }\n  operator const T&() const { return data; }\n};\n\n//===----------------------------------------------------------------------===//\n/// FastFoldingSetNode - This is a subclass of FoldingSetNode which stores\n/// a FoldingSetNodeID value rather than requiring the node to recompute it\n/// each time it is needed. This trades space for speed (which can be\n/// significant if the ID is long), and it also permits nodes to drop\n/// information that would otherwise only be required for recomputing an ID.\nclass FastFoldingSetNode : public FoldingSetNode {\n  FoldingSetNodeID FastID;\n\nprotected:\n  explicit FastFoldingSetNode(const FoldingSetNodeID &ID) : FastID(ID) {}\n\npublic:\n  void Profile(FoldingSetNodeID &ID) const { ID.AddNodeID(FastID); }\n};\n\n//===----------------------------------------------------------------------===//\n// Partial specializations of FoldingSetTrait.\n\ntemplate<typename T> struct FoldingSetTrait<T*> {\n  static inline void Profile(T *X, FoldingSetNodeID &ID) {\n    ID.AddPointer(X);\n  }\n};\ntemplate <typename T1, typename T2>\nstruct FoldingSetTrait<std::pair<T1, T2>> {\n  static inline void Profile(const std::pair<T1, T2> &P,\n                             FoldingSetNodeID &ID) {\n    ID.Add(P.first);\n    ID.Add(P.second);\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_FOLDINGSET_H\n"}, "53": {"id": 53, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/TinyPtrVector.h", "content": "//===- llvm/ADT/TinyPtrVector.h - 'Normally tiny' vectors -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_TINYPTRVECTOR_H\n#define LLVM_ADT_TINYPTRVECTOR_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <type_traits>\n\nnamespace llvm {\n\n/// TinyPtrVector - This class is specialized for cases where there are\n/// normally 0 or 1 element in a vector, but is general enough to go beyond that\n/// when required.\n///\n/// NOTE: This container doesn't allow you to store a null pointer into it.\n///\ntemplate <typename EltTy>\nclass TinyPtrVector {\npublic:\n  using VecTy = SmallVector<EltTy, 4>;\n  using value_type = typename VecTy::value_type;\n  // EltTy must be the first pointer type so that is<EltTy> is true for the\n  // default-constructed PtrUnion. This allows an empty TinyPtrVector to\n  // naturally vend a begin/end iterator of type EltTy* without an additional\n  // check for the empty state.\n  using PtrUnion = PointerUnion<EltTy, VecTy *>;\n\nprivate:\n  PtrUnion Val;\n\npublic:\n  TinyPtrVector() = default;\n\n  ~TinyPtrVector() {\n    if (VecTy *V = Val.template dyn_cast<VecTy*>())\n      delete V;\n  }\n\n  TinyPtrVector(const TinyPtrVector &RHS) : Val(RHS.Val) {\n    if (VecTy *V = Val.template dyn_cast<VecTy*>())\n      Val = new VecTy(*V);\n  }\n\n  TinyPtrVector &operator=(const TinyPtrVector &RHS) {\n    if (this == &RHS)\n      return *this;\n    if (RHS.empty()) {\n      this->clear();\n      return *this;\n    }\n\n    // Try to squeeze into the single slot. If it won't fit, allocate a copied\n    // vector.\n    if (Val.template is<EltTy>()) {\n      if (RHS.size() == 1)\n        Val = RHS.front();\n      else\n        Val = new VecTy(*RHS.Val.template get<VecTy*>());\n      return *this;\n    }\n\n    // If we have a full vector allocated, try to re-use it.\n    if (RHS.Val.template is<EltTy>()) {\n      Val.template get<VecTy*>()->clear();\n      Val.template get<VecTy*>()->push_back(RHS.front());\n    } else {\n      *Val.template get<VecTy*>() = *RHS.Val.template get<VecTy*>();\n    }\n    return *this;\n  }\n\n  TinyPtrVector(TinyPtrVector &&RHS) : Val(RHS.Val) {\n    RHS.Val = (EltTy)nullptr;\n  }\n\n  TinyPtrVector &operator=(TinyPtrVector &&RHS) {\n    if (this == &RHS)\n      return *this;\n    if (RHS.empty()) {\n      this->clear();\n      return *this;\n    }\n\n    // If this vector has been allocated on the heap, re-use it if cheap. If it\n    // would require more copying, just delete it and we'll steal the other\n    // side.\n    if (VecTy *V = Val.template dyn_cast<VecTy*>()) {\n      if (RHS.Val.template is<EltTy>()) {\n        V->clear();\n        V->push_back(RHS.front());\n        RHS.Val = EltTy();\n        return *this;\n      }\n      delete V;\n    }\n\n    Val = RHS.Val;\n    RHS.Val = EltTy();\n    return *this;\n  }\n\n  TinyPtrVector(std::initializer_list<EltTy> IL)\n      : Val(IL.size() == 0\n                ? PtrUnion()\n                : IL.size() == 1 ? PtrUnion(*IL.begin())\n                                 : PtrUnion(new VecTy(IL.begin(), IL.end()))) {}\n\n  /// Constructor from an ArrayRef.\n  ///\n  /// This also is a constructor for individual array elements due to the single\n  /// element constructor for ArrayRef.\n  explicit TinyPtrVector(ArrayRef<EltTy> Elts)\n      : Val(Elts.empty()\n                ? PtrUnion()\n                : Elts.size() == 1\n                      ? PtrUnion(Elts[0])\n                      : PtrUnion(new VecTy(Elts.begin(), Elts.end()))) {}\n\n  TinyPtrVector(size_t Count, EltTy Value)\n      : Val(Count == 0 ? PtrUnion()\n                       : Count == 1 ? PtrUnion(Value)\n                                    : PtrUnion(new VecTy(Count, Value))) {}\n\n  // implicit conversion operator to ArrayRef.\n  operator ArrayRef<EltTy>() const {\n    if (Val.isNull())\n      return None;\n    if (Val.template is<EltTy>())\n      return *Val.getAddrOfPtr1();\n    return *Val.template get<VecTy*>();\n  }\n\n  // implicit conversion operator to MutableArrayRef.\n  operator MutableArrayRef<EltTy>() {\n    if (Val.isNull())\n      return None;\n    if (Val.template is<EltTy>())\n      return *Val.getAddrOfPtr1();\n    return *Val.template get<VecTy*>();\n  }\n\n  // Implicit conversion to ArrayRef<U> if EltTy* implicitly converts to U*.\n  template <\n      typename U,\n      std::enable_if_t<std::is_convertible<ArrayRef<EltTy>, ArrayRef<U>>::value,\n                       bool> = false>\n  operator ArrayRef<U>() const {\n    return operator ArrayRef<EltTy>();\n  }\n\n  bool empty() const {\n    // This vector can be empty if it contains no element, or if it\n    // contains a pointer to an empty vector.\n    if (Val.isNull()) return true;\n    if (VecTy *Vec = Val.template dyn_cast<VecTy*>())\n      return Vec->empty();\n    return false;\n  }\n\n  unsigned size() const {\n    if (empty())\n      return 0;\n    if (Val.template is<EltTy>())\n      return 1;\n    return Val.template get<VecTy*>()->size();\n  }\n\n  using iterator = EltTy *;\n  using const_iterator = const EltTy *;\n  using reverse_iterator = std::reverse_iterator<iterator>;\n  using const_reverse_iterator = std::reverse_iterator<const_iterator>;\n\n  iterator begin() {\n    if (Val.template is<EltTy>())\n      return Val.getAddrOfPtr1();\n\n    return Val.template get<VecTy *>()->begin();\n  }\n\n  iterator end() {\n    if (Val.template is<EltTy>())\n      return begin() + (Val.isNull() ? 0 : 1);\n\n    return Val.template get<VecTy *>()->end();\n  }\n\n  const_iterator begin() const {\n    return (const_iterator)const_cast<TinyPtrVector*>(this)->begin();\n  }\n\n  const_iterator end() const {\n    return (const_iterator)const_cast<TinyPtrVector*>(this)->end();\n  }\n\n  reverse_iterator rbegin() { return reverse_iterator(end()); }\n  reverse_iterator rend() { return reverse_iterator(begin()); }\n\n  const_reverse_iterator rbegin() const {\n    return const_reverse_iterator(end());\n  }\n\n  const_reverse_iterator rend() const {\n    return const_reverse_iterator(begin());\n  }\n\n  EltTy operator[](unsigned i) const {\n    assert(!Val.isNull() && \"can't index into an empty vector\");\n    if (Val.template is<EltTy>()) {\n      assert(i == 0 && \"tinyvector index out of range\");\n      return Val.template get<EltTy>();\n    }\n\n    assert(i < Val.template get<VecTy*>()->size() &&\n           \"tinyvector index out of range\");\n    return (*Val.template get<VecTy*>())[i];\n  }\n\n  EltTy front() const {\n    assert(!empty() && \"vector empty\");\n    if (Val.template is<EltTy>())\n      return Val.template get<EltTy>();\n    return Val.template get<VecTy*>()->front();\n  }\n\n  EltTy back() const {\n    assert(!empty() && \"vector empty\");\n    if (Val.template is<EltTy>())\n      return Val.template get<EltTy>();\n    return Val.template get<VecTy*>()->back();\n  }\n\n  void push_back(EltTy NewVal) {\n    // If we have nothing, add something.\n    if (Val.isNull()) {\n      Val = NewVal;\n      assert(!Val.isNull() && \"Can't add a null value\");\n      return;\n    }\n\n    // If we have a single value, convert to a vector.\n    if (Val.template is<EltTy>()) {\n      EltTy V = Val.template get<EltTy>();\n      Val = new VecTy();\n      Val.template get<VecTy*>()->push_back(V);\n    }\n\n    // Add the new value, we know we have a vector.\n    Val.template get<VecTy*>()->push_back(NewVal);\n  }\n\n  void pop_back() {\n    // If we have a single value, convert to empty.\n    if (Val.template is<EltTy>())\n      Val = (EltTy)nullptr;\n    else if (VecTy *Vec = Val.template get<VecTy*>())\n      Vec->pop_back();\n  }\n\n  void clear() {\n    // If we have a single value, convert to empty.\n    if (Val.template is<EltTy>()) {\n      Val = EltTy();\n    } else if (VecTy *Vec = Val.template dyn_cast<VecTy*>()) {\n      // If we have a vector form, just clear it.\n      Vec->clear();\n    }\n    // Otherwise, we're already empty.\n  }\n\n  iterator erase(iterator I) {\n    assert(I >= begin() && \"Iterator to erase is out of bounds.\");\n    assert(I < end() && \"Erasing at past-the-end iterator.\");\n\n    // If we have a single value, convert to empty.\n    if (Val.template is<EltTy>()) {\n      if (I == begin())\n        Val = EltTy();\n    } else if (VecTy *Vec = Val.template dyn_cast<VecTy*>()) {\n      // multiple items in a vector; just do the erase, there is no\n      // benefit to collapsing back to a pointer\n      return Vec->erase(I);\n    }\n    return end();\n  }\n\n  iterator erase(iterator S, iterator E) {\n    assert(S >= begin() && \"Range to erase is out of bounds.\");\n    assert(S <= E && \"Trying to erase invalid range.\");\n    assert(E <= end() && \"Trying to erase past the end.\");\n\n    if (Val.template is<EltTy>()) {\n      if (S == begin() && S != E)\n        Val = EltTy();\n    } else if (VecTy *Vec = Val.template dyn_cast<VecTy*>()) {\n      return Vec->erase(S, E);\n    }\n    return end();\n  }\n\n  iterator insert(iterator I, const EltTy &Elt) {\n    assert(I >= this->begin() && \"Insertion iterator is out of bounds.\");\n    assert(I <= this->end() && \"Inserting past the end of the vector.\");\n    if (I == end()) {\n      push_back(Elt);\n      return std::prev(end());\n    }\n    assert(!Val.isNull() && \"Null value with non-end insert iterator.\");\n    if (Val.template is<EltTy>()) {\n      EltTy V = Val.template get<EltTy>();\n      assert(I == begin());\n      Val = Elt;\n      push_back(V);\n      return begin();\n    }\n\n    return Val.template get<VecTy*>()->insert(I, Elt);\n  }\n\n  template<typename ItTy>\n  iterator insert(iterator I, ItTy From, ItTy To) {\n    assert(I >= this->begin() && \"Insertion iterator is out of bounds.\");\n    assert(I <= this->end() && \"Inserting past the end of the vector.\");\n    if (From == To)\n      return I;\n\n    // If we have a single value, convert to a vector.\n    ptrdiff_t Offset = I - begin();\n    if (Val.isNull()) {\n      if (std::next(From) == To) {\n        Val = *From;\n        return begin();\n      }\n\n      Val = new VecTy();\n    } else if (Val.template is<EltTy>()) {\n      EltTy V = Val.template get<EltTy>();\n      Val = new VecTy();\n      Val.template get<VecTy*>()->push_back(V);\n    }\n    return Val.template get<VecTy*>()->insert(begin() + Offset, From, To);\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_TINYPTRVECTOR_H\n"}, "56": {"id": 56, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCTargetOptions.h", "content": "//===- MCTargetOptions.h - MC Target Options --------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MCTARGETOPTIONS_H\n#define LLVM_MC_MCTARGETOPTIONS_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include <string>\n#include <vector>\n\nnamespace llvm {\n\nenum class ExceptionHandling {\n  None,     ///< No exception support\n  DwarfCFI, ///< DWARF-like instruction based exceptions\n  SjLj,     ///< setjmp/longjmp based exceptions\n  ARM,      ///< ARM EHABI\n  WinEH,    ///< Windows Exception Handling\n  Wasm,     ///< WebAssembly Exception Handling\n  AIX,      ///< AIX Exception Handling\n};\n\nenum class DebugCompressionType {\n  None, ///< No compression\n  GNU,  ///< zlib-gnu style compression\n  Z,    ///< zlib style complession\n};\n\nclass StringRef;\n\nclass MCTargetOptions {\npublic:\n  enum AsmInstrumentation {\n    AsmInstrumentationNone,\n    AsmInstrumentationAddress\n  };\n\n  bool MCRelaxAll : 1;\n  bool MCNoExecStack : 1;\n  bool MCFatalWarnings : 1;\n  bool MCNoWarn : 1;\n  bool MCNoDeprecatedWarn : 1;\n  bool MCSaveTempLabels : 1;\n  bool MCUseDwarfDirectory : 1;\n  bool MCIncrementalLinkerCompatible : 1;\n  bool ShowMCEncoding : 1;\n  bool ShowMCInst : 1;\n  bool AsmVerbose : 1;\n\n  /// Preserve Comments in Assembly.\n  bool PreserveAsmComments : 1;\n\n  bool Dwarf64 : 1;\n  int DwarfVersion = 0;\n\n  std::string ABIName;\n  std::string AssemblyLanguage;\n  std::string SplitDwarfFile;\n\n  const char *Argv0 = nullptr;\n  ArrayRef<const char *> CommandLineArgs;\n\n  /// Additional paths to search for `.include` directives when using the\n  /// integrated assembler.\n  std::vector<std::string> IASSearchPaths;\n\n  MCTargetOptions();\n\n  /// getABIName - If this returns a non-empty string this represents the\n  /// textual name of the ABI that we want the backend to use, e.g. o32, or\n  /// aapcs-linux.\n  StringRef getABIName() const;\n\n  /// getAssemblyLanguage - If this returns a non-empty string this represents\n  /// the textual name of the assembly language that we will use for this\n  /// target, e.g. masm.\n  StringRef getAssemblyLanguage() const;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_MC_MCTARGETOPTIONS_H\n"}, "62": {"id": 62, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TrailingObjects.h", "content": "//===--- TrailingObjects.h - Variable-length classes ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// This header defines support for implementing classes that have\n/// some trailing object (or arrays of objects) appended to them. The\n/// main purpose is to make it obvious where this idiom is being used,\n/// and to make the usage more idiomatic and more difficult to get\n/// wrong.\n///\n/// The TrailingObject template abstracts away the reinterpret_cast,\n/// pointer arithmetic, and size calculations used for the allocation\n/// and access of appended arrays of objects, and takes care that they\n/// are all allocated at their required alignment. Additionally, it\n/// ensures that the base type is final -- deriving from a class that\n/// expects data appended immediately after it is typically not safe.\n///\n/// Users are expected to derive from this template, and provide\n/// numTrailingObjects implementations for each trailing type except\n/// the last, e.g. like this sample:\n///\n/// \\code\n/// class VarLengthObj : private TrailingObjects<VarLengthObj, int, double> {\n///   friend TrailingObjects;\n///\n///   unsigned NumInts, NumDoubles;\n///   size_t numTrailingObjects(OverloadToken<int>) const { return NumInts; }\n///  };\n/// \\endcode\n///\n/// You can access the appended arrays via 'getTrailingObjects', and\n/// determine the size needed for allocation via\n/// 'additionalSizeToAlloc' and 'totalSizeToAlloc'.\n///\n/// All the methods implemented by this class are are intended for use\n/// by the implementation of the class, not as part of its interface\n/// (thus, private inheritance is suggested).\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_TRAILINGOBJECTS_H\n#define LLVM_SUPPORT_TRAILINGOBJECTS_H\n\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/Alignment.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <new>\n#include <type_traits>\n\nnamespace llvm {\n\nnamespace trailing_objects_internal {\n/// Helper template to calculate the max alignment requirement for a set of\n/// objects.\ntemplate <typename First, typename... Rest> class AlignmentCalcHelper {\nprivate:\n  enum {\n    FirstAlignment = alignof(First),\n    RestAlignment = AlignmentCalcHelper<Rest...>::Alignment,\n  };\n\npublic:\n  enum {\n    Alignment = FirstAlignment > RestAlignment ? FirstAlignment : RestAlignment\n  };\n};\n\ntemplate <typename First> class AlignmentCalcHelper<First> {\npublic:\n  enum { Alignment = alignof(First) };\n};\n\n/// The base class for TrailingObjects* classes.\nclass TrailingObjectsBase {\nprotected:\n  /// OverloadToken's purpose is to allow specifying function overloads\n  /// for different types, without actually taking the types as\n  /// parameters. (Necessary because member function templates cannot\n  /// be specialized, so overloads must be used instead of\n  /// specialization.)\n  template <typename T> struct OverloadToken {};\n};\n\n// Just a little helper for transforming a type pack into the same\n// number of a different type. e.g.:\n//   ExtractSecondType<Foo..., int>::type\ntemplate <typename Ty1, typename Ty2> struct ExtractSecondType {\n  typedef Ty2 type;\n};\n\n// TrailingObjectsImpl is somewhat complicated, because it is a\n// recursively inheriting template, in order to handle the template\n// varargs. Each level of inheritance picks off a single trailing type\n// then recurses on the rest. The \"Align\", \"BaseTy\", and\n// \"TopTrailingObj\" arguments are passed through unchanged through the\n// recursion. \"PrevTy\" is, at each level, the type handled by the\n// level right above it.\n\ntemplate <int Align, typename BaseTy, typename TopTrailingObj, typename PrevTy,\n          typename... MoreTys>\nclass TrailingObjectsImpl {\n  // The main template definition is never used -- the two\n  // specializations cover all possibilities.\n};\n\ntemplate <int Align, typename BaseTy, typename TopTrailingObj, typename PrevTy,\n          typename NextTy, typename... MoreTys>\nclass TrailingObjectsImpl<Align, BaseTy, TopTrailingObj, PrevTy, NextTy,\n                          MoreTys...>\n    : public TrailingObjectsImpl<Align, BaseTy, TopTrailingObj, NextTy,\n                                 MoreTys...> {\n\n  typedef TrailingObjectsImpl<Align, BaseTy, TopTrailingObj, NextTy, MoreTys...>\n      ParentType;\n\n  struct RequiresRealignment {\n    static const bool value = alignof(PrevTy) < alignof(NextTy);\n  };\n\n  static constexpr bool requiresRealignment() {\n    return RequiresRealignment::value;\n  }\n\nprotected:\n  // Ensure the inherited getTrailingObjectsImpl is not hidden.\n  using ParentType::getTrailingObjectsImpl;\n\n  // These two functions are helper functions for\n  // TrailingObjects::getTrailingObjects. They recurse to the left --\n  // the result for each type in the list of trailing types depends on\n  // the result of calling the function on the type to the\n  // left. However, the function for the type to the left is\n  // implemented by a *subclass* of this class, so we invoke it via\n  // the TopTrailingObj, which is, via the\n  // curiously-recurring-template-pattern, the most-derived type in\n  // this recursion, and thus, contains all the overloads.\n  static const NextTy *\n  getTrailingObjectsImpl(const BaseTy *Obj,\n                         TrailingObjectsBase::OverloadToken<NextTy>) {\n    auto *Ptr = TopTrailingObj::getTrailingObjectsImpl(\n                    Obj, TrailingObjectsBase::OverloadToken<PrevTy>()) +\n                TopTrailingObj::callNumTrailingObjects(\n                    Obj, TrailingObjectsBase::OverloadToken<PrevTy>());\n\n    if (requiresRealignment())\n      return reinterpret_cast<const NextTy *>(\n          alignAddr(Ptr, Align::Of<NextTy>()));\n    else\n      return reinterpret_cast<const NextTy *>(Ptr);\n  }\n\n  static NextTy *\n  getTrailingObjectsImpl(BaseTy *Obj,\n                         TrailingObjectsBase::OverloadToken<NextTy>) {\n    auto *Ptr = TopTrailingObj::getTrailingObjectsImpl(\n                    Obj, TrailingObjectsBase::OverloadToken<PrevTy>()) +\n                TopTrailingObj::callNumTrailingObjects(\n                    Obj, TrailingObjectsBase::OverloadToken<PrevTy>());\n\n    if (requiresRealignment())\n      return reinterpret_cast<NextTy *>(alignAddr(Ptr, Align::Of<NextTy>()));\n    else\n      return reinterpret_cast<NextTy *>(Ptr);\n  }\n\n  // Helper function for TrailingObjects::additionalSizeToAlloc: this\n  // function recurses to superclasses, each of which requires one\n  // fewer size_t argument, and adds its own size.\n  static constexpr size_t additionalSizeToAllocImpl(\n      size_t SizeSoFar, size_t Count1,\n      typename ExtractSecondType<MoreTys, size_t>::type... MoreCounts) {\n    return ParentType::additionalSizeToAllocImpl(\n        (requiresRealignment() ? llvm::alignTo<alignof(NextTy)>(SizeSoFar)\n                               : SizeSoFar) +\n            sizeof(NextTy) * Count1,\n        MoreCounts...);\n  }\n};\n\n// The base case of the TrailingObjectsImpl inheritance recursion,\n// when there's no more trailing types.\ntemplate <int Align, typename BaseTy, typename TopTrailingObj, typename PrevTy>\nclass alignas(Align) TrailingObjectsImpl<Align, BaseTy, TopTrailingObj, PrevTy>\n    : public TrailingObjectsBase {\nprotected:\n  // This is a dummy method, only here so the \"using\" doesn't fail --\n  // it will never be called, because this function recurses backwards\n  // up the inheritance chain to subclasses.\n  static void getTrailingObjectsImpl();\n\n  static constexpr size_t additionalSizeToAllocImpl(size_t SizeSoFar) {\n    return SizeSoFar;\n  }\n\n  template <bool CheckAlignment> static void verifyTrailingObjectsAlignment() {}\n};\n\n} // end namespace trailing_objects_internal\n\n// Finally, the main type defined in this file, the one intended for users...\n\n/// See the file comment for details on the usage of the\n/// TrailingObjects type.\ntemplate <typename BaseTy, typename... TrailingTys>\nclass TrailingObjects : private trailing_objects_internal::TrailingObjectsImpl<\n                            trailing_objects_internal::AlignmentCalcHelper<\n                                TrailingTys...>::Alignment,\n                            BaseTy, TrailingObjects<BaseTy, TrailingTys...>,\n                            BaseTy, TrailingTys...> {\n\n  template <int A, typename B, typename T, typename P, typename... M>\n  friend class trailing_objects_internal::TrailingObjectsImpl;\n\n  template <typename... Tys> class Foo {};\n\n  typedef trailing_objects_internal::TrailingObjectsImpl<\n      trailing_objects_internal::AlignmentCalcHelper<TrailingTys...>::Alignment,\n      BaseTy, TrailingObjects<BaseTy, TrailingTys...>, BaseTy, TrailingTys...>\n      ParentType;\n  using TrailingObjectsBase = trailing_objects_internal::TrailingObjectsBase;\n\n  using ParentType::getTrailingObjectsImpl;\n\n  // This function contains only a static_assert BaseTy is final. The\n  // static_assert must be in a function, and not at class-level\n  // because BaseTy isn't complete at class instantiation time, but\n  // will be by the time this function is instantiated.\n  static void verifyTrailingObjectsAssertions() {\n    static_assert(std::is_final<BaseTy>(), \"BaseTy must be final.\");\n  }\n\n  // These two methods are the base of the recursion for this method.\n  static const BaseTy *\n  getTrailingObjectsImpl(const BaseTy *Obj,\n                         TrailingObjectsBase::OverloadToken<BaseTy>) {\n    return Obj;\n  }\n\n  static BaseTy *\n  getTrailingObjectsImpl(BaseTy *Obj,\n                         TrailingObjectsBase::OverloadToken<BaseTy>) {\n    return Obj;\n  }\n\n  // callNumTrailingObjects simply calls numTrailingObjects on the\n  // provided Obj -- except when the type being queried is BaseTy\n  // itself. There is always only one of the base object, so that case\n  // is handled here. (An additional benefit of indirecting through\n  // this function is that consumers only say \"friend\n  // TrailingObjects\", and thus, only this class itself can call the\n  // numTrailingObjects function.)\n  static size_t\n  callNumTrailingObjects(const BaseTy *Obj,\n                         TrailingObjectsBase::OverloadToken<BaseTy>) {\n    return 1;\n  }\n\n  template <typename T>\n  static size_t callNumTrailingObjects(const BaseTy *Obj,\n                                       TrailingObjectsBase::OverloadToken<T>) {\n    return Obj->numTrailingObjects(TrailingObjectsBase::OverloadToken<T>());\n  }\n\npublic:\n  // Make this (privately inherited) member public.\n#ifndef _MSC_VER\n  using ParentType::OverloadToken;\n#else\n  // An MSVC bug prevents the above from working, (last tested at CL version\n  // 19.28). \"Class5\" in TrailingObjectsTest.cpp tests the problematic case.\n  template <typename T>\n  using OverloadToken = typename ParentType::template OverloadToken<T>;\n#endif\n\n  /// Returns a pointer to the trailing object array of the given type\n  /// (which must be one of those specified in the class template). The\n  /// array may have zero or more elements in it.\n  template <typename T> const T *getTrailingObjects() const {\n    verifyTrailingObjectsAssertions();\n    // Forwards to an impl function with overloads, since member\n    // function templates can't be specialized.\n    return this->getTrailingObjectsImpl(\n        static_cast<const BaseTy *>(this),\n        TrailingObjectsBase::OverloadToken<T>());\n  }\n\n  /// Returns a pointer to the trailing object array of the given type\n  /// (which must be one of those specified in the class template). The\n  /// array may have zero or more elements in it.\n  template <typename T> T *getTrailingObjects() {\n    verifyTrailingObjectsAssertions();\n    // Forwards to an impl function with overloads, since member\n    // function templates can't be specialized.\n    return this->getTrailingObjectsImpl(\n        static_cast<BaseTy *>(this), TrailingObjectsBase::OverloadToken<T>());\n  }\n\n  /// Returns the size of the trailing data, if an object were\n  /// allocated with the given counts (The counts are in the same order\n  /// as the template arguments). This does not include the size of the\n  /// base object.  The template arguments must be the same as those\n  /// used in the class; they are supplied here redundantly only so\n  /// that it's clear what the counts are counting in callers.\n  template <typename... Tys>\n  static constexpr std::enable_if_t<\n      std::is_same<Foo<TrailingTys...>, Foo<Tys...>>::value, size_t>\n  additionalSizeToAlloc(typename trailing_objects_internal::ExtractSecondType<\n                        TrailingTys, size_t>::type... Counts) {\n    return ParentType::additionalSizeToAllocImpl(0, Counts...);\n  }\n\n  /// Returns the total size of an object if it were allocated with the\n  /// given trailing object counts. This is the same as\n  /// additionalSizeToAlloc, except it *does* include the size of the base\n  /// object.\n  template <typename... Tys>\n  static constexpr std::enable_if_t<\n      std::is_same<Foo<TrailingTys...>, Foo<Tys...>>::value, size_t>\n  totalSizeToAlloc(typename trailing_objects_internal::ExtractSecondType<\n                   TrailingTys, size_t>::type... Counts) {\n    return sizeof(BaseTy) + ParentType::additionalSizeToAllocImpl(0, Counts...);\n  }\n\n  TrailingObjects() = default;\n  TrailingObjects(const TrailingObjects &) = delete;\n  TrailingObjects(TrailingObjects &&) = delete;\n  TrailingObjects &operator=(const TrailingObjects &) = delete;\n  TrailingObjects &operator=(TrailingObjects &&) = delete;\n\n  /// A type where its ::with_counts template member has a ::type member\n  /// suitable for use as uninitialized storage for an object with the given\n  /// trailing object counts. The template arguments are similar to those\n  /// of additionalSizeToAlloc.\n  ///\n  /// Use with FixedSizeStorageOwner, e.g.:\n  ///\n  /// \\code{.cpp}\n  ///\n  /// MyObj::FixedSizeStorage<void *>::with_counts<1u>::type myStackObjStorage;\n  /// MyObj::FixedSizeStorageOwner\n  ///     myStackObjOwner(new ((void *)&myStackObjStorage) MyObj);\n  /// MyObj *const myStackObjPtr = myStackObjOwner.get();\n  ///\n  /// \\endcode\n  template <typename... Tys> struct FixedSizeStorage {\n    template <size_t... Counts> struct with_counts {\n      enum { Size = totalSizeToAlloc<Tys...>(Counts...) };\n      struct type {\n        alignas(BaseTy) char buffer[Size];\n      };\n    };\n  };\n\n  /// A type that acts as the owner for an object placed into fixed storage.\n  class FixedSizeStorageOwner {\n  public:\n    FixedSizeStorageOwner(BaseTy *p) : p(p) {}\n    ~FixedSizeStorageOwner() {\n      assert(p && \"FixedSizeStorageOwner owns null?\");\n      p->~BaseTy();\n    }\n\n    BaseTy *get() { return p; }\n    const BaseTy *get() const { return p; }\n\n  private:\n    FixedSizeStorageOwner(const FixedSizeStorageOwner &) = delete;\n    FixedSizeStorageOwner(FixedSizeStorageOwner &&) = delete;\n    FixedSizeStorageOwner &operator=(const FixedSizeStorageOwner &) = delete;\n    FixedSizeStorageOwner &operator=(FixedSizeStorageOwner &&) = delete;\n\n    BaseTy *const p;\n  };\n};\n\n} // end namespace llvm\n\n#endif\n"}, "63": {"id": 63, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TypeSize.h", "content": "//===- TypeSize.h - Wrapper around type sizes -------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file provides a struct that can be used to query the size of IR types\n// which may be scalable vectors. It provides convenience operators so that\n// it can be used in much the same way as a single scalar value.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_TYPESIZE_H\n#define LLVM_SUPPORT_TYPESIZE_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/WithColor.h\"\n\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <type_traits>\n\nnamespace llvm {\n\ntemplate <typename LeafTy> struct LinearPolyBaseTypeTraits {};\n\n//===----------------------------------------------------------------------===//\n// LinearPolyBase - a base class for linear polynomials with multiple\n// dimensions. This can e.g. be used to describe offsets that are have both a\n// fixed and scalable component.\n//===----------------------------------------------------------------------===//\n\n/// LinearPolyBase describes a linear polynomial:\n///  c0 * scale0 + c1 * scale1 + ... + cK * scaleK\n/// where the scale is implicit, so only the coefficients are encoded.\ntemplate <typename LeafTy>\nclass LinearPolyBase {\npublic:\n  using ScalarTy = typename LinearPolyBaseTypeTraits<LeafTy>::ScalarTy;\n  static constexpr auto Dimensions = LinearPolyBaseTypeTraits<LeafTy>::Dimensions;\n  static_assert(Dimensions != std::numeric_limits<unsigned>::max(),\n                \"Dimensions out of range\");\n\nprivate:\n  std::array<ScalarTy, Dimensions> Coefficients;\n\nprotected:\n  LinearPolyBase(ArrayRef<ScalarTy> Values) {\n    std::copy(Values.begin(), Values.end(), Coefficients.begin());\n  }\n\npublic:\n  friend LeafTy &operator+=(LeafTy &LHS, const LeafTy &RHS) {\n    for (unsigned I=0; I<Dimensions; ++I)\n      LHS.Coefficients[I] += RHS.Coefficients[I];\n    return LHS;\n  }\n\n  friend LeafTy &operator-=(LeafTy &LHS, const LeafTy &RHS) {\n    for (unsigned I=0; I<Dimensions; ++I)\n      LHS.Coefficients[I] -= RHS.Coefficients[I];\n    return LHS;\n  }\n\n  friend LeafTy &operator*=(LeafTy &LHS, ScalarTy RHS) {\n    for (auto &C : LHS.Coefficients)\n      C *= RHS;\n    return LHS;\n  }\n\n  friend LeafTy operator+(const LeafTy &LHS, const LeafTy &RHS) {\n    LeafTy Copy = LHS;\n    return Copy += RHS;\n  }\n\n  friend LeafTy operator-(const LeafTy &LHS, const LeafTy &RHS) {\n    LeafTy Copy = LHS;\n    return Copy -= RHS;\n  }\n\n  friend LeafTy operator*(const LeafTy &LHS, ScalarTy RHS) {\n    LeafTy Copy = LHS;\n    return Copy *= RHS;\n  }\n\n  template <typename U = ScalarTy>\n  friend typename std::enable_if_t<std::is_signed<U>::value, LeafTy>\n  operator-(const LeafTy &LHS) {\n    LeafTy Copy = LHS;\n    return Copy *= -1;\n  }\n\n  bool operator==(const LinearPolyBase &RHS) const {\n    return std::equal(Coefficients.begin(), Coefficients.end(),\n                      RHS.Coefficients.begin());\n  }\n\n  bool operator!=(const LinearPolyBase &RHS) const {\n    return !(*this == RHS);\n  }\n\n  bool isZero() const {\n    return all_of(Coefficients, [](const ScalarTy &C) { return C == 0; });\n  }\n  bool isNonZero() const { return !isZero(); }\n  explicit operator bool() const { return isNonZero(); }\n\n  ScalarTy getValue(unsigned Dim) const { return Coefficients[Dim]; }\n};\n\n//===----------------------------------------------------------------------===//\n// StackOffset - Represent an offset with named fixed and scalable components.\n//===----------------------------------------------------------------------===//\n\nclass StackOffset;\ntemplate <> struct LinearPolyBaseTypeTraits<StackOffset> {\n  using ScalarTy = int64_t;\n  static constexpr unsigned Dimensions = 2;\n};\n\n/// StackOffset is a class to represent an offset with 2 dimensions,\n/// named fixed and scalable, respectively. This class allows a value for both\n/// dimensions to depict e.g. \"8 bytes and 16 scalable bytes\", which is needed\n/// to represent stack offsets.\nclass StackOffset : public LinearPolyBase<StackOffset> {\nprotected:\n  StackOffset(ScalarTy Fixed, ScalarTy Scalable)\n      : LinearPolyBase<StackOffset>({Fixed, Scalable}) {}\n\npublic:\n  StackOffset() : StackOffset({0, 0}) {}\n  StackOffset(const LinearPolyBase<StackOffset> &Other)\n      : LinearPolyBase<StackOffset>(Other) {}\n  static StackOffset getFixed(ScalarTy Fixed) { return {Fixed, 0}; }\n  static StackOffset getScalable(ScalarTy Scalable) { return {0, Scalable}; }\n  static StackOffset get(ScalarTy Fixed, ScalarTy Scalable) {\n    return {Fixed, Scalable};\n  }\n\n  ScalarTy getFixed() const { return this->getValue(0); }\n  ScalarTy getScalable() const { return this->getValue(1); }\n};\n\n//===----------------------------------------------------------------------===//\n// UnivariateLinearPolyBase - a base class for linear polynomials with multiple\n// dimensions, but where only one dimension can be set at any time.\n// This can e.g. be used to describe sizes that are either fixed or scalable.\n//===----------------------------------------------------------------------===//\n\n/// UnivariateLinearPolyBase is a base class for ElementCount and TypeSize.\n/// Like LinearPolyBase it tries to represent a linear polynomial\n/// where only one dimension can be set at any time, e.g.\n///   0 * scale0 + 0 * scale1 + ... + cJ * scaleJ + ... + 0 * scaleK\n/// The dimension that is set is the univariate dimension.\ntemplate <typename LeafTy>\nclass UnivariateLinearPolyBase {\npublic:\n  using ScalarTy = typename LinearPolyBaseTypeTraits<LeafTy>::ScalarTy;\n  static constexpr auto Dimensions = LinearPolyBaseTypeTraits<LeafTy>::Dimensions;\n  static_assert(Dimensions != std::numeric_limits<unsigned>::max(),\n                \"Dimensions out of range\");\n\nprotected:\n  ScalarTy Value;         // The value at the univeriate dimension.\n  unsigned UnivariateDim; // The univeriate dimension.\n\n  UnivariateLinearPolyBase(ScalarTy Val, unsigned UnivariateDim)\n      : Value(Val), UnivariateDim(UnivariateDim) {\n    assert(UnivariateDim < Dimensions && \"Dimension out of range\");\n  }\n\n  friend LeafTy &operator+=(LeafTy &LHS, const LeafTy &RHS) {\n    assert(LHS.UnivariateDim == RHS.UnivariateDim && \"Invalid dimensions\");\n    LHS.Value += RHS.Value;\n    return LHS;\n  }\n\n  friend LeafTy &operator-=(LeafTy &LHS, const LeafTy &RHS) {\n    assert(LHS.UnivariateDim == RHS.UnivariateDim && \"Invalid dimensions\");\n    LHS.Value -= RHS.Value;\n    return LHS;\n  }\n\n  friend LeafTy &operator*=(LeafTy &LHS, ScalarTy RHS) {\n    LHS.Value *= RHS;\n    return LHS;\n  }\n\n  friend LeafTy operator+(const LeafTy &LHS, const LeafTy &RHS) {\n    LeafTy Copy = LHS;\n    return Copy += RHS;\n  }\n\n  friend LeafTy operator-(const LeafTy &LHS, const LeafTy &RHS) {\n    LeafTy Copy = LHS;\n    return Copy -= RHS;\n  }\n\n  friend LeafTy operator*(const LeafTy &LHS, ScalarTy RHS) {\n    LeafTy Copy = LHS;\n    return Copy *= RHS;\n  }\n\n  template <typename U = ScalarTy>\n  friend typename std::enable_if<std::is_signed<U>::value, LeafTy>::type\n  operator-(const LeafTy &LHS) {\n    LeafTy Copy = LHS;\n    return Copy *= -1;\n  }\n\npublic:\n  bool operator==(const UnivariateLinearPolyBase &RHS) const {\n    return Value == RHS.Value && UnivariateDim == RHS.UnivariateDim;\n  }\n\n  bool operator!=(const UnivariateLinearPolyBase &RHS) const {\n    return !(*this == RHS);\n  }\n\n  bool isZero() const { return !Value; }\n  bool isNonZero() const { return !isZero(); }\n  explicit operator bool() const { return isNonZero(); }\n  ScalarTy getValue() const { return Value; }\n  ScalarTy getValue(unsigned Dim) const {\n    return Dim == UnivariateDim ? Value : 0;\n  }\n\n  /// Add \\p RHS to the value at the univariate dimension.\n  LeafTy getWithIncrement(ScalarTy RHS) const {\n    return static_cast<LeafTy>(\n        UnivariateLinearPolyBase(Value + RHS, UnivariateDim));\n  }\n\n  /// Subtract \\p RHS from the value at the univariate dimension.\n  LeafTy getWithDecrement(ScalarTy RHS) const {\n    return static_cast<LeafTy>(\n        UnivariateLinearPolyBase(Value - RHS, UnivariateDim));\n  }\n};\n\n\n//===----------------------------------------------------------------------===//\n// LinearPolySize - base class for fixed- or scalable sizes.\n//  ^  ^ \n//  |  |\n//  |  +----- ElementCount - Leaf class to represent an element count\n//  |                        (vscale x unsigned)\n//  |\n//  +-------- TypeSize - Leaf class to represent a type size\n//                       (vscale x uint64_t)\n//===----------------------------------------------------------------------===//\n\n/// LinearPolySize is a base class to represent sizes. It is either\n/// fixed-sized or it is scalable-sized, but it cannot be both.\ntemplate <typename LeafTy>\nclass LinearPolySize : public UnivariateLinearPolyBase<LeafTy> {\n  // Make the parent class a friend, so that it can access the protected\n  // conversion/copy-constructor for UnivariatePolyBase<LeafTy> ->\n  // LinearPolySize<LeafTy>.\n  friend class UnivariateLinearPolyBase<LeafTy>;\n\npublic:\n  using ScalarTy = typename UnivariateLinearPolyBase<LeafTy>::ScalarTy;\n  enum Dims : unsigned { FixedDim = 0, ScalableDim = 1 };\n\nprotected:\n  LinearPolySize(ScalarTy MinVal, Dims D)\n      : UnivariateLinearPolyBase<LeafTy>(MinVal, D) {}\n\n  LinearPolySize(const UnivariateLinearPolyBase<LeafTy> &V)\n      : UnivariateLinearPolyBase<LeafTy>(V) {}\n\npublic:\n\n  static LeafTy getFixed(ScalarTy MinVal) {\n    return static_cast<LeafTy>(LinearPolySize(MinVal, FixedDim));\n  }\n  static LeafTy getScalable(ScalarTy MinVal) {\n    return static_cast<LeafTy>(LinearPolySize(MinVal, ScalableDim));\n  }\n  static LeafTy get(ScalarTy MinVal, bool Scalable) {\n    return static_cast<LeafTy>(\n        LinearPolySize(MinVal, Scalable ? ScalableDim : FixedDim));\n  }\n  static LeafTy getNull() { return get(0, false); }\n\n  /// Returns the minimum value this size can represent.\n  ScalarTy getKnownMinValue() const { return this->getValue(); }\n  /// Returns whether the size is scaled by a runtime quantity (vscale).\n  bool isScalable() const { return this->UnivariateDim == ScalableDim; }\n  /// A return value of true indicates we know at compile time that the number\n  /// of elements (vscale * Min) is definitely even. However, returning false\n  /// does not guarantee that the total number of elements is odd.\n  bool isKnownEven() const { return (getKnownMinValue() & 0x1) == 0; }\n  /// This function tells the caller whether the element count is known at\n  /// compile time to be a multiple of the scalar value RHS.\n  bool isKnownMultipleOf(ScalarTy RHS) const {\n    return getKnownMinValue() % RHS == 0;\n  }\n\n  // Return the minimum value with the assumption that the count is exact.\n  // Use in places where a scalable count doesn't make sense (e.g. non-vector\n  // types, or vectors in backends which don't support scalable vectors).\n  ScalarTy getFixedValue() const {\n    assert(!isScalable() &&\n           \"Request for a fixed element count on a scalable object\");\n    return getKnownMinValue();\n  }\n\n  // For some cases, size ordering between scalable and fixed size types cannot\n  // be determined at compile time, so such comparisons aren't allowed.\n  //\n  // e.g. <vscale x 2 x i16> could be bigger than <4 x i32> with a runtime\n  // vscale >= 5, equal sized with a vscale of 4, and smaller with\n  // a vscale <= 3.\n  //\n  // All the functions below make use of the fact vscale is always >= 1, which\n  // means that <vscale x 4 x i32> is guaranteed to be >= <4 x i32>, etc.\n\n  static bool isKnownLT(const LinearPolySize &LHS, const LinearPolySize &RHS) {\n    if (!LHS.isScalable() || RHS.isScalable())\n      return LHS.getKnownMinValue() < RHS.getKnownMinValue();\n    return false;\n  }\n\n  static bool isKnownGT(const LinearPolySize &LHS, const LinearPolySize &RHS) {\n    if (LHS.isScalable() || !RHS.isScalable())\n      return LHS.getKnownMinValue() > RHS.getKnownMinValue();\n    return false;\n  }\n\n  static bool isKnownLE(const LinearPolySize &LHS, const LinearPolySize &RHS) {\n    if (!LHS.isScalable() || RHS.isScalable())\n      return LHS.getKnownMinValue() <= RHS.getKnownMinValue();\n    return false;\n  }\n\n  static bool isKnownGE(const LinearPolySize &LHS, const LinearPolySize &RHS) {\n    if (LHS.isScalable() || !RHS.isScalable())\n      return LHS.getKnownMinValue() >= RHS.getKnownMinValue();\n    return false;\n  }\n\n  /// We do not provide the '/' operator here because division for polynomial\n  /// types does not work in the same way as for normal integer types. We can\n  /// only divide the minimum value (or coefficient) by RHS, which is not the\n  /// same as\n  ///   (Min * Vscale) / RHS\n  /// The caller is recommended to use this function in combination with\n  /// isKnownMultipleOf(RHS), which lets the caller know if it's possible to\n  /// perform a lossless divide by RHS.\n  LeafTy divideCoefficientBy(ScalarTy RHS) const {\n    return static_cast<LeafTy>(\n        LinearPolySize::get(getKnownMinValue() / RHS, isScalable()));\n  }\n\n  LeafTy coefficientNextPowerOf2() const {\n    return static_cast<LeafTy>(LinearPolySize::get(\n        static_cast<ScalarTy>(llvm::NextPowerOf2(getKnownMinValue())),\n        isScalable()));\n  }\n\n  /// Printing function.\n  void print(raw_ostream &OS) const {\n    if (isScalable())\n      OS << \"vscale x \";\n    OS << getKnownMinValue();\n  }\n};\n\nclass ElementCount;\ntemplate <> struct LinearPolyBaseTypeTraits<ElementCount> {\n  using ScalarTy = unsigned;\n  static constexpr unsigned Dimensions = 2;\n};\n\nclass ElementCount : public LinearPolySize<ElementCount> {\npublic:\n  ElementCount() : LinearPolySize(LinearPolySize::getNull()) {}\n\n  ElementCount(const LinearPolySize<ElementCount> &V) : LinearPolySize(V) {}\n\n  /// Counting predicates.\n  ///\n  ///@{ Number of elements..\n  /// Exactly one element.\n  bool isScalar() const { return !isScalable() && getKnownMinValue() == 1; }\n  /// One or more elements.\n  bool isVector() const {\n    return (isScalable() && getKnownMinValue() != 0) || getKnownMinValue() > 1;\n  }\n  ///@}\n};\n\n// This class is used to represent the size of types. If the type is of fixed\nclass TypeSize;\ntemplate <> struct LinearPolyBaseTypeTraits<TypeSize> {\n  using ScalarTy = uint64_t;\n  static constexpr unsigned Dimensions = 2;\n};\n\n// TODO: Most functionality in this class will gradually be phased out\n// so it will resemble LinearPolySize as much as possible.\n//\n// TypeSize is used to represent the size of types. If the type is of fixed\n// size, it will represent the exact size. If the type is a scalable vector,\n// it will represent the known minimum size.\nclass TypeSize : public LinearPolySize<TypeSize> {\npublic:\n  TypeSize(const LinearPolySize<TypeSize> &V) : LinearPolySize(V) {}\n  TypeSize(ScalarTy MinVal, bool IsScalable)\n      : LinearPolySize(LinearPolySize::get(MinVal, IsScalable)) {}\n\n  static TypeSize Fixed(ScalarTy MinVal) { return TypeSize(MinVal, false); }\n  static TypeSize Scalable(ScalarTy MinVal) { return TypeSize(MinVal, true); }\n\n  ScalarTy getFixedSize() const { return getFixedValue(); }\n  ScalarTy getKnownMinSize() const { return getKnownMinValue(); }\n\n  // All code for this class below this point is needed because of the\n  // temporary implicit conversion to uint64_t. The operator overloads are\n  // needed because otherwise the conversion of the parent class\n  // UnivariateLinearPolyBase -> TypeSize is ambiguous.\n  // TODO: Remove the implicit conversion.\n\n  // Casts to a uint64_t if this is a fixed-width size.\n  //\n  // This interface is deprecated and will be removed in a future version\n  // of LLVM in favour of upgrading uses that rely on this implicit conversion\n  // to uint64_t. Calls to functions that return a TypeSize should use the\n  // proper interfaces to TypeSize.\n  // In practice this is mostly calls to MVT/EVT::getSizeInBits().\n  //\n  // To determine how to upgrade the code:\n  //\n  //   if (<algorithm works for both scalable and fixed-width vectors>)\n  //     use getKnownMinValue()\n  //   else if (<algorithm works only for fixed-width vectors>) {\n  //     if <algorithm can be adapted for both scalable and fixed-width vectors>\n  //       update the algorithm and use getKnownMinValue()\n  //     else\n  //       bail out early for scalable vectors and use getFixedValue()\n  //   }\n  operator ScalarTy() const {\n#ifdef STRICT_FIXED_SIZE_VECTORS\n    return getFixedValue();\n#else\n    if (isScalable())\n      WithColor::warning() << \"Compiler has made implicit assumption that \"\n                              \"TypeSize is not scalable. This may or may not \"\n                              \"lead to broken code.\\n\";\n    return getKnownMinValue();\n#endif\n  }\n\n  // Additional operators needed to avoid ambiguous parses\n  // because of the implicit conversion hack.\n  friend TypeSize operator*(const TypeSize &LHS, const int RHS) {\n    return LHS * (ScalarTy)RHS;\n  }\n  friend TypeSize operator*(const TypeSize &LHS, const unsigned RHS) {\n    return LHS * (ScalarTy)RHS;\n  }\n  friend TypeSize operator*(const TypeSize &LHS, const int64_t RHS) {\n    return LHS * (ScalarTy)RHS;\n  }\n  friend TypeSize operator*(const int LHS, const TypeSize &RHS) {\n    return RHS * LHS;\n  }\n  friend TypeSize operator*(const unsigned LHS, const TypeSize &RHS) {\n    return RHS * LHS;\n  }\n  friend TypeSize operator*(const int64_t LHS, const TypeSize &RHS) {\n    return RHS * LHS;\n  }\n  friend TypeSize operator*(const uint64_t LHS, const TypeSize &RHS) {\n    return RHS * LHS;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Utilities\n//===----------------------------------------------------------------------===//\n\n/// Returns a TypeSize with a known minimum size that is the next integer\n/// (mod 2**64) that is greater than or equal to \\p Value and is a multiple\n/// of \\p Align. \\p Align must be non-zero.\n///\n/// Similar to the alignTo functions in MathExtras.h\ninline TypeSize alignTo(TypeSize Size, uint64_t Align) {\n  assert(Align != 0u && \"Align must be non-zero\");\n  return {(Size.getKnownMinValue() + Align - 1) / Align * Align,\n          Size.isScalable()};\n}\n\n/// Stream operator function for `LinearPolySize`.\ntemplate <typename LeafTy>\ninline raw_ostream &operator<<(raw_ostream &OS,\n                               const LinearPolySize<LeafTy> &PS) {\n  PS.print(OS);\n  return OS;\n}\n\ntemplate <typename T> struct DenseMapInfo;\ntemplate <> struct DenseMapInfo<ElementCount> {\n  static inline ElementCount getEmptyKey() {\n    return ElementCount::getScalable(~0U);\n  }\n  static inline ElementCount getTombstoneKey() {\n    return ElementCount::getFixed(~0U - 1);\n  }\n  static unsigned getHashValue(const ElementCount &EltCnt) {\n    unsigned HashVal = EltCnt.getKnownMinValue() * 37U;\n    if (EltCnt.isScalable())\n      return (HashVal - 1U);\n\n    return HashVal;\n  }\n\n  static bool isEqual(const ElementCount &LHS, const ElementCount &RHS) {\n    return LHS == RHS;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_TYPESIZE_H\n"}, "66": {"id": 66, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Target/TargetOptions.h", "content": "//===-- llvm/Target/TargetOptions.h - Target Options ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines command line option flags that are shared across various\n// targets.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TARGET_TARGETOPTIONS_H\n#define LLVM_TARGET_TARGETOPTIONS_H\n\n#include \"llvm/ADT/FloatingPointMode.h\"\n#include \"llvm/MC/MCTargetOptions.h\"\n\n#include <memory>\n\nnamespace llvm {\n  struct fltSemantics;\n  class MachineFunction;\n  class MemoryBuffer;\n\n  namespace FloatABI {\n    enum ABIType {\n      Default, // Target-specific (either soft or hard depending on triple, etc).\n      Soft,    // Soft float.\n      Hard     // Hard float.\n    };\n  }\n\n  namespace FPOpFusion {\n    enum FPOpFusionMode {\n      Fast,     // Enable fusion of FP ops wherever it's profitable.\n      Standard, // Only allow fusion of 'blessed' ops (currently just fmuladd).\n      Strict    // Never fuse FP-ops.\n    };\n  }\n\n  namespace JumpTable {\n    enum JumpTableType {\n      Single,          // Use a single table for all indirect jumptable calls.\n      Arity,           // Use one table per number of function parameters.\n      Simplified,      // Use one table per function type, with types projected\n                       // into 4 types: pointer to non-function, struct,\n                       // primitive, and function pointer.\n      Full             // Use one table per unique function type\n    };\n  }\n\n  namespace ThreadModel {\n    enum Model {\n      POSIX,  // POSIX Threads\n      Single  // Single Threaded Environment\n    };\n  }\n\n  enum class BasicBlockSection {\n    All,    // Use Basic Block Sections for all basic blocks.  A section\n            // for every basic block can significantly bloat object file sizes.\n    List,   // Get list of functions & BBs from a file. Selectively enables\n            // basic block sections for a subset of basic blocks which can be\n            // used to control object size bloats from creating sections.\n    Labels, // Do not use Basic Block Sections but label basic blocks.  This\n            // is useful when associating profile counts from virtual addresses\n            // to basic blocks.\n    Preset, // Similar to list but the blocks are identified by passes which\n            // seek to use Basic Block Sections, e.g. MachineFunctionSplitter.\n            // This option cannot be set via the command line.\n    None    // Do not use Basic Block Sections.\n  };\n\n  enum class StackProtectorGuards {\n    None,\n    TLS,\n    Global\n  };\n\n  enum class EABI {\n    Unknown,\n    Default, // Default means not specified\n    EABI4,   // Target-specific (either 4, 5 or gnu depending on triple).\n    EABI5,\n    GNU\n  };\n\n  /// Identify a debugger for \"tuning\" the debug info.\n  ///\n  /// The \"debugger tuning\" concept allows us to present a more intuitive\n  /// interface that unpacks into different sets of defaults for the various\n  /// individual feature-flag settings, that suit the preferences of the\n  /// various debuggers.  However, it's worth remembering that debuggers are\n  /// not the only consumers of debug info, and some variations in DWARF might\n  /// better be treated as target/platform issues. Fundamentally,\n  /// o if the feature is useful (or not) to a particular debugger, regardless\n  ///   of the target, that's a tuning decision;\n  /// o if the feature is useful (or not) on a particular platform, regardless\n  ///   of the debugger, that's a target decision.\n  /// It's not impossible to see both factors in some specific case.\n  ///\n  /// The \"tuning\" should be used to set defaults for individual feature flags\n  /// in DwarfDebug; if a given feature has a more specific command-line option,\n  /// that option should take precedence over the tuning.\n  enum class DebuggerKind {\n    Default,  // No specific tuning requested.\n    GDB,      // Tune debug info for gdb.\n    LLDB,     // Tune debug info for lldb.\n    SCE       // Tune debug info for SCE targets (e.g. PS4).\n  };\n\n  /// Enable abort calls when global instruction selection fails to lower/select\n  /// an instruction.\n  enum class GlobalISelAbortMode {\n    Disable,        // Disable the abort.\n    Enable,         // Enable the abort.\n    DisableWithDiag // Disable the abort but emit a diagnostic on failure.\n  };\n\n  class TargetOptions {\n  public:\n    TargetOptions()\n        : UnsafeFPMath(false), NoInfsFPMath(false), NoNaNsFPMath(false),\n          NoTrappingFPMath(true), NoSignedZerosFPMath(false),\n          EnableAIXExtendedAltivecABI(false),\n          HonorSignDependentRoundingFPMathOption(false), NoZerosInBSS(false),\n          GuaranteedTailCallOpt(false), StackSymbolOrdering(true),\n          EnableFastISel(false), EnableGlobalISel(false), UseInitArray(false),\n          DisableIntegratedAS(false), RelaxELFRelocations(false),\n          FunctionSections(false), DataSections(false),\n          IgnoreXCOFFVisibility(false), XCOFFTracebackTable(true),\n          UniqueSectionNames(true), UniqueBasicBlockSectionNames(false),\n          TrapUnreachable(false), NoTrapAfterNoreturn(false), TLSSize(0),\n          EmulatedTLS(false), ExplicitEmulatedTLS(false), EnableIPRA(false),\n          EmitStackSizeSection(false), EnableMachineOutliner(false),\n          EnableMachineFunctionSplitter(false), SupportsDefaultOutlining(false),\n          EmitAddrsig(false), EmitCallSiteInfo(false),\n          SupportsDebugEntryValues(false), EnableDebugEntryValues(false),\n          PseudoProbeForProfiling(false), ValueTrackingVariableLocations(false),\n          ForceDwarfFrameSection(false), XRayOmitFunctionIndex(false),\n          FPDenormalMode(DenormalMode::IEEE, DenormalMode::IEEE) {}\n\n    /// DisableFramePointerElim - This returns true if frame pointer elimination\n    /// optimization should be disabled for the given machine function.\n    bool DisableFramePointerElim(const MachineFunction &MF) const;\n\n    /// If greater than 0, override the default value of\n    /// MCAsmInfo::BinutilsVersion.\n    std::pair<int, int> BinutilsVersion{0, 0};\n\n    /// UnsafeFPMath - This flag is enabled when the\n    /// -enable-unsafe-fp-math flag is specified on the command line.  When\n    /// this flag is off (the default), the code generator is not allowed to\n    /// produce results that are \"less precise\" than IEEE allows.  This includes\n    /// use of X86 instructions like FSIN and FCOS instead of libcalls.\n    unsigned UnsafeFPMath : 1;\n\n    /// NoInfsFPMath - This flag is enabled when the\n    /// -enable-no-infs-fp-math flag is specified on the command line. When\n    /// this flag is off (the default), the code generator is not allowed to\n    /// assume the FP arithmetic arguments and results are never +-Infs.\n    unsigned NoInfsFPMath : 1;\n\n    /// NoNaNsFPMath - This flag is enabled when the\n    /// -enable-no-nans-fp-math flag is specified on the command line. When\n    /// this flag is off (the default), the code generator is not allowed to\n    /// assume the FP arithmetic arguments and results are never NaNs.\n    unsigned NoNaNsFPMath : 1;\n\n    /// NoTrappingFPMath - This flag is enabled when the\n    /// -enable-no-trapping-fp-math is specified on the command line. This\n    /// specifies that there are no trap handlers to handle exceptions.\n    unsigned NoTrappingFPMath : 1;\n\n    /// NoSignedZerosFPMath - This flag is enabled when the\n    /// -enable-no-signed-zeros-fp-math is specified on the command line. This\n    /// specifies that optimizations are allowed to treat the sign of a zero\n    /// argument or result as insignificant.\n    unsigned NoSignedZerosFPMath : 1;\n\n    /// EnableAIXExtendedAltivecABI - This flag returns true when -vec-extabi is\n    /// specified. The code generator is then able to use both volatile and\n    /// nonvolitle vector regisers. When false, the code generator only uses\n    /// volatile vector registers which is the default setting on AIX.\n    unsigned EnableAIXExtendedAltivecABI : 1;\n\n    /// HonorSignDependentRoundingFPMath - This returns true when the\n    /// -enable-sign-dependent-rounding-fp-math is specified.  If this returns\n    /// false (the default), the code generator is allowed to assume that the\n    /// rounding behavior is the default (round-to-zero for all floating point\n    /// to integer conversions, and round-to-nearest for all other arithmetic\n    /// truncations).  If this is enabled (set to true), the code generator must\n    /// assume that the rounding mode may dynamically change.\n    unsigned HonorSignDependentRoundingFPMathOption : 1;\n    bool HonorSignDependentRoundingFPMath() const;\n\n    /// NoZerosInBSS - By default some codegens place zero-initialized data to\n    /// .bss section. This flag disables such behaviour (necessary, e.g. for\n    /// crt*.o compiling).\n    unsigned NoZerosInBSS : 1;\n\n    /// GuaranteedTailCallOpt - This flag is enabled when -tailcallopt is\n    /// specified on the commandline. When the flag is on, participating targets\n    /// will perform tail call optimization on all calls which use the fastcc\n    /// calling convention and which satisfy certain target-independent\n    /// criteria (being at the end of a function, having the same return type\n    /// as their parent function, etc.), using an alternate ABI if necessary.\n    unsigned GuaranteedTailCallOpt : 1;\n\n    /// StackAlignmentOverride - Override default stack alignment for target.\n    unsigned StackAlignmentOverride = 0;\n\n    /// StackSymbolOrdering - When true, this will allow CodeGen to order\n    /// the local stack symbols (for code size, code locality, or any other\n    /// heuristics). When false, the local symbols are left in whatever order\n    /// they were generated. Default is true.\n    unsigned StackSymbolOrdering : 1;\n\n    /// EnableFastISel - This flag enables fast-path instruction selection\n    /// which trades away generated code quality in favor of reducing\n    /// compile time.\n    unsigned EnableFastISel : 1;\n\n    /// EnableGlobalISel - This flag enables global instruction selection.\n    unsigned EnableGlobalISel : 1;\n\n    /// EnableGlobalISelAbort - Control abort behaviour when global instruction\n    /// selection fails to lower/select an instruction.\n    GlobalISelAbortMode GlobalISelAbort = GlobalISelAbortMode::Enable;\n\n    /// UseInitArray - Use .init_array instead of .ctors for static\n    /// constructors.\n    unsigned UseInitArray : 1;\n\n    /// Disable the integrated assembler.\n    unsigned DisableIntegratedAS : 1;\n\n    /// Compress DWARF debug sections.\n    DebugCompressionType CompressDebugSections = DebugCompressionType::None;\n\n    unsigned RelaxELFRelocations : 1;\n\n    /// Emit functions into separate sections.\n    unsigned FunctionSections : 1;\n\n    /// Emit data into separate sections.\n    unsigned DataSections : 1;\n\n    /// Do not emit visibility attribute for xcoff.\n    unsigned IgnoreXCOFFVisibility : 1;\n\n    /// Emit XCOFF traceback table.\n    unsigned XCOFFTracebackTable : 1;\n\n    unsigned UniqueSectionNames : 1;\n\n    /// Use unique names for basic block sections.\n    unsigned UniqueBasicBlockSectionNames : 1;\n\n    /// Emit target-specific trap instruction for 'unreachable' IR instructions.\n    unsigned TrapUnreachable : 1;\n\n    /// Do not emit a trap instruction for 'unreachable' IR instructions behind\n    /// noreturn calls, even if TrapUnreachable is true.\n    unsigned NoTrapAfterNoreturn : 1;\n\n    /// Bit size of immediate TLS offsets (0 == use the default).\n    unsigned TLSSize : 8;\n\n    /// EmulatedTLS - This flag enables emulated TLS model, using emutls\n    /// function in the runtime library..\n    unsigned EmulatedTLS : 1;\n\n    /// Whether -emulated-tls or -no-emulated-tls is set.\n    unsigned ExplicitEmulatedTLS : 1;\n\n    /// This flag enables InterProcedural Register Allocation (IPRA).\n    unsigned EnableIPRA : 1;\n\n    /// Emit section containing metadata on function stack sizes.\n    unsigned EmitStackSizeSection : 1;\n\n    /// Enables the MachineOutliner pass.\n    unsigned EnableMachineOutliner : 1;\n\n    /// Enables the MachineFunctionSplitter pass.\n    unsigned EnableMachineFunctionSplitter : 1;\n\n    /// Set if the target supports default outlining behaviour.\n    unsigned SupportsDefaultOutlining : 1;\n\n    /// Emit address-significance table.\n    unsigned EmitAddrsig : 1;\n\n    /// Emit basic blocks into separate sections.\n    BasicBlockSection BBSections = BasicBlockSection::None;\n\n    /// Memory Buffer that contains information on sampled basic blocks and used\n    /// to selectively generate basic block sections.\n    std::shared_ptr<MemoryBuffer> BBSectionsFuncListBuf;\n\n    /// The flag enables call site info production. It is used only for debug\n    /// info, and it is restricted only to optimized code. This can be used for\n    /// something else, so that should be controlled in the frontend.\n    unsigned EmitCallSiteInfo : 1;\n    /// Set if the target supports the debug entry values by default.\n    unsigned SupportsDebugEntryValues : 1;\n    /// When set to true, the EnableDebugEntryValues option forces production\n    /// of debug entry values even if the target does not officially support\n    /// it. Useful for testing purposes only. This flag should never be checked\n    /// directly, always use \\ref ShouldEmitDebugEntryValues instead.\n     unsigned EnableDebugEntryValues : 1;\n    /// NOTE: There are targets that still do not support the debug entry values\n    /// production.\n    bool ShouldEmitDebugEntryValues() const;\n\n    /// Emit pseudo probes into the binary for sample profiling\n    unsigned PseudoProbeForProfiling : 1;\n\n    // When set to true, use experimental new debug variable location tracking,\n    // which seeks to follow the values of variables rather than their location,\n    // post isel.\n    unsigned ValueTrackingVariableLocations : 1;\n\n    /// Emit DWARF debug frame section.\n    unsigned ForceDwarfFrameSection : 1;\n\n    /// Emit XRay Function Index section\n    unsigned XRayOmitFunctionIndex : 1;\n\n    /// Stack protector guard offset to use.\n    unsigned StackProtectorGuardOffset : 32;\n\n    /// Stack protector guard mode to use, e.g. tls, global.\n    StackProtectorGuards StackProtectorGuard =\n                                         StackProtectorGuards::None;\n\n    /// Stack protector guard reg to use, e.g. usually fs or gs in X86.\n    std::string StackProtectorGuardReg = \"None\";\n\n    /// FloatABIType - This setting is set by -float-abi=xxx option is specfied\n    /// on the command line. This setting may either be Default, Soft, or Hard.\n    /// Default selects the target's default behavior. Soft selects the ABI for\n    /// software floating point, but does not indicate that FP hardware may not\n    /// be used. Such a combination is unfortunately popular (e.g.\n    /// arm-apple-darwin). Hard presumes that the normal FP ABI is used.\n    FloatABI::ABIType FloatABIType = FloatABI::Default;\n\n    /// AllowFPOpFusion - This flag is set by the -fuse-fp-ops=xxx option.\n    /// This controls the creation of fused FP ops that store intermediate\n    /// results in higher precision than IEEE allows (E.g. FMAs).\n    ///\n    /// Fast mode - allows formation of fused FP ops whenever they're\n    /// profitable.\n    /// Standard mode - allow fusion only for 'blessed' FP ops. At present the\n    /// only blessed op is the fmuladd intrinsic. In the future more blessed ops\n    /// may be added.\n    /// Strict mode - allow fusion only if/when it can be proven that the excess\n    /// precision won't effect the result.\n    ///\n    /// Note: This option only controls formation of fused ops by the\n    /// optimizers.  Fused operations that are explicitly specified (e.g. FMA\n    /// via the llvm.fma.* intrinsic) will always be honored, regardless of\n    /// the value of this option.\n    FPOpFusion::FPOpFusionMode AllowFPOpFusion = FPOpFusion::Standard;\n\n    /// ThreadModel - This flag specifies the type of threading model to assume\n    /// for things like atomics\n    ThreadModel::Model ThreadModel = ThreadModel::POSIX;\n\n    /// EABIVersion - This flag specifies the EABI version\n    EABI EABIVersion = EABI::Default;\n\n    /// Which debugger to tune for.\n    DebuggerKind DebuggerTuning = DebuggerKind::Default;\n\n  private:\n    /// Flushing mode to assume in default FP environment.\n    DenormalMode FPDenormalMode;\n\n    /// Flushing mode to assume in default FP environment, for float/vector of\n    /// float.\n    DenormalMode FP32DenormalMode;\n\n  public:\n    void setFPDenormalMode(DenormalMode Mode) {\n      FPDenormalMode = Mode;\n    }\n\n    void setFP32DenormalMode(DenormalMode Mode) {\n      FP32DenormalMode = Mode;\n    }\n\n    DenormalMode getRawFPDenormalMode() const {\n      return FPDenormalMode;\n    }\n\n    DenormalMode getRawFP32DenormalMode() const {\n      return FP32DenormalMode;\n    }\n\n    DenormalMode getDenormalMode(const fltSemantics &FPType) const;\n\n    /// What exception model to use\n    ExceptionHandling ExceptionModel = ExceptionHandling::None;\n\n    /// Machine level options.\n    MCTargetOptions MCOptions;\n  };\n\n} // End llvm namespace\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 9, "file": 0, "line": 146}, "message": "'LValueBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/APValue.h", "reportHash": "80c9b9f2055077abb7b9926964afe1ce", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 0, "line": 191}, "message": "'LocalState' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/APValue.h", "reportHash": "94306b1293ef3b9f8f1ca7222661551d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 0, "line": 194}, "message": "'' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/APValue.h", "reportHash": "831b1573839fbdb3f753d85445b9670a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 0, "line": 249}, "message": "'NoLValuePath' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/APValue.h", "reportHash": "6bd8fd775c52682addb2a59cf2c039e3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 0, "line": 329}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 0, "line": 329}, "message": "'APValue' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/APValue.h", "reportHash": "ce028174fbf962c1b37100fd5b2a0058", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 1, "line": 100}, "message": "'ConceptReference' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTConcept.h", "reportHash": "e2fe68daed512c2f80f98247ceb0a5ba", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 2, "line": 54}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 2, "line": 54}, "message": "'ASTVector<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTVector.h", "reportHash": "67aa00f4746f784a11436be0b7424ccb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 3, "line": 82}, "message": "'TranslationUnitDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Decl.h", "reportHash": "302d1cf2ac970f21212586679f9852c8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 3, "line": 114}, "message": "'PragmaCommentDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Decl.h", "reportHash": "79cbdeed5e78a3cd570bba628db8fba7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 3, "line": 148}, "message": "'PragmaDetectMismatchDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Decl.h", "reportHash": "18cc8af9b8591c50f8baf89e4ce49f8a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 3, "line": 196}, "message": "'ExternCContextDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Decl.h", "reportHash": "1f95d566d57c0fbdb159b155c8850bfd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 3, "line": 223}, "message": "'NamedDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Decl.h", "reportHash": "09e392b475be0d4922fcd55baefb8942", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 3, "line": 512}, "message": "'NamespaceDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Decl.h", "reportHash": "f73b0296779b1db37a7e7c9763da0272", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 3, "line": 634}, "message": "'ValueDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Decl.h", "reportHash": "a52418fa5bfcba0798ecd3b1cc5302b5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 3, "line": 686}, "message": "'DeclaratorDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Decl.h", "reportHash": "904867b4c8071836c669dc0f2852cf3e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 3, "line": 690}, "message": "'ExtInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Decl.h", "reportHash": "2c3e3709d996013b2a4e8a5a9b6cdad2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 3, "line": 834}, "message": "'VarDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Decl.h", "reportHash": "233d40e3bdbb57c2d82409828a72eedc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 3, "line": 1811}, "message": "'FunctionDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Decl.h", "reportHash": "7a508f20c12000cacec8b5034dd690dc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 3, "line": 3085}, "message": "'TypeDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Decl.h", "reportHash": "6aaa99848d7469d8ff17b61bc0655c98", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 3, "line": 3128}, "message": "'ModedTInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Decl.h", "reportHash": "3f60723537ea04a6299a032e4bb72c48", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 3, "line": 3275}, "message": "'TagDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Decl.h", "reportHash": "4209802f4c95ff02598bd41df1948bb7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 3, "line": 4065}, "message": "'FileScopeAsmDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Decl.h", "reportHash": "4ff4778b921e31e6ef097cf194e3c5fa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 3, "line": 4100}, "message": "'BlockDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Decl.h", "reportHash": "c0a98ca990386c0b47031daf34b95cf1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 3, "line": 4289}, "message": "'CapturedDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Decl.h", "reportHash": "c0b4d4daf29d8500ab0c81665dc1e7b4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 3, "line": 4394}, "message": "'ImportDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Decl.h", "reportHash": "d07eea31751324d140430b2b82735a51", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 3, "line": 4474}, "message": "'ExportDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Decl.h", "reportHash": "5b7e92801d465cca822e37a5f5143ae8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 3, "line": 4521}, "message": "'EmptyDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Decl.h", "reportHash": "43afacdabf693464f7a8702c3bf19467", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 4, "line": 375}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 4, "line": 375}, "message": "'Decl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclBase.h", "reportHash": "901a5fd836022bba5db3527997847ef3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 4, "line": 1210}, "message": "'PrettyStackTraceDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclBase.h", "reportHash": "2cadf0e7a95b37b50041e3ab6beeb569", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 5, "line": 86}, "message": "'AccessSpecDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclCXX.h", "reportHash": "394ce3d1aaf55e58edbadcc95798e987", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 5, "line": 278}, "message": "'DefinitionData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclCXX.h", "reportHash": "2440a9a03d34fe7436ba741f6ea9b256", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 5, "line": 1915}, "message": "'RequiresExprBodyDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclCXX.h", "reportHash": "adfcb2f3dfe5597a4527077f8130404e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 5, "line": 2784}, "message": "'LinkageSpecDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclCXX.h", "reportHash": "4b5793a6f08588af0cbeeeb5292cec5a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 5, "line": 3081}, "message": "'LifetimeExtendedTemporaryDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclCXX.h", "reportHash": "9e8b53a2b8b24e9c405cb9b719142c8b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 5, "line": 3769}, "message": "'StaticAssertDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclCXX.h", "reportHash": "431f272e46f2027d6ab27363d5b477f6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 5, "line": 3975}, "message": "'MSGuidDeclParts' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclCXX.h", "reportHash": "a6f478e2b70c91fc60a620c966526ead", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 6, "line": 139}, "message": "'ObjCMethodDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclObjC.h", "reportHash": "705c6a22ca142a9a94d103bbfe5bbe68", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 6, "line": 397}, "message": "'GetTypeFn' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclObjC.h", "reportHash": "c509a08be43f59c3245d7bf1dde17891", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 6, "line": 947}, "message": "'ObjCContainerDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclObjC.h", "reportHash": "67c182445c43aceb98e083e892ab5cb2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 6, "line": 2411}, "message": "'ObjCImplDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclObjC.h", "reportHash": "44ad9fef8372b8aa42d7fa4a807198c0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 6, "line": 2485}, "message": "'ObjCCategoryImplDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclObjC.h", "reportHash": "6412469eaa2692ac4f28b32c04bed1a5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 6, "line": 2538}, "message": "'ObjCImplementationDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclObjC.h", "reportHash": "b94d6ab93641210c78ce1622df41a501", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 6, "line": 2743}, "message": "'ObjCPropertyImplDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclObjC.h", "reportHash": "4b2b2b4ae758605c1cc3f2d210215369", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 7, "line": 398}, "message": "'TemplateDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclTemplate.h", "reportHash": "f894764dfe68a95a3910bb720b4e5601", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 7, "line": 1143}, "message": "'TemplateParmPosition' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclTemplate.h", "reportHash": "0aaa4295dd32e12843b3f9a23517ed9c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 7, "line": 1759}, "message": "'BuiltinTemplateDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclTemplate.h", "reportHash": "5f24d75e1e83d8bddd7ffaa301542d0c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 7, "line": 1803}, "message": "'SpecializedPartialSpecialization' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclTemplate.h", "reportHash": "a2c932cc8eec4b175e22af4f312dfaf7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 7, "line": 1818}, "message": "'ExplicitSpecializationInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclTemplate.h", "reportHash": "af02bb4f0d29065f36992b4b9044078f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 7, "line": 2439}, "message": "'FriendTemplateDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclTemplate.h", "reportHash": "b46ef5fcebddce78f7b360abb090d086", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 7, "line": 2599}, "message": "'ClassScopeFunctionSpecializationDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclTemplate.h", "reportHash": "7f7958c696935ae4bc561d78c7388837", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 7, "line": 2665}, "message": "'SpecializedPartialSpecialization' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclTemplate.h", "reportHash": "a2c932cc8eec4b175e22af4f312dfaf7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 7, "line": 2680}, "message": "'ExplicitSpecializationInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclTemplate.h", "reportHash": "af02bb4f0d29065f36992b4b9044078f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 40, "file": 8, "line": 101}, "message": "'CXXOperatorIdName' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclarationName.h", "reportHash": "ee4840b42b61c24b4d55dfa1f5d7f8c4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 8, "line": 608}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 8, "line": 608}, "message": "'DeclarationNameTable' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclarationName.h", "reportHash": "ec4b15dced10a6bc9ea21be244a82f41", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 9, "line": 115}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 9, "line": 115}, "message": "'Expr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "5a75670e8e80b850a008a977c5831df6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 994}, "message": "'FullExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "0a90de319ce2ef244d66c3e1a58da2b2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 1125}, "message": "'OpaqueValueExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "2f5b41d393d2a3c7c24fdb1d1195ae4f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 1213}, "message": "'DeclRefExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "37581c3c088cc718627a2e537c8d0a37", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 1466}, "message": "'APIntStorage' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "6b4ee35b698f76e6ab4cb8623e9c8f49", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 1474}, "message": "'APFloatStorage' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "99ca8c23e5616290e1fe55ecb2cd924b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 1484}, "message": "'IntegerLiteral' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "114d83c0913574c032ce842d97d211ea", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 1527}, "message": "'FixedPointLiteral' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "3b9b356bda3cf18895647801500985c0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 1574}, "message": "'CharacterLiteral' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "c1d11f7c17967dce55a91e1ac0b77511", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 1627}, "message": "'FloatingLiteral' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "c97f5794b5c786d488bb880f9c96da59", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 1706}, "message": "'ImaginaryLiteral' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "9333539afa5c60d6000b4376793a41e0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 1755}, "message": "'StringLiteral' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "938ffc5831e309d0486742f5c6261930", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 1947}, "message": "'PredefinedExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "69fdc479465814e43eb36e8e1b902625", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 2042}, "message": "'ParenExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "6d33d2b19f349092e27428cc53ff62cd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 2093}, "message": "'UnaryOperator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "8d1d92eca6d358d78ee31902d620ee5c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 2374}, "message": "'OffsetOfExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "225b43f5f043a6840245f979c6da14ad", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 2479}, "message": "'UnaryExprOrTypeTraitExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "2ec9babd697ee3e5c21479c51c5ac713", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 9, "line": 2480}, "message": "'' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "d516bc46bd1344764427b4db79486d30", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 2574}, "message": "'ArraySubscriptExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "286ada2b14703ccd45b4620d03a0a04d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 2652}, "message": "'MatrixSubscriptExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "3b2786ce1be05c0c9435962866d43995", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 2730}, "message": "'CallExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "f92036d17c86e06970cddc51c367ffde", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 3086}, "message": "'MemberExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "ec3f8b4fc6aaa57070f93c03524e8d4b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 3327}, "message": "'CompoundLiteralExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "6acc724b448bf0c6d3efda994f35004f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 3397}, "message": "'CastExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "e2760e7827e40ee9dfcedd23aa26cfd3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 3619}, "message": "'ExplicitCastExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "551fd34980c776cc5d259652404b7918", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 3727}, "message": "'BinaryOperator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "d9d632cbb3b0c1f57a88ed656bb51f45", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 4027}, "message": "'AbstractConditionalOperator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "351b910aa789e2901f236af191e94faa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 4224}, "message": "'AddrLabelExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "a73243daad475832a248275dcd1fc015", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 4269}, "message": "'StmtExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "824c92a7e80aa5c7c6072559ed0cb273", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 4317}, "message": "'ShuffleVectorExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "e4825537c410e92ecaab04dbe7e1e9d5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 4385}, "message": "'ConvertVectorExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "23e511281ec7ce06283e0a80c8eb154e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 4444}, "message": "'ChooseExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "dee8115fadf42613a4b3442c00196fab", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 4519}, "message": "'GNUNullExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "cee238767203afc4800db27ae46ae75c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 4553}, "message": "'VAArgExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "9698cb251bdeb1e750886e9057285873", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 4602}, "message": "'SourceLocExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "0e40d7550dc7d8477dff3d1bc169ed85", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 4710}, "message": "'InitListExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "d159e8d26b0ceb8f769f9bb97b0e7414", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 4948}, "message": "'DesignatedInitExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "8f7436ce67c06230288bd9a3dc42c72b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 9, "line": 4987}, "message": "'FieldDesignator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "148ed50b3e5378fad9964043944b4e07", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 9, "line": 5004}, "message": "'ArrayOrRangeDesignator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "e8ee73a31a2fe11eba4acc7f39601eb1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 5249}, "message": "'NoInitExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "17afcc0b65088cff204478094c5cfc88", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 5286}, "message": "'DesignatedInitUpdateExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "37fa26b330d7a404273e1e4606adbaa4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 5340}, "message": "'ArrayInitLoopExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "e4622320096bc5d3a192a370883af7ce", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 5393}, "message": "'ArrayInitIndexExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "707997664b1d69c6f4920a5588e2ecbb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 5429}, "message": "'ImplicitValueInitExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "9b6a5f56e020d53d2957147270ba0bb7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 5456}, "message": "'ParenListExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "a6fb8a4db1ccb2e359d494af89dc8442", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 5547}, "message": "'GenericSelectionExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "092ad2debef4e1f1448a427b278f72ca", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 5829}, "message": "'ExtVectorElementExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "9f27943e29644aef072b04bf4aec608f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 5889}, "message": "'BlockExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "cf55be0c4e7b26a3493b74769dd60993", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 5950}, "message": "'AsTypeExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "cda05bd430fc56cd4202ca0eebf382a8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 6019}, "message": "'PseudoObjectExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "729509b86d0d7c507216b218c20cfd6e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 6153}, "message": "'AtomicExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "76448fe2038600f858f2c7b14eddbec8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 6282}, "message": "'TypoExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "d82d77dec586e9a4b65feb544cb75104", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 6336}, "message": "'RecoveryExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "8b44e1f94034eb47898e0fd4e9d6b1f9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 284}, "message": "'CXXRewrittenBinaryOperator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "884984d6f4be1129886500a399a8cd5d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 721}, "message": "'CXXBoolLiteralExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "f4320c200f96185eb43a6518263e55a1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 759}, "message": "'CXXNullPtrLiteralExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "3b0bce5de428f38c409e657972a08b49", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 791}, "message": "'CXXStdInitializerListExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "2f2f3ff766429bc6b2f1ba0e90e86c47", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 839}, "message": "'CXXTypeidExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "822357c42d31f73069531503013d7b2b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 923}, "message": "'MSPropertyRefExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "d95c37835e4ec563257be2bf26384207", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 994}, "message": "'MSPropertySubscriptExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "ecba0a61c7db897ca067206dea2c3bfe", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 1056}, "message": "'CXXUuidofExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "ddcdd0bd5bd68701027cfce06077c9e7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 1142}, "message": "'CXXThisExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "3181101d65d16c8d23b9c984bf33dc69", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 1181}, "message": "'CXXThrowExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "7a6f8221a2213f0d42da2a1db1044847", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 1241}, "message": "'CXXDefaultArgExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "9942be6069b36dd006adfe584704e3d4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 1318}, "message": "'CXXDefaultInitExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "4701581904ba6702463a085db27b9e65", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 1412}, "message": "'CXXBindTemporaryExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "70545631205e88826b1e6154bddab693", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 1460}, "message": "'CXXConstructExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "51ee04cd7e5e58f9909005279030242c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 1651}, "message": "'CXXInheritedCtorInitExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "0a9ed89c25f7b021d966534653397630", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 1865}, "message": "'LambdaExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "096c84a510e22e9f715d233c9f122c91", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 2093}, "message": "'CXXScalarValueInitExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "ccd9efdfaeaf0bc7d8519e90ad5f6009", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 2139}, "message": "'CXXNewExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "34f7d53f168909eeeec4a15c51892837", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 2398}, "message": "'CXXDeleteExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "ec1fe48a957c44f8ad9ad7258865f270", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 2466}, "message": "'PseudoDestructorTypeStorage' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "3b02db6437c5b17dbfb1fec57f0f8464", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 2517}, "message": "'CXXPseudoDestructorExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "0dbe2e041f97e10ada9da35eb0da8daa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 2665}, "message": "'TypeTraitExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "c19fb48b1a1b41ec51a27798a6455147", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 2753}, "message": "'ArrayTypeTraitExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "85dd2b8c6cb15a50283a416c6f04c7b2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 2823}, "message": "'ExpressionTraitExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "601c35c873c988091fd9094562b7e21b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 2880}, "message": "'OverloadExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "1a2365b51d20e8219e3d25c55698b93e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 3191}, "message": "'DependentScopeDeclRefExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "279db9c08a0a9f3afb3ca5c9c21fb05c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 3428}, "message": "'CXXUnresolvedConstructExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "c7475fb5d4394179d36e0417f378ab2c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 3550}, "message": "'CXXDependentScopeMemberExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "904c35f0c1c0b9b5996a2165d2ff750e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 3997}, "message": "'CXXNoexceptExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "7e6e1dcb1eda0514b6ccbac996115467", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 4051}, "message": "'PackExpansionExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "0346938063194082bbea7e17060aad10", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 4127}, "message": "'SizeOfPackExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "797d640a29955542220948f91b0bb56c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 4245}, "message": "'SubstNonTypeTemplateParmExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "df600af435737b3c856a71cd78fc6387", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 4312}, "message": "'SubstNonTypeTemplateParmPackExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "21079a987c755e490492372a11fb06ad", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 4380}, "message": "'FunctionParmPackExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "b4754e70bd55499d441705262106a496", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 4462}, "message": "'MaterializeTemporaryExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "8d33d9a20e5e98dcb1c4f4358b9a7797", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 4576}, "message": "'CXXFoldExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "7e2cfc9434adb5d09d246ad59752fc02", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 4681}, "message": "'CoroutineSuspendExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "fd128a864db428b7358379dcaabca3df", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 4802}, "message": "'DependentCoawaitExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprCXX.h", "reportHash": "96fd4102492110d6fd9580e08abaee14", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 11, "line": 52}, "message": "'ObjCStringLiteral' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprObjC.h", "reportHash": "d1da0273205115aa983338eca8ddefaf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 11, "line": 88}, "message": "'ObjCBoolLiteralExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprObjC.h", "reportHash": "de904f701df970599e34155cd3d4e941", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 11, "line": 128}, "message": "'ObjCBoxedExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprObjC.h", "reportHash": "e207b4451e6e785b2c5ba30380e64255", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 11, "line": 190}, "message": "'ObjCArrayLiteral' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprObjC.h", "reportHash": "1839b9731373f909442f244cdfffb2d3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 11, "line": 306}, "message": "'ObjCDictionaryLiteral' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprObjC.h", "reportHash": "d2500e7cbb55010a1415d42b6adb8995", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 11, "line": 409}, "message": "'ObjCEncodeExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprObjC.h", "reportHash": "37da1e3bffe1efd99f526aba8c655cc4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 11, "line": 454}, "message": "'ObjCSelectorExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprObjC.h", "reportHash": "f260ae4d35d0f40122be772fbc1a5dd7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 11, "line": 504}, "message": "'ObjCProtocolExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprObjC.h", "reportHash": "c9fb26027f36c104a6799e58eed5fa41", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 11, "line": 548}, "message": "'ObjCIvarRefExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprObjC.h", "reportHash": "6fa06768dd4cb19072fbef6cb76fcd74", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 11, "line": 614}, "message": "'ObjCPropertyRefExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprObjC.h", "reportHash": "02ede3d97751d446fb11b3ac3f040184", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 11, "line": 841}, "message": "'ObjCSubscriptRefExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprObjC.h", "reportHash": "5d21452a5f80c0da816caa5bd0968948", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 11, "line": 940}, "message": "'ObjCMessageExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprObjC.h", "reportHash": "30dd1a512524b863feb32d6a0af8d5ab", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 11, "line": 1482}, "message": "'ObjCIsaExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprObjC.h", "reportHash": "e69cfbfcfdb80fab1e674ca6bfb3f3fe", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 11, "line": 1566}, "message": "'ObjCIndirectCopyRestoreExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprObjC.h", "reportHash": "afb77c5ea115cac35c1f1479835f507e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 11, "line": 1686}, "message": "'ObjCAvailabilityCheckExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprObjC.h", "reportHash": "b83b3a7314a5e2397674803d4735ea21", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 96}, "message": "'StmtBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "a7696ef29060b04c0853bb5867296bfe", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 106}, "message": "'NullStmtBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "fb5b3ecf996a16648a46f75d6d0ce7f0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 124}, "message": "'CompoundStmtBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "ad25c455beace49028f223779aaa29f0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 136}, "message": "'LabelStmtBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "30a0c06caf8f35aba1055fa6a2962f9b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 144}, "message": "'AttributedStmtBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "c147052a514e689b96da159dcf5cce84", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 157}, "message": "'IfStmtBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "08268a3c145c48addf2a12300abfe648", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 179}, "message": "'SwitchStmtBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "594c0683521b117bdaf0ff5dd952338a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 199}, "message": "'WhileStmtBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "f340aa389e463905d6b929bb9e0eb2ea", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 212}, "message": "'DoStmtBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "da9669a354920cc7da0a6c5f5cf255ea", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 221}, "message": "'ForStmtBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "6be6c7ca0a69ae5ef28831c2156e4608", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 230}, "message": "'GotoStmtBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "812119ae08674569406d3259d7d4b961", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 240}, "message": "'ContinueStmtBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "87a22bc2404fca6803293c428be15a7c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 249}, "message": "'BreakStmtBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "66ab12f7fd9147e7085011da17b201a9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 258}, "message": "'ReturnStmtBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "a49573a64660283f48d297324c438936", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 270}, "message": "'SwitchCaseBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "6398b84a172ca02ee3a0ec9129362ec2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 286}, "message": "'ExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "d676fe52358dc3b68e3b28712d08c02b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 318}, "message": "'ConstantExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "0a2a7d79fe65010920f2ac882c750308", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 348}, "message": "'PredefinedExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "74cb6bb706392cb0ad76359d8750d9ef", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 366}, "message": "'DeclRefExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "1540eb843e96748481f089cd53d5bef5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 384}, "message": "'FloatingLiteralBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "c20b61adad11efc16c2935c169129bd4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 393}, "message": "'StringLiteralBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "f2443418eefbd5c4069e8fc2e35ef265", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 415}, "message": "'CharacterLiteralBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "1dcd8328c289aa27b05d0178b6af71f1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 423}, "message": "'UnaryOperatorBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "dd845e7f79bef12dff9cf7a91e302da4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 439}, "message": "'UnaryExprOrTypeTraitExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "b5bed12e070fe5ebcf17eb0223713c25", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 448}, "message": "'ArrayOrMatrixSubscriptExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "0d0504a48ee807439c64c448fb6da88b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 457}, "message": "'CallExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "0d82f8354f8cd73c5ddebb8115fafdb8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 480}, "message": "'MemberExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "18456a42885e2c92cf29596eb89dde34", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 515}, "message": "'CastExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "b37211c8a797d29b87bdc2cdb989072e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 532}, "message": "'BinaryOperatorBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "ef823b8ab4e14dae5795677997f818fc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 547}, "message": "'InitListExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "204b7b9d7796b6dd4850f0a9a4a8d196", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 557}, "message": "'ParenListExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "6c4c554ca02f2d5046d666099c56144b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 567}, "message": "'GenericSelectionExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "927d16a760759fef0838263f49a1941f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 577}, "message": "'PseudoObjectExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "7f56c1d0a8b21b43f8c4187001ccb5b8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 589}, "message": "'SourceLocExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "bc58e131227569b33455aa1078a16fef", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 600}, "message": "'StmtExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "e2fde915e339fc4d83d8453b6347fbc9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 614}, "message": "'CXXOperatorCallExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "1720fdc1ff8b387410775a1efa625c86", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 625}, "message": "'CXXRewrittenBinaryOperatorBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "61fadc2ea32c10340f2e224ab368d8e9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 634}, "message": "'CXXBoolLiteralExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "8901576482791b848a8da99f894e3c87", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 646}, "message": "'CXXNullPtrLiteralExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "9df517fc302726e0eca3b7cae66418ac", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 655}, "message": "'CXXThisExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "98fa9ceb11f84d6710a9a21f7d267703", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 667}, "message": "'CXXThrowExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "2fcf8279a1706e10949075fa9c7bead5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 680}, "message": "'CXXDefaultArgExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "95b932f633c05f0b55fc41e3bb9ac102", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 690}, "message": "'CXXDefaultInitExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "8f6710bae58bee85253e7214adcdf06d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 700}, "message": "'CXXScalarValueInitExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "a2e2e842f28a7f518f48043716eb1c1a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 709}, "message": "'CXXNewExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "5271d8951d93cbac85deed98e4114f67", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 742}, "message": "'CXXDeleteExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "741400e5c1e1948826c652d7ae086f04", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 767}, "message": "'TypeTraitExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "a74cf0b5c5984d5621028c0ff7299382", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 787}, "message": "'DependentScopeDeclRefExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "85abd4dfe1c0a204066052b0bae51f49", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 799}, "message": "'CXXConstructExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "16d694ca9608d4b0d6b116df7f5e92f3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 815}, "message": "'ExprWithCleanupsBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "1df75d40e950548e1132e08ad712e3b9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 827}, "message": "'CXXUnresolvedConstructExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "545517e8d075f986b6b12b79f1a417f1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 837}, "message": "'CXXDependentScopeMemberExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "8a588c171b2d58daab713a80058c5bbe", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 859}, "message": "'OverloadExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "09a8d3d066248a4530e8df3b70343cbe", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 879}, "message": "'UnresolvedLookupExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "7886ed78f4d9db3220ad6949f966c325", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 897}, "message": "'UnresolvedMemberExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "6798f36e0c1b330d186012230deab41c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 914}, "message": "'CXXNoexceptExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "47d006e995a482a1be32c767b96bda9c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 923}, "message": "'SubstNonTypeTemplateParmExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "457be413a4e6795735c35c8dc171f677", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 933}, "message": "'LambdaExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "ee9990d92ea108e77766f93bbf947f77", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 955}, "message": "'RequiresExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "76d9204d76296a346798cd7da1a05ba1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 968}, "message": "'CoawaitExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "c03f4df711134fc561bdd9c403e1be94", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 978}, "message": "'ObjCIndirectCopyRestoreExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "59dd7681daefe73aa5b94b6a43e34f95", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 988}, "message": "'OpaqueValueExprBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "2f7a26ca5164e9619e8802a7a7578874", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 12, "line": 1102}, "message": "'EmptyShell' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "dcb33a78d37fd9acc6b89758441d9e17", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 12, "line": 1149}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 12, "line": 1149}, "message": "'Stmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "974ad087a46f3f3d10bf7dab33e99766", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 1291}, "message": "'DeclStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "b17e163d744489962bf15b2239a84032", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 1363}, "message": "'NullStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "48e06793c7bf428e5109c6ea91313957", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 1398}, "message": "'CompoundStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "2f7eeb20ba6897fe5a77c3249633095b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 1521}, "message": "'SwitchCase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "907dc9a219243ad87f13c1e9d1b6ce8e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 1566}, "message": "'CaseStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "26911cfd7f7c7391c9debf37f2666a4a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 1722}, "message": "'DefaultStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "319a326e2660a0cf64c2b7d4fc280ffc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 1779}, "message": "'ValueStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "f94c05eb0444202b33fef58d69fc03a2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 1798}, "message": "'LabelStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "f779b51582333d70e0ebac9c13cef554", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 1842}, "message": "'AttributedStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "87108bbffe05e3632933231236c97f11", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 1900}, "message": "'IfStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "27477c2368cf22265f50f22bfa55d419", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 2117}, "message": "'SwitchStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "de94aad7ee1b032eed1559872cc9559d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 2308}, "message": "'WhileStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "9d951839f5c56d9acea1a78ce51602b0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 2445}, "message": "'DoStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "40a74b339d4afe6b50d87eef2049c3f1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 2501}, "message": "'ForStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "a2c5d8909f6e87c42f0b8eb46de5ae51", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 2572}, "message": "'GotoStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "be3e57c052bc0aa9cbc80d0f1df5fdee", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 2611}, "message": "'IndirectGotoStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "95193e29851ff3db2e0f117bcc7c49fb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 2660}, "message": "'ContinueStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "258c4ee5cc89a857e50512fc061af33c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 2690}, "message": "'BreakStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "8af7e16bfe91096da63bd54086d60a3a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 2727}, "message": "'ReturnStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "b7a97862724d009ccb53b6742be56bf8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 2810}, "message": "'AsmStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "3c246719a7da1e0c5fcfd128be8ac512", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 2969}, "message": "'GCCAsmStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "28a5d0d02360efd1e310b9f7dd95d273", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 12, "line": 3004}, "message": "'AsmStringPiece' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "44de6b4e5b067ba80d8ce9d3f59a5033", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 3192}, "message": "'MSAsmStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "f6c2ebc576caa76f4ef461ceca5533ed", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 3296}, "message": "'SEHExceptStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "3a95befae750b89c0de4e310d7647aa8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 3340}, "message": "'SEHFinallyStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "52814463f6ff83e99dc14491342b9419", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 3375}, "message": "'SEHTryStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "921026e8a500ffb380892236605bc8b9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 3428}, "message": "'SEHLeaveStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "774b7bf844e977846b629ef799838731", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 3467}, "message": "'CapturedStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Stmt.h", "reportHash": "5ded70f5b5b8b22767847e94f1837230", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 13, "line": 28}, "message": "'CXXCatchStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtCXX.h", "reportHash": "a299d7f9b2129b4820237c087bd8cc59", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 13, "line": 68}, "message": "'CXXTryStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtCXX.h", "reportHash": "3f9b4f16696f2fc1dab7b1a8c09944e3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 13, "line": 134}, "message": "'CXXForRangeStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtCXX.h", "reportHash": "9f775ab8dcd79d30a5ab0f172c99bca7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 13, "line": 252}, "message": "'MSDependentExistsStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtCXX.h", "reportHash": "85d6fa64f5dad5b515eef2b0a1876696", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 13, "line": 317}, "message": "'CoroutineBodyStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtCXX.h", "reportHash": "bb584b81e7afe5d3de4688ce9a0c074a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 13, "line": 456}, "message": "'CoreturnStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtCXX.h", "reportHash": "04ced83cb43ef76d7ac00cd40193c330", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 14, "line": 27}, "message": "'StmtIteratorBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtIterator.h", "reportHash": "c06447f08feaa2f22f58c407b2df5c5a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 14, "line": 36}, "message": "'' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtIterator.h", "reportHash": "231b80861cde367c833675d4baee29ce", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 14, "line": 125}, "message": "'StmtIterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtIterator.h", "reportHash": "90b5b074d5de87b9fc98f91d68dd5bc3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 14, "line": 141}, "message": "'ConstStmtIterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtIterator.h", "reportHash": "b6ba500e413024230676fc20cbd51584", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 15, "line": 405}, "message": "'TemplateArgumentLocInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/TemplateBase.h", "reportHash": "02e3004fec03b2586f87b837e8f69904", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 16, "line": 47}, "message": "'UncommonTemplateNameStorage' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/TemplateName.h", "reportHash": "d809097d39b8a932b1429d6222ee8739", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 16, "line": 56}, "message": "'BitsTag' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/TemplateName.h", "reportHash": "a01329060b17c6e712d77545736fa9cd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 16, "line": 65}, "message": "'' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/TemplateName.h", "reportHash": "79f0ea554d9a322e4e66dd491adb7c4b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 1337}, "message": "'ExtQualsTypeCommonBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "968767731e3fd8d1dd08399825e1d88e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 17, "line": 1489}, "message": "'TypeBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "53a394d5da5f59e0cd2477c1ccdd7a83", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 17, "line": 1532}, "message": "'ArrayTypeBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "9e23a6f719e9204861937a42b6412eed", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 17, "line": 1547}, "message": "'ConstantArrayTypeBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "57ede6b66deb5c0edd7ab0d842f39cfb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 17, "line": 1556}, "message": "'BuiltinTypeBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "ad273129667b69f10c0295093591e117", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 17, "line": 1568}, "message": "'FunctionTypeBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "1a8bd177f2174e007c61f0295fc31d13", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 17, "line": 1612}, "message": "'ObjCObjectTypeBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "8bdb076500cbc76f75c9afb118bca5ec", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 17, "line": 1627}, "message": "'ReferenceTypeBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "a135613a568f38322a237c115b7dc5d7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 17, "line": 1650}, "message": "'TypeWithKeywordBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "fd8f8bcffc339e48104d2263da38fd25", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 17, "line": 1661}, "message": "'ElaboratedTypeBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "4a310d17e715fc992f434cdc8603212f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 17, "line": 1671}, "message": "'VectorTypeBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "3f2d8ef06eba73f74f3477a3b0d06fe7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 17, "line": 1684}, "message": "'AttributedTypeBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "795bd8a42ebb6c0726873837670e8712", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 17, "line": 1693}, "message": "'AutoTypeBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "5245a5e890f7618d0a1e3991a1741722", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 17, "line": 1712}, "message": "'SubstTemplateTypeParmPackTypeBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "abb38729c2295c144e947033196c45f8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 17, "line": 1727}, "message": "'TemplateSpecializationTypeBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "a8b0c41bc174e67f99f6d14d831b7b96", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 17, "line": 1745}, "message": "'DependentTemplateSpecializationTypeBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "d5634fe3d393f709de1007ac0b226f84", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 17, "line": 1761}, "message": "'PackExpansionTypeBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "aac2ea6761000469619bff06be519005", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 17, "line": 1842}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 17, "line": 1842}, "message": "'Type' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "36aa3383cd7316421492cc592e81b2ea", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 2480}, "message": "'BuiltinType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "777a84eaa8a2dfc6928015ced87cc651", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 2574}, "message": "'ComplexType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "767947e53080519239c1c64759a1ecb0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 2601}, "message": "'ParenType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "5fb914b2e2a126dcb7714f30ef5d21c9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 2627}, "message": "'PointerType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "abda6a8b84c27371a81497a6bb7ac946", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 2656}, "message": "'AdjustedType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "87305ea0b90b42fe13f20fab4d500e5c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 2690}, "message": "'DecayedType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "fe649e6f48755b898058d1f33b46fdc8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 2707}, "message": "'BlockPointerType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "9893cf46d86575c8242ba60644494c1d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 2738}, "message": "'ReferenceType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "faebb6aa0f3a64144549a795af833a03", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 2818}, "message": "'MemberPointerType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "4817e8dfcbead487e2040cca3ac371b0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 2870}, "message": "'ArrayType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "29b79529eb33a6ded63443ce37770fda", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 2916}, "message": "'ConstantArrayType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "02c339ab989bd30bb147809be1dca212", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 3134}, "message": "'DependentAddressSpaceType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "92592c963aa4ee1afdd6fef86c03fc3e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 3176}, "message": "'DependentSizedExtVectorType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "7ebd920cce32c9bbebaee8266f663082", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 3216}, "message": "'VectorType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "d85ae01d8a76e520cecf143e922c1f19", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 3295}, "message": "'DependentVectorType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "062081dab692e2c09388e58a7c5121ba", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 3406}, "message": "'MatrixType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "b5eccef87dfbc679b539e66e80d0c630", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 3541}, "message": "'FunctionType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "6eb7b824524da3882e1554f1dc08fc7c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 4336}, "message": "'UnresolvedUsingType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "1e645da1de7f8f39de66b94f43d207de", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 4366}, "message": "'TypedefType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "5ac9ea4ed0e9614fcf891c23832ea2f0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 4386}, "message": "'MacroQualifiedType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "a074d05635615b8a07d5097319309a06", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 4417}, "message": "'TypeOfExprType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "f3ee442b4d50937ccb16a7ca8ba58657", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 4460}, "message": "'TypeOfType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "784ebaf7b77d0fb0bd0473c2357c82e9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 4483}, "message": "'DecltypeType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "685cb4454cfb3279194f3cd0541e0d37", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 4526}, "message": "'UnaryTransformType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "967bd8c302551e0fef5dbdb2c244450d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 4584}, "message": "'TagType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "410600667dbd973cda670a2e21055a98", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 4663}, "message": "'AttributedType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "f481fca04e156650e03245ae6f054f39", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 4760}, "message": "'TemplateTypeParmType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "cc258fb759629170ae41f90f93050211", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 17, "line": 4764}, "message": "'CanonicalTTPTInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "d72225c2363fc366a78e42c6e40d95eb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 4839}, "message": "'SubstTemplateTypeParmType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "6808977d20a2913182bd2cdd51a035e3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 4892}, "message": "'SubstTemplateTypeParmPackType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "46f5a2a45ebffa24c24332d28d0a155a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 4941}, "message": "'DeducedType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "7809486096b909e54f4b384f6a7df0bd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 18, "file": 17, "line": 5098}, "message": "'TemplateSpecializationType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "1ee005d59d7980c30a26dd24b6fafd13", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 5251}, "message": "'InjectedClassNameType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "769868cb867e5e7fddc6a41bd401c202", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 5350}, "message": "'TypeWithKeyword' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "0311adacb18f366f261911e0a326e1dc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 5627}, "message": "'PackExpansionType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "42eda49404290b4f7d9d58c360de134d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 5736}, "message": "'ObjCTypeParamType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "b692b296dbabf09d221c3df985facece", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 5811}, "message": "'ObjCObjectType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "e930e4088a309822f8fadef76606d62e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 6068}, "message": "'ObjCObjectPointerType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "e0570d134e7c7a826be7d8db21067612", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 6238}, "message": "'AtomicType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "a3d29767c7632069f7620e72cb9948fc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 6268}, "message": "'PipeType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "84d46d3923f914be8587acd1e448fba5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 6302}, "message": "'ExtIntType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "666d025bc5fb6a54f2a39e7af46a672f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 6331}, "message": "'DependentExtIntType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "2927dedd8aee5d69d85911d9c3d97a61", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 6360}, "message": "'QualifierCollector' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "069060d7526e2790d520f1b58ca0482e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 18, "line": 74}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 18, "line": 74}, "message": "'UnresolvedSetImpl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/UnresolvedSet.h", "reportHash": "f9d273829ab6199a2daec142a5ec4695", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 19, "line": 419}, "message": "'AnalysisDeclContextManager' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/AnalysisDeclContext.h", "reportHash": "8de1a0cb73213471df5f5dfe7d79fe77", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 132}, "message": "'CFGStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/CFG.h", "reportHash": "f52e64c49bf4524a06d397ca0f03c723", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 156}, "message": "'CFGConstructor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/CFG.h", "reportHash": "779b080d85cac9fd46078a26711989bc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 184}, "message": "'CFGCXXRecordTypedCall' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/CFG.h", "reportHash": "dda3ef7a85f74bca5e61f32363945fef", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 225}, "message": "'CFGInitializer' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/CFG.h", "reportHash": "ad364c3b979c83250cada4be2b44a2a7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 245}, "message": "'CFGNewAllocator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/CFG.h", "reportHash": "4ea94f210fb7634a80112b7bfc1c2028", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 271}, "message": "'CFGLoopExit' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/CFG.h", "reportHash": "e95d043b3356c0edadf50d463bcce761", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 290}, "message": "'CFGLifetimeEnds' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/CFG.h", "reportHash": "287bbe74a3ae70a8f3c5bc800b68adac", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 315}, "message": "'CFGScopeBegin' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/CFG.h", "reportHash": "9fffc8fb124f722653796cced44d203c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 341}, "message": "'CFGScopeEnd' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/CFG.h", "reportHash": "362ebac64e0d11f63c03d108bffc421f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 364}, "message": "'CFGImplicitDtor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/CFG.h", "reportHash": "15fc3c7574040e5cf8712ac1ac6595db", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 389}, "message": "'CFGAutomaticObjDtor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/CFG.h", "reportHash": "19c8b99fed5b86547cf4112bf6b96385", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 414}, "message": "'CFGDeleteDtor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/CFG.h", "reportHash": "ad1c20fb513978ce555ceed5503dd757", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 440}, "message": "'CFGBaseDtor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/CFG.h", "reportHash": "894e59b16cdde63ffd56babfbe34bd56", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 461}, "message": "'CFGMemberDtor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/CFG.h", "reportHash": "6208dd358d615b33d9ea63dfac2004a4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 20, "line": 482}, "message": "'CFGTemporaryDtor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/CFG.h", "reportHash": "cada7d540f10c9285896898642a41181", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 20, "line": 980}, "message": "'FilterOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/CFG.h", "reportHash": "c974fdad15d8e627506e4181f08421f7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 21, "line": 28}, "message": "'ConstructionContextItem' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/ConstructionContext.h", "reportHash": "f77fb75d4d5939181778ff3a46375f99", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 21, "line": 236}, "message": "'ConstructionContext' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/ConstructionContext.h", "reportHash": "139c06bde15ef327112c74290f600360", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 21, "line": 303}, "message": "'VariableConstructionContext' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/ConstructionContext.h", "reportHash": "2eb89f54e1144488c67ec001387d5b98", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 21, "line": 369}, "message": "'ConstructorInitializerConstructionContext' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/ConstructionContext.h", "reportHash": "d63bee7a1f09d8a9e23272bc8502abda", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 21, "line": 463}, "message": "'TemporaryObjectConstructionContext' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/ConstructionContext.h", "reportHash": "bfb39ed2bed02affdee05905f7d32294", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 21, "line": 559}, "message": "'ReturnedValueConstructionContext' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/ConstructionContext.h", "reportHash": "2ba921c53303b19cd523445a5d27dcba", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 22, "line": 52}, "message": "'SimpleProgramPointTag' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/ProgramPoint.h", "reportHash": "6fb2c188858bf28945566c9dba16aaae", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 22, "line": 225}, "message": "'BlockEntrance' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/ProgramPoint.h", "reportHash": "1c915ea378c3694af984d41771bc96ea", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 22, "line": 271}, "message": "'StmtPoint' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/ProgramPoint.h", "reportHash": "3ab7661df6a5d4664b487d2682a2d78d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 22, "line": 311}, "message": "'PostStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/ProgramPoint.h", "reportHash": "e8d14f0d603deaed4a6e9bee1846952c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 22, "line": 373}, "message": "'LocationCheck' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/ProgramPoint.h", "reportHash": "1e1b33c5de6d652f35435dd176aba025", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 22, "line": 559}, "message": "'ImplicitCallPoint' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/ProgramPoint.h", "reportHash": "cf6ff4f360ade9de454c8ed44560a685", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 23, "line": 40}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 23, "line": 40}, "message": "'BumpVectorContext' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/Support/BumpVector.h", "reportHash": "a855737d076162a5ad4cc7e7920032b5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 24, "line": 33}, "message": "'CodeGenOptionsBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/CodeGenOptions.h", "reportHash": "81a59902f1ae71517fcb3e66f40ab550", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 24, "line": 49}, "message": "'CodeGenOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/CodeGenOptions.h", "reportHash": "bc87b34f9fa800023a86fe336dd71aa3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 24, "line": 202}, "message": "'BitcodeFileToLink' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/CodeGenOptions.h", "reportHash": "e810c9c324b4fb2dc4dfd22b72fff2a1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 24, "line": 301}, "message": "'OptRemark' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/CodeGenOptions.h", "reportHash": "40937fac9bd7048728f981d29f1b63f3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 25, "line": 147}, "message": "'DiagnosticStorage' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Diagnostic.h", "reportHash": "67bcb1d553b0b6e8a26dcde6114b9e13", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 25, "line": 1240}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 25, "line": 1240}, "message": "'StreamingDiagnostic' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Diagnostic.h", "reportHash": "761563300fa05c5736805d16a41cb810", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 25, "line": 1532}, "message": "'Diagnostic' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Diagnostic.h", "reportHash": "20e191f58f4a5e5f5c84357af907e532", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 25, "line": 1656}, "message": "'StoredDiagnostic' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Diagnostic.h", "reportHash": "20f7f47f2593861d56ec5430534ad280", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 25, "line": 1762}, "message": "'IgnoringDiagConsumer' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Diagnostic.h", "reportHash": "2238e841c7640b6d3ea4848fe4bdce80", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 26, "line": 71}, "message": "'clang/Basic/DiagnosticCommonKinds.inc' file not found"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h", "reportHash": "0212dcde1e4a793396a6f1f45b22be74", "checkerName": "clang-diagnostic-error", "reviewStatus": null, "severity": "CRITICAL"}, {"events": [{"location": {"col": 7, "file": 27, "line": 70}, "message": "'DiagnosticOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/DiagnosticOptions.h", "reportHash": "c357bb6c7ac215deafe5fb80baca3dc9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 28, "line": 134}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 28, "line": 134}, "message": "'IdentifierInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/IdentifierTable.h", "reportHash": "66602e3770784ae81c61113f831dbf21", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 40, "file": 28, "line": 884}, "message": "'DeclarationNameExtra' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/IdentifierTable.h", "reportHash": "1d8082b85475deb66c8b895983d39437", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 29, "line": 34}, "message": "'LangOptionsBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/LangOptions.h", "reportHash": "f4086ae191685f1271381da7912693b0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 29, "line": 58}, "message": "'LangOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/LangOptions.h", "reportHash": "3fb60992fd990721f452ba5119b8759e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 30, "line": 27}, "message": "'ObjCRuntime' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/ObjCRuntime.h", "reportHash": "60628d7d5bce99ee036cc1d4f96f06c0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 31, "line": 78}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 31, "line": 78}, "message": "'PartialDiagnostic' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/PartialDiagnostic.h", "reportHash": "8979c1239b6f05e22eee362df0cf3cca", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 32, "line": 152}, "message": "'SanitizerSet' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Sanitizers.h", "reportHash": "692d6ba1341416b26401ce005426d3f0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 33, "line": 94}, "message": "'AtomicScopeOpenCLModel' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SyncScope.h", "reportHash": "95609aab351dbde83d0bec5ed026985b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 38}, "message": "'ConditionTruthVal' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ConstraintManager.h", "reportHash": "a2fa1af186d22d6fac3f516a8605c29a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 35, "line": 75}, "message": "'SVal' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SVals.h", "reportHash": "95cfc21a6b79bfe282b6efd1511954fb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 35, "line": 223}, "message": "'DefinedOrUnknownSVal' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SVals.h", "reportHash": "d042e12f96e5c283b78bd0161c154e11", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 35, "line": 256}, "message": "'DefinedSVal' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SVals.h", "reportHash": "d0c4231cec0e079f8522152b2539873d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 35, "line": 292}, "message": "'NonLoc' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SVals.h", "reportHash": "412f7967252054333c31667e16701f1b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 35, "line": 314}, "message": "'Loc' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SVals.h", "reportHash": "dbacfcdf49b1f009958cb1be3954a7cd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 36, "line": 100}, "message": "'APFixedPoint' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h", "reportHash": "7d06cb825be980a99ec1268d9f72a658", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 37, "line": 259}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 37, "line": 259}, "message": "'IEEEFloat' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFloat.h", "reportHash": "0441376e2e8d8d3f0bccf5df2e1984c2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 37, "line": 620}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 37, "line": 620}, "message": "'DoubleAPFloat' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFloat.h", "reportHash": "cdb872278aa91b73949617cec71187de", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 37, "line": 755}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 37, "line": 755}, "message": "'Storage' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFloat.h", "reportHash": "b006baed4a59640deaebfe3af61e8905", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 37, "line": 876}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 37, "line": 876}, "message": "'APFloat' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFloat.h", "reportHash": "46d70ef85f0e4073ea73093c882de96a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 42, "line": 30}, "message": "'DenseSetEmpty' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseSet.h", "reportHash": "c750ac52769ffb7b182c847192507ac3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 44, "line": 125}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 44, "line": 125}, "message": "'FoldingSetBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "6cbd1b88bf2b5d1bd23a2c61ca1a2b66", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 44, "line": 133}, "message": "'Node' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "5cdcc239d55a4e13b7d49e7f9aeaf494", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 44, "line": 285}, "message": "'FoldingSetNodeIDRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "6909d2734d14ba9274ced18a399f31c5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 44, "line": 313}, "message": "'FoldingSetNodeID' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "25aa3ca6b9656180f7ab1d2036d36830", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 44, "line": 413}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 44, "line": 413}, "message": "'FoldingSetImpl<Derived, T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "79a81db4c2d80cb7e349c400a5f0d105", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 44, "line": 531}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 44, "line": 531}, "message": "'FoldingSet<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "7733c2472e14bbba539dc37a46be07c7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 44, "line": 665}, "message": "'FoldingSetIteratorImpl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "266959673e3a512c803a43651769e870", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 44, "line": 707}, "message": "'FoldingSetBucketIteratorImpl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "fc885a7f216b5ea1a828b993bbfd252c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 53, "line": 84}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 53, "line": 84}, "message": "'TinyPtrVector<EltTy>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/TinyPtrVector.h", "reportHash": "fd55356b960d27db5d7193c9bad8216f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 56, "line": 36}, "message": "'MCTargetOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCTargetOptions.h", "reportHash": "74aadaa8aa8ed52aa0e4203711a94248", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 62, "line": 333}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 62, "line": 333}, "message": "'TrailingObjects<BaseTy, TrailingTys...>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TrailingObjects.h", "reportHash": "ef24a957ca91ccfec74d7c393dbdc511", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 62, "line": 375}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 62, "line": 375}, "message": "'FixedSizeStorageOwner' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TrailingObjects.h", "reportHash": "1657c7fb52922374a7a7399fd8138363", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 63, "line": 130}, "message": "'StackOffset' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TypeSize.h", "reportHash": "47248dcba3fcba3671909dcf19f21431", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 66, "line": 122}, "message": "'TargetOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Target/TargetOptions.h", "reportHash": "7001bc86c90cae6297d495cff85aa6f0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
