<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clang-doc/Representation.h", "content": "///===-- Representation.h - ClangDoc Representation -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the internal representations of different declaration\n// types for the clang-doc tool.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_DOC_REPRESENTATION_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANG_DOC_REPRESENTATION_H\n\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Tooling/StandaloneExecution.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include <array>\n#include <string>\n\nnamespace clang {\nnamespace doc {\n\n// SHA1'd hash of a USR.\nusing SymbolID = std::array<uint8_t, 20>;\n\nstruct Info;\nstruct FunctionInfo;\nstruct EnumInfo;\nstruct BaseRecordInfo;\n\nenum class InfoType {\n  IT_default,\n  IT_namespace,\n  IT_record,\n  IT_function,\n  IT_enum\n};\n\n// A representation of a parsed comment.\nstruct CommentInfo {\n  CommentInfo() = default;\n  CommentInfo(CommentInfo &Other) = delete;\n  CommentInfo(CommentInfo &&Other) = default;\n  CommentInfo &operator=(CommentInfo &&Other) = default;\n\n  bool operator==(const CommentInfo &Other) const {\n    auto FirstCI = std::tie(Kind, Text, Name, Direction, ParamName, CloseName,\n                            SelfClosing, Explicit, AttrKeys, AttrValues, Args);\n    auto SecondCI =\n        std::tie(Other.Kind, Other.Text, Other.Name, Other.Direction,\n                 Other.ParamName, Other.CloseName, Other.SelfClosing,\n                 Other.Explicit, Other.AttrKeys, Other.AttrValues, Other.Args);\n\n    if (FirstCI != SecondCI || Children.size() != Other.Children.size())\n      return false;\n\n    return std::equal(Children.begin(), Children.end(), Other.Children.begin(),\n                      llvm::deref<std::equal_to<>>{});\n  }\n\n  // This operator is used to sort a vector of CommentInfos.\n  // No specific order (attributes more important than others) is required. Any\n  // sort is enough, the order is only needed to call std::unique after sorting\n  // the vector.\n  bool operator<(const CommentInfo &Other) const {\n    auto FirstCI = std::tie(Kind, Text, Name, Direction, ParamName, CloseName,\n                            SelfClosing, Explicit, AttrKeys, AttrValues, Args);\n    auto SecondCI =\n        std::tie(Other.Kind, Other.Text, Other.Name, Other.Direction,\n                 Other.ParamName, Other.CloseName, Other.SelfClosing,\n                 Other.Explicit, Other.AttrKeys, Other.AttrValues, Other.Args);\n\n    if (FirstCI < SecondCI)\n      return true;\n\n    if (FirstCI == SecondCI) {\n      return std::lexicographical_compare(\n          Children.begin(), Children.end(), Other.Children.begin(),\n          Other.Children.end(), llvm::deref<std::less<>>());\n    }\n\n    return false;\n  }\n\n  SmallString<16>\n      Kind; // Kind of comment (FullComment, ParagraphComment, TextComment,\n            // InlineCommandComment, HTMLStartTagComment, HTMLEndTagComment,\n            // BlockCommandComment, ParamCommandComment,\n            // TParamCommandComment, VerbatimBlockComment,\n            // VerbatimBlockLineComment, VerbatimLineComment).\n  SmallString<64> Text;      // Text of the comment.\n  SmallString<16> Name;      // Name of the comment (for Verbatim and HTML).\n  SmallString<8> Direction;  // Parameter direction (for (T)ParamCommand).\n  SmallString<16> ParamName; // Parameter name (for (T)ParamCommand).\n  SmallString<16> CloseName; // Closing tag name (for VerbatimBlock).\n  bool SelfClosing = false;  // Indicates if tag is self-closing (for HTML).\n  bool Explicit = false; // Indicates if the direction of a param is explicit\n                         // (for (T)ParamCommand).\n  llvm::SmallVector<SmallString<16>, 4>\n      AttrKeys; // List of attribute keys (for HTML).\n  llvm::SmallVector<SmallString<16>, 4>\n      AttrValues; // List of attribute values for each key (for HTML).\n  llvm::SmallVector<SmallString<16>, 4>\n      Args; // List of arguments to commands (for InlineCommand).\n  std::vector<std::unique_ptr<CommentInfo>>\n      Children; // List of child comments for this CommentInfo.\n};\n\nstruct Reference {\n  Reference() = default;\n  Reference(llvm::StringRef Name) : Name(Name) {}\n  // An empty path means the info is in the global namespace because the path is\n  // a composite of the parent namespaces.\n  Reference(llvm::StringRef Name, StringRef Path)\n      : Name(Name), Path(Path), IsInGlobalNamespace(Path.empty()) {}\n  Reference(SymbolID USR, StringRef Name, InfoType IT)\n      : USR(USR), Name(Name), RefType(IT) {}\n  // An empty path means the info is in the global namespace because the path is\n  // a composite of the parent namespaces.\n  Reference(SymbolID USR, StringRef Name, InfoType IT, StringRef Path)\n      : USR(USR), Name(Name), RefType(IT), Path(Path),\n        IsInGlobalNamespace(Path.empty()) {}\n\n  bool operator==(const Reference &Other) const {\n    return std::tie(USR, Name, RefType) ==\n           std::tie(Other.USR, Other.Name, Other.RefType);\n  }\n\n  bool mergeable(const Reference &Other);\n  void merge(Reference &&I);\n\n  /// Returns the path for this Reference relative to CurrentPath.\n  llvm::SmallString<64> getRelativeFilePath(const StringRef &CurrentPath) const;\n\n  /// Returns the basename that should be used for this Reference.\n  llvm::SmallString<16> getFileBaseName() const;\n\n  SymbolID USR = SymbolID(); // Unique identifier for referenced decl\n  SmallString<16> Name;      // Name of type (possibly unresolved).\n  InfoType RefType = InfoType::IT_default; // Indicates the type of this\n                                           // Reference (namespace, record,\n                                           // function, enum, default).\n  // Path of directory where the clang-doc generated file will be saved\n  // (possibly unresolved)\n  llvm::SmallString<128> Path;\n  // Indicates if the info's parent is the global namespace, or if the info is\n  // the global namespace\n  bool IsInGlobalNamespace = false;\n};\n\n// A base struct for TypeInfos\nstruct TypeInfo {\n  TypeInfo() = default;\n  TypeInfo(SymbolID Type, StringRef Field, InfoType IT)\n      : Type(Type, Field, IT) {}\n  TypeInfo(SymbolID Type, StringRef Field, InfoType IT, StringRef Path)\n      : Type(Type, Field, IT, Path) {}\n  TypeInfo(llvm::StringRef RefName) : Type(RefName) {}\n  TypeInfo(llvm::StringRef RefName, StringRef Path) : Type(RefName, Path) {}\n\n  bool operator==(const TypeInfo &Other) const { return Type == Other.Type; }\n\n  Reference Type; // Referenced type in this info.\n};\n\n// Info for field types.\nstruct FieldTypeInfo : public TypeInfo {\n  FieldTypeInfo() = default;\n  FieldTypeInfo(SymbolID Type, StringRef Field, InfoType IT, StringRef Path,\n                llvm::StringRef Name)\n      : TypeInfo(Type, Field, IT, Path), Name(Name) {}\n  FieldTypeInfo(llvm::StringRef RefName, llvm::StringRef Name)\n      : TypeInfo(RefName), Name(Name) {}\n  FieldTypeInfo(llvm::StringRef RefName, StringRef Path, llvm::StringRef Name)\n      : TypeInfo(RefName, Path), Name(Name) {}\n\n  bool operator==(const FieldTypeInfo &Other) const {\n    return std::tie(Type, Name) == std::tie(Other.Type, Other.Name);\n  }\n\n  SmallString<16> Name; // Name associated with this info.\n};\n\n// Info for member types.\nstruct MemberTypeInfo : public FieldTypeInfo {\n  MemberTypeInfo() = default;\n  MemberTypeInfo(SymbolID Type, StringRef Field, InfoType IT, StringRef Path,\n                 llvm::StringRef Name, AccessSpecifier Access)\n      : FieldTypeInfo(Type, Field, IT, Path, Name), Access(Access) {}\n  MemberTypeInfo(llvm::StringRef RefName, llvm::StringRef Name,\n                 AccessSpecifier Access)\n      : FieldTypeInfo(RefName, Name), Access(Access) {}\n  MemberTypeInfo(llvm::StringRef RefName, StringRef Path, llvm::StringRef Name,\n                 AccessSpecifier Access)\n      : FieldTypeInfo(RefName, Path, Name), Access(Access) {}\n\n  bool operator==(const MemberTypeInfo &Other) const {\n    return std::tie(Type, Name, Access) ==\n           std::tie(Other.Type, Other.Name, Other.Access);\n  }\n\n  // Access level associated with this info (public, protected, private, none).\n  // AS_public is set as default because the bitcode writer requires the enum\n  // with value 0 to be used as the default.\n  // (AS_public = 0, AS_protected = 1, AS_private = 2, AS_none = 3)\n  AccessSpecifier Access = AccessSpecifier::AS_public;\n};\n\nstruct Location {\n  Location() = default;\n  Location(int LineNumber, SmallString<16> Filename)\n      : LineNumber(LineNumber), Filename(std::move(Filename)) {}\n  Location(int LineNumber, SmallString<16> Filename, bool IsFileInRootDir)\n      : LineNumber(LineNumber), Filename(std::move(Filename)),\n        IsFileInRootDir(IsFileInRootDir) {}\n\n  bool operator==(const Location &Other) const {\n    return std::tie(LineNumber, Filename) ==\n           std::tie(Other.LineNumber, Other.Filename);\n  }\n\n  // This operator is used to sort a vector of Locations.\n  // No specific order (attributes more important than others) is required. Any\n  // sort is enough, the order is only needed to call std::unique after sorting\n  // the vector.\n  bool operator<(const Location &Other) const {\n    return std::tie(LineNumber, Filename) <\n           std::tie(Other.LineNumber, Other.Filename);\n  }\n\n  int LineNumber;               // Line number of this Location.\n  SmallString<32> Filename;     // File for this Location.\n  bool IsFileInRootDir = false; // Indicates if file is inside root directory\n};\n\n/// A base struct for Infos.\nstruct Info {\n  Info() = default;\n  Info(InfoType IT) : IT(IT) {}\n  Info(InfoType IT, SymbolID USR) : USR(USR), IT(IT) {}\n  Info(InfoType IT, SymbolID USR, StringRef Name)\n      : USR(USR), IT(IT), Name(Name) {}\n  Info(InfoType IT, SymbolID USR, StringRef Name, StringRef Path)\n      : USR(USR), IT(IT), Name(Name), Path(Path) {}\n  Info(const Info &Other) = delete;\n  Info(Info &&Other) = default;\n\n  virtual ~Info() = default;\n\n  SymbolID USR =\n      SymbolID(); // Unique identifier for the decl described by this Info.\n  const InfoType IT = InfoType::IT_default; // InfoType of this particular Info.\n  SmallString<16> Name;                     // Unqualified name of the decl.\n  llvm::SmallVector<Reference, 4>\n      Namespace; // List of parent namespaces for this decl.\n  std::vector<CommentInfo> Description; // Comment description of this decl.\n  llvm::SmallString<128> Path;          // Path of directory where the clang-doc\n                                        // generated file will be saved\n\n  void mergeBase(Info &&I);\n  bool mergeable(const Info &Other);\n\n  llvm::SmallString<16> extractName() const;\n\n  /// Returns the file path for this Info relative to CurrentPath.\n  llvm::SmallString<64> getRelativeFilePath(const StringRef &CurrentPath) const;\n\n  /// Returns the basename that should be used for this Info.\n  llvm::SmallString<16> getFileBaseName() const;\n\n  // Returns a reference to the parent scope (that is, the immediate parent\n  // namespace or class in which this decl resides).\n  llvm::Expected<Reference> getEnclosingScope();\n};\n\n// Info for namespaces.\nstruct NamespaceInfo : public Info {\n  NamespaceInfo() : Info(InfoType::IT_namespace) {}\n  NamespaceInfo(SymbolID USR) : Info(InfoType::IT_namespace, USR) {}\n  NamespaceInfo(SymbolID USR, StringRef Name)\n      : Info(InfoType::IT_namespace, USR, Name) {}\n  NamespaceInfo(SymbolID USR, StringRef Name, StringRef Path)\n      : Info(InfoType::IT_namespace, USR, Name, Path) {}\n\n  void merge(NamespaceInfo &&I);\n\n  // Namespaces and Records are references because they will be properly\n  // documented in their own info, while the entirety of Functions and Enums are\n  // included here because they should not have separate documentation from\n  // their scope.\n  std::vector<Reference> ChildNamespaces;\n  std::vector<Reference> ChildRecords;\n  std::vector<FunctionInfo> ChildFunctions;\n  std::vector<EnumInfo> ChildEnums;\n};\n\n// Info for symbols.\nstruct SymbolInfo : public Info {\n  SymbolInfo(InfoType IT) : Info(IT) {}\n  SymbolInfo(InfoType IT, SymbolID USR) : Info(IT, USR) {}\n  SymbolInfo(InfoType IT, SymbolID USR, StringRef Name) : Info(IT, USR, Name) {}\n  SymbolInfo(InfoType IT, SymbolID USR, StringRef Name, StringRef Path)\n      : Info(IT, USR, Name, Path) {}\n\n  void merge(SymbolInfo &&I);\n\n  llvm::Optional<Location> DefLoc;    // Location where this decl is defined.\n  llvm::SmallVector<Location, 2> Loc; // Locations where this decl is declared.\n};\n\n// TODO: Expand to allow for documenting templating and default args.\n// Info for functions.\nstruct FunctionInfo : public SymbolInfo {\n  FunctionInfo() : SymbolInfo(InfoType::IT_function) {}\n  FunctionInfo(SymbolID USR) : SymbolInfo(InfoType::IT_function, USR) {}\n\n  void merge(FunctionInfo &&I);\n\n  bool IsMethod = false; // Indicates whether this function is a class method.\n  Reference Parent;      // Reference to the parent class decl for this method.\n  TypeInfo ReturnType;   // Info about the return type of this function.\n  llvm::SmallVector<FieldTypeInfo, 4> Params; // List of parameters.\n  // Access level for this method (public, private, protected, none).\n  // AS_public is set as default because the bitcode writer requires the enum\n  // with value 0 to be used as the default.\n  // (AS_public = 0, AS_protected = 1, AS_private = 2, AS_none = 3)\n  AccessSpecifier Access = AccessSpecifier::AS_public;\n};\n\n// TODO: Expand to allow for documenting templating, inheritance access,\n// friend classes\n// Info for types.\nstruct RecordInfo : public SymbolInfo {\n  RecordInfo() : SymbolInfo(InfoType::IT_record) {}\n  RecordInfo(SymbolID USR) : SymbolInfo(InfoType::IT_record, USR) {}\n  RecordInfo(SymbolID USR, StringRef Name)\n      : SymbolInfo(InfoType::IT_record, USR, Name) {}\n  RecordInfo(SymbolID USR, StringRef Name, StringRef Path)\n      : SymbolInfo(InfoType::IT_record, USR, Name, Path) {}\n\n  void merge(RecordInfo &&I);\n\n  TagTypeKind TagType = TagTypeKind::TTK_Struct; // Type of this record\n                                                 // (struct, class, union,\n                                                 // interface).\n  bool IsTypeDef = false; // Indicates if record was declared using typedef\n  llvm::SmallVector<MemberTypeInfo, 4>\n      Members;                             // List of info about record members.\n  llvm::SmallVector<Reference, 4> Parents; // List of base/parent records\n                                           // (does not include virtual\n                                           // parents).\n  llvm::SmallVector<Reference, 4>\n      VirtualParents; // List of virtual base/parent records.\n\n  std::vector<BaseRecordInfo>\n      Bases; // List of base/parent records; this includes inherited methods and\n             // attributes\n\n  // Records are references because they will be properly documented in their\n  // own info, while the entirety of Functions and Enums are included here\n  // because they should not have separate documentation from their scope.\n  std::vector<Reference> ChildRecords;\n  std::vector<FunctionInfo> ChildFunctions;\n  std::vector<EnumInfo> ChildEnums;\n};\n\nstruct BaseRecordInfo : public RecordInfo {\n  BaseRecordInfo() : RecordInfo() {}\n  BaseRecordInfo(SymbolID USR, StringRef Name, StringRef Path, bool IsVirtual,\n                 AccessSpecifier Access, bool IsParent)\n      : RecordInfo(USR, Name, Path), IsVirtual(IsVirtual), Access(Access),\n        IsParent(IsParent) {}\n\n  // Indicates if base corresponds to a virtual inheritance\n  bool IsVirtual = false;\n  // Access level associated with this inherited info (public, protected,\n  // private).\n  AccessSpecifier Access = AccessSpecifier::AS_public;\n  bool IsParent = false; // Indicates if this base is a direct parent\n};\n\n// TODO: Expand to allow for documenting templating.\n// Info for types.\nstruct EnumInfo : public SymbolInfo {\n  EnumInfo() : SymbolInfo(InfoType::IT_enum) {}\n  EnumInfo(SymbolID USR) : SymbolInfo(InfoType::IT_enum, USR) {}\n\n  void merge(EnumInfo &&I);\n\n  bool Scoped =\n      false; // Indicates whether this enum is scoped (e.g. enum class).\n  llvm::SmallVector<SmallString<16>, 4> Members; // List of enum members.\n};\n\nstruct Index : public Reference {\n  Index() = default;\n  Index(StringRef Name) : Reference(Name) {}\n  Index(StringRef Name, StringRef JumpToSection)\n      : Reference(Name), JumpToSection(JumpToSection) {}\n  Index(SymbolID USR, StringRef Name, InfoType IT, StringRef Path)\n      : Reference(USR, Name, IT, Path) {}\n  // This is used to look for a USR in a vector of Indexes using std::find\n  bool operator==(const SymbolID &Other) const { return USR == Other; }\n  bool operator<(const Index &Other) const;\n\n  llvm::Optional<SmallString<16>> JumpToSection;\n  std::vector<Index> Children;\n\n  void sort();\n};\n\n// TODO: Add functionality to include separate markdown pages.\n\n// A standalone function to call to merge a vector of infos into one.\n// This assumes that all infos in the vector are of the same type, and will fail\n// if they are different.\nllvm::Expected<std::unique_ptr<Info>>\nmergeInfos(std::vector<std::unique_ptr<Info>> &Values);\n\nstruct ClangDocContext {\n  ClangDocContext() = default;\n  ClangDocContext(tooling::ExecutionContext *ECtx, StringRef ProjectName,\n                  bool PublicOnly, StringRef OutDirectory, StringRef SourceRoot,\n                  StringRef RepositoryUrl,\n                  std::vector<std::string> UserStylesheets,\n                  std::vector<std::string> JsScripts);\n  tooling::ExecutionContext *ECtx;\n  std::string ProjectName; // Name of project clang-doc is documenting.\n  bool PublicOnly; // Indicates if only public declarations are documented.\n  std::string OutDirectory; // Directory for outputting generated files.\n  std::string SourceRoot;   // Directory where processed files are stored. Links\n                            // to definition locations will only be generated if\n                            // the file is in this dir.\n  // URL of repository that hosts code used for links to definition locations.\n  llvm::Optional<std::string> RepositoryUrl;\n  // Path of CSS stylesheets that will be copied to OutDirectory and used to\n  // style all HTML files.\n  std::vector<std::string> UserStylesheets;\n  // JavaScript files that will be imported in allHTML file.\n  std::vector<std::string> JsScripts;\n  // Other files that should be copied to OutDirectory, besides UserStylesheets.\n  std::vector<std::string> FilesToCopy;\n  Index Idx;\n};\n\n} // namespace doc\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_DOC_REPRESENTATION_H\n"}, "4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Attr.h", "content": "//===--- Attr.h - Classes for representing attributes ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the Attr interface and subclasses.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_ATTR_H\n#define LLVM_CLANG_AST_ATTR_H\n\n#include \"clang/AST/ASTFwd.h\"\n#include \"clang/AST/AttrIterator.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/AttrKinds.h\"\n#include \"clang/Basic/AttributeCommonInfo.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/OpenMPKinds.h\"\n#include \"clang/Basic/Sanitizers.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/StringSwitch.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/VersionTuple.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <algorithm>\n#include <cassert>\n\nnamespace clang {\nclass ASTContext;\nclass AttributeCommonInfo;\nclass IdentifierInfo;\nclass ObjCInterfaceDecl;\nclass Expr;\nclass QualType;\nclass FunctionDecl;\nclass TypeSourceInfo;\nclass OMPTraitInfo;\n\n/// Attr - This represents one attribute.\nclass Attr : public AttributeCommonInfo {\nprivate:\n  unsigned AttrKind : 16;\n\nprotected:\n  /// An index into the spelling list of an\n  /// attribute defined in Attr.td file.\n  unsigned Inherited : 1;\n  unsigned IsPackExpansion : 1;\n  unsigned Implicit : 1;\n  // FIXME: These are properties of the attribute kind, not state for this\n  // instance of the attribute.\n  unsigned IsLateParsed : 1;\n  unsigned InheritEvenIfAlreadyPresent : 1;\n\n  void *operator new(size_t bytes) noexcept {\n    llvm_unreachable(\"Attrs cannot be allocated with regular 'new'.\");\n  }\n  void operator delete(void *data) noexcept {\n    llvm_unreachable(\"Attrs cannot be released with regular 'delete'.\");\n  }\n\npublic:\n  // Forward so that the regular new and delete do not hide global ones.\n  void *operator new(size_t Bytes, ASTContext &C,\n                     size_t Alignment = 8) noexcept {\n    return ::operator new(Bytes, C, Alignment);\n  }\n  void operator delete(void *Ptr, ASTContext &C, size_t Alignment) noexcept {\n    return ::operator delete(Ptr, C, Alignment);\n  }\n\nprotected:\n  Attr(ASTContext &Context, const AttributeCommonInfo &CommonInfo,\n       attr::Kind AK, bool IsLateParsed)\n      : AttributeCommonInfo(CommonInfo), AttrKind(AK), Inherited(false),\n        IsPackExpansion(false), Implicit(false), IsLateParsed(IsLateParsed),\n        InheritEvenIfAlreadyPresent(false) {}\n\npublic:\n  attr::Kind getKind() const { return static_cast<attr::Kind>(AttrKind); }\n\n  unsigned getSpellingListIndex() const {\n    return getAttributeSpellingListIndex();\n  }\n  const char *getSpelling() const;\n\n  SourceLocation getLocation() const { return getRange().getBegin(); }\n\n  bool isInherited() const { return Inherited; }\n\n  /// Returns true if the attribute has been implicitly created instead\n  /// of explicitly written by the user.\n  bool isImplicit() const { return Implicit; }\n  void setImplicit(bool I) { Implicit = I; }\n\n  void setPackExpansion(bool PE) { IsPackExpansion = PE; }\n  bool isPackExpansion() const { return IsPackExpansion; }\n\n  // Clone this attribute.\n  Attr *clone(ASTContext &C) const;\n\n  bool isLateParsed() const { return IsLateParsed; }\n\n  // Pretty print this attribute.\n  void printPretty(raw_ostream &OS, const PrintingPolicy &Policy) const;\n};\n\nclass TypeAttr : public Attr {\nprotected:\n  TypeAttr(ASTContext &Context, const AttributeCommonInfo &CommonInfo,\n           attr::Kind AK, bool IsLateParsed)\n      : Attr(Context, CommonInfo, AK, IsLateParsed) {}\n\npublic:\n  static bool classof(const Attr *A) {\n    return A->getKind() >= attr::FirstTypeAttr &&\n           A->getKind() <= attr::LastTypeAttr;\n  }\n};\n\nclass StmtAttr : public Attr {\nprotected:\n  StmtAttr(ASTContext &Context, const AttributeCommonInfo &CommonInfo,\n           attr::Kind AK, bool IsLateParsed)\n      : Attr(Context, CommonInfo, AK, IsLateParsed) {}\n\npublic:\n  static bool classof(const Attr *A) {\n    return A->getKind() >= attr::FirstStmtAttr &&\n           A->getKind() <= attr::LastStmtAttr;\n  }\n};\n\nclass InheritableAttr : public Attr {\nprotected:\n  InheritableAttr(ASTContext &Context, const AttributeCommonInfo &CommonInfo,\n                  attr::Kind AK, bool IsLateParsed,\n                  bool InheritEvenIfAlreadyPresent)\n      : Attr(Context, CommonInfo, AK, IsLateParsed) {\n    this->InheritEvenIfAlreadyPresent = InheritEvenIfAlreadyPresent;\n  }\n\npublic:\n  void setInherited(bool I) { Inherited = I; }\n\n  /// Should this attribute be inherited from a prior declaration even if it's\n  /// explicitly provided in the current declaration?\n  bool shouldInheritEvenIfAlreadyPresent() const {\n    return InheritEvenIfAlreadyPresent;\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Attr *A) {\n    return A->getKind() >= attr::FirstInheritableAttr &&\n           A->getKind() <= attr::LastInheritableAttr;\n  }\n};\n\nclass DeclOrStmtAttr : public InheritableAttr {\nprotected:\n  DeclOrStmtAttr(ASTContext &Context, const AttributeCommonInfo &CommonInfo,\n                 attr::Kind AK, bool IsLateParsed,\n                 bool InheritEvenIfAlreadyPresent)\n      : InheritableAttr(Context, CommonInfo, AK, IsLateParsed,\n                        InheritEvenIfAlreadyPresent) {}\n\npublic:\n  static bool classof(const Attr *A) {\n    return A->getKind() >= attr::FirstDeclOrStmtAttr &&\n           A->getKind() <= attr::LastDeclOrStmtAttr;\n  }\n};\n\nclass InheritableParamAttr : public InheritableAttr {\nprotected:\n  InheritableParamAttr(ASTContext &Context,\n                       const AttributeCommonInfo &CommonInfo, attr::Kind AK,\n                       bool IsLateParsed, bool InheritEvenIfAlreadyPresent)\n      : InheritableAttr(Context, CommonInfo, AK, IsLateParsed,\n                        InheritEvenIfAlreadyPresent) {}\n\npublic:\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Attr *A) {\n    return A->getKind() >= attr::FirstInheritableParamAttr &&\n           A->getKind() <= attr::LastInheritableParamAttr;\n  }\n};\n\n/// A parameter attribute which changes the argument-passing ABI rule\n/// for the parameter.\nclass ParameterABIAttr : public InheritableParamAttr {\nprotected:\n  ParameterABIAttr(ASTContext &Context, const AttributeCommonInfo &CommonInfo,\n                   attr::Kind AK, bool IsLateParsed,\n                   bool InheritEvenIfAlreadyPresent)\n      : InheritableParamAttr(Context, CommonInfo, AK, IsLateParsed,\n                             InheritEvenIfAlreadyPresent) {}\n\npublic:\n  ParameterABI getABI() const {\n    switch (getKind()) {\n    case attr::SwiftContext:\n      return ParameterABI::SwiftContext;\n    case attr::SwiftErrorResult:\n      return ParameterABI::SwiftErrorResult;\n    case attr::SwiftIndirectResult:\n      return ParameterABI::SwiftIndirectResult;\n    default:\n      llvm_unreachable(\"bad parameter ABI attribute kind\");\n    }\n  }\n\n  static bool classof(const Attr *A) {\n    return A->getKind() >= attr::FirstParameterABIAttr &&\n           A->getKind() <= attr::LastParameterABIAttr;\n   }\n};\n\n/// A single parameter index whose accessors require each use to make explicit\n/// the parameter index encoding needed.\nclass ParamIdx {\n  // Idx is exposed only via accessors that specify specific encodings.\n  unsigned Idx : 30;\n  unsigned HasThis : 1;\n  unsigned IsValid : 1;\n\n  void assertComparable(const ParamIdx &I) const {\n    assert(isValid() && I.isValid() &&\n           \"ParamIdx must be valid to be compared\");\n    // It's possible to compare indices from separate functions, but so far\n    // it's not proven useful.  Moreover, it might be confusing because a\n    // comparison on the results of getASTIndex might be inconsistent with a\n    // comparison on the ParamIdx objects themselves.\n    assert(HasThis == I.HasThis &&\n           \"ParamIdx must be for the same function to be compared\");\n  }\n\npublic:\n  /// Construct an invalid parameter index (\\c isValid returns false and\n  /// accessors fail an assert).\n  ParamIdx() : Idx(0), HasThis(false), IsValid(false) {}\n\n  /// \\param Idx is the parameter index as it is normally specified in\n  /// attributes in the source: one-origin including any C++ implicit this\n  /// parameter.\n  ///\n  /// \\param D is the declaration containing the parameters.  It is used to\n  /// determine if there is a C++ implicit this parameter.\n  ParamIdx(unsigned Idx, const Decl *D)\n      : Idx(Idx), HasThis(false), IsValid(true) {\n    assert(Idx >= 1 && \"Idx must be one-origin\");\n    if (const auto *FD = dyn_cast<FunctionDecl>(D))\n      HasThis = FD->isCXXInstanceMember();\n  }\n\n  /// A type into which \\c ParamIdx can be serialized.\n  ///\n  /// A static assertion that it's of the correct size follows the \\c ParamIdx\n  /// class definition.\n  typedef uint32_t SerialType;\n\n  /// Produce a representation that can later be passed to \\c deserialize to\n  /// construct an equivalent \\c ParamIdx.\n  SerialType serialize() const {\n    return *reinterpret_cast<const SerialType *>(this);\n  }\n\n  /// Construct from a result from \\c serialize.\n  static ParamIdx deserialize(SerialType S) {\n    // Using this two-step static_cast via void * instead of reinterpret_cast\n    // silences a -Wstrict-aliasing false positive from GCC7 and earlier.\n    void *ParamIdxPtr = static_cast<void *>(&S);\n    ParamIdx P(*static_cast<ParamIdx *>(ParamIdxPtr));\n    assert((!P.IsValid || P.Idx >= 1) && \"valid Idx must be one-origin\");\n    return P;\n  }\n\n  /// Is this parameter index valid?\n  bool isValid() const { return IsValid; }\n\n  /// Get the parameter index as it would normally be encoded for attributes at\n  /// the source level of representation: one-origin including any C++ implicit\n  /// this parameter.\n  ///\n  /// This encoding thus makes sense for diagnostics, pretty printing, and\n  /// constructing new attributes from a source-like specification.\n  unsigned getSourceIndex() const {\n    assert(isValid() && \"ParamIdx must be valid\");\n    return Idx;\n  }\n\n  /// Get the parameter index as it would normally be encoded at the AST level\n  /// of representation: zero-origin not including any C++ implicit this\n  /// parameter.\n  ///\n  /// This is the encoding primarily used in Sema.  However, in diagnostics,\n  /// Sema uses \\c getSourceIndex instead.\n  unsigned getASTIndex() const {\n    assert(isValid() && \"ParamIdx must be valid\");\n    assert(Idx >= 1 + HasThis &&\n           \"stored index must be base-1 and not specify C++ implicit this\");\n    return Idx - 1 - HasThis;\n  }\n\n  /// Get the parameter index as it would normally be encoded at the LLVM level\n  /// of representation: zero-origin including any C++ implicit this parameter.\n  ///\n  /// This is the encoding primarily used in CodeGen.\n  unsigned getLLVMIndex() const {\n    assert(isValid() && \"ParamIdx must be valid\");\n    assert(Idx >= 1 && \"stored index must be base-1\");\n    return Idx - 1;\n  }\n\n  bool operator==(const ParamIdx &I) const {\n    assertComparable(I);\n    return Idx == I.Idx;\n  }\n  bool operator!=(const ParamIdx &I) const {\n    assertComparable(I);\n    return Idx != I.Idx;\n  }\n  bool operator<(const ParamIdx &I) const {\n    assertComparable(I);\n    return Idx < I.Idx;\n  }\n  bool operator>(const ParamIdx &I) const {\n    assertComparable(I);\n    return Idx > I.Idx;\n  }\n  bool operator<=(const ParamIdx &I) const {\n    assertComparable(I);\n    return Idx <= I.Idx;\n  }\n  bool operator>=(const ParamIdx &I) const {\n    assertComparable(I);\n    return Idx >= I.Idx;\n  }\n};\n\nstatic_assert(sizeof(ParamIdx) == sizeof(ParamIdx::SerialType),\n              \"ParamIdx does not fit its serialization type\");\n\n/// Contains information gathered from parsing the contents of TargetAttr.\nstruct ParsedTargetAttr {\n  std::vector<std::string> Features;\n  StringRef Architecture;\n  StringRef Tune;\n  StringRef BranchProtection;\n  bool DuplicateArchitecture = false;\n  bool DuplicateTune = false;\n  bool operator ==(const ParsedTargetAttr &Other) const {\n    return DuplicateArchitecture == Other.DuplicateArchitecture &&\n           DuplicateTune == Other.DuplicateTune &&\n           Architecture == Other.Architecture &&\n           Tune == Other.Tune &&\n           BranchProtection == Other.BranchProtection &&\n           Features == Other.Features;\n  }\n};\n\n#include \"clang/AST/Attrs.inc\"\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             const Attr *At) {\n  DB.AddTaggedVal(reinterpret_cast<intptr_t>(At),\n                  DiagnosticsEngine::ak_attr);\n  return DB;\n}\n}  // end namespace clang\n\n#endif\n"}, "5": {"id": 5, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Comment.h", "content": "//===--- Comment.h - Comment AST nodes --------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines comment AST nodes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_COMMENT_H\n#define LLVM_CLANG_AST_COMMENT_H\n\n#include \"clang/AST/CommentCommandTraits.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringRef.h\"\n\nnamespace clang {\nclass Decl;\nclass ParmVarDecl;\nclass TemplateParameterList;\n\nnamespace comments {\nclass FullComment;\n\n/// Describes the syntax that was used in a documentation command.\n///\n/// Exact values of this enumeration are important because they used to select\n/// parts of diagnostic messages.  Audit diagnostics before changing or adding\n/// a new value.\nenum CommandMarkerKind {\n  /// Command started with a backslash character:\n  /// \\code\n  ///   \\foo\n  /// \\endcode\n  CMK_Backslash = 0,\n\n  /// Command started with an 'at' character:\n  /// \\code\n  ///   @foo\n  /// \\endcode\n  CMK_At = 1\n};\n\n/// Any part of the comment.\n/// Abstract class.\nclass Comment {\nprotected:\n  /// Preferred location to show caret.\n  SourceLocation Loc;\n\n  /// Source range of this AST node.\n  SourceRange Range;\n\n  class CommentBitfields {\n    friend class Comment;\n\n    /// Type of this AST node.\n    unsigned Kind : 8;\n  };\n  enum { NumCommentBits = 8 };\n\n  class InlineContentCommentBitfields {\n    friend class InlineContentComment;\n\n    unsigned : NumCommentBits;\n\n    /// True if there is a newline after this inline content node.\n    /// (There is no separate AST node for a newline.)\n    unsigned HasTrailingNewline : 1;\n  };\n  enum { NumInlineContentCommentBits = NumCommentBits + 1 };\n\n  class TextCommentBitfields {\n    friend class TextComment;\n\n    unsigned : NumInlineContentCommentBits;\n\n    /// True if \\c IsWhitespace field contains a valid value.\n    mutable unsigned IsWhitespaceValid : 1;\n\n    /// True if this comment AST node contains only whitespace.\n    mutable unsigned IsWhitespace : 1;\n  };\n  enum { NumTextCommentBits = NumInlineContentCommentBits + 2 };\n\n  class InlineCommandCommentBitfields {\n    friend class InlineCommandComment;\n\n    unsigned : NumInlineContentCommentBits;\n\n    unsigned RenderKind : 3;\n\n    unsigned CommandID : CommandInfo::NumCommandIDBits;\n  };\n  enum { NumInlineCommandCommentBits = NumInlineContentCommentBits + 3 +\n                                       CommandInfo::NumCommandIDBits };\n\n  class HTMLTagCommentBitfields {\n    friend class HTMLTagComment;\n\n    unsigned : NumInlineContentCommentBits;\n\n    /// True if we found that this tag is malformed in some way.\n    unsigned IsMalformed : 1;\n  };\n  enum { NumHTMLTagCommentBits = NumInlineContentCommentBits + 1 };\n\n  class HTMLStartTagCommentBitfields {\n    friend class HTMLStartTagComment;\n\n    unsigned : NumHTMLTagCommentBits;\n\n    /// True if this tag is self-closing (e. g., <br />).  This is based on tag\n    /// spelling in comment (plain <br> would not set this flag).\n    unsigned IsSelfClosing : 1;\n  };\n  enum { NumHTMLStartTagCommentBits = NumHTMLTagCommentBits + 1 };\n\n  class ParagraphCommentBitfields {\n    friend class ParagraphComment;\n\n    unsigned : NumCommentBits;\n\n    /// True if \\c IsWhitespace field contains a valid value.\n    mutable unsigned IsWhitespaceValid : 1;\n\n    /// True if this comment AST node contains only whitespace.\n    mutable unsigned IsWhitespace : 1;\n  };\n  enum { NumParagraphCommentBits = NumCommentBits + 2 };\n\n  class BlockCommandCommentBitfields {\n    friend class BlockCommandComment;\n\n    unsigned : NumCommentBits;\n\n    unsigned CommandID : CommandInfo::NumCommandIDBits;\n\n    /// Describes the syntax that was used in a documentation command.\n    /// Contains values from CommandMarkerKind enum.\n    unsigned CommandMarker : 1;\n  };\n  enum { NumBlockCommandCommentBits = NumCommentBits +\n                                      CommandInfo::NumCommandIDBits + 1 };\n\n  class ParamCommandCommentBitfields {\n    friend class ParamCommandComment;\n\n    unsigned : NumBlockCommandCommentBits;\n\n    /// Parameter passing direction, see ParamCommandComment::PassDirection.\n    unsigned Direction : 2;\n\n    /// True if direction was specified explicitly in the comment.\n    unsigned IsDirectionExplicit : 1;\n  };\n  enum { NumParamCommandCommentBits = NumBlockCommandCommentBits + 3 };\n\n  union {\n    CommentBitfields CommentBits;\n    InlineContentCommentBitfields InlineContentCommentBits;\n    TextCommentBitfields TextCommentBits;\n    InlineCommandCommentBitfields InlineCommandCommentBits;\n    HTMLTagCommentBitfields HTMLTagCommentBits;\n    HTMLStartTagCommentBitfields HTMLStartTagCommentBits;\n    ParagraphCommentBitfields ParagraphCommentBits;\n    BlockCommandCommentBitfields BlockCommandCommentBits;\n    ParamCommandCommentBitfields ParamCommandCommentBits;\n  };\n\n  void setSourceRange(SourceRange SR) {\n    Range = SR;\n  }\n\n  void setLocation(SourceLocation L) {\n    Loc = L;\n  }\n\npublic:\n  enum CommentKind {\n    NoCommentKind = 0,\n#define COMMENT(CLASS, PARENT) CLASS##Kind,\n#define COMMENT_RANGE(BASE, FIRST, LAST) \\\n    First##BASE##Constant=FIRST##Kind, Last##BASE##Constant=LAST##Kind,\n#define LAST_COMMENT_RANGE(BASE, FIRST, LAST) \\\n    First##BASE##Constant=FIRST##Kind, Last##BASE##Constant=LAST##Kind\n#define ABSTRACT_COMMENT(COMMENT)\n#include \"clang/AST/CommentNodes.inc\"\n  };\n\n  Comment(CommentKind K,\n          SourceLocation LocBegin,\n          SourceLocation LocEnd) :\n      Loc(LocBegin), Range(SourceRange(LocBegin, LocEnd)) {\n    CommentBits.Kind = K;\n  }\n\n  CommentKind getCommentKind() const {\n    return static_cast<CommentKind>(CommentBits.Kind);\n  }\n\n  const char *getCommentKindName() const;\n\n  void dump() const;\n  void dumpColor() const;\n  void dump(raw_ostream &OS, const ASTContext &Context) const;\n\n  SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n\n  SourceLocation getLocation() const LLVM_READONLY { return Loc; }\n\n  typedef Comment * const *child_iterator;\n\n  child_iterator child_begin() const;\n  child_iterator child_end() const;\n\n  // TODO: const child iterator\n\n  unsigned child_count() const {\n    return child_end() - child_begin();\n  }\n};\n\n/// Inline content (contained within a block).\n/// Abstract class.\nclass InlineContentComment : public Comment {\nprotected:\n  InlineContentComment(CommentKind K,\n                       SourceLocation LocBegin,\n                       SourceLocation LocEnd) :\n      Comment(K, LocBegin, LocEnd) {\n    InlineContentCommentBits.HasTrailingNewline = 0;\n  }\n\npublic:\n  static bool classof(const Comment *C) {\n    return C->getCommentKind() >= FirstInlineContentCommentConstant &&\n           C->getCommentKind() <= LastInlineContentCommentConstant;\n  }\n\n  void addTrailingNewline() {\n    InlineContentCommentBits.HasTrailingNewline = 1;\n  }\n\n  bool hasTrailingNewline() const {\n    return InlineContentCommentBits.HasTrailingNewline;\n  }\n};\n\n/// Plain text.\nclass TextComment : public InlineContentComment {\n  StringRef Text;\n\npublic:\n  TextComment(SourceLocation LocBegin,\n              SourceLocation LocEnd,\n              StringRef Text) :\n      InlineContentComment(TextCommentKind, LocBegin, LocEnd),\n      Text(Text) {\n    TextCommentBits.IsWhitespaceValid = false;\n  }\n\n  static bool classof(const Comment *C) {\n    return C->getCommentKind() == TextCommentKind;\n  }\n\n  child_iterator child_begin() const { return nullptr; }\n\n  child_iterator child_end() const { return nullptr; }\n\n  StringRef getText() const LLVM_READONLY { return Text; }\n\n  bool isWhitespace() const {\n    if (TextCommentBits.IsWhitespaceValid)\n      return TextCommentBits.IsWhitespace;\n\n    TextCommentBits.IsWhitespace = isWhitespaceNoCache();\n    TextCommentBits.IsWhitespaceValid = true;\n    return TextCommentBits.IsWhitespace;\n  }\n\nprivate:\n  bool isWhitespaceNoCache() const;\n};\n\n/// A command with word-like arguments that is considered inline content.\nclass InlineCommandComment : public InlineContentComment {\npublic:\n  struct Argument {\n    SourceRange Range;\n    StringRef Text;\n\n    Argument(SourceRange Range, StringRef Text) : Range(Range), Text(Text) { }\n  };\n\n  /// The most appropriate rendering mode for this command, chosen on command\n  /// semantics in Doxygen.\n  enum RenderKind {\n    RenderNormal,\n    RenderBold,\n    RenderMonospaced,\n    RenderEmphasized,\n    RenderAnchor\n  };\n\nprotected:\n  /// Command arguments.\n  ArrayRef<Argument> Args;\n\npublic:\n  InlineCommandComment(SourceLocation LocBegin,\n                       SourceLocation LocEnd,\n                       unsigned CommandID,\n                       RenderKind RK,\n                       ArrayRef<Argument> Args) :\n      InlineContentComment(InlineCommandCommentKind, LocBegin, LocEnd),\n      Args(Args) {\n    InlineCommandCommentBits.RenderKind = RK;\n    InlineCommandCommentBits.CommandID = CommandID;\n  }\n\n  static bool classof(const Comment *C) {\n    return C->getCommentKind() == InlineCommandCommentKind;\n  }\n\n  child_iterator child_begin() const { return nullptr; }\n\n  child_iterator child_end() const { return nullptr; }\n\n  unsigned getCommandID() const {\n    return InlineCommandCommentBits.CommandID;\n  }\n\n  StringRef getCommandName(const CommandTraits &Traits) const {\n    return Traits.getCommandInfo(getCommandID())->Name;\n  }\n\n  SourceRange getCommandNameRange() const {\n    return SourceRange(getBeginLoc().getLocWithOffset(-1), getEndLoc());\n  }\n\n  RenderKind getRenderKind() const {\n    return static_cast<RenderKind>(InlineCommandCommentBits.RenderKind);\n  }\n\n  unsigned getNumArgs() const {\n    return Args.size();\n  }\n\n  StringRef getArgText(unsigned Idx) const {\n    return Args[Idx].Text;\n  }\n\n  SourceRange getArgRange(unsigned Idx) const {\n    return Args[Idx].Range;\n  }\n};\n\n/// Abstract class for opening and closing HTML tags.  HTML tags are always\n/// treated as inline content (regardless HTML semantics).\nclass HTMLTagComment : public InlineContentComment {\nprotected:\n  StringRef TagName;\n  SourceRange TagNameRange;\n\n  HTMLTagComment(CommentKind K,\n                 SourceLocation LocBegin,\n                 SourceLocation LocEnd,\n                 StringRef TagName,\n                 SourceLocation TagNameBegin,\n                 SourceLocation TagNameEnd) :\n      InlineContentComment(K, LocBegin, LocEnd),\n      TagName(TagName),\n      TagNameRange(TagNameBegin, TagNameEnd) {\n    setLocation(TagNameBegin);\n    HTMLTagCommentBits.IsMalformed = 0;\n  }\n\npublic:\n  static bool classof(const Comment *C) {\n    return C->getCommentKind() >= FirstHTMLTagCommentConstant &&\n           C->getCommentKind() <= LastHTMLTagCommentConstant;\n  }\n\n  StringRef getTagName() const LLVM_READONLY { return TagName; }\n\n  SourceRange getTagNameSourceRange() const LLVM_READONLY {\n    SourceLocation L = getLocation();\n    return SourceRange(L.getLocWithOffset(1),\n                       L.getLocWithOffset(1 + TagName.size()));\n  }\n\n  bool isMalformed() const {\n    return HTMLTagCommentBits.IsMalformed;\n  }\n\n  void setIsMalformed() {\n    HTMLTagCommentBits.IsMalformed = 1;\n  }\n};\n\n/// An opening HTML tag with attributes.\nclass HTMLStartTagComment : public HTMLTagComment {\npublic:\n  class Attribute {\n  public:\n    SourceLocation NameLocBegin;\n    StringRef Name;\n\n    SourceLocation EqualsLoc;\n\n    SourceRange ValueRange;\n    StringRef Value;\n\n    Attribute() { }\n\n    Attribute(SourceLocation NameLocBegin, StringRef Name) :\n        NameLocBegin(NameLocBegin), Name(Name),\n        EqualsLoc(SourceLocation()),\n        ValueRange(SourceRange()), Value(StringRef())\n    { }\n\n    Attribute(SourceLocation NameLocBegin, StringRef Name,\n              SourceLocation EqualsLoc,\n              SourceRange ValueRange, StringRef Value) :\n        NameLocBegin(NameLocBegin), Name(Name),\n        EqualsLoc(EqualsLoc),\n        ValueRange(ValueRange), Value(Value)\n    { }\n\n    SourceLocation getNameLocEnd() const {\n      return NameLocBegin.getLocWithOffset(Name.size());\n    }\n\n    SourceRange getNameRange() const {\n      return SourceRange(NameLocBegin, getNameLocEnd());\n    }\n  };\n\nprivate:\n  ArrayRef<Attribute> Attributes;\n\npublic:\n  HTMLStartTagComment(SourceLocation LocBegin,\n                      StringRef TagName) :\n      HTMLTagComment(HTMLStartTagCommentKind,\n                     LocBegin, LocBegin.getLocWithOffset(1 + TagName.size()),\n                     TagName,\n                     LocBegin.getLocWithOffset(1),\n                     LocBegin.getLocWithOffset(1 + TagName.size())) {\n    HTMLStartTagCommentBits.IsSelfClosing = false;\n  }\n\n  static bool classof(const Comment *C) {\n    return C->getCommentKind() == HTMLStartTagCommentKind;\n  }\n\n  child_iterator child_begin() const { return nullptr; }\n\n  child_iterator child_end() const { return nullptr; }\n\n  unsigned getNumAttrs() const {\n    return Attributes.size();\n  }\n\n  const Attribute &getAttr(unsigned Idx) const {\n    return Attributes[Idx];\n  }\n\n  void setAttrs(ArrayRef<Attribute> Attrs) {\n    Attributes = Attrs;\n    if (!Attrs.empty()) {\n      const Attribute &Attr = Attrs.back();\n      SourceLocation L = Attr.ValueRange.getEnd();\n      if (L.isValid())\n        Range.setEnd(L);\n      else {\n        Range.setEnd(Attr.getNameLocEnd());\n      }\n    }\n  }\n\n  void setGreaterLoc(SourceLocation GreaterLoc) {\n    Range.setEnd(GreaterLoc);\n  }\n\n  bool isSelfClosing() const {\n    return HTMLStartTagCommentBits.IsSelfClosing;\n  }\n\n  void setSelfClosing() {\n    HTMLStartTagCommentBits.IsSelfClosing = true;\n  }\n};\n\n/// A closing HTML tag.\nclass HTMLEndTagComment : public HTMLTagComment {\npublic:\n  HTMLEndTagComment(SourceLocation LocBegin,\n                    SourceLocation LocEnd,\n                    StringRef TagName) :\n      HTMLTagComment(HTMLEndTagCommentKind,\n                     LocBegin, LocEnd,\n                     TagName,\n                     LocBegin.getLocWithOffset(2),\n                     LocBegin.getLocWithOffset(2 + TagName.size()))\n  { }\n\n  static bool classof(const Comment *C) {\n    return C->getCommentKind() == HTMLEndTagCommentKind;\n  }\n\n  child_iterator child_begin() const { return nullptr; }\n\n  child_iterator child_end() const { return nullptr; }\n};\n\n/// Block content (contains inline content).\n/// Abstract class.\nclass BlockContentComment : public Comment {\nprotected:\n  BlockContentComment(CommentKind K,\n                      SourceLocation LocBegin,\n                      SourceLocation LocEnd) :\n      Comment(K, LocBegin, LocEnd)\n  { }\n\npublic:\n  static bool classof(const Comment *C) {\n    return C->getCommentKind() >= FirstBlockContentCommentConstant &&\n           C->getCommentKind() <= LastBlockContentCommentConstant;\n  }\n};\n\n/// A single paragraph that contains inline content.\nclass ParagraphComment : public BlockContentComment {\n  ArrayRef<InlineContentComment *> Content;\n\npublic:\n  ParagraphComment(ArrayRef<InlineContentComment *> Content) :\n      BlockContentComment(ParagraphCommentKind,\n                          SourceLocation(),\n                          SourceLocation()),\n      Content(Content) {\n    if (Content.empty()) {\n      ParagraphCommentBits.IsWhitespace = true;\n      ParagraphCommentBits.IsWhitespaceValid = true;\n      return;\n    }\n\n    ParagraphCommentBits.IsWhitespaceValid = false;\n\n    setSourceRange(SourceRange(Content.front()->getBeginLoc(),\n                               Content.back()->getEndLoc()));\n    setLocation(Content.front()->getBeginLoc());\n  }\n\n  static bool classof(const Comment *C) {\n    return C->getCommentKind() == ParagraphCommentKind;\n  }\n\n  child_iterator child_begin() const {\n    return reinterpret_cast<child_iterator>(Content.begin());\n  }\n\n  child_iterator child_end() const {\n    return reinterpret_cast<child_iterator>(Content.end());\n  }\n\n  bool isWhitespace() const {\n    if (ParagraphCommentBits.IsWhitespaceValid)\n      return ParagraphCommentBits.IsWhitespace;\n\n    ParagraphCommentBits.IsWhitespace = isWhitespaceNoCache();\n    ParagraphCommentBits.IsWhitespaceValid = true;\n    return ParagraphCommentBits.IsWhitespace;\n  }\n\nprivate:\n  bool isWhitespaceNoCache() const;\n};\n\n/// A command that has zero or more word-like arguments (number of word-like\n/// arguments depends on command name) and a paragraph as an argument\n/// (e. g., \\\\brief).\nclass BlockCommandComment : public BlockContentComment {\npublic:\n  struct Argument {\n    SourceRange Range;\n    StringRef Text;\n\n    Argument() { }\n    Argument(SourceRange Range, StringRef Text) : Range(Range), Text(Text) { }\n  };\n\nprotected:\n  /// Word-like arguments.\n  ArrayRef<Argument> Args;\n\n  /// Paragraph argument.\n  ParagraphComment *Paragraph;\n\n  BlockCommandComment(CommentKind K,\n                      SourceLocation LocBegin,\n                      SourceLocation LocEnd,\n                      unsigned CommandID,\n                      CommandMarkerKind CommandMarker) :\n      BlockContentComment(K, LocBegin, LocEnd),\n      Paragraph(nullptr) {\n    setLocation(getCommandNameBeginLoc());\n    BlockCommandCommentBits.CommandID = CommandID;\n    BlockCommandCommentBits.CommandMarker = CommandMarker;\n  }\n\npublic:\n  BlockCommandComment(SourceLocation LocBegin,\n                      SourceLocation LocEnd,\n                      unsigned CommandID,\n                      CommandMarkerKind CommandMarker) :\n      BlockContentComment(BlockCommandCommentKind, LocBegin, LocEnd),\n      Paragraph(nullptr) {\n    setLocation(getCommandNameBeginLoc());\n    BlockCommandCommentBits.CommandID = CommandID;\n    BlockCommandCommentBits.CommandMarker = CommandMarker;\n  }\n\n  static bool classof(const Comment *C) {\n    return C->getCommentKind() >= FirstBlockCommandCommentConstant &&\n           C->getCommentKind() <= LastBlockCommandCommentConstant;\n  }\n\n  child_iterator child_begin() const {\n    return reinterpret_cast<child_iterator>(&Paragraph);\n  }\n\n  child_iterator child_end() const {\n    return reinterpret_cast<child_iterator>(&Paragraph + 1);\n  }\n\n  unsigned getCommandID() const {\n    return BlockCommandCommentBits.CommandID;\n  }\n\n  StringRef getCommandName(const CommandTraits &Traits) const {\n    return Traits.getCommandInfo(getCommandID())->Name;\n  }\n\n  SourceLocation getCommandNameBeginLoc() const {\n    return getBeginLoc().getLocWithOffset(1);\n  }\n\n  SourceRange getCommandNameRange(const CommandTraits &Traits) const {\n    StringRef Name = getCommandName(Traits);\n    return SourceRange(getCommandNameBeginLoc(),\n                       getBeginLoc().getLocWithOffset(1 + Name.size()));\n  }\n\n  unsigned getNumArgs() const {\n    return Args.size();\n  }\n\n  StringRef getArgText(unsigned Idx) const {\n    return Args[Idx].Text;\n  }\n\n  SourceRange getArgRange(unsigned Idx) const {\n    return Args[Idx].Range;\n  }\n\n  void setArgs(ArrayRef<Argument> A) {\n    Args = A;\n    if (Args.size() > 0) {\n      SourceLocation NewLocEnd = Args.back().Range.getEnd();\n      if (NewLocEnd.isValid())\n        setSourceRange(SourceRange(getBeginLoc(), NewLocEnd));\n    }\n  }\n\n  ParagraphComment *getParagraph() const LLVM_READONLY {\n    return Paragraph;\n  }\n\n  bool hasNonWhitespaceParagraph() const {\n    return Paragraph && !Paragraph->isWhitespace();\n  }\n\n  void setParagraph(ParagraphComment *PC) {\n    Paragraph = PC;\n    SourceLocation NewLocEnd = PC->getEndLoc();\n    if (NewLocEnd.isValid())\n      setSourceRange(SourceRange(getBeginLoc(), NewLocEnd));\n  }\n\n  CommandMarkerKind getCommandMarker() const LLVM_READONLY {\n    return static_cast<CommandMarkerKind>(\n        BlockCommandCommentBits.CommandMarker);\n  }\n};\n\n/// Doxygen \\\\param command.\nclass ParamCommandComment : public BlockCommandComment {\nprivate:\n  /// Parameter index in the function declaration.\n  unsigned ParamIndex;\n\npublic:\n  enum : unsigned {\n    InvalidParamIndex = ~0U,\n    VarArgParamIndex = ~0U/*InvalidParamIndex*/ - 1U\n  };\n\n  ParamCommandComment(SourceLocation LocBegin,\n                      SourceLocation LocEnd,\n                      unsigned CommandID,\n                      CommandMarkerKind CommandMarker) :\n      BlockCommandComment(ParamCommandCommentKind, LocBegin, LocEnd,\n                          CommandID, CommandMarker),\n      ParamIndex(InvalidParamIndex) {\n    ParamCommandCommentBits.Direction = In;\n    ParamCommandCommentBits.IsDirectionExplicit = false;\n  }\n\n  static bool classof(const Comment *C) {\n    return C->getCommentKind() == ParamCommandCommentKind;\n  }\n\n  enum PassDirection {\n    In,\n    Out,\n    InOut\n  };\n\n  static const char *getDirectionAsString(PassDirection D);\n\n  PassDirection getDirection() const LLVM_READONLY {\n    return static_cast<PassDirection>(ParamCommandCommentBits.Direction);\n  }\n\n  bool isDirectionExplicit() const LLVM_READONLY {\n    return ParamCommandCommentBits.IsDirectionExplicit;\n  }\n\n  void setDirection(PassDirection Direction, bool Explicit) {\n    ParamCommandCommentBits.Direction = Direction;\n    ParamCommandCommentBits.IsDirectionExplicit = Explicit;\n  }\n\n  bool hasParamName() const {\n    return getNumArgs() > 0;\n  }\n\n  StringRef getParamName(const FullComment *FC) const;\n\n  StringRef getParamNameAsWritten() const {\n    return Args[0].Text;\n  }\n\n  SourceRange getParamNameRange() const {\n    return Args[0].Range;\n  }\n\n  bool isParamIndexValid() const LLVM_READONLY {\n    return ParamIndex != InvalidParamIndex;\n  }\n\n  bool isVarArgParam() const LLVM_READONLY {\n    return ParamIndex == VarArgParamIndex;\n  }\n\n  void setIsVarArgParam() {\n    ParamIndex = VarArgParamIndex;\n    assert(isParamIndexValid());\n  }\n\n  unsigned getParamIndex() const LLVM_READONLY {\n    assert(isParamIndexValid());\n    assert(!isVarArgParam());\n    return ParamIndex;\n  }\n\n  void setParamIndex(unsigned Index) {\n    ParamIndex = Index;\n    assert(isParamIndexValid());\n    assert(!isVarArgParam());\n  }\n};\n\n/// Doxygen \\\\tparam command, describes a template parameter.\nclass TParamCommandComment : public BlockCommandComment {\nprivate:\n  /// If this template parameter name was resolved (found in template parameter\n  /// list), then this stores a list of position indexes in all template\n  /// parameter lists.\n  ///\n  /// For example:\n  /// \\verbatim\n  ///     template<typename C, template<typename T> class TT>\n  ///     void test(TT<int> aaa);\n  /// \\endverbatim\n  /// For C:  Position = { 0 }\n  /// For TT: Position = { 1 }\n  /// For T:  Position = { 1, 0 }\n  ArrayRef<unsigned> Position;\n\npublic:\n  TParamCommandComment(SourceLocation LocBegin,\n                       SourceLocation LocEnd,\n                       unsigned CommandID,\n                       CommandMarkerKind CommandMarker) :\n      BlockCommandComment(TParamCommandCommentKind, LocBegin, LocEnd, CommandID,\n                          CommandMarker)\n  { }\n\n  static bool classof(const Comment *C) {\n    return C->getCommentKind() == TParamCommandCommentKind;\n  }\n\n  bool hasParamName() const {\n    return getNumArgs() > 0;\n  }\n\n  StringRef getParamName(const FullComment *FC) const;\n\n  StringRef getParamNameAsWritten() const {\n    return Args[0].Text;\n  }\n\n  SourceRange getParamNameRange() const {\n    return Args[0].Range;\n  }\n\n  bool isPositionValid() const LLVM_READONLY {\n    return !Position.empty();\n  }\n\n  unsigned getDepth() const {\n    assert(isPositionValid());\n    return Position.size();\n  }\n\n  unsigned getIndex(unsigned Depth) const {\n    assert(isPositionValid());\n    return Position[Depth];\n  }\n\n  void setPosition(ArrayRef<unsigned> NewPosition) {\n    Position = NewPosition;\n    assert(isPositionValid());\n  }\n};\n\n/// A line of text contained in a verbatim block.\nclass VerbatimBlockLineComment : public Comment {\n  StringRef Text;\n\npublic:\n  VerbatimBlockLineComment(SourceLocation LocBegin,\n                           StringRef Text) :\n      Comment(VerbatimBlockLineCommentKind,\n              LocBegin,\n              LocBegin.getLocWithOffset(Text.size())),\n      Text(Text)\n  { }\n\n  static bool classof(const Comment *C) {\n    return C->getCommentKind() == VerbatimBlockLineCommentKind;\n  }\n\n  child_iterator child_begin() const { return nullptr; }\n\n  child_iterator child_end() const { return nullptr; }\n\n  StringRef getText() const LLVM_READONLY {\n    return Text;\n  }\n};\n\n/// A verbatim block command (e. g., preformatted code).  Verbatim block has an\n/// opening and a closing command and contains multiple lines of text\n/// (VerbatimBlockLineComment nodes).\nclass VerbatimBlockComment : public BlockCommandComment {\nprotected:\n  StringRef CloseName;\n  SourceLocation CloseNameLocBegin;\n  ArrayRef<VerbatimBlockLineComment *> Lines;\n\npublic:\n  VerbatimBlockComment(SourceLocation LocBegin,\n                       SourceLocation LocEnd,\n                       unsigned CommandID) :\n      BlockCommandComment(VerbatimBlockCommentKind,\n                          LocBegin, LocEnd, CommandID,\n                          CMK_At) // FIXME: improve source fidelity.\n  { }\n\n  static bool classof(const Comment *C) {\n    return C->getCommentKind() == VerbatimBlockCommentKind;\n  }\n\n  child_iterator child_begin() const {\n    return reinterpret_cast<child_iterator>(Lines.begin());\n  }\n\n  child_iterator child_end() const {\n    return reinterpret_cast<child_iterator>(Lines.end());\n  }\n\n  void setCloseName(StringRef Name, SourceLocation LocBegin) {\n    CloseName = Name;\n    CloseNameLocBegin = LocBegin;\n  }\n\n  void setLines(ArrayRef<VerbatimBlockLineComment *> L) {\n    Lines = L;\n  }\n\n  StringRef getCloseName() const {\n    return CloseName;\n  }\n\n  unsigned getNumLines() const {\n    return Lines.size();\n  }\n\n  StringRef getText(unsigned LineIdx) const {\n    return Lines[LineIdx]->getText();\n  }\n};\n\n/// A verbatim line command.  Verbatim line has an opening command, a single\n/// line of text (up to the newline after the opening command) and has no\n/// closing command.\nclass VerbatimLineComment : public BlockCommandComment {\nprotected:\n  StringRef Text;\n  SourceLocation TextBegin;\n\npublic:\n  VerbatimLineComment(SourceLocation LocBegin,\n                      SourceLocation LocEnd,\n                      unsigned CommandID,\n                      SourceLocation TextBegin,\n                      StringRef Text) :\n      BlockCommandComment(VerbatimLineCommentKind,\n                          LocBegin, LocEnd,\n                          CommandID,\n                          CMK_At), // FIXME: improve source fidelity.\n      Text(Text),\n      TextBegin(TextBegin)\n  { }\n\n  static bool classof(const Comment *C) {\n    return C->getCommentKind() == VerbatimLineCommentKind;\n  }\n\n  child_iterator child_begin() const { return nullptr; }\n\n  child_iterator child_end() const { return nullptr; }\n\n  StringRef getText() const {\n    return Text;\n  }\n\n  SourceRange getTextRange() const {\n    return SourceRange(TextBegin, getEndLoc());\n  }\n};\n\n/// Information about the declaration, useful to clients of FullComment.\nstruct DeclInfo {\n  /// Declaration the comment is actually attached to (in the source).\n  /// Should not be NULL.\n  const Decl *CommentDecl;\n\n  /// CurrentDecl is the declaration with which the FullComment is associated.\n  ///\n  /// It can be different from \\c CommentDecl.  It happens when we decide\n  /// that the comment originally attached to \\c CommentDecl is fine for\n  /// \\c CurrentDecl too (for example, for a redeclaration or an overrider of\n  /// \\c CommentDecl).\n  ///\n  /// The information in the DeclInfo corresponds to CurrentDecl.\n  const Decl *CurrentDecl;\n\n  /// Parameters that can be referenced by \\\\param if \\c CommentDecl is something\n  /// that we consider a \"function\".\n  ArrayRef<const ParmVarDecl *> ParamVars;\n\n  /// Function return type if \\c CommentDecl is something that we consider\n  /// a \"function\".\n  QualType ReturnType;\n\n  /// Template parameters that can be referenced by \\\\tparam if \\c CommentDecl is\n  /// a template (\\c IsTemplateDecl or \\c IsTemplatePartialSpecialization is\n  /// true).\n  const TemplateParameterList *TemplateParameters;\n\n  /// A simplified description of \\c CommentDecl kind that should be good enough\n  /// for documentation rendering purposes.\n  enum DeclKind {\n    /// Everything else not explicitly mentioned below.\n    OtherKind,\n\n    /// Something that we consider a \"function\":\n    /// \\li function,\n    /// \\li function template,\n    /// \\li function template specialization,\n    /// \\li member function,\n    /// \\li member function template,\n    /// \\li member function template specialization,\n    /// \\li ObjC method,\n    /// \\li a typedef for a function pointer, member function pointer,\n    ///     ObjC block.\n    FunctionKind,\n\n    /// Something that we consider a \"class\":\n    /// \\li class/struct,\n    /// \\li class template,\n    /// \\li class template (partial) specialization.\n    ClassKind,\n\n    /// Something that we consider a \"variable\":\n    /// \\li namespace scope variables;\n    /// \\li static and non-static class data members;\n    /// \\li enumerators.\n    VariableKind,\n\n    /// A C++ namespace.\n    NamespaceKind,\n\n    /// A C++ typedef-name (a 'typedef' decl specifier or alias-declaration),\n    /// see \\c TypedefNameDecl.\n    TypedefKind,\n\n    /// An enumeration or scoped enumeration.\n    EnumKind\n  };\n\n  /// What kind of template specialization \\c CommentDecl is.\n  enum TemplateDeclKind {\n    NotTemplate,\n    Template,\n    TemplateSpecialization,\n    TemplatePartialSpecialization\n  };\n\n  /// If false, only \\c CommentDecl is valid.\n  unsigned IsFilled : 1;\n\n  /// Simplified kind of \\c CommentDecl, see \\c DeclKind enum.\n  unsigned Kind : 3;\n\n  /// Is \\c CommentDecl a template declaration.\n  unsigned TemplateKind : 2;\n\n  /// Is \\c CommentDecl an ObjCMethodDecl.\n  unsigned IsObjCMethod : 1;\n\n  /// Is \\c CommentDecl a non-static member function of C++ class or\n  /// instance method of ObjC class.\n  /// Can be true only if \\c IsFunctionDecl is true.\n  unsigned IsInstanceMethod : 1;\n\n  /// Is \\c CommentDecl a static member function of C++ class or\n  /// class method of ObjC class.\n  /// Can be true only if \\c IsFunctionDecl is true.\n  unsigned IsClassMethod : 1;\n\n  void fill();\n\n  DeclKind getKind() const LLVM_READONLY {\n    return static_cast<DeclKind>(Kind);\n  }\n\n  TemplateDeclKind getTemplateKind() const LLVM_READONLY {\n    return static_cast<TemplateDeclKind>(TemplateKind);\n  }\n};\n\n/// A full comment attached to a declaration, contains block content.\nclass FullComment : public Comment {\n  ArrayRef<BlockContentComment *> Blocks;\n  DeclInfo *ThisDeclInfo;\n\npublic:\n  FullComment(ArrayRef<BlockContentComment *> Blocks, DeclInfo *D) :\n      Comment(FullCommentKind, SourceLocation(), SourceLocation()),\n      Blocks(Blocks), ThisDeclInfo(D) {\n    if (Blocks.empty())\n      return;\n\n    setSourceRange(\n        SourceRange(Blocks.front()->getBeginLoc(), Blocks.back()->getEndLoc()));\n    setLocation(Blocks.front()->getBeginLoc());\n  }\n\n  static bool classof(const Comment *C) {\n    return C->getCommentKind() == FullCommentKind;\n  }\n\n  child_iterator child_begin() const {\n    return reinterpret_cast<child_iterator>(Blocks.begin());\n  }\n\n  child_iterator child_end() const {\n    return reinterpret_cast<child_iterator>(Blocks.end());\n  }\n\n  const Decl *getDecl() const LLVM_READONLY {\n    return ThisDeclInfo->CommentDecl;\n  }\n\n  const DeclInfo *getDeclInfo() const LLVM_READONLY {\n    if (!ThisDeclInfo->IsFilled)\n      ThisDeclInfo->fill();\n    return ThisDeclInfo;\n  }\n\n  ArrayRef<BlockContentComment *> getBlocks() const { return Blocks; }\n\n};\n} // end namespace comments\n} // end namespace clang\n\n#endif\n\n"}, "6": {"id": 6, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Decl.h", "content": "//===- Decl.h - Classes for representing declarations -----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the Decl subclasses.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_DECL_H\n#define LLVM_CLANG_AST_DECL_H\n\n#include \"clang/AST/APValue.h\"\n#include \"clang/AST/ASTContextAllocate.h\"\n#include \"clang/AST/DeclAccessPair.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/ExternalASTSource.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/Redeclarable.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/AddressSpaces.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/Linkage.h\"\n#include \"clang/Basic/OperatorKinds.h\"\n#include \"clang/Basic/PartialDiagnostic.h\"\n#include \"clang/Basic/PragmaKinds.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Basic/Visibility.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <string>\n#include <utility>\n\nnamespace clang {\n\nclass ASTContext;\nstruct ASTTemplateArgumentListInfo;\nclass Attr;\nclass CompoundStmt;\nclass DependentFunctionTemplateSpecializationInfo;\nclass EnumDecl;\nclass Expr;\nclass FunctionTemplateDecl;\nclass FunctionTemplateSpecializationInfo;\nclass FunctionTypeLoc;\nclass LabelStmt;\nclass MemberSpecializationInfo;\nclass Module;\nclass NamespaceDecl;\nclass ParmVarDecl;\nclass RecordDecl;\nclass Stmt;\nclass StringLiteral;\nclass TagDecl;\nclass TemplateArgumentList;\nclass TemplateArgumentListInfo;\nclass TemplateParameterList;\nclass TypeAliasTemplateDecl;\nclass TypeLoc;\nclass UnresolvedSetImpl;\nclass VarTemplateDecl;\n\n/// The top declaration context.\nclass TranslationUnitDecl : public Decl, public DeclContext {\n  ASTContext &Ctx;\n\n  /// The (most recently entered) anonymous namespace for this\n  /// translation unit, if one has been created.\n  NamespaceDecl *AnonymousNamespace = nullptr;\n\n  explicit TranslationUnitDecl(ASTContext &ctx);\n\n  virtual void anchor();\n\npublic:\n  ASTContext &getASTContext() const { return Ctx; }\n\n  NamespaceDecl *getAnonymousNamespace() const { return AnonymousNamespace; }\n  void setAnonymousNamespace(NamespaceDecl *D) { AnonymousNamespace = D; }\n\n  static TranslationUnitDecl *Create(ASTContext &C);\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == TranslationUnit; }\n  static DeclContext *castToDeclContext(const TranslationUnitDecl *D) {\n    return static_cast<DeclContext *>(const_cast<TranslationUnitDecl*>(D));\n  }\n  static TranslationUnitDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<TranslationUnitDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Represents a `#pragma comment` line. Always a child of\n/// TranslationUnitDecl.\nclass PragmaCommentDecl final\n    : public Decl,\n      private llvm::TrailingObjects<PragmaCommentDecl, char> {\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend TrailingObjects;\n\n  PragmaMSCommentKind CommentKind;\n\n  PragmaCommentDecl(TranslationUnitDecl *TU, SourceLocation CommentLoc,\n                    PragmaMSCommentKind CommentKind)\n      : Decl(PragmaComment, TU, CommentLoc), CommentKind(CommentKind) {}\n\n  virtual void anchor();\n\npublic:\n  static PragmaCommentDecl *Create(const ASTContext &C, TranslationUnitDecl *DC,\n                                   SourceLocation CommentLoc,\n                                   PragmaMSCommentKind CommentKind,\n                                   StringRef Arg);\n  static PragmaCommentDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                               unsigned ArgSize);\n\n  PragmaMSCommentKind getCommentKind() const { return CommentKind; }\n\n  StringRef getArg() const { return getTrailingObjects<char>(); }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == PragmaComment; }\n};\n\n/// Represents a `#pragma detect_mismatch` line. Always a child of\n/// TranslationUnitDecl.\nclass PragmaDetectMismatchDecl final\n    : public Decl,\n      private llvm::TrailingObjects<PragmaDetectMismatchDecl, char> {\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend TrailingObjects;\n\n  size_t ValueStart;\n\n  PragmaDetectMismatchDecl(TranslationUnitDecl *TU, SourceLocation Loc,\n                           size_t ValueStart)\n      : Decl(PragmaDetectMismatch, TU, Loc), ValueStart(ValueStart) {}\n\n  virtual void anchor();\n\npublic:\n  static PragmaDetectMismatchDecl *Create(const ASTContext &C,\n                                          TranslationUnitDecl *DC,\n                                          SourceLocation Loc, StringRef Name,\n                                          StringRef Value);\n  static PragmaDetectMismatchDecl *\n  CreateDeserialized(ASTContext &C, unsigned ID, unsigned NameValueSize);\n\n  StringRef getName() const { return getTrailingObjects<char>(); }\n  StringRef getValue() const { return getTrailingObjects<char>() + ValueStart; }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == PragmaDetectMismatch; }\n};\n\n/// Declaration context for names declared as extern \"C\" in C++. This\n/// is neither the semantic nor lexical context for such declarations, but is\n/// used to check for conflicts with other extern \"C\" declarations. Example:\n///\n/// \\code\n///   namespace N { extern \"C\" void f(); } // #1\n///   void N::f() {}                       // #2\n///   namespace M { extern \"C\" void f(); } // #3\n/// \\endcode\n///\n/// The semantic context of #1 is namespace N and its lexical context is the\n/// LinkageSpecDecl; the semantic context of #2 is namespace N and its lexical\n/// context is the TU. However, both declarations are also visible in the\n/// extern \"C\" context.\n///\n/// The declaration at #3 finds it is a redeclaration of \\c N::f through\n/// lookup in the extern \"C\" context.\nclass ExternCContextDecl : public Decl, public DeclContext {\n  explicit ExternCContextDecl(TranslationUnitDecl *TU)\n    : Decl(ExternCContext, TU, SourceLocation()),\n      DeclContext(ExternCContext) {}\n\n  virtual void anchor();\n\npublic:\n  static ExternCContextDecl *Create(const ASTContext &C,\n                                    TranslationUnitDecl *TU);\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ExternCContext; }\n  static DeclContext *castToDeclContext(const ExternCContextDecl *D) {\n    return static_cast<DeclContext *>(const_cast<ExternCContextDecl*>(D));\n  }\n  static ExternCContextDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<ExternCContextDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// This represents a decl that may have a name.  Many decls have names such\n/// as ObjCMethodDecl, but not \\@class, etc.\n///\n/// Note that not every NamedDecl is actually named (e.g., a struct might\n/// be anonymous), and not every name is an identifier.\nclass NamedDecl : public Decl {\n  /// The name of this declaration, which is typically a normal\n  /// identifier but may also be a special kind of name (C++\n  /// constructor, Objective-C selector, etc.)\n  DeclarationName Name;\n\n  virtual void anchor();\n\nprivate:\n  NamedDecl *getUnderlyingDeclImpl() LLVM_READONLY;\n\nprotected:\n  NamedDecl(Kind DK, DeclContext *DC, SourceLocation L, DeclarationName N)\n      : Decl(DK, DC, L), Name(N) {}\n\npublic:\n  /// Get the identifier that names this declaration, if there is one.\n  ///\n  /// This will return NULL if this declaration has no name (e.g., for\n  /// an unnamed class) or if the name is a special name (C++ constructor,\n  /// Objective-C selector, etc.).\n  IdentifierInfo *getIdentifier() const { return Name.getAsIdentifierInfo(); }\n\n  /// Get the name of identifier for this declaration as a StringRef.\n  ///\n  /// This requires that the declaration have a name and that it be a simple\n  /// identifier.\n  StringRef getName() const {\n    assert(Name.isIdentifier() && \"Name is not a simple identifier\");\n    return getIdentifier() ? getIdentifier()->getName() : \"\";\n  }\n\n  /// Get a human-readable name for the declaration, even if it is one of the\n  /// special kinds of names (C++ constructor, Objective-C selector, etc).\n  ///\n  /// Creating this name requires expensive string manipulation, so it should\n  /// be called only when performance doesn't matter. For simple declarations,\n  /// getNameAsCString() should suffice.\n  //\n  // FIXME: This function should be renamed to indicate that it is not just an\n  // alternate form of getName(), and clients should move as appropriate.\n  //\n  // FIXME: Deprecated, move clients to getName().\n  std::string getNameAsString() const { return Name.getAsString(); }\n\n  /// Pretty-print the unqualified name of this declaration. Can be overloaded\n  /// by derived classes to provide a more user-friendly name when appropriate.\n  virtual void printName(raw_ostream &os) const;\n\n  /// Get the actual, stored name of the declaration, which may be a special\n  /// name.\n  ///\n  /// Note that generally in diagnostics, the non-null \\p NamedDecl* itself\n  /// should be sent into the diagnostic instead of using the result of\n  /// \\p getDeclName().\n  ///\n  /// A \\p DeclarationName in a diagnostic will just be streamed to the output,\n  /// which will directly result in a call to \\p DeclarationName::print.\n  ///\n  /// A \\p NamedDecl* in a diagnostic will also ultimately result in a call to\n  /// \\p DeclarationName::print, but with two customisation points along the\n  /// way (\\p getNameForDiagnostic and \\p printName). These are used to print\n  /// the template arguments if any, and to provide a user-friendly name for\n  /// some entities (such as unnamed variables and anonymous records).\n  DeclarationName getDeclName() const { return Name; }\n\n  /// Set the name of this declaration.\n  void setDeclName(DeclarationName N) { Name = N; }\n\n  /// Returns a human-readable qualified name for this declaration, like\n  /// A::B::i, for i being member of namespace A::B.\n  ///\n  /// If the declaration is not a member of context which can be named (record,\n  /// namespace), it will return the same result as printName().\n  ///\n  /// Creating this name is expensive, so it should be called only when\n  /// performance doesn't matter.\n  void printQualifiedName(raw_ostream &OS) const;\n  void printQualifiedName(raw_ostream &OS, const PrintingPolicy &Policy) const;\n\n  /// Print only the nested name specifier part of a fully-qualified name,\n  /// including the '::' at the end. E.g.\n  ///    when `printQualifiedName(D)` prints \"A::B::i\",\n  ///    this function prints \"A::B::\".\n  void printNestedNameSpecifier(raw_ostream &OS) const;\n  void printNestedNameSpecifier(raw_ostream &OS,\n                                const PrintingPolicy &Policy) const;\n\n  // FIXME: Remove string version.\n  std::string getQualifiedNameAsString() const;\n\n  /// Appends a human-readable name for this declaration into the given stream.\n  ///\n  /// This is the method invoked by Sema when displaying a NamedDecl\n  /// in a diagnostic.  It does not necessarily produce the same\n  /// result as printName(); for example, class template\n  /// specializations are printed with their template arguments.\n  virtual void getNameForDiagnostic(raw_ostream &OS,\n                                    const PrintingPolicy &Policy,\n                                    bool Qualified) const;\n\n  /// Determine whether this declaration, if known to be well-formed within\n  /// its context, will replace the declaration OldD if introduced into scope.\n  ///\n  /// A declaration will replace another declaration if, for example, it is\n  /// a redeclaration of the same variable or function, but not if it is a\n  /// declaration of a different kind (function vs. class) or an overloaded\n  /// function.\n  ///\n  /// \\param IsKnownNewer \\c true if this declaration is known to be newer\n  /// than \\p OldD (for instance, if this declaration is newly-created).\n  bool declarationReplaces(NamedDecl *OldD, bool IsKnownNewer = true) const;\n\n  /// Determine whether this declaration has linkage.\n  bool hasLinkage() const;\n\n  using Decl::isModulePrivate;\n  using Decl::setModulePrivate;\n\n  /// Determine whether this declaration is a C++ class member.\n  bool isCXXClassMember() const {\n    const DeclContext *DC = getDeclContext();\n\n    // C++0x [class.mem]p1:\n    //   The enumerators of an unscoped enumeration defined in\n    //   the class are members of the class.\n    if (isa<EnumDecl>(DC))\n      DC = DC->getRedeclContext();\n\n    return DC->isRecord();\n  }\n\n  /// Determine whether the given declaration is an instance member of\n  /// a C++ class.\n  bool isCXXInstanceMember() const;\n\n  /// Determine what kind of linkage this entity has.\n  ///\n  /// This is not the linkage as defined by the standard or the codegen notion\n  /// of linkage. It is just an implementation detail that is used to compute\n  /// those.\n  Linkage getLinkageInternal() const;\n\n  /// Get the linkage from a semantic point of view. Entities in\n  /// anonymous namespaces are external (in c++98).\n  Linkage getFormalLinkage() const {\n    return clang::getFormalLinkage(getLinkageInternal());\n  }\n\n  /// True if this decl has external linkage.\n  bool hasExternalFormalLinkage() const {\n    return isExternalFormalLinkage(getLinkageInternal());\n  }\n\n  bool isExternallyVisible() const {\n    return clang::isExternallyVisible(getLinkageInternal());\n  }\n\n  /// Determine whether this declaration can be redeclared in a\n  /// different translation unit.\n  bool isExternallyDeclarable() const {\n    return isExternallyVisible() && !getOwningModuleForLinkage();\n  }\n\n  /// Determines the visibility of this entity.\n  Visibility getVisibility() const {\n    return getLinkageAndVisibility().getVisibility();\n  }\n\n  /// Determines the linkage and visibility of this entity.\n  LinkageInfo getLinkageAndVisibility() const;\n\n  /// Kinds of explicit visibility.\n  enum ExplicitVisibilityKind {\n    /// Do an LV computation for, ultimately, a type.\n    /// Visibility may be restricted by type visibility settings and\n    /// the visibility of template arguments.\n    VisibilityForType,\n\n    /// Do an LV computation for, ultimately, a non-type declaration.\n    /// Visibility may be restricted by value visibility settings and\n    /// the visibility of template arguments.\n    VisibilityForValue\n  };\n\n  /// If visibility was explicitly specified for this\n  /// declaration, return that visibility.\n  Optional<Visibility>\n  getExplicitVisibility(ExplicitVisibilityKind kind) const;\n\n  /// True if the computed linkage is valid. Used for consistency\n  /// checking. Should always return true.\n  bool isLinkageValid() const;\n\n  /// True if something has required us to compute the linkage\n  /// of this declaration.\n  ///\n  /// Language features which can retroactively change linkage (like a\n  /// typedef name for linkage purposes) may need to consider this,\n  /// but hopefully only in transitory ways during parsing.\n  bool hasLinkageBeenComputed() const {\n    return hasCachedLinkage();\n  }\n\n  /// Looks through UsingDecls and ObjCCompatibleAliasDecls for\n  /// the underlying named decl.\n  NamedDecl *getUnderlyingDecl() {\n    // Fast-path the common case.\n    if (this->getKind() != UsingShadow &&\n        this->getKind() != ConstructorUsingShadow &&\n        this->getKind() != ObjCCompatibleAlias &&\n        this->getKind() != NamespaceAlias)\n      return this;\n\n    return getUnderlyingDeclImpl();\n  }\n  const NamedDecl *getUnderlyingDecl() const {\n    return const_cast<NamedDecl*>(this)->getUnderlyingDecl();\n  }\n\n  NamedDecl *getMostRecentDecl() {\n    return cast<NamedDecl>(static_cast<Decl *>(this)->getMostRecentDecl());\n  }\n  const NamedDecl *getMostRecentDecl() const {\n    return const_cast<NamedDecl*>(this)->getMostRecentDecl();\n  }\n\n  ObjCStringFormatFamily getObjCFStringFormattingFamily() const;\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K >= firstNamed && K <= lastNamed; }\n};\n\ninline raw_ostream &operator<<(raw_ostream &OS, const NamedDecl &ND) {\n  ND.printName(OS);\n  return OS;\n}\n\n/// Represents the declaration of a label.  Labels also have a\n/// corresponding LabelStmt, which indicates the position that the label was\n/// defined at.  For normal labels, the location of the decl is the same as the\n/// location of the statement.  For GNU local labels (__label__), the decl\n/// location is where the __label__ is.\nclass LabelDecl : public NamedDecl {\n  LabelStmt *TheStmt;\n  StringRef MSAsmName;\n  bool MSAsmNameResolved = false;\n\n  /// For normal labels, this is the same as the main declaration\n  /// label, i.e., the location of the identifier; for GNU local labels,\n  /// this is the location of the __label__ keyword.\n  SourceLocation LocStart;\n\n  LabelDecl(DeclContext *DC, SourceLocation IdentL, IdentifierInfo *II,\n            LabelStmt *S, SourceLocation StartL)\n      : NamedDecl(Label, DC, IdentL, II), TheStmt(S), LocStart(StartL) {}\n\n  void anchor() override;\n\npublic:\n  static LabelDecl *Create(ASTContext &C, DeclContext *DC,\n                           SourceLocation IdentL, IdentifierInfo *II);\n  static LabelDecl *Create(ASTContext &C, DeclContext *DC,\n                           SourceLocation IdentL, IdentifierInfo *II,\n                           SourceLocation GnuLabelL);\n  static LabelDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  LabelStmt *getStmt() const { return TheStmt; }\n  void setStmt(LabelStmt *T) { TheStmt = T; }\n\n  bool isGnuLocal() const { return LocStart != getLocation(); }\n  void setLocStart(SourceLocation L) { LocStart = L; }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(LocStart, getLocation());\n  }\n\n  bool isMSAsmLabel() const { return !MSAsmName.empty(); }\n  bool isResolvedMSAsmLabel() const { return isMSAsmLabel() && MSAsmNameResolved; }\n  void setMSAsmLabel(StringRef Name);\n  StringRef getMSAsmLabel() const { return MSAsmName; }\n  void setMSAsmLabelResolved() { MSAsmNameResolved = true; }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Label; }\n};\n\n/// Represent a C++ namespace.\nclass NamespaceDecl : public NamedDecl, public DeclContext,\n                      public Redeclarable<NamespaceDecl>\n{\n  /// The starting location of the source range, pointing\n  /// to either the namespace or the inline keyword.\n  SourceLocation LocStart;\n\n  /// The ending location of the source range.\n  SourceLocation RBraceLoc;\n\n  /// A pointer to either the anonymous namespace that lives just inside\n  /// this namespace or to the first namespace in the chain (the latter case\n  /// only when this is not the first in the chain), along with a\n  /// boolean value indicating whether this is an inline namespace.\n  llvm::PointerIntPair<NamespaceDecl *, 1, bool> AnonOrFirstNamespaceAndInline;\n\n  NamespaceDecl(ASTContext &C, DeclContext *DC, bool Inline,\n                SourceLocation StartLoc, SourceLocation IdLoc,\n                IdentifierInfo *Id, NamespaceDecl *PrevDecl);\n\n  using redeclarable_base = Redeclarable<NamespaceDecl>;\n\n  NamespaceDecl *getNextRedeclarationImpl() override;\n  NamespaceDecl *getPreviousDeclImpl() override;\n  NamespaceDecl *getMostRecentDeclImpl() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static NamespaceDecl *Create(ASTContext &C, DeclContext *DC,\n                               bool Inline, SourceLocation StartLoc,\n                               SourceLocation IdLoc, IdentifierInfo *Id,\n                               NamespaceDecl *PrevDecl);\n\n  static NamespaceDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  /// Returns true if this is an anonymous namespace declaration.\n  ///\n  /// For example:\n  /// \\code\n  ///   namespace {\n  ///     ...\n  ///   };\n  /// \\endcode\n  /// q.v. C++ [namespace.unnamed]\n  bool isAnonymousNamespace() const {\n    return !getIdentifier();\n  }\n\n  /// Returns true if this is an inline namespace declaration.\n  bool isInline() const {\n    return AnonOrFirstNamespaceAndInline.getInt();\n  }\n\n  /// Set whether this is an inline namespace declaration.\n  void setInline(bool Inline) {\n    AnonOrFirstNamespaceAndInline.setInt(Inline);\n  }\n\n  /// Get the original (first) namespace declaration.\n  NamespaceDecl *getOriginalNamespace();\n\n  /// Get the original (first) namespace declaration.\n  const NamespaceDecl *getOriginalNamespace() const;\n\n  /// Return true if this declaration is an original (first) declaration\n  /// of the namespace. This is false for non-original (subsequent) namespace\n  /// declarations and anonymous namespaces.\n  bool isOriginalNamespace() const;\n\n  /// Retrieve the anonymous namespace nested inside this namespace,\n  /// if any.\n  NamespaceDecl *getAnonymousNamespace() const {\n    return getOriginalNamespace()->AnonOrFirstNamespaceAndInline.getPointer();\n  }\n\n  void setAnonymousNamespace(NamespaceDecl *D) {\n    getOriginalNamespace()->AnonOrFirstNamespaceAndInline.setPointer(D);\n  }\n\n  /// Retrieves the canonical declaration of this namespace.\n  NamespaceDecl *getCanonicalDecl() override {\n    return getOriginalNamespace();\n  }\n  const NamespaceDecl *getCanonicalDecl() const {\n    return getOriginalNamespace();\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(LocStart, RBraceLoc);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return LocStart; }\n  SourceLocation getRBraceLoc() const { return RBraceLoc; }\n  void setLocStart(SourceLocation L) { LocStart = L; }\n  void setRBraceLoc(SourceLocation L) { RBraceLoc = L; }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Namespace; }\n  static DeclContext *castToDeclContext(const NamespaceDecl *D) {\n    return static_cast<DeclContext *>(const_cast<NamespaceDecl*>(D));\n  }\n  static NamespaceDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<NamespaceDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Represent the declaration of a variable (in which case it is\n/// an lvalue) a function (in which case it is a function designator) or\n/// an enum constant.\nclass ValueDecl : public NamedDecl {\n  QualType DeclType;\n\n  void anchor() override;\n\nprotected:\n  ValueDecl(Kind DK, DeclContext *DC, SourceLocation L,\n            DeclarationName N, QualType T)\n    : NamedDecl(DK, DC, L, N), DeclType(T) {}\n\npublic:\n  QualType getType() const { return DeclType; }\n  void setType(QualType newType) { DeclType = newType; }\n\n  /// Determine whether this symbol is weakly-imported,\n  ///        or declared with the weak or weak-ref attr.\n  bool isWeak() const;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K >= firstValue && K <= lastValue; }\n};\n\n/// A struct with extended info about a syntactic\n/// name qualifier, to be used for the case of out-of-line declarations.\nstruct QualifierInfo {\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// The number of \"outer\" template parameter lists.\n  /// The count includes all of the template parameter lists that were matched\n  /// against the template-ids occurring into the NNS and possibly (in the\n  /// case of an explicit specialization) a final \"template <>\".\n  unsigned NumTemplParamLists = 0;\n\n  /// A new-allocated array of size NumTemplParamLists,\n  /// containing pointers to the \"outer\" template parameter lists.\n  /// It includes all of the template parameter lists that were matched\n  /// against the template-ids occurring into the NNS and possibly (in the\n  /// case of an explicit specialization) a final \"template <>\".\n  TemplateParameterList** TemplParamLists = nullptr;\n\n  QualifierInfo() = default;\n  QualifierInfo(const QualifierInfo &) = delete;\n  QualifierInfo& operator=(const QualifierInfo &) = delete;\n\n  /// Sets info about \"outer\" template parameter lists.\n  void setTemplateParameterListsInfo(ASTContext &Context,\n                                     ArrayRef<TemplateParameterList *> TPLists);\n};\n\n/// Represents a ValueDecl that came out of a declarator.\n/// Contains type source information through TypeSourceInfo.\nclass DeclaratorDecl : public ValueDecl {\n  // A struct representing a TInfo, a trailing requires-clause and a syntactic\n  // qualifier, to be used for the (uncommon) case of out-of-line declarations\n  // and constrained function decls.\n  struct ExtInfo : public QualifierInfo {\n    TypeSourceInfo *TInfo;\n    Expr *TrailingRequiresClause = nullptr;\n  };\n\n  llvm::PointerUnion<TypeSourceInfo *, ExtInfo *> DeclInfo;\n\n  /// The start of the source range for this declaration,\n  /// ignoring outer template declarations.\n  SourceLocation InnerLocStart;\n\n  bool hasExtInfo() const { return DeclInfo.is<ExtInfo*>(); }\n  ExtInfo *getExtInfo() { return DeclInfo.get<ExtInfo*>(); }\n  const ExtInfo *getExtInfo() const { return DeclInfo.get<ExtInfo*>(); }\n\nprotected:\n  DeclaratorDecl(Kind DK, DeclContext *DC, SourceLocation L,\n                 DeclarationName N, QualType T, TypeSourceInfo *TInfo,\n                 SourceLocation StartL)\n      : ValueDecl(DK, DC, L, N, T), DeclInfo(TInfo), InnerLocStart(StartL) {}\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return hasExtInfo()\n      ? getExtInfo()->TInfo\n      : DeclInfo.get<TypeSourceInfo*>();\n  }\n\n  void setTypeSourceInfo(TypeSourceInfo *TI) {\n    if (hasExtInfo())\n      getExtInfo()->TInfo = TI;\n    else\n      DeclInfo = TI;\n  }\n\n  /// Return start of source range ignoring outer template declarations.\n  SourceLocation getInnerLocStart() const { return InnerLocStart; }\n  void setInnerLocStart(SourceLocation L) { InnerLocStart = L; }\n\n  /// Return start of source range taking into account any outer template\n  /// declarations.\n  SourceLocation getOuterLocStart() const;\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getOuterLocStart();\n  }\n\n  /// Retrieve the nested-name-specifier that qualifies the name of this\n  /// declaration, if it was present in the source.\n  NestedNameSpecifier *getQualifier() const {\n    return hasExtInfo() ? getExtInfo()->QualifierLoc.getNestedNameSpecifier()\n                        : nullptr;\n  }\n\n  /// Retrieve the nested-name-specifier (with source-location\n  /// information) that qualifies the name of this declaration, if it was\n  /// present in the source.\n  NestedNameSpecifierLoc getQualifierLoc() const {\n    return hasExtInfo() ? getExtInfo()->QualifierLoc\n                        : NestedNameSpecifierLoc();\n  }\n\n  void setQualifierInfo(NestedNameSpecifierLoc QualifierLoc);\n\n  /// \\brief Get the constraint-expression introduced by the trailing\n  /// requires-clause in the function/member declaration, or null if no\n  /// requires-clause was provided.\n  Expr *getTrailingRequiresClause() {\n    return hasExtInfo() ? getExtInfo()->TrailingRequiresClause\n                        : nullptr;\n  }\n\n  const Expr *getTrailingRequiresClause() const {\n    return hasExtInfo() ? getExtInfo()->TrailingRequiresClause\n                        : nullptr;\n  }\n\n  void setTrailingRequiresClause(Expr *TrailingRequiresClause);\n\n  unsigned getNumTemplateParameterLists() const {\n    return hasExtInfo() ? getExtInfo()->NumTemplParamLists : 0;\n  }\n\n  TemplateParameterList *getTemplateParameterList(unsigned index) const {\n    assert(index < getNumTemplateParameterLists());\n    return getExtInfo()->TemplParamLists[index];\n  }\n\n  void setTemplateParameterListsInfo(ASTContext &Context,\n                                     ArrayRef<TemplateParameterList *> TPLists);\n\n  SourceLocation getTypeSpecStartLoc() const;\n  SourceLocation getTypeSpecEndLoc() const;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K >= firstDeclarator && K <= lastDeclarator;\n  }\n};\n\n/// Structure used to store a statement, the constant value to\n/// which it was evaluated (if any), and whether or not the statement\n/// is an integral constant expression (if known).\nstruct EvaluatedStmt {\n  /// Whether this statement was already evaluated.\n  bool WasEvaluated : 1;\n\n  /// Whether this statement is being evaluated.\n  bool IsEvaluating : 1;\n\n  /// Whether this variable is known to have constant initialization. This is\n  /// currently only computed in C++, for static / thread storage duration\n  /// variables that might have constant initialization and for variables that\n  /// are usable in constant expressions.\n  bool HasConstantInitialization : 1;\n\n  /// Whether this variable is known to have constant destruction. That is,\n  /// whether running the destructor on the initial value is a side-effect\n  /// (and doesn't inspect any state that might have changed during program\n  /// execution). This is currently only computed if the destructor is\n  /// non-trivial.\n  bool HasConstantDestruction : 1;\n\n  /// In C++98, whether the initializer is an ICE. This affects whether the\n  /// variable is usable in constant expressions.\n  bool HasICEInit : 1;\n  bool CheckedForICEInit : 1;\n\n  Stmt *Value;\n  APValue Evaluated;\n\n  EvaluatedStmt()\n      : WasEvaluated(false), IsEvaluating(false),\n        HasConstantInitialization(false), HasConstantDestruction(false),\n        HasICEInit(false), CheckedForICEInit(false) {}\n};\n\n/// Represents a variable declaration or definition.\nclass VarDecl : public DeclaratorDecl, public Redeclarable<VarDecl> {\npublic:\n  /// Initialization styles.\n  enum InitializationStyle {\n    /// C-style initialization with assignment\n    CInit,\n\n    /// Call-style initialization (C++98)\n    CallInit,\n\n    /// Direct list-initialization (C++11)\n    ListInit\n  };\n\n  /// Kinds of thread-local storage.\n  enum TLSKind {\n    /// Not a TLS variable.\n    TLS_None,\n\n    /// TLS with a known-constant initializer.\n    TLS_Static,\n\n    /// TLS with a dynamic initializer.\n    TLS_Dynamic\n  };\n\n  /// Return the string used to specify the storage class \\p SC.\n  ///\n  /// It is illegal to call this function with SC == None.\n  static const char *getStorageClassSpecifierString(StorageClass SC);\n\nprotected:\n  // A pointer union of Stmt * and EvaluatedStmt *. When an EvaluatedStmt, we\n  // have allocated the auxiliary struct of information there.\n  //\n  // TODO: It is a bit unfortunate to use a PointerUnion inside the VarDecl for\n  // this as *many* VarDecls are ParmVarDecls that don't have default\n  // arguments. We could save some space by moving this pointer union to be\n  // allocated in trailing space when necessary.\n  using InitType = llvm::PointerUnion<Stmt *, EvaluatedStmt *>;\n\n  /// The initializer for this variable or, for a ParmVarDecl, the\n  /// C++ default argument.\n  mutable InitType Init;\n\nprivate:\n  friend class ASTDeclReader;\n  friend class ASTNodeImporter;\n  friend class StmtIteratorBase;\n\n  class VarDeclBitfields {\n    friend class ASTDeclReader;\n    friend class VarDecl;\n\n    unsigned SClass : 3;\n    unsigned TSCSpec : 2;\n    unsigned InitStyle : 2;\n\n    /// Whether this variable is an ARC pseudo-__strong variable; see\n    /// isARCPseudoStrong() for details.\n    unsigned ARCPseudoStrong : 1;\n  };\n  enum { NumVarDeclBits = 8 };\n\nprotected:\n  enum { NumParameterIndexBits = 8 };\n\n  enum DefaultArgKind {\n    DAK_None,\n    DAK_Unparsed,\n    DAK_Uninstantiated,\n    DAK_Normal\n  };\n\n  enum { NumScopeDepthOrObjCQualsBits = 7 };\n\n  class ParmVarDeclBitfields {\n    friend class ASTDeclReader;\n    friend class ParmVarDecl;\n\n    unsigned : NumVarDeclBits;\n\n    /// Whether this parameter inherits a default argument from a\n    /// prior declaration.\n    unsigned HasInheritedDefaultArg : 1;\n\n    /// Describes the kind of default argument for this parameter. By default\n    /// this is none. If this is normal, then the default argument is stored in\n    /// the \\c VarDecl initializer expression unless we were unable to parse\n    /// (even an invalid) expression for the default argument.\n    unsigned DefaultArgKind : 2;\n\n    /// Whether this parameter undergoes K&R argument promotion.\n    unsigned IsKNRPromoted : 1;\n\n    /// Whether this parameter is an ObjC method parameter or not.\n    unsigned IsObjCMethodParam : 1;\n\n    /// If IsObjCMethodParam, a Decl::ObjCDeclQualifier.\n    /// Otherwise, the number of function parameter scopes enclosing\n    /// the function parameter scope in which this parameter was\n    /// declared.\n    unsigned ScopeDepthOrObjCQuals : NumScopeDepthOrObjCQualsBits;\n\n    /// The number of parameters preceding this parameter in the\n    /// function parameter scope in which it was declared.\n    unsigned ParameterIndex : NumParameterIndexBits;\n  };\n\n  class NonParmVarDeclBitfields {\n    friend class ASTDeclReader;\n    friend class ImplicitParamDecl;\n    friend class VarDecl;\n\n    unsigned : NumVarDeclBits;\n\n    // FIXME: We need something similar to CXXRecordDecl::DefinitionData.\n    /// Whether this variable is a definition which was demoted due to\n    /// module merge.\n    unsigned IsThisDeclarationADemotedDefinition : 1;\n\n    /// Whether this variable is the exception variable in a C++ catch\n    /// or an Objective-C @catch statement.\n    unsigned ExceptionVar : 1;\n\n    /// Whether this local variable could be allocated in the return\n    /// slot of its function, enabling the named return value optimization\n    /// (NRVO).\n    unsigned NRVOVariable : 1;\n\n    /// Whether this variable is the for-range-declaration in a C++0x\n    /// for-range statement.\n    unsigned CXXForRangeDecl : 1;\n\n    /// Whether this variable is the for-in loop declaration in Objective-C.\n    unsigned ObjCForDecl : 1;\n\n    /// Whether this variable is (C++1z) inline.\n    unsigned IsInline : 1;\n\n    /// Whether this variable has (C++1z) inline explicitly specified.\n    unsigned IsInlineSpecified : 1;\n\n    /// Whether this variable is (C++0x) constexpr.\n    unsigned IsConstexpr : 1;\n\n    /// Whether this variable is the implicit variable for a lambda\n    /// init-capture.\n    unsigned IsInitCapture : 1;\n\n    /// Whether this local extern variable's previous declaration was\n    /// declared in the same block scope. This controls whether we should merge\n    /// the type of this declaration with its previous declaration.\n    unsigned PreviousDeclInSameBlockScope : 1;\n\n    /// Defines kind of the ImplicitParamDecl: 'this', 'self', 'vtt', '_cmd' or\n    /// something else.\n    unsigned ImplicitParamKind : 3;\n\n    unsigned EscapingByref : 1;\n  };\n\n  union {\n    unsigned AllBits;\n    VarDeclBitfields VarDeclBits;\n    ParmVarDeclBitfields ParmVarDeclBits;\n    NonParmVarDeclBitfields NonParmVarDeclBits;\n  };\n\n  VarDecl(Kind DK, ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n          SourceLocation IdLoc, IdentifierInfo *Id, QualType T,\n          TypeSourceInfo *TInfo, StorageClass SC);\n\n  using redeclarable_base = Redeclarable<VarDecl>;\n\n  VarDecl *getNextRedeclarationImpl() override {\n    return getNextRedeclaration();\n  }\n\n  VarDecl *getPreviousDeclImpl() override {\n    return getPreviousDecl();\n  }\n\n  VarDecl *getMostRecentDeclImpl() override {\n    return getMostRecentDecl();\n  }\n\npublic:\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  static VarDecl *Create(ASTContext &C, DeclContext *DC,\n                         SourceLocation StartLoc, SourceLocation IdLoc,\n                         IdentifierInfo *Id, QualType T, TypeSourceInfo *TInfo,\n                         StorageClass S);\n\n  static VarDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  /// Returns the storage class as written in the source. For the\n  /// computed linkage of symbol, see getLinkage.\n  StorageClass getStorageClass() const {\n    return (StorageClass) VarDeclBits.SClass;\n  }\n  void setStorageClass(StorageClass SC);\n\n  void setTSCSpec(ThreadStorageClassSpecifier TSC) {\n    VarDeclBits.TSCSpec = TSC;\n    assert(VarDeclBits.TSCSpec == TSC && \"truncation\");\n  }\n  ThreadStorageClassSpecifier getTSCSpec() const {\n    return static_cast<ThreadStorageClassSpecifier>(VarDeclBits.TSCSpec);\n  }\n  TLSKind getTLSKind() const;\n\n  /// Returns true if a variable with function scope is a non-static local\n  /// variable.\n  bool hasLocalStorage() const {\n    if (getStorageClass() == SC_None) {\n      // OpenCL v1.2 s6.5.3: The __constant or constant address space name is\n      // used to describe variables allocated in global memory and which are\n      // accessed inside a kernel(s) as read-only variables. As such, variables\n      // in constant address space cannot have local storage.\n      if (getType().getAddressSpace() == LangAS::opencl_constant)\n        return false;\n      // Second check is for C++11 [dcl.stc]p4.\n      return !isFileVarDecl() && getTSCSpec() == TSCS_unspecified;\n    }\n\n    // Global Named Register (GNU extension)\n    if (getStorageClass() == SC_Register && !isLocalVarDeclOrParm())\n      return false;\n\n    // Return true for:  Auto, Register.\n    // Return false for: Extern, Static, PrivateExtern, OpenCLWorkGroupLocal.\n\n    return getStorageClass() >= SC_Auto;\n  }\n\n  /// Returns true if a variable with function scope is a static local\n  /// variable.\n  bool isStaticLocal() const {\n    return (getStorageClass() == SC_Static ||\n            // C++11 [dcl.stc]p4\n            (getStorageClass() == SC_None && getTSCSpec() == TSCS_thread_local))\n      && !isFileVarDecl();\n  }\n\n  /// Returns true if a variable has extern or __private_extern__\n  /// storage.\n  bool hasExternalStorage() const {\n    return getStorageClass() == SC_Extern ||\n           getStorageClass() == SC_PrivateExtern;\n  }\n\n  /// Returns true for all variables that do not have local storage.\n  ///\n  /// This includes all global variables as well as static variables declared\n  /// within a function.\n  bool hasGlobalStorage() const { return !hasLocalStorage(); }\n\n  /// Get the storage duration of this variable, per C++ [basic.stc].\n  StorageDuration getStorageDuration() const {\n    return hasLocalStorage() ? SD_Automatic :\n           getTSCSpec() ? SD_Thread : SD_Static;\n  }\n\n  /// Compute the language linkage.\n  LanguageLinkage getLanguageLinkage() const;\n\n  /// Determines whether this variable is a variable with external, C linkage.\n  bool isExternC() const;\n\n  /// Determines whether this variable's context is, or is nested within,\n  /// a C++ extern \"C\" linkage spec.\n  bool isInExternCContext() const;\n\n  /// Determines whether this variable's context is, or is nested within,\n  /// a C++ extern \"C++\" linkage spec.\n  bool isInExternCXXContext() const;\n\n  /// Returns true for local variable declarations other than parameters.\n  /// Note that this includes static variables inside of functions. It also\n  /// includes variables inside blocks.\n  ///\n  ///   void foo() { int x; static int y; extern int z; }\n  bool isLocalVarDecl() const {\n    if (getKind() != Decl::Var && getKind() != Decl::Decomposition)\n      return false;\n    if (const DeclContext *DC = getLexicalDeclContext())\n      return DC->getRedeclContext()->isFunctionOrMethod();\n    return false;\n  }\n\n  /// Similar to isLocalVarDecl but also includes parameters.\n  bool isLocalVarDeclOrParm() const {\n    return isLocalVarDecl() || getKind() == Decl::ParmVar;\n  }\n\n  /// Similar to isLocalVarDecl, but excludes variables declared in blocks.\n  bool isFunctionOrMethodVarDecl() const {\n    if (getKind() != Decl::Var && getKind() != Decl::Decomposition)\n      return false;\n    const DeclContext *DC = getLexicalDeclContext()->getRedeclContext();\n    return DC->isFunctionOrMethod() && DC->getDeclKind() != Decl::Block;\n  }\n\n  /// Determines whether this is a static data member.\n  ///\n  /// This will only be true in C++, and applies to, e.g., the\n  /// variable 'x' in:\n  /// \\code\n  /// struct S {\n  ///   static int x;\n  /// };\n  /// \\endcode\n  bool isStaticDataMember() const {\n    // If it wasn't static, it would be a FieldDecl.\n    return getKind() != Decl::ParmVar && getDeclContext()->isRecord();\n  }\n\n  VarDecl *getCanonicalDecl() override;\n  const VarDecl *getCanonicalDecl() const {\n    return const_cast<VarDecl*>(this)->getCanonicalDecl();\n  }\n\n  enum DefinitionKind {\n    /// This declaration is only a declaration.\n    DeclarationOnly,\n\n    /// This declaration is a tentative definition.\n    TentativeDefinition,\n\n    /// This declaration is definitely a definition.\n    Definition\n  };\n\n  /// Check whether this declaration is a definition. If this could be\n  /// a tentative definition (in C), don't check whether there's an overriding\n  /// definition.\n  DefinitionKind isThisDeclarationADefinition(ASTContext &) const;\n  DefinitionKind isThisDeclarationADefinition() const {\n    return isThisDeclarationADefinition(getASTContext());\n  }\n\n  /// Check whether this variable is defined in this translation unit.\n  DefinitionKind hasDefinition(ASTContext &) const;\n  DefinitionKind hasDefinition() const {\n    return hasDefinition(getASTContext());\n  }\n\n  /// Get the tentative definition that acts as the real definition in a TU.\n  /// Returns null if there is a proper definition available.\n  VarDecl *getActingDefinition();\n  const VarDecl *getActingDefinition() const {\n    return const_cast<VarDecl*>(this)->getActingDefinition();\n  }\n\n  /// Get the real (not just tentative) definition for this declaration.\n  VarDecl *getDefinition(ASTContext &);\n  const VarDecl *getDefinition(ASTContext &C) const {\n    return const_cast<VarDecl*>(this)->getDefinition(C);\n  }\n  VarDecl *getDefinition() {\n    return getDefinition(getASTContext());\n  }\n  const VarDecl *getDefinition() const {\n    return const_cast<VarDecl*>(this)->getDefinition();\n  }\n\n  /// Determine whether this is or was instantiated from an out-of-line\n  /// definition of a static data member.\n  bool isOutOfLine() const override;\n\n  /// Returns true for file scoped variable declaration.\n  bool isFileVarDecl() const {\n    Kind K = getKind();\n    if (K == ParmVar || K == ImplicitParam)\n      return false;\n\n    if (getLexicalDeclContext()->getRedeclContext()->isFileContext())\n      return true;\n\n    if (isStaticDataMember())\n      return true;\n\n    return false;\n  }\n\n  /// Get the initializer for this variable, no matter which\n  /// declaration it is attached to.\n  const Expr *getAnyInitializer() const {\n    const VarDecl *D;\n    return getAnyInitializer(D);\n  }\n\n  /// Get the initializer for this variable, no matter which\n  /// declaration it is attached to. Also get that declaration.\n  const Expr *getAnyInitializer(const VarDecl *&D) const;\n\n  bool hasInit() const;\n  const Expr *getInit() const {\n    return const_cast<VarDecl *>(this)->getInit();\n  }\n  Expr *getInit();\n\n  /// Retrieve the address of the initializer expression.\n  Stmt **getInitAddress();\n\n  void setInit(Expr *I);\n\n  /// Get the initializing declaration of this variable, if any. This is\n  /// usually the definition, except that for a static data member it can be\n  /// the in-class declaration.\n  VarDecl *getInitializingDeclaration();\n  const VarDecl *getInitializingDeclaration() const {\n    return const_cast<VarDecl *>(this)->getInitializingDeclaration();\n  }\n\n  /// Determine whether this variable's value might be usable in a\n  /// constant expression, according to the relevant language standard.\n  /// This only checks properties of the declaration, and does not check\n  /// whether the initializer is in fact a constant expression.\n  ///\n  /// This corresponds to C++20 [expr.const]p3's notion of a\n  /// \"potentially-constant\" variable.\n  bool mightBeUsableInConstantExpressions(const ASTContext &C) const;\n\n  /// Determine whether this variable's value can be used in a\n  /// constant expression, according to the relevant language standard,\n  /// including checking whether it was initialized by a constant expression.\n  bool isUsableInConstantExpressions(const ASTContext &C) const;\n\n  EvaluatedStmt *ensureEvaluatedStmt() const;\n  EvaluatedStmt *getEvaluatedStmt() const;\n\n  /// Attempt to evaluate the value of the initializer attached to this\n  /// declaration, and produce notes explaining why it cannot be evaluated.\n  /// Returns a pointer to the value if evaluation succeeded, 0 otherwise.\n  APValue *evaluateValue() const;\n\nprivate:\n  APValue *evaluateValueImpl(SmallVectorImpl<PartialDiagnosticAt> &Notes,\n                             bool IsConstantInitialization) const;\n\npublic:\n  /// Return the already-evaluated value of this variable's\n  /// initializer, or NULL if the value is not yet known. Returns pointer\n  /// to untyped APValue if the value could not be evaluated.\n  APValue *getEvaluatedValue() const;\n\n  /// Evaluate the destruction of this variable to determine if it constitutes\n  /// constant destruction.\n  ///\n  /// \\pre hasConstantInitialization()\n  /// \\return \\c true if this variable has constant destruction, \\c false if\n  ///         not.\n  bool evaluateDestruction(SmallVectorImpl<PartialDiagnosticAt> &Notes) const;\n\n  /// Determine whether this variable has constant initialization.\n  ///\n  /// This is only set in two cases: when the language semantics require\n  /// constant initialization (globals in C and some globals in C++), and when\n  /// the variable is usable in constant expressions (constexpr, const int, and\n  /// reference variables in C++).\n  bool hasConstantInitialization() const;\n\n  /// Determine whether the initializer of this variable is an integer constant\n  /// expression. For use in C++98, where this affects whether the variable is\n  /// usable in constant expressions.\n  bool hasICEInitializer(const ASTContext &Context) const;\n\n  /// Evaluate the initializer of this variable to determine whether it's a\n  /// constant initializer. Should only be called once, after completing the\n  /// definition of the variable.\n  bool checkForConstantInitialization(\n      SmallVectorImpl<PartialDiagnosticAt> &Notes) const;\n\n  void setInitStyle(InitializationStyle Style) {\n    VarDeclBits.InitStyle = Style;\n  }\n\n  /// The style of initialization for this declaration.\n  ///\n  /// C-style initialization is \"int x = 1;\". Call-style initialization is\n  /// a C++98 direct-initializer, e.g. \"int x(1);\". The Init expression will be\n  /// the expression inside the parens or a \"ClassType(a,b,c)\" class constructor\n  /// expression for class types. List-style initialization is C++11 syntax,\n  /// e.g. \"int x{1};\". Clients can distinguish between different forms of\n  /// initialization by checking this value. In particular, \"int x = {1};\" is\n  /// C-style, \"int x({1})\" is call-style, and \"int x{1};\" is list-style; the\n  /// Init expression in all three cases is an InitListExpr.\n  InitializationStyle getInitStyle() const {\n    return static_cast<InitializationStyle>(VarDeclBits.InitStyle);\n  }\n\n  /// Whether the initializer is a direct-initializer (list or call).\n  bool isDirectInit() const {\n    return getInitStyle() != CInit;\n  }\n\n  /// If this definition should pretend to be a declaration.\n  bool isThisDeclarationADemotedDefinition() const {\n    return isa<ParmVarDecl>(this) ? false :\n      NonParmVarDeclBits.IsThisDeclarationADemotedDefinition;\n  }\n\n  /// This is a definition which should be demoted to a declaration.\n  ///\n  /// In some cases (mostly module merging) we can end up with two visible\n  /// definitions one of which needs to be demoted to a declaration to keep\n  /// the AST invariants.\n  void demoteThisDefinitionToDeclaration() {\n    assert(isThisDeclarationADefinition() && \"Not a definition!\");\n    assert(!isa<ParmVarDecl>(this) && \"Cannot demote ParmVarDecls!\");\n    NonParmVarDeclBits.IsThisDeclarationADemotedDefinition = 1;\n  }\n\n  /// Determine whether this variable is the exception variable in a\n  /// C++ catch statememt or an Objective-C \\@catch statement.\n  bool isExceptionVariable() const {\n    return isa<ParmVarDecl>(this) ? false : NonParmVarDeclBits.ExceptionVar;\n  }\n  void setExceptionVariable(bool EV) {\n    assert(!isa<ParmVarDecl>(this));\n    NonParmVarDeclBits.ExceptionVar = EV;\n  }\n\n  /// Determine whether this local variable can be used with the named\n  /// return value optimization (NRVO).\n  ///\n  /// The named return value optimization (NRVO) works by marking certain\n  /// non-volatile local variables of class type as NRVO objects. These\n  /// locals can be allocated within the return slot of their containing\n  /// function, in which case there is no need to copy the object to the\n  /// return slot when returning from the function. Within the function body,\n  /// each return that returns the NRVO object will have this variable as its\n  /// NRVO candidate.\n  bool isNRVOVariable() const {\n    return isa<ParmVarDecl>(this) ? false : NonParmVarDeclBits.NRVOVariable;\n  }\n  void setNRVOVariable(bool NRVO) {\n    assert(!isa<ParmVarDecl>(this));\n    NonParmVarDeclBits.NRVOVariable = NRVO;\n  }\n\n  /// Determine whether this variable is the for-range-declaration in\n  /// a C++0x for-range statement.\n  bool isCXXForRangeDecl() const {\n    return isa<ParmVarDecl>(this) ? false : NonParmVarDeclBits.CXXForRangeDecl;\n  }\n  void setCXXForRangeDecl(bool FRD) {\n    assert(!isa<ParmVarDecl>(this));\n    NonParmVarDeclBits.CXXForRangeDecl = FRD;\n  }\n\n  /// Determine whether this variable is a for-loop declaration for a\n  /// for-in statement in Objective-C.\n  bool isObjCForDecl() const {\n    return NonParmVarDeclBits.ObjCForDecl;\n  }\n\n  void setObjCForDecl(bool FRD) {\n    NonParmVarDeclBits.ObjCForDecl = FRD;\n  }\n\n  /// Determine whether this variable is an ARC pseudo-__strong variable. A\n  /// pseudo-__strong variable has a __strong-qualified type but does not\n  /// actually retain the object written into it. Generally such variables are\n  /// also 'const' for safety. There are 3 cases where this will be set, 1) if\n  /// the variable is annotated with the objc_externally_retained attribute, 2)\n  /// if its 'self' in a non-init method, or 3) if its the variable in an for-in\n  /// loop.\n  bool isARCPseudoStrong() const { return VarDeclBits.ARCPseudoStrong; }\n  void setARCPseudoStrong(bool PS) { VarDeclBits.ARCPseudoStrong = PS; }\n\n  /// Whether this variable is (C++1z) inline.\n  bool isInline() const {\n    return isa<ParmVarDecl>(this) ? false : NonParmVarDeclBits.IsInline;\n  }\n  bool isInlineSpecified() const {\n    return isa<ParmVarDecl>(this) ? false\n                                  : NonParmVarDeclBits.IsInlineSpecified;\n  }\n  void setInlineSpecified() {\n    assert(!isa<ParmVarDecl>(this));\n    NonParmVarDeclBits.IsInline = true;\n    NonParmVarDeclBits.IsInlineSpecified = true;\n  }\n  void setImplicitlyInline() {\n    assert(!isa<ParmVarDecl>(this));\n    NonParmVarDeclBits.IsInline = true;\n  }\n\n  /// Whether this variable is (C++11) constexpr.\n  bool isConstexpr() const {\n    return isa<ParmVarDecl>(this) ? false : NonParmVarDeclBits.IsConstexpr;\n  }\n  void setConstexpr(bool IC) {\n    assert(!isa<ParmVarDecl>(this));\n    NonParmVarDeclBits.IsConstexpr = IC;\n  }\n\n  /// Whether this variable is the implicit variable for a lambda init-capture.\n  bool isInitCapture() const {\n    return isa<ParmVarDecl>(this) ? false : NonParmVarDeclBits.IsInitCapture;\n  }\n  void setInitCapture(bool IC) {\n    assert(!isa<ParmVarDecl>(this));\n    NonParmVarDeclBits.IsInitCapture = IC;\n  }\n\n  /// Determine whether this variable is actually a function parameter pack or\n  /// init-capture pack.\n  bool isParameterPack() const;\n\n  /// Whether this local extern variable declaration's previous declaration\n  /// was declared in the same block scope. Only correct in C++.\n  bool isPreviousDeclInSameBlockScope() const {\n    return isa<ParmVarDecl>(this)\n               ? false\n               : NonParmVarDeclBits.PreviousDeclInSameBlockScope;\n  }\n  void setPreviousDeclInSameBlockScope(bool Same) {\n    assert(!isa<ParmVarDecl>(this));\n    NonParmVarDeclBits.PreviousDeclInSameBlockScope = Same;\n  }\n\n  /// Indicates the capture is a __block variable that is captured by a block\n  /// that can potentially escape (a block for which BlockDecl::doesNotEscape\n  /// returns false).\n  bool isEscapingByref() const;\n\n  /// Indicates the capture is a __block variable that is never captured by an\n  /// escaping block.\n  bool isNonEscapingByref() const;\n\n  void setEscapingByref() {\n    NonParmVarDeclBits.EscapingByref = true;\n  }\n\n  /// Retrieve the variable declaration from which this variable could\n  /// be instantiated, if it is an instantiation (rather than a non-template).\n  VarDecl *getTemplateInstantiationPattern() const;\n\n  /// If this variable is an instantiated static data member of a\n  /// class template specialization, returns the templated static data member\n  /// from which it was instantiated.\n  VarDecl *getInstantiatedFromStaticDataMember() const;\n\n  /// If this variable is an instantiation of a variable template or a\n  /// static data member of a class template, determine what kind of\n  /// template specialization or instantiation this is.\n  TemplateSpecializationKind getTemplateSpecializationKind() const;\n\n  /// Get the template specialization kind of this variable for the purposes of\n  /// template instantiation. This differs from getTemplateSpecializationKind()\n  /// for an instantiation of a class-scope explicit specialization.\n  TemplateSpecializationKind\n  getTemplateSpecializationKindForInstantiation() const;\n\n  /// If this variable is an instantiation of a variable template or a\n  /// static data member of a class template, determine its point of\n  /// instantiation.\n  SourceLocation getPointOfInstantiation() const;\n\n  /// If this variable is an instantiation of a static data member of a\n  /// class template specialization, retrieves the member specialization\n  /// information.\n  MemberSpecializationInfo *getMemberSpecializationInfo() const;\n\n  /// For a static data member that was instantiated from a static\n  /// data member of a class template, set the template specialiation kind.\n  void setTemplateSpecializationKind(TemplateSpecializationKind TSK,\n                        SourceLocation PointOfInstantiation = SourceLocation());\n\n  /// Specify that this variable is an instantiation of the\n  /// static data member VD.\n  void setInstantiationOfStaticDataMember(VarDecl *VD,\n                                          TemplateSpecializationKind TSK);\n\n  /// Retrieves the variable template that is described by this\n  /// variable declaration.\n  ///\n  /// Every variable template is represented as a VarTemplateDecl and a\n  /// VarDecl. The former contains template properties (such as\n  /// the template parameter lists) while the latter contains the\n  /// actual description of the template's\n  /// contents. VarTemplateDecl::getTemplatedDecl() retrieves the\n  /// VarDecl that from a VarTemplateDecl, while\n  /// getDescribedVarTemplate() retrieves the VarTemplateDecl from\n  /// a VarDecl.\n  VarTemplateDecl *getDescribedVarTemplate() const;\n\n  void setDescribedVarTemplate(VarTemplateDecl *Template);\n\n  // Is this variable known to have a definition somewhere in the complete\n  // program? This may be true even if the declaration has internal linkage and\n  // has no definition within this source file.\n  bool isKnownToBeDefined() const;\n\n  /// Is destruction of this variable entirely suppressed? If so, the variable\n  /// need not have a usable destructor at all.\n  bool isNoDestroy(const ASTContext &) const;\n\n  /// Would the destruction of this variable have any effect, and if so, what\n  /// kind?\n  QualType::DestructionKind needsDestruction(const ASTContext &Ctx) const;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K >= firstVar && K <= lastVar; }\n};\n\nclass ImplicitParamDecl : public VarDecl {\n  void anchor() override;\n\npublic:\n  /// Defines the kind of the implicit parameter: is this an implicit parameter\n  /// with pointer to 'this', 'self', '_cmd', virtual table pointers, captured\n  /// context or something else.\n  enum ImplicitParamKind : unsigned {\n    /// Parameter for Objective-C 'self' argument\n    ObjCSelf,\n\n    /// Parameter for Objective-C '_cmd' argument\n    ObjCCmd,\n\n    /// Parameter for C++ 'this' argument\n    CXXThis,\n\n    /// Parameter for C++ virtual table pointers\n    CXXVTT,\n\n    /// Parameter for captured context\n    CapturedContext,\n\n    /// Other implicit parameter\n    Other,\n  };\n\n  /// Create implicit parameter.\n  static ImplicitParamDecl *Create(ASTContext &C, DeclContext *DC,\n                                   SourceLocation IdLoc, IdentifierInfo *Id,\n                                   QualType T, ImplicitParamKind ParamKind);\n  static ImplicitParamDecl *Create(ASTContext &C, QualType T,\n                                   ImplicitParamKind ParamKind);\n\n  static ImplicitParamDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  ImplicitParamDecl(ASTContext &C, DeclContext *DC, SourceLocation IdLoc,\n                    IdentifierInfo *Id, QualType Type,\n                    ImplicitParamKind ParamKind)\n      : VarDecl(ImplicitParam, C, DC, IdLoc, IdLoc, Id, Type,\n                /*TInfo=*/nullptr, SC_None) {\n    NonParmVarDeclBits.ImplicitParamKind = ParamKind;\n    setImplicit();\n  }\n\n  ImplicitParamDecl(ASTContext &C, QualType Type, ImplicitParamKind ParamKind)\n      : VarDecl(ImplicitParam, C, /*DC=*/nullptr, SourceLocation(),\n                SourceLocation(), /*Id=*/nullptr, Type,\n                /*TInfo=*/nullptr, SC_None) {\n    NonParmVarDeclBits.ImplicitParamKind = ParamKind;\n    setImplicit();\n  }\n\n  /// Returns the implicit parameter kind.\n  ImplicitParamKind getParameterKind() const {\n    return static_cast<ImplicitParamKind>(NonParmVarDeclBits.ImplicitParamKind);\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ImplicitParam; }\n};\n\n/// Represents a parameter to a function.\nclass ParmVarDecl : public VarDecl {\npublic:\n  enum { MaxFunctionScopeDepth = 255 };\n  enum { MaxFunctionScopeIndex = 255 };\n\nprotected:\n  ParmVarDecl(Kind DK, ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n              SourceLocation IdLoc, IdentifierInfo *Id, QualType T,\n              TypeSourceInfo *TInfo, StorageClass S, Expr *DefArg)\n      : VarDecl(DK, C, DC, StartLoc, IdLoc, Id, T, TInfo, S) {\n    assert(ParmVarDeclBits.HasInheritedDefaultArg == false);\n    assert(ParmVarDeclBits.DefaultArgKind == DAK_None);\n    assert(ParmVarDeclBits.IsKNRPromoted == false);\n    assert(ParmVarDeclBits.IsObjCMethodParam == false);\n    setDefaultArg(DefArg);\n  }\n\npublic:\n  static ParmVarDecl *Create(ASTContext &C, DeclContext *DC,\n                             SourceLocation StartLoc,\n                             SourceLocation IdLoc, IdentifierInfo *Id,\n                             QualType T, TypeSourceInfo *TInfo,\n                             StorageClass S, Expr *DefArg);\n\n  static ParmVarDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  void setObjCMethodScopeInfo(unsigned parameterIndex) {\n    ParmVarDeclBits.IsObjCMethodParam = true;\n    setParameterIndex(parameterIndex);\n  }\n\n  void setScopeInfo(unsigned scopeDepth, unsigned parameterIndex) {\n    assert(!ParmVarDeclBits.IsObjCMethodParam);\n\n    ParmVarDeclBits.ScopeDepthOrObjCQuals = scopeDepth;\n    assert(ParmVarDeclBits.ScopeDepthOrObjCQuals == scopeDepth\n           && \"truncation!\");\n\n    setParameterIndex(parameterIndex);\n  }\n\n  bool isObjCMethodParameter() const {\n    return ParmVarDeclBits.IsObjCMethodParam;\n  }\n\n  /// Determines whether this parameter is destroyed in the callee function.\n  bool isDestroyedInCallee() const;\n\n  unsigned getFunctionScopeDepth() const {\n    if (ParmVarDeclBits.IsObjCMethodParam) return 0;\n    return ParmVarDeclBits.ScopeDepthOrObjCQuals;\n  }\n\n  static constexpr unsigned getMaxFunctionScopeDepth() {\n    return (1u << NumScopeDepthOrObjCQualsBits) - 1;\n  }\n\n  /// Returns the index of this parameter in its prototype or method scope.\n  unsigned getFunctionScopeIndex() const {\n    return getParameterIndex();\n  }\n\n  ObjCDeclQualifier getObjCDeclQualifier() const {\n    if (!ParmVarDeclBits.IsObjCMethodParam) return OBJC_TQ_None;\n    return ObjCDeclQualifier(ParmVarDeclBits.ScopeDepthOrObjCQuals);\n  }\n  void setObjCDeclQualifier(ObjCDeclQualifier QTVal) {\n    assert(ParmVarDeclBits.IsObjCMethodParam);\n    ParmVarDeclBits.ScopeDepthOrObjCQuals = QTVal;\n  }\n\n  /// True if the value passed to this parameter must undergo\n  /// K&R-style default argument promotion:\n  ///\n  /// C99 6.5.2.2.\n  ///   If the expression that denotes the called function has a type\n  ///   that does not include a prototype, the integer promotions are\n  ///   performed on each argument, and arguments that have type float\n  ///   are promoted to double.\n  bool isKNRPromoted() const {\n    return ParmVarDeclBits.IsKNRPromoted;\n  }\n  void setKNRPromoted(bool promoted) {\n    ParmVarDeclBits.IsKNRPromoted = promoted;\n  }\n\n  Expr *getDefaultArg();\n  const Expr *getDefaultArg() const {\n    return const_cast<ParmVarDecl *>(this)->getDefaultArg();\n  }\n\n  void setDefaultArg(Expr *defarg);\n\n  /// Retrieve the source range that covers the entire default\n  /// argument.\n  SourceRange getDefaultArgRange() const;\n  void setUninstantiatedDefaultArg(Expr *arg);\n  Expr *getUninstantiatedDefaultArg();\n  const Expr *getUninstantiatedDefaultArg() const {\n    return const_cast<ParmVarDecl *>(this)->getUninstantiatedDefaultArg();\n  }\n\n  /// Determines whether this parameter has a default argument,\n  /// either parsed or not.\n  bool hasDefaultArg() const;\n\n  /// Determines whether this parameter has a default argument that has not\n  /// yet been parsed. This will occur during the processing of a C++ class\n  /// whose member functions have default arguments, e.g.,\n  /// @code\n  ///   class X {\n  ///   public:\n  ///     void f(int x = 17); // x has an unparsed default argument now\n  ///   }; // x has a regular default argument now\n  /// @endcode\n  bool hasUnparsedDefaultArg() const {\n    return ParmVarDeclBits.DefaultArgKind == DAK_Unparsed;\n  }\n\n  bool hasUninstantiatedDefaultArg() const {\n    return ParmVarDeclBits.DefaultArgKind == DAK_Uninstantiated;\n  }\n\n  /// Specify that this parameter has an unparsed default argument.\n  /// The argument will be replaced with a real default argument via\n  /// setDefaultArg when the class definition enclosing the function\n  /// declaration that owns this default argument is completed.\n  void setUnparsedDefaultArg() {\n    ParmVarDeclBits.DefaultArgKind = DAK_Unparsed;\n  }\n\n  bool hasInheritedDefaultArg() const {\n    return ParmVarDeclBits.HasInheritedDefaultArg;\n  }\n\n  void setHasInheritedDefaultArg(bool I = true) {\n    ParmVarDeclBits.HasInheritedDefaultArg = I;\n  }\n\n  QualType getOriginalType() const;\n\n  /// Sets the function declaration that owns this\n  /// ParmVarDecl. Since ParmVarDecls are often created before the\n  /// FunctionDecls that own them, this routine is required to update\n  /// the DeclContext appropriately.\n  void setOwningFunction(DeclContext *FD) { setDeclContext(FD); }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ParmVar; }\n\nprivate:\n  enum { ParameterIndexSentinel = (1 << NumParameterIndexBits) - 1 };\n\n  void setParameterIndex(unsigned parameterIndex) {\n    if (parameterIndex >= ParameterIndexSentinel) {\n      setParameterIndexLarge(parameterIndex);\n      return;\n    }\n\n    ParmVarDeclBits.ParameterIndex = parameterIndex;\n    assert(ParmVarDeclBits.ParameterIndex == parameterIndex && \"truncation!\");\n  }\n  unsigned getParameterIndex() const {\n    unsigned d = ParmVarDeclBits.ParameterIndex;\n    return d == ParameterIndexSentinel ? getParameterIndexLarge() : d;\n  }\n\n  void setParameterIndexLarge(unsigned parameterIndex);\n  unsigned getParameterIndexLarge() const;\n};\n\nenum class MultiVersionKind {\n  None,\n  Target,\n  CPUSpecific,\n  CPUDispatch\n};\n\n/// Represents a function declaration or definition.\n///\n/// Since a given function can be declared several times in a program,\n/// there may be several FunctionDecls that correspond to that\n/// function. Only one of those FunctionDecls will be found when\n/// traversing the list of declarations in the context of the\n/// FunctionDecl (e.g., the translation unit); this FunctionDecl\n/// contains all of the information known about the function. Other,\n/// previous declarations of the function are available via the\n/// getPreviousDecl() chain.\nclass FunctionDecl : public DeclaratorDecl,\n                     public DeclContext,\n                     public Redeclarable<FunctionDecl> {\n  // This class stores some data in DeclContext::FunctionDeclBits\n  // to save some space. Use the provided accessors to access it.\npublic:\n  /// The kind of templated function a FunctionDecl can be.\n  enum TemplatedKind {\n    // Not templated.\n    TK_NonTemplate,\n    // The pattern in a function template declaration.\n    TK_FunctionTemplate,\n    // A non-template function that is an instantiation or explicit\n    // specialization of a member of a templated class.\n    TK_MemberSpecialization,\n    // An instantiation or explicit specialization of a function template.\n    // Note: this might have been instantiated from a templated class if it\n    // is a class-scope explicit specialization.\n    TK_FunctionTemplateSpecialization,\n    // A function template specialization that hasn't yet been resolved to a\n    // particular specialized function template.\n    TK_DependentFunctionTemplateSpecialization\n  };\n\n  /// Stashed information about a defaulted function definition whose body has\n  /// not yet been lazily generated.\n  class DefaultedFunctionInfo final\n      : llvm::TrailingObjects<DefaultedFunctionInfo, DeclAccessPair> {\n    friend TrailingObjects;\n    unsigned NumLookups;\n\n  public:\n    static DefaultedFunctionInfo *Create(ASTContext &Context,\n                                         ArrayRef<DeclAccessPair> Lookups);\n    /// Get the unqualified lookup results that should be used in this\n    /// defaulted function definition.\n    ArrayRef<DeclAccessPair> getUnqualifiedLookups() const {\n      return {getTrailingObjects<DeclAccessPair>(), NumLookups};\n    }\n  };\n\nprivate:\n  /// A new[]'d array of pointers to VarDecls for the formal\n  /// parameters of this function.  This is null if a prototype or if there are\n  /// no formals.\n  ParmVarDecl **ParamInfo = nullptr;\n\n  /// The active member of this union is determined by\n  /// FunctionDeclBits.HasDefaultedFunctionInfo.\n  union {\n    /// The body of the function.\n    LazyDeclStmtPtr Body;\n    /// Information about a future defaulted function definition.\n    DefaultedFunctionInfo *DefaultedInfo;\n  };\n\n  unsigned ODRHash;\n\n  /// End part of this FunctionDecl's source range.\n  ///\n  /// We could compute the full range in getSourceRange(). However, when we're\n  /// dealing with a function definition deserialized from a PCH/AST file,\n  /// we can only compute the full range once the function body has been\n  /// de-serialized, so it's far better to have the (sometimes-redundant)\n  /// EndRangeLoc.\n  SourceLocation EndRangeLoc;\n\n  /// The template or declaration that this declaration\n  /// describes or was instantiated from, respectively.\n  ///\n  /// For non-templates, this value will be NULL. For function\n  /// declarations that describe a function template, this will be a\n  /// pointer to a FunctionTemplateDecl. For member functions\n  /// of class template specializations, this will be a MemberSpecializationInfo\n  /// pointer containing information about the specialization.\n  /// For function template specializations, this will be a\n  /// FunctionTemplateSpecializationInfo, which contains information about\n  /// the template being specialized and the template arguments involved in\n  /// that specialization.\n  llvm::PointerUnion<FunctionTemplateDecl *,\n                     MemberSpecializationInfo *,\n                     FunctionTemplateSpecializationInfo *,\n                     DependentFunctionTemplateSpecializationInfo *>\n    TemplateOrSpecialization;\n\n  /// Provides source/type location info for the declaration name embedded in\n  /// the DeclaratorDecl base class.\n  DeclarationNameLoc DNLoc;\n\n  /// Specify that this function declaration is actually a function\n  /// template specialization.\n  ///\n  /// \\param C the ASTContext.\n  ///\n  /// \\param Template the function template that this function template\n  /// specialization specializes.\n  ///\n  /// \\param TemplateArgs the template arguments that produced this\n  /// function template specialization from the template.\n  ///\n  /// \\param InsertPos If non-NULL, the position in the function template\n  /// specialization set where the function template specialization data will\n  /// be inserted.\n  ///\n  /// \\param TSK the kind of template specialization this is.\n  ///\n  /// \\param TemplateArgsAsWritten location info of template arguments.\n  ///\n  /// \\param PointOfInstantiation point at which the function template\n  /// specialization was first instantiated.\n  void setFunctionTemplateSpecialization(ASTContext &C,\n                                         FunctionTemplateDecl *Template,\n                                       const TemplateArgumentList *TemplateArgs,\n                                         void *InsertPos,\n                                         TemplateSpecializationKind TSK,\n                          const TemplateArgumentListInfo *TemplateArgsAsWritten,\n                                         SourceLocation PointOfInstantiation);\n\n  /// Specify that this record is an instantiation of the\n  /// member function FD.\n  void setInstantiationOfMemberFunction(ASTContext &C, FunctionDecl *FD,\n                                        TemplateSpecializationKind TSK);\n\n  void setParams(ASTContext &C, ArrayRef<ParmVarDecl *> NewParamInfo);\n\n  // This is unfortunately needed because ASTDeclWriter::VisitFunctionDecl\n  // need to access this bit but we want to avoid making ASTDeclWriter\n  // a friend of FunctionDeclBitfields just for this.\n  bool isDeletedBit() const { return FunctionDeclBits.IsDeleted; }\n\n  /// Whether an ODRHash has been stored.\n  bool hasODRHash() const { return FunctionDeclBits.HasODRHash; }\n\n  /// State that an ODRHash has been stored.\n  void setHasODRHash(bool B = true) { FunctionDeclBits.HasODRHash = B; }\n\nprotected:\n  FunctionDecl(Kind DK, ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n               const DeclarationNameInfo &NameInfo, QualType T,\n               TypeSourceInfo *TInfo, StorageClass S, bool isInlineSpecified,\n               ConstexprSpecKind ConstexprKind,\n               Expr *TrailingRequiresClause = nullptr);\n\n  using redeclarable_base = Redeclarable<FunctionDecl>;\n\n  FunctionDecl *getNextRedeclarationImpl() override {\n    return getNextRedeclaration();\n  }\n\n  FunctionDecl *getPreviousDeclImpl() override {\n    return getPreviousDecl();\n  }\n\n  FunctionDecl *getMostRecentDeclImpl() override {\n    return getMostRecentDecl();\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  static FunctionDecl *\n  Create(ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n         SourceLocation NLoc, DeclarationName N, QualType T,\n         TypeSourceInfo *TInfo, StorageClass SC, bool isInlineSpecified = false,\n         bool hasWrittenPrototype = true,\n         ConstexprSpecKind ConstexprKind = ConstexprSpecKind::Unspecified,\n         Expr *TrailingRequiresClause = nullptr) {\n    DeclarationNameInfo NameInfo(N, NLoc);\n    return FunctionDecl::Create(C, DC, StartLoc, NameInfo, T, TInfo, SC,\n                                isInlineSpecified, hasWrittenPrototype,\n                                ConstexprKind, TrailingRequiresClause);\n  }\n\n  static FunctionDecl *Create(ASTContext &C, DeclContext *DC,\n                              SourceLocation StartLoc,\n                              const DeclarationNameInfo &NameInfo, QualType T,\n                              TypeSourceInfo *TInfo, StorageClass SC,\n                              bool isInlineSpecified, bool hasWrittenPrototype,\n                              ConstexprSpecKind ConstexprKind,\n                              Expr *TrailingRequiresClause);\n\n  static FunctionDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  DeclarationNameInfo getNameInfo() const {\n    return DeclarationNameInfo(getDeclName(), getLocation(), DNLoc);\n  }\n\n  void getNameForDiagnostic(raw_ostream &OS, const PrintingPolicy &Policy,\n                            bool Qualified) const override;\n\n  void setRangeEnd(SourceLocation E) { EndRangeLoc = E; }\n\n  /// Returns the location of the ellipsis of a variadic function.\n  SourceLocation getEllipsisLoc() const {\n    const auto *FPT = getType()->getAs<FunctionProtoType>();\n    if (FPT && FPT->isVariadic())\n      return FPT->getEllipsisLoc();\n    return SourceLocation();\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  // Function definitions.\n  //\n  // A function declaration may be:\n  // - a non defining declaration,\n  // - a definition. A function may be defined because:\n  //   - it has a body, or will have it in the case of late parsing.\n  //   - it has an uninstantiated body. The body does not exist because the\n  //     function is not used yet, but the declaration is considered a\n  //     definition and does not allow other definition of this function.\n  //   - it does not have a user specified body, but it does not allow\n  //     redefinition, because it is deleted/defaulted or is defined through\n  //     some other mechanism (alias, ifunc).\n\n  /// Returns true if the function has a body.\n  ///\n  /// The function body might be in any of the (re-)declarations of this\n  /// function. The variant that accepts a FunctionDecl pointer will set that\n  /// function declaration to the actual declaration containing the body (if\n  /// there is one).\n  bool hasBody(const FunctionDecl *&Definition) const;\n\n  bool hasBody() const override {\n    const FunctionDecl* Definition;\n    return hasBody(Definition);\n  }\n\n  /// Returns whether the function has a trivial body that does not require any\n  /// specific codegen.\n  bool hasTrivialBody() const;\n\n  /// Returns true if the function has a definition that does not need to be\n  /// instantiated.\n  ///\n  /// The variant that accepts a FunctionDecl pointer will set that function\n  /// declaration to the declaration that is a definition (if there is one).\n  ///\n  /// \\param CheckForPendingFriendDefinition If \\c true, also check for friend\n  ///        declarations that were instantiataed from function definitions.\n  ///        Such a declaration behaves as if it is a definition for the\n  ///        purpose of redefinition checking, but isn't actually a \"real\"\n  ///        definition until its body is instantiated.\n  bool isDefined(const FunctionDecl *&Definition,\n                 bool CheckForPendingFriendDefinition = false) const;\n\n  bool isDefined() const {\n    const FunctionDecl* Definition;\n    return isDefined(Definition);\n  }\n\n  /// Get the definition for this declaration.\n  FunctionDecl *getDefinition() {\n    const FunctionDecl *Definition;\n    if (isDefined(Definition))\n      return const_cast<FunctionDecl *>(Definition);\n    return nullptr;\n  }\n  const FunctionDecl *getDefinition() const {\n    return const_cast<FunctionDecl *>(this)->getDefinition();\n  }\n\n  /// Retrieve the body (definition) of the function. The function body might be\n  /// in any of the (re-)declarations of this function. The variant that accepts\n  /// a FunctionDecl pointer will set that function declaration to the actual\n  /// declaration containing the body (if there is one).\n  /// NOTE: For checking if there is a body, use hasBody() instead, to avoid\n  /// unnecessary AST de-serialization of the body.\n  Stmt *getBody(const FunctionDecl *&Definition) const;\n\n  Stmt *getBody() const override {\n    const FunctionDecl* Definition;\n    return getBody(Definition);\n  }\n\n  /// Returns whether this specific declaration of the function is also a\n  /// definition that does not contain uninstantiated body.\n  ///\n  /// This does not determine whether the function has been defined (e.g., in a\n  /// previous definition); for that information, use isDefined.\n  ///\n  /// Note: the function declaration does not become a definition until the\n  /// parser reaches the definition, if called before, this function will return\n  /// `false`.\n  bool isThisDeclarationADefinition() const {\n    return isDeletedAsWritten() || isDefaulted() ||\n           doesThisDeclarationHaveABody() || hasSkippedBody() ||\n           willHaveBody() || hasDefiningAttr();\n  }\n\n  /// Determine whether this specific declaration of the function is a friend\n  /// declaration that was instantiated from a function definition. Such\n  /// declarations behave like definitions in some contexts.\n  bool isThisDeclarationInstantiatedFromAFriendDefinition() const;\n\n  /// Returns whether this specific declaration of the function has a body.\n  bool doesThisDeclarationHaveABody() const {\n    return (!FunctionDeclBits.HasDefaultedFunctionInfo && Body) ||\n           isLateTemplateParsed();\n  }\n\n  void setBody(Stmt *B);\n  void setLazyBody(uint64_t Offset) {\n    FunctionDeclBits.HasDefaultedFunctionInfo = false;\n    Body = LazyDeclStmtPtr(Offset);\n  }\n\n  void setDefaultedFunctionInfo(DefaultedFunctionInfo *Info);\n  DefaultedFunctionInfo *getDefaultedFunctionInfo() const;\n\n  /// Whether this function is variadic.\n  bool isVariadic() const;\n\n  /// Whether this function is marked as virtual explicitly.\n  bool isVirtualAsWritten() const {\n    return FunctionDeclBits.IsVirtualAsWritten;\n  }\n\n  /// State that this function is marked as virtual explicitly.\n  void setVirtualAsWritten(bool V) { FunctionDeclBits.IsVirtualAsWritten = V; }\n\n  /// Whether this virtual function is pure, i.e. makes the containing class\n  /// abstract.\n  bool isPure() const { return FunctionDeclBits.IsPure; }\n  void setPure(bool P = true);\n\n  /// Whether this templated function will be late parsed.\n  bool isLateTemplateParsed() const {\n    return FunctionDeclBits.IsLateTemplateParsed;\n  }\n\n  /// State that this templated function will be late parsed.\n  void setLateTemplateParsed(bool ILT = true) {\n    FunctionDeclBits.IsLateTemplateParsed = ILT;\n  }\n\n  /// Whether this function is \"trivial\" in some specialized C++ senses.\n  /// Can only be true for default constructors, copy constructors,\n  /// copy assignment operators, and destructors.  Not meaningful until\n  /// the class has been fully built by Sema.\n  bool isTrivial() const { return FunctionDeclBits.IsTrivial; }\n  void setTrivial(bool IT) { FunctionDeclBits.IsTrivial = IT; }\n\n  bool isTrivialForCall() const { return FunctionDeclBits.IsTrivialForCall; }\n  void setTrivialForCall(bool IT) { FunctionDeclBits.IsTrivialForCall = IT; }\n\n  /// Whether this function is defaulted. Valid for e.g.\n  /// special member functions, defaulted comparisions (not methods!).\n  bool isDefaulted() const { return FunctionDeclBits.IsDefaulted; }\n  void setDefaulted(bool D = true) { FunctionDeclBits.IsDefaulted = D; }\n\n  /// Whether this function is explicitly defaulted.\n  bool isExplicitlyDefaulted() const {\n    return FunctionDeclBits.IsExplicitlyDefaulted;\n  }\n\n  /// State that this function is explicitly defaulted.\n  void setExplicitlyDefaulted(bool ED = true) {\n    FunctionDeclBits.IsExplicitlyDefaulted = ED;\n  }\n\n  /// True if this method is user-declared and was not\n  /// deleted or defaulted on its first declaration.\n  bool isUserProvided() const {\n    auto *DeclAsWritten = this;\n    if (FunctionDecl *Pattern = getTemplateInstantiationPattern())\n      DeclAsWritten = Pattern;\n    return !(DeclAsWritten->isDeleted() ||\n             DeclAsWritten->getCanonicalDecl()->isDefaulted());\n  }\n\n  /// Whether falling off this function implicitly returns null/zero.\n  /// If a more specific implicit return value is required, front-ends\n  /// should synthesize the appropriate return statements.\n  bool hasImplicitReturnZero() const {\n    return FunctionDeclBits.HasImplicitReturnZero;\n  }\n\n  /// State that falling off this function implicitly returns null/zero.\n  /// If a more specific implicit return value is required, front-ends\n  /// should synthesize the appropriate return statements.\n  void setHasImplicitReturnZero(bool IRZ) {\n    FunctionDeclBits.HasImplicitReturnZero = IRZ;\n  }\n\n  /// Whether this function has a prototype, either because one\n  /// was explicitly written or because it was \"inherited\" by merging\n  /// a declaration without a prototype with a declaration that has a\n  /// prototype.\n  bool hasPrototype() const {\n    return hasWrittenPrototype() || hasInheritedPrototype();\n  }\n\n  /// Whether this function has a written prototype.\n  bool hasWrittenPrototype() const {\n    return FunctionDeclBits.HasWrittenPrototype;\n  }\n\n  /// State that this function has a written prototype.\n  void setHasWrittenPrototype(bool P = true) {\n    FunctionDeclBits.HasWrittenPrototype = P;\n  }\n\n  /// Whether this function inherited its prototype from a\n  /// previous declaration.\n  bool hasInheritedPrototype() const {\n    return FunctionDeclBits.HasInheritedPrototype;\n  }\n\n  /// State that this function inherited its prototype from a\n  /// previous declaration.\n  void setHasInheritedPrototype(bool P = true) {\n    FunctionDeclBits.HasInheritedPrototype = P;\n  }\n\n  /// Whether this is a (C++11) constexpr function or constexpr constructor.\n  bool isConstexpr() const {\n    return getConstexprKind() != ConstexprSpecKind::Unspecified;\n  }\n  void setConstexprKind(ConstexprSpecKind CSK) {\n    FunctionDeclBits.ConstexprKind = static_cast<uint64_t>(CSK);\n  }\n  ConstexprSpecKind getConstexprKind() const {\n    return static_cast<ConstexprSpecKind>(FunctionDeclBits.ConstexprKind);\n  }\n  bool isConstexprSpecified() const {\n    return getConstexprKind() == ConstexprSpecKind::Constexpr;\n  }\n  bool isConsteval() const {\n    return getConstexprKind() == ConstexprSpecKind::Consteval;\n  }\n\n  /// Whether the instantiation of this function is pending.\n  /// This bit is set when the decision to instantiate this function is made\n  /// and unset if and when the function body is created. That leaves out\n  /// cases where instantiation did not happen because the template definition\n  /// was not seen in this TU. This bit remains set in those cases, under the\n  /// assumption that the instantiation will happen in some other TU.\n  bool instantiationIsPending() const {\n    return FunctionDeclBits.InstantiationIsPending;\n  }\n\n  /// State that the instantiation of this function is pending.\n  /// (see instantiationIsPending)\n  void setInstantiationIsPending(bool IC) {\n    FunctionDeclBits.InstantiationIsPending = IC;\n  }\n\n  /// Indicates the function uses __try.\n  bool usesSEHTry() const { return FunctionDeclBits.UsesSEHTry; }\n  void setUsesSEHTry(bool UST) { FunctionDeclBits.UsesSEHTry = UST; }\n\n  /// Whether this function has been deleted.\n  ///\n  /// A function that is \"deleted\" (via the C++0x \"= delete\" syntax)\n  /// acts like a normal function, except that it cannot actually be\n  /// called or have its address taken. Deleted functions are\n  /// typically used in C++ overload resolution to attract arguments\n  /// whose type or lvalue/rvalue-ness would permit the use of a\n  /// different overload that would behave incorrectly. For example,\n  /// one might use deleted functions to ban implicit conversion from\n  /// a floating-point number to an Integer type:\n  ///\n  /// @code\n  /// struct Integer {\n  ///   Integer(long); // construct from a long\n  ///   Integer(double) = delete; // no construction from float or double\n  ///   Integer(long double) = delete; // no construction from long double\n  /// };\n  /// @endcode\n  // If a function is deleted, its first declaration must be.\n  bool isDeleted() const {\n    return getCanonicalDecl()->FunctionDeclBits.IsDeleted;\n  }\n\n  bool isDeletedAsWritten() const {\n    return FunctionDeclBits.IsDeleted && !isDefaulted();\n  }\n\n  void setDeletedAsWritten(bool D = true) { FunctionDeclBits.IsDeleted = D; }\n\n  /// Determines whether this function is \"main\", which is the\n  /// entry point into an executable program.\n  bool isMain() const;\n\n  /// Determines whether this function is a MSVCRT user defined entry\n  /// point.\n  bool isMSVCRTEntryPoint() const;\n\n  /// Determines whether this operator new or delete is one\n  /// of the reserved global placement operators:\n  ///    void *operator new(size_t, void *);\n  ///    void *operator new[](size_t, void *);\n  ///    void operator delete(void *, void *);\n  ///    void operator delete[](void *, void *);\n  /// These functions have special behavior under [new.delete.placement]:\n  ///    These functions are reserved, a C++ program may not define\n  ///    functions that displace the versions in the Standard C++ library.\n  ///    The provisions of [basic.stc.dynamic] do not apply to these\n  ///    reserved placement forms of operator new and operator delete.\n  ///\n  /// This function must be an allocation or deallocation function.\n  bool isReservedGlobalPlacementOperator() const;\n\n  /// Determines whether this function is one of the replaceable\n  /// global allocation functions:\n  ///    void *operator new(size_t);\n  ///    void *operator new(size_t, const std::nothrow_t &) noexcept;\n  ///    void *operator new[](size_t);\n  ///    void *operator new[](size_t, const std::nothrow_t &) noexcept;\n  ///    void operator delete(void *) noexcept;\n  ///    void operator delete(void *, std::size_t) noexcept;      [C++1y]\n  ///    void operator delete(void *, const std::nothrow_t &) noexcept;\n  ///    void operator delete[](void *) noexcept;\n  ///    void operator delete[](void *, std::size_t) noexcept;    [C++1y]\n  ///    void operator delete[](void *, const std::nothrow_t &) noexcept;\n  /// These functions have special behavior under C++1y [expr.new]:\n  ///    An implementation is allowed to omit a call to a replaceable global\n  ///    allocation function. [...]\n  ///\n  /// If this function is an aligned allocation/deallocation function, return\n  /// the parameter number of the requested alignment through AlignmentParam.\n  ///\n  /// If this function is an allocation/deallocation function that takes\n  /// the `std::nothrow_t` tag, return true through IsNothrow,\n  bool isReplaceableGlobalAllocationFunction(\n      Optional<unsigned> *AlignmentParam = nullptr,\n      bool *IsNothrow = nullptr) const;\n\n  /// Determine if this function provides an inline implementation of a builtin.\n  bool isInlineBuiltinDeclaration() const;\n\n  /// Determine whether this is a destroying operator delete.\n  bool isDestroyingOperatorDelete() const;\n\n  /// Compute the language linkage.\n  LanguageLinkage getLanguageLinkage() const;\n\n  /// Determines whether this function is a function with\n  /// external, C linkage.\n  bool isExternC() const;\n\n  /// Determines whether this function's context is, or is nested within,\n  /// a C++ extern \"C\" linkage spec.\n  bool isInExternCContext() const;\n\n  /// Determines whether this function's context is, or is nested within,\n  /// a C++ extern \"C++\" linkage spec.\n  bool isInExternCXXContext() const;\n\n  /// Determines whether this is a global function.\n  bool isGlobal() const;\n\n  /// Determines whether this function is known to be 'noreturn', through\n  /// an attribute on its declaration or its type.\n  bool isNoReturn() const;\n\n  /// True if the function was a definition but its body was skipped.\n  bool hasSkippedBody() const { return FunctionDeclBits.HasSkippedBody; }\n  void setHasSkippedBody(bool Skipped = true) {\n    FunctionDeclBits.HasSkippedBody = Skipped;\n  }\n\n  /// True if this function will eventually have a body, once it's fully parsed.\n  bool willHaveBody() const { return FunctionDeclBits.WillHaveBody; }\n  void setWillHaveBody(bool V = true) { FunctionDeclBits.WillHaveBody = V; }\n\n  /// True if this function is considered a multiversioned function.\n  bool isMultiVersion() const {\n    return getCanonicalDecl()->FunctionDeclBits.IsMultiVersion;\n  }\n\n  /// Sets the multiversion state for this declaration and all of its\n  /// redeclarations.\n  void setIsMultiVersion(bool V = true) {\n    getCanonicalDecl()->FunctionDeclBits.IsMultiVersion = V;\n  }\n\n  /// Gets the kind of multiversioning attribute this declaration has. Note that\n  /// this can return a value even if the function is not multiversion, such as\n  /// the case of 'target'.\n  MultiVersionKind getMultiVersionKind() const;\n\n\n  /// True if this function is a multiversioned dispatch function as a part of\n  /// the cpu_specific/cpu_dispatch functionality.\n  bool isCPUDispatchMultiVersion() const;\n  /// True if this function is a multiversioned processor specific function as a\n  /// part of the cpu_specific/cpu_dispatch functionality.\n  bool isCPUSpecificMultiVersion() const;\n\n  /// True if this function is a multiversioned dispatch function as a part of\n  /// the target functionality.\n  bool isTargetMultiVersion() const;\n\n  /// \\brief Get the associated-constraints of this function declaration.\n  /// Currently, this will either be a vector of size 1 containing the\n  /// trailing-requires-clause or an empty vector.\n  ///\n  /// Use this instead of getTrailingRequiresClause for concepts APIs that\n  /// accept an ArrayRef of constraint expressions.\n  void getAssociatedConstraints(SmallVectorImpl<const Expr *> &AC) const {\n    if (auto *TRC = getTrailingRequiresClause())\n      AC.push_back(TRC);\n  }\n\n  void setPreviousDeclaration(FunctionDecl * PrevDecl);\n\n  FunctionDecl *getCanonicalDecl() override;\n  const FunctionDecl *getCanonicalDecl() const {\n    return const_cast<FunctionDecl*>(this)->getCanonicalDecl();\n  }\n\n  unsigned getBuiltinID(bool ConsiderWrapperFunctions = false) const;\n\n  // ArrayRef interface to parameters.\n  ArrayRef<ParmVarDecl *> parameters() const {\n    return {ParamInfo, getNumParams()};\n  }\n  MutableArrayRef<ParmVarDecl *> parameters() {\n    return {ParamInfo, getNumParams()};\n  }\n\n  // Iterator access to formal parameters.\n  using param_iterator = MutableArrayRef<ParmVarDecl *>::iterator;\n  using param_const_iterator = ArrayRef<ParmVarDecl *>::const_iterator;\n\n  bool param_empty() const { return parameters().empty(); }\n  param_iterator param_begin() { return parameters().begin(); }\n  param_iterator param_end() { return parameters().end(); }\n  param_const_iterator param_begin() const { return parameters().begin(); }\n  param_const_iterator param_end() const { return parameters().end(); }\n  size_t param_size() const { return parameters().size(); }\n\n  /// Return the number of parameters this function must have based on its\n  /// FunctionType.  This is the length of the ParamInfo array after it has been\n  /// created.\n  unsigned getNumParams() const;\n\n  const ParmVarDecl *getParamDecl(unsigned i) const {\n    assert(i < getNumParams() && \"Illegal param #\");\n    return ParamInfo[i];\n  }\n  ParmVarDecl *getParamDecl(unsigned i) {\n    assert(i < getNumParams() && \"Illegal param #\");\n    return ParamInfo[i];\n  }\n  void setParams(ArrayRef<ParmVarDecl *> NewParamInfo) {\n    setParams(getASTContext(), NewParamInfo);\n  }\n\n  /// Returns the minimum number of arguments needed to call this function. This\n  /// may be fewer than the number of function parameters, if some of the\n  /// parameters have default arguments (in C++).\n  unsigned getMinRequiredArguments() const;\n\n  /// Determine whether this function has a single parameter, or multiple\n  /// parameters where all but the first have default arguments.\n  ///\n  /// This notion is used in the definition of copy/move constructors and\n  /// initializer list constructors. Note that, unlike getMinRequiredArguments,\n  /// parameter packs are not treated specially here.\n  bool hasOneParamOrDefaultArgs() const;\n\n  /// Find the source location information for how the type of this function\n  /// was written. May be absent (for example if the function was declared via\n  /// a typedef) and may contain a different type from that of the function\n  /// (for example if the function type was adjusted by an attribute).\n  FunctionTypeLoc getFunctionTypeLoc() const;\n\n  QualType getReturnType() const {\n    return getType()->castAs<FunctionType>()->getReturnType();\n  }\n\n  /// Attempt to compute an informative source range covering the\n  /// function return type. This may omit qualifiers and other information with\n  /// limited representation in the AST.\n  SourceRange getReturnTypeSourceRange() const;\n\n  /// Attempt to compute an informative source range covering the\n  /// function parameters, including the ellipsis of a variadic function.\n  /// The source range excludes the parentheses, and is invalid if there are\n  /// no parameters and no ellipsis.\n  SourceRange getParametersSourceRange() const;\n\n  /// Get the declared return type, which may differ from the actual return\n  /// type if the return type is deduced.\n  QualType getDeclaredReturnType() const {\n    auto *TSI = getTypeSourceInfo();\n    QualType T = TSI ? TSI->getType() : getType();\n    return T->castAs<FunctionType>()->getReturnType();\n  }\n\n  /// Gets the ExceptionSpecificationType as declared.\n  ExceptionSpecificationType getExceptionSpecType() const {\n    auto *TSI = getTypeSourceInfo();\n    QualType T = TSI ? TSI->getType() : getType();\n    const auto *FPT = T->getAs<FunctionProtoType>();\n    return FPT ? FPT->getExceptionSpecType() : EST_None;\n  }\n\n  /// Attempt to compute an informative source range covering the\n  /// function exception specification, if any.\n  SourceRange getExceptionSpecSourceRange() const;\n\n  /// Determine the type of an expression that calls this function.\n  QualType getCallResultType() const {\n    return getType()->castAs<FunctionType>()->getCallResultType(\n        getASTContext());\n  }\n\n  /// Returns the storage class as written in the source. For the\n  /// computed linkage of symbol, see getLinkage.\n  StorageClass getStorageClass() const {\n    return static_cast<StorageClass>(FunctionDeclBits.SClass);\n  }\n\n  /// Sets the storage class as written in the source.\n  void setStorageClass(StorageClass SClass) {\n    FunctionDeclBits.SClass = SClass;\n  }\n\n  /// Determine whether the \"inline\" keyword was specified for this\n  /// function.\n  bool isInlineSpecified() const { return FunctionDeclBits.IsInlineSpecified; }\n\n  /// Set whether the \"inline\" keyword was specified for this function.\n  void setInlineSpecified(bool I) {\n    FunctionDeclBits.IsInlineSpecified = I;\n    FunctionDeclBits.IsInline = I;\n  }\n\n  /// Flag that this function is implicitly inline.\n  void setImplicitlyInline(bool I = true) { FunctionDeclBits.IsInline = I; }\n\n  /// Determine whether this function should be inlined, because it is\n  /// either marked \"inline\" or \"constexpr\" or is a member function of a class\n  /// that was defined in the class body.\n  bool isInlined() const { return FunctionDeclBits.IsInline; }\n\n  bool isInlineDefinitionExternallyVisible() const;\n\n  bool isMSExternInline() const;\n\n  bool doesDeclarationForceExternallyVisibleDefinition() const;\n\n  bool isStatic() const { return getStorageClass() == SC_Static; }\n\n  /// Whether this function declaration represents an C++ overloaded\n  /// operator, e.g., \"operator+\".\n  bool isOverloadedOperator() const {\n    return getOverloadedOperator() != OO_None;\n  }\n\n  OverloadedOperatorKind getOverloadedOperator() const;\n\n  const IdentifierInfo *getLiteralIdentifier() const;\n\n  /// If this function is an instantiation of a member function\n  /// of a class template specialization, retrieves the function from\n  /// which it was instantiated.\n  ///\n  /// This routine will return non-NULL for (non-templated) member\n  /// functions of class templates and for instantiations of function\n  /// templates. For example, given:\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   void f(T);\n  /// };\n  /// \\endcode\n  ///\n  /// The declaration for X<int>::f is a (non-templated) FunctionDecl\n  /// whose parent is the class template specialization X<int>. For\n  /// this declaration, getInstantiatedFromFunction() will return\n  /// the FunctionDecl X<T>::A. When a complete definition of\n  /// X<int>::A is required, it will be instantiated from the\n  /// declaration returned by getInstantiatedFromMemberFunction().\n  FunctionDecl *getInstantiatedFromMemberFunction() const;\n\n  /// What kind of templated function this is.\n  TemplatedKind getTemplatedKind() const;\n\n  /// If this function is an instantiation of a member function of a\n  /// class template specialization, retrieves the member specialization\n  /// information.\n  MemberSpecializationInfo *getMemberSpecializationInfo() const;\n\n  /// Specify that this record is an instantiation of the\n  /// member function FD.\n  void setInstantiationOfMemberFunction(FunctionDecl *FD,\n                                        TemplateSpecializationKind TSK) {\n    setInstantiationOfMemberFunction(getASTContext(), FD, TSK);\n  }\n\n  /// Retrieves the function template that is described by this\n  /// function declaration.\n  ///\n  /// Every function template is represented as a FunctionTemplateDecl\n  /// and a FunctionDecl (or something derived from FunctionDecl). The\n  /// former contains template properties (such as the template\n  /// parameter lists) while the latter contains the actual\n  /// description of the template's\n  /// contents. FunctionTemplateDecl::getTemplatedDecl() retrieves the\n  /// FunctionDecl that describes the function template,\n  /// getDescribedFunctionTemplate() retrieves the\n  /// FunctionTemplateDecl from a FunctionDecl.\n  FunctionTemplateDecl *getDescribedFunctionTemplate() const;\n\n  void setDescribedFunctionTemplate(FunctionTemplateDecl *Template);\n\n  /// Determine whether this function is a function template\n  /// specialization.\n  bool isFunctionTemplateSpecialization() const {\n    return getPrimaryTemplate() != nullptr;\n  }\n\n  /// If this function is actually a function template specialization,\n  /// retrieve information about this function template specialization.\n  /// Otherwise, returns NULL.\n  FunctionTemplateSpecializationInfo *getTemplateSpecializationInfo() const;\n\n  /// Determines whether this function is a function template\n  /// specialization or a member of a class template specialization that can\n  /// be implicitly instantiated.\n  bool isImplicitlyInstantiable() const;\n\n  /// Determines if the given function was instantiated from a\n  /// function template.\n  bool isTemplateInstantiation() const;\n\n  /// Retrieve the function declaration from which this function could\n  /// be instantiated, if it is an instantiation (rather than a non-template\n  /// or a specialization, for example).\n  ///\n  /// If \\p ForDefinition is \\c false, explicit specializations will be treated\n  /// as if they were implicit instantiations. This will then find the pattern\n  /// corresponding to non-definition portions of the declaration, such as\n  /// default arguments and the exception specification.\n  FunctionDecl *\n  getTemplateInstantiationPattern(bool ForDefinition = true) const;\n\n  /// Retrieve the primary template that this function template\n  /// specialization either specializes or was instantiated from.\n  ///\n  /// If this function declaration is not a function template specialization,\n  /// returns NULL.\n  FunctionTemplateDecl *getPrimaryTemplate() const;\n\n  /// Retrieve the template arguments used to produce this function\n  /// template specialization from the primary template.\n  ///\n  /// If this function declaration is not a function template specialization,\n  /// returns NULL.\n  const TemplateArgumentList *getTemplateSpecializationArgs() const;\n\n  /// Retrieve the template argument list as written in the sources,\n  /// if any.\n  ///\n  /// If this function declaration is not a function template specialization\n  /// or if it had no explicit template argument list, returns NULL.\n  /// Note that it an explicit template argument list may be written empty,\n  /// e.g., template<> void foo<>(char* s);\n  const ASTTemplateArgumentListInfo*\n  getTemplateSpecializationArgsAsWritten() const;\n\n  /// Specify that this function declaration is actually a function\n  /// template specialization.\n  ///\n  /// \\param Template the function template that this function template\n  /// specialization specializes.\n  ///\n  /// \\param TemplateArgs the template arguments that produced this\n  /// function template specialization from the template.\n  ///\n  /// \\param InsertPos If non-NULL, the position in the function template\n  /// specialization set where the function template specialization data will\n  /// be inserted.\n  ///\n  /// \\param TSK the kind of template specialization this is.\n  ///\n  /// \\param TemplateArgsAsWritten location info of template arguments.\n  ///\n  /// \\param PointOfInstantiation point at which the function template\n  /// specialization was first instantiated.\n  void setFunctionTemplateSpecialization(FunctionTemplateDecl *Template,\n                const TemplateArgumentList *TemplateArgs,\n                void *InsertPos,\n                TemplateSpecializationKind TSK = TSK_ImplicitInstantiation,\n                const TemplateArgumentListInfo *TemplateArgsAsWritten = nullptr,\n                SourceLocation PointOfInstantiation = SourceLocation()) {\n    setFunctionTemplateSpecialization(getASTContext(), Template, TemplateArgs,\n                                      InsertPos, TSK, TemplateArgsAsWritten,\n                                      PointOfInstantiation);\n  }\n\n  /// Specifies that this function declaration is actually a\n  /// dependent function template specialization.\n  void setDependentTemplateSpecialization(ASTContext &Context,\n                             const UnresolvedSetImpl &Templates,\n                      const TemplateArgumentListInfo &TemplateArgs);\n\n  DependentFunctionTemplateSpecializationInfo *\n  getDependentSpecializationInfo() const;\n\n  /// Determine what kind of template instantiation this function\n  /// represents.\n  TemplateSpecializationKind getTemplateSpecializationKind() const;\n\n  /// Determine the kind of template specialization this function represents\n  /// for the purpose of template instantiation.\n  TemplateSpecializationKind\n  getTemplateSpecializationKindForInstantiation() const;\n\n  /// Determine what kind of template instantiation this function\n  /// represents.\n  void setTemplateSpecializationKind(TemplateSpecializationKind TSK,\n                        SourceLocation PointOfInstantiation = SourceLocation());\n\n  /// Retrieve the (first) point of instantiation of a function template\n  /// specialization or a member of a class template specialization.\n  ///\n  /// \\returns the first point of instantiation, if this function was\n  /// instantiated from a template; otherwise, returns an invalid source\n  /// location.\n  SourceLocation getPointOfInstantiation() const;\n\n  /// Determine whether this is or was instantiated from an out-of-line\n  /// definition of a member function.\n  bool isOutOfLine() const override;\n\n  /// Identify a memory copying or setting function.\n  /// If the given function is a memory copy or setting function, returns\n  /// the corresponding Builtin ID. If the function is not a memory function,\n  /// returns 0.\n  unsigned getMemoryFunctionKind() const;\n\n  /// Returns ODRHash of the function.  This value is calculated and\n  /// stored on first call, then the stored value returned on the other calls.\n  unsigned getODRHash();\n\n  /// Returns cached ODRHash of the function.  This must have been previously\n  /// computed and stored.\n  unsigned getODRHash() const;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K >= firstFunction && K <= lastFunction;\n  }\n  static DeclContext *castToDeclContext(const FunctionDecl *D) {\n    return static_cast<DeclContext *>(const_cast<FunctionDecl*>(D));\n  }\n  static FunctionDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<FunctionDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Represents a member of a struct/union/class.\nclass FieldDecl : public DeclaratorDecl, public Mergeable<FieldDecl> {\n  unsigned BitField : 1;\n  unsigned Mutable : 1;\n  mutable unsigned CachedFieldIndex : 30;\n\n  /// The kinds of value we can store in InitializerOrBitWidth.\n  ///\n  /// Note that this is compatible with InClassInitStyle except for\n  /// ISK_CapturedVLAType.\n  enum InitStorageKind {\n    /// If the pointer is null, there's nothing special.  Otherwise,\n    /// this is a bitfield and the pointer is the Expr* storing the\n    /// bit-width.\n    ISK_NoInit = (unsigned) ICIS_NoInit,\n\n    /// The pointer is an (optional due to delayed parsing) Expr*\n    /// holding the copy-initializer.\n    ISK_InClassCopyInit = (unsigned) ICIS_CopyInit,\n\n    /// The pointer is an (optional due to delayed parsing) Expr*\n    /// holding the list-initializer.\n    ISK_InClassListInit = (unsigned) ICIS_ListInit,\n\n    /// The pointer is a VariableArrayType* that's been captured;\n    /// the enclosing context is a lambda or captured statement.\n    ISK_CapturedVLAType,\n  };\n\n  /// If this is a bitfield with a default member initializer, this\n  /// structure is used to represent the two expressions.\n  struct InitAndBitWidth {\n    Expr *Init;\n    Expr *BitWidth;\n  };\n\n  /// Storage for either the bit-width, the in-class initializer, or\n  /// both (via InitAndBitWidth), or the captured variable length array bound.\n  ///\n  /// If the storage kind is ISK_InClassCopyInit or\n  /// ISK_InClassListInit, but the initializer is null, then this\n  /// field has an in-class initializer that has not yet been parsed\n  /// and attached.\n  // FIXME: Tail-allocate this to reduce the size of FieldDecl in the\n  // overwhelmingly common case that we have none of these things.\n  llvm::PointerIntPair<void *, 2, InitStorageKind> InitStorage;\n\nprotected:\n  FieldDecl(Kind DK, DeclContext *DC, SourceLocation StartLoc,\n            SourceLocation IdLoc, IdentifierInfo *Id,\n            QualType T, TypeSourceInfo *TInfo, Expr *BW, bool Mutable,\n            InClassInitStyle InitStyle)\n    : DeclaratorDecl(DK, DC, IdLoc, Id, T, TInfo, StartLoc),\n      BitField(false), Mutable(Mutable), CachedFieldIndex(0),\n      InitStorage(nullptr, (InitStorageKind) InitStyle) {\n    if (BW)\n      setBitWidth(BW);\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static FieldDecl *Create(const ASTContext &C, DeclContext *DC,\n                           SourceLocation StartLoc, SourceLocation IdLoc,\n                           IdentifierInfo *Id, QualType T,\n                           TypeSourceInfo *TInfo, Expr *BW, bool Mutable,\n                           InClassInitStyle InitStyle);\n\n  static FieldDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// Returns the index of this field within its record,\n  /// as appropriate for passing to ASTRecordLayout::getFieldOffset.\n  unsigned getFieldIndex() const;\n\n  /// Determines whether this field is mutable (C++ only).\n  bool isMutable() const { return Mutable; }\n\n  /// Determines whether this field is a bitfield.\n  bool isBitField() const { return BitField; }\n\n  /// Determines whether this is an unnamed bitfield.\n  bool isUnnamedBitfield() const { return isBitField() && !getDeclName(); }\n\n  /// Determines whether this field is a\n  /// representative for an anonymous struct or union. Such fields are\n  /// unnamed and are implicitly generated by the implementation to\n  /// store the data for the anonymous union or struct.\n  bool isAnonymousStructOrUnion() const;\n\n  Expr *getBitWidth() const {\n    if (!BitField)\n      return nullptr;\n    void *Ptr = InitStorage.getPointer();\n    if (getInClassInitStyle())\n      return static_cast<InitAndBitWidth*>(Ptr)->BitWidth;\n    return static_cast<Expr*>(Ptr);\n  }\n\n  unsigned getBitWidthValue(const ASTContext &Ctx) const;\n\n  /// Set the bit-field width for this member.\n  // Note: used by some clients (i.e., do not remove it).\n  void setBitWidth(Expr *Width) {\n    assert(!hasCapturedVLAType() && !BitField &&\n           \"bit width or captured type already set\");\n    assert(Width && \"no bit width specified\");\n    InitStorage.setPointer(\n        InitStorage.getInt()\n            ? new (getASTContext())\n                  InitAndBitWidth{getInClassInitializer(), Width}\n            : static_cast<void*>(Width));\n    BitField = true;\n  }\n\n  /// Remove the bit-field width from this member.\n  // Note: used by some clients (i.e., do not remove it).\n  void removeBitWidth() {\n    assert(isBitField() && \"no bitfield width to remove\");\n    InitStorage.setPointer(getInClassInitializer());\n    BitField = false;\n  }\n\n  /// Is this a zero-length bit-field? Such bit-fields aren't really bit-fields\n  /// at all and instead act as a separator between contiguous runs of other\n  /// bit-fields.\n  bool isZeroLengthBitField(const ASTContext &Ctx) const;\n\n  /// Determine if this field is a subobject of zero size, that is, either a\n  /// zero-length bit-field or a field of empty class type with the\n  /// [[no_unique_address]] attribute.\n  bool isZeroSize(const ASTContext &Ctx) const;\n\n  /// Get the kind of (C++11) default member initializer that this field has.\n  InClassInitStyle getInClassInitStyle() const {\n    InitStorageKind storageKind = InitStorage.getInt();\n    return (storageKind == ISK_CapturedVLAType\n              ? ICIS_NoInit : (InClassInitStyle) storageKind);\n  }\n\n  /// Determine whether this member has a C++11 default member initializer.\n  bool hasInClassInitializer() const {\n    return getInClassInitStyle() != ICIS_NoInit;\n  }\n\n  /// Get the C++11 default member initializer for this member, or null if one\n  /// has not been set. If a valid declaration has a default member initializer,\n  /// but this returns null, then we have not parsed and attached it yet.\n  Expr *getInClassInitializer() const {\n    if (!hasInClassInitializer())\n      return nullptr;\n    void *Ptr = InitStorage.getPointer();\n    if (BitField)\n      return static_cast<InitAndBitWidth*>(Ptr)->Init;\n    return static_cast<Expr*>(Ptr);\n  }\n\n  /// Set the C++11 in-class initializer for this member.\n  void setInClassInitializer(Expr *Init) {\n    assert(hasInClassInitializer() && !getInClassInitializer());\n    if (BitField)\n      static_cast<InitAndBitWidth*>(InitStorage.getPointer())->Init = Init;\n    else\n      InitStorage.setPointer(Init);\n  }\n\n  /// Remove the C++11 in-class initializer from this member.\n  void removeInClassInitializer() {\n    assert(hasInClassInitializer() && \"no initializer to remove\");\n    InitStorage.setPointerAndInt(getBitWidth(), ISK_NoInit);\n  }\n\n  /// Determine whether this member captures the variable length array\n  /// type.\n  bool hasCapturedVLAType() const {\n    return InitStorage.getInt() == ISK_CapturedVLAType;\n  }\n\n  /// Get the captured variable length array type.\n  const VariableArrayType *getCapturedVLAType() const {\n    return hasCapturedVLAType() ? static_cast<const VariableArrayType *>(\n                                      InitStorage.getPointer())\n                                : nullptr;\n  }\n\n  /// Set the captured variable length array type for this field.\n  void setCapturedVLAType(const VariableArrayType *VLAType);\n\n  /// Returns the parent of this field declaration, which\n  /// is the struct in which this field is defined.\n  ///\n  /// Returns null if this is not a normal class/struct field declaration, e.g.\n  /// ObjCAtDefsFieldDecl, ObjCIvarDecl.\n  const RecordDecl *getParent() const {\n    return dyn_cast<RecordDecl>(getDeclContext());\n  }\n\n  RecordDecl *getParent() {\n    return dyn_cast<RecordDecl>(getDeclContext());\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  /// Retrieves the canonical declaration of this field.\n  FieldDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const FieldDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K >= firstField && K <= lastField; }\n};\n\n/// An instance of this object exists for each enum constant\n/// that is defined.  For example, in \"enum X {a,b}\", each of a/b are\n/// EnumConstantDecl's, X is an instance of EnumDecl, and the type of a/b is a\n/// TagType for the X EnumDecl.\nclass EnumConstantDecl : public ValueDecl, public Mergeable<EnumConstantDecl> {\n  Stmt *Init; // an integer constant expression\n  llvm::APSInt Val; // The value.\n\nprotected:\n  EnumConstantDecl(DeclContext *DC, SourceLocation L,\n                   IdentifierInfo *Id, QualType T, Expr *E,\n                   const llvm::APSInt &V)\n    : ValueDecl(EnumConstant, DC, L, Id, T), Init((Stmt*)E), Val(V) {}\n\npublic:\n  friend class StmtIteratorBase;\n\n  static EnumConstantDecl *Create(ASTContext &C, EnumDecl *DC,\n                                  SourceLocation L, IdentifierInfo *Id,\n                                  QualType T, Expr *E,\n                                  const llvm::APSInt &V);\n  static EnumConstantDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  const Expr *getInitExpr() const { return (const Expr*) Init; }\n  Expr *getInitExpr() { return (Expr*) Init; }\n  const llvm::APSInt &getInitVal() const { return Val; }\n\n  void setInitExpr(Expr *E) { Init = (Stmt*) E; }\n  void setInitVal(const llvm::APSInt &V) { Val = V; }\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  /// Retrieves the canonical declaration of this enumerator.\n  EnumConstantDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const EnumConstantDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == EnumConstant; }\n};\n\n/// Represents a field injected from an anonymous union/struct into the parent\n/// scope. These are always implicit.\nclass IndirectFieldDecl : public ValueDecl,\n                          public Mergeable<IndirectFieldDecl> {\n  NamedDecl **Chaining;\n  unsigned ChainingSize;\n\n  IndirectFieldDecl(ASTContext &C, DeclContext *DC, SourceLocation L,\n                    DeclarationName N, QualType T,\n                    MutableArrayRef<NamedDecl *> CH);\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n\n  static IndirectFieldDecl *Create(ASTContext &C, DeclContext *DC,\n                                   SourceLocation L, IdentifierInfo *Id,\n                                   QualType T, llvm::MutableArrayRef<NamedDecl *> CH);\n\n  static IndirectFieldDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  using chain_iterator = ArrayRef<NamedDecl *>::const_iterator;\n\n  ArrayRef<NamedDecl *> chain() const {\n    return llvm::makeArrayRef(Chaining, ChainingSize);\n  }\n  chain_iterator chain_begin() const { return chain().begin(); }\n  chain_iterator chain_end() const { return chain().end(); }\n\n  unsigned getChainingSize() const { return ChainingSize; }\n\n  FieldDecl *getAnonField() const {\n    assert(chain().size() >= 2);\n    return cast<FieldDecl>(chain().back());\n  }\n\n  VarDecl *getVarDecl() const {\n    assert(chain().size() >= 2);\n    return dyn_cast<VarDecl>(chain().front());\n  }\n\n  IndirectFieldDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const IndirectFieldDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == IndirectField; }\n};\n\n/// Represents a declaration of a type.\nclass TypeDecl : public NamedDecl {\n  friend class ASTContext;\n\n  /// This indicates the Type object that represents\n  /// this TypeDecl.  It is a cache maintained by\n  /// ASTContext::getTypedefType, ASTContext::getTagDeclType, and\n  /// ASTContext::getTemplateTypeParmType, and TemplateTypeParmDecl.\n  mutable const Type *TypeForDecl = nullptr;\n\n  /// The start of the source range for this declaration.\n  SourceLocation LocStart;\n\n  void anchor() override;\n\nprotected:\n  TypeDecl(Kind DK, DeclContext *DC, SourceLocation L, IdentifierInfo *Id,\n           SourceLocation StartL = SourceLocation())\n    : NamedDecl(DK, DC, L, Id), LocStart(StartL) {}\n\npublic:\n  // Low-level accessor. If you just want the type defined by this node,\n  // check out ASTContext::getTypeDeclType or one of\n  // ASTContext::getTypedefType, ASTContext::getRecordType, etc. if you\n  // already know the specific kind of node this is.\n  const Type *getTypeForDecl() const { return TypeForDecl; }\n  void setTypeForDecl(const Type *TD) { TypeForDecl = TD; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return LocStart; }\n  void setLocStart(SourceLocation L) { LocStart = L; }\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    if (LocStart.isValid())\n      return SourceRange(LocStart, getLocation());\n    else\n      return SourceRange(getLocation());\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K >= firstType && K <= lastType; }\n};\n\n/// Base class for declarations which introduce a typedef-name.\nclass TypedefNameDecl : public TypeDecl, public Redeclarable<TypedefNameDecl> {\n  struct alignas(8) ModedTInfo {\n    TypeSourceInfo *first;\n    QualType second;\n  };\n\n  /// If int part is 0, we have not computed IsTransparentTag.\n  /// Otherwise, IsTransparentTag is (getInt() >> 1).\n  mutable llvm::PointerIntPair<\n      llvm::PointerUnion<TypeSourceInfo *, ModedTInfo *>, 2>\n      MaybeModedTInfo;\n\n  void anchor() override;\n\nprotected:\n  TypedefNameDecl(Kind DK, ASTContext &C, DeclContext *DC,\n                  SourceLocation StartLoc, SourceLocation IdLoc,\n                  IdentifierInfo *Id, TypeSourceInfo *TInfo)\n      : TypeDecl(DK, DC, IdLoc, Id, StartLoc), redeclarable_base(C),\n        MaybeModedTInfo(TInfo, 0) {}\n\n  using redeclarable_base = Redeclarable<TypedefNameDecl>;\n\n  TypedefNameDecl *getNextRedeclarationImpl() override {\n    return getNextRedeclaration();\n  }\n\n  TypedefNameDecl *getPreviousDeclImpl() override {\n    return getPreviousDecl();\n  }\n\n  TypedefNameDecl *getMostRecentDeclImpl() override {\n    return getMostRecentDecl();\n  }\n\npublic:\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  bool isModed() const {\n    return MaybeModedTInfo.getPointer().is<ModedTInfo *>();\n  }\n\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return isModed() ? MaybeModedTInfo.getPointer().get<ModedTInfo *>()->first\n                     : MaybeModedTInfo.getPointer().get<TypeSourceInfo *>();\n  }\n\n  QualType getUnderlyingType() const {\n    return isModed() ? MaybeModedTInfo.getPointer().get<ModedTInfo *>()->second\n                     : MaybeModedTInfo.getPointer()\n                           .get<TypeSourceInfo *>()\n                           ->getType();\n  }\n\n  void setTypeSourceInfo(TypeSourceInfo *newType) {\n    MaybeModedTInfo.setPointer(newType);\n  }\n\n  void setModedTypeSourceInfo(TypeSourceInfo *unmodedTSI, QualType modedTy) {\n    MaybeModedTInfo.setPointer(new (getASTContext(), 8)\n                                   ModedTInfo({unmodedTSI, modedTy}));\n  }\n\n  /// Retrieves the canonical declaration of this typedef-name.\n  TypedefNameDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const TypedefNameDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  /// Retrieves the tag declaration for which this is the typedef name for\n  /// linkage purposes, if any.\n  ///\n  /// \\param AnyRedecl Look for the tag declaration in any redeclaration of\n  /// this typedef declaration.\n  TagDecl *getAnonDeclWithTypedefName(bool AnyRedecl = false) const;\n\n  /// Determines if this typedef shares a name and spelling location with its\n  /// underlying tag type, as is the case with the NS_ENUM macro.\n  bool isTransparentTag() const {\n    if (MaybeModedTInfo.getInt())\n      return MaybeModedTInfo.getInt() & 0x2;\n    return isTransparentTagSlow();\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K >= firstTypedefName && K <= lastTypedefName;\n  }\n\nprivate:\n  bool isTransparentTagSlow() const;\n};\n\n/// Represents the declaration of a typedef-name via the 'typedef'\n/// type specifier.\nclass TypedefDecl : public TypedefNameDecl {\n  TypedefDecl(ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n              SourceLocation IdLoc, IdentifierInfo *Id, TypeSourceInfo *TInfo)\n      : TypedefNameDecl(Typedef, C, DC, StartLoc, IdLoc, Id, TInfo) {}\n\npublic:\n  static TypedefDecl *Create(ASTContext &C, DeclContext *DC,\n                             SourceLocation StartLoc, SourceLocation IdLoc,\n                             IdentifierInfo *Id, TypeSourceInfo *TInfo);\n  static TypedefDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Typedef; }\n};\n\n/// Represents the declaration of a typedef-name via a C++11\n/// alias-declaration.\nclass TypeAliasDecl : public TypedefNameDecl {\n  /// The template for which this is the pattern, if any.\n  TypeAliasTemplateDecl *Template;\n\n  TypeAliasDecl(ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n                SourceLocation IdLoc, IdentifierInfo *Id, TypeSourceInfo *TInfo)\n      : TypedefNameDecl(TypeAlias, C, DC, StartLoc, IdLoc, Id, TInfo),\n        Template(nullptr) {}\n\npublic:\n  static TypeAliasDecl *Create(ASTContext &C, DeclContext *DC,\n                               SourceLocation StartLoc, SourceLocation IdLoc,\n                               IdentifierInfo *Id, TypeSourceInfo *TInfo);\n  static TypeAliasDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  TypeAliasTemplateDecl *getDescribedAliasTemplate() const { return Template; }\n  void setDescribedAliasTemplate(TypeAliasTemplateDecl *TAT) { Template = TAT; }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == TypeAlias; }\n};\n\n/// Represents the declaration of a struct/union/class/enum.\nclass TagDecl : public TypeDecl,\n                public DeclContext,\n                public Redeclarable<TagDecl> {\n  // This class stores some data in DeclContext::TagDeclBits\n  // to save some space. Use the provided accessors to access it.\npublic:\n  // This is really ugly.\n  using TagKind = TagTypeKind;\n\nprivate:\n  SourceRange BraceRange;\n\n  // A struct representing syntactic qualifier info,\n  // to be used for the (uncommon) case of out-of-line declarations.\n  using ExtInfo = QualifierInfo;\n\n  /// If the (out-of-line) tag declaration name\n  /// is qualified, it points to the qualifier info (nns and range);\n  /// otherwise, if the tag declaration is anonymous and it is part of\n  /// a typedef or alias, it points to the TypedefNameDecl (used for mangling);\n  /// otherwise, if the tag declaration is anonymous and it is used as a\n  /// declaration specifier for variables, it points to the first VarDecl (used\n  /// for mangling);\n  /// otherwise, it is a null (TypedefNameDecl) pointer.\n  llvm::PointerUnion<TypedefNameDecl *, ExtInfo *> TypedefNameDeclOrQualifier;\n\n  bool hasExtInfo() const { return TypedefNameDeclOrQualifier.is<ExtInfo *>(); }\n  ExtInfo *getExtInfo() { return TypedefNameDeclOrQualifier.get<ExtInfo *>(); }\n  const ExtInfo *getExtInfo() const {\n    return TypedefNameDeclOrQualifier.get<ExtInfo *>();\n  }\n\nprotected:\n  TagDecl(Kind DK, TagKind TK, const ASTContext &C, DeclContext *DC,\n          SourceLocation L, IdentifierInfo *Id, TagDecl *PrevDecl,\n          SourceLocation StartL);\n\n  using redeclarable_base = Redeclarable<TagDecl>;\n\n  TagDecl *getNextRedeclarationImpl() override {\n    return getNextRedeclaration();\n  }\n\n  TagDecl *getPreviousDeclImpl() override {\n    return getPreviousDecl();\n  }\n\n  TagDecl *getMostRecentDeclImpl() override {\n    return getMostRecentDecl();\n  }\n\n  /// Completes the definition of this tag declaration.\n  ///\n  /// This is a helper function for derived classes.\n  void completeDefinition();\n\n  /// True if this decl is currently being defined.\n  void setBeingDefined(bool V = true) { TagDeclBits.IsBeingDefined = V; }\n\n  /// Indicates whether it is possible for declarations of this kind\n  /// to have an out-of-date definition.\n  ///\n  /// This option is only enabled when modules are enabled.\n  void setMayHaveOutOfDateDef(bool V = true) {\n    TagDeclBits.MayHaveOutOfDateDef = V;\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  SourceRange getBraceRange() const { return BraceRange; }\n  void setBraceRange(SourceRange R) { BraceRange = R; }\n\n  /// Return SourceLocation representing start of source\n  /// range ignoring outer template declarations.\n  SourceLocation getInnerLocStart() const { return getBeginLoc(); }\n\n  /// Return SourceLocation representing start of source\n  /// range taking into account any outer template declarations.\n  SourceLocation getOuterLocStart() const;\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  TagDecl *getCanonicalDecl() override;\n  const TagDecl *getCanonicalDecl() const {\n    return const_cast<TagDecl*>(this)->getCanonicalDecl();\n  }\n\n  /// Return true if this declaration is a completion definition of the type.\n  /// Provided for consistency.\n  bool isThisDeclarationADefinition() const {\n    return isCompleteDefinition();\n  }\n\n  /// Return true if this decl has its body fully specified.\n  bool isCompleteDefinition() const { return TagDeclBits.IsCompleteDefinition; }\n\n  /// True if this decl has its body fully specified.\n  void setCompleteDefinition(bool V = true) {\n    TagDeclBits.IsCompleteDefinition = V;\n  }\n\n  /// Return true if this complete decl is\n  /// required to be complete for some existing use.\n  bool isCompleteDefinitionRequired() const {\n    return TagDeclBits.IsCompleteDefinitionRequired;\n  }\n\n  /// True if this complete decl is\n  /// required to be complete for some existing use.\n  void setCompleteDefinitionRequired(bool V = true) {\n    TagDeclBits.IsCompleteDefinitionRequired = V;\n  }\n\n  /// Return true if this decl is currently being defined.\n  bool isBeingDefined() const { return TagDeclBits.IsBeingDefined; }\n\n  /// True if this tag declaration is \"embedded\" (i.e., defined or declared\n  /// for the very first time) in the syntax of a declarator.\n  bool isEmbeddedInDeclarator() const {\n    return TagDeclBits.IsEmbeddedInDeclarator;\n  }\n\n  /// True if this tag declaration is \"embedded\" (i.e., defined or declared\n  /// for the very first time) in the syntax of a declarator.\n  void setEmbeddedInDeclarator(bool isInDeclarator) {\n    TagDeclBits.IsEmbeddedInDeclarator = isInDeclarator;\n  }\n\n  /// True if this tag is free standing, e.g. \"struct foo;\".\n  bool isFreeStanding() const { return TagDeclBits.IsFreeStanding; }\n\n  /// True if this tag is free standing, e.g. \"struct foo;\".\n  void setFreeStanding(bool isFreeStanding = true) {\n    TagDeclBits.IsFreeStanding = isFreeStanding;\n  }\n\n  /// Indicates whether it is possible for declarations of this kind\n  /// to have an out-of-date definition.\n  ///\n  /// This option is only enabled when modules are enabled.\n  bool mayHaveOutOfDateDef() const { return TagDeclBits.MayHaveOutOfDateDef; }\n\n  /// Whether this declaration declares a type that is\n  /// dependent, i.e., a type that somehow depends on template\n  /// parameters.\n  bool isDependentType() const { return isDependentContext(); }\n\n  /// Starts the definition of this tag declaration.\n  ///\n  /// This method should be invoked at the beginning of the definition\n  /// of this tag declaration. It will set the tag type into a state\n  /// where it is in the process of being defined.\n  void startDefinition();\n\n  /// Returns the TagDecl that actually defines this\n  ///  struct/union/class/enum.  When determining whether or not a\n  ///  struct/union/class/enum has a definition, one should use this\n  ///  method as opposed to 'isDefinition'.  'isDefinition' indicates\n  ///  whether or not a specific TagDecl is defining declaration, not\n  ///  whether or not the struct/union/class/enum type is defined.\n  ///  This method returns NULL if there is no TagDecl that defines\n  ///  the struct/union/class/enum.\n  TagDecl *getDefinition() const;\n\n  StringRef getKindName() const {\n    return TypeWithKeyword::getTagTypeKindName(getTagKind());\n  }\n\n  TagKind getTagKind() const {\n    return static_cast<TagKind>(TagDeclBits.TagDeclKind);\n  }\n\n  void setTagKind(TagKind TK) { TagDeclBits.TagDeclKind = TK; }\n\n  bool isStruct() const { return getTagKind() == TTK_Struct; }\n  bool isInterface() const { return getTagKind() == TTK_Interface; }\n  bool isClass()  const { return getTagKind() == TTK_Class; }\n  bool isUnion()  const { return getTagKind() == TTK_Union; }\n  bool isEnum()   const { return getTagKind() == TTK_Enum; }\n\n  /// Is this tag type named, either directly or via being defined in\n  /// a typedef of this type?\n  ///\n  /// C++11 [basic.link]p8:\n  ///   A type is said to have linkage if and only if:\n  ///     - it is a class or enumeration type that is named (or has a\n  ///       name for linkage purposes) and the name has linkage; ...\n  /// C++11 [dcl.typedef]p9:\n  ///   If the typedef declaration defines an unnamed class (or enum),\n  ///   the first typedef-name declared by the declaration to be that\n  ///   class type (or enum type) is used to denote the class type (or\n  ///   enum type) for linkage purposes only.\n  ///\n  /// C does not have an analogous rule, but the same concept is\n  /// nonetheless useful in some places.\n  bool hasNameForLinkage() const {\n    return (getDeclName() || getTypedefNameForAnonDecl());\n  }\n\n  TypedefNameDecl *getTypedefNameForAnonDecl() const {\n    return hasExtInfo() ? nullptr\n                        : TypedefNameDeclOrQualifier.get<TypedefNameDecl *>();\n  }\n\n  void setTypedefNameForAnonDecl(TypedefNameDecl *TDD);\n\n  /// Retrieve the nested-name-specifier that qualifies the name of this\n  /// declaration, if it was present in the source.\n  NestedNameSpecifier *getQualifier() const {\n    return hasExtInfo() ? getExtInfo()->QualifierLoc.getNestedNameSpecifier()\n                        : nullptr;\n  }\n\n  /// Retrieve the nested-name-specifier (with source-location\n  /// information) that qualifies the name of this declaration, if it was\n  /// present in the source.\n  NestedNameSpecifierLoc getQualifierLoc() const {\n    return hasExtInfo() ? getExtInfo()->QualifierLoc\n                        : NestedNameSpecifierLoc();\n  }\n\n  void setQualifierInfo(NestedNameSpecifierLoc QualifierLoc);\n\n  unsigned getNumTemplateParameterLists() const {\n    return hasExtInfo() ? getExtInfo()->NumTemplParamLists : 0;\n  }\n\n  TemplateParameterList *getTemplateParameterList(unsigned i) const {\n    assert(i < getNumTemplateParameterLists());\n    return getExtInfo()->TemplParamLists[i];\n  }\n\n  void setTemplateParameterListsInfo(ASTContext &Context,\n                                     ArrayRef<TemplateParameterList *> TPLists);\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K >= firstTag && K <= lastTag; }\n\n  static DeclContext *castToDeclContext(const TagDecl *D) {\n    return static_cast<DeclContext *>(const_cast<TagDecl*>(D));\n  }\n\n  static TagDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<TagDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Represents an enum.  In C++11, enums can be forward-declared\n/// with a fixed underlying type, and in C we allow them to be forward-declared\n/// with no underlying type as an extension.\nclass EnumDecl : public TagDecl {\n  // This class stores some data in DeclContext::EnumDeclBits\n  // to save some space. Use the provided accessors to access it.\n\n  /// This represent the integer type that the enum corresponds\n  /// to for code generation purposes.  Note that the enumerator constants may\n  /// have a different type than this does.\n  ///\n  /// If the underlying integer type was explicitly stated in the source\n  /// code, this is a TypeSourceInfo* for that type. Otherwise this type\n  /// was automatically deduced somehow, and this is a Type*.\n  ///\n  /// Normally if IsFixed(), this would contain a TypeSourceInfo*, but in\n  /// some cases it won't.\n  ///\n  /// The underlying type of an enumeration never has any qualifiers, so\n  /// we can get away with just storing a raw Type*, and thus save an\n  /// extra pointer when TypeSourceInfo is needed.\n  llvm::PointerUnion<const Type *, TypeSourceInfo *> IntegerType;\n\n  /// The integer type that values of this type should\n  /// promote to.  In C, enumerators are generally of an integer type\n  /// directly, but gcc-style large enumerators (and all enumerators\n  /// in C++) are of the enum type instead.\n  QualType PromotionType;\n\n  /// If this enumeration is an instantiation of a member enumeration\n  /// of a class template specialization, this is the member specialization\n  /// information.\n  MemberSpecializationInfo *SpecializationInfo = nullptr;\n\n  /// Store the ODRHash after first calculation.\n  /// The corresponding flag HasODRHash is in EnumDeclBits\n  /// and can be accessed with the provided accessors.\n  unsigned ODRHash;\n\n  EnumDecl(ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n           SourceLocation IdLoc, IdentifierInfo *Id, EnumDecl *PrevDecl,\n           bool Scoped, bool ScopedUsingClassTag, bool Fixed);\n\n  void anchor() override;\n\n  void setInstantiationOfMemberEnum(ASTContext &C, EnumDecl *ED,\n                                    TemplateSpecializationKind TSK);\n\n  /// Sets the width in bits required to store all the\n  /// non-negative enumerators of this enum.\n  void setNumPositiveBits(unsigned Num) {\n    EnumDeclBits.NumPositiveBits = Num;\n    assert(EnumDeclBits.NumPositiveBits == Num && \"can't store this bitcount\");\n  }\n\n  /// Returns the width in bits required to store all the\n  /// negative enumerators of this enum. (see getNumNegativeBits)\n  void setNumNegativeBits(unsigned Num) { EnumDeclBits.NumNegativeBits = Num; }\n\npublic:\n  /// True if this tag declaration is a scoped enumeration. Only\n  /// possible in C++11 mode.\n  void setScoped(bool Scoped = true) { EnumDeclBits.IsScoped = Scoped; }\n\n  /// If this tag declaration is a scoped enum,\n  /// then this is true if the scoped enum was declared using the class\n  /// tag, false if it was declared with the struct tag. No meaning is\n  /// associated if this tag declaration is not a scoped enum.\n  void setScopedUsingClassTag(bool ScopedUCT = true) {\n    EnumDeclBits.IsScopedUsingClassTag = ScopedUCT;\n  }\n\n  /// True if this is an Objective-C, C++11, or\n  /// Microsoft-style enumeration with a fixed underlying type.\n  void setFixed(bool Fixed = true) { EnumDeclBits.IsFixed = Fixed; }\n\nprivate:\n  /// True if a valid hash is stored in ODRHash.\n  bool hasODRHash() const { return EnumDeclBits.HasODRHash; }\n  void setHasODRHash(bool Hash = true) { EnumDeclBits.HasODRHash = Hash; }\n\npublic:\n  friend class ASTDeclReader;\n\n  EnumDecl *getCanonicalDecl() override {\n    return cast<EnumDecl>(TagDecl::getCanonicalDecl());\n  }\n  const EnumDecl *getCanonicalDecl() const {\n    return const_cast<EnumDecl*>(this)->getCanonicalDecl();\n  }\n\n  EnumDecl *getPreviousDecl() {\n    return cast_or_null<EnumDecl>(\n            static_cast<TagDecl *>(this)->getPreviousDecl());\n  }\n  const EnumDecl *getPreviousDecl() const {\n    return const_cast<EnumDecl*>(this)->getPreviousDecl();\n  }\n\n  EnumDecl *getMostRecentDecl() {\n    return cast<EnumDecl>(static_cast<TagDecl *>(this)->getMostRecentDecl());\n  }\n  const EnumDecl *getMostRecentDecl() const {\n    return const_cast<EnumDecl*>(this)->getMostRecentDecl();\n  }\n\n  EnumDecl *getDefinition() const {\n    return cast_or_null<EnumDecl>(TagDecl::getDefinition());\n  }\n\n  static EnumDecl *Create(ASTContext &C, DeclContext *DC,\n                          SourceLocation StartLoc, SourceLocation IdLoc,\n                          IdentifierInfo *Id, EnumDecl *PrevDecl,\n                          bool IsScoped, bool IsScopedUsingClassTag,\n                          bool IsFixed);\n  static EnumDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// When created, the EnumDecl corresponds to a\n  /// forward-declared enum. This method is used to mark the\n  /// declaration as being defined; its enumerators have already been\n  /// added (via DeclContext::addDecl). NewType is the new underlying\n  /// type of the enumeration type.\n  void completeDefinition(QualType NewType,\n                          QualType PromotionType,\n                          unsigned NumPositiveBits,\n                          unsigned NumNegativeBits);\n\n  // Iterates through the enumerators of this enumeration.\n  using enumerator_iterator = specific_decl_iterator<EnumConstantDecl>;\n  using enumerator_range =\n      llvm::iterator_range<specific_decl_iterator<EnumConstantDecl>>;\n\n  enumerator_range enumerators() const {\n    return enumerator_range(enumerator_begin(), enumerator_end());\n  }\n\n  enumerator_iterator enumerator_begin() const {\n    const EnumDecl *E = getDefinition();\n    if (!E)\n      E = this;\n    return enumerator_iterator(E->decls_begin());\n  }\n\n  enumerator_iterator enumerator_end() const {\n    const EnumDecl *E = getDefinition();\n    if (!E)\n      E = this;\n    return enumerator_iterator(E->decls_end());\n  }\n\n  /// Return the integer type that enumerators should promote to.\n  QualType getPromotionType() const { return PromotionType; }\n\n  /// Set the promotion type.\n  void setPromotionType(QualType T) { PromotionType = T; }\n\n  /// Return the integer type this enum decl corresponds to.\n  /// This returns a null QualType for an enum forward definition with no fixed\n  /// underlying type.\n  QualType getIntegerType() const {\n    if (!IntegerType)\n      return QualType();\n    if (const Type *T = IntegerType.dyn_cast<const Type*>())\n      return QualType(T, 0);\n    return IntegerType.get<TypeSourceInfo*>()->getType().getUnqualifiedType();\n  }\n\n  /// Set the underlying integer type.\n  void setIntegerType(QualType T) { IntegerType = T.getTypePtrOrNull(); }\n\n  /// Set the underlying integer type source info.\n  void setIntegerTypeSourceInfo(TypeSourceInfo *TInfo) { IntegerType = TInfo; }\n\n  /// Return the type source info for the underlying integer type,\n  /// if no type source info exists, return 0.\n  TypeSourceInfo *getIntegerTypeSourceInfo() const {\n    return IntegerType.dyn_cast<TypeSourceInfo*>();\n  }\n\n  /// Retrieve the source range that covers the underlying type if\n  /// specified.\n  SourceRange getIntegerTypeRange() const LLVM_READONLY;\n\n  /// Returns the width in bits required to store all the\n  /// non-negative enumerators of this enum.\n  unsigned getNumPositiveBits() const { return EnumDeclBits.NumPositiveBits; }\n\n  /// Returns the width in bits required to store all the\n  /// negative enumerators of this enum.  These widths include\n  /// the rightmost leading 1;  that is:\n  ///\n  /// MOST NEGATIVE ENUMERATOR     PATTERN     NUM NEGATIVE BITS\n  /// ------------------------     -------     -----------------\n  ///                       -1     1111111                     1\n  ///                      -10     1110110                     5\n  ///                     -101     1001011                     8\n  unsigned getNumNegativeBits() const { return EnumDeclBits.NumNegativeBits; }\n\n  /// Returns true if this is a C++11 scoped enumeration.\n  bool isScoped() const { return EnumDeclBits.IsScoped; }\n\n  /// Returns true if this is a C++11 scoped enumeration.\n  bool isScopedUsingClassTag() const {\n    return EnumDeclBits.IsScopedUsingClassTag;\n  }\n\n  /// Returns true if this is an Objective-C, C++11, or\n  /// Microsoft-style enumeration with a fixed underlying type.\n  bool isFixed() const { return EnumDeclBits.IsFixed; }\n\n  unsigned getODRHash();\n\n  /// Returns true if this can be considered a complete type.\n  bool isComplete() const {\n    // IntegerType is set for fixed type enums and non-fixed but implicitly\n    // int-sized Microsoft enums.\n    return isCompleteDefinition() || IntegerType;\n  }\n\n  /// Returns true if this enum is either annotated with\n  /// enum_extensibility(closed) or isn't annotated with enum_extensibility.\n  bool isClosed() const;\n\n  /// Returns true if this enum is annotated with flag_enum and isn't annotated\n  /// with enum_extensibility(open).\n  bool isClosedFlag() const;\n\n  /// Returns true if this enum is annotated with neither flag_enum nor\n  /// enum_extensibility(open).\n  bool isClosedNonFlag() const;\n\n  /// Retrieve the enum definition from which this enumeration could\n  /// be instantiated, if it is an instantiation (rather than a non-template).\n  EnumDecl *getTemplateInstantiationPattern() const;\n\n  /// Returns the enumeration (declared within the template)\n  /// from which this enumeration type was instantiated, or NULL if\n  /// this enumeration was not instantiated from any template.\n  EnumDecl *getInstantiatedFromMemberEnum() const;\n\n  /// If this enumeration is a member of a specialization of a\n  /// templated class, determine what kind of template specialization\n  /// or instantiation this is.\n  TemplateSpecializationKind getTemplateSpecializationKind() const;\n\n  /// For an enumeration member that was instantiated from a member\n  /// enumeration of a templated class, set the template specialiation kind.\n  void setTemplateSpecializationKind(TemplateSpecializationKind TSK,\n                        SourceLocation PointOfInstantiation = SourceLocation());\n\n  /// If this enumeration is an instantiation of a member enumeration of\n  /// a class template specialization, retrieves the member specialization\n  /// information.\n  MemberSpecializationInfo *getMemberSpecializationInfo() const {\n    return SpecializationInfo;\n  }\n\n  /// Specify that this enumeration is an instantiation of the\n  /// member enumeration ED.\n  void setInstantiationOfMemberEnum(EnumDecl *ED,\n                                    TemplateSpecializationKind TSK) {\n    setInstantiationOfMemberEnum(getASTContext(), ED, TSK);\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Enum; }\n};\n\n/// Represents a struct/union/class.  For example:\n///   struct X;                  // Forward declaration, no \"body\".\n///   union Y { int A, B; };     // Has body with members A and B (FieldDecls).\n/// This decl will be marked invalid if *any* members are invalid.\nclass RecordDecl : public TagDecl {\n  // This class stores some data in DeclContext::RecordDeclBits\n  // to save some space. Use the provided accessors to access it.\npublic:\n  friend class DeclContext;\n  /// Enum that represents the different ways arguments are passed to and\n  /// returned from function calls. This takes into account the target-specific\n  /// and version-specific rules along with the rules determined by the\n  /// language.\n  enum ArgPassingKind : unsigned {\n    /// The argument of this type can be passed directly in registers.\n    APK_CanPassInRegs,\n\n    /// The argument of this type cannot be passed directly in registers.\n    /// Records containing this type as a subobject are not forced to be passed\n    /// indirectly. This value is used only in C++. This value is required by\n    /// C++ because, in uncommon situations, it is possible for a class to have\n    /// only trivial copy/move constructors even when one of its subobjects has\n    /// a non-trivial copy/move constructor (if e.g. the corresponding copy/move\n    /// constructor in the derived class is deleted).\n    APK_CannotPassInRegs,\n\n    /// The argument of this type cannot be passed directly in registers.\n    /// Records containing this type as a subobject are forced to be passed\n    /// indirectly.\n    APK_CanNeverPassInRegs\n  };\n\nprotected:\n  RecordDecl(Kind DK, TagKind TK, const ASTContext &C, DeclContext *DC,\n             SourceLocation StartLoc, SourceLocation IdLoc,\n             IdentifierInfo *Id, RecordDecl *PrevDecl);\n\npublic:\n  static RecordDecl *Create(const ASTContext &C, TagKind TK, DeclContext *DC,\n                            SourceLocation StartLoc, SourceLocation IdLoc,\n                            IdentifierInfo *Id, RecordDecl* PrevDecl = nullptr);\n  static RecordDecl *CreateDeserialized(const ASTContext &C, unsigned ID);\n\n  RecordDecl *getPreviousDecl() {\n    return cast_or_null<RecordDecl>(\n            static_cast<TagDecl *>(this)->getPreviousDecl());\n  }\n  const RecordDecl *getPreviousDecl() const {\n    return const_cast<RecordDecl*>(this)->getPreviousDecl();\n  }\n\n  RecordDecl *getMostRecentDecl() {\n    return cast<RecordDecl>(static_cast<TagDecl *>(this)->getMostRecentDecl());\n  }\n  const RecordDecl *getMostRecentDecl() const {\n    return const_cast<RecordDecl*>(this)->getMostRecentDecl();\n  }\n\n  bool hasFlexibleArrayMember() const {\n    return RecordDeclBits.HasFlexibleArrayMember;\n  }\n\n  void setHasFlexibleArrayMember(bool V) {\n    RecordDeclBits.HasFlexibleArrayMember = V;\n  }\n\n  /// Whether this is an anonymous struct or union. To be an anonymous\n  /// struct or union, it must have been declared without a name and\n  /// there must be no objects of this type declared, e.g.,\n  /// @code\n  ///   union { int i; float f; };\n  /// @endcode\n  /// is an anonymous union but neither of the following are:\n  /// @code\n  ///  union X { int i; float f; };\n  ///  union { int i; float f; } obj;\n  /// @endcode\n  bool isAnonymousStructOrUnion() const {\n    return RecordDeclBits.AnonymousStructOrUnion;\n  }\n\n  void setAnonymousStructOrUnion(bool Anon) {\n    RecordDeclBits.AnonymousStructOrUnion = Anon;\n  }\n\n  bool hasObjectMember() const { return RecordDeclBits.HasObjectMember; }\n  void setHasObjectMember(bool val) { RecordDeclBits.HasObjectMember = val; }\n\n  bool hasVolatileMember() const { return RecordDeclBits.HasVolatileMember; }\n\n  void setHasVolatileMember(bool val) {\n    RecordDeclBits.HasVolatileMember = val;\n  }\n\n  bool hasLoadedFieldsFromExternalStorage() const {\n    return RecordDeclBits.LoadedFieldsFromExternalStorage;\n  }\n\n  void setHasLoadedFieldsFromExternalStorage(bool val) const {\n    RecordDeclBits.LoadedFieldsFromExternalStorage = val;\n  }\n\n  /// Functions to query basic properties of non-trivial C structs.\n  bool isNonTrivialToPrimitiveDefaultInitialize() const {\n    return RecordDeclBits.NonTrivialToPrimitiveDefaultInitialize;\n  }\n\n  void setNonTrivialToPrimitiveDefaultInitialize(bool V) {\n    RecordDeclBits.NonTrivialToPrimitiveDefaultInitialize = V;\n  }\n\n  bool isNonTrivialToPrimitiveCopy() const {\n    return RecordDeclBits.NonTrivialToPrimitiveCopy;\n  }\n\n  void setNonTrivialToPrimitiveCopy(bool V) {\n    RecordDeclBits.NonTrivialToPrimitiveCopy = V;\n  }\n\n  bool isNonTrivialToPrimitiveDestroy() const {\n    return RecordDeclBits.NonTrivialToPrimitiveDestroy;\n  }\n\n  void setNonTrivialToPrimitiveDestroy(bool V) {\n    RecordDeclBits.NonTrivialToPrimitiveDestroy = V;\n  }\n\n  bool hasNonTrivialToPrimitiveDefaultInitializeCUnion() const {\n    return RecordDeclBits.HasNonTrivialToPrimitiveDefaultInitializeCUnion;\n  }\n\n  void setHasNonTrivialToPrimitiveDefaultInitializeCUnion(bool V) {\n    RecordDeclBits.HasNonTrivialToPrimitiveDefaultInitializeCUnion = V;\n  }\n\n  bool hasNonTrivialToPrimitiveDestructCUnion() const {\n    return RecordDeclBits.HasNonTrivialToPrimitiveDestructCUnion;\n  }\n\n  void setHasNonTrivialToPrimitiveDestructCUnion(bool V) {\n    RecordDeclBits.HasNonTrivialToPrimitiveDestructCUnion = V;\n  }\n\n  bool hasNonTrivialToPrimitiveCopyCUnion() const {\n    return RecordDeclBits.HasNonTrivialToPrimitiveCopyCUnion;\n  }\n\n  void setHasNonTrivialToPrimitiveCopyCUnion(bool V) {\n    RecordDeclBits.HasNonTrivialToPrimitiveCopyCUnion = V;\n  }\n\n  /// Determine whether this class can be passed in registers. In C++ mode,\n  /// it must have at least one trivial, non-deleted copy or move constructor.\n  /// FIXME: This should be set as part of completeDefinition.\n  bool canPassInRegisters() const {\n    return getArgPassingRestrictions() == APK_CanPassInRegs;\n  }\n\n  ArgPassingKind getArgPassingRestrictions() const {\n    return static_cast<ArgPassingKind>(RecordDeclBits.ArgPassingRestrictions);\n  }\n\n  void setArgPassingRestrictions(ArgPassingKind Kind) {\n    RecordDeclBits.ArgPassingRestrictions = Kind;\n  }\n\n  bool isParamDestroyedInCallee() const {\n    return RecordDeclBits.ParamDestroyedInCallee;\n  }\n\n  void setParamDestroyedInCallee(bool V) {\n    RecordDeclBits.ParamDestroyedInCallee = V;\n  }\n\n  /// Determines whether this declaration represents the\n  /// injected class name.\n  ///\n  /// The injected class name in C++ is the name of the class that\n  /// appears inside the class itself. For example:\n  ///\n  /// \\code\n  /// struct C {\n  ///   // C is implicitly declared here as a synonym for the class name.\n  /// };\n  ///\n  /// C::C c; // same as \"C c;\"\n  /// \\endcode\n  bool isInjectedClassName() const;\n\n  /// Determine whether this record is a class describing a lambda\n  /// function object.\n  bool isLambda() const;\n\n  /// Determine whether this record is a record for captured variables in\n  /// CapturedStmt construct.\n  bool isCapturedRecord() const;\n\n  /// Mark the record as a record for captured variables in CapturedStmt\n  /// construct.\n  void setCapturedRecord();\n\n  /// Returns the RecordDecl that actually defines\n  ///  this struct/union/class.  When determining whether or not a\n  ///  struct/union/class is completely defined, one should use this\n  ///  method as opposed to 'isCompleteDefinition'.\n  ///  'isCompleteDefinition' indicates whether or not a specific\n  ///  RecordDecl is a completed definition, not whether or not the\n  ///  record type is defined.  This method returns NULL if there is\n  ///  no RecordDecl that defines the struct/union/tag.\n  RecordDecl *getDefinition() const {\n    return cast_or_null<RecordDecl>(TagDecl::getDefinition());\n  }\n\n  /// Returns whether this record is a union, or contains (at any nesting level)\n  /// a union member. This is used by CMSE to warn about possible information\n  /// leaks.\n  bool isOrContainsUnion() const;\n\n  // Iterator access to field members. The field iterator only visits\n  // the non-static data members of this class, ignoring any static\n  // data members, functions, constructors, destructors, etc.\n  using field_iterator = specific_decl_iterator<FieldDecl>;\n  using field_range = llvm::iterator_range<specific_decl_iterator<FieldDecl>>;\n\n  field_range fields() const { return field_range(field_begin(), field_end()); }\n  field_iterator field_begin() const;\n\n  field_iterator field_end() const {\n    return field_iterator(decl_iterator());\n  }\n\n  // Whether there are any fields (non-static data members) in this record.\n  bool field_empty() const {\n    return field_begin() == field_end();\n  }\n\n  /// Note that the definition of this type is now complete.\n  virtual void completeDefinition();\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K >= firstRecord && K <= lastRecord;\n  }\n\n  /// Get whether or not this is an ms_struct which can\n  /// be turned on with an attribute, pragma, or -mms-bitfields\n  /// commandline option.\n  bool isMsStruct(const ASTContext &C) const;\n\n  /// Whether we are allowed to insert extra padding between fields.\n  /// These padding are added to help AddressSanitizer detect\n  /// intra-object-overflow bugs.\n  bool mayInsertExtraPadding(bool EmitRemark = false) const;\n\n  /// Finds the first data member which has a name.\n  /// nullptr is returned if no named data member exists.\n  const FieldDecl *findFirstNamedDataMember() const;\n\nprivate:\n  /// Deserialize just the fields.\n  void LoadFieldsFromExternalStorage() const;\n};\n\nclass FileScopeAsmDecl : public Decl {\n  StringLiteral *AsmString;\n  SourceLocation RParenLoc;\n\n  FileScopeAsmDecl(DeclContext *DC, StringLiteral *asmstring,\n                   SourceLocation StartL, SourceLocation EndL)\n    : Decl(FileScopeAsm, DC, StartL), AsmString(asmstring), RParenLoc(EndL) {}\n\n  virtual void anchor();\n\npublic:\n  static FileScopeAsmDecl *Create(ASTContext &C, DeclContext *DC,\n                                  StringLiteral *Str, SourceLocation AsmLoc,\n                                  SourceLocation RParenLoc);\n\n  static FileScopeAsmDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceLocation getAsmLoc() const { return getLocation(); }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(getAsmLoc(), getRParenLoc());\n  }\n\n  const StringLiteral *getAsmString() const { return AsmString; }\n  StringLiteral *getAsmString() { return AsmString; }\n  void setAsmString(StringLiteral *Asm) { AsmString = Asm; }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == FileScopeAsm; }\n};\n\n/// Represents a block literal declaration, which is like an\n/// unnamed FunctionDecl.  For example:\n/// ^{ statement-body }   or   ^(int arg1, float arg2){ statement-body }\nclass BlockDecl : public Decl, public DeclContext {\n  // This class stores some data in DeclContext::BlockDeclBits\n  // to save some space. Use the provided accessors to access it.\npublic:\n  /// A class which contains all the information about a particular\n  /// captured value.\n  class Capture {\n    enum {\n      flag_isByRef = 0x1,\n      flag_isNested = 0x2\n    };\n\n    /// The variable being captured.\n    llvm::PointerIntPair<VarDecl*, 2> VariableAndFlags;\n\n    /// The copy expression, expressed in terms of a DeclRef (or\n    /// BlockDeclRef) to the captured variable.  Only required if the\n    /// variable has a C++ class type.\n    Expr *CopyExpr;\n\n  public:\n    Capture(VarDecl *variable, bool byRef, bool nested, Expr *copy)\n      : VariableAndFlags(variable,\n                  (byRef ? flag_isByRef : 0) | (nested ? flag_isNested : 0)),\n        CopyExpr(copy) {}\n\n    /// The variable being captured.\n    VarDecl *getVariable() const { return VariableAndFlags.getPointer(); }\n\n    /// Whether this is a \"by ref\" capture, i.e. a capture of a __block\n    /// variable.\n    bool isByRef() const { return VariableAndFlags.getInt() & flag_isByRef; }\n\n    bool isEscapingByref() const {\n      return getVariable()->isEscapingByref();\n    }\n\n    bool isNonEscapingByref() const {\n      return getVariable()->isNonEscapingByref();\n    }\n\n    /// Whether this is a nested capture, i.e. the variable captured\n    /// is not from outside the immediately enclosing function/block.\n    bool isNested() const { return VariableAndFlags.getInt() & flag_isNested; }\n\n    bool hasCopyExpr() const { return CopyExpr != nullptr; }\n    Expr *getCopyExpr() const { return CopyExpr; }\n    void setCopyExpr(Expr *e) { CopyExpr = e; }\n  };\n\nprivate:\n  /// A new[]'d array of pointers to ParmVarDecls for the formal\n  /// parameters of this function.  This is null if a prototype or if there are\n  /// no formals.\n  ParmVarDecl **ParamInfo = nullptr;\n  unsigned NumParams = 0;\n\n  Stmt *Body = nullptr;\n  TypeSourceInfo *SignatureAsWritten = nullptr;\n\n  const Capture *Captures = nullptr;\n  unsigned NumCaptures = 0;\n\n  unsigned ManglingNumber = 0;\n  Decl *ManglingContextDecl = nullptr;\n\nprotected:\n  BlockDecl(DeclContext *DC, SourceLocation CaretLoc);\n\npublic:\n  static BlockDecl *Create(ASTContext &C, DeclContext *DC, SourceLocation L);\n  static BlockDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceLocation getCaretLocation() const { return getLocation(); }\n\n  bool isVariadic() const { return BlockDeclBits.IsVariadic; }\n  void setIsVariadic(bool value) { BlockDeclBits.IsVariadic = value; }\n\n  CompoundStmt *getCompoundBody() const { return (CompoundStmt*) Body; }\n  Stmt *getBody() const override { return (Stmt*) Body; }\n  void setBody(CompoundStmt *B) { Body = (Stmt*) B; }\n\n  void setSignatureAsWritten(TypeSourceInfo *Sig) { SignatureAsWritten = Sig; }\n  TypeSourceInfo *getSignatureAsWritten() const { return SignatureAsWritten; }\n\n  // ArrayRef access to formal parameters.\n  ArrayRef<ParmVarDecl *> parameters() const {\n    return {ParamInfo, getNumParams()};\n  }\n  MutableArrayRef<ParmVarDecl *> parameters() {\n    return {ParamInfo, getNumParams()};\n  }\n\n  // Iterator access to formal parameters.\n  using param_iterator = MutableArrayRef<ParmVarDecl *>::iterator;\n  using param_const_iterator = ArrayRef<ParmVarDecl *>::const_iterator;\n\n  bool param_empty() const { return parameters().empty(); }\n  param_iterator param_begin() { return parameters().begin(); }\n  param_iterator param_end() { return parameters().end(); }\n  param_const_iterator param_begin() const { return parameters().begin(); }\n  param_const_iterator param_end() const { return parameters().end(); }\n  size_t param_size() const { return parameters().size(); }\n\n  unsigned getNumParams() const { return NumParams; }\n\n  const ParmVarDecl *getParamDecl(unsigned i) const {\n    assert(i < getNumParams() && \"Illegal param #\");\n    return ParamInfo[i];\n  }\n  ParmVarDecl *getParamDecl(unsigned i) {\n    assert(i < getNumParams() && \"Illegal param #\");\n    return ParamInfo[i];\n  }\n\n  void setParams(ArrayRef<ParmVarDecl *> NewParamInfo);\n\n  /// True if this block (or its nested blocks) captures\n  /// anything of local storage from its enclosing scopes.\n  bool hasCaptures() const { return NumCaptures || capturesCXXThis(); }\n\n  /// Returns the number of captured variables.\n  /// Does not include an entry for 'this'.\n  unsigned getNumCaptures() const { return NumCaptures; }\n\n  using capture_const_iterator = ArrayRef<Capture>::const_iterator;\n\n  ArrayRef<Capture> captures() const { return {Captures, NumCaptures}; }\n\n  capture_const_iterator capture_begin() const { return captures().begin(); }\n  capture_const_iterator capture_end() const { return captures().end(); }\n\n  bool capturesCXXThis() const { return BlockDeclBits.CapturesCXXThis; }\n  void setCapturesCXXThis(bool B = true) { BlockDeclBits.CapturesCXXThis = B; }\n\n  bool blockMissingReturnType() const {\n    return BlockDeclBits.BlockMissingReturnType;\n  }\n\n  void setBlockMissingReturnType(bool val = true) {\n    BlockDeclBits.BlockMissingReturnType = val;\n  }\n\n  bool isConversionFromLambda() const {\n    return BlockDeclBits.IsConversionFromLambda;\n  }\n\n  void setIsConversionFromLambda(bool val = true) {\n    BlockDeclBits.IsConversionFromLambda = val;\n  }\n\n  bool doesNotEscape() const { return BlockDeclBits.DoesNotEscape; }\n  void setDoesNotEscape(bool B = true) { BlockDeclBits.DoesNotEscape = B; }\n\n  bool canAvoidCopyToHeap() const {\n    return BlockDeclBits.CanAvoidCopyToHeap;\n  }\n  void setCanAvoidCopyToHeap(bool B = true) {\n    BlockDeclBits.CanAvoidCopyToHeap = B;\n  }\n\n  bool capturesVariable(const VarDecl *var) const;\n\n  void setCaptures(ASTContext &Context, ArrayRef<Capture> Captures,\n                   bool CapturesCXXThis);\n\n  unsigned getBlockManglingNumber() const { return ManglingNumber; }\n\n  Decl *getBlockManglingContextDecl() const { return ManglingContextDecl; }\n\n  void setBlockMangling(unsigned Number, Decl *Ctx) {\n    ManglingNumber = Number;\n    ManglingContextDecl = Ctx;\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Block; }\n  static DeclContext *castToDeclContext(const BlockDecl *D) {\n    return static_cast<DeclContext *>(const_cast<BlockDecl*>(D));\n  }\n  static BlockDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<BlockDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Represents the body of a CapturedStmt, and serves as its DeclContext.\nclass CapturedDecl final\n    : public Decl,\n      public DeclContext,\n      private llvm::TrailingObjects<CapturedDecl, ImplicitParamDecl *> {\nprotected:\n  size_t numTrailingObjects(OverloadToken<ImplicitParamDecl>) {\n    return NumParams;\n  }\n\nprivate:\n  /// The number of parameters to the outlined function.\n  unsigned NumParams;\n\n  /// The position of context parameter in list of parameters.\n  unsigned ContextParam;\n\n  /// The body of the outlined function.\n  llvm::PointerIntPair<Stmt *, 1, bool> BodyAndNothrow;\n\n  explicit CapturedDecl(DeclContext *DC, unsigned NumParams);\n\n  ImplicitParamDecl *const *getParams() const {\n    return getTrailingObjects<ImplicitParamDecl *>();\n  }\n\n  ImplicitParamDecl **getParams() {\n    return getTrailingObjects<ImplicitParamDecl *>();\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend TrailingObjects;\n\n  static CapturedDecl *Create(ASTContext &C, DeclContext *DC,\n                              unsigned NumParams);\n  static CapturedDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                          unsigned NumParams);\n\n  Stmt *getBody() const override;\n  void setBody(Stmt *B);\n\n  bool isNothrow() const;\n  void setNothrow(bool Nothrow = true);\n\n  unsigned getNumParams() const { return NumParams; }\n\n  ImplicitParamDecl *getParam(unsigned i) const {\n    assert(i < NumParams);\n    return getParams()[i];\n  }\n  void setParam(unsigned i, ImplicitParamDecl *P) {\n    assert(i < NumParams);\n    getParams()[i] = P;\n  }\n\n  // ArrayRef interface to parameters.\n  ArrayRef<ImplicitParamDecl *> parameters() const {\n    return {getParams(), getNumParams()};\n  }\n  MutableArrayRef<ImplicitParamDecl *> parameters() {\n    return {getParams(), getNumParams()};\n  }\n\n  /// Retrieve the parameter containing captured variables.\n  ImplicitParamDecl *getContextParam() const {\n    assert(ContextParam < NumParams);\n    return getParam(ContextParam);\n  }\n  void setContextParam(unsigned i, ImplicitParamDecl *P) {\n    assert(i < NumParams);\n    ContextParam = i;\n    setParam(i, P);\n  }\n  unsigned getContextParamPosition() const { return ContextParam; }\n\n  using param_iterator = ImplicitParamDecl *const *;\n  using param_range = llvm::iterator_range<param_iterator>;\n\n  /// Retrieve an iterator pointing to the first parameter decl.\n  param_iterator param_begin() const { return getParams(); }\n  /// Retrieve an iterator one past the last parameter decl.\n  param_iterator param_end() const { return getParams() + NumParams; }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Captured; }\n  static DeclContext *castToDeclContext(const CapturedDecl *D) {\n    return static_cast<DeclContext *>(const_cast<CapturedDecl *>(D));\n  }\n  static CapturedDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<CapturedDecl *>(const_cast<DeclContext *>(DC));\n  }\n};\n\n/// Describes a module import declaration, which makes the contents\n/// of the named module visible in the current translation unit.\n///\n/// An import declaration imports the named module (or submodule). For example:\n/// \\code\n///   @import std.vector;\n/// \\endcode\n///\n/// Import declarations can also be implicitly generated from\n/// \\#include/\\#import directives.\nclass ImportDecl final : public Decl,\n                         llvm::TrailingObjects<ImportDecl, SourceLocation> {\n  friend class ASTContext;\n  friend class ASTDeclReader;\n  friend class ASTReader;\n  friend TrailingObjects;\n\n  /// The imported module.\n  Module *ImportedModule = nullptr;\n\n  /// The next import in the list of imports local to the translation\n  /// unit being parsed (not loaded from an AST file).\n  ///\n  /// Includes a bit that indicates whether we have source-location information\n  /// for each identifier in the module name.\n  ///\n  /// When the bit is false, we only have a single source location for the\n  /// end of the import declaration.\n  llvm::PointerIntPair<ImportDecl *, 1, bool> NextLocalImportAndComplete;\n\n  ImportDecl(DeclContext *DC, SourceLocation StartLoc, Module *Imported,\n             ArrayRef<SourceLocation> IdentifierLocs);\n\n  ImportDecl(DeclContext *DC, SourceLocation StartLoc, Module *Imported,\n             SourceLocation EndLoc);\n\n  ImportDecl(EmptyShell Empty) : Decl(Import, Empty) {}\n\n  bool isImportComplete() const { return NextLocalImportAndComplete.getInt(); }\n\n  void setImportComplete(bool C) { NextLocalImportAndComplete.setInt(C); }\n\n  /// The next import in the list of imports local to the translation\n  /// unit being parsed (not loaded from an AST file).\n  ImportDecl *getNextLocalImport() const {\n    return NextLocalImportAndComplete.getPointer();\n  }\n\n  void setNextLocalImport(ImportDecl *Import) {\n    NextLocalImportAndComplete.setPointer(Import);\n  }\n\npublic:\n  /// Create a new module import declaration.\n  static ImportDecl *Create(ASTContext &C, DeclContext *DC,\n                            SourceLocation StartLoc, Module *Imported,\n                            ArrayRef<SourceLocation> IdentifierLocs);\n\n  /// Create a new module import declaration for an implicitly-generated\n  /// import.\n  static ImportDecl *CreateImplicit(ASTContext &C, DeclContext *DC,\n                                    SourceLocation StartLoc, Module *Imported,\n                                    SourceLocation EndLoc);\n\n  /// Create a new, deserialized module import declaration.\n  static ImportDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                        unsigned NumLocations);\n\n  /// Retrieve the module that was imported by the import declaration.\n  Module *getImportedModule() const { return ImportedModule; }\n\n  /// Retrieves the locations of each of the identifiers that make up\n  /// the complete module name in the import declaration.\n  ///\n  /// This will return an empty array if the locations of the individual\n  /// identifiers aren't available.\n  ArrayRef<SourceLocation> getIdentifierLocs() const;\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Import; }\n};\n\n/// Represents a C++ Modules TS module export declaration.\n///\n/// For example:\n/// \\code\n///   export void foo();\n/// \\endcode\nclass ExportDecl final : public Decl, public DeclContext {\n  virtual void anchor();\n\nprivate:\n  friend class ASTDeclReader;\n\n  /// The source location for the right brace (if valid).\n  SourceLocation RBraceLoc;\n\n  ExportDecl(DeclContext *DC, SourceLocation ExportLoc)\n      : Decl(Export, DC, ExportLoc), DeclContext(Export),\n        RBraceLoc(SourceLocation()) {}\n\npublic:\n  static ExportDecl *Create(ASTContext &C, DeclContext *DC,\n                            SourceLocation ExportLoc);\n  static ExportDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceLocation getExportLoc() const { return getLocation(); }\n  SourceLocation getRBraceLoc() const { return RBraceLoc; }\n  void setRBraceLoc(SourceLocation L) { RBraceLoc = L; }\n\n  bool hasBraces() const { return RBraceLoc.isValid(); }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    if (hasBraces())\n      return RBraceLoc;\n    // No braces: get the end location of the (only) declaration in context\n    // (if present).\n    return decls_empty() ? getLocation() : decls_begin()->getEndLoc();\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(getLocation(), getEndLoc());\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Export; }\n  static DeclContext *castToDeclContext(const ExportDecl *D) {\n    return static_cast<DeclContext *>(const_cast<ExportDecl*>(D));\n  }\n  static ExportDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<ExportDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Represents an empty-declaration.\nclass EmptyDecl : public Decl {\n  EmptyDecl(DeclContext *DC, SourceLocation L) : Decl(Empty, DC, L) {}\n\n  virtual void anchor();\n\npublic:\n  static EmptyDecl *Create(ASTContext &C, DeclContext *DC,\n                           SourceLocation L);\n  static EmptyDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Empty; }\n};\n\n/// Insertion operator for diagnostics.  This allows sending NamedDecl's\n/// into a diagnostic with <<.\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &PD,\n                                             const NamedDecl *ND) {\n  PD.AddTaggedVal(reinterpret_cast<intptr_t>(ND),\n                  DiagnosticsEngine::ak_nameddecl);\n  return PD;\n}\n\ntemplate<typename decl_type>\nvoid Redeclarable<decl_type>::setPreviousDecl(decl_type *PrevDecl) {\n  // Note: This routine is implemented here because we need both NamedDecl\n  // and Redeclarable to be defined.\n  assert(RedeclLink.isFirst() &&\n         \"setPreviousDecl on a decl already in a redeclaration chain\");\n\n  if (PrevDecl) {\n    // Point to previous. Make sure that this is actually the most recent\n    // redeclaration, or we can build invalid chains. If the most recent\n    // redeclaration is invalid, it won't be PrevDecl, but we want it anyway.\n    First = PrevDecl->getFirstDecl();\n    assert(First->RedeclLink.isFirst() && \"Expected first\");\n    decl_type *MostRecent = First->getNextRedeclaration();\n    RedeclLink = PreviousDeclLink(cast<decl_type>(MostRecent));\n\n    // If the declaration was previously visible, a redeclaration of it remains\n    // visible even if it wouldn't be visible by itself.\n    static_cast<decl_type*>(this)->IdentifierNamespace |=\n      MostRecent->getIdentifierNamespace() &\n      (Decl::IDNS_Ordinary | Decl::IDNS_Tag | Decl::IDNS_Type);\n  } else {\n    // Make this first.\n    First = static_cast<decl_type*>(this);\n  }\n\n  // First one will point to this one as latest.\n  First->RedeclLink.setLatest(static_cast<decl_type*>(this));\n\n  assert(!isa<NamedDecl>(static_cast<decl_type*>(this)) ||\n         cast<NamedDecl>(static_cast<decl_type*>(this))->isLinkageValid());\n}\n\n// Inline function definitions.\n\n/// Check if the given decl is complete.\n///\n/// We use this function to break a cycle between the inline definitions in\n/// Type.h and Decl.h.\ninline bool IsEnumDeclComplete(EnumDecl *ED) {\n  return ED->isComplete();\n}\n\n/// Check if the given decl is scoped.\n///\n/// We use this function to break a cycle between the inline definitions in\n/// Type.h and Decl.h.\ninline bool IsEnumDeclScoped(EnumDecl *ED) {\n  return ED->isScoped();\n}\n\n/// OpenMP variants are mangled early based on their OpenMP context selector.\n/// The new name looks likes this:\n///  <name> + OpenMPVariantManglingSeparatorStr + <mangled OpenMP context>\nstatic constexpr StringRef getOpenMPVariantManglingSeparatorStr() {\n  return \"$ompvariant\";\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_DECL_H\n"}, "7": {"id": 7, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclBase.h", "content": "//===- DeclBase.h - Base Classes for representing declarations --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the Decl and DeclContext interfaces.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_DECLBASE_H\n#define LLVM_CLANG_AST_DECLBASE_H\n\n#include \"clang/AST/ASTDumperUtils.h\"\n#include \"clang/AST/AttrIterator.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/PrettyStackTrace.h\"\n#include \"llvm/Support/VersionTuple.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <string>\n#include <type_traits>\n#include <utility>\n\nnamespace clang {\n\nclass ASTContext;\nclass ASTMutationListener;\nclass Attr;\nclass BlockDecl;\nclass DeclContext;\nclass ExternalSourceSymbolAttr;\nclass FunctionDecl;\nclass FunctionType;\nclass IdentifierInfo;\nenum Linkage : unsigned char;\nclass LinkageSpecDecl;\nclass Module;\nclass NamedDecl;\nclass ObjCCategoryDecl;\nclass ObjCCategoryImplDecl;\nclass ObjCContainerDecl;\nclass ObjCImplDecl;\nclass ObjCImplementationDecl;\nclass ObjCInterfaceDecl;\nclass ObjCMethodDecl;\nclass ObjCProtocolDecl;\nstruct PrintingPolicy;\nclass RecordDecl;\nclass SourceManager;\nclass Stmt;\nclass StoredDeclsMap;\nclass TemplateDecl;\nclass TemplateParameterList;\nclass TranslationUnitDecl;\nclass UsingDirectiveDecl;\n\n/// Captures the result of checking the availability of a\n/// declaration.\nenum AvailabilityResult {\n  AR_Available = 0,\n  AR_NotYetIntroduced,\n  AR_Deprecated,\n  AR_Unavailable\n};\n\n/// Decl - This represents one declaration (or definition), e.g. a variable,\n/// typedef, function, struct, etc.\n///\n/// Note: There are objects tacked on before the *beginning* of Decl\n/// (and its subclasses) in its Decl::operator new(). Proper alignment\n/// of all subclasses (not requiring more than the alignment of Decl) is\n/// asserted in DeclBase.cpp.\nclass alignas(8) Decl {\npublic:\n  /// Lists the kind of concrete classes of Decl.\n  enum Kind {\n#define DECL(DERIVED, BASE) DERIVED,\n#define ABSTRACT_DECL(DECL)\n#define DECL_RANGE(BASE, START, END) \\\n        first##BASE = START, last##BASE = END,\n#define LAST_DECL_RANGE(BASE, START, END) \\\n        first##BASE = START, last##BASE = END\n#include \"clang/AST/DeclNodes.inc\"\n  };\n\n  /// A placeholder type used to construct an empty shell of a\n  /// decl-derived type that will be filled in later (e.g., by some\n  /// deserialization method).\n  struct EmptyShell {};\n\n  /// IdentifierNamespace - The different namespaces in which\n  /// declarations may appear.  According to C99 6.2.3, there are\n  /// four namespaces, labels, tags, members and ordinary\n  /// identifiers.  C++ describes lookup completely differently:\n  /// certain lookups merely \"ignore\" certain kinds of declarations,\n  /// usually based on whether the declaration is of a type, etc.\n  ///\n  /// These are meant as bitmasks, so that searches in\n  /// C++ can look into the \"tag\" namespace during ordinary lookup.\n  ///\n  /// Decl currently provides 15 bits of IDNS bits.\n  enum IdentifierNamespace {\n    /// Labels, declared with 'x:' and referenced with 'goto x'.\n    IDNS_Label               = 0x0001,\n\n    /// Tags, declared with 'struct foo;' and referenced with\n    /// 'struct foo'.  All tags are also types.  This is what\n    /// elaborated-type-specifiers look for in C.\n    /// This also contains names that conflict with tags in the\n    /// same scope but that are otherwise ordinary names (non-type\n    /// template parameters and indirect field declarations).\n    IDNS_Tag                 = 0x0002,\n\n    /// Types, declared with 'struct foo', typedefs, etc.\n    /// This is what elaborated-type-specifiers look for in C++,\n    /// but note that it's ill-formed to find a non-tag.\n    IDNS_Type                = 0x0004,\n\n    /// Members, declared with object declarations within tag\n    /// definitions.  In C, these can only be found by \"qualified\"\n    /// lookup in member expressions.  In C++, they're found by\n    /// normal lookup.\n    IDNS_Member              = 0x0008,\n\n    /// Namespaces, declared with 'namespace foo {}'.\n    /// Lookup for nested-name-specifiers find these.\n    IDNS_Namespace           = 0x0010,\n\n    /// Ordinary names.  In C, everything that's not a label, tag,\n    /// member, or function-local extern ends up here.\n    IDNS_Ordinary            = 0x0020,\n\n    /// Objective C \\@protocol.\n    IDNS_ObjCProtocol        = 0x0040,\n\n    /// This declaration is a friend function.  A friend function\n    /// declaration is always in this namespace but may also be in\n    /// IDNS_Ordinary if it was previously declared.\n    IDNS_OrdinaryFriend      = 0x0080,\n\n    /// This declaration is a friend class.  A friend class\n    /// declaration is always in this namespace but may also be in\n    /// IDNS_Tag|IDNS_Type if it was previously declared.\n    IDNS_TagFriend           = 0x0100,\n\n    /// This declaration is a using declaration.  A using declaration\n    /// *introduces* a number of other declarations into the current\n    /// scope, and those declarations use the IDNS of their targets,\n    /// but the actual using declarations go in this namespace.\n    IDNS_Using               = 0x0200,\n\n    /// This declaration is a C++ operator declared in a non-class\n    /// context.  All such operators are also in IDNS_Ordinary.\n    /// C++ lexical operator lookup looks for these.\n    IDNS_NonMemberOperator   = 0x0400,\n\n    /// This declaration is a function-local extern declaration of a\n    /// variable or function. This may also be IDNS_Ordinary if it\n    /// has been declared outside any function. These act mostly like\n    /// invisible friend declarations, but are also visible to unqualified\n    /// lookup within the scope of the declaring function.\n    IDNS_LocalExtern         = 0x0800,\n\n    /// This declaration is an OpenMP user defined reduction construction.\n    IDNS_OMPReduction        = 0x1000,\n\n    /// This declaration is an OpenMP user defined mapper.\n    IDNS_OMPMapper           = 0x2000,\n  };\n\n  /// ObjCDeclQualifier - 'Qualifiers' written next to the return and\n  /// parameter types in method declarations.  Other than remembering\n  /// them and mangling them into the method's signature string, these\n  /// are ignored by the compiler; they are consumed by certain\n  /// remote-messaging frameworks.\n  ///\n  /// in, inout, and out are mutually exclusive and apply only to\n  /// method parameters.  bycopy and byref are mutually exclusive and\n  /// apply only to method parameters (?).  oneway applies only to\n  /// results.  All of these expect their corresponding parameter to\n  /// have a particular type.  None of this is currently enforced by\n  /// clang.\n  ///\n  /// This should be kept in sync with ObjCDeclSpec::ObjCDeclQualifier.\n  enum ObjCDeclQualifier {\n    OBJC_TQ_None = 0x0,\n    OBJC_TQ_In = 0x1,\n    OBJC_TQ_Inout = 0x2,\n    OBJC_TQ_Out = 0x4,\n    OBJC_TQ_Bycopy = 0x8,\n    OBJC_TQ_Byref = 0x10,\n    OBJC_TQ_Oneway = 0x20,\n\n    /// The nullability qualifier is set when the nullability of the\n    /// result or parameter was expressed via a context-sensitive\n    /// keyword.\n    OBJC_TQ_CSNullability = 0x40\n  };\n\n  /// The kind of ownership a declaration has, for visibility purposes.\n  /// This enumeration is designed such that higher values represent higher\n  /// levels of name hiding.\n  enum class ModuleOwnershipKind : unsigned {\n    /// This declaration is not owned by a module.\n    Unowned,\n\n    /// This declaration has an owning module, but is globally visible\n    /// (typically because its owning module is visible and we know that\n    /// modules cannot later become hidden in this compilation).\n    /// After serialization and deserialization, this will be converted\n    /// to VisibleWhenImported.\n    Visible,\n\n    /// This declaration has an owning module, and is visible when that\n    /// module is imported.\n    VisibleWhenImported,\n\n    /// This declaration has an owning module, but is only visible to\n    /// lookups that occur within that module.\n    ModulePrivate\n  };\n\nprotected:\n  /// The next declaration within the same lexical\n  /// DeclContext. These pointers form the linked list that is\n  /// traversed via DeclContext's decls_begin()/decls_end().\n  ///\n  /// The extra two bits are used for the ModuleOwnershipKind.\n  llvm::PointerIntPair<Decl *, 2, ModuleOwnershipKind> NextInContextAndBits;\n\nprivate:\n  friend class DeclContext;\n\n  struct MultipleDC {\n    DeclContext *SemanticDC;\n    DeclContext *LexicalDC;\n  };\n\n  /// DeclCtx - Holds either a DeclContext* or a MultipleDC*.\n  /// For declarations that don't contain C++ scope specifiers, it contains\n  /// the DeclContext where the Decl was declared.\n  /// For declarations with C++ scope specifiers, it contains a MultipleDC*\n  /// with the context where it semantically belongs (SemanticDC) and the\n  /// context where it was lexically declared (LexicalDC).\n  /// e.g.:\n  ///\n  ///   namespace A {\n  ///      void f(); // SemanticDC == LexicalDC == 'namespace A'\n  ///   }\n  ///   void A::f(); // SemanticDC == namespace 'A'\n  ///                // LexicalDC == global namespace\n  llvm::PointerUnion<DeclContext*, MultipleDC*> DeclCtx;\n\n  bool isInSemaDC() const { return DeclCtx.is<DeclContext*>(); }\n  bool isOutOfSemaDC() const { return DeclCtx.is<MultipleDC*>(); }\n\n  MultipleDC *getMultipleDC() const {\n    return DeclCtx.get<MultipleDC*>();\n  }\n\n  DeclContext *getSemanticDC() const {\n    return DeclCtx.get<DeclContext*>();\n  }\n\n  /// Loc - The location of this decl.\n  SourceLocation Loc;\n\n  /// DeclKind - This indicates which class this is.\n  unsigned DeclKind : 7;\n\n  /// InvalidDecl - This indicates a semantic error occurred.\n  unsigned InvalidDecl :  1;\n\n  /// HasAttrs - This indicates whether the decl has attributes or not.\n  unsigned HasAttrs : 1;\n\n  /// Implicit - Whether this declaration was implicitly generated by\n  /// the implementation rather than explicitly written by the user.\n  unsigned Implicit : 1;\n\n  /// Whether this declaration was \"used\", meaning that a definition is\n  /// required.\n  unsigned Used : 1;\n\n  /// Whether this declaration was \"referenced\".\n  /// The difference with 'Used' is whether the reference appears in a\n  /// evaluated context or not, e.g. functions used in uninstantiated templates\n  /// are regarded as \"referenced\" but not \"used\".\n  unsigned Referenced : 1;\n\n  /// Whether this declaration is a top-level declaration (function,\n  /// global variable, etc.) that is lexically inside an objc container\n  /// definition.\n  unsigned TopLevelDeclInObjCContainer : 1;\n\n  /// Whether statistic collection is enabled.\n  static bool StatisticsEnabled;\n\nprotected:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend class ASTNodeImporter;\n  friend class ASTReader;\n  friend class CXXClassMemberWrapper;\n  friend class LinkageComputer;\n  template<typename decl_type> friend class Redeclarable;\n\n  /// Access - Used by C++ decls for the access specifier.\n  // NOTE: VC++ treats enums as signed, avoid using the AccessSpecifier enum\n  unsigned Access : 2;\n\n  /// Whether this declaration was loaded from an AST file.\n  unsigned FromASTFile : 1;\n\n  /// IdentifierNamespace - This specifies what IDNS_* namespace this lives in.\n  unsigned IdentifierNamespace : 14;\n\n  /// If 0, we have not computed the linkage of this declaration.\n  /// Otherwise, it is the linkage + 1.\n  mutable unsigned CacheValidAndLinkage : 3;\n\n  /// Allocate memory for a deserialized declaration.\n  ///\n  /// This routine must be used to allocate memory for any declaration that is\n  /// deserialized from a module file.\n  ///\n  /// \\param Size The size of the allocated object.\n  /// \\param Ctx The context in which we will allocate memory.\n  /// \\param ID The global ID of the deserialized declaration.\n  /// \\param Extra The amount of extra space to allocate after the object.\n  void *operator new(std::size_t Size, const ASTContext &Ctx, unsigned ID,\n                     std::size_t Extra = 0);\n\n  /// Allocate memory for a non-deserialized declaration.\n  void *operator new(std::size_t Size, const ASTContext &Ctx,\n                     DeclContext *Parent, std::size_t Extra = 0);\n\nprivate:\n  bool AccessDeclContextSanity() const;\n\n  /// Get the module ownership kind to use for a local lexical child of \\p DC,\n  /// which may be either a local or (rarely) an imported declaration.\n  static ModuleOwnershipKind getModuleOwnershipKindForChildOf(DeclContext *DC) {\n    if (DC) {\n      auto *D = cast<Decl>(DC);\n      auto MOK = D->getModuleOwnershipKind();\n      if (MOK != ModuleOwnershipKind::Unowned &&\n          (!D->isFromASTFile() || D->hasLocalOwningModuleStorage()))\n        return MOK;\n      // If D is not local and we have no local module storage, then we don't\n      // need to track module ownership at all.\n    }\n    return ModuleOwnershipKind::Unowned;\n  }\n\npublic:\n  Decl() = delete;\n  Decl(const Decl&) = delete;\n  Decl(Decl &&) = delete;\n  Decl &operator=(const Decl&) = delete;\n  Decl &operator=(Decl&&) = delete;\n\nprotected:\n  Decl(Kind DK, DeclContext *DC, SourceLocation L)\n      : NextInContextAndBits(nullptr, getModuleOwnershipKindForChildOf(DC)),\n        DeclCtx(DC), Loc(L), DeclKind(DK), InvalidDecl(false), HasAttrs(false),\n        Implicit(false), Used(false), Referenced(false),\n        TopLevelDeclInObjCContainer(false), Access(AS_none), FromASTFile(0),\n        IdentifierNamespace(getIdentifierNamespaceForKind(DK)),\n        CacheValidAndLinkage(0) {\n    if (StatisticsEnabled) add(DK);\n  }\n\n  Decl(Kind DK, EmptyShell Empty)\n      : DeclKind(DK), InvalidDecl(false), HasAttrs(false), Implicit(false),\n        Used(false), Referenced(false), TopLevelDeclInObjCContainer(false),\n        Access(AS_none), FromASTFile(0),\n        IdentifierNamespace(getIdentifierNamespaceForKind(DK)),\n        CacheValidAndLinkage(0) {\n    if (StatisticsEnabled) add(DK);\n  }\n\n  virtual ~Decl();\n\n  /// Update a potentially out-of-date declaration.\n  void updateOutOfDate(IdentifierInfo &II) const;\n\n  Linkage getCachedLinkage() const {\n    return Linkage(CacheValidAndLinkage - 1);\n  }\n\n  void setCachedLinkage(Linkage L) const {\n    CacheValidAndLinkage = L + 1;\n  }\n\n  bool hasCachedLinkage() const {\n    return CacheValidAndLinkage;\n  }\n\npublic:\n  /// Source range that this declaration covers.\n  virtual SourceRange getSourceRange() const LLVM_READONLY {\n    return SourceRange(getLocation(), getLocation());\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getSourceRange().getBegin();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getSourceRange().getEnd();\n  }\n\n  SourceLocation getLocation() const { return Loc; }\n  void setLocation(SourceLocation L) { Loc = L; }\n\n  Kind getKind() const { return static_cast<Kind>(DeclKind); }\n  const char *getDeclKindName() const;\n\n  Decl *getNextDeclInContext() { return NextInContextAndBits.getPointer(); }\n  const Decl *getNextDeclInContext() const {return NextInContextAndBits.getPointer();}\n\n  DeclContext *getDeclContext() {\n    if (isInSemaDC())\n      return getSemanticDC();\n    return getMultipleDC()->SemanticDC;\n  }\n  const DeclContext *getDeclContext() const {\n    return const_cast<Decl*>(this)->getDeclContext();\n  }\n\n  /// Find the innermost non-closure ancestor of this declaration,\n  /// walking up through blocks, lambdas, etc.  If that ancestor is\n  /// not a code context (!isFunctionOrMethod()), returns null.\n  ///\n  /// A declaration may be its own non-closure context.\n  Decl *getNonClosureContext();\n  const Decl *getNonClosureContext() const {\n    return const_cast<Decl*>(this)->getNonClosureContext();\n  }\n\n  TranslationUnitDecl *getTranslationUnitDecl();\n  const TranslationUnitDecl *getTranslationUnitDecl() const {\n    return const_cast<Decl*>(this)->getTranslationUnitDecl();\n  }\n\n  bool isInAnonymousNamespace() const;\n\n  bool isInStdNamespace() const;\n\n  ASTContext &getASTContext() const LLVM_READONLY;\n\n  /// Helper to get the language options from the ASTContext.\n  /// Defined out of line to avoid depending on ASTContext.h.\n  const LangOptions &getLangOpts() const LLVM_READONLY;\n\n  void setAccess(AccessSpecifier AS) {\n    Access = AS;\n    assert(AccessDeclContextSanity());\n  }\n\n  AccessSpecifier getAccess() const {\n    assert(AccessDeclContextSanity());\n    return AccessSpecifier(Access);\n  }\n\n  /// Retrieve the access specifier for this declaration, even though\n  /// it may not yet have been properly set.\n  AccessSpecifier getAccessUnsafe() const {\n    return AccessSpecifier(Access);\n  }\n\n  bool hasAttrs() const { return HasAttrs; }\n\n  void setAttrs(const AttrVec& Attrs) {\n    return setAttrsImpl(Attrs, getASTContext());\n  }\n\n  AttrVec &getAttrs() {\n    return const_cast<AttrVec&>(const_cast<const Decl*>(this)->getAttrs());\n  }\n\n  const AttrVec &getAttrs() const;\n  void dropAttrs();\n  void addAttr(Attr *A);\n\n  using attr_iterator = AttrVec::const_iterator;\n  using attr_range = llvm::iterator_range<attr_iterator>;\n\n  attr_range attrs() const {\n    return attr_range(attr_begin(), attr_end());\n  }\n\n  attr_iterator attr_begin() const {\n    return hasAttrs() ? getAttrs().begin() : nullptr;\n  }\n  attr_iterator attr_end() const {\n    return hasAttrs() ? getAttrs().end() : nullptr;\n  }\n\n  template <typename T>\n  void dropAttr() {\n    if (!HasAttrs) return;\n\n    AttrVec &Vec = getAttrs();\n    llvm::erase_if(Vec, [](Attr *A) { return isa<T>(A); });\n\n    if (Vec.empty())\n      HasAttrs = false;\n  }\n\n  template <typename T>\n  llvm::iterator_range<specific_attr_iterator<T>> specific_attrs() const {\n    return llvm::make_range(specific_attr_begin<T>(), specific_attr_end<T>());\n  }\n\n  template <typename T>\n  specific_attr_iterator<T> specific_attr_begin() const {\n    return specific_attr_iterator<T>(attr_begin());\n  }\n\n  template <typename T>\n  specific_attr_iterator<T> specific_attr_end() const {\n    return specific_attr_iterator<T>(attr_end());\n  }\n\n  template<typename T> T *getAttr() const {\n    return hasAttrs() ? getSpecificAttr<T>(getAttrs()) : nullptr;\n  }\n\n  template<typename T> bool hasAttr() const {\n    return hasAttrs() && hasSpecificAttr<T>(getAttrs());\n  }\n\n  /// getMaxAlignment - return the maximum alignment specified by attributes\n  /// on this decl, 0 if there are none.\n  unsigned getMaxAlignment() const;\n\n  /// setInvalidDecl - Indicates the Decl had a semantic error. This\n  /// allows for graceful error recovery.\n  void setInvalidDecl(bool Invalid = true);\n  bool isInvalidDecl() const { return (bool) InvalidDecl; }\n\n  /// isImplicit - Indicates whether the declaration was implicitly\n  /// generated by the implementation. If false, this declaration\n  /// was written explicitly in the source code.\n  bool isImplicit() const { return Implicit; }\n  void setImplicit(bool I = true) { Implicit = I; }\n\n  /// Whether *any* (re-)declaration of the entity was used, meaning that\n  /// a definition is required.\n  ///\n  /// \\param CheckUsedAttr When true, also consider the \"used\" attribute\n  /// (in addition to the \"used\" bit set by \\c setUsed()) when determining\n  /// whether the function is used.\n  bool isUsed(bool CheckUsedAttr = true) const;\n\n  /// Set whether the declaration is used, in the sense of odr-use.\n  ///\n  /// This should only be used immediately after creating a declaration.\n  /// It intentionally doesn't notify any listeners.\n  void setIsUsed() { getCanonicalDecl()->Used = true; }\n\n  /// Mark the declaration used, in the sense of odr-use.\n  ///\n  /// This notifies any mutation listeners in addition to setting a bit\n  /// indicating the declaration is used.\n  void markUsed(ASTContext &C);\n\n  /// Whether any declaration of this entity was referenced.\n  bool isReferenced() const;\n\n  /// Whether this declaration was referenced. This should not be relied\n  /// upon for anything other than debugging.\n  bool isThisDeclarationReferenced() const { return Referenced; }\n\n  void setReferenced(bool R = true) { Referenced = R; }\n\n  /// Whether this declaration is a top-level declaration (function,\n  /// global variable, etc.) that is lexically inside an objc container\n  /// definition.\n  bool isTopLevelDeclInObjCContainer() const {\n    return TopLevelDeclInObjCContainer;\n  }\n\n  void setTopLevelDeclInObjCContainer(bool V = true) {\n    TopLevelDeclInObjCContainer = V;\n  }\n\n  /// Looks on this and related declarations for an applicable\n  /// external source symbol attribute.\n  ExternalSourceSymbolAttr *getExternalSourceSymbolAttr() const;\n\n  /// Whether this declaration was marked as being private to the\n  /// module in which it was defined.\n  bool isModulePrivate() const {\n    return getModuleOwnershipKind() == ModuleOwnershipKind::ModulePrivate;\n  }\n\n  /// Return true if this declaration has an attribute which acts as\n  /// definition of the entity, such as 'alias' or 'ifunc'.\n  bool hasDefiningAttr() const;\n\n  /// Return this declaration's defining attribute if it has one.\n  const Attr *getDefiningAttr() const;\n\nprotected:\n  /// Specify that this declaration was marked as being private\n  /// to the module in which it was defined.\n  void setModulePrivate() {\n    // The module-private specifier has no effect on unowned declarations.\n    // FIXME: We should track this in some way for source fidelity.\n    if (getModuleOwnershipKind() == ModuleOwnershipKind::Unowned)\n      return;\n    setModuleOwnershipKind(ModuleOwnershipKind::ModulePrivate);\n  }\n\npublic:\n  /// Set the FromASTFile flag. This indicates that this declaration\n  /// was deserialized and not parsed from source code and enables\n  /// features such as module ownership information.\n  void setFromASTFile() {\n    FromASTFile = true;\n  }\n\n  /// Set the owning module ID.  This may only be called for\n  /// deserialized Decls.\n  void setOwningModuleID(unsigned ID) {\n    assert(isFromASTFile() && \"Only works on a deserialized declaration\");\n    *((unsigned*)this - 2) = ID;\n  }\n\npublic:\n  /// Determine the availability of the given declaration.\n  ///\n  /// This routine will determine the most restrictive availability of\n  /// the given declaration (e.g., preferring 'unavailable' to\n  /// 'deprecated').\n  ///\n  /// \\param Message If non-NULL and the result is not \\c\n  /// AR_Available, will be set to a (possibly empty) message\n  /// describing why the declaration has not been introduced, is\n  /// deprecated, or is unavailable.\n  ///\n  /// \\param EnclosingVersion The version to compare with. If empty, assume the\n  /// deployment target version.\n  ///\n  /// \\param RealizedPlatform If non-NULL and the availability result is found\n  /// in an available attribute it will set to the platform which is written in\n  /// the available attribute.\n  AvailabilityResult\n  getAvailability(std::string *Message = nullptr,\n                  VersionTuple EnclosingVersion = VersionTuple(),\n                  StringRef *RealizedPlatform = nullptr) const;\n\n  /// Retrieve the version of the target platform in which this\n  /// declaration was introduced.\n  ///\n  /// \\returns An empty version tuple if this declaration has no 'introduced'\n  /// availability attributes, or the version tuple that's specified in the\n  /// attribute otherwise.\n  VersionTuple getVersionIntroduced() const;\n\n  /// Determine whether this declaration is marked 'deprecated'.\n  ///\n  /// \\param Message If non-NULL and the declaration is deprecated,\n  /// this will be set to the message describing why the declaration\n  /// was deprecated (which may be empty).\n  bool isDeprecated(std::string *Message = nullptr) const {\n    return getAvailability(Message) == AR_Deprecated;\n  }\n\n  /// Determine whether this declaration is marked 'unavailable'.\n  ///\n  /// \\param Message If non-NULL and the declaration is unavailable,\n  /// this will be set to the message describing why the declaration\n  /// was made unavailable (which may be empty).\n  bool isUnavailable(std::string *Message = nullptr) const {\n    return getAvailability(Message) == AR_Unavailable;\n  }\n\n  /// Determine whether this is a weak-imported symbol.\n  ///\n  /// Weak-imported symbols are typically marked with the\n  /// 'weak_import' attribute, but may also be marked with an\n  /// 'availability' attribute where we're targing a platform prior to\n  /// the introduction of this feature.\n  bool isWeakImported() const;\n\n  /// Determines whether this symbol can be weak-imported,\n  /// e.g., whether it would be well-formed to add the weak_import\n  /// attribute.\n  ///\n  /// \\param IsDefinition Set to \\c true to indicate that this\n  /// declaration cannot be weak-imported because it has a definition.\n  bool canBeWeakImported(bool &IsDefinition) const;\n\n  /// Determine whether this declaration came from an AST file (such as\n  /// a precompiled header or module) rather than having been parsed.\n  bool isFromASTFile() const { return FromASTFile; }\n\n  /// Retrieve the global declaration ID associated with this\n  /// declaration, which specifies where this Decl was loaded from.\n  unsigned getGlobalID() const {\n    if (isFromASTFile())\n      return *((const unsigned*)this - 1);\n    return 0;\n  }\n\n  /// Retrieve the global ID of the module that owns this particular\n  /// declaration.\n  unsigned getOwningModuleID() const {\n    if (isFromASTFile())\n      return *((const unsigned*)this - 2);\n    return 0;\n  }\n\nprivate:\n  Module *getOwningModuleSlow() const;\n\nprotected:\n  bool hasLocalOwningModuleStorage() const;\n\npublic:\n  /// Get the imported owning module, if this decl is from an imported\n  /// (non-local) module.\n  Module *getImportedOwningModule() const {\n    if (!isFromASTFile() || !hasOwningModule())\n      return nullptr;\n\n    return getOwningModuleSlow();\n  }\n\n  /// Get the local owning module, if known. Returns nullptr if owner is\n  /// not yet known or declaration is not from a module.\n  Module *getLocalOwningModule() const {\n    if (isFromASTFile() || !hasOwningModule())\n      return nullptr;\n\n    assert(hasLocalOwningModuleStorage() &&\n           \"owned local decl but no local module storage\");\n    return reinterpret_cast<Module *const *>(this)[-1];\n  }\n  void setLocalOwningModule(Module *M) {\n    assert(!isFromASTFile() && hasOwningModule() &&\n           hasLocalOwningModuleStorage() &&\n           \"should not have a cached owning module\");\n    reinterpret_cast<Module **>(this)[-1] = M;\n  }\n\n  /// Is this declaration owned by some module?\n  bool hasOwningModule() const {\n    return getModuleOwnershipKind() != ModuleOwnershipKind::Unowned;\n  }\n\n  /// Get the module that owns this declaration (for visibility purposes).\n  Module *getOwningModule() const {\n    return isFromASTFile() ? getImportedOwningModule() : getLocalOwningModule();\n  }\n\n  /// Get the module that owns this declaration for linkage purposes.\n  /// There only ever is such a module under the C++ Modules TS.\n  ///\n  /// \\param IgnoreLinkage Ignore the linkage of the entity; assume that\n  /// all declarations in a global module fragment are unowned.\n  Module *getOwningModuleForLinkage(bool IgnoreLinkage = false) const;\n\n  /// Determine whether this declaration is definitely visible to name lookup,\n  /// independent of whether the owning module is visible.\n  /// Note: The declaration may be visible even if this returns \\c false if the\n  /// owning module is visible within the query context. This is a low-level\n  /// helper function; most code should be calling Sema::isVisible() instead.\n  bool isUnconditionallyVisible() const {\n    return (int)getModuleOwnershipKind() <= (int)ModuleOwnershipKind::Visible;\n  }\n\n  /// Set that this declaration is globally visible, even if it came from a\n  /// module that is not visible.\n  void setVisibleDespiteOwningModule() {\n    if (!isUnconditionallyVisible())\n      setModuleOwnershipKind(ModuleOwnershipKind::Visible);\n  }\n\n  /// Get the kind of module ownership for this declaration.\n  ModuleOwnershipKind getModuleOwnershipKind() const {\n    return NextInContextAndBits.getInt();\n  }\n\n  /// Set whether this declaration is hidden from name lookup.\n  void setModuleOwnershipKind(ModuleOwnershipKind MOK) {\n    assert(!(getModuleOwnershipKind() == ModuleOwnershipKind::Unowned &&\n             MOK != ModuleOwnershipKind::Unowned && !isFromASTFile() &&\n             !hasLocalOwningModuleStorage()) &&\n           \"no storage available for owning module for this declaration\");\n    NextInContextAndBits.setInt(MOK);\n  }\n\n  unsigned getIdentifierNamespace() const {\n    return IdentifierNamespace;\n  }\n\n  bool isInIdentifierNamespace(unsigned NS) const {\n    return getIdentifierNamespace() & NS;\n  }\n\n  static unsigned getIdentifierNamespaceForKind(Kind DK);\n\n  bool hasTagIdentifierNamespace() const {\n    return isTagIdentifierNamespace(getIdentifierNamespace());\n  }\n\n  static bool isTagIdentifierNamespace(unsigned NS) {\n    // TagDecls have Tag and Type set and may also have TagFriend.\n    return (NS & ~IDNS_TagFriend) == (IDNS_Tag | IDNS_Type);\n  }\n\n  /// getLexicalDeclContext - The declaration context where this Decl was\n  /// lexically declared (LexicalDC). May be different from\n  /// getDeclContext() (SemanticDC).\n  /// e.g.:\n  ///\n  ///   namespace A {\n  ///      void f(); // SemanticDC == LexicalDC == 'namespace A'\n  ///   }\n  ///   void A::f(); // SemanticDC == namespace 'A'\n  ///                // LexicalDC == global namespace\n  DeclContext *getLexicalDeclContext() {\n    if (isInSemaDC())\n      return getSemanticDC();\n    return getMultipleDC()->LexicalDC;\n  }\n  const DeclContext *getLexicalDeclContext() const {\n    return const_cast<Decl*>(this)->getLexicalDeclContext();\n  }\n\n  /// Determine whether this declaration is declared out of line (outside its\n  /// semantic context).\n  virtual bool isOutOfLine() const;\n\n  /// setDeclContext - Set both the semantic and lexical DeclContext\n  /// to DC.\n  void setDeclContext(DeclContext *DC);\n\n  void setLexicalDeclContext(DeclContext *DC);\n\n  /// Determine whether this declaration is a templated entity (whether it is\n  // within the scope of a template parameter).\n  bool isTemplated() const;\n\n  /// Determine the number of levels of template parameter surrounding this\n  /// declaration.\n  unsigned getTemplateDepth() const;\n\n  /// isDefinedOutsideFunctionOrMethod - This predicate returns true if this\n  /// scoped decl is defined outside the current function or method.  This is\n  /// roughly global variables and functions, but also handles enums (which\n  /// could be defined inside or outside a function etc).\n  bool isDefinedOutsideFunctionOrMethod() const {\n    return getParentFunctionOrMethod() == nullptr;\n  }\n\n  /// Determine whether a substitution into this declaration would occur as\n  /// part of a substitution into a dependent local scope. Such a substitution\n  /// transitively substitutes into all constructs nested within this\n  /// declaration.\n  ///\n  /// This recognizes non-defining declarations as well as members of local\n  /// classes and lambdas:\n  /// \\code\n  ///     template<typename T> void foo() { void bar(); }\n  ///     template<typename T> void foo2() { class ABC { void bar(); }; }\n  ///     template<typename T> inline int x = [](){ return 0; }();\n  /// \\endcode\n  bool isInLocalScopeForInstantiation() const;\n\n  /// If this decl is defined inside a function/method/block it returns\n  /// the corresponding DeclContext, otherwise it returns null.\n  const DeclContext *getParentFunctionOrMethod() const;\n  DeclContext *getParentFunctionOrMethod() {\n    return const_cast<DeclContext*>(\n                    const_cast<const Decl*>(this)->getParentFunctionOrMethod());\n  }\n\n  /// Retrieves the \"canonical\" declaration of the given declaration.\n  virtual Decl *getCanonicalDecl() { return this; }\n  const Decl *getCanonicalDecl() const {\n    return const_cast<Decl*>(this)->getCanonicalDecl();\n  }\n\n  /// Whether this particular Decl is a canonical one.\n  bool isCanonicalDecl() const { return getCanonicalDecl() == this; }\n\nprotected:\n  /// Returns the next redeclaration or itself if this is the only decl.\n  ///\n  /// Decl subclasses that can be redeclared should override this method so that\n  /// Decl::redecl_iterator can iterate over them.\n  virtual Decl *getNextRedeclarationImpl() { return this; }\n\n  /// Implementation of getPreviousDecl(), to be overridden by any\n  /// subclass that has a redeclaration chain.\n  virtual Decl *getPreviousDeclImpl() { return nullptr; }\n\n  /// Implementation of getMostRecentDecl(), to be overridden by any\n  /// subclass that has a redeclaration chain.\n  virtual Decl *getMostRecentDeclImpl() { return this; }\n\npublic:\n  /// Iterates through all the redeclarations of the same decl.\n  class redecl_iterator {\n    /// Current - The current declaration.\n    Decl *Current = nullptr;\n    Decl *Starter;\n\n  public:\n    using value_type = Decl *;\n    using reference = const value_type &;\n    using pointer = const value_type *;\n    using iterator_category = std::forward_iterator_tag;\n    using difference_type = std::ptrdiff_t;\n\n    redecl_iterator() = default;\n    explicit redecl_iterator(Decl *C) : Current(C), Starter(C) {}\n\n    reference operator*() const { return Current; }\n    value_type operator->() const { return Current; }\n\n    redecl_iterator& operator++() {\n      assert(Current && \"Advancing while iterator has reached end\");\n      // Get either previous decl or latest decl.\n      Decl *Next = Current->getNextRedeclarationImpl();\n      assert(Next && \"Should return next redeclaration or itself, never null!\");\n      Current = (Next != Starter) ? Next : nullptr;\n      return *this;\n    }\n\n    redecl_iterator operator++(int) {\n      redecl_iterator tmp(*this);\n      ++(*this);\n      return tmp;\n    }\n\n    friend bool operator==(redecl_iterator x, redecl_iterator y) {\n      return x.Current == y.Current;\n    }\n\n    friend bool operator!=(redecl_iterator x, redecl_iterator y) {\n      return x.Current != y.Current;\n    }\n  };\n\n  using redecl_range = llvm::iterator_range<redecl_iterator>;\n\n  /// Returns an iterator range for all the redeclarations of the same\n  /// decl. It will iterate at least once (when this decl is the only one).\n  redecl_range redecls() const {\n    return redecl_range(redecls_begin(), redecls_end());\n  }\n\n  redecl_iterator redecls_begin() const {\n    return redecl_iterator(const_cast<Decl *>(this));\n  }\n\n  redecl_iterator redecls_end() const { return redecl_iterator(); }\n\n  /// Retrieve the previous declaration that declares the same entity\n  /// as this declaration, or NULL if there is no previous declaration.\n  Decl *getPreviousDecl() { return getPreviousDeclImpl(); }\n\n  /// Retrieve the previous declaration that declares the same entity\n  /// as this declaration, or NULL if there is no previous declaration.\n  const Decl *getPreviousDecl() const {\n    return const_cast<Decl *>(this)->getPreviousDeclImpl();\n  }\n\n  /// True if this is the first declaration in its redeclaration chain.\n  bool isFirstDecl() const {\n    return getPreviousDecl() == nullptr;\n  }\n\n  /// Retrieve the most recent declaration that declares the same entity\n  /// as this declaration (which may be this declaration).\n  Decl *getMostRecentDecl() { return getMostRecentDeclImpl(); }\n\n  /// Retrieve the most recent declaration that declares the same entity\n  /// as this declaration (which may be this declaration).\n  const Decl *getMostRecentDecl() const {\n    return const_cast<Decl *>(this)->getMostRecentDeclImpl();\n  }\n\n  /// getBody - If this Decl represents a declaration for a body of code,\n  ///  such as a function or method definition, this method returns the\n  ///  top-level Stmt* of that body.  Otherwise this method returns null.\n  virtual Stmt* getBody() const { return nullptr; }\n\n  /// Returns true if this \\c Decl represents a declaration for a body of\n  /// code, such as a function or method definition.\n  /// Note that \\c hasBody can also return true if any redeclaration of this\n  /// \\c Decl represents a declaration for a body of code.\n  virtual bool hasBody() const { return getBody() != nullptr; }\n\n  /// getBodyRBrace - Gets the right brace of the body, if a body exists.\n  /// This works whether the body is a CompoundStmt or a CXXTryStmt.\n  SourceLocation getBodyRBrace() const;\n\n  // global temp stats (until we have a per-module visitor)\n  static void add(Kind k);\n  static void EnableStatistics();\n  static void PrintStats();\n\n  /// isTemplateParameter - Determines whether this declaration is a\n  /// template parameter.\n  bool isTemplateParameter() const;\n\n  /// isTemplateParameter - Determines whether this declaration is a\n  /// template parameter pack.\n  bool isTemplateParameterPack() const;\n\n  /// Whether this declaration is a parameter pack.\n  bool isParameterPack() const;\n\n  /// returns true if this declaration is a template\n  bool isTemplateDecl() const;\n\n  /// Whether this declaration is a function or function template.\n  bool isFunctionOrFunctionTemplate() const {\n    return (DeclKind >= Decl::firstFunction &&\n            DeclKind <= Decl::lastFunction) ||\n           DeclKind == FunctionTemplate;\n  }\n\n  /// If this is a declaration that describes some template, this\n  /// method returns that template declaration.\n  ///\n  /// Note that this returns nullptr for partial specializations, because they\n  /// are not modeled as TemplateDecls. Use getDescribedTemplateParams to handle\n  /// those cases.\n  TemplateDecl *getDescribedTemplate() const;\n\n  /// If this is a declaration that describes some template or partial\n  /// specialization, this returns the corresponding template parameter list.\n  const TemplateParameterList *getDescribedTemplateParams() const;\n\n  /// Returns the function itself, or the templated function if this is a\n  /// function template.\n  FunctionDecl *getAsFunction() LLVM_READONLY;\n\n  const FunctionDecl *getAsFunction() const {\n    return const_cast<Decl *>(this)->getAsFunction();\n  }\n\n  /// Changes the namespace of this declaration to reflect that it's\n  /// a function-local extern declaration.\n  ///\n  /// These declarations appear in the lexical context of the extern\n  /// declaration, but in the semantic context of the enclosing namespace\n  /// scope.\n  void setLocalExternDecl() {\n    Decl *Prev = getPreviousDecl();\n    IdentifierNamespace &= ~IDNS_Ordinary;\n\n    // It's OK for the declaration to still have the \"invisible friend\" flag or\n    // the \"conflicts with tag declarations in this scope\" flag for the outer\n    // scope.\n    assert((IdentifierNamespace & ~(IDNS_OrdinaryFriend | IDNS_Tag)) == 0 &&\n           \"namespace is not ordinary\");\n\n    IdentifierNamespace |= IDNS_LocalExtern;\n    if (Prev && Prev->getIdentifierNamespace() & IDNS_Ordinary)\n      IdentifierNamespace |= IDNS_Ordinary;\n  }\n\n  /// Determine whether this is a block-scope declaration with linkage.\n  /// This will either be a local variable declaration declared 'extern', or a\n  /// local function declaration.\n  bool isLocalExternDecl() {\n    return IdentifierNamespace & IDNS_LocalExtern;\n  }\n\n  /// Changes the namespace of this declaration to reflect that it's\n  /// the object of a friend declaration.\n  ///\n  /// These declarations appear in the lexical context of the friending\n  /// class, but in the semantic context of the actual entity.  This property\n  /// applies only to a specific decl object;  other redeclarations of the\n  /// same entity may not (and probably don't) share this property.\n  void setObjectOfFriendDecl(bool PerformFriendInjection = false) {\n    unsigned OldNS = IdentifierNamespace;\n    assert((OldNS & (IDNS_Tag | IDNS_Ordinary |\n                     IDNS_TagFriend | IDNS_OrdinaryFriend |\n                     IDNS_LocalExtern | IDNS_NonMemberOperator)) &&\n           \"namespace includes neither ordinary nor tag\");\n    assert(!(OldNS & ~(IDNS_Tag | IDNS_Ordinary | IDNS_Type |\n                       IDNS_TagFriend | IDNS_OrdinaryFriend |\n                       IDNS_LocalExtern | IDNS_NonMemberOperator)) &&\n           \"namespace includes other than ordinary or tag\");\n\n    Decl *Prev = getPreviousDecl();\n    IdentifierNamespace &= ~(IDNS_Ordinary | IDNS_Tag | IDNS_Type);\n\n    if (OldNS & (IDNS_Tag | IDNS_TagFriend)) {\n      IdentifierNamespace |= IDNS_TagFriend;\n      if (PerformFriendInjection ||\n          (Prev && Prev->getIdentifierNamespace() & IDNS_Tag))\n        IdentifierNamespace |= IDNS_Tag | IDNS_Type;\n    }\n\n    if (OldNS & (IDNS_Ordinary | IDNS_OrdinaryFriend |\n                 IDNS_LocalExtern | IDNS_NonMemberOperator)) {\n      IdentifierNamespace |= IDNS_OrdinaryFriend;\n      if (PerformFriendInjection ||\n          (Prev && Prev->getIdentifierNamespace() & IDNS_Ordinary))\n        IdentifierNamespace |= IDNS_Ordinary;\n    }\n  }\n\n  enum FriendObjectKind {\n    FOK_None,      ///< Not a friend object.\n    FOK_Declared,  ///< A friend of a previously-declared entity.\n    FOK_Undeclared ///< A friend of a previously-undeclared entity.\n  };\n\n  /// Determines whether this declaration is the object of a\n  /// friend declaration and, if so, what kind.\n  ///\n  /// There is currently no direct way to find the associated FriendDecl.\n  FriendObjectKind getFriendObjectKind() const {\n    unsigned mask =\n        (IdentifierNamespace & (IDNS_TagFriend | IDNS_OrdinaryFriend));\n    if (!mask) return FOK_None;\n    return (IdentifierNamespace & (IDNS_Tag | IDNS_Ordinary) ? FOK_Declared\n                                                             : FOK_Undeclared);\n  }\n\n  /// Specifies that this declaration is a C++ overloaded non-member.\n  void setNonMemberOperator() {\n    assert(getKind() == Function || getKind() == FunctionTemplate);\n    assert((IdentifierNamespace & IDNS_Ordinary) &&\n           \"visible non-member operators should be in ordinary namespace\");\n    IdentifierNamespace |= IDNS_NonMemberOperator;\n  }\n\n  static bool classofKind(Kind K) { return true; }\n  static DeclContext *castToDeclContext(const Decl *);\n  static Decl *castFromDeclContext(const DeclContext *);\n\n  void print(raw_ostream &Out, unsigned Indentation = 0,\n             bool PrintInstantiation = false) const;\n  void print(raw_ostream &Out, const PrintingPolicy &Policy,\n             unsigned Indentation = 0, bool PrintInstantiation = false) const;\n  static void printGroup(Decl** Begin, unsigned NumDecls,\n                         raw_ostream &Out, const PrintingPolicy &Policy,\n                         unsigned Indentation = 0);\n\n  // Debuggers don't usually respect default arguments.\n  void dump() const;\n\n  // Same as dump(), but forces color printing.\n  void dumpColor() const;\n\n  void dump(raw_ostream &Out, bool Deserialize = false,\n            ASTDumpOutputFormat OutputFormat = ADOF_Default) const;\n\n  /// \\return Unique reproducible object identifier\n  int64_t getID() const;\n\n  /// Looks through the Decl's underlying type to extract a FunctionType\n  /// when possible. Will return null if the type underlying the Decl does not\n  /// have a FunctionType.\n  const FunctionType *getFunctionType(bool BlocksToo = true) const;\n\nprivate:\n  void setAttrsImpl(const AttrVec& Attrs, ASTContext &Ctx);\n  void setDeclContextsImpl(DeclContext *SemaDC, DeclContext *LexicalDC,\n                           ASTContext &Ctx);\n\nprotected:\n  ASTMutationListener *getASTMutationListener() const;\n};\n\n/// Determine whether two declarations declare the same entity.\ninline bool declaresSameEntity(const Decl *D1, const Decl *D2) {\n  if (!D1 || !D2)\n    return false;\n\n  if (D1 == D2)\n    return true;\n\n  return D1->getCanonicalDecl() == D2->getCanonicalDecl();\n}\n\n/// PrettyStackTraceDecl - If a crash occurs, indicate that it happened when\n/// doing something to a specific decl.\nclass PrettyStackTraceDecl : public llvm::PrettyStackTraceEntry {\n  const Decl *TheDecl;\n  SourceLocation Loc;\n  SourceManager &SM;\n  const char *Message;\n\npublic:\n  PrettyStackTraceDecl(const Decl *theDecl, SourceLocation L,\n                       SourceManager &sm, const char *Msg)\n      : TheDecl(theDecl), Loc(L), SM(sm), Message(Msg) {}\n\n  void print(raw_ostream &OS) const override;\n};\n\n/// The results of name lookup within a DeclContext. This is either a\n/// single result (with no stable storage) or a collection of results (with\n/// stable storage provided by the lookup table).\nclass DeclContextLookupResult {\n  using ResultTy = ArrayRef<NamedDecl *>;\n\n  ResultTy Result;\n\n  // If there is only one lookup result, it would be invalidated by\n  // reallocations of the name table, so store it separately.\n  NamedDecl *Single = nullptr;\n\n  static NamedDecl *const SingleElementDummyList;\n\npublic:\n  DeclContextLookupResult() = default;\n  DeclContextLookupResult(ArrayRef<NamedDecl *> Result)\n      : Result(Result) {}\n  DeclContextLookupResult(NamedDecl *Single)\n      : Result(SingleElementDummyList), Single(Single) {}\n\n  class iterator;\n\n  using IteratorBase =\n      llvm::iterator_adaptor_base<iterator, ResultTy::iterator,\n                                  std::random_access_iterator_tag, NamedDecl *>;\n\n  class iterator : public IteratorBase {\n    value_type SingleElement;\n\n  public:\n    explicit iterator(pointer Pos, value_type Single = nullptr)\n        : IteratorBase(Pos), SingleElement(Single) {}\n\n    reference operator*() const {\n      return SingleElement ? SingleElement : IteratorBase::operator*();\n    }\n  };\n\n  using const_iterator = iterator;\n  using pointer = iterator::pointer;\n  using reference = iterator::reference;\n\n  iterator begin() const { return iterator(Result.begin(), Single); }\n  iterator end() const { return iterator(Result.end(), Single); }\n\n  bool empty() const { return Result.empty(); }\n  pointer data() const { return Single ? &Single : Result.data(); }\n  size_t size() const { return Single ? 1 : Result.size(); }\n  reference front() const { return Single ? Single : Result.front(); }\n  reference back() const { return Single ? Single : Result.back(); }\n  reference operator[](size_t N) const { return Single ? Single : Result[N]; }\n\n  // FIXME: Remove this from the interface\n  DeclContextLookupResult slice(size_t N) const {\n    DeclContextLookupResult Sliced = Result.slice(N);\n    Sliced.Single = Single;\n    return Sliced;\n  }\n};\n\n/// DeclContext - This is used only as base class of specific decl types that\n/// can act as declaration contexts. These decls are (only the top classes\n/// that directly derive from DeclContext are mentioned, not their subclasses):\n///\n///   TranslationUnitDecl\n///   ExternCContext\n///   NamespaceDecl\n///   TagDecl\n///   OMPDeclareReductionDecl\n///   OMPDeclareMapperDecl\n///   FunctionDecl\n///   ObjCMethodDecl\n///   ObjCContainerDecl\n///   LinkageSpecDecl\n///   ExportDecl\n///   BlockDecl\n///   CapturedDecl\nclass DeclContext {\n  /// For makeDeclVisibleInContextImpl\n  friend class ASTDeclReader;\n  /// For reconcileExternalVisibleStorage, CreateStoredDeclsMap,\n  /// hasNeedToReconcileExternalVisibleStorage\n  friend class ExternalASTSource;\n  /// For CreateStoredDeclsMap\n  friend class DependentDiagnostic;\n  /// For hasNeedToReconcileExternalVisibleStorage,\n  /// hasLazyLocalLexicalLookups, hasLazyExternalLexicalLookups\n  friend class ASTWriter;\n\n  // We use uint64_t in the bit-fields below since some bit-fields\n  // cross the unsigned boundary and this breaks the packing.\n\n  /// Stores the bits used by DeclContext.\n  /// If modified NumDeclContextBit, the ctor of DeclContext and the accessor\n  /// methods in DeclContext should be updated appropriately.\n  class DeclContextBitfields {\n    friend class DeclContext;\n    /// DeclKind - This indicates which class this is.\n    uint64_t DeclKind : 7;\n\n    /// Whether this declaration context also has some external\n    /// storage that contains additional declarations that are lexically\n    /// part of this context.\n    mutable uint64_t ExternalLexicalStorage : 1;\n\n    /// Whether this declaration context also has some external\n    /// storage that contains additional declarations that are visible\n    /// in this context.\n    mutable uint64_t ExternalVisibleStorage : 1;\n\n    /// Whether this declaration context has had externally visible\n    /// storage added since the last lookup. In this case, \\c LookupPtr's\n    /// invariant may not hold and needs to be fixed before we perform\n    /// another lookup.\n    mutable uint64_t NeedToReconcileExternalVisibleStorage : 1;\n\n    /// If \\c true, this context may have local lexical declarations\n    /// that are missing from the lookup table.\n    mutable uint64_t HasLazyLocalLexicalLookups : 1;\n\n    /// If \\c true, the external source may have lexical declarations\n    /// that are missing from the lookup table.\n    mutable uint64_t HasLazyExternalLexicalLookups : 1;\n\n    /// If \\c true, lookups should only return identifier from\n    /// DeclContext scope (for example TranslationUnit). Used in\n    /// LookupQualifiedName()\n    mutable uint64_t UseQualifiedLookup : 1;\n  };\n\n  /// Number of bits in DeclContextBitfields.\n  enum { NumDeclContextBits = 13 };\n\n  /// Stores the bits used by TagDecl.\n  /// If modified NumTagDeclBits and the accessor\n  /// methods in TagDecl should be updated appropriately.\n  class TagDeclBitfields {\n    friend class TagDecl;\n    /// For the bits in DeclContextBitfields\n    uint64_t : NumDeclContextBits;\n\n    /// The TagKind enum.\n    uint64_t TagDeclKind : 3;\n\n    /// True if this is a definition (\"struct foo {};\"), false if it is a\n    /// declaration (\"struct foo;\").  It is not considered a definition\n    /// until the definition has been fully processed.\n    uint64_t IsCompleteDefinition : 1;\n\n    /// True if this is currently being defined.\n    uint64_t IsBeingDefined : 1;\n\n    /// True if this tag declaration is \"embedded\" (i.e., defined or declared\n    /// for the very first time) in the syntax of a declarator.\n    uint64_t IsEmbeddedInDeclarator : 1;\n\n    /// True if this tag is free standing, e.g. \"struct foo;\".\n    uint64_t IsFreeStanding : 1;\n\n    /// Indicates whether it is possible for declarations of this kind\n    /// to have an out-of-date definition.\n    ///\n    /// This option is only enabled when modules are enabled.\n    uint64_t MayHaveOutOfDateDef : 1;\n\n    /// Has the full definition of this type been required by a use somewhere in\n    /// the TU.\n    uint64_t IsCompleteDefinitionRequired : 1;\n  };\n\n  /// Number of non-inherited bits in TagDeclBitfields.\n  enum { NumTagDeclBits = 9 };\n\n  /// Stores the bits used by EnumDecl.\n  /// If modified NumEnumDeclBit and the accessor\n  /// methods in EnumDecl should be updated appropriately.\n  class EnumDeclBitfields {\n    friend class EnumDecl;\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n    /// For the bits in TagDeclBitfields.\n    uint64_t : NumTagDeclBits;\n\n    /// Width in bits required to store all the non-negative\n    /// enumerators of this enum.\n    uint64_t NumPositiveBits : 8;\n\n    /// Width in bits required to store all the negative\n    /// enumerators of this enum.\n    uint64_t NumNegativeBits : 8;\n\n    /// True if this tag declaration is a scoped enumeration. Only\n    /// possible in C++11 mode.\n    uint64_t IsScoped : 1;\n\n    /// If this tag declaration is a scoped enum,\n    /// then this is true if the scoped enum was declared using the class\n    /// tag, false if it was declared with the struct tag. No meaning is\n    /// associated if this tag declaration is not a scoped enum.\n    uint64_t IsScopedUsingClassTag : 1;\n\n    /// True if this is an enumeration with fixed underlying type. Only\n    /// possible in C++11, Microsoft extensions, or Objective C mode.\n    uint64_t IsFixed : 1;\n\n    /// True if a valid hash is stored in ODRHash.\n    uint64_t HasODRHash : 1;\n  };\n\n  /// Number of non-inherited bits in EnumDeclBitfields.\n  enum { NumEnumDeclBits = 20 };\n\n  /// Stores the bits used by RecordDecl.\n  /// If modified NumRecordDeclBits and the accessor\n  /// methods in RecordDecl should be updated appropriately.\n  class RecordDeclBitfields {\n    friend class RecordDecl;\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n    /// For the bits in TagDeclBitfields.\n    uint64_t : NumTagDeclBits;\n\n    /// This is true if this struct ends with a flexible\n    /// array member (e.g. int X[]) or if this union contains a struct that does.\n    /// If so, this cannot be contained in arrays or other structs as a member.\n    uint64_t HasFlexibleArrayMember : 1;\n\n    /// Whether this is the type of an anonymous struct or union.\n    uint64_t AnonymousStructOrUnion : 1;\n\n    /// This is true if this struct has at least one member\n    /// containing an Objective-C object pointer type.\n    uint64_t HasObjectMember : 1;\n\n    /// This is true if struct has at least one member of\n    /// 'volatile' type.\n    uint64_t HasVolatileMember : 1;\n\n    /// Whether the field declarations of this record have been loaded\n    /// from external storage. To avoid unnecessary deserialization of\n    /// methods/nested types we allow deserialization of just the fields\n    /// when needed.\n    mutable uint64_t LoadedFieldsFromExternalStorage : 1;\n\n    /// Basic properties of non-trivial C structs.\n    uint64_t NonTrivialToPrimitiveDefaultInitialize : 1;\n    uint64_t NonTrivialToPrimitiveCopy : 1;\n    uint64_t NonTrivialToPrimitiveDestroy : 1;\n\n    /// The following bits indicate whether this is or contains a C union that\n    /// is non-trivial to default-initialize, destruct, or copy. These bits\n    /// imply the associated basic non-triviality predicates declared above.\n    uint64_t HasNonTrivialToPrimitiveDefaultInitializeCUnion : 1;\n    uint64_t HasNonTrivialToPrimitiveDestructCUnion : 1;\n    uint64_t HasNonTrivialToPrimitiveCopyCUnion : 1;\n\n    /// Indicates whether this struct is destroyed in the callee.\n    uint64_t ParamDestroyedInCallee : 1;\n\n    /// Represents the way this type is passed to a function.\n    uint64_t ArgPassingRestrictions : 2;\n  };\n\n  /// Number of non-inherited bits in RecordDeclBitfields.\n  enum { NumRecordDeclBits = 14 };\n\n  /// Stores the bits used by OMPDeclareReductionDecl.\n  /// If modified NumOMPDeclareReductionDeclBits and the accessor\n  /// methods in OMPDeclareReductionDecl should be updated appropriately.\n  class OMPDeclareReductionDeclBitfields {\n    friend class OMPDeclareReductionDecl;\n    /// For the bits in DeclContextBitfields\n    uint64_t : NumDeclContextBits;\n\n    /// Kind of initializer,\n    /// function call or omp_priv<init_expr> initializtion.\n    uint64_t InitializerKind : 2;\n  };\n\n  /// Number of non-inherited bits in OMPDeclareReductionDeclBitfields.\n  enum { NumOMPDeclareReductionDeclBits = 2 };\n\n  /// Stores the bits used by FunctionDecl.\n  /// If modified NumFunctionDeclBits and the accessor\n  /// methods in FunctionDecl and CXXDeductionGuideDecl\n  /// (for IsCopyDeductionCandidate) should be updated appropriately.\n  class FunctionDeclBitfields {\n    friend class FunctionDecl;\n    /// For IsCopyDeductionCandidate\n    friend class CXXDeductionGuideDecl;\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n\n    uint64_t SClass : 3;\n    uint64_t IsInline : 1;\n    uint64_t IsInlineSpecified : 1;\n\n    uint64_t IsVirtualAsWritten : 1;\n    uint64_t IsPure : 1;\n    uint64_t HasInheritedPrototype : 1;\n    uint64_t HasWrittenPrototype : 1;\n    uint64_t IsDeleted : 1;\n    /// Used by CXXMethodDecl\n    uint64_t IsTrivial : 1;\n\n    /// This flag indicates whether this function is trivial for the purpose of\n    /// calls. This is meaningful only when this function is a copy/move\n    /// constructor or a destructor.\n    uint64_t IsTrivialForCall : 1;\n\n    uint64_t IsDefaulted : 1;\n    uint64_t IsExplicitlyDefaulted : 1;\n    uint64_t HasDefaultedFunctionInfo : 1;\n    uint64_t HasImplicitReturnZero : 1;\n    uint64_t IsLateTemplateParsed : 1;\n\n    /// Kind of contexpr specifier as defined by ConstexprSpecKind.\n    uint64_t ConstexprKind : 2;\n    uint64_t InstantiationIsPending : 1;\n\n    /// Indicates if the function uses __try.\n    uint64_t UsesSEHTry : 1;\n\n    /// Indicates if the function was a definition\n    /// but its body was skipped.\n    uint64_t HasSkippedBody : 1;\n\n    /// Indicates if the function declaration will\n    /// have a body, once we're done parsing it.\n    uint64_t WillHaveBody : 1;\n\n    /// Indicates that this function is a multiversioned\n    /// function using attribute 'target'.\n    uint64_t IsMultiVersion : 1;\n\n    /// [C++17] Only used by CXXDeductionGuideDecl. Indicates that\n    /// the Deduction Guide is the implicitly generated 'copy\n    /// deduction candidate' (is used during overload resolution).\n    uint64_t IsCopyDeductionCandidate : 1;\n\n    /// Store the ODRHash after first calculation.\n    uint64_t HasODRHash : 1;\n\n    /// Indicates if the function uses Floating Point Constrained Intrinsics\n    uint64_t UsesFPIntrin : 1;\n  };\n\n  /// Number of non-inherited bits in FunctionDeclBitfields.\n  enum { NumFunctionDeclBits = 27 };\n\n  /// Stores the bits used by CXXConstructorDecl. If modified\n  /// NumCXXConstructorDeclBits and the accessor\n  /// methods in CXXConstructorDecl should be updated appropriately.\n  class CXXConstructorDeclBitfields {\n    friend class CXXConstructorDecl;\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n    /// For the bits in FunctionDeclBitfields.\n    uint64_t : NumFunctionDeclBits;\n\n    /// 24 bits to fit in the remaining available space.\n    /// Note that this makes CXXConstructorDeclBitfields take\n    /// exactly 64 bits and thus the width of NumCtorInitializers\n    /// will need to be shrunk if some bit is added to NumDeclContextBitfields,\n    /// NumFunctionDeclBitfields or CXXConstructorDeclBitfields.\n    uint64_t NumCtorInitializers : 21;\n    uint64_t IsInheritingConstructor : 1;\n\n    /// Whether this constructor has a trail-allocated explicit specifier.\n    uint64_t HasTrailingExplicitSpecifier : 1;\n    /// If this constructor does't have a trail-allocated explicit specifier.\n    /// Whether this constructor is explicit specified.\n    uint64_t IsSimpleExplicit : 1;\n  };\n\n  /// Number of non-inherited bits in CXXConstructorDeclBitfields.\n  enum {\n    NumCXXConstructorDeclBits = 64 - NumDeclContextBits - NumFunctionDeclBits\n  };\n\n  /// Stores the bits used by ObjCMethodDecl.\n  /// If modified NumObjCMethodDeclBits and the accessor\n  /// methods in ObjCMethodDecl should be updated appropriately.\n  class ObjCMethodDeclBitfields {\n    friend class ObjCMethodDecl;\n\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n\n    /// The conventional meaning of this method; an ObjCMethodFamily.\n    /// This is not serialized; instead, it is computed on demand and\n    /// cached.\n    mutable uint64_t Family : ObjCMethodFamilyBitWidth;\n\n    /// instance (true) or class (false) method.\n    uint64_t IsInstance : 1;\n    uint64_t IsVariadic : 1;\n\n    /// True if this method is the getter or setter for an explicit property.\n    uint64_t IsPropertyAccessor : 1;\n\n    /// True if this method is a synthesized property accessor stub.\n    uint64_t IsSynthesizedAccessorStub : 1;\n\n    /// Method has a definition.\n    uint64_t IsDefined : 1;\n\n    /// Method redeclaration in the same interface.\n    uint64_t IsRedeclaration : 1;\n\n    /// Is redeclared in the same interface.\n    mutable uint64_t HasRedeclaration : 1;\n\n    /// \\@required/\\@optional\n    uint64_t DeclImplementation : 2;\n\n    /// in, inout, etc.\n    uint64_t objcDeclQualifier : 7;\n\n    /// Indicates whether this method has a related result type.\n    uint64_t RelatedResultType : 1;\n\n    /// Whether the locations of the selector identifiers are in a\n    /// \"standard\" position, a enum SelectorLocationsKind.\n    uint64_t SelLocsKind : 2;\n\n    /// Whether this method overrides any other in the class hierarchy.\n    ///\n    /// A method is said to override any method in the class's\n    /// base classes, its protocols, or its categories' protocols, that has\n    /// the same selector and is of the same kind (class or instance).\n    /// A method in an implementation is not considered as overriding the same\n    /// method in the interface or its categories.\n    uint64_t IsOverriding : 1;\n\n    /// Indicates if the method was a definition but its body was skipped.\n    uint64_t HasSkippedBody : 1;\n  };\n\n  /// Number of non-inherited bits in ObjCMethodDeclBitfields.\n  enum { NumObjCMethodDeclBits = 24 };\n\n  /// Stores the bits used by ObjCContainerDecl.\n  /// If modified NumObjCContainerDeclBits and the accessor\n  /// methods in ObjCContainerDecl should be updated appropriately.\n  class ObjCContainerDeclBitfields {\n    friend class ObjCContainerDecl;\n    /// For the bits in DeclContextBitfields\n    uint32_t : NumDeclContextBits;\n\n    // Not a bitfield but this saves space.\n    // Note that ObjCContainerDeclBitfields is full.\n    SourceLocation AtStart;\n  };\n\n  /// Number of non-inherited bits in ObjCContainerDeclBitfields.\n  /// Note that here we rely on the fact that SourceLocation is 32 bits\n  /// wide. We check this with the static_assert in the ctor of DeclContext.\n  enum { NumObjCContainerDeclBits = 64 - NumDeclContextBits };\n\n  /// Stores the bits used by LinkageSpecDecl.\n  /// If modified NumLinkageSpecDeclBits and the accessor\n  /// methods in LinkageSpecDecl should be updated appropriately.\n  class LinkageSpecDeclBitfields {\n    friend class LinkageSpecDecl;\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n\n    /// The language for this linkage specification with values\n    /// in the enum LinkageSpecDecl::LanguageIDs.\n    uint64_t Language : 3;\n\n    /// True if this linkage spec has braces.\n    /// This is needed so that hasBraces() returns the correct result while the\n    /// linkage spec body is being parsed.  Once RBraceLoc has been set this is\n    /// not used, so it doesn't need to be serialized.\n    uint64_t HasBraces : 1;\n  };\n\n  /// Number of non-inherited bits in LinkageSpecDeclBitfields.\n  enum { NumLinkageSpecDeclBits = 4 };\n\n  /// Stores the bits used by BlockDecl.\n  /// If modified NumBlockDeclBits and the accessor\n  /// methods in BlockDecl should be updated appropriately.\n  class BlockDeclBitfields {\n    friend class BlockDecl;\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n\n    uint64_t IsVariadic : 1;\n    uint64_t CapturesCXXThis : 1;\n    uint64_t BlockMissingReturnType : 1;\n    uint64_t IsConversionFromLambda : 1;\n\n    /// A bit that indicates this block is passed directly to a function as a\n    /// non-escaping parameter.\n    uint64_t DoesNotEscape : 1;\n\n    /// A bit that indicates whether it's possible to avoid coying this block to\n    /// the heap when it initializes or is assigned to a local variable with\n    /// automatic storage.\n    uint64_t CanAvoidCopyToHeap : 1;\n  };\n\n  /// Number of non-inherited bits in BlockDeclBitfields.\n  enum { NumBlockDeclBits = 5 };\n\n  /// Pointer to the data structure used to lookup declarations\n  /// within this context (or a DependentStoredDeclsMap if this is a\n  /// dependent context). We maintain the invariant that, if the map\n  /// contains an entry for a DeclarationName (and we haven't lazily\n  /// omitted anything), then it contains all relevant entries for that\n  /// name (modulo the hasExternalDecls() flag).\n  mutable StoredDeclsMap *LookupPtr = nullptr;\n\nprotected:\n  /// This anonymous union stores the bits belonging to DeclContext and classes\n  /// deriving from it. The goal is to use otherwise wasted\n  /// space in DeclContext to store data belonging to derived classes.\n  /// The space saved is especially significient when pointers are aligned\n  /// to 8 bytes. In this case due to alignment requirements we have a\n  /// little less than 8 bytes free in DeclContext which we can use.\n  /// We check that none of the classes in this union is larger than\n  /// 8 bytes with static_asserts in the ctor of DeclContext.\n  union {\n    DeclContextBitfields DeclContextBits;\n    TagDeclBitfields TagDeclBits;\n    EnumDeclBitfields EnumDeclBits;\n    RecordDeclBitfields RecordDeclBits;\n    OMPDeclareReductionDeclBitfields OMPDeclareReductionDeclBits;\n    FunctionDeclBitfields FunctionDeclBits;\n    CXXConstructorDeclBitfields CXXConstructorDeclBits;\n    ObjCMethodDeclBitfields ObjCMethodDeclBits;\n    ObjCContainerDeclBitfields ObjCContainerDeclBits;\n    LinkageSpecDeclBitfields LinkageSpecDeclBits;\n    BlockDeclBitfields BlockDeclBits;\n\n    static_assert(sizeof(DeclContextBitfields) <= 8,\n                  \"DeclContextBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(TagDeclBitfields) <= 8,\n                  \"TagDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(EnumDeclBitfields) <= 8,\n                  \"EnumDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(RecordDeclBitfields) <= 8,\n                  \"RecordDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(OMPDeclareReductionDeclBitfields) <= 8,\n                  \"OMPDeclareReductionDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(FunctionDeclBitfields) <= 8,\n                  \"FunctionDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(CXXConstructorDeclBitfields) <= 8,\n                  \"CXXConstructorDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(ObjCMethodDeclBitfields) <= 8,\n                  \"ObjCMethodDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(ObjCContainerDeclBitfields) <= 8,\n                  \"ObjCContainerDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(LinkageSpecDeclBitfields) <= 8,\n                  \"LinkageSpecDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(BlockDeclBitfields) <= 8,\n                  \"BlockDeclBitfields is larger than 8 bytes!\");\n  };\n\n  /// FirstDecl - The first declaration stored within this declaration\n  /// context.\n  mutable Decl *FirstDecl = nullptr;\n\n  /// LastDecl - The last declaration stored within this declaration\n  /// context. FIXME: We could probably cache this value somewhere\n  /// outside of the DeclContext, to reduce the size of DeclContext by\n  /// another pointer.\n  mutable Decl *LastDecl = nullptr;\n\n  /// Build up a chain of declarations.\n  ///\n  /// \\returns the first/last pair of declarations.\n  static std::pair<Decl *, Decl *>\n  BuildDeclChain(ArrayRef<Decl*> Decls, bool FieldsAlreadyLoaded);\n\n  DeclContext(Decl::Kind K);\n\npublic:\n  ~DeclContext();\n\n  Decl::Kind getDeclKind() const {\n    return static_cast<Decl::Kind>(DeclContextBits.DeclKind);\n  }\n\n  const char *getDeclKindName() const;\n\n  /// getParent - Returns the containing DeclContext.\n  DeclContext *getParent() {\n    return cast<Decl>(this)->getDeclContext();\n  }\n  const DeclContext *getParent() const {\n    return const_cast<DeclContext*>(this)->getParent();\n  }\n\n  /// getLexicalParent - Returns the containing lexical DeclContext. May be\n  /// different from getParent, e.g.:\n  ///\n  ///   namespace A {\n  ///      struct S;\n  ///   }\n  ///   struct A::S {}; // getParent() == namespace 'A'\n  ///                   // getLexicalParent() == translation unit\n  ///\n  DeclContext *getLexicalParent() {\n    return cast<Decl>(this)->getLexicalDeclContext();\n  }\n  const DeclContext *getLexicalParent() const {\n    return const_cast<DeclContext*>(this)->getLexicalParent();\n  }\n\n  DeclContext *getLookupParent();\n\n  const DeclContext *getLookupParent() const {\n    return const_cast<DeclContext*>(this)->getLookupParent();\n  }\n\n  ASTContext &getParentASTContext() const {\n    return cast<Decl>(this)->getASTContext();\n  }\n\n  bool isClosure() const { return getDeclKind() == Decl::Block; }\n\n  /// Return this DeclContext if it is a BlockDecl. Otherwise, return the\n  /// innermost enclosing BlockDecl or null if there are no enclosing blocks.\n  const BlockDecl *getInnermostBlockDecl() const;\n\n  bool isObjCContainer() const {\n    switch (getDeclKind()) {\n    case Decl::ObjCCategory:\n    case Decl::ObjCCategoryImpl:\n    case Decl::ObjCImplementation:\n    case Decl::ObjCInterface:\n    case Decl::ObjCProtocol:\n      return true;\n    default:\n      return false;\n    }\n  }\n\n  bool isFunctionOrMethod() const {\n    switch (getDeclKind()) {\n    case Decl::Block:\n    case Decl::Captured:\n    case Decl::ObjCMethod:\n      return true;\n    default:\n      return getDeclKind() >= Decl::firstFunction &&\n             getDeclKind() <= Decl::lastFunction;\n    }\n  }\n\n  /// Test whether the context supports looking up names.\n  bool isLookupContext() const {\n    return !isFunctionOrMethod() && getDeclKind() != Decl::LinkageSpec &&\n           getDeclKind() != Decl::Export;\n  }\n\n  bool isFileContext() const {\n    return getDeclKind() == Decl::TranslationUnit ||\n           getDeclKind() == Decl::Namespace;\n  }\n\n  bool isTranslationUnit() const {\n    return getDeclKind() == Decl::TranslationUnit;\n  }\n\n  bool isRecord() const {\n    return getDeclKind() >= Decl::firstRecord &&\n           getDeclKind() <= Decl::lastRecord;\n  }\n\n  bool isNamespace() const { return getDeclKind() == Decl::Namespace; }\n\n  bool isStdNamespace() const;\n\n  bool isInlineNamespace() const;\n\n  /// Determines whether this context is dependent on a\n  /// template parameter.\n  bool isDependentContext() const;\n\n  /// isTransparentContext - Determines whether this context is a\n  /// \"transparent\" context, meaning that the members declared in this\n  /// context are semantically declared in the nearest enclosing\n  /// non-transparent (opaque) context but are lexically declared in\n  /// this context. For example, consider the enumerators of an\n  /// enumeration type:\n  /// @code\n  /// enum E {\n  ///   Val1\n  /// };\n  /// @endcode\n  /// Here, E is a transparent context, so its enumerator (Val1) will\n  /// appear (semantically) that it is in the same context of E.\n  /// Examples of transparent contexts include: enumerations (except for\n  /// C++0x scoped enums), and C++ linkage specifications.\n  bool isTransparentContext() const;\n\n  /// Determines whether this context or some of its ancestors is a\n  /// linkage specification context that specifies C linkage.\n  bool isExternCContext() const;\n\n  /// Retrieve the nearest enclosing C linkage specification context.\n  const LinkageSpecDecl *getExternCContext() const;\n\n  /// Determines whether this context or some of its ancestors is a\n  /// linkage specification context that specifies C++ linkage.\n  bool isExternCXXContext() const;\n\n  /// Determine whether this declaration context is equivalent\n  /// to the declaration context DC.\n  bool Equals(const DeclContext *DC) const {\n    return DC && this->getPrimaryContext() == DC->getPrimaryContext();\n  }\n\n  /// Determine whether this declaration context encloses the\n  /// declaration context DC.\n  bool Encloses(const DeclContext *DC) const;\n\n  /// Find the nearest non-closure ancestor of this context,\n  /// i.e. the innermost semantic parent of this context which is not\n  /// a closure.  A context may be its own non-closure ancestor.\n  Decl *getNonClosureAncestor();\n  const Decl *getNonClosureAncestor() const {\n    return const_cast<DeclContext*>(this)->getNonClosureAncestor();\n  }\n\n  /// getPrimaryContext - There may be many different\n  /// declarations of the same entity (including forward declarations\n  /// of classes, multiple definitions of namespaces, etc.), each with\n  /// a different set of declarations. This routine returns the\n  /// \"primary\" DeclContext structure, which will contain the\n  /// information needed to perform name lookup into this context.\n  DeclContext *getPrimaryContext();\n  const DeclContext *getPrimaryContext() const {\n    return const_cast<DeclContext*>(this)->getPrimaryContext();\n  }\n\n  /// getRedeclContext - Retrieve the context in which an entity conflicts with\n  /// other entities of the same name, or where it is a redeclaration if the\n  /// two entities are compatible. This skips through transparent contexts.\n  DeclContext *getRedeclContext();\n  const DeclContext *getRedeclContext() const {\n    return const_cast<DeclContext *>(this)->getRedeclContext();\n  }\n\n  /// Retrieve the nearest enclosing namespace context.\n  DeclContext *getEnclosingNamespaceContext();\n  const DeclContext *getEnclosingNamespaceContext() const {\n    return const_cast<DeclContext *>(this)->getEnclosingNamespaceContext();\n  }\n\n  /// Retrieve the outermost lexically enclosing record context.\n  RecordDecl *getOuterLexicalRecordContext();\n  const RecordDecl *getOuterLexicalRecordContext() const {\n    return const_cast<DeclContext *>(this)->getOuterLexicalRecordContext();\n  }\n\n  /// Test if this context is part of the enclosing namespace set of\n  /// the context NS, as defined in C++0x [namespace.def]p9. If either context\n  /// isn't a namespace, this is equivalent to Equals().\n  ///\n  /// The enclosing namespace set of a namespace is the namespace and, if it is\n  /// inline, its enclosing namespace, recursively.\n  bool InEnclosingNamespaceSetOf(const DeclContext *NS) const;\n\n  /// Collects all of the declaration contexts that are semantically\n  /// connected to this declaration context.\n  ///\n  /// For declaration contexts that have multiple semantically connected but\n  /// syntactically distinct contexts, such as C++ namespaces, this routine\n  /// retrieves the complete set of such declaration contexts in source order.\n  /// For example, given:\n  ///\n  /// \\code\n  /// namespace N {\n  ///   int x;\n  /// }\n  /// namespace N {\n  ///   int y;\n  /// }\n  /// \\endcode\n  ///\n  /// The \\c Contexts parameter will contain both definitions of N.\n  ///\n  /// \\param Contexts Will be cleared and set to the set of declaration\n  /// contexts that are semanticaly connected to this declaration context,\n  /// in source order, including this context (which may be the only result,\n  /// for non-namespace contexts).\n  void collectAllContexts(SmallVectorImpl<DeclContext *> &Contexts);\n\n  /// decl_iterator - Iterates through the declarations stored\n  /// within this context.\n  class decl_iterator {\n    /// Current - The current declaration.\n    Decl *Current = nullptr;\n\n  public:\n    using value_type = Decl *;\n    using reference = const value_type &;\n    using pointer = const value_type *;\n    using iterator_category = std::forward_iterator_tag;\n    using difference_type = std::ptrdiff_t;\n\n    decl_iterator() = default;\n    explicit decl_iterator(Decl *C) : Current(C) {}\n\n    reference operator*() const { return Current; }\n\n    // This doesn't meet the iterator requirements, but it's convenient\n    value_type operator->() const { return Current; }\n\n    decl_iterator& operator++() {\n      Current = Current->getNextDeclInContext();\n      return *this;\n    }\n\n    decl_iterator operator++(int) {\n      decl_iterator tmp(*this);\n      ++(*this);\n      return tmp;\n    }\n\n    friend bool operator==(decl_iterator x, decl_iterator y) {\n      return x.Current == y.Current;\n    }\n\n    friend bool operator!=(decl_iterator x, decl_iterator y) {\n      return x.Current != y.Current;\n    }\n  };\n\n  using decl_range = llvm::iterator_range<decl_iterator>;\n\n  /// decls_begin/decls_end - Iterate over the declarations stored in\n  /// this context.\n  decl_range decls() const { return decl_range(decls_begin(), decls_end()); }\n  decl_iterator decls_begin() const;\n  decl_iterator decls_end() const { return decl_iterator(); }\n  bool decls_empty() const;\n\n  /// noload_decls_begin/end - Iterate over the declarations stored in this\n  /// context that are currently loaded; don't attempt to retrieve anything\n  /// from an external source.\n  decl_range noload_decls() const {\n    return decl_range(noload_decls_begin(), noload_decls_end());\n  }\n  decl_iterator noload_decls_begin() const { return decl_iterator(FirstDecl); }\n  decl_iterator noload_decls_end() const { return decl_iterator(); }\n\n  /// specific_decl_iterator - Iterates over a subrange of\n  /// declarations stored in a DeclContext, providing only those that\n  /// are of type SpecificDecl (or a class derived from it). This\n  /// iterator is used, for example, to provide iteration over just\n  /// the fields within a RecordDecl (with SpecificDecl = FieldDecl).\n  template<typename SpecificDecl>\n  class specific_decl_iterator {\n    /// Current - The current, underlying declaration iterator, which\n    /// will either be NULL or will point to a declaration of\n    /// type SpecificDecl.\n    DeclContext::decl_iterator Current;\n\n    /// SkipToNextDecl - Advances the current position up to the next\n    /// declaration of type SpecificDecl that also meets the criteria\n    /// required by Acceptable.\n    void SkipToNextDecl() {\n      while (*Current && !isa<SpecificDecl>(*Current))\n        ++Current;\n    }\n\n  public:\n    using value_type = SpecificDecl *;\n    // TODO: Add reference and pointer types (with some appropriate proxy type)\n    // if we ever have a need for them.\n    using reference = void;\n    using pointer = void;\n    using difference_type =\n        std::iterator_traits<DeclContext::decl_iterator>::difference_type;\n    using iterator_category = std::forward_iterator_tag;\n\n    specific_decl_iterator() = default;\n\n    /// specific_decl_iterator - Construct a new iterator over a\n    /// subset of the declarations the range [C,\n    /// end-of-declarations). If A is non-NULL, it is a pointer to a\n    /// member function of SpecificDecl that should return true for\n    /// all of the SpecificDecl instances that will be in the subset\n    /// of iterators. For example, if you want Objective-C instance\n    /// methods, SpecificDecl will be ObjCMethodDecl and A will be\n    /// &ObjCMethodDecl::isInstanceMethod.\n    explicit specific_decl_iterator(DeclContext::decl_iterator C) : Current(C) {\n      SkipToNextDecl();\n    }\n\n    value_type operator*() const { return cast<SpecificDecl>(*Current); }\n\n    // This doesn't meet the iterator requirements, but it's convenient\n    value_type operator->() const { return **this; }\n\n    specific_decl_iterator& operator++() {\n      ++Current;\n      SkipToNextDecl();\n      return *this;\n    }\n\n    specific_decl_iterator operator++(int) {\n      specific_decl_iterator tmp(*this);\n      ++(*this);\n      return tmp;\n    }\n\n    friend bool operator==(const specific_decl_iterator& x,\n                           const specific_decl_iterator& y) {\n      return x.Current == y.Current;\n    }\n\n    friend bool operator!=(const specific_decl_iterator& x,\n                           const specific_decl_iterator& y) {\n      return x.Current != y.Current;\n    }\n  };\n\n  /// Iterates over a filtered subrange of declarations stored\n  /// in a DeclContext.\n  ///\n  /// This iterator visits only those declarations that are of type\n  /// SpecificDecl (or a class derived from it) and that meet some\n  /// additional run-time criteria. This iterator is used, for\n  /// example, to provide access to the instance methods within an\n  /// Objective-C interface (with SpecificDecl = ObjCMethodDecl and\n  /// Acceptable = ObjCMethodDecl::isInstanceMethod).\n  template<typename SpecificDecl, bool (SpecificDecl::*Acceptable)() const>\n  class filtered_decl_iterator {\n    /// Current - The current, underlying declaration iterator, which\n    /// will either be NULL or will point to a declaration of\n    /// type SpecificDecl.\n    DeclContext::decl_iterator Current;\n\n    /// SkipToNextDecl - Advances the current position up to the next\n    /// declaration of type SpecificDecl that also meets the criteria\n    /// required by Acceptable.\n    void SkipToNextDecl() {\n      while (*Current &&\n             (!isa<SpecificDecl>(*Current) ||\n              (Acceptable && !(cast<SpecificDecl>(*Current)->*Acceptable)())))\n        ++Current;\n    }\n\n  public:\n    using value_type = SpecificDecl *;\n    // TODO: Add reference and pointer types (with some appropriate proxy type)\n    // if we ever have a need for them.\n    using reference = void;\n    using pointer = void;\n    using difference_type =\n        std::iterator_traits<DeclContext::decl_iterator>::difference_type;\n    using iterator_category = std::forward_iterator_tag;\n\n    filtered_decl_iterator() = default;\n\n    /// filtered_decl_iterator - Construct a new iterator over a\n    /// subset of the declarations the range [C,\n    /// end-of-declarations). If A is non-NULL, it is a pointer to a\n    /// member function of SpecificDecl that should return true for\n    /// all of the SpecificDecl instances that will be in the subset\n    /// of iterators. For example, if you want Objective-C instance\n    /// methods, SpecificDecl will be ObjCMethodDecl and A will be\n    /// &ObjCMethodDecl::isInstanceMethod.\n    explicit filtered_decl_iterator(DeclContext::decl_iterator C) : Current(C) {\n      SkipToNextDecl();\n    }\n\n    value_type operator*() const { return cast<SpecificDecl>(*Current); }\n    value_type operator->() const { return cast<SpecificDecl>(*Current); }\n\n    filtered_decl_iterator& operator++() {\n      ++Current;\n      SkipToNextDecl();\n      return *this;\n    }\n\n    filtered_decl_iterator operator++(int) {\n      filtered_decl_iterator tmp(*this);\n      ++(*this);\n      return tmp;\n    }\n\n    friend bool operator==(const filtered_decl_iterator& x,\n                           const filtered_decl_iterator& y) {\n      return x.Current == y.Current;\n    }\n\n    friend bool operator!=(const filtered_decl_iterator& x,\n                           const filtered_decl_iterator& y) {\n      return x.Current != y.Current;\n    }\n  };\n\n  /// Add the declaration D into this context.\n  ///\n  /// This routine should be invoked when the declaration D has first\n  /// been declared, to place D into the context where it was\n  /// (lexically) defined. Every declaration must be added to one\n  /// (and only one!) context, where it can be visited via\n  /// [decls_begin(), decls_end()). Once a declaration has been added\n  /// to its lexical context, the corresponding DeclContext owns the\n  /// declaration.\n  ///\n  /// If D is also a NamedDecl, it will be made visible within its\n  /// semantic context via makeDeclVisibleInContext.\n  void addDecl(Decl *D);\n\n  /// Add the declaration D into this context, but suppress\n  /// searches for external declarations with the same name.\n  ///\n  /// Although analogous in function to addDecl, this removes an\n  /// important check.  This is only useful if the Decl is being\n  /// added in response to an external search; in all other cases,\n  /// addDecl() is the right function to use.\n  /// See the ASTImporter for use cases.\n  void addDeclInternal(Decl *D);\n\n  /// Add the declaration D to this context without modifying\n  /// any lookup tables.\n  ///\n  /// This is useful for some operations in dependent contexts where\n  /// the semantic context might not be dependent;  this basically\n  /// only happens with friends.\n  void addHiddenDecl(Decl *D);\n\n  /// Removes a declaration from this context.\n  void removeDecl(Decl *D);\n\n  /// Checks whether a declaration is in this context.\n  bool containsDecl(Decl *D) const;\n\n  /// Checks whether a declaration is in this context.\n  /// This also loads the Decls from the external source before the check.\n  bool containsDeclAndLoad(Decl *D) const;\n\n  using lookup_result = DeclContextLookupResult;\n  using lookup_iterator = lookup_result::iterator;\n\n  /// lookup - Find the declarations (if any) with the given Name in\n  /// this context. Returns a range of iterators that contains all of\n  /// the declarations with this name, with object, function, member,\n  /// and enumerator names preceding any tag name. Note that this\n  /// routine will not look into parent contexts.\n  lookup_result lookup(DeclarationName Name) const;\n\n  /// Find the declarations with the given name that are visible\n  /// within this context; don't attempt to retrieve anything from an\n  /// external source.\n  lookup_result noload_lookup(DeclarationName Name);\n\n  /// A simplistic name lookup mechanism that performs name lookup\n  /// into this declaration context without consulting the external source.\n  ///\n  /// This function should almost never be used, because it subverts the\n  /// usual relationship between a DeclContext and the external source.\n  /// See the ASTImporter for the (few, but important) use cases.\n  ///\n  /// FIXME: This is very inefficient; replace uses of it with uses of\n  /// noload_lookup.\n  void localUncachedLookup(DeclarationName Name,\n                           SmallVectorImpl<NamedDecl *> &Results);\n\n  /// Makes a declaration visible within this context.\n  ///\n  /// This routine makes the declaration D visible to name lookup\n  /// within this context and, if this is a transparent context,\n  /// within its parent contexts up to the first enclosing\n  /// non-transparent context. Making a declaration visible within a\n  /// context does not transfer ownership of a declaration, and a\n  /// declaration can be visible in many contexts that aren't its\n  /// lexical context.\n  ///\n  /// If D is a redeclaration of an existing declaration that is\n  /// visible from this context, as determined by\n  /// NamedDecl::declarationReplaces, the previous declaration will be\n  /// replaced with D.\n  void makeDeclVisibleInContext(NamedDecl *D);\n\n  /// all_lookups_iterator - An iterator that provides a view over the results\n  /// of looking up every possible name.\n  class all_lookups_iterator;\n\n  using lookups_range = llvm::iterator_range<all_lookups_iterator>;\n\n  lookups_range lookups() const;\n  // Like lookups(), but avoids loading external declarations.\n  // If PreserveInternalState, avoids building lookup data structures too.\n  lookups_range noload_lookups(bool PreserveInternalState) const;\n\n  /// Iterators over all possible lookups within this context.\n  all_lookups_iterator lookups_begin() const;\n  all_lookups_iterator lookups_end() const;\n\n  /// Iterators over all possible lookups within this context that are\n  /// currently loaded; don't attempt to retrieve anything from an external\n  /// source.\n  all_lookups_iterator noload_lookups_begin() const;\n  all_lookups_iterator noload_lookups_end() const;\n\n  struct udir_iterator;\n\n  using udir_iterator_base =\n      llvm::iterator_adaptor_base<udir_iterator, lookup_iterator,\n                                  std::random_access_iterator_tag,\n                                  UsingDirectiveDecl *>;\n\n  struct udir_iterator : udir_iterator_base {\n    udir_iterator(lookup_iterator I) : udir_iterator_base(I) {}\n\n    UsingDirectiveDecl *operator*() const;\n  };\n\n  using udir_range = llvm::iterator_range<udir_iterator>;\n\n  udir_range using_directives() const;\n\n  // These are all defined in DependentDiagnostic.h.\n  class ddiag_iterator;\n\n  using ddiag_range = llvm::iterator_range<DeclContext::ddiag_iterator>;\n\n  inline ddiag_range ddiags() const;\n\n  // Low-level accessors\n\n  /// Mark that there are external lexical declarations that we need\n  /// to include in our lookup table (and that are not available as external\n  /// visible lookups). These extra lookup results will be found by walking\n  /// the lexical declarations of this context. This should be used only if\n  /// setHasExternalLexicalStorage() has been called on any decl context for\n  /// which this is the primary context.\n  void setMustBuildLookupTable() {\n    assert(this == getPrimaryContext() &&\n           \"should only be called on primary context\");\n    DeclContextBits.HasLazyExternalLexicalLookups = true;\n  }\n\n  /// Retrieve the internal representation of the lookup structure.\n  /// This may omit some names if we are lazily building the structure.\n  StoredDeclsMap *getLookupPtr() const { return LookupPtr; }\n\n  /// Ensure the lookup structure is fully-built and return it.\n  StoredDeclsMap *buildLookup();\n\n  /// Whether this DeclContext has external storage containing\n  /// additional declarations that are lexically in this context.\n  bool hasExternalLexicalStorage() const {\n    return DeclContextBits.ExternalLexicalStorage;\n  }\n\n  /// State whether this DeclContext has external storage for\n  /// declarations lexically in this context.\n  void setHasExternalLexicalStorage(bool ES = true) const {\n    DeclContextBits.ExternalLexicalStorage = ES;\n  }\n\n  /// Whether this DeclContext has external storage containing\n  /// additional declarations that are visible in this context.\n  bool hasExternalVisibleStorage() const {\n    return DeclContextBits.ExternalVisibleStorage;\n  }\n\n  /// State whether this DeclContext has external storage for\n  /// declarations visible in this context.\n  void setHasExternalVisibleStorage(bool ES = true) const {\n    DeclContextBits.ExternalVisibleStorage = ES;\n    if (ES && LookupPtr)\n      DeclContextBits.NeedToReconcileExternalVisibleStorage = true;\n  }\n\n  /// Determine whether the given declaration is stored in the list of\n  /// declarations lexically within this context.\n  bool isDeclInLexicalTraversal(const Decl *D) const {\n    return D && (D->NextInContextAndBits.getPointer() || D == FirstDecl ||\n                 D == LastDecl);\n  }\n\n  bool setUseQualifiedLookup(bool use = true) const {\n    bool old_value = DeclContextBits.UseQualifiedLookup;\n    DeclContextBits.UseQualifiedLookup = use;\n    return old_value;\n  }\n\n  bool shouldUseQualifiedLookup() const {\n    return DeclContextBits.UseQualifiedLookup;\n  }\n\n  static bool classof(const Decl *D);\n  static bool classof(const DeclContext *D) { return true; }\n\n  void dumpDeclContext() const;\n  void dumpLookups() const;\n  void dumpLookups(llvm::raw_ostream &OS, bool DumpDecls = false,\n                   bool Deserialize = false) const;\n\nprivate:\n  /// Whether this declaration context has had externally visible\n  /// storage added since the last lookup. In this case, \\c LookupPtr's\n  /// invariant may not hold and needs to be fixed before we perform\n  /// another lookup.\n  bool hasNeedToReconcileExternalVisibleStorage() const {\n    return DeclContextBits.NeedToReconcileExternalVisibleStorage;\n  }\n\n  /// State that this declaration context has had externally visible\n  /// storage added since the last lookup. In this case, \\c LookupPtr's\n  /// invariant may not hold and needs to be fixed before we perform\n  /// another lookup.\n  void setNeedToReconcileExternalVisibleStorage(bool Need = true) const {\n    DeclContextBits.NeedToReconcileExternalVisibleStorage = Need;\n  }\n\n  /// If \\c true, this context may have local lexical declarations\n  /// that are missing from the lookup table.\n  bool hasLazyLocalLexicalLookups() const {\n    return DeclContextBits.HasLazyLocalLexicalLookups;\n  }\n\n  /// If \\c true, this context may have local lexical declarations\n  /// that are missing from the lookup table.\n  void setHasLazyLocalLexicalLookups(bool HasLLLL = true) const {\n    DeclContextBits.HasLazyLocalLexicalLookups = HasLLLL;\n  }\n\n  /// If \\c true, the external source may have lexical declarations\n  /// that are missing from the lookup table.\n  bool hasLazyExternalLexicalLookups() const {\n    return DeclContextBits.HasLazyExternalLexicalLookups;\n  }\n\n  /// If \\c true, the external source may have lexical declarations\n  /// that are missing from the lookup table.\n  void setHasLazyExternalLexicalLookups(bool HasLELL = true) const {\n    DeclContextBits.HasLazyExternalLexicalLookups = HasLELL;\n  }\n\n  void reconcileExternalVisibleStorage() const;\n  bool LoadLexicalDeclsFromExternalStorage() const;\n\n  /// Makes a declaration visible within this context, but\n  /// suppresses searches for external declarations with the same\n  /// name.\n  ///\n  /// Analogous to makeDeclVisibleInContext, but for the exclusive\n  /// use of addDeclInternal().\n  void makeDeclVisibleInContextInternal(NamedDecl *D);\n\n  StoredDeclsMap *CreateStoredDeclsMap(ASTContext &C) const;\n\n  void loadLazyLocalLexicalLookups();\n  void buildLookupImpl(DeclContext *DCtx, bool Internal);\n  void makeDeclVisibleInContextWithFlags(NamedDecl *D, bool Internal,\n                                         bool Rediscoverable);\n  void makeDeclVisibleInContextImpl(NamedDecl *D, bool Internal);\n};\n\ninline bool Decl::isTemplateParameter() const {\n  return getKind() == TemplateTypeParm || getKind() == NonTypeTemplateParm ||\n         getKind() == TemplateTemplateParm;\n}\n\n// Specialization selected when ToTy is not a known subclass of DeclContext.\ntemplate <class ToTy,\n          bool IsKnownSubtype = ::std::is_base_of<DeclContext, ToTy>::value>\nstruct cast_convert_decl_context {\n  static const ToTy *doit(const DeclContext *Val) {\n    return static_cast<const ToTy*>(Decl::castFromDeclContext(Val));\n  }\n\n  static ToTy *doit(DeclContext *Val) {\n    return static_cast<ToTy*>(Decl::castFromDeclContext(Val));\n  }\n};\n\n// Specialization selected when ToTy is a known subclass of DeclContext.\ntemplate <class ToTy>\nstruct cast_convert_decl_context<ToTy, true> {\n  static const ToTy *doit(const DeclContext *Val) {\n    return static_cast<const ToTy*>(Val);\n  }\n\n  static ToTy *doit(DeclContext *Val) {\n    return static_cast<ToTy*>(Val);\n  }\n};\n\n} // namespace clang\n\nnamespace llvm {\n\n/// isa<T>(DeclContext*)\ntemplate <typename To>\nstruct isa_impl<To, ::clang::DeclContext> {\n  static bool doit(const ::clang::DeclContext &Val) {\n    return To::classofKind(Val.getDeclKind());\n  }\n};\n\n/// cast<T>(DeclContext*)\ntemplate<class ToTy>\nstruct cast_convert_val<ToTy,\n                        const ::clang::DeclContext,const ::clang::DeclContext> {\n  static const ToTy &doit(const ::clang::DeclContext &Val) {\n    return *::clang::cast_convert_decl_context<ToTy>::doit(&Val);\n  }\n};\n\ntemplate<class ToTy>\nstruct cast_convert_val<ToTy, ::clang::DeclContext, ::clang::DeclContext> {\n  static ToTy &doit(::clang::DeclContext &Val) {\n    return *::clang::cast_convert_decl_context<ToTy>::doit(&Val);\n  }\n};\n\ntemplate<class ToTy>\nstruct cast_convert_val<ToTy,\n                     const ::clang::DeclContext*, const ::clang::DeclContext*> {\n  static const ToTy *doit(const ::clang::DeclContext *Val) {\n    return ::clang::cast_convert_decl_context<ToTy>::doit(Val);\n  }\n};\n\ntemplate<class ToTy>\nstruct cast_convert_val<ToTy, ::clang::DeclContext*, ::clang::DeclContext*> {\n  static ToTy *doit(::clang::DeclContext *Val) {\n    return ::clang::cast_convert_decl_context<ToTy>::doit(Val);\n  }\n};\n\n/// Implement cast_convert_val for Decl -> DeclContext conversions.\ntemplate<class FromTy>\nstruct cast_convert_val< ::clang::DeclContext, FromTy, FromTy> {\n  static ::clang::DeclContext &doit(const FromTy &Val) {\n    return *FromTy::castToDeclContext(&Val);\n  }\n};\n\ntemplate<class FromTy>\nstruct cast_convert_val< ::clang::DeclContext, FromTy*, FromTy*> {\n  static ::clang::DeclContext *doit(const FromTy *Val) {\n    return FromTy::castToDeclContext(Val);\n  }\n};\n\ntemplate<class FromTy>\nstruct cast_convert_val< const ::clang::DeclContext, FromTy, FromTy> {\n  static const ::clang::DeclContext &doit(const FromTy &Val) {\n    return *FromTy::castToDeclContext(&Val);\n  }\n};\n\ntemplate<class FromTy>\nstruct cast_convert_val< const ::clang::DeclContext, FromTy*, FromTy*> {\n  static const ::clang::DeclContext *doit(const FromTy *Val) {\n    return FromTy::castToDeclContext(Val);\n  }\n};\n\n} // namespace llvm\n\n#endif // LLVM_CLANG_AST_DECLBASE_H\n"}, "8": {"id": 8, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclCXX.h", "content": "//===- DeclCXX.h - Classes for representing C++ declarations --*- C++ -*-=====//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the C++ Decl subclasses, other than those for templates\n/// (found in DeclTemplate.h) and friends (in DeclFriend.h).\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_DECLCXX_H\n#define LLVM_CLANG_AST_DECLCXX_H\n\n#include \"clang/AST/ASTUnresolvedSet.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExternalASTSource.h\"\n#include \"clang/AST/LambdaCapture.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/Redeclarable.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/AST/TypeLoc.h\"\n#include \"clang/AST/UnresolvedSet.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/Lambda.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/OperatorKinds.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/TinyPtrVector.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <memory>\n#include <vector>\n\nnamespace clang {\n\nclass ASTContext;\nclass ClassTemplateDecl;\nclass ConstructorUsingShadowDecl;\nclass CXXBasePath;\nclass CXXBasePaths;\nclass CXXConstructorDecl;\nclass CXXDestructorDecl;\nclass CXXFinalOverriderMap;\nclass CXXIndirectPrimaryBaseSet;\nclass CXXMethodDecl;\nclass DecompositionDecl;\nclass DiagnosticBuilder;\nclass FriendDecl;\nclass FunctionTemplateDecl;\nclass IdentifierInfo;\nclass MemberSpecializationInfo;\nclass TemplateDecl;\nclass TemplateParameterList;\nclass UsingDecl;\n\n/// Represents an access specifier followed by colon ':'.\n///\n/// An objects of this class represents sugar for the syntactic occurrence\n/// of an access specifier followed by a colon in the list of member\n/// specifiers of a C++ class definition.\n///\n/// Note that they do not represent other uses of access specifiers,\n/// such as those occurring in a list of base specifiers.\n/// Also note that this class has nothing to do with so-called\n/// \"access declarations\" (C++98 11.3 [class.access.dcl]).\nclass AccessSpecDecl : public Decl {\n  /// The location of the ':'.\n  SourceLocation ColonLoc;\n\n  AccessSpecDecl(AccessSpecifier AS, DeclContext *DC,\n                 SourceLocation ASLoc, SourceLocation ColonLoc)\n    : Decl(AccessSpec, DC, ASLoc), ColonLoc(ColonLoc) {\n    setAccess(AS);\n  }\n\n  AccessSpecDecl(EmptyShell Empty) : Decl(AccessSpec, Empty) {}\n\n  virtual void anchor();\n\npublic:\n  /// The location of the access specifier.\n  SourceLocation getAccessSpecifierLoc() const { return getLocation(); }\n\n  /// Sets the location of the access specifier.\n  void setAccessSpecifierLoc(SourceLocation ASLoc) { setLocation(ASLoc); }\n\n  /// The location of the colon following the access specifier.\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  /// Sets the location of the colon.\n  void setColonLoc(SourceLocation CLoc) { ColonLoc = CLoc; }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(getAccessSpecifierLoc(), getColonLoc());\n  }\n\n  static AccessSpecDecl *Create(ASTContext &C, AccessSpecifier AS,\n                                DeclContext *DC, SourceLocation ASLoc,\n                                SourceLocation ColonLoc) {\n    return new (C, DC) AccessSpecDecl(AS, DC, ASLoc, ColonLoc);\n  }\n\n  static AccessSpecDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == AccessSpec; }\n};\n\n/// Represents a base class of a C++ class.\n///\n/// Each CXXBaseSpecifier represents a single, direct base class (or\n/// struct) of a C++ class (or struct). It specifies the type of that\n/// base class, whether it is a virtual or non-virtual base, and what\n/// level of access (public, protected, private) is used for the\n/// derivation. For example:\n///\n/// \\code\n///   class A { };\n///   class B { };\n///   class C : public virtual A, protected B { };\n/// \\endcode\n///\n/// In this code, C will have two CXXBaseSpecifiers, one for \"public\n/// virtual A\" and the other for \"protected B\".\nclass CXXBaseSpecifier {\n  /// The source code range that covers the full base\n  /// specifier, including the \"virtual\" (if present) and access\n  /// specifier (if present).\n  SourceRange Range;\n\n  /// The source location of the ellipsis, if this is a pack\n  /// expansion.\n  SourceLocation EllipsisLoc;\n\n  /// Whether this is a virtual base class or not.\n  unsigned Virtual : 1;\n\n  /// Whether this is the base of a class (true) or of a struct (false).\n  ///\n  /// This determines the mapping from the access specifier as written in the\n  /// source code to the access specifier used for semantic analysis.\n  unsigned BaseOfClass : 1;\n\n  /// Access specifier as written in the source code (may be AS_none).\n  ///\n  /// The actual type of data stored here is an AccessSpecifier, but we use\n  /// \"unsigned\" here to work around a VC++ bug.\n  unsigned Access : 2;\n\n  /// Whether the class contains a using declaration\n  /// to inherit the named class's constructors.\n  unsigned InheritConstructors : 1;\n\n  /// The type of the base class.\n  ///\n  /// This will be a class or struct (or a typedef of such). The source code\n  /// range does not include the \\c virtual or the access specifier.\n  TypeSourceInfo *BaseTypeInfo;\n\npublic:\n  CXXBaseSpecifier() = default;\n  CXXBaseSpecifier(SourceRange R, bool V, bool BC, AccessSpecifier A,\n                   TypeSourceInfo *TInfo, SourceLocation EllipsisLoc)\n    : Range(R), EllipsisLoc(EllipsisLoc), Virtual(V), BaseOfClass(BC),\n      Access(A), InheritConstructors(false), BaseTypeInfo(TInfo) {}\n\n  /// Retrieves the source range that contains the entire base specifier.\n  SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n\n  /// Get the location at which the base class type was written.\n  SourceLocation getBaseTypeLoc() const LLVM_READONLY {\n    return BaseTypeInfo->getTypeLoc().getBeginLoc();\n  }\n\n  /// Determines whether the base class is a virtual base class (or not).\n  bool isVirtual() const { return Virtual; }\n\n  /// Determine whether this base class is a base of a class declared\n  /// with the 'class' keyword (vs. one declared with the 'struct' keyword).\n  bool isBaseOfClass() const { return BaseOfClass; }\n\n  /// Determine whether this base specifier is a pack expansion.\n  bool isPackExpansion() const { return EllipsisLoc.isValid(); }\n\n  /// Determine whether this base class's constructors get inherited.\n  bool getInheritConstructors() const { return InheritConstructors; }\n\n  /// Set that this base class's constructors should be inherited.\n  void setInheritConstructors(bool Inherit = true) {\n    InheritConstructors = Inherit;\n  }\n\n  /// For a pack expansion, determine the location of the ellipsis.\n  SourceLocation getEllipsisLoc() const {\n    return EllipsisLoc;\n  }\n\n  /// Returns the access specifier for this base specifier.\n  ///\n  /// This is the actual base specifier as used for semantic analysis, so\n  /// the result can never be AS_none. To retrieve the access specifier as\n  /// written in the source code, use getAccessSpecifierAsWritten().\n  AccessSpecifier getAccessSpecifier() const {\n    if ((AccessSpecifier)Access == AS_none)\n      return BaseOfClass? AS_private : AS_public;\n    else\n      return (AccessSpecifier)Access;\n  }\n\n  /// Retrieves the access specifier as written in the source code\n  /// (which may mean that no access specifier was explicitly written).\n  ///\n  /// Use getAccessSpecifier() to retrieve the access specifier for use in\n  /// semantic analysis.\n  AccessSpecifier getAccessSpecifierAsWritten() const {\n    return (AccessSpecifier)Access;\n  }\n\n  /// Retrieves the type of the base class.\n  ///\n  /// This type will always be an unqualified class type.\n  QualType getType() const {\n    return BaseTypeInfo->getType().getUnqualifiedType();\n  }\n\n  /// Retrieves the type and source location of the base class.\n  TypeSourceInfo *getTypeSourceInfo() const { return BaseTypeInfo; }\n};\n\n/// Represents a C++ struct/union/class.\nclass CXXRecordDecl : public RecordDecl {\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend class ASTNodeImporter;\n  friend class ASTReader;\n  friend class ASTRecordWriter;\n  friend class ASTWriter;\n  friend class DeclContext;\n  friend class LambdaExpr;\n\n  friend void FunctionDecl::setPure(bool);\n  friend void TagDecl::startDefinition();\n\n  /// Values used in DefinitionData fields to represent special members.\n  enum SpecialMemberFlags {\n    SMF_DefaultConstructor = 0x1,\n    SMF_CopyConstructor = 0x2,\n    SMF_MoveConstructor = 0x4,\n    SMF_CopyAssignment = 0x8,\n    SMF_MoveAssignment = 0x10,\n    SMF_Destructor = 0x20,\n    SMF_All = 0x3f\n  };\n\n  struct DefinitionData {\n    #define FIELD(Name, Width, Merge) \\\n    unsigned Name : Width;\n    #include \"CXXRecordDeclDefinitionBits.def\"\n\n    /// Whether this class describes a C++ lambda.\n    unsigned IsLambda : 1;\n\n    /// Whether we are currently parsing base specifiers.\n    unsigned IsParsingBaseSpecifiers : 1;\n\n    /// True when visible conversion functions are already computed\n    /// and are available.\n    unsigned ComputedVisibleConversions : 1;\n\n    unsigned HasODRHash : 1;\n\n    /// A hash of parts of the class to help in ODR checking.\n    unsigned ODRHash = 0;\n\n    /// The number of base class specifiers in Bases.\n    unsigned NumBases = 0;\n\n    /// The number of virtual base class specifiers in VBases.\n    unsigned NumVBases = 0;\n\n    /// Base classes of this class.\n    ///\n    /// FIXME: This is wasted space for a union.\n    LazyCXXBaseSpecifiersPtr Bases;\n\n    /// direct and indirect virtual base classes of this class.\n    LazyCXXBaseSpecifiersPtr VBases;\n\n    /// The conversion functions of this C++ class (but not its\n    /// inherited conversion functions).\n    ///\n    /// Each of the entries in this overload set is a CXXConversionDecl.\n    LazyASTUnresolvedSet Conversions;\n\n    /// The conversion functions of this C++ class and all those\n    /// inherited conversion functions that are visible in this class.\n    ///\n    /// Each of the entries in this overload set is a CXXConversionDecl or a\n    /// FunctionTemplateDecl.\n    LazyASTUnresolvedSet VisibleConversions;\n\n    /// The declaration which defines this record.\n    CXXRecordDecl *Definition;\n\n    /// The first friend declaration in this class, or null if there\n    /// aren't any.\n    ///\n    /// This is actually currently stored in reverse order.\n    LazyDeclPtr FirstFriend;\n\n    DefinitionData(CXXRecordDecl *D);\n\n    /// Retrieve the set of direct base classes.\n    CXXBaseSpecifier *getBases() const {\n      if (!Bases.isOffset())\n        return Bases.get(nullptr);\n      return getBasesSlowCase();\n    }\n\n    /// Retrieve the set of virtual base classes.\n    CXXBaseSpecifier *getVBases() const {\n      if (!VBases.isOffset())\n        return VBases.get(nullptr);\n      return getVBasesSlowCase();\n    }\n\n    ArrayRef<CXXBaseSpecifier> bases() const {\n      return llvm::makeArrayRef(getBases(), NumBases);\n    }\n\n    ArrayRef<CXXBaseSpecifier> vbases() const {\n      return llvm::makeArrayRef(getVBases(), NumVBases);\n    }\n\n  private:\n    CXXBaseSpecifier *getBasesSlowCase() const;\n    CXXBaseSpecifier *getVBasesSlowCase() const;\n  };\n\n  struct DefinitionData *DefinitionData;\n\n  /// Describes a C++ closure type (generated by a lambda expression).\n  struct LambdaDefinitionData : public DefinitionData {\n    using Capture = LambdaCapture;\n\n    /// Whether this lambda is known to be dependent, even if its\n    /// context isn't dependent.\n    ///\n    /// A lambda with a non-dependent context can be dependent if it occurs\n    /// within the default argument of a function template, because the\n    /// lambda will have been created with the enclosing context as its\n    /// declaration context, rather than function. This is an unfortunate\n    /// artifact of having to parse the default arguments before.\n    unsigned Dependent : 1;\n\n    /// Whether this lambda is a generic lambda.\n    unsigned IsGenericLambda : 1;\n\n    /// The Default Capture.\n    unsigned CaptureDefault : 2;\n\n    /// The number of captures in this lambda is limited 2^NumCaptures.\n    unsigned NumCaptures : 15;\n\n    /// The number of explicit captures in this lambda.\n    unsigned NumExplicitCaptures : 13;\n\n    /// Has known `internal` linkage.\n    unsigned HasKnownInternalLinkage : 1;\n\n    /// The number used to indicate this lambda expression for name\n    /// mangling in the Itanium C++ ABI.\n    unsigned ManglingNumber : 31;\n\n    /// The declaration that provides context for this lambda, if the\n    /// actual DeclContext does not suffice. This is used for lambdas that\n    /// occur within default arguments of function parameters within the class\n    /// or within a data member initializer.\n    LazyDeclPtr ContextDecl;\n\n    /// The list of captures, both explicit and implicit, for this\n    /// lambda.\n    Capture *Captures = nullptr;\n\n    /// The type of the call method.\n    TypeSourceInfo *MethodTyInfo;\n\n    LambdaDefinitionData(CXXRecordDecl *D, TypeSourceInfo *Info, bool Dependent,\n                         bool IsGeneric, LambdaCaptureDefault CaptureDefault)\n        : DefinitionData(D), Dependent(Dependent), IsGenericLambda(IsGeneric),\n          CaptureDefault(CaptureDefault), NumCaptures(0),\n          NumExplicitCaptures(0), HasKnownInternalLinkage(0), ManglingNumber(0),\n          MethodTyInfo(Info) {\n      IsLambda = true;\n\n      // C++1z [expr.prim.lambda]p4:\n      //   This class type is not an aggregate type.\n      Aggregate = false;\n      PlainOldData = false;\n    }\n  };\n\n  struct DefinitionData *dataPtr() const {\n    // Complete the redecl chain (if necessary).\n    getMostRecentDecl();\n    return DefinitionData;\n  }\n\n  struct DefinitionData &data() const {\n    auto *DD = dataPtr();\n    assert(DD && \"queried property of class with no definition\");\n    return *DD;\n  }\n\n  struct LambdaDefinitionData &getLambdaData() const {\n    // No update required: a merged definition cannot change any lambda\n    // properties.\n    auto *DD = DefinitionData;\n    assert(DD && DD->IsLambda && \"queried lambda property of non-lambda class\");\n    return static_cast<LambdaDefinitionData&>(*DD);\n  }\n\n  /// The template or declaration that this declaration\n  /// describes or was instantiated from, respectively.\n  ///\n  /// For non-templates, this value will be null. For record\n  /// declarations that describe a class template, this will be a\n  /// pointer to a ClassTemplateDecl. For member\n  /// classes of class template specializations, this will be the\n  /// MemberSpecializationInfo referring to the member class that was\n  /// instantiated or specialized.\n  llvm::PointerUnion<ClassTemplateDecl *, MemberSpecializationInfo *>\n      TemplateOrInstantiation;\n\n  /// Called from setBases and addedMember to notify the class that a\n  /// direct or virtual base class or a member of class type has been added.\n  void addedClassSubobject(CXXRecordDecl *Base);\n\n  /// Notify the class that member has been added.\n  ///\n  /// This routine helps maintain information about the class based on which\n  /// members have been added. It will be invoked by DeclContext::addDecl()\n  /// whenever a member is added to this record.\n  void addedMember(Decl *D);\n\n  void markedVirtualFunctionPure();\n\n  /// Get the head of our list of friend declarations, possibly\n  /// deserializing the friends from an external AST source.\n  FriendDecl *getFirstFriend() const;\n\n  /// Determine whether this class has an empty base class subobject of type X\n  /// or of one of the types that might be at offset 0 within X (per the C++\n  /// \"standard layout\" rules).\n  bool hasSubobjectAtOffsetZeroOfEmptyBaseType(ASTContext &Ctx,\n                                               const CXXRecordDecl *X);\n\nprotected:\n  CXXRecordDecl(Kind K, TagKind TK, const ASTContext &C, DeclContext *DC,\n                SourceLocation StartLoc, SourceLocation IdLoc,\n                IdentifierInfo *Id, CXXRecordDecl *PrevDecl);\n\npublic:\n  /// Iterator that traverses the base classes of a class.\n  using base_class_iterator = CXXBaseSpecifier *;\n\n  /// Iterator that traverses the base classes of a class.\n  using base_class_const_iterator = const CXXBaseSpecifier *;\n\n  CXXRecordDecl *getCanonicalDecl() override {\n    return cast<CXXRecordDecl>(RecordDecl::getCanonicalDecl());\n  }\n\n  const CXXRecordDecl *getCanonicalDecl() const {\n    return const_cast<CXXRecordDecl*>(this)->getCanonicalDecl();\n  }\n\n  CXXRecordDecl *getPreviousDecl() {\n    return cast_or_null<CXXRecordDecl>(\n            static_cast<RecordDecl *>(this)->getPreviousDecl());\n  }\n\n  const CXXRecordDecl *getPreviousDecl() const {\n    return const_cast<CXXRecordDecl*>(this)->getPreviousDecl();\n  }\n\n  CXXRecordDecl *getMostRecentDecl() {\n    return cast<CXXRecordDecl>(\n            static_cast<RecordDecl *>(this)->getMostRecentDecl());\n  }\n\n  const CXXRecordDecl *getMostRecentDecl() const {\n    return const_cast<CXXRecordDecl*>(this)->getMostRecentDecl();\n  }\n\n  CXXRecordDecl *getMostRecentNonInjectedDecl() {\n    CXXRecordDecl *Recent =\n        static_cast<CXXRecordDecl *>(this)->getMostRecentDecl();\n    while (Recent->isInjectedClassName()) {\n      // FIXME: Does injected class name need to be in the redeclarations chain?\n      assert(Recent->getPreviousDecl());\n      Recent = Recent->getPreviousDecl();\n    }\n    return Recent;\n  }\n\n  const CXXRecordDecl *getMostRecentNonInjectedDecl() const {\n    return const_cast<CXXRecordDecl*>(this)->getMostRecentNonInjectedDecl();\n  }\n\n  CXXRecordDecl *getDefinition() const {\n    // We only need an update if we don't already know which\n    // declaration is the definition.\n    auto *DD = DefinitionData ? DefinitionData : dataPtr();\n    return DD ? DD->Definition : nullptr;\n  }\n\n  bool hasDefinition() const { return DefinitionData || dataPtr(); }\n\n  static CXXRecordDecl *Create(const ASTContext &C, TagKind TK, DeclContext *DC,\n                               SourceLocation StartLoc, SourceLocation IdLoc,\n                               IdentifierInfo *Id,\n                               CXXRecordDecl *PrevDecl = nullptr,\n                               bool DelayTypeCreation = false);\n  static CXXRecordDecl *CreateLambda(const ASTContext &C, DeclContext *DC,\n                                     TypeSourceInfo *Info, SourceLocation Loc,\n                                     bool DependentLambda, bool IsGeneric,\n                                     LambdaCaptureDefault CaptureDefault);\n  static CXXRecordDecl *CreateDeserialized(const ASTContext &C, unsigned ID);\n\n  bool isDynamicClass() const {\n    return data().Polymorphic || data().NumVBases != 0;\n  }\n\n  /// @returns true if class is dynamic or might be dynamic because the\n  /// definition is incomplete of dependent.\n  bool mayBeDynamicClass() const {\n    return !hasDefinition() || isDynamicClass() || hasAnyDependentBases();\n  }\n\n  /// @returns true if class is non dynamic or might be non dynamic because the\n  /// definition is incomplete of dependent.\n  bool mayBeNonDynamicClass() const {\n    return !hasDefinition() || !isDynamicClass() || hasAnyDependentBases();\n  }\n\n  void setIsParsingBaseSpecifiers() { data().IsParsingBaseSpecifiers = true; }\n\n  bool isParsingBaseSpecifiers() const {\n    return data().IsParsingBaseSpecifiers;\n  }\n\n  unsigned getODRHash() const;\n\n  /// Sets the base classes of this struct or class.\n  void setBases(CXXBaseSpecifier const * const *Bases, unsigned NumBases);\n\n  /// Retrieves the number of base classes of this class.\n  unsigned getNumBases() const { return data().NumBases; }\n\n  using base_class_range = llvm::iterator_range<base_class_iterator>;\n  using base_class_const_range =\n      llvm::iterator_range<base_class_const_iterator>;\n\n  base_class_range bases() {\n    return base_class_range(bases_begin(), bases_end());\n  }\n  base_class_const_range bases() const {\n    return base_class_const_range(bases_begin(), bases_end());\n  }\n\n  base_class_iterator bases_begin() { return data().getBases(); }\n  base_class_const_iterator bases_begin() const { return data().getBases(); }\n  base_class_iterator bases_end() { return bases_begin() + data().NumBases; }\n  base_class_const_iterator bases_end() const {\n    return bases_begin() + data().NumBases;\n  }\n\n  /// Retrieves the number of virtual base classes of this class.\n  unsigned getNumVBases() const { return data().NumVBases; }\n\n  base_class_range vbases() {\n    return base_class_range(vbases_begin(), vbases_end());\n  }\n  base_class_const_range vbases() const {\n    return base_class_const_range(vbases_begin(), vbases_end());\n  }\n\n  base_class_iterator vbases_begin() { return data().getVBases(); }\n  base_class_const_iterator vbases_begin() const { return data().getVBases(); }\n  base_class_iterator vbases_end() { return vbases_begin() + data().NumVBases; }\n  base_class_const_iterator vbases_end() const {\n    return vbases_begin() + data().NumVBases;\n  }\n\n  /// Determine whether this class has any dependent base classes which\n  /// are not the current instantiation.\n  bool hasAnyDependentBases() const;\n\n  /// Iterator access to method members.  The method iterator visits\n  /// all method members of the class, including non-instance methods,\n  /// special methods, etc.\n  using method_iterator = specific_decl_iterator<CXXMethodDecl>;\n  using method_range =\n      llvm::iterator_range<specific_decl_iterator<CXXMethodDecl>>;\n\n  method_range methods() const {\n    return method_range(method_begin(), method_end());\n  }\n\n  /// Method begin iterator.  Iterates in the order the methods\n  /// were declared.\n  method_iterator method_begin() const {\n    return method_iterator(decls_begin());\n  }\n\n  /// Method past-the-end iterator.\n  method_iterator method_end() const {\n    return method_iterator(decls_end());\n  }\n\n  /// Iterator access to constructor members.\n  using ctor_iterator = specific_decl_iterator<CXXConstructorDecl>;\n  using ctor_range =\n      llvm::iterator_range<specific_decl_iterator<CXXConstructorDecl>>;\n\n  ctor_range ctors() const { return ctor_range(ctor_begin(), ctor_end()); }\n\n  ctor_iterator ctor_begin() const {\n    return ctor_iterator(decls_begin());\n  }\n\n  ctor_iterator ctor_end() const {\n    return ctor_iterator(decls_end());\n  }\n\n  /// An iterator over friend declarations.  All of these are defined\n  /// in DeclFriend.h.\n  class friend_iterator;\n  using friend_range = llvm::iterator_range<friend_iterator>;\n\n  friend_range friends() const;\n  friend_iterator friend_begin() const;\n  friend_iterator friend_end() const;\n  void pushFriendDecl(FriendDecl *FD);\n\n  /// Determines whether this record has any friends.\n  bool hasFriends() const {\n    return data().FirstFriend.isValid();\n  }\n\n  /// \\c true if a defaulted copy constructor for this class would be\n  /// deleted.\n  bool defaultedCopyConstructorIsDeleted() const {\n    assert((!needsOverloadResolutionForCopyConstructor() ||\n            (data().DeclaredSpecialMembers & SMF_CopyConstructor)) &&\n           \"this property has not yet been computed by Sema\");\n    return data().DefaultedCopyConstructorIsDeleted;\n  }\n\n  /// \\c true if a defaulted move constructor for this class would be\n  /// deleted.\n  bool defaultedMoveConstructorIsDeleted() const {\n    assert((!needsOverloadResolutionForMoveConstructor() ||\n            (data().DeclaredSpecialMembers & SMF_MoveConstructor)) &&\n           \"this property has not yet been computed by Sema\");\n    return data().DefaultedMoveConstructorIsDeleted;\n  }\n\n  /// \\c true if a defaulted destructor for this class would be deleted.\n  bool defaultedDestructorIsDeleted() const {\n    assert((!needsOverloadResolutionForDestructor() ||\n            (data().DeclaredSpecialMembers & SMF_Destructor)) &&\n           \"this property has not yet been computed by Sema\");\n    return data().DefaultedDestructorIsDeleted;\n  }\n\n  /// \\c true if we know for sure that this class has a single,\n  /// accessible, unambiguous copy constructor that is not deleted.\n  bool hasSimpleCopyConstructor() const {\n    return !hasUserDeclaredCopyConstructor() &&\n           !data().DefaultedCopyConstructorIsDeleted;\n  }\n\n  /// \\c true if we know for sure that this class has a single,\n  /// accessible, unambiguous move constructor that is not deleted.\n  bool hasSimpleMoveConstructor() const {\n    return !hasUserDeclaredMoveConstructor() && hasMoveConstructor() &&\n           !data().DefaultedMoveConstructorIsDeleted;\n  }\n\n  /// \\c true if we know for sure that this class has a single,\n  /// accessible, unambiguous copy assignment operator that is not deleted.\n  bool hasSimpleCopyAssignment() const {\n    return !hasUserDeclaredCopyAssignment() &&\n           !data().DefaultedCopyAssignmentIsDeleted;\n  }\n\n  /// \\c true if we know for sure that this class has a single,\n  /// accessible, unambiguous move assignment operator that is not deleted.\n  bool hasSimpleMoveAssignment() const {\n    return !hasUserDeclaredMoveAssignment() && hasMoveAssignment() &&\n           !data().DefaultedMoveAssignmentIsDeleted;\n  }\n\n  /// \\c true if we know for sure that this class has an accessible\n  /// destructor that is not deleted.\n  bool hasSimpleDestructor() const {\n    return !hasUserDeclaredDestructor() &&\n           !data().DefaultedDestructorIsDeleted;\n  }\n\n  /// Determine whether this class has any default constructors.\n  bool hasDefaultConstructor() const {\n    return (data().DeclaredSpecialMembers & SMF_DefaultConstructor) ||\n           needsImplicitDefaultConstructor();\n  }\n\n  /// Determine if we need to declare a default constructor for\n  /// this class.\n  ///\n  /// This value is used for lazy creation of default constructors.\n  bool needsImplicitDefaultConstructor() const {\n    return (!data().UserDeclaredConstructor &&\n            !(data().DeclaredSpecialMembers & SMF_DefaultConstructor) &&\n            (!isLambda() || lambdaIsDefaultConstructibleAndAssignable())) ||\n           // FIXME: Proposed fix to core wording issue: if a class inherits\n           // a default constructor and doesn't explicitly declare one, one\n           // is declared implicitly.\n           (data().HasInheritedDefaultConstructor &&\n            !(data().DeclaredSpecialMembers & SMF_DefaultConstructor));\n  }\n\n  /// Determine whether this class has any user-declared constructors.\n  ///\n  /// When true, a default constructor will not be implicitly declared.\n  bool hasUserDeclaredConstructor() const {\n    return data().UserDeclaredConstructor;\n  }\n\n  /// Whether this class has a user-provided default constructor\n  /// per C++11.\n  bool hasUserProvidedDefaultConstructor() const {\n    return data().UserProvidedDefaultConstructor;\n  }\n\n  /// Determine whether this class has a user-declared copy constructor.\n  ///\n  /// When false, a copy constructor will be implicitly declared.\n  bool hasUserDeclaredCopyConstructor() const {\n    return data().UserDeclaredSpecialMembers & SMF_CopyConstructor;\n  }\n\n  /// Determine whether this class needs an implicit copy\n  /// constructor to be lazily declared.\n  bool needsImplicitCopyConstructor() const {\n    return !(data().DeclaredSpecialMembers & SMF_CopyConstructor);\n  }\n\n  /// Determine whether we need to eagerly declare a defaulted copy\n  /// constructor for this class.\n  bool needsOverloadResolutionForCopyConstructor() const {\n    // C++17 [class.copy.ctor]p6:\n    //   If the class definition declares a move constructor or move assignment\n    //   operator, the implicitly declared copy constructor is defined as\n    //   deleted.\n    // In MSVC mode, sometimes a declared move assignment does not delete an\n    // implicit copy constructor, so defer this choice to Sema.\n    if (data().UserDeclaredSpecialMembers &\n        (SMF_MoveConstructor | SMF_MoveAssignment))\n      return true;\n    return data().NeedOverloadResolutionForCopyConstructor;\n  }\n\n  /// Determine whether an implicit copy constructor for this type\n  /// would have a parameter with a const-qualified reference type.\n  bool implicitCopyConstructorHasConstParam() const {\n    return data().ImplicitCopyConstructorCanHaveConstParamForNonVBase &&\n           (isAbstract() ||\n            data().ImplicitCopyConstructorCanHaveConstParamForVBase);\n  }\n\n  /// Determine whether this class has a copy constructor with\n  /// a parameter type which is a reference to a const-qualified type.\n  bool hasCopyConstructorWithConstParam() const {\n    return data().HasDeclaredCopyConstructorWithConstParam ||\n           (needsImplicitCopyConstructor() &&\n            implicitCopyConstructorHasConstParam());\n  }\n\n  /// Whether this class has a user-declared move constructor or\n  /// assignment operator.\n  ///\n  /// When false, a move constructor and assignment operator may be\n  /// implicitly declared.\n  bool hasUserDeclaredMoveOperation() const {\n    return data().UserDeclaredSpecialMembers &\n             (SMF_MoveConstructor | SMF_MoveAssignment);\n  }\n\n  /// Determine whether this class has had a move constructor\n  /// declared by the user.\n  bool hasUserDeclaredMoveConstructor() const {\n    return data().UserDeclaredSpecialMembers & SMF_MoveConstructor;\n  }\n\n  /// Determine whether this class has a move constructor.\n  bool hasMoveConstructor() const {\n    return (data().DeclaredSpecialMembers & SMF_MoveConstructor) ||\n           needsImplicitMoveConstructor();\n  }\n\n  /// Set that we attempted to declare an implicit copy\n  /// constructor, but overload resolution failed so we deleted it.\n  void setImplicitCopyConstructorIsDeleted() {\n    assert((data().DefaultedCopyConstructorIsDeleted ||\n            needsOverloadResolutionForCopyConstructor()) &&\n           \"Copy constructor should not be deleted\");\n    data().DefaultedCopyConstructorIsDeleted = true;\n  }\n\n  /// Set that we attempted to declare an implicit move\n  /// constructor, but overload resolution failed so we deleted it.\n  void setImplicitMoveConstructorIsDeleted() {\n    assert((data().DefaultedMoveConstructorIsDeleted ||\n            needsOverloadResolutionForMoveConstructor()) &&\n           \"move constructor should not be deleted\");\n    data().DefaultedMoveConstructorIsDeleted = true;\n  }\n\n  /// Set that we attempted to declare an implicit destructor,\n  /// but overload resolution failed so we deleted it.\n  void setImplicitDestructorIsDeleted() {\n    assert((data().DefaultedDestructorIsDeleted ||\n            needsOverloadResolutionForDestructor()) &&\n           \"destructor should not be deleted\");\n    data().DefaultedDestructorIsDeleted = true;\n  }\n\n  /// Determine whether this class should get an implicit move\n  /// constructor or if any existing special member function inhibits this.\n  bool needsImplicitMoveConstructor() const {\n    return !(data().DeclaredSpecialMembers & SMF_MoveConstructor) &&\n           !hasUserDeclaredCopyConstructor() &&\n           !hasUserDeclaredCopyAssignment() &&\n           !hasUserDeclaredMoveAssignment() &&\n           !hasUserDeclaredDestructor();\n  }\n\n  /// Determine whether we need to eagerly declare a defaulted move\n  /// constructor for this class.\n  bool needsOverloadResolutionForMoveConstructor() const {\n    return data().NeedOverloadResolutionForMoveConstructor;\n  }\n\n  /// Determine whether this class has a user-declared copy assignment\n  /// operator.\n  ///\n  /// When false, a copy assignment operator will be implicitly declared.\n  bool hasUserDeclaredCopyAssignment() const {\n    return data().UserDeclaredSpecialMembers & SMF_CopyAssignment;\n  }\n\n  /// Set that we attempted to declare an implicit copy assignment\n  /// operator, but overload resolution failed so we deleted it.\n  void setImplicitCopyAssignmentIsDeleted() {\n    assert((data().DefaultedCopyAssignmentIsDeleted ||\n            needsOverloadResolutionForCopyAssignment()) &&\n           \"copy assignment should not be deleted\");\n    data().DefaultedCopyAssignmentIsDeleted = true;\n  }\n\n  /// Determine whether this class needs an implicit copy\n  /// assignment operator to be lazily declared.\n  bool needsImplicitCopyAssignment() const {\n    return !(data().DeclaredSpecialMembers & SMF_CopyAssignment);\n  }\n\n  /// Determine whether we need to eagerly declare a defaulted copy\n  /// assignment operator for this class.\n  bool needsOverloadResolutionForCopyAssignment() const {\n    // C++20 [class.copy.assign]p2:\n    //   If the class definition declares a move constructor or move assignment\n    //   operator, the implicitly declared copy assignment operator is defined\n    //   as deleted.\n    // In MSVC mode, sometimes a declared move constructor does not delete an\n    // implicit copy assignment, so defer this choice to Sema.\n    if (data().UserDeclaredSpecialMembers &\n        (SMF_MoveConstructor | SMF_MoveAssignment))\n      return true;\n    return data().NeedOverloadResolutionForCopyAssignment;\n  }\n\n  /// Determine whether an implicit copy assignment operator for this\n  /// type would have a parameter with a const-qualified reference type.\n  bool implicitCopyAssignmentHasConstParam() const {\n    return data().ImplicitCopyAssignmentHasConstParam;\n  }\n\n  /// Determine whether this class has a copy assignment operator with\n  /// a parameter type which is a reference to a const-qualified type or is not\n  /// a reference.\n  bool hasCopyAssignmentWithConstParam() const {\n    return data().HasDeclaredCopyAssignmentWithConstParam ||\n           (needsImplicitCopyAssignment() &&\n            implicitCopyAssignmentHasConstParam());\n  }\n\n  /// Determine whether this class has had a move assignment\n  /// declared by the user.\n  bool hasUserDeclaredMoveAssignment() const {\n    return data().UserDeclaredSpecialMembers & SMF_MoveAssignment;\n  }\n\n  /// Determine whether this class has a move assignment operator.\n  bool hasMoveAssignment() const {\n    return (data().DeclaredSpecialMembers & SMF_MoveAssignment) ||\n           needsImplicitMoveAssignment();\n  }\n\n  /// Set that we attempted to declare an implicit move assignment\n  /// operator, but overload resolution failed so we deleted it.\n  void setImplicitMoveAssignmentIsDeleted() {\n    assert((data().DefaultedMoveAssignmentIsDeleted ||\n            needsOverloadResolutionForMoveAssignment()) &&\n           \"move assignment should not be deleted\");\n    data().DefaultedMoveAssignmentIsDeleted = true;\n  }\n\n  /// Determine whether this class should get an implicit move\n  /// assignment operator or if any existing special member function inhibits\n  /// this.\n  bool needsImplicitMoveAssignment() const {\n    return !(data().DeclaredSpecialMembers & SMF_MoveAssignment) &&\n           !hasUserDeclaredCopyConstructor() &&\n           !hasUserDeclaredCopyAssignment() &&\n           !hasUserDeclaredMoveConstructor() &&\n           !hasUserDeclaredDestructor() &&\n           (!isLambda() || lambdaIsDefaultConstructibleAndAssignable());\n  }\n\n  /// Determine whether we need to eagerly declare a move assignment\n  /// operator for this class.\n  bool needsOverloadResolutionForMoveAssignment() const {\n    return data().NeedOverloadResolutionForMoveAssignment;\n  }\n\n  /// Determine whether this class has a user-declared destructor.\n  ///\n  /// When false, a destructor will be implicitly declared.\n  bool hasUserDeclaredDestructor() const {\n    return data().UserDeclaredSpecialMembers & SMF_Destructor;\n  }\n\n  /// Determine whether this class needs an implicit destructor to\n  /// be lazily declared.\n  bool needsImplicitDestructor() const {\n    return !(data().DeclaredSpecialMembers & SMF_Destructor);\n  }\n\n  /// Determine whether we need to eagerly declare a destructor for this\n  /// class.\n  bool needsOverloadResolutionForDestructor() const {\n    return data().NeedOverloadResolutionForDestructor;\n  }\n\n  /// Determine whether this class describes a lambda function object.\n  bool isLambda() const {\n    // An update record can't turn a non-lambda into a lambda.\n    auto *DD = DefinitionData;\n    return DD && DD->IsLambda;\n  }\n\n  /// Determine whether this class describes a generic\n  /// lambda function object (i.e. function call operator is\n  /// a template).\n  bool isGenericLambda() const;\n\n  /// Determine whether this lambda should have an implicit default constructor\n  /// and copy and move assignment operators.\n  bool lambdaIsDefaultConstructibleAndAssignable() const;\n\n  /// Retrieve the lambda call operator of the closure type\n  /// if this is a closure type.\n  CXXMethodDecl *getLambdaCallOperator() const;\n\n  /// Retrieve the dependent lambda call operator of the closure type\n  /// if this is a templated closure type.\n  FunctionTemplateDecl *getDependentLambdaCallOperator() const;\n\n  /// Retrieve the lambda static invoker, the address of which\n  /// is returned by the conversion operator, and the body of which\n  /// is forwarded to the lambda call operator. The version that does not\n  /// take a calling convention uses the 'default' calling convention for free\n  /// functions if the Lambda's calling convention was not modified via\n  /// attribute. Otherwise, it will return the calling convention specified for\n  /// the lambda.\n  CXXMethodDecl *getLambdaStaticInvoker() const;\n  CXXMethodDecl *getLambdaStaticInvoker(CallingConv CC) const;\n\n  /// Retrieve the generic lambda's template parameter list.\n  /// Returns null if the class does not represent a lambda or a generic\n  /// lambda.\n  TemplateParameterList *getGenericLambdaTemplateParameterList() const;\n\n  /// Retrieve the lambda template parameters that were specified explicitly.\n  ArrayRef<NamedDecl *> getLambdaExplicitTemplateParameters() const;\n\n  LambdaCaptureDefault getLambdaCaptureDefault() const {\n    assert(isLambda());\n    return static_cast<LambdaCaptureDefault>(getLambdaData().CaptureDefault);\n  }\n\n  /// Set the captures for this lambda closure type.\n  void setCaptures(ASTContext &Context, ArrayRef<LambdaCapture> Captures);\n\n  /// For a closure type, retrieve the mapping from captured\n  /// variables and \\c this to the non-static data members that store the\n  /// values or references of the captures.\n  ///\n  /// \\param Captures Will be populated with the mapping from captured\n  /// variables to the corresponding fields.\n  ///\n  /// \\param ThisCapture Will be set to the field declaration for the\n  /// \\c this capture.\n  ///\n  /// \\note No entries will be added for init-captures, as they do not capture\n  /// variables.\n  void getCaptureFields(llvm::DenseMap<const VarDecl *, FieldDecl *> &Captures,\n                        FieldDecl *&ThisCapture) const;\n\n  using capture_const_iterator = const LambdaCapture *;\n  using capture_const_range = llvm::iterator_range<capture_const_iterator>;\n\n  capture_const_range captures() const {\n    return capture_const_range(captures_begin(), captures_end());\n  }\n\n  capture_const_iterator captures_begin() const {\n    return isLambda() ? getLambdaData().Captures : nullptr;\n  }\n\n  capture_const_iterator captures_end() const {\n    return isLambda() ? captures_begin() + getLambdaData().NumCaptures\n                      : nullptr;\n  }\n\n  unsigned capture_size() const { return getLambdaData().NumCaptures; }\n\n  using conversion_iterator = UnresolvedSetIterator;\n\n  conversion_iterator conversion_begin() const {\n    return data().Conversions.get(getASTContext()).begin();\n  }\n\n  conversion_iterator conversion_end() const {\n    return data().Conversions.get(getASTContext()).end();\n  }\n\n  /// Removes a conversion function from this class.  The conversion\n  /// function must currently be a member of this class.  Furthermore,\n  /// this class must currently be in the process of being defined.\n  void removeConversion(const NamedDecl *Old);\n\n  /// Get all conversion functions visible in current class,\n  /// including conversion function templates.\n  llvm::iterator_range<conversion_iterator>\n  getVisibleConversionFunctions() const;\n\n  /// Determine whether this class is an aggregate (C++ [dcl.init.aggr]),\n  /// which is a class with no user-declared constructors, no private\n  /// or protected non-static data members, no base classes, and no virtual\n  /// functions (C++ [dcl.init.aggr]p1).\n  bool isAggregate() const { return data().Aggregate; }\n\n  /// Whether this class has any in-class initializers\n  /// for non-static data members (including those in anonymous unions or\n  /// structs).\n  bool hasInClassInitializer() const { return data().HasInClassInitializer; }\n\n  /// Whether this class or any of its subobjects has any members of\n  /// reference type which would make value-initialization ill-formed.\n  ///\n  /// Per C++03 [dcl.init]p5:\n  ///  - if T is a non-union class type without a user-declared constructor,\n  ///    then every non-static data member and base-class component of T is\n  ///    value-initialized [...] A program that calls for [...]\n  ///    value-initialization of an entity of reference type is ill-formed.\n  bool hasUninitializedReferenceMember() const {\n    return !isUnion() && !hasUserDeclaredConstructor() &&\n           data().HasUninitializedReferenceMember;\n  }\n\n  /// Whether this class is a POD-type (C++ [class]p4)\n  ///\n  /// For purposes of this function a class is POD if it is an aggregate\n  /// that has no non-static non-POD data members, no reference data\n  /// members, no user-defined copy assignment operator and no\n  /// user-defined destructor.\n  ///\n  /// Note that this is the C++ TR1 definition of POD.\n  bool isPOD() const { return data().PlainOldData; }\n\n  /// True if this class is C-like, without C++-specific features, e.g.\n  /// it contains only public fields, no bases, tag kind is not 'class', etc.\n  bool isCLike() const;\n\n  /// Determine whether this is an empty class in the sense of\n  /// (C++11 [meta.unary.prop]).\n  ///\n  /// The CXXRecordDecl is a class type, but not a union type,\n  /// with no non-static data members other than bit-fields of length 0,\n  /// no virtual member functions, no virtual base classes,\n  /// and no base class B for which is_empty<B>::value is false.\n  ///\n  /// \\note This does NOT include a check for union-ness.\n  bool isEmpty() const { return data().Empty; }\n\n  bool hasPrivateFields() const {\n    return data().HasPrivateFields;\n  }\n\n  bool hasProtectedFields() const {\n    return data().HasProtectedFields;\n  }\n\n  /// Determine whether this class has direct non-static data members.\n  bool hasDirectFields() const {\n    auto &D = data();\n    return D.HasPublicFields || D.HasProtectedFields || D.HasPrivateFields;\n  }\n\n  /// Whether this class is polymorphic (C++ [class.virtual]),\n  /// which means that the class contains or inherits a virtual function.\n  bool isPolymorphic() const { return data().Polymorphic; }\n\n  /// Determine whether this class has a pure virtual function.\n  ///\n  /// The class is is abstract per (C++ [class.abstract]p2) if it declares\n  /// a pure virtual function or inherits a pure virtual function that is\n  /// not overridden.\n  bool isAbstract() const { return data().Abstract; }\n\n  /// Determine whether this class is standard-layout per\n  /// C++ [class]p7.\n  bool isStandardLayout() const { return data().IsStandardLayout; }\n\n  /// Determine whether this class was standard-layout per\n  /// C++11 [class]p7, specifically using the C++11 rules without any DRs.\n  bool isCXX11StandardLayout() const { return data().IsCXX11StandardLayout; }\n\n  /// Determine whether this class, or any of its class subobjects,\n  /// contains a mutable field.\n  bool hasMutableFields() const { return data().HasMutableFields; }\n\n  /// Determine whether this class has any variant members.\n  bool hasVariantMembers() const { return data().HasVariantMembers; }\n\n  /// Determine whether this class has a trivial default constructor\n  /// (C++11 [class.ctor]p5).\n  bool hasTrivialDefaultConstructor() const {\n    return hasDefaultConstructor() &&\n           (data().HasTrivialSpecialMembers & SMF_DefaultConstructor);\n  }\n\n  /// Determine whether this class has a non-trivial default constructor\n  /// (C++11 [class.ctor]p5).\n  bool hasNonTrivialDefaultConstructor() const {\n    return (data().DeclaredNonTrivialSpecialMembers & SMF_DefaultConstructor) ||\n           (needsImplicitDefaultConstructor() &&\n            !(data().HasTrivialSpecialMembers & SMF_DefaultConstructor));\n  }\n\n  /// Determine whether this class has at least one constexpr constructor\n  /// other than the copy or move constructors.\n  bool hasConstexprNonCopyMoveConstructor() const {\n    return data().HasConstexprNonCopyMoveConstructor ||\n           (needsImplicitDefaultConstructor() &&\n            defaultedDefaultConstructorIsConstexpr());\n  }\n\n  /// Determine whether a defaulted default constructor for this class\n  /// would be constexpr.\n  bool defaultedDefaultConstructorIsConstexpr() const {\n    return data().DefaultedDefaultConstructorIsConstexpr &&\n           (!isUnion() || hasInClassInitializer() || !hasVariantMembers() ||\n            getLangOpts().CPlusPlus20);\n  }\n\n  /// Determine whether this class has a constexpr default constructor.\n  bool hasConstexprDefaultConstructor() const {\n    return data().HasConstexprDefaultConstructor ||\n           (needsImplicitDefaultConstructor() &&\n            defaultedDefaultConstructorIsConstexpr());\n  }\n\n  /// Determine whether this class has a trivial copy constructor\n  /// (C++ [class.copy]p6, C++11 [class.copy]p12)\n  bool hasTrivialCopyConstructor() const {\n    return data().HasTrivialSpecialMembers & SMF_CopyConstructor;\n  }\n\n  bool hasTrivialCopyConstructorForCall() const {\n    return data().HasTrivialSpecialMembersForCall & SMF_CopyConstructor;\n  }\n\n  /// Determine whether this class has a non-trivial copy constructor\n  /// (C++ [class.copy]p6, C++11 [class.copy]p12)\n  bool hasNonTrivialCopyConstructor() const {\n    return data().DeclaredNonTrivialSpecialMembers & SMF_CopyConstructor ||\n           !hasTrivialCopyConstructor();\n  }\n\n  bool hasNonTrivialCopyConstructorForCall() const {\n    return (data().DeclaredNonTrivialSpecialMembersForCall &\n            SMF_CopyConstructor) ||\n           !hasTrivialCopyConstructorForCall();\n  }\n\n  /// Determine whether this class has a trivial move constructor\n  /// (C++11 [class.copy]p12)\n  bool hasTrivialMoveConstructor() const {\n    return hasMoveConstructor() &&\n           (data().HasTrivialSpecialMembers & SMF_MoveConstructor);\n  }\n\n  bool hasTrivialMoveConstructorForCall() const {\n    return hasMoveConstructor() &&\n           (data().HasTrivialSpecialMembersForCall & SMF_MoveConstructor);\n  }\n\n  /// Determine whether this class has a non-trivial move constructor\n  /// (C++11 [class.copy]p12)\n  bool hasNonTrivialMoveConstructor() const {\n    return (data().DeclaredNonTrivialSpecialMembers & SMF_MoveConstructor) ||\n           (needsImplicitMoveConstructor() &&\n            !(data().HasTrivialSpecialMembers & SMF_MoveConstructor));\n  }\n\n  bool hasNonTrivialMoveConstructorForCall() const {\n    return (data().DeclaredNonTrivialSpecialMembersForCall &\n            SMF_MoveConstructor) ||\n           (needsImplicitMoveConstructor() &&\n            !(data().HasTrivialSpecialMembersForCall & SMF_MoveConstructor));\n  }\n\n  /// Determine whether this class has a trivial copy assignment operator\n  /// (C++ [class.copy]p11, C++11 [class.copy]p25)\n  bool hasTrivialCopyAssignment() const {\n    return data().HasTrivialSpecialMembers & SMF_CopyAssignment;\n  }\n\n  /// Determine whether this class has a non-trivial copy assignment\n  /// operator (C++ [class.copy]p11, C++11 [class.copy]p25)\n  bool hasNonTrivialCopyAssignment() const {\n    return data().DeclaredNonTrivialSpecialMembers & SMF_CopyAssignment ||\n           !hasTrivialCopyAssignment();\n  }\n\n  /// Determine whether this class has a trivial move assignment operator\n  /// (C++11 [class.copy]p25)\n  bool hasTrivialMoveAssignment() const {\n    return hasMoveAssignment() &&\n           (data().HasTrivialSpecialMembers & SMF_MoveAssignment);\n  }\n\n  /// Determine whether this class has a non-trivial move assignment\n  /// operator (C++11 [class.copy]p25)\n  bool hasNonTrivialMoveAssignment() const {\n    return (data().DeclaredNonTrivialSpecialMembers & SMF_MoveAssignment) ||\n           (needsImplicitMoveAssignment() &&\n            !(data().HasTrivialSpecialMembers & SMF_MoveAssignment));\n  }\n\n  /// Determine whether a defaulted default constructor for this class\n  /// would be constexpr.\n  bool defaultedDestructorIsConstexpr() const {\n    return data().DefaultedDestructorIsConstexpr &&\n           getLangOpts().CPlusPlus20;\n  }\n\n  /// Determine whether this class has a constexpr destructor.\n  bool hasConstexprDestructor() const;\n\n  /// Determine whether this class has a trivial destructor\n  /// (C++ [class.dtor]p3)\n  bool hasTrivialDestructor() const {\n    return data().HasTrivialSpecialMembers & SMF_Destructor;\n  }\n\n  bool hasTrivialDestructorForCall() const {\n    return data().HasTrivialSpecialMembersForCall & SMF_Destructor;\n  }\n\n  /// Determine whether this class has a non-trivial destructor\n  /// (C++ [class.dtor]p3)\n  bool hasNonTrivialDestructor() const {\n    return !(data().HasTrivialSpecialMembers & SMF_Destructor);\n  }\n\n  bool hasNonTrivialDestructorForCall() const {\n    return !(data().HasTrivialSpecialMembersForCall & SMF_Destructor);\n  }\n\n  void setHasTrivialSpecialMemberForCall() {\n    data().HasTrivialSpecialMembersForCall =\n        (SMF_CopyConstructor | SMF_MoveConstructor | SMF_Destructor);\n  }\n\n  /// Determine whether declaring a const variable with this type is ok\n  /// per core issue 253.\n  bool allowConstDefaultInit() const {\n    return !data().HasUninitializedFields ||\n           !(data().HasDefaultedDefaultConstructor ||\n             needsImplicitDefaultConstructor());\n  }\n\n  /// Determine whether this class has a destructor which has no\n  /// semantic effect.\n  ///\n  /// Any such destructor will be trivial, public, defaulted and not deleted,\n  /// and will call only irrelevant destructors.\n  bool hasIrrelevantDestructor() const {\n    return data().HasIrrelevantDestructor;\n  }\n\n  /// Determine whether this class has a non-literal or/ volatile type\n  /// non-static data member or base class.\n  bool hasNonLiteralTypeFieldsOrBases() const {\n    return data().HasNonLiteralTypeFieldsOrBases;\n  }\n\n  /// Determine whether this class has a using-declaration that names\n  /// a user-declared base class constructor.\n  bool hasInheritedConstructor() const {\n    return data().HasInheritedConstructor;\n  }\n\n  /// Determine whether this class has a using-declaration that names\n  /// a base class assignment operator.\n  bool hasInheritedAssignment() const {\n    return data().HasInheritedAssignment;\n  }\n\n  /// Determine whether this class is considered trivially copyable per\n  /// (C++11 [class]p6).\n  bool isTriviallyCopyable() const;\n\n  /// Determine whether this class is considered trivial.\n  ///\n  /// C++11 [class]p6:\n  ///    \"A trivial class is a class that has a trivial default constructor and\n  ///    is trivially copyable.\"\n  bool isTrivial() const {\n    return isTriviallyCopyable() && hasTrivialDefaultConstructor();\n  }\n\n  /// Determine whether this class is a literal type.\n  ///\n  /// C++11 [basic.types]p10:\n  ///   A class type that has all the following properties:\n  ///     - it has a trivial destructor\n  ///     - every constructor call and full-expression in the\n  ///       brace-or-equal-intializers for non-static data members (if any) is\n  ///       a constant expression.\n  ///     - it is an aggregate type or has at least one constexpr constructor\n  ///       or constructor template that is not a copy or move constructor, and\n  ///     - all of its non-static data members and base classes are of literal\n  ///       types\n  ///\n  /// We resolve DR1361 by ignoring the second bullet. We resolve DR1452 by\n  /// treating types with trivial default constructors as literal types.\n  ///\n  /// Only in C++17 and beyond, are lambdas literal types.\n  bool isLiteral() const {\n    const LangOptions &LangOpts = getLangOpts();\n    return (LangOpts.CPlusPlus20 ? hasConstexprDestructor()\n                                          : hasTrivialDestructor()) &&\n           (!isLambda() || LangOpts.CPlusPlus17) &&\n           !hasNonLiteralTypeFieldsOrBases() &&\n           (isAggregate() || isLambda() ||\n            hasConstexprNonCopyMoveConstructor() ||\n            hasTrivialDefaultConstructor());\n  }\n\n  /// Determine whether this is a structural type.\n  bool isStructural() const {\n    return isLiteral() && data().StructuralIfLiteral;\n  }\n\n  /// If this record is an instantiation of a member class,\n  /// retrieves the member class from which it was instantiated.\n  ///\n  /// This routine will return non-null for (non-templated) member\n  /// classes of class templates. For example, given:\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   struct A { };\n  /// };\n  /// \\endcode\n  ///\n  /// The declaration for X<int>::A is a (non-templated) CXXRecordDecl\n  /// whose parent is the class template specialization X<int>. For\n  /// this declaration, getInstantiatedFromMemberClass() will return\n  /// the CXXRecordDecl X<T>::A. When a complete definition of\n  /// X<int>::A is required, it will be instantiated from the\n  /// declaration returned by getInstantiatedFromMemberClass().\n  CXXRecordDecl *getInstantiatedFromMemberClass() const;\n\n  /// If this class is an instantiation of a member class of a\n  /// class template specialization, retrieves the member specialization\n  /// information.\n  MemberSpecializationInfo *getMemberSpecializationInfo() const;\n\n  /// Specify that this record is an instantiation of the\n  /// member class \\p RD.\n  void setInstantiationOfMemberClass(CXXRecordDecl *RD,\n                                     TemplateSpecializationKind TSK);\n\n  /// Retrieves the class template that is described by this\n  /// class declaration.\n  ///\n  /// Every class template is represented as a ClassTemplateDecl and a\n  /// CXXRecordDecl. The former contains template properties (such as\n  /// the template parameter lists) while the latter contains the\n  /// actual description of the template's\n  /// contents. ClassTemplateDecl::getTemplatedDecl() retrieves the\n  /// CXXRecordDecl that from a ClassTemplateDecl, while\n  /// getDescribedClassTemplate() retrieves the ClassTemplateDecl from\n  /// a CXXRecordDecl.\n  ClassTemplateDecl *getDescribedClassTemplate() const;\n\n  void setDescribedClassTemplate(ClassTemplateDecl *Template);\n\n  /// Determine whether this particular class is a specialization or\n  /// instantiation of a class template or member class of a class template,\n  /// and how it was instantiated or specialized.\n  TemplateSpecializationKind getTemplateSpecializationKind() const;\n\n  /// Set the kind of specialization or template instantiation this is.\n  void setTemplateSpecializationKind(TemplateSpecializationKind TSK);\n\n  /// Retrieve the record declaration from which this record could be\n  /// instantiated. Returns null if this class is not a template instantiation.\n  const CXXRecordDecl *getTemplateInstantiationPattern() const;\n\n  CXXRecordDecl *getTemplateInstantiationPattern() {\n    return const_cast<CXXRecordDecl *>(const_cast<const CXXRecordDecl *>(this)\n                                           ->getTemplateInstantiationPattern());\n  }\n\n  /// Returns the destructor decl for this class.\n  CXXDestructorDecl *getDestructor() const;\n\n  /// Returns true if the class destructor, or any implicitly invoked\n  /// destructors are marked noreturn.\n  bool isAnyDestructorNoReturn() const;\n\n  /// If the class is a local class [class.local], returns\n  /// the enclosing function declaration.\n  const FunctionDecl *isLocalClass() const {\n    if (const auto *RD = dyn_cast<CXXRecordDecl>(getDeclContext()))\n      return RD->isLocalClass();\n\n    return dyn_cast<FunctionDecl>(getDeclContext());\n  }\n\n  FunctionDecl *isLocalClass() {\n    return const_cast<FunctionDecl*>(\n        const_cast<const CXXRecordDecl*>(this)->isLocalClass());\n  }\n\n  /// Determine whether this dependent class is a current instantiation,\n  /// when viewed from within the given context.\n  bool isCurrentInstantiation(const DeclContext *CurContext) const;\n\n  /// Determine whether this class is derived from the class \\p Base.\n  ///\n  /// This routine only determines whether this class is derived from \\p Base,\n  /// but does not account for factors that may make a Derived -> Base class\n  /// ill-formed, such as private/protected inheritance or multiple, ambiguous\n  /// base class subobjects.\n  ///\n  /// \\param Base the base class we are searching for.\n  ///\n  /// \\returns true if this class is derived from Base, false otherwise.\n  bool isDerivedFrom(const CXXRecordDecl *Base) const;\n\n  /// Determine whether this class is derived from the type \\p Base.\n  ///\n  /// This routine only determines whether this class is derived from \\p Base,\n  /// but does not account for factors that may make a Derived -> Base class\n  /// ill-formed, such as private/protected inheritance or multiple, ambiguous\n  /// base class subobjects.\n  ///\n  /// \\param Base the base class we are searching for.\n  ///\n  /// \\param Paths will contain the paths taken from the current class to the\n  /// given \\p Base class.\n  ///\n  /// \\returns true if this class is derived from \\p Base, false otherwise.\n  ///\n  /// \\todo add a separate parameter to configure IsDerivedFrom, rather than\n  /// tangling input and output in \\p Paths\n  bool isDerivedFrom(const CXXRecordDecl *Base, CXXBasePaths &Paths) const;\n\n  /// Determine whether this class is virtually derived from\n  /// the class \\p Base.\n  ///\n  /// This routine only determines whether this class is virtually\n  /// derived from \\p Base, but does not account for factors that may\n  /// make a Derived -> Base class ill-formed, such as\n  /// private/protected inheritance or multiple, ambiguous base class\n  /// subobjects.\n  ///\n  /// \\param Base the base class we are searching for.\n  ///\n  /// \\returns true if this class is virtually derived from Base,\n  /// false otherwise.\n  bool isVirtuallyDerivedFrom(const CXXRecordDecl *Base) const;\n\n  /// Determine whether this class is provably not derived from\n  /// the type \\p Base.\n  bool isProvablyNotDerivedFrom(const CXXRecordDecl *Base) const;\n\n  /// Function type used by forallBases() as a callback.\n  ///\n  /// \\param BaseDefinition the definition of the base class\n  ///\n  /// \\returns true if this base matched the search criteria\n  using ForallBasesCallback =\n      llvm::function_ref<bool(const CXXRecordDecl *BaseDefinition)>;\n\n  /// Determines if the given callback holds for all the direct\n  /// or indirect base classes of this type.\n  ///\n  /// The class itself does not count as a base class.  This routine\n  /// returns false if the class has non-computable base classes.\n  ///\n  /// \\param BaseMatches Callback invoked for each (direct or indirect) base\n  /// class of this type until a call returns false.\n  bool forallBases(ForallBasesCallback BaseMatches) const;\n\n  /// Function type used by lookupInBases() to determine whether a\n  /// specific base class subobject matches the lookup criteria.\n  ///\n  /// \\param Specifier the base-class specifier that describes the inheritance\n  /// from the base class we are trying to match.\n  ///\n  /// \\param Path the current path, from the most-derived class down to the\n  /// base named by the \\p Specifier.\n  ///\n  /// \\returns true if this base matched the search criteria, false otherwise.\n  using BaseMatchesCallback =\n      llvm::function_ref<bool(const CXXBaseSpecifier *Specifier,\n                              CXXBasePath &Path)>;\n\n  /// Look for entities within the base classes of this C++ class,\n  /// transitively searching all base class subobjects.\n  ///\n  /// This routine uses the callback function \\p BaseMatches to find base\n  /// classes meeting some search criteria, walking all base class subobjects\n  /// and populating the given \\p Paths structure with the paths through the\n  /// inheritance hierarchy that resulted in a match. On a successful search,\n  /// the \\p Paths structure can be queried to retrieve the matching paths and\n  /// to determine if there were any ambiguities.\n  ///\n  /// \\param BaseMatches callback function used to determine whether a given\n  /// base matches the user-defined search criteria.\n  ///\n  /// \\param Paths used to record the paths from this class to its base class\n  /// subobjects that match the search criteria.\n  ///\n  /// \\param LookupInDependent can be set to true to extend the search to\n  /// dependent base classes.\n  ///\n  /// \\returns true if there exists any path from this class to a base class\n  /// subobject that matches the search criteria.\n  bool lookupInBases(BaseMatchesCallback BaseMatches, CXXBasePaths &Paths,\n                     bool LookupInDependent = false) const;\n\n  /// Base-class lookup callback that determines whether the given\n  /// base class specifier refers to a specific class declaration.\n  ///\n  /// This callback can be used with \\c lookupInBases() to determine whether\n  /// a given derived class has is a base class subobject of a particular type.\n  /// The base record pointer should refer to the canonical CXXRecordDecl of the\n  /// base class that we are searching for.\n  static bool FindBaseClass(const CXXBaseSpecifier *Specifier,\n                            CXXBasePath &Path, const CXXRecordDecl *BaseRecord);\n\n  /// Base-class lookup callback that determines whether the\n  /// given base class specifier refers to a specific class\n  /// declaration and describes virtual derivation.\n  ///\n  /// This callback can be used with \\c lookupInBases() to determine\n  /// whether a given derived class has is a virtual base class\n  /// subobject of a particular type.  The base record pointer should\n  /// refer to the canonical CXXRecordDecl of the base class that we\n  /// are searching for.\n  static bool FindVirtualBaseClass(const CXXBaseSpecifier *Specifier,\n                                   CXXBasePath &Path,\n                                   const CXXRecordDecl *BaseRecord);\n\n  /// Retrieve the final overriders for each virtual member\n  /// function in the class hierarchy where this class is the\n  /// most-derived class in the class hierarchy.\n  void getFinalOverriders(CXXFinalOverriderMap &FinaOverriders) const;\n\n  /// Get the indirect primary bases for this class.\n  void getIndirectPrimaryBases(CXXIndirectPrimaryBaseSet& Bases) const;\n\n  /// Determine whether this class has a member with the given name, possibly\n  /// in a non-dependent base class.\n  ///\n  /// No check for ambiguity is performed, so this should never be used when\n  /// implementing language semantics, but it may be appropriate for warnings,\n  /// static analysis, or similar.\n  bool hasMemberName(DeclarationName N) const;\n\n  /// Performs an imprecise lookup of a dependent name in this class.\n  ///\n  /// This function does not follow strict semantic rules and should be used\n  /// only when lookup rules can be relaxed, e.g. indexing.\n  std::vector<const NamedDecl *>\n  lookupDependentName(DeclarationName Name,\n                      llvm::function_ref<bool(const NamedDecl *ND)> Filter);\n\n  /// Renders and displays an inheritance diagram\n  /// for this C++ class and all of its base classes (transitively) using\n  /// GraphViz.\n  void viewInheritance(ASTContext& Context) const;\n\n  /// Calculates the access of a decl that is reached\n  /// along a path.\n  static AccessSpecifier MergeAccess(AccessSpecifier PathAccess,\n                                     AccessSpecifier DeclAccess) {\n    assert(DeclAccess != AS_none);\n    if (DeclAccess == AS_private) return AS_none;\n    return (PathAccess > DeclAccess ? PathAccess : DeclAccess);\n  }\n\n  /// Indicates that the declaration of a defaulted or deleted special\n  /// member function is now complete.\n  void finishedDefaultedOrDeletedMember(CXXMethodDecl *MD);\n\n  void setTrivialForCallFlags(CXXMethodDecl *MD);\n\n  /// Indicates that the definition of this class is now complete.\n  void completeDefinition() override;\n\n  /// Indicates that the definition of this class is now complete,\n  /// and provides a final overrider map to help determine\n  ///\n  /// \\param FinalOverriders The final overrider map for this class, which can\n  /// be provided as an optimization for abstract-class checking. If NULL,\n  /// final overriders will be computed if they are needed to complete the\n  /// definition.\n  void completeDefinition(CXXFinalOverriderMap *FinalOverriders);\n\n  /// Determine whether this class may end up being abstract, even though\n  /// it is not yet known to be abstract.\n  ///\n  /// \\returns true if this class is not known to be abstract but has any\n  /// base classes that are abstract. In this case, \\c completeDefinition()\n  /// will need to compute final overriders to determine whether the class is\n  /// actually abstract.\n  bool mayBeAbstract() const;\n\n  /// Determine whether it's impossible for a class to be derived from this\n  /// class. This is best-effort, and may conservatively return false.\n  bool isEffectivelyFinal() const;\n\n  /// If this is the closure type of a lambda expression, retrieve the\n  /// number to be used for name mangling in the Itanium C++ ABI.\n  ///\n  /// Zero indicates that this closure type has internal linkage, so the\n  /// mangling number does not matter, while a non-zero value indicates which\n  /// lambda expression this is in this particular context.\n  unsigned getLambdaManglingNumber() const {\n    assert(isLambda() && \"Not a lambda closure type!\");\n    return getLambdaData().ManglingNumber;\n  }\n\n  /// The lambda is known to has internal linkage no matter whether it has name\n  /// mangling number.\n  bool hasKnownLambdaInternalLinkage() const {\n    assert(isLambda() && \"Not a lambda closure type!\");\n    return getLambdaData().HasKnownInternalLinkage;\n  }\n\n  /// Retrieve the declaration that provides additional context for a\n  /// lambda, when the normal declaration context is not specific enough.\n  ///\n  /// Certain contexts (default arguments of in-class function parameters and\n  /// the initializers of data members) have separate name mangling rules for\n  /// lambdas within the Itanium C++ ABI. For these cases, this routine provides\n  /// the declaration in which the lambda occurs, e.g., the function parameter\n  /// or the non-static data member. Otherwise, it returns NULL to imply that\n  /// the declaration context suffices.\n  Decl *getLambdaContextDecl() const;\n\n  /// Set the mangling number and context declaration for a lambda\n  /// class.\n  void setLambdaMangling(unsigned ManglingNumber, Decl *ContextDecl,\n                         bool HasKnownInternalLinkage = false) {\n    assert(isLambda() && \"Not a lambda closure type!\");\n    getLambdaData().ManglingNumber = ManglingNumber;\n    getLambdaData().ContextDecl = ContextDecl;\n    getLambdaData().HasKnownInternalLinkage = HasKnownInternalLinkage;\n  }\n\n  /// Set the device side mangling number.\n  void setDeviceLambdaManglingNumber(unsigned Num) const;\n\n  /// Retrieve the device side mangling number.\n  unsigned getDeviceLambdaManglingNumber() const;\n\n  /// Returns the inheritance model used for this record.\n  MSInheritanceModel getMSInheritanceModel() const;\n\n  /// Calculate what the inheritance model would be for this class.\n  MSInheritanceModel calculateInheritanceModel() const;\n\n  /// In the Microsoft C++ ABI, use zero for the field offset of a null data\n  /// member pointer if we can guarantee that zero is not a valid field offset,\n  /// or if the member pointer has multiple fields.  Polymorphic classes have a\n  /// vfptr at offset zero, so we can use zero for null.  If there are multiple\n  /// fields, we can use zero even if it is a valid field offset because\n  /// null-ness testing will check the other fields.\n  bool nullFieldOffsetIsZero() const;\n\n  /// Controls when vtordisps will be emitted if this record is used as a\n  /// virtual base.\n  MSVtorDispMode getMSVtorDispMode() const;\n\n  /// Determine whether this lambda expression was known to be dependent\n  /// at the time it was created, even if its context does not appear to be\n  /// dependent.\n  ///\n  /// This flag is a workaround for an issue with parsing, where default\n  /// arguments are parsed before their enclosing function declarations have\n  /// been created. This means that any lambda expressions within those\n  /// default arguments will have as their DeclContext the context enclosing\n  /// the function declaration, which may be non-dependent even when the\n  /// function declaration itself is dependent. This flag indicates when we\n  /// know that the lambda is dependent despite that.\n  bool isDependentLambda() const {\n    return isLambda() && getLambdaData().Dependent;\n  }\n\n  TypeSourceInfo *getLambdaTypeInfo() const {\n    return getLambdaData().MethodTyInfo;\n  }\n\n  // Determine whether this type is an Interface Like type for\n  // __interface inheritance purposes.\n  bool isInterfaceLike() const;\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K >= firstCXXRecord && K <= lastCXXRecord;\n  }\n};\n\n/// Store information needed for an explicit specifier.\n/// Used by CXXDeductionGuideDecl, CXXConstructorDecl and CXXConversionDecl.\nclass ExplicitSpecifier {\n  llvm::PointerIntPair<Expr *, 2, ExplicitSpecKind> ExplicitSpec{\n      nullptr, ExplicitSpecKind::ResolvedFalse};\n\npublic:\n  ExplicitSpecifier() = default;\n  ExplicitSpecifier(Expr *Expression, ExplicitSpecKind Kind)\n      : ExplicitSpec(Expression, Kind) {}\n  ExplicitSpecKind getKind() const { return ExplicitSpec.getInt(); }\n  const Expr *getExpr() const { return ExplicitSpec.getPointer(); }\n  Expr *getExpr() { return ExplicitSpec.getPointer(); }\n\n  /// Determine if the declaration had an explicit specifier of any kind.\n  bool isSpecified() const {\n    return ExplicitSpec.getInt() != ExplicitSpecKind::ResolvedFalse ||\n           ExplicitSpec.getPointer();\n  }\n\n  /// Check for equivalence of explicit specifiers.\n  /// \\return true if the explicit specifier are equivalent, false otherwise.\n  bool isEquivalent(const ExplicitSpecifier Other) const;\n  /// Determine whether this specifier is known to correspond to an explicit\n  /// declaration. Returns false if the specifier is absent or has an\n  /// expression that is value-dependent or evaluates to false.\n  bool isExplicit() const {\n    return ExplicitSpec.getInt() == ExplicitSpecKind::ResolvedTrue;\n  }\n  /// Determine if the explicit specifier is invalid.\n  /// This state occurs after a substitution failures.\n  bool isInvalid() const {\n    return ExplicitSpec.getInt() == ExplicitSpecKind::Unresolved &&\n           !ExplicitSpec.getPointer();\n  }\n  void setKind(ExplicitSpecKind Kind) { ExplicitSpec.setInt(Kind); }\n  void setExpr(Expr *E) { ExplicitSpec.setPointer(E); }\n  // Retrieve the explicit specifier in the given declaration, if any.\n  static ExplicitSpecifier getFromDecl(FunctionDecl *Function);\n  static const ExplicitSpecifier getFromDecl(const FunctionDecl *Function) {\n    return getFromDecl(const_cast<FunctionDecl *>(Function));\n  }\n  static ExplicitSpecifier Invalid() {\n    return ExplicitSpecifier(nullptr, ExplicitSpecKind::Unresolved);\n  }\n};\n\n/// Represents a C++ deduction guide declaration.\n///\n/// \\code\n/// template<typename T> struct A { A(); A(T); };\n/// A() -> A<int>;\n/// \\endcode\n///\n/// In this example, there will be an explicit deduction guide from the\n/// second line, and implicit deduction guide templates synthesized from\n/// the constructors of \\c A.\nclass CXXDeductionGuideDecl : public FunctionDecl {\n  void anchor() override;\n\nprivate:\n  CXXDeductionGuideDecl(ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n                        ExplicitSpecifier ES,\n                        const DeclarationNameInfo &NameInfo, QualType T,\n                        TypeSourceInfo *TInfo, SourceLocation EndLocation)\n      : FunctionDecl(CXXDeductionGuide, C, DC, StartLoc, NameInfo, T, TInfo,\n                     SC_None, false, ConstexprSpecKind::Unspecified),\n        ExplicitSpec(ES) {\n    if (EndLocation.isValid())\n      setRangeEnd(EndLocation);\n    setIsCopyDeductionCandidate(false);\n  }\n\n  ExplicitSpecifier ExplicitSpec;\n  void setExplicitSpecifier(ExplicitSpecifier ES) { ExplicitSpec = ES; }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static CXXDeductionGuideDecl *\n  Create(ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n         ExplicitSpecifier ES, const DeclarationNameInfo &NameInfo, QualType T,\n         TypeSourceInfo *TInfo, SourceLocation EndLocation);\n\n  static CXXDeductionGuideDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  ExplicitSpecifier getExplicitSpecifier() { return ExplicitSpec; }\n  const ExplicitSpecifier getExplicitSpecifier() const { return ExplicitSpec; }\n\n  /// Return true if the declartion is already resolved to be explicit.\n  bool isExplicit() const { return ExplicitSpec.isExplicit(); }\n\n  /// Get the template for which this guide performs deduction.\n  TemplateDecl *getDeducedTemplate() const {\n    return getDeclName().getCXXDeductionGuideTemplate();\n  }\n\n  void setIsCopyDeductionCandidate(bool isCDC = true) {\n    FunctionDeclBits.IsCopyDeductionCandidate = isCDC;\n  }\n\n  bool isCopyDeductionCandidate() const {\n    return FunctionDeclBits.IsCopyDeductionCandidate;\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == CXXDeductionGuide; }\n};\n\n/// \\brief Represents the body of a requires-expression.\n///\n/// This decl exists merely to serve as the DeclContext for the local\n/// parameters of the requires expression as well as other declarations inside\n/// it.\n///\n/// \\code\n/// template<typename T> requires requires (T t) { {t++} -> regular; }\n/// \\endcode\n///\n/// In this example, a RequiresExpr object will be generated for the expression,\n/// and a RequiresExprBodyDecl will be created to hold the parameter t and the\n/// template argument list imposed by the compound requirement.\nclass RequiresExprBodyDecl : public Decl, public DeclContext {\n  RequiresExprBodyDecl(ASTContext &C, DeclContext *DC, SourceLocation StartLoc)\n      : Decl(RequiresExprBody, DC, StartLoc), DeclContext(RequiresExprBody) {}\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static RequiresExprBodyDecl *Create(ASTContext &C, DeclContext *DC,\n                                      SourceLocation StartLoc);\n\n  static RequiresExprBodyDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == RequiresExprBody; }\n};\n\n/// Represents a static or instance method of a struct/union/class.\n///\n/// In the terminology of the C++ Standard, these are the (static and\n/// non-static) member functions, whether virtual or not.\nclass CXXMethodDecl : public FunctionDecl {\n  void anchor() override;\n\nprotected:\n  CXXMethodDecl(Kind DK, ASTContext &C, CXXRecordDecl *RD,\n                SourceLocation StartLoc, const DeclarationNameInfo &NameInfo,\n                QualType T, TypeSourceInfo *TInfo, StorageClass SC,\n                bool isInline, ConstexprSpecKind ConstexprKind,\n                SourceLocation EndLocation,\n                Expr *TrailingRequiresClause = nullptr)\n      : FunctionDecl(DK, C, RD, StartLoc, NameInfo, T, TInfo, SC, isInline,\n                     ConstexprKind, TrailingRequiresClause) {\n    if (EndLocation.isValid())\n      setRangeEnd(EndLocation);\n  }\n\npublic:\n  static CXXMethodDecl *Create(ASTContext &C, CXXRecordDecl *RD,\n                               SourceLocation StartLoc,\n                               const DeclarationNameInfo &NameInfo, QualType T,\n                               TypeSourceInfo *TInfo, StorageClass SC,\n                               bool isInline, ConstexprSpecKind ConstexprKind,\n                               SourceLocation EndLocation,\n                               Expr *TrailingRequiresClause = nullptr);\n\n  static CXXMethodDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  bool isStatic() const;\n  bool isInstance() const { return !isStatic(); }\n\n  /// Returns true if the given operator is implicitly static in a record\n  /// context.\n  static bool isStaticOverloadedOperator(OverloadedOperatorKind OOK) {\n    // [class.free]p1:\n    // Any allocation function for a class T is a static member\n    // (even if not explicitly declared static).\n    // [class.free]p6 Any deallocation function for a class X is a static member\n    // (even if not explicitly declared static).\n    return OOK == OO_New || OOK == OO_Array_New || OOK == OO_Delete ||\n           OOK == OO_Array_Delete;\n  }\n\n  bool isConst() const { return getType()->castAs<FunctionType>()->isConst(); }\n  bool isVolatile() const { return getType()->castAs<FunctionType>()->isVolatile(); }\n\n  bool isVirtual() const {\n    CXXMethodDecl *CD = const_cast<CXXMethodDecl*>(this)->getCanonicalDecl();\n\n    // Member function is virtual if it is marked explicitly so, or if it is\n    // declared in __interface -- then it is automatically pure virtual.\n    if (CD->isVirtualAsWritten() || CD->isPure())\n      return true;\n\n    return CD->size_overridden_methods() != 0;\n  }\n\n  /// If it's possible to devirtualize a call to this method, return the called\n  /// function. Otherwise, return null.\n\n  /// \\param Base The object on which this virtual function is called.\n  /// \\param IsAppleKext True if we are compiling for Apple kext.\n  CXXMethodDecl *getDevirtualizedMethod(const Expr *Base, bool IsAppleKext);\n\n  const CXXMethodDecl *getDevirtualizedMethod(const Expr *Base,\n                                              bool IsAppleKext) const {\n    return const_cast<CXXMethodDecl *>(this)->getDevirtualizedMethod(\n        Base, IsAppleKext);\n  }\n\n  /// Determine whether this is a usual deallocation function (C++\n  /// [basic.stc.dynamic.deallocation]p2), which is an overloaded delete or\n  /// delete[] operator with a particular signature. Populates \\p PreventedBy\n  /// with the declarations of the functions of the same kind if they were the\n  /// reason for this function returning false. This is used by\n  /// Sema::isUsualDeallocationFunction to reconsider the answer based on the\n  /// context.\n  bool isUsualDeallocationFunction(\n      SmallVectorImpl<const FunctionDecl *> &PreventedBy) const;\n\n  /// Determine whether this is a copy-assignment operator, regardless\n  /// of whether it was declared implicitly or explicitly.\n  bool isCopyAssignmentOperator() const;\n\n  /// Determine whether this is a move assignment operator.\n  bool isMoveAssignmentOperator() const;\n\n  CXXMethodDecl *getCanonicalDecl() override {\n    return cast<CXXMethodDecl>(FunctionDecl::getCanonicalDecl());\n  }\n  const CXXMethodDecl *getCanonicalDecl() const {\n    return const_cast<CXXMethodDecl*>(this)->getCanonicalDecl();\n  }\n\n  CXXMethodDecl *getMostRecentDecl() {\n    return cast<CXXMethodDecl>(\n            static_cast<FunctionDecl *>(this)->getMostRecentDecl());\n  }\n  const CXXMethodDecl *getMostRecentDecl() const {\n    return const_cast<CXXMethodDecl*>(this)->getMostRecentDecl();\n  }\n\n  void addOverriddenMethod(const CXXMethodDecl *MD);\n\n  using method_iterator = const CXXMethodDecl *const *;\n\n  method_iterator begin_overridden_methods() const;\n  method_iterator end_overridden_methods() const;\n  unsigned size_overridden_methods() const;\n\n  using overridden_method_range = llvm::iterator_range<\n      llvm::TinyPtrVector<const CXXMethodDecl *>::const_iterator>;\n\n  overridden_method_range overridden_methods() const;\n\n  /// Return the parent of this method declaration, which\n  /// is the class in which this method is defined.\n  const CXXRecordDecl *getParent() const {\n    return cast<CXXRecordDecl>(FunctionDecl::getParent());\n  }\n\n  /// Return the parent of this method declaration, which\n  /// is the class in which this method is defined.\n  CXXRecordDecl *getParent() {\n    return const_cast<CXXRecordDecl *>(\n             cast<CXXRecordDecl>(FunctionDecl::getParent()));\n  }\n\n  /// Return the type of the \\c this pointer.\n  ///\n  /// Should only be called for instance (i.e., non-static) methods. Note\n  /// that for the call operator of a lambda closure type, this returns the\n  /// desugared 'this' type (a pointer to the closure type), not the captured\n  /// 'this' type.\n  QualType getThisType() const;\n\n  /// Return the type of the object pointed by \\c this.\n  ///\n  /// See getThisType() for usage restriction.\n  QualType getThisObjectType() const;\n\n  static QualType getThisType(const FunctionProtoType *FPT,\n                              const CXXRecordDecl *Decl);\n\n  static QualType getThisObjectType(const FunctionProtoType *FPT,\n                                    const CXXRecordDecl *Decl);\n\n  Qualifiers getMethodQualifiers() const {\n    return getType()->castAs<FunctionProtoType>()->getMethodQuals();\n  }\n\n  /// Retrieve the ref-qualifier associated with this method.\n  ///\n  /// In the following example, \\c f() has an lvalue ref-qualifier, \\c g()\n  /// has an rvalue ref-qualifier, and \\c h() has no ref-qualifier.\n  /// @code\n  /// struct X {\n  ///   void f() &;\n  ///   void g() &&;\n  ///   void h();\n  /// };\n  /// @endcode\n  RefQualifierKind getRefQualifier() const {\n    return getType()->castAs<FunctionProtoType>()->getRefQualifier();\n  }\n\n  bool hasInlineBody() const;\n\n  /// Determine whether this is a lambda closure type's static member\n  /// function that is used for the result of the lambda's conversion to\n  /// function pointer (for a lambda with no captures).\n  ///\n  /// The function itself, if used, will have a placeholder body that will be\n  /// supplied by IR generation to either forward to the function call operator\n  /// or clone the function call operator.\n  bool isLambdaStaticInvoker() const;\n\n  /// Find the method in \\p RD that corresponds to this one.\n  ///\n  /// Find if \\p RD or one of the classes it inherits from override this method.\n  /// If so, return it. \\p RD is assumed to be a subclass of the class defining\n  /// this method (or be the class itself), unless \\p MayBeBase is set to true.\n  CXXMethodDecl *\n  getCorrespondingMethodInClass(const CXXRecordDecl *RD,\n                                bool MayBeBase = false);\n\n  const CXXMethodDecl *\n  getCorrespondingMethodInClass(const CXXRecordDecl *RD,\n                                bool MayBeBase = false) const {\n    return const_cast<CXXMethodDecl *>(this)\n              ->getCorrespondingMethodInClass(RD, MayBeBase);\n  }\n\n  /// Find if \\p RD declares a function that overrides this function, and if so,\n  /// return it. Does not search base classes.\n  CXXMethodDecl *getCorrespondingMethodDeclaredInClass(const CXXRecordDecl *RD,\n                                                       bool MayBeBase = false);\n  const CXXMethodDecl *\n  getCorrespondingMethodDeclaredInClass(const CXXRecordDecl *RD,\n                                        bool MayBeBase = false) const {\n    return const_cast<CXXMethodDecl *>(this)\n        ->getCorrespondingMethodDeclaredInClass(RD, MayBeBase);\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K >= firstCXXMethod && K <= lastCXXMethod;\n  }\n};\n\n/// Represents a C++ base or member initializer.\n///\n/// This is part of a constructor initializer that\n/// initializes one non-static member variable or one base class. For\n/// example, in the following, both 'A(a)' and 'f(3.14159)' are member\n/// initializers:\n///\n/// \\code\n/// class A { };\n/// class B : public A {\n///   float f;\n/// public:\n///   B(A& a) : A(a), f(3.14159) { }\n/// };\n/// \\endcode\nclass CXXCtorInitializer final {\n  /// Either the base class name/delegating constructor type (stored as\n  /// a TypeSourceInfo*), an normal field (FieldDecl), or an anonymous field\n  /// (IndirectFieldDecl*) being initialized.\n  llvm::PointerUnion<TypeSourceInfo *, FieldDecl *, IndirectFieldDecl *>\n      Initializee;\n\n  /// The argument used to initialize the base or member, which may\n  /// end up constructing an object (when multiple arguments are involved).\n  Stmt *Init;\n\n  /// The source location for the field name or, for a base initializer\n  /// pack expansion, the location of the ellipsis.\n  ///\n  /// In the case of a delegating\n  /// constructor, it will still include the type's source location as the\n  /// Initializee points to the CXXConstructorDecl (to allow loop detection).\n  SourceLocation MemberOrEllipsisLocation;\n\n  /// Location of the left paren of the ctor-initializer.\n  SourceLocation LParenLoc;\n\n  /// Location of the right paren of the ctor-initializer.\n  SourceLocation RParenLoc;\n\n  /// If the initializee is a type, whether that type makes this\n  /// a delegating initialization.\n  unsigned IsDelegating : 1;\n\n  /// If the initializer is a base initializer, this keeps track\n  /// of whether the base is virtual or not.\n  unsigned IsVirtual : 1;\n\n  /// Whether or not the initializer is explicitly written\n  /// in the sources.\n  unsigned IsWritten : 1;\n\n  /// If IsWritten is true, then this number keeps track of the textual order\n  /// of this initializer in the original sources, counting from 0.\n  unsigned SourceOrder : 13;\n\npublic:\n  /// Creates a new base-class initializer.\n  explicit\n  CXXCtorInitializer(ASTContext &Context, TypeSourceInfo *TInfo, bool IsVirtual,\n                     SourceLocation L, Expr *Init, SourceLocation R,\n                     SourceLocation EllipsisLoc);\n\n  /// Creates a new member initializer.\n  explicit\n  CXXCtorInitializer(ASTContext &Context, FieldDecl *Member,\n                     SourceLocation MemberLoc, SourceLocation L, Expr *Init,\n                     SourceLocation R);\n\n  /// Creates a new anonymous field initializer.\n  explicit\n  CXXCtorInitializer(ASTContext &Context, IndirectFieldDecl *Member,\n                     SourceLocation MemberLoc, SourceLocation L, Expr *Init,\n                     SourceLocation R);\n\n  /// Creates a new delegating initializer.\n  explicit\n  CXXCtorInitializer(ASTContext &Context, TypeSourceInfo *TInfo,\n                     SourceLocation L, Expr *Init, SourceLocation R);\n\n  /// \\return Unique reproducible object identifier.\n  int64_t getID(const ASTContext &Context) const;\n\n  /// Determine whether this initializer is initializing a base class.\n  bool isBaseInitializer() const {\n    return Initializee.is<TypeSourceInfo*>() && !IsDelegating;\n  }\n\n  /// Determine whether this initializer is initializing a non-static\n  /// data member.\n  bool isMemberInitializer() const { return Initializee.is<FieldDecl*>(); }\n\n  bool isAnyMemberInitializer() const {\n    return isMemberInitializer() || isIndirectMemberInitializer();\n  }\n\n  bool isIndirectMemberInitializer() const {\n    return Initializee.is<IndirectFieldDecl*>();\n  }\n\n  /// Determine whether this initializer is an implicit initializer\n  /// generated for a field with an initializer defined on the member\n  /// declaration.\n  ///\n  /// In-class member initializers (also known as \"non-static data member\n  /// initializations\", NSDMIs) were introduced in C++11.\n  bool isInClassMemberInitializer() const {\n    return Init->getStmtClass() == Stmt::CXXDefaultInitExprClass;\n  }\n\n  /// Determine whether this initializer is creating a delegating\n  /// constructor.\n  bool isDelegatingInitializer() const {\n    return Initializee.is<TypeSourceInfo*>() && IsDelegating;\n  }\n\n  /// Determine whether this initializer is a pack expansion.\n  bool isPackExpansion() const {\n    return isBaseInitializer() && MemberOrEllipsisLocation.isValid();\n  }\n\n  // For a pack expansion, returns the location of the ellipsis.\n  SourceLocation getEllipsisLoc() const {\n    assert(isPackExpansion() && \"Initializer is not a pack expansion\");\n    return MemberOrEllipsisLocation;\n  }\n\n  /// If this is a base class initializer, returns the type of the\n  /// base class with location information. Otherwise, returns an NULL\n  /// type location.\n  TypeLoc getBaseClassLoc() const;\n\n  /// If this is a base class initializer, returns the type of the base class.\n  /// Otherwise, returns null.\n  const Type *getBaseClass() const;\n\n  /// Returns whether the base is virtual or not.\n  bool isBaseVirtual() const {\n    assert(isBaseInitializer() && \"Must call this on base initializer!\");\n\n    return IsVirtual;\n  }\n\n  /// Returns the declarator information for a base class or delegating\n  /// initializer.\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return Initializee.dyn_cast<TypeSourceInfo *>();\n  }\n\n  /// If this is a member initializer, returns the declaration of the\n  /// non-static data member being initialized. Otherwise, returns null.\n  FieldDecl *getMember() const {\n    if (isMemberInitializer())\n      return Initializee.get<FieldDecl*>();\n    return nullptr;\n  }\n\n  FieldDecl *getAnyMember() const {\n    if (isMemberInitializer())\n      return Initializee.get<FieldDecl*>();\n    if (isIndirectMemberInitializer())\n      return Initializee.get<IndirectFieldDecl*>()->getAnonField();\n    return nullptr;\n  }\n\n  IndirectFieldDecl *getIndirectMember() const {\n    if (isIndirectMemberInitializer())\n      return Initializee.get<IndirectFieldDecl*>();\n    return nullptr;\n  }\n\n  SourceLocation getMemberLocation() const {\n    return MemberOrEllipsisLocation;\n  }\n\n  /// Determine the source location of the initializer.\n  SourceLocation getSourceLocation() const;\n\n  /// Determine the source range covering the entire initializer.\n  SourceRange getSourceRange() const LLVM_READONLY;\n\n  /// Determine whether this initializer is explicitly written\n  /// in the source code.\n  bool isWritten() const { return IsWritten; }\n\n  /// Return the source position of the initializer, counting from 0.\n  /// If the initializer was implicit, -1 is returned.\n  int getSourceOrder() const {\n    return IsWritten ? static_cast<int>(SourceOrder) : -1;\n  }\n\n  /// Set the source order of this initializer.\n  ///\n  /// This can only be called once for each initializer; it cannot be called\n  /// on an initializer having a positive number of (implicit) array indices.\n  ///\n  /// This assumes that the initializer was written in the source code, and\n  /// ensures that isWritten() returns true.\n  void setSourceOrder(int Pos) {\n    assert(!IsWritten &&\n           \"setSourceOrder() used on implicit initializer\");\n    assert(SourceOrder == 0 &&\n           \"calling twice setSourceOrder() on the same initializer\");\n    assert(Pos >= 0 &&\n           \"setSourceOrder() used to make an initializer implicit\");\n    IsWritten = true;\n    SourceOrder = static_cast<unsigned>(Pos);\n  }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n\n  /// Get the initializer.\n  Expr *getInit() const { return static_cast<Expr *>(Init); }\n};\n\n/// Description of a constructor that was inherited from a base class.\nclass InheritedConstructor {\n  ConstructorUsingShadowDecl *Shadow = nullptr;\n  CXXConstructorDecl *BaseCtor = nullptr;\n\npublic:\n  InheritedConstructor() = default;\n  InheritedConstructor(ConstructorUsingShadowDecl *Shadow,\n                       CXXConstructorDecl *BaseCtor)\n      : Shadow(Shadow), BaseCtor(BaseCtor) {}\n\n  explicit operator bool() const { return Shadow; }\n\n  ConstructorUsingShadowDecl *getShadowDecl() const { return Shadow; }\n  CXXConstructorDecl *getConstructor() const { return BaseCtor; }\n};\n\n/// Represents a C++ constructor within a class.\n///\n/// For example:\n///\n/// \\code\n/// class X {\n/// public:\n///   explicit X(int); // represented by a CXXConstructorDecl.\n/// };\n/// \\endcode\nclass CXXConstructorDecl final\n    : public CXXMethodDecl,\n      private llvm::TrailingObjects<CXXConstructorDecl, InheritedConstructor,\n                                    ExplicitSpecifier> {\n  // This class stores some data in DeclContext::CXXConstructorDeclBits\n  // to save some space. Use the provided accessors to access it.\n\n  /// \\name Support for base and member initializers.\n  /// \\{\n  /// The arguments used to initialize the base or member.\n  LazyCXXCtorInitializersPtr CtorInitializers;\n\n  CXXConstructorDecl(ASTContext &C, CXXRecordDecl *RD, SourceLocation StartLoc,\n                     const DeclarationNameInfo &NameInfo, QualType T,\n                     TypeSourceInfo *TInfo, ExplicitSpecifier ES, bool isInline,\n                     bool isImplicitlyDeclared, ConstexprSpecKind ConstexprKind,\n                     InheritedConstructor Inherited,\n                     Expr *TrailingRequiresClause);\n\n  void anchor() override;\n\n  size_t numTrailingObjects(OverloadToken<InheritedConstructor>) const {\n    return CXXConstructorDeclBits.IsInheritingConstructor;\n  }\n  size_t numTrailingObjects(OverloadToken<ExplicitSpecifier>) const {\n    return CXXConstructorDeclBits.HasTrailingExplicitSpecifier;\n  }\n\n  ExplicitSpecifier getExplicitSpecifierInternal() const {\n    if (CXXConstructorDeclBits.HasTrailingExplicitSpecifier)\n      return *getTrailingObjects<ExplicitSpecifier>();\n    return ExplicitSpecifier(\n        nullptr, CXXConstructorDeclBits.IsSimpleExplicit\n                     ? ExplicitSpecKind::ResolvedTrue\n                     : ExplicitSpecKind::ResolvedFalse);\n  }\n\n  enum TraillingAllocKind {\n    TAKInheritsConstructor = 1,\n    TAKHasTailExplicit = 1 << 1,\n  };\n\n  uint64_t getTraillingAllocKind() const {\n    return numTrailingObjects(OverloadToken<InheritedConstructor>()) |\n           (numTrailingObjects(OverloadToken<ExplicitSpecifier>()) << 1);\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend TrailingObjects;\n\n  static CXXConstructorDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                                uint64_t AllocKind);\n  static CXXConstructorDecl *\n  Create(ASTContext &C, CXXRecordDecl *RD, SourceLocation StartLoc,\n         const DeclarationNameInfo &NameInfo, QualType T, TypeSourceInfo *TInfo,\n         ExplicitSpecifier ES, bool isInline, bool isImplicitlyDeclared,\n         ConstexprSpecKind ConstexprKind,\n         InheritedConstructor Inherited = InheritedConstructor(),\n         Expr *TrailingRequiresClause = nullptr);\n\n  void setExplicitSpecifier(ExplicitSpecifier ES) {\n    assert((!ES.getExpr() ||\n            CXXConstructorDeclBits.HasTrailingExplicitSpecifier) &&\n           \"cannot set this explicit specifier. no trail-allocated space for \"\n           \"explicit\");\n    if (ES.getExpr())\n      *getCanonicalDecl()->getTrailingObjects<ExplicitSpecifier>() = ES;\n    else\n      CXXConstructorDeclBits.IsSimpleExplicit = ES.isExplicit();\n  }\n\n  ExplicitSpecifier getExplicitSpecifier() {\n    return getCanonicalDecl()->getExplicitSpecifierInternal();\n  }\n  const ExplicitSpecifier getExplicitSpecifier() const {\n    return getCanonicalDecl()->getExplicitSpecifierInternal();\n  }\n\n  /// Return true if the declartion is already resolved to be explicit.\n  bool isExplicit() const { return getExplicitSpecifier().isExplicit(); }\n\n  /// Iterates through the member/base initializer list.\n  using init_iterator = CXXCtorInitializer **;\n\n  /// Iterates through the member/base initializer list.\n  using init_const_iterator = CXXCtorInitializer *const *;\n\n  using init_range = llvm::iterator_range<init_iterator>;\n  using init_const_range = llvm::iterator_range<init_const_iterator>;\n\n  init_range inits() { return init_range(init_begin(), init_end()); }\n  init_const_range inits() const {\n    return init_const_range(init_begin(), init_end());\n  }\n\n  /// Retrieve an iterator to the first initializer.\n  init_iterator init_begin() {\n    const auto *ConstThis = this;\n    return const_cast<init_iterator>(ConstThis->init_begin());\n  }\n\n  /// Retrieve an iterator to the first initializer.\n  init_const_iterator init_begin() const;\n\n  /// Retrieve an iterator past the last initializer.\n  init_iterator       init_end()       {\n    return init_begin() + getNumCtorInitializers();\n  }\n\n  /// Retrieve an iterator past the last initializer.\n  init_const_iterator init_end() const {\n    return init_begin() + getNumCtorInitializers();\n  }\n\n  using init_reverse_iterator = std::reverse_iterator<init_iterator>;\n  using init_const_reverse_iterator =\n      std::reverse_iterator<init_const_iterator>;\n\n  init_reverse_iterator init_rbegin() {\n    return init_reverse_iterator(init_end());\n  }\n  init_const_reverse_iterator init_rbegin() const {\n    return init_const_reverse_iterator(init_end());\n  }\n\n  init_reverse_iterator init_rend() {\n    return init_reverse_iterator(init_begin());\n  }\n  init_const_reverse_iterator init_rend() const {\n    return init_const_reverse_iterator(init_begin());\n  }\n\n  /// Determine the number of arguments used to initialize the member\n  /// or base.\n  unsigned getNumCtorInitializers() const {\n      return CXXConstructorDeclBits.NumCtorInitializers;\n  }\n\n  void setNumCtorInitializers(unsigned numCtorInitializers) {\n    CXXConstructorDeclBits.NumCtorInitializers = numCtorInitializers;\n    // This assert added because NumCtorInitializers is stored\n    // in CXXConstructorDeclBits as a bitfield and its width has\n    // been shrunk from 32 bits to fit into CXXConstructorDeclBitfields.\n    assert(CXXConstructorDeclBits.NumCtorInitializers ==\n           numCtorInitializers && \"NumCtorInitializers overflow!\");\n  }\n\n  void setCtorInitializers(CXXCtorInitializer **Initializers) {\n    CtorInitializers = Initializers;\n  }\n\n  /// Determine whether this constructor is a delegating constructor.\n  bool isDelegatingConstructor() const {\n    return (getNumCtorInitializers() == 1) &&\n           init_begin()[0]->isDelegatingInitializer();\n  }\n\n  /// When this constructor delegates to another, retrieve the target.\n  CXXConstructorDecl *getTargetConstructor() const;\n\n  /// Whether this constructor is a default\n  /// constructor (C++ [class.ctor]p5), which can be used to\n  /// default-initialize a class of this type.\n  bool isDefaultConstructor() const;\n\n  /// Whether this constructor is a copy constructor (C++ [class.copy]p2,\n  /// which can be used to copy the class.\n  ///\n  /// \\p TypeQuals will be set to the qualifiers on the\n  /// argument type. For example, \\p TypeQuals would be set to \\c\n  /// Qualifiers::Const for the following copy constructor:\n  ///\n  /// \\code\n  /// class X {\n  /// public:\n  ///   X(const X&);\n  /// };\n  /// \\endcode\n  bool isCopyConstructor(unsigned &TypeQuals) const;\n\n  /// Whether this constructor is a copy\n  /// constructor (C++ [class.copy]p2, which can be used to copy the\n  /// class.\n  bool isCopyConstructor() const {\n    unsigned TypeQuals = 0;\n    return isCopyConstructor(TypeQuals);\n  }\n\n  /// Determine whether this constructor is a move constructor\n  /// (C++11 [class.copy]p3), which can be used to move values of the class.\n  ///\n  /// \\param TypeQuals If this constructor is a move constructor, will be set\n  /// to the type qualifiers on the referent of the first parameter's type.\n  bool isMoveConstructor(unsigned &TypeQuals) const;\n\n  /// Determine whether this constructor is a move constructor\n  /// (C++11 [class.copy]p3), which can be used to move values of the class.\n  bool isMoveConstructor() const {\n    unsigned TypeQuals = 0;\n    return isMoveConstructor(TypeQuals);\n  }\n\n  /// Determine whether this is a copy or move constructor.\n  ///\n  /// \\param TypeQuals Will be set to the type qualifiers on the reference\n  /// parameter, if in fact this is a copy or move constructor.\n  bool isCopyOrMoveConstructor(unsigned &TypeQuals) const;\n\n  /// Determine whether this a copy or move constructor.\n  bool isCopyOrMoveConstructor() const {\n    unsigned Quals;\n    return isCopyOrMoveConstructor(Quals);\n  }\n\n  /// Whether this constructor is a\n  /// converting constructor (C++ [class.conv.ctor]), which can be\n  /// used for user-defined conversions.\n  bool isConvertingConstructor(bool AllowExplicit) const;\n\n  /// Determine whether this is a member template specialization that\n  /// would copy the object to itself. Such constructors are never used to copy\n  /// an object.\n  bool isSpecializationCopyingObject() const;\n\n  /// Determine whether this is an implicit constructor synthesized to\n  /// model a call to a constructor inherited from a base class.\n  bool isInheritingConstructor() const {\n    return CXXConstructorDeclBits.IsInheritingConstructor;\n  }\n\n  /// State that this is an implicit constructor synthesized to\n  /// model a call to a constructor inherited from a base class.\n  void setInheritingConstructor(bool isIC = true) {\n    CXXConstructorDeclBits.IsInheritingConstructor = isIC;\n  }\n\n  /// Get the constructor that this inheriting constructor is based on.\n  InheritedConstructor getInheritedConstructor() const {\n    return isInheritingConstructor() ?\n      *getTrailingObjects<InheritedConstructor>() : InheritedConstructor();\n  }\n\n  CXXConstructorDecl *getCanonicalDecl() override {\n    return cast<CXXConstructorDecl>(FunctionDecl::getCanonicalDecl());\n  }\n  const CXXConstructorDecl *getCanonicalDecl() const {\n    return const_cast<CXXConstructorDecl*>(this)->getCanonicalDecl();\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == CXXConstructor; }\n};\n\n/// Represents a C++ destructor within a class.\n///\n/// For example:\n///\n/// \\code\n/// class X {\n/// public:\n///   ~X(); // represented by a CXXDestructorDecl.\n/// };\n/// \\endcode\nclass CXXDestructorDecl : public CXXMethodDecl {\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  // FIXME: Don't allocate storage for these except in the first declaration\n  // of a virtual destructor.\n  FunctionDecl *OperatorDelete = nullptr;\n  Expr *OperatorDeleteThisArg = nullptr;\n\n  CXXDestructorDecl(ASTContext &C, CXXRecordDecl *RD, SourceLocation StartLoc,\n                    const DeclarationNameInfo &NameInfo, QualType T,\n                    TypeSourceInfo *TInfo, bool isInline,\n                    bool isImplicitlyDeclared, ConstexprSpecKind ConstexprKind,\n                    Expr *TrailingRequiresClause = nullptr)\n      : CXXMethodDecl(CXXDestructor, C, RD, StartLoc, NameInfo, T, TInfo,\n                      SC_None, isInline, ConstexprKind, SourceLocation(),\n                      TrailingRequiresClause) {\n    setImplicit(isImplicitlyDeclared);\n  }\n\n  void anchor() override;\n\npublic:\n  static CXXDestructorDecl *Create(ASTContext &C, CXXRecordDecl *RD,\n                                   SourceLocation StartLoc,\n                                   const DeclarationNameInfo &NameInfo,\n                                   QualType T, TypeSourceInfo *TInfo,\n                                   bool isInline, bool isImplicitlyDeclared,\n                                   ConstexprSpecKind ConstexprKind,\n                                   Expr *TrailingRequiresClause = nullptr);\n  static CXXDestructorDecl *CreateDeserialized(ASTContext & C, unsigned ID);\n\n  void setOperatorDelete(FunctionDecl *OD, Expr *ThisArg);\n\n  const FunctionDecl *getOperatorDelete() const {\n    return getCanonicalDecl()->OperatorDelete;\n  }\n\n  Expr *getOperatorDeleteThisArg() const {\n    return getCanonicalDecl()->OperatorDeleteThisArg;\n  }\n\n  CXXDestructorDecl *getCanonicalDecl() override {\n    return cast<CXXDestructorDecl>(FunctionDecl::getCanonicalDecl());\n  }\n  const CXXDestructorDecl *getCanonicalDecl() const {\n    return const_cast<CXXDestructorDecl*>(this)->getCanonicalDecl();\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == CXXDestructor; }\n};\n\n/// Represents a C++ conversion function within a class.\n///\n/// For example:\n///\n/// \\code\n/// class X {\n/// public:\n///   operator bool();\n/// };\n/// \\endcode\nclass CXXConversionDecl : public CXXMethodDecl {\n  CXXConversionDecl(ASTContext &C, CXXRecordDecl *RD, SourceLocation StartLoc,\n                    const DeclarationNameInfo &NameInfo, QualType T,\n                    TypeSourceInfo *TInfo, bool isInline, ExplicitSpecifier ES,\n                    ConstexprSpecKind ConstexprKind, SourceLocation EndLocation,\n                    Expr *TrailingRequiresClause = nullptr)\n      : CXXMethodDecl(CXXConversion, C, RD, StartLoc, NameInfo, T, TInfo,\n                      SC_None, isInline, ConstexprKind, EndLocation,\n                      TrailingRequiresClause),\n        ExplicitSpec(ES) {}\n  void anchor() override;\n\n  ExplicitSpecifier ExplicitSpec;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static CXXConversionDecl *\n  Create(ASTContext &C, CXXRecordDecl *RD, SourceLocation StartLoc,\n         const DeclarationNameInfo &NameInfo, QualType T, TypeSourceInfo *TInfo,\n         bool isInline, ExplicitSpecifier ES, ConstexprSpecKind ConstexprKind,\n         SourceLocation EndLocation, Expr *TrailingRequiresClause = nullptr);\n  static CXXConversionDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  ExplicitSpecifier getExplicitSpecifier() {\n    return getCanonicalDecl()->ExplicitSpec;\n  }\n\n  const ExplicitSpecifier getExplicitSpecifier() const {\n    return getCanonicalDecl()->ExplicitSpec;\n  }\n\n  /// Return true if the declartion is already resolved to be explicit.\n  bool isExplicit() const { return getExplicitSpecifier().isExplicit(); }\n  void setExplicitSpecifier(ExplicitSpecifier ES) { ExplicitSpec = ES; }\n\n  /// Returns the type that this conversion function is converting to.\n  QualType getConversionType() const {\n    return getType()->castAs<FunctionType>()->getReturnType();\n  }\n\n  /// Determine whether this conversion function is a conversion from\n  /// a lambda closure type to a block pointer.\n  bool isLambdaToBlockPointerConversion() const;\n\n  CXXConversionDecl *getCanonicalDecl() override {\n    return cast<CXXConversionDecl>(FunctionDecl::getCanonicalDecl());\n  }\n  const CXXConversionDecl *getCanonicalDecl() const {\n    return const_cast<CXXConversionDecl*>(this)->getCanonicalDecl();\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == CXXConversion; }\n};\n\n/// Represents a linkage specification.\n///\n/// For example:\n/// \\code\n///   extern \"C\" void foo();\n/// \\endcode\nclass LinkageSpecDecl : public Decl, public DeclContext {\n  virtual void anchor();\n  // This class stores some data in DeclContext::LinkageSpecDeclBits to save\n  // some space. Use the provided accessors to access it.\npublic:\n  /// Represents the language in a linkage specification.\n  ///\n  /// The values are part of the serialization ABI for\n  /// ASTs and cannot be changed without altering that ABI.\n  enum LanguageIDs { lang_c = 1, lang_cxx = 2 };\n\nprivate:\n  /// The source location for the extern keyword.\n  SourceLocation ExternLoc;\n\n  /// The source location for the right brace (if valid).\n  SourceLocation RBraceLoc;\n\n  LinkageSpecDecl(DeclContext *DC, SourceLocation ExternLoc,\n                  SourceLocation LangLoc, LanguageIDs lang, bool HasBraces);\n\npublic:\n  static LinkageSpecDecl *Create(ASTContext &C, DeclContext *DC,\n                                 SourceLocation ExternLoc,\n                                 SourceLocation LangLoc, LanguageIDs Lang,\n                                 bool HasBraces);\n  static LinkageSpecDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// Return the language specified by this linkage specification.\n  LanguageIDs getLanguage() const {\n    return static_cast<LanguageIDs>(LinkageSpecDeclBits.Language);\n  }\n\n  /// Set the language specified by this linkage specification.\n  void setLanguage(LanguageIDs L) { LinkageSpecDeclBits.Language = L; }\n\n  /// Determines whether this linkage specification had braces in\n  /// its syntactic form.\n  bool hasBraces() const {\n    assert(!RBraceLoc.isValid() || LinkageSpecDeclBits.HasBraces);\n    return LinkageSpecDeclBits.HasBraces;\n  }\n\n  SourceLocation getExternLoc() const { return ExternLoc; }\n  SourceLocation getRBraceLoc() const { return RBraceLoc; }\n  void setExternLoc(SourceLocation L) { ExternLoc = L; }\n  void setRBraceLoc(SourceLocation L) {\n    RBraceLoc = L;\n    LinkageSpecDeclBits.HasBraces = RBraceLoc.isValid();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    if (hasBraces())\n      return getRBraceLoc();\n    // No braces: get the end location of the (only) declaration in context\n    // (if present).\n    return decls_empty() ? getLocation() : decls_begin()->getEndLoc();\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(ExternLoc, getEndLoc());\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == LinkageSpec; }\n\n  static DeclContext *castToDeclContext(const LinkageSpecDecl *D) {\n    return static_cast<DeclContext *>(const_cast<LinkageSpecDecl*>(D));\n  }\n\n  static LinkageSpecDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<LinkageSpecDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Represents C++ using-directive.\n///\n/// For example:\n/// \\code\n///    using namespace std;\n/// \\endcode\n///\n/// \\note UsingDirectiveDecl should be Decl not NamedDecl, but we provide\n/// artificial names for all using-directives in order to store\n/// them in DeclContext effectively.\nclass UsingDirectiveDecl : public NamedDecl {\n  /// The location of the \\c using keyword.\n  SourceLocation UsingLoc;\n\n  /// The location of the \\c namespace keyword.\n  SourceLocation NamespaceLoc;\n\n  /// The nested-name-specifier that precedes the namespace.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// The namespace nominated by this using-directive.\n  NamedDecl *NominatedNamespace;\n\n  /// Enclosing context containing both using-directive and nominated\n  /// namespace.\n  DeclContext *CommonAncestor;\n\n  UsingDirectiveDecl(DeclContext *DC, SourceLocation UsingLoc,\n                     SourceLocation NamespcLoc,\n                     NestedNameSpecifierLoc QualifierLoc,\n                     SourceLocation IdentLoc,\n                     NamedDecl *Nominated,\n                     DeclContext *CommonAncestor)\n      : NamedDecl(UsingDirective, DC, IdentLoc, getName()), UsingLoc(UsingLoc),\n        NamespaceLoc(NamespcLoc), QualifierLoc(QualifierLoc),\n        NominatedNamespace(Nominated), CommonAncestor(CommonAncestor) {}\n\n  /// Returns special DeclarationName used by using-directives.\n  ///\n  /// This is only used by DeclContext for storing UsingDirectiveDecls in\n  /// its lookup structure.\n  static DeclarationName getName() {\n    return DeclarationName::getUsingDirectiveName();\n  }\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n\n  // Friend for getUsingDirectiveName.\n  friend class DeclContext;\n\n  /// Retrieve the nested-name-specifier that qualifies the\n  /// name of the namespace, with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the nested-name-specifier that qualifies the\n  /// name of the namespace.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  NamedDecl *getNominatedNamespaceAsWritten() { return NominatedNamespace; }\n  const NamedDecl *getNominatedNamespaceAsWritten() const {\n    return NominatedNamespace;\n  }\n\n  /// Returns the namespace nominated by this using-directive.\n  NamespaceDecl *getNominatedNamespace();\n\n  const NamespaceDecl *getNominatedNamespace() const {\n    return const_cast<UsingDirectiveDecl*>(this)->getNominatedNamespace();\n  }\n\n  /// Returns the common ancestor context of this using-directive and\n  /// its nominated namespace.\n  DeclContext *getCommonAncestor() { return CommonAncestor; }\n  const DeclContext *getCommonAncestor() const { return CommonAncestor; }\n\n  /// Return the location of the \\c using keyword.\n  SourceLocation getUsingLoc() const { return UsingLoc; }\n\n  // FIXME: Could omit 'Key' in name.\n  /// Returns the location of the \\c namespace keyword.\n  SourceLocation getNamespaceKeyLocation() const { return NamespaceLoc; }\n\n  /// Returns the location of this using declaration's identifier.\n  SourceLocation getIdentLocation() const { return getLocation(); }\n\n  static UsingDirectiveDecl *Create(ASTContext &C, DeclContext *DC,\n                                    SourceLocation UsingLoc,\n                                    SourceLocation NamespaceLoc,\n                                    NestedNameSpecifierLoc QualifierLoc,\n                                    SourceLocation IdentLoc,\n                                    NamedDecl *Nominated,\n                                    DeclContext *CommonAncestor);\n  static UsingDirectiveDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(UsingLoc, getLocation());\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == UsingDirective; }\n};\n\n/// Represents a C++ namespace alias.\n///\n/// For example:\n///\n/// \\code\n/// namespace Foo = Bar;\n/// \\endcode\nclass NamespaceAliasDecl : public NamedDecl,\n                           public Redeclarable<NamespaceAliasDecl> {\n  friend class ASTDeclReader;\n\n  /// The location of the \\c namespace keyword.\n  SourceLocation NamespaceLoc;\n\n  /// The location of the namespace's identifier.\n  ///\n  /// This is accessed by TargetNameLoc.\n  SourceLocation IdentLoc;\n\n  /// The nested-name-specifier that precedes the namespace.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// The Decl that this alias points to, either a NamespaceDecl or\n  /// a NamespaceAliasDecl.\n  NamedDecl *Namespace;\n\n  NamespaceAliasDecl(ASTContext &C, DeclContext *DC,\n                     SourceLocation NamespaceLoc, SourceLocation AliasLoc,\n                     IdentifierInfo *Alias, NestedNameSpecifierLoc QualifierLoc,\n                     SourceLocation IdentLoc, NamedDecl *Namespace)\n      : NamedDecl(NamespaceAlias, DC, AliasLoc, Alias), redeclarable_base(C),\n        NamespaceLoc(NamespaceLoc), IdentLoc(IdentLoc),\n        QualifierLoc(QualifierLoc), Namespace(Namespace) {}\n\n  void anchor() override;\n\n  using redeclarable_base = Redeclarable<NamespaceAliasDecl>;\n\n  NamespaceAliasDecl *getNextRedeclarationImpl() override;\n  NamespaceAliasDecl *getPreviousDeclImpl() override;\n  NamespaceAliasDecl *getMostRecentDeclImpl() override;\n\npublic:\n  static NamespaceAliasDecl *Create(ASTContext &C, DeclContext *DC,\n                                    SourceLocation NamespaceLoc,\n                                    SourceLocation AliasLoc,\n                                    IdentifierInfo *Alias,\n                                    NestedNameSpecifierLoc QualifierLoc,\n                                    SourceLocation IdentLoc,\n                                    NamedDecl *Namespace);\n\n  static NamespaceAliasDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n\n  NamespaceAliasDecl *getCanonicalDecl() override {\n    return getFirstDecl();\n  }\n  const NamespaceAliasDecl *getCanonicalDecl() const {\n    return getFirstDecl();\n  }\n\n  /// Retrieve the nested-name-specifier that qualifies the\n  /// name of the namespace, with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the nested-name-specifier that qualifies the\n  /// name of the namespace.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  /// Retrieve the namespace declaration aliased by this directive.\n  NamespaceDecl *getNamespace() {\n    if (auto *AD = dyn_cast<NamespaceAliasDecl>(Namespace))\n      return AD->getNamespace();\n\n    return cast<NamespaceDecl>(Namespace);\n  }\n\n  const NamespaceDecl *getNamespace() const {\n    return const_cast<NamespaceAliasDecl *>(this)->getNamespace();\n  }\n\n  /// Returns the location of the alias name, i.e. 'foo' in\n  /// \"namespace foo = ns::bar;\".\n  SourceLocation getAliasLoc() const { return getLocation(); }\n\n  /// Returns the location of the \\c namespace keyword.\n  SourceLocation getNamespaceLoc() const { return NamespaceLoc; }\n\n  /// Returns the location of the identifier in the named namespace.\n  SourceLocation getTargetNameLoc() const { return IdentLoc; }\n\n  /// Retrieve the namespace that this alias refers to, which\n  /// may either be a NamespaceDecl or a NamespaceAliasDecl.\n  NamedDecl *getAliasedNamespace() const { return Namespace; }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(NamespaceLoc, IdentLoc);\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == NamespaceAlias; }\n};\n\n/// Implicit declaration of a temporary that was materialized by\n/// a MaterializeTemporaryExpr and lifetime-extended by a declaration\nclass LifetimeExtendedTemporaryDecl final\n    : public Decl,\n      public Mergeable<LifetimeExtendedTemporaryDecl> {\n  friend class MaterializeTemporaryExpr;\n  friend class ASTDeclReader;\n\n  Stmt *ExprWithTemporary = nullptr;\n\n  /// The declaration which lifetime-extended this reference, if any.\n  /// Either a VarDecl, or (for a ctor-initializer) a FieldDecl.\n  ValueDecl *ExtendingDecl = nullptr;\n  unsigned ManglingNumber;\n\n  mutable APValue *Value = nullptr;\n\n  virtual void anchor();\n\n  LifetimeExtendedTemporaryDecl(Expr *Temp, ValueDecl *EDecl, unsigned Mangling)\n      : Decl(Decl::LifetimeExtendedTemporary, EDecl->getDeclContext(),\n             EDecl->getLocation()),\n        ExprWithTemporary(Temp), ExtendingDecl(EDecl),\n        ManglingNumber(Mangling) {}\n\n  LifetimeExtendedTemporaryDecl(EmptyShell)\n      : Decl(Decl::LifetimeExtendedTemporary, EmptyShell{}) {}\n\npublic:\n  static LifetimeExtendedTemporaryDecl *Create(Expr *Temp, ValueDecl *EDec,\n                                               unsigned Mangling) {\n    return new (EDec->getASTContext(), EDec->getDeclContext())\n        LifetimeExtendedTemporaryDecl(Temp, EDec, Mangling);\n  }\n  static LifetimeExtendedTemporaryDecl *CreateDeserialized(ASTContext &C,\n                                                           unsigned ID) {\n    return new (C, ID) LifetimeExtendedTemporaryDecl(EmptyShell{});\n  }\n\n  ValueDecl *getExtendingDecl() { return ExtendingDecl; }\n  const ValueDecl *getExtendingDecl() const { return ExtendingDecl; }\n\n  /// Retrieve the storage duration for the materialized temporary.\n  StorageDuration getStorageDuration() const;\n\n  /// Retrieve the expression to which the temporary materialization conversion\n  /// was applied. This isn't necessarily the initializer of the temporary due\n  /// to the C++98 delayed materialization rules, but\n  /// skipRValueSubobjectAdjustments can be used to find said initializer within\n  /// the subexpression.\n  Expr *getTemporaryExpr() { return cast<Expr>(ExprWithTemporary); }\n  const Expr *getTemporaryExpr() const { return cast<Expr>(ExprWithTemporary); }\n\n  unsigned getManglingNumber() const { return ManglingNumber; }\n\n  /// Get the storage for the constant value of a materialized temporary\n  /// of static storage duration.\n  APValue *getOrCreateValue(bool MayCreate) const;\n\n  APValue *getValue() const { return Value; }\n\n  // Iterators\n  Stmt::child_range childrenExpr() {\n    return Stmt::child_range(&ExprWithTemporary, &ExprWithTemporary + 1);\n  }\n\n  Stmt::const_child_range childrenExpr() const {\n    return Stmt::const_child_range(&ExprWithTemporary, &ExprWithTemporary + 1);\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K == Decl::LifetimeExtendedTemporary;\n  }\n};\n\n/// Represents a shadow declaration introduced into a scope by a\n/// (resolved) using declaration.\n///\n/// For example,\n/// \\code\n/// namespace A {\n///   void foo();\n/// }\n/// namespace B {\n///   using A::foo; // <- a UsingDecl\n///                 // Also creates a UsingShadowDecl for A::foo() in B\n/// }\n/// \\endcode\nclass UsingShadowDecl : public NamedDecl, public Redeclarable<UsingShadowDecl> {\n  friend class UsingDecl;\n\n  /// The referenced declaration.\n  NamedDecl *Underlying = nullptr;\n\n  /// The using declaration which introduced this decl or the next using\n  /// shadow declaration contained in the aforementioned using declaration.\n  NamedDecl *UsingOrNextShadow = nullptr;\n\n  void anchor() override;\n\n  using redeclarable_base = Redeclarable<UsingShadowDecl>;\n\n  UsingShadowDecl *getNextRedeclarationImpl() override {\n    return getNextRedeclaration();\n  }\n\n  UsingShadowDecl *getPreviousDeclImpl() override {\n    return getPreviousDecl();\n  }\n\n  UsingShadowDecl *getMostRecentDeclImpl() override {\n    return getMostRecentDecl();\n  }\n\nprotected:\n  UsingShadowDecl(Kind K, ASTContext &C, DeclContext *DC, SourceLocation Loc,\n                  UsingDecl *Using, NamedDecl *Target);\n  UsingShadowDecl(Kind K, ASTContext &C, EmptyShell);\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static UsingShadowDecl *Create(ASTContext &C, DeclContext *DC,\n                                 SourceLocation Loc, UsingDecl *Using,\n                                 NamedDecl *Target) {\n    return new (C, DC) UsingShadowDecl(UsingShadow, C, DC, Loc, Using, Target);\n  }\n\n  static UsingShadowDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  UsingShadowDecl *getCanonicalDecl() override {\n    return getFirstDecl();\n  }\n  const UsingShadowDecl *getCanonicalDecl() const {\n    return getFirstDecl();\n  }\n\n  /// Gets the underlying declaration which has been brought into the\n  /// local scope.\n  NamedDecl *getTargetDecl() const { return Underlying; }\n\n  /// Sets the underlying declaration which has been brought into the\n  /// local scope.\n  void setTargetDecl(NamedDecl *ND) {\n    assert(ND && \"Target decl is null!\");\n    Underlying = ND;\n    // A UsingShadowDecl is never a friend or local extern declaration, even\n    // if it is a shadow declaration for one.\n    IdentifierNamespace =\n        ND->getIdentifierNamespace() &\n        ~(IDNS_OrdinaryFriend | IDNS_TagFriend | IDNS_LocalExtern);\n  }\n\n  /// Gets the using declaration to which this declaration is tied.\n  UsingDecl *getUsingDecl() const;\n\n  /// The next using shadow declaration contained in the shadow decl\n  /// chain of the using declaration which introduced this decl.\n  UsingShadowDecl *getNextUsingShadowDecl() const {\n    return dyn_cast_or_null<UsingShadowDecl>(UsingOrNextShadow);\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K == Decl::UsingShadow || K == Decl::ConstructorUsingShadow;\n  }\n};\n\n/// Represents a shadow constructor declaration introduced into a\n/// class by a C++11 using-declaration that names a constructor.\n///\n/// For example:\n/// \\code\n/// struct Base { Base(int); };\n/// struct Derived {\n///    using Base::Base; // creates a UsingDecl and a ConstructorUsingShadowDecl\n/// };\n/// \\endcode\nclass ConstructorUsingShadowDecl final : public UsingShadowDecl {\n  /// If this constructor using declaration inherted the constructor\n  /// from an indirect base class, this is the ConstructorUsingShadowDecl\n  /// in the named direct base class from which the declaration was inherited.\n  ConstructorUsingShadowDecl *NominatedBaseClassShadowDecl = nullptr;\n\n  /// If this constructor using declaration inherted the constructor\n  /// from an indirect base class, this is the ConstructorUsingShadowDecl\n  /// that will be used to construct the unique direct or virtual base class\n  /// that receives the constructor arguments.\n  ConstructorUsingShadowDecl *ConstructedBaseClassShadowDecl = nullptr;\n\n  /// \\c true if the constructor ultimately named by this using shadow\n  /// declaration is within a virtual base class subobject of the class that\n  /// contains this declaration.\n  unsigned IsVirtual : 1;\n\n  ConstructorUsingShadowDecl(ASTContext &C, DeclContext *DC, SourceLocation Loc,\n                             UsingDecl *Using, NamedDecl *Target,\n                             bool TargetInVirtualBase)\n      : UsingShadowDecl(ConstructorUsingShadow, C, DC, Loc, Using,\n                        Target->getUnderlyingDecl()),\n        NominatedBaseClassShadowDecl(\n            dyn_cast<ConstructorUsingShadowDecl>(Target)),\n        ConstructedBaseClassShadowDecl(NominatedBaseClassShadowDecl),\n        IsVirtual(TargetInVirtualBase) {\n    // If we found a constructor that chains to a constructor for a virtual\n    // base, we should directly call that virtual base constructor instead.\n    // FIXME: This logic belongs in Sema.\n    if (NominatedBaseClassShadowDecl &&\n        NominatedBaseClassShadowDecl->constructsVirtualBase()) {\n      ConstructedBaseClassShadowDecl =\n          NominatedBaseClassShadowDecl->ConstructedBaseClassShadowDecl;\n      IsVirtual = true;\n    }\n  }\n\n  ConstructorUsingShadowDecl(ASTContext &C, EmptyShell Empty)\n      : UsingShadowDecl(ConstructorUsingShadow, C, Empty), IsVirtual(false) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static ConstructorUsingShadowDecl *Create(ASTContext &C, DeclContext *DC,\n                                            SourceLocation Loc,\n                                            UsingDecl *Using, NamedDecl *Target,\n                                            bool IsVirtual);\n  static ConstructorUsingShadowDecl *CreateDeserialized(ASTContext &C,\n                                                        unsigned ID);\n\n  /// Returns the parent of this using shadow declaration, which\n  /// is the class in which this is declared.\n  //@{\n  const CXXRecordDecl *getParent() const {\n    return cast<CXXRecordDecl>(getDeclContext());\n  }\n  CXXRecordDecl *getParent() {\n    return cast<CXXRecordDecl>(getDeclContext());\n  }\n  //@}\n\n  /// Get the inheriting constructor declaration for the direct base\n  /// class from which this using shadow declaration was inherited, if there is\n  /// one. This can be different for each redeclaration of the same shadow decl.\n  ConstructorUsingShadowDecl *getNominatedBaseClassShadowDecl() const {\n    return NominatedBaseClassShadowDecl;\n  }\n\n  /// Get the inheriting constructor declaration for the base class\n  /// for which we don't have an explicit initializer, if there is one.\n  ConstructorUsingShadowDecl *getConstructedBaseClassShadowDecl() const {\n    return ConstructedBaseClassShadowDecl;\n  }\n\n  /// Get the base class that was named in the using declaration. This\n  /// can be different for each redeclaration of this same shadow decl.\n  CXXRecordDecl *getNominatedBaseClass() const;\n\n  /// Get the base class whose constructor or constructor shadow\n  /// declaration is passed the constructor arguments.\n  CXXRecordDecl *getConstructedBaseClass() const {\n    return cast<CXXRecordDecl>((ConstructedBaseClassShadowDecl\n                                    ? ConstructedBaseClassShadowDecl\n                                    : getTargetDecl())\n                                   ->getDeclContext());\n  }\n\n  /// Returns \\c true if the constructed base class is a virtual base\n  /// class subobject of this declaration's class.\n  bool constructsVirtualBase() const {\n    return IsVirtual;\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ConstructorUsingShadow; }\n};\n\n/// Represents a C++ using-declaration.\n///\n/// For example:\n/// \\code\n///    using someNameSpace::someIdentifier;\n/// \\endcode\nclass UsingDecl : public NamedDecl, public Mergeable<UsingDecl> {\n  /// The source location of the 'using' keyword itself.\n  SourceLocation UsingLocation;\n\n  /// The nested-name-specifier that precedes the name.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// Provides source/type location info for the declaration name\n  /// embedded in the ValueDecl base class.\n  DeclarationNameLoc DNLoc;\n\n  /// The first shadow declaration of the shadow decl chain associated\n  /// with this using declaration.\n  ///\n  /// The bool member of the pair store whether this decl has the \\c typename\n  /// keyword.\n  llvm::PointerIntPair<UsingShadowDecl *, 1, bool> FirstUsingShadow;\n\n  UsingDecl(DeclContext *DC, SourceLocation UL,\n            NestedNameSpecifierLoc QualifierLoc,\n            const DeclarationNameInfo &NameInfo, bool HasTypenameKeyword)\n    : NamedDecl(Using, DC, NameInfo.getLoc(), NameInfo.getName()),\n      UsingLocation(UL), QualifierLoc(QualifierLoc),\n      DNLoc(NameInfo.getInfo()), FirstUsingShadow(nullptr, HasTypenameKeyword) {\n  }\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Return the source location of the 'using' keyword.\n  SourceLocation getUsingLoc() const { return UsingLocation; }\n\n  /// Set the source location of the 'using' keyword.\n  void setUsingLoc(SourceLocation L) { UsingLocation = L; }\n\n  /// Retrieve the nested-name-specifier that qualifies the name,\n  /// with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the nested-name-specifier that qualifies the name.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  DeclarationNameInfo getNameInfo() const {\n    return DeclarationNameInfo(getDeclName(), getLocation(), DNLoc);\n  }\n\n  /// Return true if it is a C++03 access declaration (no 'using').\n  bool isAccessDeclaration() const { return UsingLocation.isInvalid(); }\n\n  /// Return true if the using declaration has 'typename'.\n  bool hasTypename() const { return FirstUsingShadow.getInt(); }\n\n  /// Sets whether the using declaration has 'typename'.\n  void setTypename(bool TN) { FirstUsingShadow.setInt(TN); }\n\n  /// Iterates through the using shadow declarations associated with\n  /// this using declaration.\n  class shadow_iterator {\n    /// The current using shadow declaration.\n    UsingShadowDecl *Current = nullptr;\n\n  public:\n    using value_type = UsingShadowDecl *;\n    using reference = UsingShadowDecl *;\n    using pointer = UsingShadowDecl *;\n    using iterator_category = std::forward_iterator_tag;\n    using difference_type = std::ptrdiff_t;\n\n    shadow_iterator() = default;\n    explicit shadow_iterator(UsingShadowDecl *C) : Current(C) {}\n\n    reference operator*() const { return Current; }\n    pointer operator->() const { return Current; }\n\n    shadow_iterator& operator++() {\n      Current = Current->getNextUsingShadowDecl();\n      return *this;\n    }\n\n    shadow_iterator operator++(int) {\n      shadow_iterator tmp(*this);\n      ++(*this);\n      return tmp;\n    }\n\n    friend bool operator==(shadow_iterator x, shadow_iterator y) {\n      return x.Current == y.Current;\n    }\n    friend bool operator!=(shadow_iterator x, shadow_iterator y) {\n      return x.Current != y.Current;\n    }\n  };\n\n  using shadow_range = llvm::iterator_range<shadow_iterator>;\n\n  shadow_range shadows() const {\n    return shadow_range(shadow_begin(), shadow_end());\n  }\n\n  shadow_iterator shadow_begin() const {\n    return shadow_iterator(FirstUsingShadow.getPointer());\n  }\n\n  shadow_iterator shadow_end() const { return shadow_iterator(); }\n\n  /// Return the number of shadowed declarations associated with this\n  /// using declaration.\n  unsigned shadow_size() const {\n    return std::distance(shadow_begin(), shadow_end());\n  }\n\n  void addShadowDecl(UsingShadowDecl *S);\n  void removeShadowDecl(UsingShadowDecl *S);\n\n  static UsingDecl *Create(ASTContext &C, DeclContext *DC,\n                           SourceLocation UsingL,\n                           NestedNameSpecifierLoc QualifierLoc,\n                           const DeclarationNameInfo &NameInfo,\n                           bool HasTypenameKeyword);\n\n  static UsingDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  /// Retrieves the canonical declaration of this declaration.\n  UsingDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const UsingDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Using; }\n};\n\n/// Represents a pack of using declarations that a single\n/// using-declarator pack-expanded into.\n///\n/// \\code\n/// template<typename ...T> struct X : T... {\n///   using T::operator()...;\n///   using T::operator T...;\n/// };\n/// \\endcode\n///\n/// In the second case above, the UsingPackDecl will have the name\n/// 'operator T' (which contains an unexpanded pack), but the individual\n/// UsingDecls and UsingShadowDecls will have more reasonable names.\nclass UsingPackDecl final\n    : public NamedDecl, public Mergeable<UsingPackDecl>,\n      private llvm::TrailingObjects<UsingPackDecl, NamedDecl *> {\n  /// The UnresolvedUsingValueDecl or UnresolvedUsingTypenameDecl from\n  /// which this waas instantiated.\n  NamedDecl *InstantiatedFrom;\n\n  /// The number of using-declarations created by this pack expansion.\n  unsigned NumExpansions;\n\n  UsingPackDecl(DeclContext *DC, NamedDecl *InstantiatedFrom,\n                ArrayRef<NamedDecl *> UsingDecls)\n      : NamedDecl(UsingPack, DC,\n                  InstantiatedFrom ? InstantiatedFrom->getLocation()\n                                   : SourceLocation(),\n                  InstantiatedFrom ? InstantiatedFrom->getDeclName()\n                                   : DeclarationName()),\n        InstantiatedFrom(InstantiatedFrom), NumExpansions(UsingDecls.size()) {\n    std::uninitialized_copy(UsingDecls.begin(), UsingDecls.end(),\n                            getTrailingObjects<NamedDecl *>());\n  }\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend TrailingObjects;\n\n  /// Get the using declaration from which this was instantiated. This will\n  /// always be an UnresolvedUsingValueDecl or an UnresolvedUsingTypenameDecl\n  /// that is a pack expansion.\n  NamedDecl *getInstantiatedFromUsingDecl() const { return InstantiatedFrom; }\n\n  /// Get the set of using declarations that this pack expanded into. Note that\n  /// some of these may still be unresolved.\n  ArrayRef<NamedDecl *> expansions() const {\n    return llvm::makeArrayRef(getTrailingObjects<NamedDecl *>(), NumExpansions);\n  }\n\n  static UsingPackDecl *Create(ASTContext &C, DeclContext *DC,\n                               NamedDecl *InstantiatedFrom,\n                               ArrayRef<NamedDecl *> UsingDecls);\n\n  static UsingPackDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                           unsigned NumExpansions);\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return InstantiatedFrom->getSourceRange();\n  }\n\n  UsingPackDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const UsingPackDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == UsingPack; }\n};\n\n/// Represents a dependent using declaration which was not marked with\n/// \\c typename.\n///\n/// Unlike non-dependent using declarations, these *only* bring through\n/// non-types; otherwise they would break two-phase lookup.\n///\n/// \\code\n/// template \\<class T> class A : public Base<T> {\n///   using Base<T>::foo;\n/// };\n/// \\endcode\nclass UnresolvedUsingValueDecl : public ValueDecl,\n                                 public Mergeable<UnresolvedUsingValueDecl> {\n  /// The source location of the 'using' keyword\n  SourceLocation UsingLocation;\n\n  /// If this is a pack expansion, the location of the '...'.\n  SourceLocation EllipsisLoc;\n\n  /// The nested-name-specifier that precedes the name.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// Provides source/type location info for the declaration name\n  /// embedded in the ValueDecl base class.\n  DeclarationNameLoc DNLoc;\n\n  UnresolvedUsingValueDecl(DeclContext *DC, QualType Ty,\n                           SourceLocation UsingLoc,\n                           NestedNameSpecifierLoc QualifierLoc,\n                           const DeclarationNameInfo &NameInfo,\n                           SourceLocation EllipsisLoc)\n      : ValueDecl(UnresolvedUsingValue, DC,\n                  NameInfo.getLoc(), NameInfo.getName(), Ty),\n        UsingLocation(UsingLoc), EllipsisLoc(EllipsisLoc),\n        QualifierLoc(QualifierLoc), DNLoc(NameInfo.getInfo()) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Returns the source location of the 'using' keyword.\n  SourceLocation getUsingLoc() const { return UsingLocation; }\n\n  /// Set the source location of the 'using' keyword.\n  void setUsingLoc(SourceLocation L) { UsingLocation = L; }\n\n  /// Return true if it is a C++03 access declaration (no 'using').\n  bool isAccessDeclaration() const { return UsingLocation.isInvalid(); }\n\n  /// Retrieve the nested-name-specifier that qualifies the name,\n  /// with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the nested-name-specifier that qualifies the name.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  DeclarationNameInfo getNameInfo() const {\n    return DeclarationNameInfo(getDeclName(), getLocation(), DNLoc);\n  }\n\n  /// Determine whether this is a pack expansion.\n  bool isPackExpansion() const {\n    return EllipsisLoc.isValid();\n  }\n\n  /// Get the location of the ellipsis if this is a pack expansion.\n  SourceLocation getEllipsisLoc() const {\n    return EllipsisLoc;\n  }\n\n  static UnresolvedUsingValueDecl *\n    Create(ASTContext &C, DeclContext *DC, SourceLocation UsingLoc,\n           NestedNameSpecifierLoc QualifierLoc,\n           const DeclarationNameInfo &NameInfo, SourceLocation EllipsisLoc);\n\n  static UnresolvedUsingValueDecl *\n  CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  /// Retrieves the canonical declaration of this declaration.\n  UnresolvedUsingValueDecl *getCanonicalDecl() override {\n    return getFirstDecl();\n  }\n  const UnresolvedUsingValueDecl *getCanonicalDecl() const {\n    return getFirstDecl();\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == UnresolvedUsingValue; }\n};\n\n/// Represents a dependent using declaration which was marked with\n/// \\c typename.\n///\n/// \\code\n/// template \\<class T> class A : public Base<T> {\n///   using typename Base<T>::foo;\n/// };\n/// \\endcode\n///\n/// The type associated with an unresolved using typename decl is\n/// currently always a typename type.\nclass UnresolvedUsingTypenameDecl\n    : public TypeDecl,\n      public Mergeable<UnresolvedUsingTypenameDecl> {\n  friend class ASTDeclReader;\n\n  /// The source location of the 'typename' keyword\n  SourceLocation TypenameLocation;\n\n  /// If this is a pack expansion, the location of the '...'.\n  SourceLocation EllipsisLoc;\n\n  /// The nested-name-specifier that precedes the name.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  UnresolvedUsingTypenameDecl(DeclContext *DC, SourceLocation UsingLoc,\n                              SourceLocation TypenameLoc,\n                              NestedNameSpecifierLoc QualifierLoc,\n                              SourceLocation TargetNameLoc,\n                              IdentifierInfo *TargetName,\n                              SourceLocation EllipsisLoc)\n    : TypeDecl(UnresolvedUsingTypename, DC, TargetNameLoc, TargetName,\n               UsingLoc),\n      TypenameLocation(TypenameLoc), EllipsisLoc(EllipsisLoc),\n      QualifierLoc(QualifierLoc) {}\n\n  void anchor() override;\n\npublic:\n  /// Returns the source location of the 'using' keyword.\n  SourceLocation getUsingLoc() const { return getBeginLoc(); }\n\n  /// Returns the source location of the 'typename' keyword.\n  SourceLocation getTypenameLoc() const { return TypenameLocation; }\n\n  /// Retrieve the nested-name-specifier that qualifies the name,\n  /// with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the nested-name-specifier that qualifies the name.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  DeclarationNameInfo getNameInfo() const {\n    return DeclarationNameInfo(getDeclName(), getLocation());\n  }\n\n  /// Determine whether this is a pack expansion.\n  bool isPackExpansion() const {\n    return EllipsisLoc.isValid();\n  }\n\n  /// Get the location of the ellipsis if this is a pack expansion.\n  SourceLocation getEllipsisLoc() const {\n    return EllipsisLoc;\n  }\n\n  static UnresolvedUsingTypenameDecl *\n    Create(ASTContext &C, DeclContext *DC, SourceLocation UsingLoc,\n           SourceLocation TypenameLoc, NestedNameSpecifierLoc QualifierLoc,\n           SourceLocation TargetNameLoc, DeclarationName TargetName,\n           SourceLocation EllipsisLoc);\n\n  static UnresolvedUsingTypenameDecl *\n  CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// Retrieves the canonical declaration of this declaration.\n  UnresolvedUsingTypenameDecl *getCanonicalDecl() override {\n    return getFirstDecl();\n  }\n  const UnresolvedUsingTypenameDecl *getCanonicalDecl() const {\n    return getFirstDecl();\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == UnresolvedUsingTypename; }\n};\n\n/// Represents a C++11 static_assert declaration.\nclass StaticAssertDecl : public Decl {\n  llvm::PointerIntPair<Expr *, 1, bool> AssertExprAndFailed;\n  StringLiteral *Message;\n  SourceLocation RParenLoc;\n\n  StaticAssertDecl(DeclContext *DC, SourceLocation StaticAssertLoc,\n                   Expr *AssertExpr, StringLiteral *Message,\n                   SourceLocation RParenLoc, bool Failed)\n      : Decl(StaticAssert, DC, StaticAssertLoc),\n        AssertExprAndFailed(AssertExpr, Failed), Message(Message),\n        RParenLoc(RParenLoc) {}\n\n  virtual void anchor();\n\npublic:\n  friend class ASTDeclReader;\n\n  static StaticAssertDecl *Create(ASTContext &C, DeclContext *DC,\n                                  SourceLocation StaticAssertLoc,\n                                  Expr *AssertExpr, StringLiteral *Message,\n                                  SourceLocation RParenLoc, bool Failed);\n  static StaticAssertDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  Expr *getAssertExpr() { return AssertExprAndFailed.getPointer(); }\n  const Expr *getAssertExpr() const { return AssertExprAndFailed.getPointer(); }\n\n  StringLiteral *getMessage() { return Message; }\n  const StringLiteral *getMessage() const { return Message; }\n\n  bool isFailed() const { return AssertExprAndFailed.getInt(); }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(getLocation(), getRParenLoc());\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == StaticAssert; }\n};\n\n/// A binding in a decomposition declaration. For instance, given:\n///\n///   int n[3];\n///   auto &[a, b, c] = n;\n///\n/// a, b, and c are BindingDecls, whose bindings are the expressions\n/// x[0], x[1], and x[2] respectively, where x is the implicit\n/// DecompositionDecl of type 'int (&)[3]'.\nclass BindingDecl : public ValueDecl {\n  /// The declaration that this binding binds to part of.\n  LazyDeclPtr Decomp;\n  /// The binding represented by this declaration. References to this\n  /// declaration are effectively equivalent to this expression (except\n  /// that it is only evaluated once at the point of declaration of the\n  /// binding).\n  Expr *Binding = nullptr;\n\n  BindingDecl(DeclContext *DC, SourceLocation IdLoc, IdentifierInfo *Id)\n      : ValueDecl(Decl::Binding, DC, IdLoc, Id, QualType()) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n\n  static BindingDecl *Create(ASTContext &C, DeclContext *DC,\n                             SourceLocation IdLoc, IdentifierInfo *Id);\n  static BindingDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// Get the expression to which this declaration is bound. This may be null\n  /// in two different cases: while parsing the initializer for the\n  /// decomposition declaration, and when the initializer is type-dependent.\n  Expr *getBinding() const { return Binding; }\n\n  /// Get the decomposition declaration that this binding represents a\n  /// decomposition of.\n  ValueDecl *getDecomposedDecl() const;\n\n  /// Get the variable (if any) that holds the value of evaluating the binding.\n  /// Only present for user-defined bindings for tuple-like types.\n  VarDecl *getHoldingVar() const;\n\n  /// Set the binding for this BindingDecl, along with its declared type (which\n  /// should be a possibly-cv-qualified form of the type of the binding, or a\n  /// reference to such a type).\n  void setBinding(QualType DeclaredType, Expr *Binding) {\n    setType(DeclaredType);\n    this->Binding = Binding;\n  }\n\n  /// Set the decomposed variable for this BindingDecl.\n  void setDecomposedDecl(ValueDecl *Decomposed) { Decomp = Decomposed; }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Decl::Binding; }\n};\n\n/// A decomposition declaration. For instance, given:\n///\n///   int n[3];\n///   auto &[a, b, c] = n;\n///\n/// the second line declares a DecompositionDecl of type 'int (&)[3]', and\n/// three BindingDecls (named a, b, and c). An instance of this class is always\n/// unnamed, but behaves in almost all other respects like a VarDecl.\nclass DecompositionDecl final\n    : public VarDecl,\n      private llvm::TrailingObjects<DecompositionDecl, BindingDecl *> {\n  /// The number of BindingDecl*s following this object.\n  unsigned NumBindings;\n\n  DecompositionDecl(ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n                    SourceLocation LSquareLoc, QualType T,\n                    TypeSourceInfo *TInfo, StorageClass SC,\n                    ArrayRef<BindingDecl *> Bindings)\n      : VarDecl(Decomposition, C, DC, StartLoc, LSquareLoc, nullptr, T, TInfo,\n                SC),\n        NumBindings(Bindings.size()) {\n    std::uninitialized_copy(Bindings.begin(), Bindings.end(),\n                            getTrailingObjects<BindingDecl *>());\n    for (auto *B : Bindings)\n      B->setDecomposedDecl(this);\n  }\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend TrailingObjects;\n\n  static DecompositionDecl *Create(ASTContext &C, DeclContext *DC,\n                                   SourceLocation StartLoc,\n                                   SourceLocation LSquareLoc,\n                                   QualType T, TypeSourceInfo *TInfo,\n                                   StorageClass S,\n                                   ArrayRef<BindingDecl *> Bindings);\n  static DecompositionDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                               unsigned NumBindings);\n\n  ArrayRef<BindingDecl *> bindings() const {\n    return llvm::makeArrayRef(getTrailingObjects<BindingDecl *>(), NumBindings);\n  }\n\n  void printName(raw_ostream &os) const override;\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Decomposition; }\n};\n\n/// An instance of this class represents the declaration of a property\n/// member.  This is a Microsoft extension to C++, first introduced in\n/// Visual Studio .NET 2003 as a parallel to similar features in C#\n/// and Managed C++.\n///\n/// A property must always be a non-static class member.\n///\n/// A property member superficially resembles a non-static data\n/// member, except preceded by a property attribute:\n///   __declspec(property(get=GetX, put=PutX)) int x;\n/// Either (but not both) of the 'get' and 'put' names may be omitted.\n///\n/// A reference to a property is always an lvalue.  If the lvalue\n/// undergoes lvalue-to-rvalue conversion, then a getter name is\n/// required, and that member is called with no arguments.\n/// If the lvalue is assigned into, then a setter name is required,\n/// and that member is called with one argument, the value assigned.\n/// Both operations are potentially overloaded.  Compound assignments\n/// are permitted, as are the increment and decrement operators.\n///\n/// The getter and putter methods are permitted to be overloaded,\n/// although their return and parameter types are subject to certain\n/// restrictions according to the type of the property.\n///\n/// A property declared using an incomplete array type may\n/// additionally be subscripted, adding extra parameters to the getter\n/// and putter methods.\nclass MSPropertyDecl : public DeclaratorDecl {\n  IdentifierInfo *GetterId, *SetterId;\n\n  MSPropertyDecl(DeclContext *DC, SourceLocation L, DeclarationName N,\n                 QualType T, TypeSourceInfo *TInfo, SourceLocation StartL,\n                 IdentifierInfo *Getter, IdentifierInfo *Setter)\n      : DeclaratorDecl(MSProperty, DC, L, N, T, TInfo, StartL),\n        GetterId(Getter), SetterId(Setter) {}\n\n  void anchor() override;\npublic:\n  friend class ASTDeclReader;\n\n  static MSPropertyDecl *Create(ASTContext &C, DeclContext *DC,\n                                SourceLocation L, DeclarationName N, QualType T,\n                                TypeSourceInfo *TInfo, SourceLocation StartL,\n                                IdentifierInfo *Getter, IdentifierInfo *Setter);\n  static MSPropertyDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  static bool classof(const Decl *D) { return D->getKind() == MSProperty; }\n\n  bool hasGetter() const { return GetterId != nullptr; }\n  IdentifierInfo* getGetterId() const { return GetterId; }\n  bool hasSetter() const { return SetterId != nullptr; }\n  IdentifierInfo* getSetterId() const { return SetterId; }\n};\n\n/// Parts of a decomposed MSGuidDecl. Factored out to avoid unnecessary\n/// dependencies on DeclCXX.h.\nstruct MSGuidDeclParts {\n  /// {01234567-...\n  uint32_t Part1;\n  /// ...-89ab-...\n  uint16_t Part2;\n  /// ...-cdef-...\n  uint16_t Part3;\n  /// ...-0123-456789abcdef}\n  uint8_t Part4And5[8];\n\n  uint64_t getPart4And5AsUint64() const {\n    uint64_t Val;\n    memcpy(&Val, &Part4And5, sizeof(Part4And5));\n    return Val;\n  }\n};\n\n/// A global _GUID constant. These are implicitly created by UuidAttrs.\n///\n///   struct _declspec(uuid(\"01234567-89ab-cdef-0123-456789abcdef\")) X{};\n///\n/// X is a CXXRecordDecl that contains a UuidAttr that references the (unique)\n/// MSGuidDecl for the specified UUID.\nclass MSGuidDecl : public ValueDecl,\n                   public Mergeable<MSGuidDecl>,\n                   public llvm::FoldingSetNode {\npublic:\n  using Parts = MSGuidDeclParts;\n\nprivate:\n  /// The decomposed form of the UUID.\n  Parts PartVal;\n\n  /// The resolved value of the UUID as an APValue. Computed on demand and\n  /// cached.\n  mutable APValue APVal;\n\n  void anchor() override;\n\n  MSGuidDecl(DeclContext *DC, QualType T, Parts P);\n\n  static MSGuidDecl *Create(const ASTContext &C, QualType T, Parts P);\n  static MSGuidDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  // Only ASTContext::getMSGuidDecl and deserialization create these.\n  friend class ASTContext;\n  friend class ASTReader;\n  friend class ASTDeclReader;\n\npublic:\n  /// Print this UUID in a human-readable format.\n  void printName(llvm::raw_ostream &OS) const override;\n\n  /// Get the decomposed parts of this declaration.\n  Parts getParts() const { return PartVal; }\n\n  /// Get the value of this MSGuidDecl as an APValue. This may fail and return\n  /// an absent APValue if the type of the declaration is not of the expected\n  /// shape.\n  APValue &getAsAPValue() const;\n\n  static void Profile(llvm::FoldingSetNodeID &ID, Parts P) {\n    ID.AddInteger(P.Part1);\n    ID.AddInteger(P.Part2);\n    ID.AddInteger(P.Part3);\n    ID.AddInteger(P.getPart4And5AsUint64());\n  }\n  void Profile(llvm::FoldingSetNodeID &ID) { Profile(ID, PartVal); }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Decl::MSGuid; }\n};\n\n/// Insertion operator for diagnostics.  This allows sending an AccessSpecifier\n/// into a diagnostic with <<.\nconst StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                      AccessSpecifier AS);\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_DECLCXX_H\n"}, "9": {"id": 9, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclFriend.h", "content": "//===- DeclFriend.h - Classes for C++ friend declarations -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the section of the AST representing C++ friend\n// declarations.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_DECLFRIEND_H\n#define LLVM_CLANG_AST_DECLFRIEND_H\n\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclTemplate.h\"\n#include \"clang/AST/ExternalASTSource.h\"\n#include \"clang/AST/TypeLoc.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include <cassert>\n#include <iterator>\n\nnamespace clang {\n\nclass ASTContext;\n\n/// FriendDecl - Represents the declaration of a friend entity,\n/// which can be a function, a type, or a templated function or type.\n/// For example:\n///\n/// @code\n/// template <typename T> class A {\n///   friend int foo(T);\n///   friend class B;\n///   friend T; // only in C++0x\n///   template <typename U> friend class C;\n///   template <typename U> friend A& operator+=(A&, const U&) { ... }\n/// };\n/// @endcode\n///\n/// The semantic context of a friend decl is its declaring class.\nclass FriendDecl final\n    : public Decl,\n      private llvm::TrailingObjects<FriendDecl, TemplateParameterList *> {\n  virtual void anchor();\n\npublic:\n  using FriendUnion = llvm::PointerUnion<NamedDecl *, TypeSourceInfo *>;\n\nprivate:\n  friend class CXXRecordDecl;\n  friend class CXXRecordDecl::friend_iterator;\n\n  // The declaration that's a friend of this class.\n  FriendUnion Friend;\n\n  // A pointer to the next friend in the sequence.\n  LazyDeclPtr NextFriend;\n\n  // Location of the 'friend' specifier.\n  SourceLocation FriendLoc;\n\n  /// True if this 'friend' declaration is unsupported.  Eventually we\n  /// will support every possible friend declaration, but for now we\n  /// silently ignore some and set this flag to authorize all access.\n  unsigned UnsupportedFriend : 1;\n\n  // The number of \"outer\" template parameter lists in non-templatic\n  // (currently unsupported) friend type declarations, such as\n  //     template <class T> friend class A<T>::B;\n  unsigned NumTPLists : 31;\n\n  FriendDecl(DeclContext *DC, SourceLocation L, FriendUnion Friend,\n             SourceLocation FriendL,\n             ArrayRef<TemplateParameterList *> FriendTypeTPLists)\n      : Decl(Decl::Friend, DC, L), Friend(Friend), FriendLoc(FriendL),\n        UnsupportedFriend(false), NumTPLists(FriendTypeTPLists.size()) {\n    for (unsigned i = 0; i < NumTPLists; ++i)\n      getTrailingObjects<TemplateParameterList *>()[i] = FriendTypeTPLists[i];\n  }\n\n  FriendDecl(EmptyShell Empty, unsigned NumFriendTypeTPLists)\n      : Decl(Decl::Friend, Empty), UnsupportedFriend(false),\n        NumTPLists(NumFriendTypeTPLists) {}\n\n  FriendDecl *getNextFriend() {\n    if (!NextFriend.isOffset())\n      return cast_or_null<FriendDecl>(NextFriend.get(nullptr));\n    return getNextFriendSlowCase();\n  }\n\n  FriendDecl *getNextFriendSlowCase();\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend class ASTNodeImporter;\n  friend TrailingObjects;\n\n  static FriendDecl *Create(ASTContext &C, DeclContext *DC,\n                            SourceLocation L, FriendUnion Friend_,\n                            SourceLocation FriendL,\n                            ArrayRef<TemplateParameterList*> FriendTypeTPLists\n                            = None);\n  static FriendDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                        unsigned FriendTypeNumTPLists);\n\n  /// If this friend declaration names an (untemplated but possibly\n  /// dependent) type, return the type; otherwise return null.  This\n  /// is used for elaborated-type-specifiers and, in C++0x, for\n  /// arbitrary friend type declarations.\n  TypeSourceInfo *getFriendType() const {\n    return Friend.dyn_cast<TypeSourceInfo*>();\n  }\n\n  unsigned getFriendTypeNumTemplateParameterLists() const {\n    return NumTPLists;\n  }\n\n  TemplateParameterList *getFriendTypeTemplateParameterList(unsigned N) const {\n    assert(N < NumTPLists);\n    return getTrailingObjects<TemplateParameterList *>()[N];\n  }\n\n  /// If this friend declaration doesn't name a type, return the inner\n  /// declaration.\n  NamedDecl *getFriendDecl() const {\n    return Friend.dyn_cast<NamedDecl *>();\n  }\n\n  /// Retrieves the location of the 'friend' keyword.\n  SourceLocation getFriendLoc() const {\n    return FriendLoc;\n  }\n\n  /// Retrieves the source range for the friend declaration.\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    if (NamedDecl *ND = getFriendDecl()) {\n      if (const auto *FD = dyn_cast<FunctionDecl>(ND))\n        return FD->getSourceRange();\n      if (const auto *FTD = dyn_cast<FunctionTemplateDecl>(ND))\n        return FTD->getSourceRange();\n      if (const auto *CTD = dyn_cast<ClassTemplateDecl>(ND))\n        return CTD->getSourceRange();\n      if (const auto *DD = dyn_cast<DeclaratorDecl>(ND)) {\n        if (DD->getOuterLocStart() != DD->getInnerLocStart())\n          return DD->getSourceRange();\n      }\n      return SourceRange(getFriendLoc(), ND->getEndLoc());\n    }\n    else if (TypeSourceInfo *TInfo = getFriendType()) {\n      SourceLocation StartL =\n          (NumTPLists == 0) ? getFriendLoc()\n                            : getTrailingObjects<TemplateParameterList *>()[0]\n                                  ->getTemplateLoc();\n      return SourceRange(StartL, TInfo->getTypeLoc().getEndLoc());\n    }\n    else\n      return SourceRange(getFriendLoc(), getLocation());\n  }\n\n  /// Determines if this friend kind is unsupported.\n  bool isUnsupportedFriend() const {\n    return UnsupportedFriend;\n  }\n  void setUnsupportedFriend(bool Unsupported) {\n    UnsupportedFriend = Unsupported;\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Decl::Friend; }\n};\n\n/// An iterator over the friend declarations of a class.\nclass CXXRecordDecl::friend_iterator {\n  friend class CXXRecordDecl;\n\n  FriendDecl *Ptr;\n\n  explicit friend_iterator(FriendDecl *Ptr) : Ptr(Ptr) {}\n\npublic:\n  friend_iterator() = default;\n\n  using value_type = FriendDecl *;\n  using reference = FriendDecl *;\n  using pointer = FriendDecl *;\n  using difference_type = int;\n  using iterator_category = std::forward_iterator_tag;\n\n  reference operator*() const { return Ptr; }\n\n  friend_iterator &operator++() {\n    assert(Ptr && \"attempt to increment past end of friend list\");\n    Ptr = Ptr->getNextFriend();\n    return *this;\n  }\n\n  friend_iterator operator++(int) {\n    friend_iterator tmp = *this;\n    ++*this;\n    return tmp;\n  }\n\n  bool operator==(const friend_iterator &Other) const {\n    return Ptr == Other.Ptr;\n  }\n\n  bool operator!=(const friend_iterator &Other) const {\n    return Ptr != Other.Ptr;\n  }\n\n  friend_iterator &operator+=(difference_type N) {\n    assert(N >= 0 && \"cannot rewind a CXXRecordDecl::friend_iterator\");\n    while (N--)\n      ++*this;\n    return *this;\n  }\n\n  friend_iterator operator+(difference_type N) const {\n    friend_iterator tmp = *this;\n    tmp += N;\n    return tmp;\n  }\n};\n\ninline CXXRecordDecl::friend_iterator CXXRecordDecl::friend_begin() const {\n  return friend_iterator(getFirstFriend());\n}\n\ninline CXXRecordDecl::friend_iterator CXXRecordDecl::friend_end() const {\n  return friend_iterator(nullptr);\n}\n\ninline CXXRecordDecl::friend_range CXXRecordDecl::friends() const {\n  return friend_range(friend_begin(), friend_end());\n}\n\ninline void CXXRecordDecl::pushFriendDecl(FriendDecl *FD) {\n  assert(!FD->NextFriend && \"friend already has next friend?\");\n  FD->NextFriend = data().FirstFriend;\n  data().FirstFriend = FD;\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_DECLFRIEND_H\n"}, "11": {"id": 11, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclOpenMP.h", "content": "//===- DeclOpenMP.h - Classes for representing OpenMP directives -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// This file defines OpenMP nodes for declarative directives.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_DECLOPENMP_H\n#define LLVM_CLANG_AST_DECLOPENMP_H\n\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExternalASTSource.h\"\n#include \"clang/AST/OpenMPClause.h\"\n#include \"clang/AST/Type.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n\nnamespace clang {\n\n/// This is a basic class for representing single OpenMP declarative directive.\n///\ntemplate <typename U> class OMPDeclarativeDirective : public U {\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Get the clauses storage.\n  MutableArrayRef<OMPClause *> getClauses() {\n    if (!Data)\n      return llvm::None;\n    return Data->getClauses();\n  }\n\nprotected:\n  /// Data, associated with the directive.\n  OMPChildren *Data = nullptr;\n\n  /// Build instance of directive.\n  template <typename... Params>\n  OMPDeclarativeDirective(Params &&... P) : U(std::forward<Params>(P)...) {}\n\n  template <typename T, typename... Params>\n  static T *createDirective(const ASTContext &C, DeclContext *DC,\n                            ArrayRef<OMPClause *> Clauses, unsigned NumChildren,\n                            Params &&... P) {\n    auto *Inst = new (C, DC, size(Clauses.size(), NumChildren))\n        T(DC, std::forward<Params>(P)...);\n    Inst->Data = OMPChildren::Create(Inst + 1, Clauses,\n                                     /*AssociatedStmt=*/nullptr, NumChildren);\n    Inst->Data->setClauses(Clauses);\n    return Inst;\n  }\n\n  template <typename T, typename... Params>\n  static T *createEmptyDirective(const ASTContext &C, unsigned ID,\n                                 unsigned NumClauses, unsigned NumChildren,\n                                 Params &&... P) {\n    auto *Inst = new (C, ID, size(NumClauses, NumChildren))\n        T(nullptr, std::forward<Params>(P)...);\n    Inst->Data = OMPChildren::CreateEmpty(\n        Inst + 1, NumClauses, /*HasAssociatedStmt=*/false, NumChildren);\n    return Inst;\n  }\n\n  static size_t size(unsigned NumClauses, unsigned NumChildren) {\n    return OMPChildren::size(NumClauses, /*HasAssociatedStmt=*/false,\n                             NumChildren);\n  }\n\npublic:\n  /// Get number of clauses.\n  unsigned getNumClauses() const {\n    if (!Data)\n      return 0;\n    return Data->getNumClauses();\n  }\n\n  /// Returns specified clause.\n  ///\n  /// \\param I Number of clause.\n  ///\n  OMPClause *getClause(unsigned I) const { return clauses()[I]; }\n\n  ArrayRef<OMPClause *> clauses() const {\n    if (!Data)\n      return llvm::None;\n    return Data->getClauses();\n  }\n};\n\n/// This represents '#pragma omp threadprivate ...' directive.\n/// For example, in the following, both 'a' and 'A::b' are threadprivate:\n///\n/// \\code\n/// int a;\n/// #pragma omp threadprivate(a)\n/// struct A {\n///   static int b;\n/// #pragma omp threadprivate(b)\n/// };\n/// \\endcode\n///\nclass OMPThreadPrivateDecl final : public OMPDeclarativeDirective<Decl> {\n  friend class OMPDeclarativeDirective<Decl>;\n\n  virtual void anchor();\n\n  OMPThreadPrivateDecl(DeclContext *DC = nullptr,\n                       SourceLocation L = SourceLocation())\n      : OMPDeclarativeDirective<Decl>(OMPThreadPrivate, DC, L) {}\n\n  ArrayRef<const Expr *> getVars() const {\n    auto **Storage = reinterpret_cast<Expr **>(Data->getChildren().data());\n    return llvm::makeArrayRef(Storage, Data->getNumChildren());\n  }\n\n  MutableArrayRef<Expr *> getVars() {\n    auto **Storage = reinterpret_cast<Expr **>(Data->getChildren().data());\n    return llvm::makeMutableArrayRef(Storage, Data->getNumChildren());\n  }\n\n  void setVars(ArrayRef<Expr *> VL);\n\npublic:\n  static OMPThreadPrivateDecl *Create(ASTContext &C, DeclContext *DC,\n                                      SourceLocation L,\n                                      ArrayRef<Expr *> VL);\n  static OMPThreadPrivateDecl *CreateDeserialized(ASTContext &C,\n                                                  unsigned ID, unsigned N);\n\n  typedef MutableArrayRef<Expr *>::iterator varlist_iterator;\n  typedef ArrayRef<const Expr *>::iterator varlist_const_iterator;\n  typedef llvm::iterator_range<varlist_iterator> varlist_range;\n  typedef llvm::iterator_range<varlist_const_iterator> varlist_const_range;\n\n  unsigned varlist_size() const { return Data->getNumChildren(); }\n  bool varlist_empty() const { return Data->getChildren().empty(); }\n\n  varlist_range varlists() {\n    return varlist_range(varlist_begin(), varlist_end());\n  }\n  varlist_const_range varlists() const {\n    return varlist_const_range(varlist_begin(), varlist_end());\n  }\n  varlist_iterator varlist_begin() { return getVars().begin(); }\n  varlist_iterator varlist_end() { return getVars().end(); }\n  varlist_const_iterator varlist_begin() const { return getVars().begin(); }\n  varlist_const_iterator varlist_end() const { return getVars().end(); }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == OMPThreadPrivate; }\n};\n\n/// This represents '#pragma omp declare reduction ...' directive.\n/// For example, in the following, declared reduction 'foo' for types 'int' and\n/// 'float':\n///\n/// \\code\n/// #pragma omp declare reduction (foo : int,float : omp_out += omp_in)\n///                     initializer (omp_priv = 0)\n/// \\endcode\n///\n/// Here 'omp_out += omp_in' is a combiner and 'omp_priv = 0' is an initializer.\nclass OMPDeclareReductionDecl final : public ValueDecl, public DeclContext {\n  // This class stores some data in DeclContext::OMPDeclareReductionDeclBits\n  // to save some space. Use the provided accessors to access it.\npublic:\n  enum InitKind {\n    CallInit,   // Initialized by function call.\n    DirectInit, // omp_priv(<expr>)\n    CopyInit    // omp_priv = <expr>\n  };\n\nprivate:\n  friend class ASTDeclReader;\n  /// Combiner for declare reduction construct.\n  Expr *Combiner = nullptr;\n  /// Initializer for declare reduction construct.\n  Expr *Initializer = nullptr;\n  /// In parameter of the combiner.\n  Expr *In = nullptr;\n  /// Out parameter of the combiner.\n  Expr *Out = nullptr;\n  /// Priv parameter of the initializer.\n  Expr *Priv = nullptr;\n  /// Orig parameter of the initializer.\n  Expr *Orig = nullptr;\n\n  /// Reference to the previous declare reduction construct in the same\n  /// scope with the same name. Required for proper templates instantiation if\n  /// the declare reduction construct is declared inside compound statement.\n  LazyDeclPtr PrevDeclInScope;\n\n  void anchor() override;\n\n  OMPDeclareReductionDecl(Kind DK, DeclContext *DC, SourceLocation L,\n                          DeclarationName Name, QualType Ty,\n                          OMPDeclareReductionDecl *PrevDeclInScope);\n\n  void setPrevDeclInScope(OMPDeclareReductionDecl *Prev) {\n    PrevDeclInScope = Prev;\n  }\n\npublic:\n  /// Create declare reduction node.\n  static OMPDeclareReductionDecl *\n  Create(ASTContext &C, DeclContext *DC, SourceLocation L, DeclarationName Name,\n         QualType T, OMPDeclareReductionDecl *PrevDeclInScope);\n  /// Create deserialized declare reduction node.\n  static OMPDeclareReductionDecl *CreateDeserialized(ASTContext &C,\n                                                     unsigned ID);\n\n  /// Get combiner expression of the declare reduction construct.\n  Expr *getCombiner() { return Combiner; }\n  const Expr *getCombiner() const { return Combiner; }\n  /// Get In variable of the combiner.\n  Expr *getCombinerIn() { return In; }\n  const Expr *getCombinerIn() const { return In; }\n  /// Get Out variable of the combiner.\n  Expr *getCombinerOut() { return Out; }\n  const Expr *getCombinerOut() const { return Out; }\n  /// Set combiner expression for the declare reduction construct.\n  void setCombiner(Expr *E) { Combiner = E; }\n  /// Set combiner In and Out vars.\n  void setCombinerData(Expr *InE, Expr *OutE) {\n    In = InE;\n    Out = OutE;\n  }\n\n  /// Get initializer expression (if specified) of the declare reduction\n  /// construct.\n  Expr *getInitializer() { return Initializer; }\n  const Expr *getInitializer() const { return Initializer; }\n  /// Get initializer kind.\n  InitKind getInitializerKind() const {\n    return static_cast<InitKind>(OMPDeclareReductionDeclBits.InitializerKind);\n  }\n  /// Get Orig variable of the initializer.\n  Expr *getInitOrig() { return Orig; }\n  const Expr *getInitOrig() const { return Orig; }\n  /// Get Priv variable of the initializer.\n  Expr *getInitPriv() { return Priv; }\n  const Expr *getInitPriv() const { return Priv; }\n  /// Set initializer expression for the declare reduction construct.\n  void setInitializer(Expr *E, InitKind IK) {\n    Initializer = E;\n    OMPDeclareReductionDeclBits.InitializerKind = IK;\n  }\n  /// Set initializer Orig and Priv vars.\n  void setInitializerData(Expr *OrigE, Expr *PrivE) {\n    Orig = OrigE;\n    Priv = PrivE;\n  }\n\n  /// Get reference to previous declare reduction construct in the same\n  /// scope with the same name.\n  OMPDeclareReductionDecl *getPrevDeclInScope();\n  const OMPDeclareReductionDecl *getPrevDeclInScope() const;\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == OMPDeclareReduction; }\n  static DeclContext *castToDeclContext(const OMPDeclareReductionDecl *D) {\n    return static_cast<DeclContext *>(const_cast<OMPDeclareReductionDecl *>(D));\n  }\n  static OMPDeclareReductionDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<OMPDeclareReductionDecl *>(\n        const_cast<DeclContext *>(DC));\n  }\n};\n\n/// This represents '#pragma omp declare mapper ...' directive. Map clauses are\n/// allowed to use with this directive. The following example declares a user\n/// defined mapper for the type 'struct vec'. This example instructs the fields\n/// 'len' and 'data' should be mapped when mapping instances of 'struct vec'.\n///\n/// \\code\n/// #pragma omp declare mapper(mid: struct vec v) map(v.len, v.data[0:N])\n/// \\endcode\nclass OMPDeclareMapperDecl final : public OMPDeclarativeDirective<ValueDecl>,\n                                   public DeclContext {\n  friend class OMPDeclarativeDirective<ValueDecl>;\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Mapper variable, which is 'v' in the example above\n  Expr *MapperVarRef = nullptr;\n\n  /// Name of the mapper variable\n  DeclarationName VarName;\n\n  LazyDeclPtr PrevDeclInScope;\n\n  void anchor() override;\n\n  OMPDeclareMapperDecl(DeclContext *DC, SourceLocation L, DeclarationName Name,\n                       QualType Ty, DeclarationName VarName,\n                       OMPDeclareMapperDecl *PrevDeclInScope)\n      : OMPDeclarativeDirective<ValueDecl>(OMPDeclareMapper, DC, L, Name, Ty),\n        DeclContext(OMPDeclareMapper), VarName(VarName),\n        PrevDeclInScope(PrevDeclInScope) {}\n\n  void setPrevDeclInScope(OMPDeclareMapperDecl *Prev) {\n    PrevDeclInScope = Prev;\n  }\n\npublic:\n  /// Creates declare mapper node.\n  static OMPDeclareMapperDecl *Create(ASTContext &C, DeclContext *DC,\n                                      SourceLocation L, DeclarationName Name,\n                                      QualType T, DeclarationName VarName,\n                                      ArrayRef<OMPClause *> Clauses,\n                                      OMPDeclareMapperDecl *PrevDeclInScope);\n  /// Creates deserialized declare mapper node.\n  static OMPDeclareMapperDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                                  unsigned N);\n\n  using clauselist_iterator = MutableArrayRef<OMPClause *>::iterator;\n  using clauselist_const_iterator = ArrayRef<const OMPClause *>::iterator;\n  using clauselist_range = llvm::iterator_range<clauselist_iterator>;\n  using clauselist_const_range =\n      llvm::iterator_range<clauselist_const_iterator>;\n\n  unsigned clauselist_size() const { return Data->getNumClauses(); }\n  bool clauselist_empty() const { return Data->getClauses().empty(); }\n\n  clauselist_range clauselists() {\n    return clauselist_range(clauselist_begin(), clauselist_end());\n  }\n  clauselist_const_range clauselists() const {\n    return clauselist_const_range(clauselist_begin(), clauselist_end());\n  }\n  clauselist_iterator clauselist_begin() { return Data->getClauses().begin(); }\n  clauselist_iterator clauselist_end() { return Data->getClauses().end(); }\n  clauselist_const_iterator clauselist_begin() const {\n    return Data->getClauses().begin();\n  }\n  clauselist_const_iterator clauselist_end() const {\n    return Data->getClauses().end();\n  }\n\n  /// Get the variable declared in the mapper\n  Expr *getMapperVarRef() { return cast_or_null<Expr>(Data->getChildren()[0]); }\n  const Expr *getMapperVarRef() const {\n    return cast_or_null<Expr>(Data->getChildren()[0]);\n  }\n  /// Set the variable declared in the mapper\n  void setMapperVarRef(Expr *MapperVarRefE) {\n    Data->getChildren()[0] = MapperVarRefE;\n  }\n\n  /// Get the name of the variable declared in the mapper\n  DeclarationName getVarName() { return VarName; }\n\n  /// Get reference to previous declare mapper construct in the same\n  /// scope with the same name.\n  OMPDeclareMapperDecl *getPrevDeclInScope();\n  const OMPDeclareMapperDecl *getPrevDeclInScope() const;\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == OMPDeclareMapper; }\n  static DeclContext *castToDeclContext(const OMPDeclareMapperDecl *D) {\n    return static_cast<DeclContext *>(const_cast<OMPDeclareMapperDecl *>(D));\n  }\n  static OMPDeclareMapperDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<OMPDeclareMapperDecl *>(const_cast<DeclContext *>(DC));\n  }\n};\n\n/// Pseudo declaration for capturing expressions. Also is used for capturing of\n/// non-static data members in non-static member functions.\n///\n/// Clang supports capturing of variables only, but OpenMP 4.5 allows to\n/// privatize non-static members of current class in non-static member\n/// functions. This pseudo-declaration allows properly handle this kind of\n/// capture by wrapping captured expression into a variable-like declaration.\nclass OMPCapturedExprDecl final : public VarDecl {\n  friend class ASTDeclReader;\n  void anchor() override;\n\n  OMPCapturedExprDecl(ASTContext &C, DeclContext *DC, IdentifierInfo *Id,\n                      QualType Type, TypeSourceInfo *TInfo,\n                      SourceLocation StartLoc)\n      : VarDecl(OMPCapturedExpr, C, DC, StartLoc, StartLoc, Id, Type, TInfo,\n                SC_None) {\n    setImplicit();\n  }\n\npublic:\n  static OMPCapturedExprDecl *Create(ASTContext &C, DeclContext *DC,\n                                     IdentifierInfo *Id, QualType T,\n                                     SourceLocation StartLoc);\n\n  static OMPCapturedExprDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == OMPCapturedExpr; }\n};\n\n/// This represents '#pragma omp requires...' directive.\n/// For example\n///\n/// \\code\n/// #pragma omp requires unified_address\n/// \\endcode\n///\nclass OMPRequiresDecl final : public OMPDeclarativeDirective<Decl> {\n  friend class OMPDeclarativeDirective<Decl>;\n  friend class ASTDeclReader;\n\n  virtual void anchor();\n\n  OMPRequiresDecl(DeclContext *DC, SourceLocation L)\n      : OMPDeclarativeDirective<Decl>(OMPRequires, DC, L) {}\n\npublic:\n  /// Create requires node.\n  static OMPRequiresDecl *Create(ASTContext &C, DeclContext *DC,\n                                 SourceLocation L, ArrayRef<OMPClause *> CL);\n  /// Create deserialized requires node.\n  static OMPRequiresDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                             unsigned N);\n\n  using clauselist_iterator = MutableArrayRef<OMPClause *>::iterator;\n  using clauselist_const_iterator = ArrayRef<const OMPClause *>::iterator;\n  using clauselist_range = llvm::iterator_range<clauselist_iterator>;\n  using clauselist_const_range = llvm::iterator_range<clauselist_const_iterator>;\n\n  unsigned clauselist_size() const { return Data->getNumClauses(); }\n  bool clauselist_empty() const { return Data->getClauses().empty(); }\n\n  clauselist_range clauselists() {\n    return clauselist_range(clauselist_begin(), clauselist_end());\n  }\n  clauselist_const_range clauselists() const {\n    return clauselist_const_range(clauselist_begin(), clauselist_end());\n  }\n  clauselist_iterator clauselist_begin() { return Data->getClauses().begin(); }\n  clauselist_iterator clauselist_end() { return Data->getClauses().end(); }\n  clauselist_const_iterator clauselist_begin() const {\n    return Data->getClauses().begin();\n  }\n  clauselist_const_iterator clauselist_end() const {\n    return Data->getClauses().end();\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == OMPRequires; }\n};\n\n/// This represents '#pragma omp allocate ...' directive.\n/// For example, in the following, the default allocator is used for both 'a'\n/// and 'A::b':\n///\n/// \\code\n/// int a;\n/// #pragma omp allocate(a)\n/// struct A {\n///   static int b;\n/// #pragma omp allocate(b)\n/// };\n/// \\endcode\n///\nclass OMPAllocateDecl final : public OMPDeclarativeDirective<Decl> {\n  friend class OMPDeclarativeDirective<Decl>;\n  friend class ASTDeclReader;\n\n  virtual void anchor();\n\n  OMPAllocateDecl(DeclContext *DC, SourceLocation L)\n      : OMPDeclarativeDirective<Decl>(OMPAllocate, DC, L) {}\n\n  ArrayRef<const Expr *> getVars() const {\n    auto **Storage = reinterpret_cast<Expr **>(Data->getChildren().data());\n    return llvm::makeArrayRef(Storage, Data->getNumChildren());\n  }\n\n  MutableArrayRef<Expr *> getVars() {\n    auto **Storage = reinterpret_cast<Expr **>(Data->getChildren().data());\n    return llvm::makeMutableArrayRef(Storage, Data->getNumChildren());\n  }\n\n  void setVars(ArrayRef<Expr *> VL);\n\npublic:\n  static OMPAllocateDecl *Create(ASTContext &C, DeclContext *DC,\n                                 SourceLocation L, ArrayRef<Expr *> VL,\n                                 ArrayRef<OMPClause *> CL);\n  static OMPAllocateDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                             unsigned NVars, unsigned NClauses);\n\n  typedef MutableArrayRef<Expr *>::iterator varlist_iterator;\n  typedef ArrayRef<const Expr *>::iterator varlist_const_iterator;\n  typedef llvm::iterator_range<varlist_iterator> varlist_range;\n  typedef llvm::iterator_range<varlist_const_iterator> varlist_const_range;\n  using clauselist_iterator = MutableArrayRef<OMPClause *>::iterator;\n  using clauselist_const_iterator = ArrayRef<const OMPClause *>::iterator;\n  using clauselist_range = llvm::iterator_range<clauselist_iterator>;\n  using clauselist_const_range = llvm::iterator_range<clauselist_const_iterator>;\n\n  unsigned varlist_size() const { return Data->getNumChildren(); }\n  bool varlist_empty() const { return Data->getChildren().empty(); }\n  unsigned clauselist_size() const { return Data->getNumClauses(); }\n  bool clauselist_empty() const { return Data->getClauses().empty(); }\n\n  varlist_range varlists() {\n    return varlist_range(varlist_begin(), varlist_end());\n  }\n  varlist_const_range varlists() const {\n    return varlist_const_range(varlist_begin(), varlist_end());\n  }\n  varlist_iterator varlist_begin() { return getVars().begin(); }\n  varlist_iterator varlist_end() { return getVars().end(); }\n  varlist_const_iterator varlist_begin() const { return getVars().begin(); }\n  varlist_const_iterator varlist_end() const { return getVars().end(); }\n\n  clauselist_range clauselists() {\n    return clauselist_range(clauselist_begin(), clauselist_end());\n  }\n  clauselist_const_range clauselists() const {\n    return clauselist_const_range(clauselist_begin(), clauselist_end());\n  }\n  clauselist_iterator clauselist_begin() { return Data->getClauses().begin(); }\n  clauselist_iterator clauselist_end() { return Data->getClauses().end(); }\n  clauselist_const_iterator clauselist_begin() const {\n    return Data->getClauses().begin();\n  }\n  clauselist_const_iterator clauselist_end() const {\n    return Data->getClauses().end();\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == OMPAllocate; }\n};\n\n} // end namespace clang\n\n#endif\n"}, "16": {"id": 16, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprConcepts.h", "content": "//===- ExprConcepts.h - C++2a Concepts expressions --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines Expressions and AST nodes for C++2a concepts.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_EXPRCONCEPTS_H\n#define LLVM_CLANG_AST_EXPRCONCEPTS_H\n\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/ASTConcept.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/DeclTemplate.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/TemplateBase.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include <utility>\n#include <string>\n\nnamespace clang {\nclass ASTStmtReader;\nclass ASTStmtWriter;\n\n/// \\brief Represents the specialization of a concept - evaluates to a prvalue\n/// of type bool.\n///\n/// According to C++2a [expr.prim.id]p3 an id-expression that denotes the\n/// specialization of a concept results in a prvalue of type bool.\nclass ConceptSpecializationExpr final : public Expr, public ConceptReference,\n      private llvm::TrailingObjects<ConceptSpecializationExpr,\n                                    TemplateArgument> {\n  friend class ASTStmtReader;\n  friend TrailingObjects;\npublic:\n  using SubstitutionDiagnostic = std::pair<SourceLocation, std::string>;\n\nprotected:\n  /// \\brief The number of template arguments in the tail-allocated list of\n  /// converted template arguments.\n  unsigned NumTemplateArgs;\n\n  /// \\brief Information about the satisfaction of the named concept with the\n  /// given arguments. If this expression is value dependent, this is to be\n  /// ignored.\n  ASTConstraintSatisfaction *Satisfaction;\n\n  ConceptSpecializationExpr(const ASTContext &C, NestedNameSpecifierLoc NNS,\n                            SourceLocation TemplateKWLoc,\n                            DeclarationNameInfo ConceptNameInfo,\n                            NamedDecl *FoundDecl, ConceptDecl *NamedConcept,\n                            const ASTTemplateArgumentListInfo *ArgsAsWritten,\n                            ArrayRef<TemplateArgument> ConvertedArgs,\n                            const ConstraintSatisfaction *Satisfaction);\n\n  ConceptSpecializationExpr(const ASTContext &C, ConceptDecl *NamedConcept,\n                            ArrayRef<TemplateArgument> ConvertedArgs,\n                            const ConstraintSatisfaction *Satisfaction,\n                            bool Dependent,\n                            bool ContainsUnexpandedParameterPack);\n\n  ConceptSpecializationExpr(EmptyShell Empty, unsigned NumTemplateArgs);\n\npublic:\n\n  static ConceptSpecializationExpr *\n  Create(const ASTContext &C, NestedNameSpecifierLoc NNS,\n         SourceLocation TemplateKWLoc, DeclarationNameInfo ConceptNameInfo,\n         NamedDecl *FoundDecl, ConceptDecl *NamedConcept,\n         const ASTTemplateArgumentListInfo *ArgsAsWritten,\n         ArrayRef<TemplateArgument> ConvertedArgs,\n         const ConstraintSatisfaction *Satisfaction);\n\n  static ConceptSpecializationExpr *\n  Create(const ASTContext &C, ConceptDecl *NamedConcept,\n         ArrayRef<TemplateArgument> ConvertedArgs,\n         const ConstraintSatisfaction *Satisfaction,\n         bool Dependent,\n         bool ContainsUnexpandedParameterPack);\n\n  static ConceptSpecializationExpr *\n  Create(ASTContext &C, EmptyShell Empty, unsigned NumTemplateArgs);\n\n  ArrayRef<TemplateArgument> getTemplateArguments() const {\n    return ArrayRef<TemplateArgument>(getTrailingObjects<TemplateArgument>(),\n                                      NumTemplateArgs);\n  }\n\n  /// \\brief Set new template arguments for this concept specialization.\n  void setTemplateArguments(ArrayRef<TemplateArgument> Converted);\n\n  /// \\brief Whether or not the concept with the given arguments was satisfied\n  /// when the expression was created.\n  /// The expression must not be dependent.\n  bool isSatisfied() const {\n    assert(!isValueDependent()\n           && \"isSatisfied called on a dependent ConceptSpecializationExpr\");\n    return Satisfaction->IsSatisfied;\n  }\n\n  /// \\brief Get elaborated satisfaction info about the template arguments'\n  /// satisfaction of the named concept.\n  /// The expression must not be dependent.\n  const ASTConstraintSatisfaction &getSatisfaction() const {\n    assert(!isValueDependent()\n           && \"getSatisfaction called on dependent ConceptSpecializationExpr\");\n    return *Satisfaction;\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ConceptSpecializationExprClass;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return ConceptName.getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    // If the ConceptSpecializationExpr is the ImmediatelyDeclaredConstraint\n    // of a TypeConstraint written syntactically as a constrained-parameter,\n    // there may not be a template argument list.\n    return ArgsAsWritten->RAngleLoc.isValid() ? ArgsAsWritten->RAngleLoc\n                                              : ConceptName.getEndLoc();\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\nnamespace concepts {\n\n/// \\brief A static requirement that can be used in a requires-expression to\n/// check properties of types and expression.\nclass Requirement {\npublic:\n  // Note - simple and compound requirements are both represented by the same\n  // class (ExprRequirement).\n  enum RequirementKind { RK_Type, RK_Simple, RK_Compound, RK_Nested };\nprivate:\n  const RequirementKind Kind;\n  // FIXME: use RequirementDependence to model dependence?\n  bool Dependent : 1;\n  bool ContainsUnexpandedParameterPack : 1;\n  bool Satisfied : 1;\npublic:\n  struct SubstitutionDiagnostic {\n    StringRef SubstitutedEntity;\n    // FIXME: Store diagnostics semantically and not as prerendered strings.\n    //  Fixing this probably requires serialization of PartialDiagnostic\n    //  objects.\n    SourceLocation DiagLoc;\n    StringRef DiagMessage;\n  };\n\n  Requirement(RequirementKind Kind, bool IsDependent,\n              bool ContainsUnexpandedParameterPack, bool IsSatisfied = true) :\n      Kind(Kind), Dependent(IsDependent),\n      ContainsUnexpandedParameterPack(ContainsUnexpandedParameterPack),\n      Satisfied(IsSatisfied) {}\n\n  RequirementKind getKind() const { return Kind; }\n\n  bool isSatisfied() const {\n    assert(!Dependent &&\n           \"isSatisfied can only be called on non-dependent requirements.\");\n    return Satisfied;\n  }\n\n  void setSatisfied(bool IsSatisfied) {\n    assert(!Dependent &&\n           \"setSatisfied can only be called on non-dependent requirements.\");\n    Satisfied = IsSatisfied;\n  }\n\n  void setDependent(bool IsDependent) { Dependent = IsDependent; }\n  bool isDependent() const { return Dependent; }\n\n  void setContainsUnexpandedParameterPack(bool Contains) {\n    ContainsUnexpandedParameterPack = Contains;\n  }\n  bool containsUnexpandedParameterPack() const {\n    return ContainsUnexpandedParameterPack;\n  }\n};\n\n/// \\brief A requires-expression requirement which queries the existence of a\n/// type name or type template specialization ('type' requirements).\nclass TypeRequirement : public Requirement {\npublic:\n  enum SatisfactionStatus {\n      SS_Dependent,\n      SS_SubstitutionFailure,\n      SS_Satisfied\n  };\nprivate:\n  llvm::PointerUnion<SubstitutionDiagnostic *, TypeSourceInfo *> Value;\n  SatisfactionStatus Status;\npublic:\n  friend ASTStmtReader;\n  friend ASTStmtWriter;\n\n  /// \\brief Construct a type requirement from a type. If the given type is not\n  /// dependent, this indicates that the type exists and the requirement will be\n  /// satisfied. Otherwise, the SubstitutionDiagnostic constructor is to be\n  /// used.\n  TypeRequirement(TypeSourceInfo *T);\n\n  /// \\brief Construct a type requirement when the nested name specifier is\n  /// invalid due to a bad substitution. The requirement is unsatisfied.\n  TypeRequirement(SubstitutionDiagnostic *Diagnostic) :\n      Requirement(RK_Type, false, false, false), Value(Diagnostic),\n      Status(SS_SubstitutionFailure) {}\n\n  SatisfactionStatus getSatisfactionStatus() const { return Status; }\n  void setSatisfactionStatus(SatisfactionStatus Status) {\n    this->Status = Status;\n  }\n\n  bool isSubstitutionFailure() const {\n    return Status == SS_SubstitutionFailure;\n  }\n\n  SubstitutionDiagnostic *getSubstitutionDiagnostic() const {\n    assert(Status == SS_SubstitutionFailure &&\n           \"Attempted to get substitution diagnostic when there has been no \"\n           \"substitution failure.\");\n    return Value.get<SubstitutionDiagnostic *>();\n  }\n\n  TypeSourceInfo *getType() const {\n    assert(!isSubstitutionFailure() &&\n           \"Attempted to get type when there has been a substitution failure.\");\n    return Value.get<TypeSourceInfo *>();\n  }\n\n  static bool classof(const Requirement *R) {\n    return R->getKind() == RK_Type;\n  }\n};\n\n/// \\brief A requires-expression requirement which queries the validity and\n/// properties of an expression ('simple' and 'compound' requirements).\nclass ExprRequirement : public Requirement {\npublic:\n  enum SatisfactionStatus {\n      SS_Dependent,\n      SS_ExprSubstitutionFailure,\n      SS_NoexceptNotMet,\n      SS_TypeRequirementSubstitutionFailure,\n      SS_ConstraintsNotSatisfied,\n      SS_Satisfied\n  };\n  class ReturnTypeRequirement {\n      llvm::PointerIntPair<\n          llvm::PointerUnion<TemplateParameterList *, SubstitutionDiagnostic *>,\n          1, bool>\n          TypeConstraintInfo;\n  public:\n      friend ASTStmtReader;\n      friend ASTStmtWriter;\n\n      /// \\brief No return type requirement was specified.\n      ReturnTypeRequirement() : TypeConstraintInfo(nullptr, 0) {}\n\n      /// \\brief A return type requirement was specified but it was a\n      /// substitution failure.\n      ReturnTypeRequirement(SubstitutionDiagnostic *SubstDiag) :\n          TypeConstraintInfo(SubstDiag, 0) {}\n\n      /// \\brief A 'type constraint' style return type requirement.\n      /// \\param TPL an invented template parameter list containing a single\n      /// type parameter with a type-constraint.\n      // TODO: Can we maybe not save the whole template parameter list and just\n      //  the type constraint? Saving the whole TPL makes it easier to handle in\n      //  serialization but is less elegant.\n      ReturnTypeRequirement(TemplateParameterList *TPL);\n\n      bool isDependent() const {\n        return TypeConstraintInfo.getInt();\n      }\n\n      bool containsUnexpandedParameterPack() const {\n        if (!isTypeConstraint())\n          return false;\n        return getTypeConstraintTemplateParameterList()\n                ->containsUnexpandedParameterPack();\n      }\n\n      bool isEmpty() const {\n        return TypeConstraintInfo.getPointer().isNull();\n      }\n\n      bool isSubstitutionFailure() const {\n        return !isEmpty() &&\n            TypeConstraintInfo.getPointer().is<SubstitutionDiagnostic *>();\n      }\n\n      bool isTypeConstraint() const {\n        return !isEmpty() &&\n            TypeConstraintInfo.getPointer().is<TemplateParameterList *>();\n      }\n\n      SubstitutionDiagnostic *getSubstitutionDiagnostic() const {\n        assert(isSubstitutionFailure());\n        return TypeConstraintInfo.getPointer().get<SubstitutionDiagnostic *>();\n      }\n\n      const TypeConstraint *getTypeConstraint() const;\n\n      TemplateParameterList *getTypeConstraintTemplateParameterList() const {\n        assert(isTypeConstraint());\n        return TypeConstraintInfo.getPointer().get<TemplateParameterList *>();\n      }\n  };\nprivate:\n  llvm::PointerUnion<Expr *, SubstitutionDiagnostic *> Value;\n  SourceLocation NoexceptLoc; // May be empty if noexcept wasn't specified.\n  ReturnTypeRequirement TypeReq;\n  ConceptSpecializationExpr *SubstitutedConstraintExpr;\n  SatisfactionStatus Status;\npublic:\n  friend ASTStmtReader;\n  friend ASTStmtWriter;\n\n  /// \\brief Construct a compound requirement.\n  /// \\param E the expression which is checked by this requirement.\n  /// \\param IsSimple whether this was a simple requirement in source.\n  /// \\param NoexceptLoc the location of the noexcept keyword, if it was\n  /// specified, otherwise an empty location.\n  /// \\param Req the requirement for the type of the checked expression.\n  /// \\param Status the satisfaction status of this requirement.\n  ExprRequirement(\n      Expr *E, bool IsSimple, SourceLocation NoexceptLoc,\n      ReturnTypeRequirement Req, SatisfactionStatus Status,\n      ConceptSpecializationExpr *SubstitutedConstraintExpr = nullptr);\n\n  /// \\brief Construct a compound requirement whose expression was a\n  /// substitution failure. The requirement is not satisfied.\n  /// \\param E the diagnostic emitted while instantiating the original\n  /// expression.\n  /// \\param IsSimple whether this was a simple requirement in source.\n  /// \\param NoexceptLoc the location of the noexcept keyword, if it was\n  /// specified, otherwise an empty location.\n  /// \\param Req the requirement for the type of the checked expression (omit\n  /// if no requirement was specified).\n  ExprRequirement(SubstitutionDiagnostic *E, bool IsSimple,\n                  SourceLocation NoexceptLoc, ReturnTypeRequirement Req = {});\n\n  bool isSimple() const { return getKind() == RK_Simple; }\n  bool isCompound() const { return getKind() == RK_Compound; }\n\n  bool hasNoexceptRequirement() const { return NoexceptLoc.isValid(); }\n  SourceLocation getNoexceptLoc() const { return NoexceptLoc; }\n\n  SatisfactionStatus getSatisfactionStatus() const { return Status; }\n\n  bool isExprSubstitutionFailure() const {\n    return Status == SS_ExprSubstitutionFailure;\n  }\n\n  const ReturnTypeRequirement &getReturnTypeRequirement() const {\n    return TypeReq;\n  }\n\n  ConceptSpecializationExpr *\n  getReturnTypeRequirementSubstitutedConstraintExpr() const {\n    assert(Status >= SS_TypeRequirementSubstitutionFailure);\n    return SubstitutedConstraintExpr;\n  }\n\n  SubstitutionDiagnostic *getExprSubstitutionDiagnostic() const {\n    assert(isExprSubstitutionFailure() &&\n           \"Attempted to get expression substitution diagnostic when there has \"\n           \"been no expression substitution failure\");\n    return Value.get<SubstitutionDiagnostic *>();\n  }\n\n  Expr *getExpr() const {\n    assert(!isExprSubstitutionFailure() &&\n           \"ExprRequirement has no expression because there has been a \"\n           \"substitution failure.\");\n    return Value.get<Expr *>();\n  }\n\n  static bool classof(const Requirement *R) {\n    return R->getKind() == RK_Compound || R->getKind() == RK_Simple;\n  }\n};\n\n/// \\brief A requires-expression requirement which is satisfied when a general\n/// constraint expression is satisfied ('nested' requirements).\nclass NestedRequirement : public Requirement {\n  llvm::PointerUnion<Expr *, SubstitutionDiagnostic *> Value;\n  const ASTConstraintSatisfaction *Satisfaction = nullptr;\n\npublic:\n  friend ASTStmtReader;\n  friend ASTStmtWriter;\n\n  NestedRequirement(SubstitutionDiagnostic *SubstDiag) :\n      Requirement(RK_Nested, /*Dependent=*/false,\n                  /*ContainsUnexpandedParameterPack*/false,\n                  /*Satisfied=*/false), Value(SubstDiag) {}\n\n  NestedRequirement(Expr *Constraint) :\n      Requirement(RK_Nested, /*Dependent=*/true,\n                  Constraint->containsUnexpandedParameterPack()),\n      Value(Constraint) {\n    assert(Constraint->isInstantiationDependent() &&\n           \"Nested requirement with non-dependent constraint must be \"\n           \"constructed with a ConstraintSatisfaction object\");\n  }\n\n  NestedRequirement(ASTContext &C, Expr *Constraint,\n                    const ConstraintSatisfaction &Satisfaction) :\n      Requirement(RK_Nested, Constraint->isInstantiationDependent(),\n                  Constraint->containsUnexpandedParameterPack(),\n                  Satisfaction.IsSatisfied),\n      Value(Constraint),\n      Satisfaction(ASTConstraintSatisfaction::Create(C, Satisfaction)) {}\n\n  bool isSubstitutionFailure() const {\n    return Value.is<SubstitutionDiagnostic *>();\n  }\n\n  SubstitutionDiagnostic *getSubstitutionDiagnostic() const {\n    assert(isSubstitutionFailure() &&\n           \"getSubstitutionDiagnostic() may not be called when there was no \"\n           \"substitution failure.\");\n    return Value.get<SubstitutionDiagnostic *>();\n  }\n\n  Expr *getConstraintExpr() const {\n    assert(!isSubstitutionFailure() && \"getConstraintExpr() may not be called \"\n                                       \"on nested requirements with \"\n                                       \"substitution failures.\");\n    return Value.get<Expr *>();\n  }\n\n  const ASTConstraintSatisfaction &getConstraintSatisfaction() const {\n    assert(!isSubstitutionFailure() && \"getConstraintSatisfaction() may not be \"\n                                       \"called on nested requirements with \"\n                                       \"substitution failures.\");\n    return *Satisfaction;\n  }\n\n  static bool classof(const Requirement *R) {\n    return R->getKind() == RK_Nested;\n  }\n};\n\n} // namespace concepts\n\n/// C++2a [expr.prim.req]:\n///     A requires-expression provides a concise way to express requirements on\n///     template arguments. A requirement is one that can be checked by name\n///     lookup (6.4) or by checking properties of types and expressions.\n///     [...]\n///     A requires-expression is a prvalue of type bool [...]\nclass RequiresExpr final : public Expr,\n    llvm::TrailingObjects<RequiresExpr, ParmVarDecl *,\n                          concepts::Requirement *> {\n  friend TrailingObjects;\n  friend class ASTStmtReader;\n\n  unsigned NumLocalParameters;\n  unsigned NumRequirements;\n  RequiresExprBodyDecl *Body;\n  SourceLocation RBraceLoc;\n\n  unsigned numTrailingObjects(OverloadToken<ParmVarDecl *>) const {\n    return NumLocalParameters;\n  }\n\n  unsigned numTrailingObjects(OverloadToken<concepts::Requirement *>) const {\n    return NumRequirements;\n  }\n\n  RequiresExpr(ASTContext &C, SourceLocation RequiresKWLoc,\n               RequiresExprBodyDecl *Body,\n               ArrayRef<ParmVarDecl *> LocalParameters,\n               ArrayRef<concepts::Requirement *> Requirements,\n               SourceLocation RBraceLoc);\n  RequiresExpr(ASTContext &C, EmptyShell Empty, unsigned NumLocalParameters,\n               unsigned NumRequirements);\n\npublic:\n  static RequiresExpr *\n  Create(ASTContext &C, SourceLocation RequiresKWLoc,\n         RequiresExprBodyDecl *Body, ArrayRef<ParmVarDecl *> LocalParameters,\n         ArrayRef<concepts::Requirement *> Requirements,\n         SourceLocation RBraceLoc);\n  static RequiresExpr *\n  Create(ASTContext &C, EmptyShell Empty, unsigned NumLocalParameters,\n         unsigned NumRequirements);\n\n  ArrayRef<ParmVarDecl *> getLocalParameters() const {\n    return {getTrailingObjects<ParmVarDecl *>(), NumLocalParameters};\n  }\n\n  RequiresExprBodyDecl *getBody() const { return Body; }\n\n  ArrayRef<concepts::Requirement *> getRequirements() const {\n    return {getTrailingObjects<concepts::Requirement *>(), NumRequirements};\n  }\n\n  /// \\brief Whether or not the requires clause is satisfied.\n  /// The expression must not be dependent.\n  bool isSatisfied() const {\n    assert(!isValueDependent()\n           && \"isSatisfied called on a dependent RequiresExpr\");\n    return RequiresExprBits.IsSatisfied;\n  }\n\n  SourceLocation getRequiresKWLoc() const {\n    return RequiresExprBits.RequiresKWLoc;\n  }\n\n  SourceLocation getRBraceLoc() const { return RBraceLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == RequiresExprClass;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return RequiresExprBits.RequiresKWLoc;\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return RBraceLoc;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_EXPRCONCEPTS_H\n"}, "18": {"id": 18, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprOpenMP.h", "content": "//===--- ExprOpenMP.h - Classes for representing expressions ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the Expr interface and subclasses.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_EXPROPENMP_H\n#define LLVM_CLANG_AST_EXPROPENMP_H\n\n#include \"clang/AST/ComputeDependence.h\"\n#include \"clang/AST/Expr.h\"\n\nnamespace clang {\n/// OpenMP 5.0 [2.1.5, Array Sections].\n/// To specify an array section in an OpenMP construct, array subscript\n/// expressions are extended with the following syntax:\n/// \\code\n/// [ lower-bound : length : stride ]\n/// [ lower-bound : length : ]\n/// [ lower-bound : length ]\n/// [ lower-bound : : stride ]\n/// [ lower-bound : : ]\n/// [ lower-bound : ]\n/// [ : length : stride ]\n/// [ : length : ]\n/// [ : length ]\n/// [ : : stride ]\n/// [ : : ]\n/// [ : ]\n/// \\endcode\n/// The array section must be a subset of the original array.\n/// Array sections are allowed on multidimensional arrays. Base language array\n/// subscript expressions can be used to specify length-one dimensions of\n/// multidimensional array sections.\n/// Each of the lower-bound, length, and stride expressions if specified must be\n/// an integral type expressions of the base language. When evaluated\n/// they represent a set of integer values as follows:\n/// \\code\n/// { lower-bound, lower-bound + stride, lower-bound + 2 * stride,... ,\n/// lower-bound + ((length - 1) * stride) }\n/// \\endcode\n/// The lower-bound and length must evaluate to non-negative integers.\n/// The stride must evaluate to a positive integer.\n/// When the size of the array dimension is not known, the length must be\n/// specified explicitly.\n/// When the stride is absent it defaults to 1.\n/// When the length is absent it defaults to \u2308(size \u2212 lower-bound)/stride\u2309,\n/// where size is the size of the array dimension. When the lower-bound is\n/// absent it defaults to 0.\nclass OMPArraySectionExpr : public Expr {\n  enum { BASE, LOWER_BOUND, LENGTH, STRIDE, END_EXPR };\n  Stmt *SubExprs[END_EXPR];\n  SourceLocation ColonLocFirst;\n  SourceLocation ColonLocSecond;\n  SourceLocation RBracketLoc;\n\npublic:\n  OMPArraySectionExpr(Expr *Base, Expr *LowerBound, Expr *Length, Expr *Stride,\n                      QualType Type, ExprValueKind VK, ExprObjectKind OK,\n                      SourceLocation ColonLocFirst,\n                      SourceLocation ColonLocSecond, SourceLocation RBracketLoc)\n      : Expr(OMPArraySectionExprClass, Type, VK, OK),\n        ColonLocFirst(ColonLocFirst), ColonLocSecond(ColonLocSecond),\n        RBracketLoc(RBracketLoc) {\n    SubExprs[BASE] = Base;\n    SubExprs[LOWER_BOUND] = LowerBound;\n    SubExprs[LENGTH] = Length;\n    SubExprs[STRIDE] = Stride;\n    setDependence(computeDependence(this));\n  }\n\n  /// Create an empty array section expression.\n  explicit OMPArraySectionExpr(EmptyShell Shell)\n      : Expr(OMPArraySectionExprClass, Shell) {}\n\n  /// An array section can be written only as Base[LowerBound:Length].\n\n  /// Get base of the array section.\n  Expr *getBase() { return cast<Expr>(SubExprs[BASE]); }\n  const Expr *getBase() const { return cast<Expr>(SubExprs[BASE]); }\n  /// Set base of the array section.\n  void setBase(Expr *E) { SubExprs[BASE] = E; }\n\n  /// Return original type of the base expression for array section.\n  static QualType getBaseOriginalType(const Expr *Base);\n\n  /// Get lower bound of array section.\n  Expr *getLowerBound() { return cast_or_null<Expr>(SubExprs[LOWER_BOUND]); }\n  const Expr *getLowerBound() const {\n    return cast_or_null<Expr>(SubExprs[LOWER_BOUND]);\n  }\n  /// Set lower bound of the array section.\n  void setLowerBound(Expr *E) { SubExprs[LOWER_BOUND] = E; }\n\n  /// Get length of array section.\n  Expr *getLength() { return cast_or_null<Expr>(SubExprs[LENGTH]); }\n  const Expr *getLength() const { return cast_or_null<Expr>(SubExprs[LENGTH]); }\n  /// Set length of the array section.\n  void setLength(Expr *E) { SubExprs[LENGTH] = E; }\n\n  /// Get stride of array section.\n  Expr *getStride() { return cast_or_null<Expr>(SubExprs[STRIDE]); }\n  const Expr *getStride() const { return cast_or_null<Expr>(SubExprs[STRIDE]); }\n  /// Set length of the array section.\n  void setStride(Expr *E) { SubExprs[STRIDE] = E; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getBase()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RBracketLoc; }\n\n  SourceLocation getColonLocFirst() const { return ColonLocFirst; }\n  void setColonLocFirst(SourceLocation L) { ColonLocFirst = L; }\n\n  SourceLocation getColonLocSecond() const { return ColonLocSecond; }\n  void setColonLocSecond(SourceLocation L) { ColonLocSecond = L; }\n\n  SourceLocation getRBracketLoc() const { return RBracketLoc; }\n  void setRBracketLoc(SourceLocation L) { RBracketLoc = L; }\n\n  SourceLocation getExprLoc() const LLVM_READONLY {\n    return getBase()->getExprLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPArraySectionExprClass;\n  }\n\n  child_range children() {\n    return child_range(&SubExprs[BASE], &SubExprs[END_EXPR]);\n  }\n\n  const_child_range children() const {\n    return const_child_range(&SubExprs[BASE], &SubExprs[END_EXPR]);\n  }\n};\n\n/// An explicit cast in C or a C-style cast in C++, which uses the syntax\n/// ([s1][s2]...[sn])expr. For example: @c ([3][3])f.\nclass OMPArrayShapingExpr final\n    : public Expr,\n      private llvm::TrailingObjects<OMPArrayShapingExpr, Expr *, SourceRange> {\n  friend TrailingObjects;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  /// Base node.\n  SourceLocation LPLoc; /// The location of the left paren\n  SourceLocation RPLoc; /// The location of the right paren\n  unsigned NumDims = 0; /// Number of dimensions in the shaping expression.\n\n  /// Construct full expression.\n  OMPArrayShapingExpr(QualType ExprTy, Expr *Op, SourceLocation L,\n                      SourceLocation R, ArrayRef<Expr *> Dims);\n\n  /// Construct an empty expression.\n  explicit OMPArrayShapingExpr(EmptyShell Shell, unsigned NumDims)\n      : Expr(OMPArrayShapingExprClass, Shell), NumDims(NumDims) {}\n\n  /// Sets the dimensions for the array shaping.\n  void setDimensions(ArrayRef<Expr *> Dims);\n\n  /// Sets the base expression for array shaping operation.\n  void setBase(Expr *Op) { getTrailingObjects<Expr *>()[NumDims] = Op; }\n\n  /// Sets source ranges for the brackets in the array shaping operation.\n  void setBracketsRanges(ArrayRef<SourceRange> BR);\n\n  unsigned numTrailingObjects(OverloadToken<Expr *>) const {\n    // Add an extra one for the base expression.\n    return NumDims + 1;\n  }\n\n  unsigned numTrailingObjects(OverloadToken<SourceRange>) const {\n    return NumDims;\n  }\n\npublic:\n  static OMPArrayShapingExpr *Create(const ASTContext &Context, QualType T,\n                                     Expr *Op, SourceLocation L,\n                                     SourceLocation R, ArrayRef<Expr *> Dims,\n                                     ArrayRef<SourceRange> BracketRanges);\n\n  static OMPArrayShapingExpr *CreateEmpty(const ASTContext &Context,\n                                          unsigned NumDims);\n\n  SourceLocation getLParenLoc() const { return LPLoc; }\n  void setLParenLoc(SourceLocation L) { LPLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RPLoc; }\n  void setRParenLoc(SourceLocation L) { RPLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return LPLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getBase()->getEndLoc();\n  }\n\n  /// Fetches the dimensions for array shaping expression.\n  ArrayRef<Expr *> getDimensions() const {\n    return llvm::makeArrayRef(getTrailingObjects<Expr *>(), NumDims);\n  }\n\n  /// Fetches source ranges for the brackets os the array shaping expression.\n  ArrayRef<SourceRange> getBracketsRanges() const {\n    return llvm::makeArrayRef(getTrailingObjects<SourceRange>(), NumDims);\n  }\n\n  /// Fetches base expression of array shaping expression.\n  Expr *getBase() { return getTrailingObjects<Expr *>()[NumDims]; }\n  const Expr *getBase() const { return getTrailingObjects<Expr *>()[NumDims]; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPArrayShapingExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    Stmt **Begin = reinterpret_cast<Stmt **>(getTrailingObjects<Expr *>());\n    return child_range(Begin, Begin + NumDims + 1);\n  }\n  const_child_range children() const {\n    Stmt *const *Begin =\n        reinterpret_cast<Stmt *const *>(getTrailingObjects<Expr *>());\n    return const_child_range(Begin, Begin + NumDims + 1);\n  }\n};\n\n/// Helper expressions and declaration for OMPIteratorExpr class for each\n/// iteration space.\nstruct OMPIteratorHelperData {\n  /// Internal normalized counter.\n  VarDecl *CounterVD = nullptr;\n  /// Normalized upper bound. Normalized loop iterates from 0 to Upper with\n  /// step 1.\n  Expr *Upper = nullptr;\n  /// Update expression for the originally specified iteration variable,\n  /// calculated as VD = Begin + CounterVD * Step;\n  Expr *Update = nullptr;\n  /// Updater for the internal counter: ++CounterVD;\n  Expr *CounterUpdate = nullptr;\n};\n\n/// OpenMP 5.0 [2.1.6 Iterators]\n/// Iterators are identifiers that expand to multiple values in the clause on\n/// which they appear.\n/// The syntax of the iterator modifier is as follows:\n/// \\code\n/// iterator(iterators-definition)\n/// \\endcode\n/// where iterators-definition is one of the following:\n/// \\code\n/// iterator-specifier [, iterators-definition ]\n/// \\endcode\n/// where iterator-specifier is one of the following:\n/// \\code\n/// [ iterator-type ] identifier = range-specification\n/// \\endcode\n/// where identifier is a base language identifier.\n/// iterator-type is a type name.\n/// range-specification is of the form begin:end[:step], where begin and end are\n/// expressions for which their types can be converted to iterator-type and step\n/// is an integral expression.\n/// In an iterator-specifier, if the iterator-type is not specified then the\n/// type of that iterator is of int type.\n/// The iterator-type must be an integral or pointer type.\n/// The iterator-type must not be const qualified.\nclass OMPIteratorExpr final\n    : public Expr,\n      private llvm::TrailingObjects<OMPIteratorExpr, Decl *, Expr *,\n                                    SourceLocation, OMPIteratorHelperData> {\npublic:\n  /// Iterator range representation begin:end[:step].\n  struct IteratorRange {\n    Expr *Begin = nullptr;\n    Expr *End = nullptr;\n    Expr *Step = nullptr;\n  };\n  /// Iterator definition representation.\n  struct IteratorDefinition {\n    Decl *IteratorDecl = nullptr;\n    IteratorRange Range;\n    SourceLocation AssignmentLoc;\n    SourceLocation ColonLoc, SecondColonLoc;\n  };\n\nprivate:\n  friend TrailingObjects;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  /// Offset in the list of expressions for subelements of the ranges.\n  enum class RangeExprOffset {\n    Begin = 0,\n    End = 1,\n    Step = 2,\n    Total = 3,\n  };\n  /// Offset in the list of locations for subelements of colon symbols\n  /// locations.\n  enum class RangeLocOffset {\n    AssignLoc = 0,\n    FirstColonLoc = 1,\n    SecondColonLoc = 2,\n    Total = 3,\n  };\n  /// Location of 'iterator' keyword.\n  SourceLocation IteratorKwLoc;\n  /// Location of '('.\n  SourceLocation LPLoc;\n  /// Location of ')'.\n  SourceLocation RPLoc;\n  /// Number of iterator definitions.\n  unsigned NumIterators = 0;\n\n  OMPIteratorExpr(QualType ExprTy, SourceLocation IteratorKwLoc,\n                  SourceLocation L, SourceLocation R,\n                  ArrayRef<IteratorDefinition> Data,\n                  ArrayRef<OMPIteratorHelperData> Helpers);\n\n  /// Construct an empty expression.\n  explicit OMPIteratorExpr(EmptyShell Shell, unsigned NumIterators)\n      : Expr(OMPIteratorExprClass, Shell), NumIterators(NumIterators) {}\n\n  /// Sets basic declaration for the specified iterator definition.\n  void setIteratorDeclaration(unsigned I, Decl *D);\n\n  /// Sets the location of the assignment symbol for the specified iterator\n  /// definition.\n  void setAssignmentLoc(unsigned I, SourceLocation Loc);\n\n  /// Sets begin, end and optional step expressions for specified iterator\n  /// definition.\n  void setIteratorRange(unsigned I, Expr *Begin, SourceLocation ColonLoc,\n                        Expr *End, SourceLocation SecondColonLoc, Expr *Step);\n\n  /// Sets helpers for the specified iteration space.\n  void setHelper(unsigned I, const OMPIteratorHelperData &D);\n\n  unsigned numTrailingObjects(OverloadToken<Decl *>) const {\n    return NumIterators;\n  }\n\n  unsigned numTrailingObjects(OverloadToken<Expr *>) const {\n    return NumIterators * static_cast<int>(RangeExprOffset::Total);\n  }\n\n  unsigned numTrailingObjects(OverloadToken<SourceLocation>) const {\n    return NumIterators * static_cast<int>(RangeLocOffset::Total);\n  }\n\npublic:\n  static OMPIteratorExpr *Create(const ASTContext &Context, QualType T,\n                                 SourceLocation IteratorKwLoc, SourceLocation L,\n                                 SourceLocation R,\n                                 ArrayRef<IteratorDefinition> Data,\n                                 ArrayRef<OMPIteratorHelperData> Helpers);\n\n  static OMPIteratorExpr *CreateEmpty(const ASTContext &Context,\n                                      unsigned NumIterators);\n\n  SourceLocation getLParenLoc() const { return LPLoc; }\n  void setLParenLoc(SourceLocation L) { LPLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RPLoc; }\n  void setRParenLoc(SourceLocation L) { RPLoc = L; }\n\n  SourceLocation getIteratorKwLoc() const { return IteratorKwLoc; }\n  void setIteratorKwLoc(SourceLocation L) { IteratorKwLoc = L; }\n  SourceLocation getBeginLoc() const LLVM_READONLY { return IteratorKwLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RPLoc; }\n\n  /// Gets the iterator declaration for the given iterator.\n  Decl *getIteratorDecl(unsigned I);\n  const Decl *getIteratorDecl(unsigned I) const {\n    return const_cast<OMPIteratorExpr *>(this)->getIteratorDecl(I);\n  }\n\n  /// Gets the iterator range for the given iterator.\n  IteratorRange getIteratorRange(unsigned I);\n  const IteratorRange getIteratorRange(unsigned I) const {\n    return const_cast<OMPIteratorExpr *>(this)->getIteratorRange(I);\n  }\n\n  /// Gets the location of '=' for the given iterator definition.\n  SourceLocation getAssignLoc(unsigned I) const;\n  /// Gets the location of the first ':' in the range for the given iterator\n  /// definition.\n  SourceLocation getColonLoc(unsigned I) const;\n  /// Gets the location of the second ':' (if any) in the range for the given\n  /// iteratori definition.\n  SourceLocation getSecondColonLoc(unsigned I) const;\n\n  /// Returns number of iterator definitions.\n  unsigned numOfIterators() const { return NumIterators; }\n\n  /// Fetches helper data for the specified iteration space.\n  OMPIteratorHelperData &getHelper(unsigned I);\n  const OMPIteratorHelperData &getHelper(unsigned I) const;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPIteratorExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    Stmt **Begin = reinterpret_cast<Stmt **>(getTrailingObjects<Expr *>());\n    return child_range(\n        Begin, Begin + NumIterators * static_cast<int>(RangeExprOffset::Total));\n  }\n  const_child_range children() const {\n    Stmt *const *Begin =\n        reinterpret_cast<Stmt *const *>(getTrailingObjects<Expr *>());\n    return const_child_range(\n        Begin, Begin + NumIterators * static_cast<int>(RangeExprOffset::Total));\n  }\n};\n\n} // end namespace clang\n\n#endif\n"}, "19": {"id": 19, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "content": "//===- OpenMPClause.h - Classes for OpenMP clauses --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// This file defines OpenMP AST classes for clauses.\n/// There are clauses for executable directives, clauses for declarative\n/// directives and clauses which can be used in both kinds of directives.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_OPENMPCLAUSE_H\n#define LLVM_CLANG_AST_OPENMPCLAUSE_H\n\n#include \"clang/AST/ASTFwd.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/StmtIterator.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/OpenMPKinds.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/MapVector.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Frontend/OpenMP/OMPConstants.h\"\n#include \"llvm/Frontend/OpenMP/OMPContext.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <utility>\n\nnamespace clang {\n\nclass ASTContext;\n\n//===----------------------------------------------------------------------===//\n// AST classes for clauses.\n//===----------------------------------------------------------------------===//\n\n/// This is a basic class for representing single OpenMP clause.\nclass OMPClause {\n  /// Starting location of the clause (the clause keyword).\n  SourceLocation StartLoc;\n\n  /// Ending location of the clause.\n  SourceLocation EndLoc;\n\n  /// Kind of the clause.\n  OpenMPClauseKind Kind;\n\nprotected:\n  OMPClause(OpenMPClauseKind K, SourceLocation StartLoc, SourceLocation EndLoc)\n      : StartLoc(StartLoc), EndLoc(EndLoc), Kind(K) {}\n\npublic:\n  /// Returns the starting location of the clause.\n  SourceLocation getBeginLoc() const { return StartLoc; }\n\n  /// Returns the ending location of the clause.\n  SourceLocation getEndLoc() const { return EndLoc; }\n\n  /// Sets the starting location of the clause.\n  void setLocStart(SourceLocation Loc) { StartLoc = Loc; }\n\n  /// Sets the ending location of the clause.\n  void setLocEnd(SourceLocation Loc) { EndLoc = Loc; }\n\n  /// Returns kind of OpenMP clause (private, shared, reduction, etc.).\n  OpenMPClauseKind getClauseKind() const { return Kind; }\n\n  bool isImplicit() const { return StartLoc.isInvalid(); }\n\n  using child_iterator = StmtIterator;\n  using const_child_iterator = ConstStmtIterator;\n  using child_range = llvm::iterator_range<child_iterator>;\n  using const_child_range = llvm::iterator_range<const_child_iterator>;\n\n  child_range children();\n  const_child_range children() const {\n    auto Children = const_cast<OMPClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  /// Get the iterator range for the expressions used in the clauses. Used\n  /// expressions include only the children that must be evaluated at the\n  /// runtime before entering the construct.\n  child_range used_children();\n  const_child_range used_children() const {\n    auto Children = const_cast<OMPClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  static bool classof(const OMPClause *) { return true; }\n};\n\n/// Class that handles pre-initialization statement for some clauses, like\n/// 'shedule', 'firstprivate' etc.\nclass OMPClauseWithPreInit {\n  friend class OMPClauseReader;\n\n  /// Pre-initialization statement for the clause.\n  Stmt *PreInit = nullptr;\n\n  /// Region that captures the associated stmt.\n  OpenMPDirectiveKind CaptureRegion = llvm::omp::OMPD_unknown;\n\nprotected:\n  OMPClauseWithPreInit(const OMPClause *This) {\n    assert(get(This) && \"get is not tuned for pre-init.\");\n  }\n\n  /// Set pre-initialization statement for the clause.\n  void\n  setPreInitStmt(Stmt *S,\n                 OpenMPDirectiveKind ThisRegion = llvm::omp::OMPD_unknown) {\n    PreInit = S;\n    CaptureRegion = ThisRegion;\n  }\n\npublic:\n  /// Get pre-initialization statement for the clause.\n  const Stmt *getPreInitStmt() const { return PreInit; }\n\n  /// Get pre-initialization statement for the clause.\n  Stmt *getPreInitStmt() { return PreInit; }\n\n  /// Get capture region for the stmt in the clause.\n  OpenMPDirectiveKind getCaptureRegion() const { return CaptureRegion; }\n\n  static OMPClauseWithPreInit *get(OMPClause *C);\n  static const OMPClauseWithPreInit *get(const OMPClause *C);\n};\n\n/// Class that handles post-update expression for some clauses, like\n/// 'lastprivate', 'reduction' etc.\nclass OMPClauseWithPostUpdate : public OMPClauseWithPreInit {\n  friend class OMPClauseReader;\n\n  /// Post-update expression for the clause.\n  Expr *PostUpdate = nullptr;\n\nprotected:\n  OMPClauseWithPostUpdate(const OMPClause *This) : OMPClauseWithPreInit(This) {\n    assert(get(This) && \"get is not tuned for post-update.\");\n  }\n\n  /// Set pre-initialization statement for the clause.\n  void setPostUpdateExpr(Expr *S) { PostUpdate = S; }\n\npublic:\n  /// Get post-update expression for the clause.\n  const Expr *getPostUpdateExpr() const { return PostUpdate; }\n\n  /// Get post-update expression for the clause.\n  Expr *getPostUpdateExpr() { return PostUpdate; }\n\n  static OMPClauseWithPostUpdate *get(OMPClause *C);\n  static const OMPClauseWithPostUpdate *get(const OMPClause *C);\n};\n\n/// This structure contains most locations needed for by an OMPVarListClause.\nstruct OMPVarListLocTy {\n  /// Starting location of the clause (the clause keyword).\n  SourceLocation StartLoc;\n  /// Location of '('.\n  SourceLocation LParenLoc;\n  /// Ending location of the clause.\n  SourceLocation EndLoc;\n  OMPVarListLocTy() = default;\n  OMPVarListLocTy(SourceLocation StartLoc, SourceLocation LParenLoc,\n                  SourceLocation EndLoc)\n      : StartLoc(StartLoc), LParenLoc(LParenLoc), EndLoc(EndLoc) {}\n};\n\n/// This represents clauses with the list of variables like 'private',\n/// 'firstprivate', 'copyin', 'shared', or 'reduction' clauses in the\n/// '#pragma omp ...' directives.\ntemplate <class T> class OMPVarListClause : public OMPClause {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Number of variables in the list.\n  unsigned NumVars;\n\nprotected:\n  /// Build a clause with \\a N variables\n  ///\n  /// \\param K Kind of the clause.\n  /// \\param StartLoc Starting location of the clause (the clause keyword).\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param N Number of the variables in the clause.\n  OMPVarListClause(OpenMPClauseKind K, SourceLocation StartLoc,\n                   SourceLocation LParenLoc, SourceLocation EndLoc, unsigned N)\n      : OMPClause(K, StartLoc, EndLoc), LParenLoc(LParenLoc), NumVars(N) {}\n\n  /// Fetches list of variables associated with this clause.\n  MutableArrayRef<Expr *> getVarRefs() {\n    return MutableArrayRef<Expr *>(\n        static_cast<T *>(this)->template getTrailingObjects<Expr *>(), NumVars);\n  }\n\n  /// Sets the list of variables for this clause.\n  void setVarRefs(ArrayRef<Expr *> VL) {\n    assert(VL.size() == NumVars &&\n           \"Number of variables is not the same as the preallocated buffer\");\n    std::copy(VL.begin(), VL.end(),\n              static_cast<T *>(this)->template getTrailingObjects<Expr *>());\n  }\n\npublic:\n  using varlist_iterator = MutableArrayRef<Expr *>::iterator;\n  using varlist_const_iterator = ArrayRef<const Expr *>::iterator;\n  using varlist_range = llvm::iterator_range<varlist_iterator>;\n  using varlist_const_range = llvm::iterator_range<varlist_const_iterator>;\n\n  unsigned varlist_size() const { return NumVars; }\n  bool varlist_empty() const { return NumVars == 0; }\n\n  varlist_range varlists() {\n    return varlist_range(varlist_begin(), varlist_end());\n  }\n  varlist_const_range varlists() const {\n    return varlist_const_range(varlist_begin(), varlist_end());\n  }\n\n  varlist_iterator varlist_begin() { return getVarRefs().begin(); }\n  varlist_iterator varlist_end() { return getVarRefs().end(); }\n  varlist_const_iterator varlist_begin() const { return getVarRefs().begin(); }\n  varlist_const_iterator varlist_end() const { return getVarRefs().end(); }\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Fetches list of all variables in the clause.\n  ArrayRef<const Expr *> getVarRefs() const {\n    return llvm::makeArrayRef(\n        static_cast<const T *>(this)->template getTrailingObjects<Expr *>(),\n        NumVars);\n  }\n};\n\n/// This represents 'allocator' clause in the '#pragma omp ...'\n/// directive.\n///\n/// \\code\n/// #pragma omp allocate(a) allocator(omp_default_mem_alloc)\n/// \\endcode\n/// In this example directive '#pragma omp allocate' has simple 'allocator'\n/// clause with the allocator 'omp_default_mem_alloc'.\nclass OMPAllocatorClause : public OMPClause {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Expression with the allocator.\n  Stmt *Allocator = nullptr;\n\n  /// Set allocator.\n  void setAllocator(Expr *A) { Allocator = A; }\n\npublic:\n  /// Build 'allocator' clause with the given allocator.\n  ///\n  /// \\param A Allocator.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  OMPAllocatorClause(Expr *A, SourceLocation StartLoc, SourceLocation LParenLoc,\n                     SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_allocator, StartLoc, EndLoc),\n        LParenLoc(LParenLoc), Allocator(A) {}\n\n  /// Build an empty clause.\n  OMPAllocatorClause()\n      : OMPClause(llvm::omp::OMPC_allocator, SourceLocation(),\n                  SourceLocation()) {}\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Returns allocator.\n  Expr *getAllocator() const { return cast_or_null<Expr>(Allocator); }\n\n  child_range children() { return child_range(&Allocator, &Allocator + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Allocator, &Allocator + 1);\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_allocator;\n  }\n};\n\n/// This represents clause 'allocate' in the '#pragma omp ...' directives.\n///\n/// \\code\n/// #pragma omp parallel private(a) allocate(omp_default_mem_alloc :a)\n/// \\endcode\n/// In this example directive '#pragma omp parallel' has clause 'private'\n/// and clause 'allocate' for the variable 'a'.\nclass OMPAllocateClause final\n    : public OMPVarListClause<OMPAllocateClause>,\n      private llvm::TrailingObjects<OMPAllocateClause, Expr *> {\n  friend class OMPClauseReader;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Allocator specified in the clause, or 'nullptr' if the default one is\n  /// used.\n  Expr *Allocator = nullptr;\n  /// Position of the ':' delimiter in the clause;\n  SourceLocation ColonLoc;\n\n  /// Build clause with number of variables \\a N.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param Allocator Allocator expression.\n  /// \\param ColonLoc Location of ':' delimiter.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param N Number of the variables in the clause.\n  OMPAllocateClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                    Expr *Allocator, SourceLocation ColonLoc,\n                    SourceLocation EndLoc, unsigned N)\n      : OMPVarListClause<OMPAllocateClause>(llvm::omp::OMPC_allocate, StartLoc,\n                                            LParenLoc, EndLoc, N),\n        Allocator(Allocator), ColonLoc(ColonLoc) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param N Number of variables.\n  explicit OMPAllocateClause(unsigned N)\n      : OMPVarListClause<OMPAllocateClause>(llvm::omp::OMPC_allocate,\n                                            SourceLocation(), SourceLocation(),\n                                            SourceLocation(), N) {}\n\n  /// Sets location of ':' symbol in clause.\n  void setColonLoc(SourceLocation CL) { ColonLoc = CL; }\n\n  void setAllocator(Expr *A) { Allocator = A; }\n\npublic:\n  /// Creates clause with a list of variables \\a VL.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param Allocator Allocator expression.\n  /// \\param ColonLoc Location of ':' delimiter.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param VL List of references to the variables.\n  static OMPAllocateClause *Create(const ASTContext &C, SourceLocation StartLoc,\n                                   SourceLocation LParenLoc, Expr *Allocator,\n                                   SourceLocation ColonLoc,\n                                   SourceLocation EndLoc, ArrayRef<Expr *> VL);\n\n  /// Returns the allocator expression or nullptr, if no allocator is specified.\n  Expr *getAllocator() const { return Allocator; }\n\n  /// Returns the location of the ':' delimiter.\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  /// Creates an empty clause with the place for \\a N variables.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of variables.\n  static OMPAllocateClause *CreateEmpty(const ASTContext &C, unsigned N);\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPAllocateClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_allocate;\n  }\n};\n\n/// This represents 'if' clause in the '#pragma omp ...' directive.\n///\n/// \\code\n/// #pragma omp parallel if(parallel:a > 5)\n/// \\endcode\n/// In this example directive '#pragma omp parallel' has simple 'if' clause with\n/// condition 'a > 5' and directive name modifier 'parallel'.\nclass OMPIfClause : public OMPClause, public OMPClauseWithPreInit {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Condition of the 'if' clause.\n  Stmt *Condition = nullptr;\n\n  /// Location of ':' (if any).\n  SourceLocation ColonLoc;\n\n  /// Directive name modifier for the clause.\n  OpenMPDirectiveKind NameModifier = llvm::omp::OMPD_unknown;\n\n  /// Name modifier location.\n  SourceLocation NameModifierLoc;\n\n  /// Set condition.\n  void setCondition(Expr *Cond) { Condition = Cond; }\n\n  /// Set directive name modifier for the clause.\n  void setNameModifier(OpenMPDirectiveKind NM) { NameModifier = NM; }\n\n  /// Set location of directive name modifier for the clause.\n  void setNameModifierLoc(SourceLocation Loc) { NameModifierLoc = Loc; }\n\n  /// Set location of ':'.\n  void setColonLoc(SourceLocation Loc) { ColonLoc = Loc; }\n\npublic:\n  /// Build 'if' clause with condition \\a Cond.\n  ///\n  /// \\param NameModifier [OpenMP 4.1] Directive name modifier of clause.\n  /// \\param Cond Condition of the clause.\n  /// \\param HelperCond Helper condition for the clause.\n  /// \\param CaptureRegion Innermost OpenMP region where expressions in this\n  /// clause must be captured.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param NameModifierLoc Location of directive name modifier.\n  /// \\param ColonLoc [OpenMP 4.1] Location of ':'.\n  /// \\param EndLoc Ending location of the clause.\n  OMPIfClause(OpenMPDirectiveKind NameModifier, Expr *Cond, Stmt *HelperCond,\n              OpenMPDirectiveKind CaptureRegion, SourceLocation StartLoc,\n              SourceLocation LParenLoc, SourceLocation NameModifierLoc,\n              SourceLocation ColonLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_if, StartLoc, EndLoc),\n        OMPClauseWithPreInit(this), LParenLoc(LParenLoc), Condition(Cond),\n        ColonLoc(ColonLoc), NameModifier(NameModifier),\n        NameModifierLoc(NameModifierLoc) {\n    setPreInitStmt(HelperCond, CaptureRegion);\n  }\n\n  /// Build an empty clause.\n  OMPIfClause()\n      : OMPClause(llvm::omp::OMPC_if, SourceLocation(), SourceLocation()),\n        OMPClauseWithPreInit(this) {}\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Return the location of ':'.\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  /// Returns condition.\n  Expr *getCondition() const { return cast_or_null<Expr>(Condition); }\n\n  /// Return directive name modifier associated with the clause.\n  OpenMPDirectiveKind getNameModifier() const { return NameModifier; }\n\n  /// Return the location of directive name modifier.\n  SourceLocation getNameModifierLoc() const { return NameModifierLoc; }\n\n  child_range children() { return child_range(&Condition, &Condition + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Condition, &Condition + 1);\n  }\n\n  child_range used_children();\n  const_child_range used_children() const {\n    auto Children = const_cast<OMPIfClause *>(this)->used_children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_if;\n  }\n};\n\n/// This represents 'final' clause in the '#pragma omp ...' directive.\n///\n/// \\code\n/// #pragma omp task final(a > 5)\n/// \\endcode\n/// In this example directive '#pragma omp task' has simple 'final'\n/// clause with condition 'a > 5'.\nclass OMPFinalClause : public OMPClause, public OMPClauseWithPreInit {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Condition of the 'if' clause.\n  Stmt *Condition = nullptr;\n\n  /// Set condition.\n  void setCondition(Expr *Cond) { Condition = Cond; }\n\npublic:\n  /// Build 'final' clause with condition \\a Cond.\n  ///\n  /// \\param Cond Condition of the clause.\n  /// \\param HelperCond Helper condition for the construct.\n  /// \\param CaptureRegion Innermost OpenMP region where expressions in this\n  /// clause must be captured.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  OMPFinalClause(Expr *Cond, Stmt *HelperCond,\n                 OpenMPDirectiveKind CaptureRegion, SourceLocation StartLoc,\n                 SourceLocation LParenLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_final, StartLoc, EndLoc),\n        OMPClauseWithPreInit(this), LParenLoc(LParenLoc), Condition(Cond) {\n    setPreInitStmt(HelperCond, CaptureRegion);\n  }\n\n  /// Build an empty clause.\n  OMPFinalClause()\n      : OMPClause(llvm::omp::OMPC_final, SourceLocation(), SourceLocation()),\n        OMPClauseWithPreInit(this) {}\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Returns condition.\n  Expr *getCondition() const { return cast_or_null<Expr>(Condition); }\n\n  child_range children() { return child_range(&Condition, &Condition + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Condition, &Condition + 1);\n  }\n\n  child_range used_children();\n  const_child_range used_children() const {\n    auto Children = const_cast<OMPFinalClause *>(this)->used_children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_final;\n  }\n};\n\n/// This represents 'num_threads' clause in the '#pragma omp ...'\n/// directive.\n///\n/// \\code\n/// #pragma omp parallel num_threads(6)\n/// \\endcode\n/// In this example directive '#pragma omp parallel' has simple 'num_threads'\n/// clause with number of threads '6'.\nclass OMPNumThreadsClause : public OMPClause, public OMPClauseWithPreInit {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Condition of the 'num_threads' clause.\n  Stmt *NumThreads = nullptr;\n\n  /// Set condition.\n  void setNumThreads(Expr *NThreads) { NumThreads = NThreads; }\n\npublic:\n  /// Build 'num_threads' clause with condition \\a NumThreads.\n  ///\n  /// \\param NumThreads Number of threads for the construct.\n  /// \\param HelperNumThreads Helper Number of threads for the construct.\n  /// \\param CaptureRegion Innermost OpenMP region where expressions in this\n  /// clause must be captured.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  OMPNumThreadsClause(Expr *NumThreads, Stmt *HelperNumThreads,\n                      OpenMPDirectiveKind CaptureRegion,\n                      SourceLocation StartLoc, SourceLocation LParenLoc,\n                      SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_num_threads, StartLoc, EndLoc),\n        OMPClauseWithPreInit(this), LParenLoc(LParenLoc),\n        NumThreads(NumThreads) {\n    setPreInitStmt(HelperNumThreads, CaptureRegion);\n  }\n\n  /// Build an empty clause.\n  OMPNumThreadsClause()\n      : OMPClause(llvm::omp::OMPC_num_threads, SourceLocation(),\n                  SourceLocation()),\n        OMPClauseWithPreInit(this) {}\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Returns number of threads.\n  Expr *getNumThreads() const { return cast_or_null<Expr>(NumThreads); }\n\n  child_range children() { return child_range(&NumThreads, &NumThreads + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&NumThreads, &NumThreads + 1);\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_num_threads;\n  }\n};\n\n/// This represents 'safelen' clause in the '#pragma omp ...'\n/// directive.\n///\n/// \\code\n/// #pragma omp simd safelen(4)\n/// \\endcode\n/// In this example directive '#pragma omp simd' has clause 'safelen'\n/// with single expression '4'.\n/// If the safelen clause is used then no two iterations executed\n/// concurrently with SIMD instructions can have a greater distance\n/// in the logical iteration space than its value. The parameter of\n/// the safelen clause must be a constant positive integer expression.\nclass OMPSafelenClause : public OMPClause {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Safe iteration space distance.\n  Stmt *Safelen = nullptr;\n\n  /// Set safelen.\n  void setSafelen(Expr *Len) { Safelen = Len; }\n\npublic:\n  /// Build 'safelen' clause.\n  ///\n  /// \\param Len Expression associated with this clause.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPSafelenClause(Expr *Len, SourceLocation StartLoc, SourceLocation LParenLoc,\n                   SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_safelen, StartLoc, EndLoc),\n        LParenLoc(LParenLoc), Safelen(Len) {}\n\n  /// Build an empty clause.\n  explicit OMPSafelenClause()\n      : OMPClause(llvm::omp::OMPC_safelen, SourceLocation(), SourceLocation()) {\n  }\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Return safe iteration space distance.\n  Expr *getSafelen() const { return cast_or_null<Expr>(Safelen); }\n\n  child_range children() { return child_range(&Safelen, &Safelen + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Safelen, &Safelen + 1);\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_safelen;\n  }\n};\n\n/// This represents 'simdlen' clause in the '#pragma omp ...'\n/// directive.\n///\n/// \\code\n/// #pragma omp simd simdlen(4)\n/// \\endcode\n/// In this example directive '#pragma omp simd' has clause 'simdlen'\n/// with single expression '4'.\n/// If the 'simdlen' clause is used then it specifies the preferred number of\n/// iterations to be executed concurrently. The parameter of the 'simdlen'\n/// clause must be a constant positive integer expression.\nclass OMPSimdlenClause : public OMPClause {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Safe iteration space distance.\n  Stmt *Simdlen = nullptr;\n\n  /// Set simdlen.\n  void setSimdlen(Expr *Len) { Simdlen = Len; }\n\npublic:\n  /// Build 'simdlen' clause.\n  ///\n  /// \\param Len Expression associated with this clause.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPSimdlenClause(Expr *Len, SourceLocation StartLoc, SourceLocation LParenLoc,\n                   SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_simdlen, StartLoc, EndLoc),\n        LParenLoc(LParenLoc), Simdlen(Len) {}\n\n  /// Build an empty clause.\n  explicit OMPSimdlenClause()\n      : OMPClause(llvm::omp::OMPC_simdlen, SourceLocation(), SourceLocation()) {\n  }\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Return safe iteration space distance.\n  Expr *getSimdlen() const { return cast_or_null<Expr>(Simdlen); }\n\n  child_range children() { return child_range(&Simdlen, &Simdlen + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Simdlen, &Simdlen + 1);\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_simdlen;\n  }\n};\n\n/// This represents the 'sizes' clause in the '#pragma omp tile' directive.\n///\n/// \\code\n/// #pragma omp tile sizes(5,5)\n/// for (int i = 0; i < 64; ++i)\n///   for (int j = 0; j < 64; ++j)\n/// \\endcode\nclass OMPSizesClause final\n    : public OMPClause,\n      private llvm::TrailingObjects<OMPSizesClause, Expr *> {\n  friend class OMPClauseReader;\n  friend class llvm::TrailingObjects<OMPSizesClause, Expr *>;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Number of tile sizes in the clause.\n  unsigned NumSizes;\n\n  /// Build an empty clause.\n  explicit OMPSizesClause(int NumSizes)\n      : OMPClause(llvm::omp::OMPC_sizes, SourceLocation(), SourceLocation()),\n        NumSizes(NumSizes) {}\n\npublic:\n  /// Build a 'sizes' AST node.\n  ///\n  /// \\param C         Context of the AST.\n  /// \\param StartLoc  Location of the 'sizes' identifier.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc    Location of ')'.\n  /// \\param Sizes     Content of the clause.\n  static OMPSizesClause *Create(const ASTContext &C, SourceLocation StartLoc,\n                                SourceLocation LParenLoc, SourceLocation EndLoc,\n                                ArrayRef<Expr *> Sizes);\n\n  /// Build an empty 'sizes' AST node for deserialization.\n  ///\n  /// \\param C     Context of the AST.\n  /// \\param NumSizes Number of items in the clause.\n  static OMPSizesClause *CreateEmpty(const ASTContext &C, unsigned NumSizes);\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Returns the number of list items.\n  unsigned getNumSizes() const { return NumSizes; }\n\n  /// Returns the tile size expressions.\n  MutableArrayRef<Expr *> getSizesRefs() {\n    return MutableArrayRef<Expr *>(static_cast<OMPSizesClause *>(this)\n                                       ->template getTrailingObjects<Expr *>(),\n                                   NumSizes);\n  }\n  ArrayRef<Expr *> getSizesRefs() const {\n    return ArrayRef<Expr *>(static_cast<const OMPSizesClause *>(this)\n                                ->template getTrailingObjects<Expr *>(),\n                            NumSizes);\n  }\n\n  /// Sets the tile size expressions.\n  void setSizesRefs(ArrayRef<Expr *> VL) {\n    assert(VL.size() == NumSizes);\n    std::copy(VL.begin(), VL.end(),\n              static_cast<OMPSizesClause *>(this)\n                  ->template getTrailingObjects<Expr *>());\n  }\n\n  child_range children() {\n    MutableArrayRef<Expr *> Sizes = getSizesRefs();\n    return child_range(reinterpret_cast<Stmt **>(Sizes.begin()),\n                       reinterpret_cast<Stmt **>(Sizes.end()));\n  }\n  const_child_range children() const {\n    ArrayRef<Expr *> Sizes = getSizesRefs();\n    return const_child_range(reinterpret_cast<Stmt *const *>(Sizes.begin()),\n                             reinterpret_cast<Stmt *const *>(Sizes.end()));\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_sizes;\n  }\n};\n\n/// This represents 'collapse' clause in the '#pragma omp ...'\n/// directive.\n///\n/// \\code\n/// #pragma omp simd collapse(3)\n/// \\endcode\n/// In this example directive '#pragma omp simd' has clause 'collapse'\n/// with single expression '3'.\n/// The parameter must be a constant positive integer expression, it specifies\n/// the number of nested loops that should be collapsed into a single iteration\n/// space.\nclass OMPCollapseClause : public OMPClause {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Number of for-loops.\n  Stmt *NumForLoops = nullptr;\n\n  /// Set the number of associated for-loops.\n  void setNumForLoops(Expr *Num) { NumForLoops = Num; }\n\npublic:\n  /// Build 'collapse' clause.\n  ///\n  /// \\param Num Expression associated with this clause.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  OMPCollapseClause(Expr *Num, SourceLocation StartLoc,\n                    SourceLocation LParenLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_collapse, StartLoc, EndLoc),\n        LParenLoc(LParenLoc), NumForLoops(Num) {}\n\n  /// Build an empty clause.\n  explicit OMPCollapseClause()\n      : OMPClause(llvm::omp::OMPC_collapse, SourceLocation(),\n                  SourceLocation()) {}\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Return the number of associated for-loops.\n  Expr *getNumForLoops() const { return cast_or_null<Expr>(NumForLoops); }\n\n  child_range children() { return child_range(&NumForLoops, &NumForLoops + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&NumForLoops, &NumForLoops + 1);\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_collapse;\n  }\n};\n\n/// This represents 'default' clause in the '#pragma omp ...' directive.\n///\n/// \\code\n/// #pragma omp parallel default(shared)\n/// \\endcode\n/// In this example directive '#pragma omp parallel' has simple 'default'\n/// clause with kind 'shared'.\nclass OMPDefaultClause : public OMPClause {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// A kind of the 'default' clause.\n  llvm::omp::DefaultKind Kind = llvm::omp::OMP_DEFAULT_unknown;\n\n  /// Start location of the kind in source code.\n  SourceLocation KindKwLoc;\n\n  /// Set kind of the clauses.\n  ///\n  /// \\param K Argument of clause.\n  void setDefaultKind(llvm::omp::DefaultKind K) { Kind = K; }\n\n  /// Set argument location.\n  ///\n  /// \\param KLoc Argument location.\n  void setDefaultKindKwLoc(SourceLocation KLoc) { KindKwLoc = KLoc; }\n\npublic:\n  /// Build 'default' clause with argument \\a A ('none' or 'shared').\n  ///\n  /// \\param A Argument of the clause ('none' or 'shared').\n  /// \\param ALoc Starting location of the argument.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  OMPDefaultClause(llvm::omp::DefaultKind A, SourceLocation ALoc,\n                   SourceLocation StartLoc, SourceLocation LParenLoc,\n                   SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_default, StartLoc, EndLoc),\n        LParenLoc(LParenLoc), Kind(A), KindKwLoc(ALoc) {}\n\n  /// Build an empty clause.\n  OMPDefaultClause()\n      : OMPClause(llvm::omp::OMPC_default, SourceLocation(), SourceLocation()) {\n  }\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Returns kind of the clause.\n  llvm::omp::DefaultKind getDefaultKind() const { return Kind; }\n\n  /// Returns location of clause kind.\n  SourceLocation getDefaultKindKwLoc() const { return KindKwLoc; }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_default;\n  }\n};\n\n/// This represents 'proc_bind' clause in the '#pragma omp ...'\n/// directive.\n///\n/// \\code\n/// #pragma omp parallel proc_bind(master)\n/// \\endcode\n/// In this example directive '#pragma omp parallel' has simple 'proc_bind'\n/// clause with kind 'master'.\nclass OMPProcBindClause : public OMPClause {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// A kind of the 'proc_bind' clause.\n  llvm::omp::ProcBindKind Kind = llvm::omp::OMP_PROC_BIND_unknown;\n\n  /// Start location of the kind in source code.\n  SourceLocation KindKwLoc;\n\n  /// Set kind of the clause.\n  ///\n  /// \\param K Kind of clause.\n  void setProcBindKind(llvm::omp::ProcBindKind K) { Kind = K; }\n\n  /// Set clause kind location.\n  ///\n  /// \\param KLoc Kind location.\n  void setProcBindKindKwLoc(SourceLocation KLoc) { KindKwLoc = KLoc; }\n\npublic:\n  /// Build 'proc_bind' clause with argument \\a A ('master', 'close' or\n  ///        'spread').\n  ///\n  /// \\param A Argument of the clause ('master', 'close' or 'spread').\n  /// \\param ALoc Starting location of the argument.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  OMPProcBindClause(llvm::omp::ProcBindKind A, SourceLocation ALoc,\n                    SourceLocation StartLoc, SourceLocation LParenLoc,\n                    SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_proc_bind, StartLoc, EndLoc),\n        LParenLoc(LParenLoc), Kind(A), KindKwLoc(ALoc) {}\n\n  /// Build an empty clause.\n  OMPProcBindClause()\n      : OMPClause(llvm::omp::OMPC_proc_bind, SourceLocation(),\n                  SourceLocation()) {}\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Returns kind of the clause.\n  llvm::omp::ProcBindKind getProcBindKind() const { return Kind; }\n\n  /// Returns location of clause kind.\n  SourceLocation getProcBindKindKwLoc() const { return KindKwLoc; }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_proc_bind;\n  }\n};\n\n/// This represents 'unified_address' clause in the '#pragma omp requires'\n/// directive.\n///\n/// \\code\n/// #pragma omp requires unified_address\n/// \\endcode\n/// In this example directive '#pragma omp requires' has 'unified_address'\n/// clause.\nclass OMPUnifiedAddressClause final : public OMPClause {\npublic:\n  friend class OMPClauseReader;\n  /// Build 'unified_address' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPUnifiedAddressClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_unified_address, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPUnifiedAddressClause()\n      : OMPClause(llvm::omp::OMPC_unified_address, SourceLocation(),\n                  SourceLocation()) {}\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_unified_address;\n  }\n};\n\n/// This represents 'unified_shared_memory' clause in the '#pragma omp requires'\n/// directive.\n///\n/// \\code\n/// #pragma omp requires unified_shared_memory\n/// \\endcode\n/// In this example directive '#pragma omp requires' has 'unified_shared_memory'\n/// clause.\nclass OMPUnifiedSharedMemoryClause final : public OMPClause {\npublic:\n  friend class OMPClauseReader;\n  /// Build 'unified_shared_memory' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPUnifiedSharedMemoryClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_unified_shared_memory, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPUnifiedSharedMemoryClause()\n      : OMPClause(llvm::omp::OMPC_unified_shared_memory, SourceLocation(),\n                  SourceLocation()) {}\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_unified_shared_memory;\n  }\n};\n\n/// This represents 'reverse_offload' clause in the '#pragma omp requires'\n/// directive.\n///\n/// \\code\n/// #pragma omp requires reverse_offload\n/// \\endcode\n/// In this example directive '#pragma omp requires' has 'reverse_offload'\n/// clause.\nclass OMPReverseOffloadClause final : public OMPClause {\npublic:\n  friend class OMPClauseReader;\n  /// Build 'reverse_offload' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPReverseOffloadClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_reverse_offload, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPReverseOffloadClause()\n      : OMPClause(llvm::omp::OMPC_reverse_offload, SourceLocation(),\n                  SourceLocation()) {}\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_reverse_offload;\n  }\n};\n\n/// This represents 'dynamic_allocators' clause in the '#pragma omp requires'\n/// directive.\n///\n/// \\code\n/// #pragma omp requires dynamic_allocators\n/// \\endcode\n/// In this example directive '#pragma omp requires' has 'dynamic_allocators'\n/// clause.\nclass OMPDynamicAllocatorsClause final : public OMPClause {\npublic:\n  friend class OMPClauseReader;\n  /// Build 'dynamic_allocators' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPDynamicAllocatorsClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_dynamic_allocators, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPDynamicAllocatorsClause()\n      : OMPClause(llvm::omp::OMPC_dynamic_allocators, SourceLocation(),\n                  SourceLocation()) {}\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_dynamic_allocators;\n  }\n};\n\n/// This represents 'atomic_default_mem_order' clause in the '#pragma omp\n/// requires'  directive.\n///\n/// \\code\n/// #pragma omp requires atomic_default_mem_order(seq_cst)\n/// \\endcode\n/// In this example directive '#pragma omp requires' has simple\n/// atomic_default_mem_order' clause with kind 'seq_cst'.\nclass OMPAtomicDefaultMemOrderClause final : public OMPClause {\n  friend class OMPClauseReader;\n\n  /// Location of '('\n  SourceLocation LParenLoc;\n\n  /// A kind of the 'atomic_default_mem_order' clause.\n  OpenMPAtomicDefaultMemOrderClauseKind Kind =\n      OMPC_ATOMIC_DEFAULT_MEM_ORDER_unknown;\n\n  /// Start location of the kind in source code.\n  SourceLocation KindKwLoc;\n\n  /// Set kind of the clause.\n  ///\n  /// \\param K Kind of clause.\n  void setAtomicDefaultMemOrderKind(OpenMPAtomicDefaultMemOrderClauseKind K) {\n    Kind = K;\n  }\n\n  /// Set clause kind location.\n  ///\n  /// \\param KLoc Kind location.\n  void setAtomicDefaultMemOrderKindKwLoc(SourceLocation KLoc) {\n    KindKwLoc = KLoc;\n  }\n\npublic:\n  /// Build 'atomic_default_mem_order' clause with argument \\a A ('seq_cst',\n  /// 'acq_rel' or 'relaxed').\n  ///\n  /// \\param A Argument of the clause ('seq_cst', 'acq_rel' or 'relaxed').\n  /// \\param ALoc Starting location of the argument.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  OMPAtomicDefaultMemOrderClause(OpenMPAtomicDefaultMemOrderClauseKind A,\n                                 SourceLocation ALoc, SourceLocation StartLoc,\n                                 SourceLocation LParenLoc,\n                                 SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_atomic_default_mem_order, StartLoc, EndLoc),\n        LParenLoc(LParenLoc), Kind(A), KindKwLoc(ALoc) {}\n\n  /// Build an empty clause.\n  OMPAtomicDefaultMemOrderClause()\n      : OMPClause(llvm::omp::OMPC_atomic_default_mem_order, SourceLocation(),\n                  SourceLocation()) {}\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the locaiton of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Returns kind of the clause.\n  OpenMPAtomicDefaultMemOrderClauseKind getAtomicDefaultMemOrderKind() const {\n    return Kind;\n  }\n\n  /// Returns location of clause kind.\n  SourceLocation getAtomicDefaultMemOrderKindKwLoc() const { return KindKwLoc; }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_atomic_default_mem_order;\n  }\n};\n\n/// This represents 'schedule' clause in the '#pragma omp ...' directive.\n///\n/// \\code\n/// #pragma omp for schedule(static, 3)\n/// \\endcode\n/// In this example directive '#pragma omp for' has 'schedule' clause with\n/// arguments 'static' and '3'.\nclass OMPScheduleClause : public OMPClause, public OMPClauseWithPreInit {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// A kind of the 'schedule' clause.\n  OpenMPScheduleClauseKind Kind = OMPC_SCHEDULE_unknown;\n\n  /// Modifiers for 'schedule' clause.\n  enum {FIRST, SECOND, NUM_MODIFIERS};\n  OpenMPScheduleClauseModifier Modifiers[NUM_MODIFIERS];\n\n  /// Locations of modifiers.\n  SourceLocation ModifiersLoc[NUM_MODIFIERS];\n\n  /// Start location of the schedule ind in source code.\n  SourceLocation KindLoc;\n\n  /// Location of ',' (if any).\n  SourceLocation CommaLoc;\n\n  /// Chunk size.\n  Expr *ChunkSize = nullptr;\n\n  /// Set schedule kind.\n  ///\n  /// \\param K Schedule kind.\n  void setScheduleKind(OpenMPScheduleClauseKind K) { Kind = K; }\n\n  /// Set the first schedule modifier.\n  ///\n  /// \\param M Schedule modifier.\n  void setFirstScheduleModifier(OpenMPScheduleClauseModifier M) {\n    Modifiers[FIRST] = M;\n  }\n\n  /// Set the second schedule modifier.\n  ///\n  /// \\param M Schedule modifier.\n  void setSecondScheduleModifier(OpenMPScheduleClauseModifier M) {\n    Modifiers[SECOND] = M;\n  }\n\n  /// Set location of the first schedule modifier.\n  void setFirstScheduleModifierLoc(SourceLocation Loc) {\n    ModifiersLoc[FIRST] = Loc;\n  }\n\n  /// Set location of the second schedule modifier.\n  void setSecondScheduleModifierLoc(SourceLocation Loc) {\n    ModifiersLoc[SECOND] = Loc;\n  }\n\n  /// Set schedule modifier location.\n  ///\n  /// \\param M Schedule modifier location.\n  void setScheduleModifer(OpenMPScheduleClauseModifier M) {\n    if (Modifiers[FIRST] == OMPC_SCHEDULE_MODIFIER_unknown)\n      Modifiers[FIRST] = M;\n    else {\n      assert(Modifiers[SECOND] == OMPC_SCHEDULE_MODIFIER_unknown);\n      Modifiers[SECOND] = M;\n    }\n  }\n\n  /// Sets the location of '('.\n  ///\n  /// \\param Loc Location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Set schedule kind start location.\n  ///\n  /// \\param KLoc Schedule kind location.\n  void setScheduleKindLoc(SourceLocation KLoc) { KindLoc = KLoc; }\n\n  /// Set location of ','.\n  ///\n  /// \\param Loc Location of ','.\n  void setCommaLoc(SourceLocation Loc) { CommaLoc = Loc; }\n\n  /// Set chunk size.\n  ///\n  /// \\param E Chunk size.\n  void setChunkSize(Expr *E) { ChunkSize = E; }\n\npublic:\n  /// Build 'schedule' clause with schedule kind \\a Kind and chunk size\n  /// expression \\a ChunkSize.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param KLoc Starting location of the argument.\n  /// \\param CommaLoc Location of ','.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param Kind Schedule kind.\n  /// \\param ChunkSize Chunk size.\n  /// \\param HelperChunkSize Helper chunk size for combined directives.\n  /// \\param M1 The first modifier applied to 'schedule' clause.\n  /// \\param M1Loc Location of the first modifier\n  /// \\param M2 The second modifier applied to 'schedule' clause.\n  /// \\param M2Loc Location of the second modifier\n  OMPScheduleClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                    SourceLocation KLoc, SourceLocation CommaLoc,\n                    SourceLocation EndLoc, OpenMPScheduleClauseKind Kind,\n                    Expr *ChunkSize, Stmt *HelperChunkSize,\n                    OpenMPScheduleClauseModifier M1, SourceLocation M1Loc,\n                    OpenMPScheduleClauseModifier M2, SourceLocation M2Loc)\n      : OMPClause(llvm::omp::OMPC_schedule, StartLoc, EndLoc),\n        OMPClauseWithPreInit(this), LParenLoc(LParenLoc), Kind(Kind),\n        KindLoc(KLoc), CommaLoc(CommaLoc), ChunkSize(ChunkSize) {\n    setPreInitStmt(HelperChunkSize);\n    Modifiers[FIRST] = M1;\n    Modifiers[SECOND] = M2;\n    ModifiersLoc[FIRST] = M1Loc;\n    ModifiersLoc[SECOND] = M2Loc;\n  }\n\n  /// Build an empty clause.\n  explicit OMPScheduleClause()\n      : OMPClause(llvm::omp::OMPC_schedule, SourceLocation(), SourceLocation()),\n        OMPClauseWithPreInit(this) {\n    Modifiers[FIRST] = OMPC_SCHEDULE_MODIFIER_unknown;\n    Modifiers[SECOND] = OMPC_SCHEDULE_MODIFIER_unknown;\n  }\n\n  /// Get kind of the clause.\n  OpenMPScheduleClauseKind getScheduleKind() const { return Kind; }\n\n  /// Get the first modifier of the clause.\n  OpenMPScheduleClauseModifier getFirstScheduleModifier() const {\n    return Modifiers[FIRST];\n  }\n\n  /// Get the second modifier of the clause.\n  OpenMPScheduleClauseModifier getSecondScheduleModifier() const {\n    return Modifiers[SECOND];\n  }\n\n  /// Get location of '('.\n  SourceLocation getLParenLoc() { return LParenLoc; }\n\n  /// Get kind location.\n  SourceLocation getScheduleKindLoc() { return KindLoc; }\n\n  /// Get the first modifier location.\n  SourceLocation getFirstScheduleModifierLoc() const {\n    return ModifiersLoc[FIRST];\n  }\n\n  /// Get the second modifier location.\n  SourceLocation getSecondScheduleModifierLoc() const {\n    return ModifiersLoc[SECOND];\n  }\n\n  /// Get location of ','.\n  SourceLocation getCommaLoc() { return CommaLoc; }\n\n  /// Get chunk size.\n  Expr *getChunkSize() { return ChunkSize; }\n\n  /// Get chunk size.\n  const Expr *getChunkSize() const { return ChunkSize; }\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(&ChunkSize),\n                       reinterpret_cast<Stmt **>(&ChunkSize) + 1);\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPScheduleClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_schedule;\n  }\n};\n\n/// This represents 'ordered' clause in the '#pragma omp ...' directive.\n///\n/// \\code\n/// #pragma omp for ordered (2)\n/// \\endcode\n/// In this example directive '#pragma omp for' has 'ordered' clause with\n/// parameter 2.\nclass OMPOrderedClause final\n    : public OMPClause,\n      private llvm::TrailingObjects<OMPOrderedClause, Expr *> {\n  friend class OMPClauseReader;\n  friend TrailingObjects;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Number of for-loops.\n  Stmt *NumForLoops = nullptr;\n\n  /// Real number of loops.\n  unsigned NumberOfLoops = 0;\n\n  /// Build 'ordered' clause.\n  ///\n  /// \\param Num Expression, possibly associated with this clause.\n  /// \\param NumLoops Number of loops, associated with this clause.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  OMPOrderedClause(Expr *Num, unsigned NumLoops, SourceLocation StartLoc,\n                   SourceLocation LParenLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_ordered, StartLoc, EndLoc),\n        LParenLoc(LParenLoc), NumForLoops(Num), NumberOfLoops(NumLoops) {}\n\n  /// Build an empty clause.\n  explicit OMPOrderedClause(unsigned NumLoops)\n      : OMPClause(llvm::omp::OMPC_ordered, SourceLocation(), SourceLocation()),\n        NumberOfLoops(NumLoops) {}\n\n  /// Set the number of associated for-loops.\n  void setNumForLoops(Expr *Num) { NumForLoops = Num; }\n\npublic:\n  /// Build 'ordered' clause.\n  ///\n  /// \\param Num Expression, possibly associated with this clause.\n  /// \\param NumLoops Number of loops, associated with this clause.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  static OMPOrderedClause *Create(const ASTContext &C, Expr *Num,\n                                  unsigned NumLoops, SourceLocation StartLoc,\n                                  SourceLocation LParenLoc,\n                                  SourceLocation EndLoc);\n\n  /// Build an empty clause.\n  static OMPOrderedClause* CreateEmpty(const ASTContext &C, unsigned NumLoops);\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Return the number of associated for-loops.\n  Expr *getNumForLoops() const { return cast_or_null<Expr>(NumForLoops); }\n\n  /// Set number of iterations for the specified loop.\n  void setLoopNumIterations(unsigned NumLoop, Expr *NumIterations);\n  /// Get number of iterations for all the loops.\n  ArrayRef<Expr *> getLoopNumIterations() const;\n\n  /// Set loop counter for the specified loop.\n  void setLoopCounter(unsigned NumLoop, Expr *Counter);\n  /// Get loops counter for the specified loop.\n  Expr *getLoopCounter(unsigned NumLoop);\n  const Expr *getLoopCounter(unsigned NumLoop) const;\n\n  child_range children() { return child_range(&NumForLoops, &NumForLoops + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&NumForLoops, &NumForLoops + 1);\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_ordered;\n  }\n};\n\n/// This represents 'nowait' clause in the '#pragma omp ...' directive.\n///\n/// \\code\n/// #pragma omp for nowait\n/// \\endcode\n/// In this example directive '#pragma omp for' has 'nowait' clause.\nclass OMPNowaitClause : public OMPClause {\npublic:\n  /// Build 'nowait' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPNowaitClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_nowait, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPNowaitClause()\n      : OMPClause(llvm::omp::OMPC_nowait, SourceLocation(), SourceLocation()) {}\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_nowait;\n  }\n};\n\n/// This represents 'untied' clause in the '#pragma omp ...' directive.\n///\n/// \\code\n/// #pragma omp task untied\n/// \\endcode\n/// In this example directive '#pragma omp task' has 'untied' clause.\nclass OMPUntiedClause : public OMPClause {\npublic:\n  /// Build 'untied' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPUntiedClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_untied, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPUntiedClause()\n      : OMPClause(llvm::omp::OMPC_untied, SourceLocation(), SourceLocation()) {}\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_untied;\n  }\n};\n\n/// This represents 'mergeable' clause in the '#pragma omp ...'\n/// directive.\n///\n/// \\code\n/// #pragma omp task mergeable\n/// \\endcode\n/// In this example directive '#pragma omp task' has 'mergeable' clause.\nclass OMPMergeableClause : public OMPClause {\npublic:\n  /// Build 'mergeable' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPMergeableClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_mergeable, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPMergeableClause()\n      : OMPClause(llvm::omp::OMPC_mergeable, SourceLocation(),\n                  SourceLocation()) {}\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_mergeable;\n  }\n};\n\n/// This represents 'read' clause in the '#pragma omp atomic' directive.\n///\n/// \\code\n/// #pragma omp atomic read\n/// \\endcode\n/// In this example directive '#pragma omp atomic' has 'read' clause.\nclass OMPReadClause : public OMPClause {\npublic:\n  /// Build 'read' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPReadClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_read, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPReadClause()\n      : OMPClause(llvm::omp::OMPC_read, SourceLocation(), SourceLocation()) {}\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_read;\n  }\n};\n\n/// This represents 'write' clause in the '#pragma omp atomic' directive.\n///\n/// \\code\n/// #pragma omp atomic write\n/// \\endcode\n/// In this example directive '#pragma omp atomic' has 'write' clause.\nclass OMPWriteClause : public OMPClause {\npublic:\n  /// Build 'write' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPWriteClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_write, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPWriteClause()\n      : OMPClause(llvm::omp::OMPC_write, SourceLocation(), SourceLocation()) {}\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_write;\n  }\n};\n\n/// This represents 'update' clause in the '#pragma omp atomic'\n/// directive.\n///\n/// \\code\n/// #pragma omp atomic update\n/// \\endcode\n/// In this example directive '#pragma omp atomic' has 'update' clause.\n/// Also, this class represents 'update' clause in  '#pragma omp depobj'\n/// directive.\n///\n/// \\code\n/// #pragma omp depobj(a) update(in)\n/// \\endcode\n/// In this example directive '#pragma omp depobj' has 'update' clause with 'in'\n/// dependence kind.\nclass OMPUpdateClause final\n    : public OMPClause,\n      private llvm::TrailingObjects<OMPUpdateClause, SourceLocation,\n                                    OpenMPDependClauseKind> {\n  friend class OMPClauseReader;\n  friend TrailingObjects;\n\n  /// true if extended version of the clause for 'depobj' directive.\n  bool IsExtended = false;\n\n  /// Define the sizes of each trailing object array except the last one. This\n  /// is required for TrailingObjects to work properly.\n  size_t numTrailingObjects(OverloadToken<SourceLocation>) const {\n    // 2 locations: for '(' and argument location.\n    return IsExtended ? 2 : 0;\n  }\n\n  /// Sets the the location of '(' in clause for 'depobj' directive.\n  void setLParenLoc(SourceLocation Loc) {\n    assert(IsExtended && \"Expected extended clause.\");\n    *getTrailingObjects<SourceLocation>() = Loc;\n  }\n\n  /// Sets the the location of '(' in clause for 'depobj' directive.\n  void setArgumentLoc(SourceLocation Loc) {\n    assert(IsExtended && \"Expected extended clause.\");\n    *std::next(getTrailingObjects<SourceLocation>(), 1) = Loc;\n  }\n\n  /// Sets the dependence kind for the clause for 'depobj' directive.\n  void setDependencyKind(OpenMPDependClauseKind DK) {\n    assert(IsExtended && \"Expected extended clause.\");\n    *getTrailingObjects<OpenMPDependClauseKind>() = DK;\n  }\n\n  /// Build 'update' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPUpdateClause(SourceLocation StartLoc, SourceLocation EndLoc,\n                  bool IsExtended)\n      : OMPClause(llvm::omp::OMPC_update, StartLoc, EndLoc),\n        IsExtended(IsExtended) {}\n\n  /// Build an empty clause.\n  OMPUpdateClause(bool IsExtended)\n      : OMPClause(llvm::omp::OMPC_update, SourceLocation(), SourceLocation()),\n        IsExtended(IsExtended) {}\n\npublic:\n  /// Creates clause for 'atomic' directive.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  static OMPUpdateClause *Create(const ASTContext &C, SourceLocation StartLoc,\n                                 SourceLocation EndLoc);\n\n  /// Creates clause for 'depobj' directive.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param ArgumentLoc Location of the argument.\n  /// \\param DK Dependence kind.\n  /// \\param EndLoc Ending location of the clause.\n  static OMPUpdateClause *Create(const ASTContext &C, SourceLocation StartLoc,\n                                 SourceLocation LParenLoc,\n                                 SourceLocation ArgumentLoc,\n                                 OpenMPDependClauseKind DK,\n                                 SourceLocation EndLoc);\n\n  /// Creates an empty clause with the place for \\a N variables.\n  ///\n  /// \\param C AST context.\n  /// \\param IsExtended true if extended clause for 'depobj' directive must be\n  /// created.\n  static OMPUpdateClause *CreateEmpty(const ASTContext &C, bool IsExtended);\n\n  /// Checks if the clause is the extended clauses for 'depobj' directive.\n  bool isExtended() const { return IsExtended; }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  /// Gets the the location of '(' in clause for 'depobj' directive.\n  SourceLocation getLParenLoc() const {\n    assert(IsExtended && \"Expected extended clause.\");\n    return *getTrailingObjects<SourceLocation>();\n  }\n\n  /// Gets the the location of argument in clause for 'depobj' directive.\n  SourceLocation getArgumentLoc() const {\n    assert(IsExtended && \"Expected extended clause.\");\n    return *std::next(getTrailingObjects<SourceLocation>(), 1);\n  }\n\n  /// Gets the dependence kind in clause for 'depobj' directive.\n  OpenMPDependClauseKind getDependencyKind() const {\n    assert(IsExtended && \"Expected extended clause.\");\n    return *getTrailingObjects<OpenMPDependClauseKind>();\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_update;\n  }\n};\n\n/// This represents 'capture' clause in the '#pragma omp atomic'\n/// directive.\n///\n/// \\code\n/// #pragma omp atomic capture\n/// \\endcode\n/// In this example directive '#pragma omp atomic' has 'capture' clause.\nclass OMPCaptureClause : public OMPClause {\npublic:\n  /// Build 'capture' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPCaptureClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_capture, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPCaptureClause()\n      : OMPClause(llvm::omp::OMPC_capture, SourceLocation(), SourceLocation()) {\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_capture;\n  }\n};\n\n/// This represents 'seq_cst' clause in the '#pragma omp atomic'\n/// directive.\n///\n/// \\code\n/// #pragma omp atomic seq_cst\n/// \\endcode\n/// In this example directive '#pragma omp atomic' has 'seq_cst' clause.\nclass OMPSeqCstClause : public OMPClause {\npublic:\n  /// Build 'seq_cst' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPSeqCstClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_seq_cst, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPSeqCstClause()\n      : OMPClause(llvm::omp::OMPC_seq_cst, SourceLocation(), SourceLocation()) {\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_seq_cst;\n  }\n};\n\n/// This represents 'acq_rel' clause in the '#pragma omp atomic|flush'\n/// directives.\n///\n/// \\code\n/// #pragma omp flush acq_rel\n/// \\endcode\n/// In this example directive '#pragma omp flush' has 'acq_rel' clause.\nclass OMPAcqRelClause final : public OMPClause {\npublic:\n  /// Build 'ack_rel' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPAcqRelClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_acq_rel, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPAcqRelClause()\n      : OMPClause(llvm::omp::OMPC_acq_rel, SourceLocation(), SourceLocation()) {\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_acq_rel;\n  }\n};\n\n/// This represents 'acquire' clause in the '#pragma omp atomic|flush'\n/// directives.\n///\n/// \\code\n/// #pragma omp flush acquire\n/// \\endcode\n/// In this example directive '#pragma omp flush' has 'acquire' clause.\nclass OMPAcquireClause final : public OMPClause {\npublic:\n  /// Build 'acquire' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPAcquireClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_acquire, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPAcquireClause()\n      : OMPClause(llvm::omp::OMPC_acquire, SourceLocation(), SourceLocation()) {\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_acquire;\n  }\n};\n\n/// This represents 'release' clause in the '#pragma omp atomic|flush'\n/// directives.\n///\n/// \\code\n/// #pragma omp flush release\n/// \\endcode\n/// In this example directive '#pragma omp flush' has 'release' clause.\nclass OMPReleaseClause final : public OMPClause {\npublic:\n  /// Build 'release' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPReleaseClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_release, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPReleaseClause()\n      : OMPClause(llvm::omp::OMPC_release, SourceLocation(), SourceLocation()) {\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_release;\n  }\n};\n\n/// This represents 'relaxed' clause in the '#pragma omp atomic'\n/// directives.\n///\n/// \\code\n/// #pragma omp atomic relaxed\n/// \\endcode\n/// In this example directive '#pragma omp atomic' has 'relaxed' clause.\nclass OMPRelaxedClause final : public OMPClause {\npublic:\n  /// Build 'relaxed' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPRelaxedClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_relaxed, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPRelaxedClause()\n      : OMPClause(llvm::omp::OMPC_relaxed, SourceLocation(), SourceLocation()) {\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_relaxed;\n  }\n};\n\n/// This represents clause 'private' in the '#pragma omp ...' directives.\n///\n/// \\code\n/// #pragma omp parallel private(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp parallel' has clause 'private'\n/// with the variables 'a' and 'b'.\nclass OMPPrivateClause final\n    : public OMPVarListClause<OMPPrivateClause>,\n      private llvm::TrailingObjects<OMPPrivateClause, Expr *> {\n  friend class OMPClauseReader;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Build clause with number of variables \\a N.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param N Number of the variables in the clause.\n  OMPPrivateClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                   SourceLocation EndLoc, unsigned N)\n      : OMPVarListClause<OMPPrivateClause>(llvm::omp::OMPC_private, StartLoc,\n                                           LParenLoc, EndLoc, N) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param N Number of variables.\n  explicit OMPPrivateClause(unsigned N)\n      : OMPVarListClause<OMPPrivateClause>(llvm::omp::OMPC_private,\n                                           SourceLocation(), SourceLocation(),\n                                           SourceLocation(), N) {}\n\n  /// Sets the list of references to private copies with initializers for\n  /// new private variables.\n  /// \\param VL List of references.\n  void setPrivateCopies(ArrayRef<Expr *> VL);\n\n  /// Gets the list of references to private copies with initializers for\n  /// new private variables.\n  MutableArrayRef<Expr *> getPrivateCopies() {\n    return MutableArrayRef<Expr *>(varlist_end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getPrivateCopies() const {\n    return llvm::makeArrayRef(varlist_end(), varlist_size());\n  }\n\npublic:\n  /// Creates clause with a list of variables \\a VL.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param VL List of references to the variables.\n  /// \\param PrivateVL List of references to private copies with initializers.\n  static OMPPrivateClause *Create(const ASTContext &C, SourceLocation StartLoc,\n                                  SourceLocation LParenLoc,\n                                  SourceLocation EndLoc, ArrayRef<Expr *> VL,\n                                  ArrayRef<Expr *> PrivateVL);\n\n  /// Creates an empty clause with the place for \\a N variables.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of variables.\n  static OMPPrivateClause *CreateEmpty(const ASTContext &C, unsigned N);\n\n  using private_copies_iterator = MutableArrayRef<Expr *>::iterator;\n  using private_copies_const_iterator = ArrayRef<const Expr *>::iterator;\n  using private_copies_range = llvm::iterator_range<private_copies_iterator>;\n  using private_copies_const_range =\n      llvm::iterator_range<private_copies_const_iterator>;\n\n  private_copies_range private_copies() {\n    return private_copies_range(getPrivateCopies().begin(),\n                                getPrivateCopies().end());\n  }\n\n  private_copies_const_range private_copies() const {\n    return private_copies_const_range(getPrivateCopies().begin(),\n                                      getPrivateCopies().end());\n  }\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPPrivateClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_private;\n  }\n};\n\n/// This represents clause 'firstprivate' in the '#pragma omp ...'\n/// directives.\n///\n/// \\code\n/// #pragma omp parallel firstprivate(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp parallel' has clause 'firstprivate'\n/// with the variables 'a' and 'b'.\nclass OMPFirstprivateClause final\n    : public OMPVarListClause<OMPFirstprivateClause>,\n      public OMPClauseWithPreInit,\n      private llvm::TrailingObjects<OMPFirstprivateClause, Expr *> {\n  friend class OMPClauseReader;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Build clause with number of variables \\a N.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param N Number of the variables in the clause.\n  OMPFirstprivateClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                        SourceLocation EndLoc, unsigned N)\n      : OMPVarListClause<OMPFirstprivateClause>(llvm::omp::OMPC_firstprivate,\n                                                StartLoc, LParenLoc, EndLoc, N),\n        OMPClauseWithPreInit(this) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param N Number of variables.\n  explicit OMPFirstprivateClause(unsigned N)\n      : OMPVarListClause<OMPFirstprivateClause>(\n            llvm::omp::OMPC_firstprivate, SourceLocation(), SourceLocation(),\n            SourceLocation(), N),\n        OMPClauseWithPreInit(this) {}\n\n  /// Sets the list of references to private copies with initializers for\n  /// new private variables.\n  /// \\param VL List of references.\n  void setPrivateCopies(ArrayRef<Expr *> VL);\n\n  /// Gets the list of references to private copies with initializers for\n  /// new private variables.\n  MutableArrayRef<Expr *> getPrivateCopies() {\n    return MutableArrayRef<Expr *>(varlist_end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getPrivateCopies() const {\n    return llvm::makeArrayRef(varlist_end(), varlist_size());\n  }\n\n  /// Sets the list of references to initializer variables for new\n  /// private variables.\n  /// \\param VL List of references.\n  void setInits(ArrayRef<Expr *> VL);\n\n  /// Gets the list of references to initializer variables for new\n  /// private variables.\n  MutableArrayRef<Expr *> getInits() {\n    return MutableArrayRef<Expr *>(getPrivateCopies().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getInits() const {\n    return llvm::makeArrayRef(getPrivateCopies().end(), varlist_size());\n  }\n\npublic:\n  /// Creates clause with a list of variables \\a VL.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param VL List of references to the original variables.\n  /// \\param PrivateVL List of references to private copies with initializers.\n  /// \\param InitVL List of references to auto generated variables used for\n  /// initialization of a single array element. Used if firstprivate variable is\n  /// of array type.\n  /// \\param PreInit Statement that must be executed before entering the OpenMP\n  /// region with this clause.\n  static OMPFirstprivateClause *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation LParenLoc,\n         SourceLocation EndLoc, ArrayRef<Expr *> VL, ArrayRef<Expr *> PrivateVL,\n         ArrayRef<Expr *> InitVL, Stmt *PreInit);\n\n  /// Creates an empty clause with the place for \\a N variables.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of variables.\n  static OMPFirstprivateClause *CreateEmpty(const ASTContext &C, unsigned N);\n\n  using private_copies_iterator = MutableArrayRef<Expr *>::iterator;\n  using private_copies_const_iterator = ArrayRef<const Expr *>::iterator;\n  using private_copies_range = llvm::iterator_range<private_copies_iterator>;\n  using private_copies_const_range =\n      llvm::iterator_range<private_copies_const_iterator>;\n\n  private_copies_range private_copies() {\n    return private_copies_range(getPrivateCopies().begin(),\n                                getPrivateCopies().end());\n  }\n  private_copies_const_range private_copies() const {\n    return private_copies_const_range(getPrivateCopies().begin(),\n                                      getPrivateCopies().end());\n  }\n\n  using inits_iterator = MutableArrayRef<Expr *>::iterator;\n  using inits_const_iterator = ArrayRef<const Expr *>::iterator;\n  using inits_range = llvm::iterator_range<inits_iterator>;\n  using inits_const_range = llvm::iterator_range<inits_const_iterator>;\n\n  inits_range inits() {\n    return inits_range(getInits().begin(), getInits().end());\n  }\n  inits_const_range inits() const {\n    return inits_const_range(getInits().begin(), getInits().end());\n  }\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPFirstprivateClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n  const_child_range used_children() const {\n    auto Children = const_cast<OMPFirstprivateClause *>(this)->used_children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_firstprivate;\n  }\n};\n\n/// This represents clause 'lastprivate' in the '#pragma omp ...'\n/// directives.\n///\n/// \\code\n/// #pragma omp simd lastprivate(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp simd' has clause 'lastprivate'\n/// with the variables 'a' and 'b'.\nclass OMPLastprivateClause final\n    : public OMPVarListClause<OMPLastprivateClause>,\n      public OMPClauseWithPostUpdate,\n      private llvm::TrailingObjects<OMPLastprivateClause, Expr *> {\n  // There are 4 additional tail-allocated arrays at the end of the class:\n  // 1. Contains list of pseudo variables with the default initialization for\n  // each non-firstprivate variables. Used in codegen for initialization of\n  // lastprivate copies.\n  // 2. List of helper expressions for proper generation of assignment operation\n  // required for lastprivate clause. This list represents private variables\n  // (for arrays, single array element).\n  // 3. List of helper expressions for proper generation of assignment operation\n  // required for lastprivate clause. This list represents original variables\n  // (for arrays, single array element).\n  // 4. List of helper expressions that represents assignment operation:\n  // \\code\n  // DstExprs = SrcExprs;\n  // \\endcode\n  // Required for proper codegen of final assignment performed by the\n  // lastprivate clause.\n  friend class OMPClauseReader;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Optional lastprivate kind, e.g. 'conditional', if specified by user.\n  OpenMPLastprivateModifier LPKind;\n  /// Optional location of the lasptrivate kind, if specified by user.\n  SourceLocation LPKindLoc;\n  /// Optional colon location, if specified by user.\n  SourceLocation ColonLoc;\n\n  /// Build clause with number of variables \\a N.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param N Number of the variables in the clause.\n  OMPLastprivateClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                       SourceLocation EndLoc, OpenMPLastprivateModifier LPKind,\n                       SourceLocation LPKindLoc, SourceLocation ColonLoc,\n                       unsigned N)\n      : OMPVarListClause<OMPLastprivateClause>(llvm::omp::OMPC_lastprivate,\n                                               StartLoc, LParenLoc, EndLoc, N),\n        OMPClauseWithPostUpdate(this), LPKind(LPKind), LPKindLoc(LPKindLoc),\n        ColonLoc(ColonLoc) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param N Number of variables.\n  explicit OMPLastprivateClause(unsigned N)\n      : OMPVarListClause<OMPLastprivateClause>(\n            llvm::omp::OMPC_lastprivate, SourceLocation(), SourceLocation(),\n            SourceLocation(), N),\n        OMPClauseWithPostUpdate(this) {}\n\n  /// Get the list of helper expressions for initialization of private\n  /// copies for lastprivate variables.\n  MutableArrayRef<Expr *> getPrivateCopies() {\n    return MutableArrayRef<Expr *>(varlist_end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getPrivateCopies() const {\n    return llvm::makeArrayRef(varlist_end(), varlist_size());\n  }\n\n  /// Set list of helper expressions, required for proper codegen of the\n  /// clause. These expressions represent private variables (for arrays, single\n  /// array element) in the final assignment statement performed by the\n  /// lastprivate clause.\n  void setSourceExprs(ArrayRef<Expr *> SrcExprs);\n\n  /// Get the list of helper source expressions.\n  MutableArrayRef<Expr *> getSourceExprs() {\n    return MutableArrayRef<Expr *>(getPrivateCopies().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getSourceExprs() const {\n    return llvm::makeArrayRef(getPrivateCopies().end(), varlist_size());\n  }\n\n  /// Set list of helper expressions, required for proper codegen of the\n  /// clause. These expressions represent original variables (for arrays, single\n  /// array element) in the final assignment statement performed by the\n  /// lastprivate clause.\n  void setDestinationExprs(ArrayRef<Expr *> DstExprs);\n\n  /// Get the list of helper destination expressions.\n  MutableArrayRef<Expr *> getDestinationExprs() {\n    return MutableArrayRef<Expr *>(getSourceExprs().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getDestinationExprs() const {\n    return llvm::makeArrayRef(getSourceExprs().end(), varlist_size());\n  }\n\n  /// Set list of helper assignment expressions, required for proper\n  /// codegen of the clause. These expressions are assignment expressions that\n  /// assign private copy of the variable to original variable.\n  void setAssignmentOps(ArrayRef<Expr *> AssignmentOps);\n\n  /// Get the list of helper assignment expressions.\n  MutableArrayRef<Expr *> getAssignmentOps() {\n    return MutableArrayRef<Expr *>(getDestinationExprs().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getAssignmentOps() const {\n    return llvm::makeArrayRef(getDestinationExprs().end(), varlist_size());\n  }\n\n  /// Sets lastprivate kind.\n  void setKind(OpenMPLastprivateModifier Kind) { LPKind = Kind; }\n  /// Sets location of the lastprivate kind.\n  void setKindLoc(SourceLocation Loc) { LPKindLoc = Loc; }\n  /// Sets colon symbol location.\n  void setColonLoc(SourceLocation Loc) { ColonLoc = Loc; }\n\npublic:\n  /// Creates clause with a list of variables \\a VL.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param VL List of references to the variables.\n  /// \\param SrcExprs List of helper expressions for proper generation of\n  /// assignment operation required for lastprivate clause. This list represents\n  /// private variables (for arrays, single array element).\n  /// \\param DstExprs List of helper expressions for proper generation of\n  /// assignment operation required for lastprivate clause. This list represents\n  /// original variables (for arrays, single array element).\n  /// \\param AssignmentOps List of helper expressions that represents assignment\n  /// operation:\n  /// \\code\n  /// DstExprs = SrcExprs;\n  /// \\endcode\n  /// Required for proper codegen of final assignment performed by the\n  /// lastprivate clause.\n  /// \\param LPKind Lastprivate kind, e.g. 'conditional'.\n  /// \\param LPKindLoc Location of the lastprivate kind.\n  /// \\param ColonLoc Location of the ':' symbol if lastprivate kind is used.\n  /// \\param PreInit Statement that must be executed before entering the OpenMP\n  /// region with this clause.\n  /// \\param PostUpdate Expression that must be executed after exit from the\n  /// OpenMP region with this clause.\n  static OMPLastprivateClause *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation LParenLoc,\n         SourceLocation EndLoc, ArrayRef<Expr *> VL, ArrayRef<Expr *> SrcExprs,\n         ArrayRef<Expr *> DstExprs, ArrayRef<Expr *> AssignmentOps,\n         OpenMPLastprivateModifier LPKind, SourceLocation LPKindLoc,\n         SourceLocation ColonLoc, Stmt *PreInit, Expr *PostUpdate);\n\n  /// Creates an empty clause with the place for \\a N variables.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of variables.\n  static OMPLastprivateClause *CreateEmpty(const ASTContext &C, unsigned N);\n\n  /// Lastprivate kind.\n  OpenMPLastprivateModifier getKind() const { return LPKind; }\n  /// Returns the location of the lastprivate kind.\n  SourceLocation getKindLoc() const { return LPKindLoc; }\n  /// Returns the location of the ':' symbol, if any.\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  using helper_expr_iterator = MutableArrayRef<Expr *>::iterator;\n  using helper_expr_const_iterator = ArrayRef<const Expr *>::iterator;\n  using helper_expr_range = llvm::iterator_range<helper_expr_iterator>;\n  using helper_expr_const_range =\n      llvm::iterator_range<helper_expr_const_iterator>;\n\n  /// Set list of helper expressions, required for generation of private\n  /// copies of original lastprivate variables.\n  void setPrivateCopies(ArrayRef<Expr *> PrivateCopies);\n\n  helper_expr_const_range private_copies() const {\n    return helper_expr_const_range(getPrivateCopies().begin(),\n                                   getPrivateCopies().end());\n  }\n\n  helper_expr_range private_copies() {\n    return helper_expr_range(getPrivateCopies().begin(),\n                             getPrivateCopies().end());\n  }\n\n  helper_expr_const_range source_exprs() const {\n    return helper_expr_const_range(getSourceExprs().begin(),\n                                   getSourceExprs().end());\n  }\n\n  helper_expr_range source_exprs() {\n    return helper_expr_range(getSourceExprs().begin(), getSourceExprs().end());\n  }\n\n  helper_expr_const_range destination_exprs() const {\n    return helper_expr_const_range(getDestinationExprs().begin(),\n                                   getDestinationExprs().end());\n  }\n\n  helper_expr_range destination_exprs() {\n    return helper_expr_range(getDestinationExprs().begin(),\n                             getDestinationExprs().end());\n  }\n\n  helper_expr_const_range assignment_ops() const {\n    return helper_expr_const_range(getAssignmentOps().begin(),\n                                   getAssignmentOps().end());\n  }\n\n  helper_expr_range assignment_ops() {\n    return helper_expr_range(getAssignmentOps().begin(),\n                             getAssignmentOps().end());\n  }\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPLastprivateClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_lastprivate;\n  }\n};\n\n/// This represents clause 'shared' in the '#pragma omp ...' directives.\n///\n/// \\code\n/// #pragma omp parallel shared(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp parallel' has clause 'shared'\n/// with the variables 'a' and 'b'.\nclass OMPSharedClause final\n    : public OMPVarListClause<OMPSharedClause>,\n      private llvm::TrailingObjects<OMPSharedClause, Expr *> {\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Build clause with number of variables \\a N.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param N Number of the variables in the clause.\n  OMPSharedClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                  SourceLocation EndLoc, unsigned N)\n      : OMPVarListClause<OMPSharedClause>(llvm::omp::OMPC_shared, StartLoc,\n                                          LParenLoc, EndLoc, N) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param N Number of variables.\n  explicit OMPSharedClause(unsigned N)\n      : OMPVarListClause<OMPSharedClause>(llvm::omp::OMPC_shared,\n                                          SourceLocation(), SourceLocation(),\n                                          SourceLocation(), N) {}\n\npublic:\n  /// Creates clause with a list of variables \\a VL.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param VL List of references to the variables.\n  static OMPSharedClause *Create(const ASTContext &C, SourceLocation StartLoc,\n                                 SourceLocation LParenLoc,\n                                 SourceLocation EndLoc, ArrayRef<Expr *> VL);\n\n  /// Creates an empty clause with \\a N variables.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of variables.\n  static OMPSharedClause *CreateEmpty(const ASTContext &C, unsigned N);\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPSharedClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_shared;\n  }\n};\n\n/// This represents clause 'reduction' in the '#pragma omp ...'\n/// directives.\n///\n/// \\code\n/// #pragma omp parallel reduction(+:a,b)\n/// \\endcode\n/// In this example directive '#pragma omp parallel' has clause 'reduction'\n/// with operator '+' and the variables 'a' and 'b'.\nclass OMPReductionClause final\n    : public OMPVarListClause<OMPReductionClause>,\n      public OMPClauseWithPostUpdate,\n      private llvm::TrailingObjects<OMPReductionClause, Expr *> {\n  friend class OMPClauseReader;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Reduction modifier.\n  OpenMPReductionClauseModifier Modifier = OMPC_REDUCTION_unknown;\n\n  /// Reduction modifier location.\n  SourceLocation ModifierLoc;\n\n  /// Location of ':'.\n  SourceLocation ColonLoc;\n\n  /// Nested name specifier for C++.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// Name of custom operator.\n  DeclarationNameInfo NameInfo;\n\n  /// Build clause with number of variables \\a N.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param ModifierLoc Modifier location.\n  /// \\param ColonLoc Location of ':'.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param N Number of the variables in the clause.\n  /// \\param QualifierLoc The nested-name qualifier with location information\n  /// \\param NameInfo The full name info for reduction identifier.\n  OMPReductionClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                     SourceLocation ModifierLoc, SourceLocation ColonLoc,\n                     SourceLocation EndLoc,\n                     OpenMPReductionClauseModifier Modifier, unsigned N,\n                     NestedNameSpecifierLoc QualifierLoc,\n                     const DeclarationNameInfo &NameInfo)\n      : OMPVarListClause<OMPReductionClause>(llvm::omp::OMPC_reduction,\n                                             StartLoc, LParenLoc, EndLoc, N),\n        OMPClauseWithPostUpdate(this), Modifier(Modifier),\n        ModifierLoc(ModifierLoc), ColonLoc(ColonLoc),\n        QualifierLoc(QualifierLoc), NameInfo(NameInfo) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param N Number of variables.\n  explicit OMPReductionClause(unsigned N)\n      : OMPVarListClause<OMPReductionClause>(llvm::omp::OMPC_reduction,\n                                             SourceLocation(), SourceLocation(),\n                                             SourceLocation(), N),\n        OMPClauseWithPostUpdate(this) {}\n\n  /// Sets reduction modifier.\n  void setModifier(OpenMPReductionClauseModifier M) { Modifier = M; }\n\n  /// Sets location of the modifier.\n  void setModifierLoc(SourceLocation Loc) { ModifierLoc = Loc; }\n\n  /// Sets location of ':' symbol in clause.\n  void setColonLoc(SourceLocation CL) { ColonLoc = CL; }\n\n  /// Sets the name info for specified reduction identifier.\n  void setNameInfo(DeclarationNameInfo DNI) { NameInfo = DNI; }\n\n  /// Sets the nested name specifier.\n  void setQualifierLoc(NestedNameSpecifierLoc NSL) { QualifierLoc = NSL; }\n\n  /// Set list of helper expressions, required for proper codegen of the\n  /// clause. These expressions represent private copy of the reduction\n  /// variable.\n  void setPrivates(ArrayRef<Expr *> Privates);\n\n  /// Get the list of helper privates.\n  MutableArrayRef<Expr *> getPrivates() {\n    return MutableArrayRef<Expr *>(varlist_end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getPrivates() const {\n    return llvm::makeArrayRef(varlist_end(), varlist_size());\n  }\n\n  /// Set list of helper expressions, required for proper codegen of the\n  /// clause. These expressions represent LHS expression in the final\n  /// reduction expression performed by the reduction clause.\n  void setLHSExprs(ArrayRef<Expr *> LHSExprs);\n\n  /// Get the list of helper LHS expressions.\n  MutableArrayRef<Expr *> getLHSExprs() {\n    return MutableArrayRef<Expr *>(getPrivates().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getLHSExprs() const {\n    return llvm::makeArrayRef(getPrivates().end(), varlist_size());\n  }\n\n  /// Set list of helper expressions, required for proper codegen of the\n  /// clause. These expressions represent RHS expression in the final\n  /// reduction expression performed by the reduction clause.\n  /// Also, variables in these expressions are used for proper initialization of\n  /// reduction copies.\n  void setRHSExprs(ArrayRef<Expr *> RHSExprs);\n\n  /// Get the list of helper destination expressions.\n  MutableArrayRef<Expr *> getRHSExprs() {\n    return MutableArrayRef<Expr *>(getLHSExprs().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getRHSExprs() const {\n    return llvm::makeArrayRef(getLHSExprs().end(), varlist_size());\n  }\n\n  /// Set list of helper reduction expressions, required for proper\n  /// codegen of the clause. These expressions are binary expressions or\n  /// operator/custom reduction call that calculates new value from source\n  /// helper expressions to destination helper expressions.\n  void setReductionOps(ArrayRef<Expr *> ReductionOps);\n\n  /// Get the list of helper reduction expressions.\n  MutableArrayRef<Expr *> getReductionOps() {\n    return MutableArrayRef<Expr *>(getRHSExprs().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getReductionOps() const {\n    return llvm::makeArrayRef(getRHSExprs().end(), varlist_size());\n  }\n\n  /// Set list of helper copy operations for inscan reductions.\n  /// The form is: Temps[i] = LHS[i];\n  void setInscanCopyOps(ArrayRef<Expr *> Ops);\n\n  /// Get the list of helper inscan copy operations.\n  MutableArrayRef<Expr *> getInscanCopyOps() {\n    return MutableArrayRef<Expr *>(getReductionOps().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getInscanCopyOps() const {\n    return llvm::makeArrayRef(getReductionOps().end(), varlist_size());\n  }\n\n  /// Set list of helper temp vars for inscan copy array operations.\n  void setInscanCopyArrayTemps(ArrayRef<Expr *> CopyArrayTemps);\n\n  /// Get the list of helper inscan copy temps.\n  MutableArrayRef<Expr *> getInscanCopyArrayTemps() {\n    return MutableArrayRef<Expr *>(getInscanCopyOps().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getInscanCopyArrayTemps() const {\n    return llvm::makeArrayRef(getInscanCopyOps().end(), varlist_size());\n  }\n\n  /// Set list of helper temp elements vars for inscan copy array operations.\n  void setInscanCopyArrayElems(ArrayRef<Expr *> CopyArrayElems);\n\n  /// Get the list of helper inscan copy temps.\n  MutableArrayRef<Expr *> getInscanCopyArrayElems() {\n    return MutableArrayRef<Expr *>(getInscanCopyArrayTemps().end(),\n                                   varlist_size());\n  }\n  ArrayRef<const Expr *> getInscanCopyArrayElems() const {\n    return llvm::makeArrayRef(getInscanCopyArrayTemps().end(), varlist_size());\n  }\n\npublic:\n  /// Creates clause with a list of variables \\a VL.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param ModifierLoc Modifier location.\n  /// \\param ColonLoc Location of ':'.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param VL The variables in the clause.\n  /// \\param QualifierLoc The nested-name qualifier with location information\n  /// \\param NameInfo The full name info for reduction identifier.\n  /// \\param Privates List of helper expressions for proper generation of\n  /// private copies.\n  /// \\param LHSExprs List of helper expressions for proper generation of\n  /// assignment operation required for copyprivate clause. This list represents\n  /// LHSs of the reduction expressions.\n  /// \\param RHSExprs List of helper expressions for proper generation of\n  /// assignment operation required for copyprivate clause. This list represents\n  /// RHSs of the reduction expressions.\n  /// Also, variables in these expressions are used for proper initialization of\n  /// reduction copies.\n  /// \\param ReductionOps List of helper expressions that represents reduction\n  /// expressions:\n  /// \\code\n  /// LHSExprs binop RHSExprs;\n  /// operator binop(LHSExpr, RHSExpr);\n  /// <CutomReduction>(LHSExpr, RHSExpr);\n  /// \\endcode\n  /// Required for proper codegen of final reduction operation performed by the\n  /// reduction clause.\n  /// \\param CopyOps List of copy operations for inscan reductions:\n  /// \\code\n  /// TempExprs = LHSExprs;\n  /// \\endcode\n  /// \\param CopyArrayTemps Temp arrays for prefix sums.\n  /// \\param CopyArrayElems Temp arrays for prefix sums.\n  /// \\param PreInit Statement that must be executed before entering the OpenMP\n  /// region with this clause.\n  /// \\param PostUpdate Expression that must be executed after exit from the\n  /// OpenMP region with this clause.\n  static OMPReductionClause *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation LParenLoc,\n         SourceLocation ModifierLoc, SourceLocation ColonLoc,\n         SourceLocation EndLoc, OpenMPReductionClauseModifier Modifier,\n         ArrayRef<Expr *> VL, NestedNameSpecifierLoc QualifierLoc,\n         const DeclarationNameInfo &NameInfo, ArrayRef<Expr *> Privates,\n         ArrayRef<Expr *> LHSExprs, ArrayRef<Expr *> RHSExprs,\n         ArrayRef<Expr *> ReductionOps, ArrayRef<Expr *> CopyOps,\n         ArrayRef<Expr *> CopyArrayTemps, ArrayRef<Expr *> CopyArrayElems,\n         Stmt *PreInit, Expr *PostUpdate);\n\n  /// Creates an empty clause with the place for \\a N variables.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of variables.\n  /// \\param Modifier Reduction modifier.\n  static OMPReductionClause *\n  CreateEmpty(const ASTContext &C, unsigned N,\n              OpenMPReductionClauseModifier Modifier);\n\n  /// Returns modifier.\n  OpenMPReductionClauseModifier getModifier() const { return Modifier; }\n\n  /// Returns modifier location.\n  SourceLocation getModifierLoc() const { return ModifierLoc; }\n\n  /// Gets location of ':' symbol in clause.\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  /// Gets the name info for specified reduction identifier.\n  const DeclarationNameInfo &getNameInfo() const { return NameInfo; }\n\n  /// Gets the nested name specifier.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  using helper_expr_iterator = MutableArrayRef<Expr *>::iterator;\n  using helper_expr_const_iterator = ArrayRef<const Expr *>::iterator;\n  using helper_expr_range = llvm::iterator_range<helper_expr_iterator>;\n  using helper_expr_const_range =\n      llvm::iterator_range<helper_expr_const_iterator>;\n\n  helper_expr_const_range privates() const {\n    return helper_expr_const_range(getPrivates().begin(), getPrivates().end());\n  }\n\n  helper_expr_range privates() {\n    return helper_expr_range(getPrivates().begin(), getPrivates().end());\n  }\n\n  helper_expr_const_range lhs_exprs() const {\n    return helper_expr_const_range(getLHSExprs().begin(), getLHSExprs().end());\n  }\n\n  helper_expr_range lhs_exprs() {\n    return helper_expr_range(getLHSExprs().begin(), getLHSExprs().end());\n  }\n\n  helper_expr_const_range rhs_exprs() const {\n    return helper_expr_const_range(getRHSExprs().begin(), getRHSExprs().end());\n  }\n\n  helper_expr_range rhs_exprs() {\n    return helper_expr_range(getRHSExprs().begin(), getRHSExprs().end());\n  }\n\n  helper_expr_const_range reduction_ops() const {\n    return helper_expr_const_range(getReductionOps().begin(),\n                                   getReductionOps().end());\n  }\n\n  helper_expr_range reduction_ops() {\n    return helper_expr_range(getReductionOps().begin(),\n                             getReductionOps().end());\n  }\n\n  helper_expr_const_range copy_ops() const {\n    return helper_expr_const_range(getInscanCopyOps().begin(),\n                                   getInscanCopyOps().end());\n  }\n\n  helper_expr_range copy_ops() {\n    return helper_expr_range(getInscanCopyOps().begin(),\n                             getInscanCopyOps().end());\n  }\n\n  helper_expr_const_range copy_array_temps() const {\n    return helper_expr_const_range(getInscanCopyArrayTemps().begin(),\n                                   getInscanCopyArrayTemps().end());\n  }\n\n  helper_expr_range copy_array_temps() {\n    return helper_expr_range(getInscanCopyArrayTemps().begin(),\n                             getInscanCopyArrayTemps().end());\n  }\n\n  helper_expr_const_range copy_array_elems() const {\n    return helper_expr_const_range(getInscanCopyArrayElems().begin(),\n                                   getInscanCopyArrayElems().end());\n  }\n\n  helper_expr_range copy_array_elems() {\n    return helper_expr_range(getInscanCopyArrayElems().begin(),\n                             getInscanCopyArrayElems().end());\n  }\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPReductionClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n  const_child_range used_children() const {\n    auto Children = const_cast<OMPReductionClause *>(this)->used_children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_reduction;\n  }\n};\n\n/// This represents clause 'task_reduction' in the '#pragma omp taskgroup'\n/// directives.\n///\n/// \\code\n/// #pragma omp taskgroup task_reduction(+:a,b)\n/// \\endcode\n/// In this example directive '#pragma omp taskgroup' has clause\n/// 'task_reduction' with operator '+' and the variables 'a' and 'b'.\nclass OMPTaskReductionClause final\n    : public OMPVarListClause<OMPTaskReductionClause>,\n      public OMPClauseWithPostUpdate,\n      private llvm::TrailingObjects<OMPTaskReductionClause, Expr *> {\n  friend class OMPClauseReader;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Location of ':'.\n  SourceLocation ColonLoc;\n\n  /// Nested name specifier for C++.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// Name of custom operator.\n  DeclarationNameInfo NameInfo;\n\n  /// Build clause with number of variables \\a N.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param ColonLoc Location of ':'.\n  /// \\param N Number of the variables in the clause.\n  /// \\param QualifierLoc The nested-name qualifier with location information\n  /// \\param NameInfo The full name info for reduction identifier.\n  OMPTaskReductionClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                         SourceLocation ColonLoc, SourceLocation EndLoc,\n                         unsigned N, NestedNameSpecifierLoc QualifierLoc,\n                         const DeclarationNameInfo &NameInfo)\n      : OMPVarListClause<OMPTaskReductionClause>(\n            llvm::omp::OMPC_task_reduction, StartLoc, LParenLoc, EndLoc, N),\n        OMPClauseWithPostUpdate(this), ColonLoc(ColonLoc),\n        QualifierLoc(QualifierLoc), NameInfo(NameInfo) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param N Number of variables.\n  explicit OMPTaskReductionClause(unsigned N)\n      : OMPVarListClause<OMPTaskReductionClause>(\n            llvm::omp::OMPC_task_reduction, SourceLocation(), SourceLocation(),\n            SourceLocation(), N),\n        OMPClauseWithPostUpdate(this) {}\n\n  /// Sets location of ':' symbol in clause.\n  void setColonLoc(SourceLocation CL) { ColonLoc = CL; }\n\n  /// Sets the name info for specified reduction identifier.\n  void setNameInfo(DeclarationNameInfo DNI) { NameInfo = DNI; }\n\n  /// Sets the nested name specifier.\n  void setQualifierLoc(NestedNameSpecifierLoc NSL) { QualifierLoc = NSL; }\n\n  /// Set list of helper expressions, required for proper codegen of the clause.\n  /// These expressions represent private copy of the reduction variable.\n  void setPrivates(ArrayRef<Expr *> Privates);\n\n  /// Get the list of helper privates.\n  MutableArrayRef<Expr *> getPrivates() {\n    return MutableArrayRef<Expr *>(varlist_end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getPrivates() const {\n    return llvm::makeArrayRef(varlist_end(), varlist_size());\n  }\n\n  /// Set list of helper expressions, required for proper codegen of the clause.\n  /// These expressions represent LHS expression in the final reduction\n  /// expression performed by the reduction clause.\n  void setLHSExprs(ArrayRef<Expr *> LHSExprs);\n\n  /// Get the list of helper LHS expressions.\n  MutableArrayRef<Expr *> getLHSExprs() {\n    return MutableArrayRef<Expr *>(getPrivates().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getLHSExprs() const {\n    return llvm::makeArrayRef(getPrivates().end(), varlist_size());\n  }\n\n  /// Set list of helper expressions, required for proper codegen of the clause.\n  /// These expressions represent RHS expression in the final reduction\n  /// expression performed by the reduction clause. Also, variables in these\n  /// expressions are used for proper initialization of reduction copies.\n  void setRHSExprs(ArrayRef<Expr *> RHSExprs);\n\n  ///  Get the list of helper destination expressions.\n  MutableArrayRef<Expr *> getRHSExprs() {\n    return MutableArrayRef<Expr *>(getLHSExprs().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getRHSExprs() const {\n    return llvm::makeArrayRef(getLHSExprs().end(), varlist_size());\n  }\n\n  /// Set list of helper reduction expressions, required for proper\n  /// codegen of the clause. These expressions are binary expressions or\n  /// operator/custom reduction call that calculates new value from source\n  /// helper expressions to destination helper expressions.\n  void setReductionOps(ArrayRef<Expr *> ReductionOps);\n\n  ///  Get the list of helper reduction expressions.\n  MutableArrayRef<Expr *> getReductionOps() {\n    return MutableArrayRef<Expr *>(getRHSExprs().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getReductionOps() const {\n    return llvm::makeArrayRef(getRHSExprs().end(), varlist_size());\n  }\n\npublic:\n  /// Creates clause with a list of variables \\a VL.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param ColonLoc Location of ':'.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param VL The variables in the clause.\n  /// \\param QualifierLoc The nested-name qualifier with location information\n  /// \\param NameInfo The full name info for reduction identifier.\n  /// \\param Privates List of helper expressions for proper generation of\n  /// private copies.\n  /// \\param LHSExprs List of helper expressions for proper generation of\n  /// assignment operation required for copyprivate clause. This list represents\n  /// LHSs of the reduction expressions.\n  /// \\param RHSExprs List of helper expressions for proper generation of\n  /// assignment operation required for copyprivate clause. This list represents\n  /// RHSs of the reduction expressions.\n  /// Also, variables in these expressions are used for proper initialization of\n  /// reduction copies.\n  /// \\param ReductionOps List of helper expressions that represents reduction\n  /// expressions:\n  /// \\code\n  /// LHSExprs binop RHSExprs;\n  /// operator binop(LHSExpr, RHSExpr);\n  /// <CutomReduction>(LHSExpr, RHSExpr);\n  /// \\endcode\n  /// Required for proper codegen of final reduction operation performed by the\n  /// reduction clause.\n  /// \\param PreInit Statement that must be executed before entering the OpenMP\n  /// region with this clause.\n  /// \\param PostUpdate Expression that must be executed after exit from the\n  /// OpenMP region with this clause.\n  static OMPTaskReductionClause *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation LParenLoc,\n         SourceLocation ColonLoc, SourceLocation EndLoc, ArrayRef<Expr *> VL,\n         NestedNameSpecifierLoc QualifierLoc,\n         const DeclarationNameInfo &NameInfo, ArrayRef<Expr *> Privates,\n         ArrayRef<Expr *> LHSExprs, ArrayRef<Expr *> RHSExprs,\n         ArrayRef<Expr *> ReductionOps, Stmt *PreInit, Expr *PostUpdate);\n\n  /// Creates an empty clause with the place for \\a N variables.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of variables.\n  static OMPTaskReductionClause *CreateEmpty(const ASTContext &C, unsigned N);\n\n  /// Gets location of ':' symbol in clause.\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  /// Gets the name info for specified reduction identifier.\n  const DeclarationNameInfo &getNameInfo() const { return NameInfo; }\n\n  /// Gets the nested name specifier.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  using helper_expr_iterator = MutableArrayRef<Expr *>::iterator;\n  using helper_expr_const_iterator = ArrayRef<const Expr *>::iterator;\n  using helper_expr_range = llvm::iterator_range<helper_expr_iterator>;\n  using helper_expr_const_range =\n      llvm::iterator_range<helper_expr_const_iterator>;\n\n  helper_expr_const_range privates() const {\n    return helper_expr_const_range(getPrivates().begin(), getPrivates().end());\n  }\n\n  helper_expr_range privates() {\n    return helper_expr_range(getPrivates().begin(), getPrivates().end());\n  }\n\n  helper_expr_const_range lhs_exprs() const {\n    return helper_expr_const_range(getLHSExprs().begin(), getLHSExprs().end());\n  }\n\n  helper_expr_range lhs_exprs() {\n    return helper_expr_range(getLHSExprs().begin(), getLHSExprs().end());\n  }\n\n  helper_expr_const_range rhs_exprs() const {\n    return helper_expr_const_range(getRHSExprs().begin(), getRHSExprs().end());\n  }\n\n  helper_expr_range rhs_exprs() {\n    return helper_expr_range(getRHSExprs().begin(), getRHSExprs().end());\n  }\n\n  helper_expr_const_range reduction_ops() const {\n    return helper_expr_const_range(getReductionOps().begin(),\n                                   getReductionOps().end());\n  }\n\n  helper_expr_range reduction_ops() {\n    return helper_expr_range(getReductionOps().begin(),\n                             getReductionOps().end());\n  }\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPTaskReductionClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_task_reduction;\n  }\n};\n\n/// This represents clause 'in_reduction' in the '#pragma omp task' directives.\n///\n/// \\code\n/// #pragma omp task in_reduction(+:a,b)\n/// \\endcode\n/// In this example directive '#pragma omp task' has clause 'in_reduction' with\n/// operator '+' and the variables 'a' and 'b'.\nclass OMPInReductionClause final\n    : public OMPVarListClause<OMPInReductionClause>,\n      public OMPClauseWithPostUpdate,\n      private llvm::TrailingObjects<OMPInReductionClause, Expr *> {\n  friend class OMPClauseReader;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Location of ':'.\n  SourceLocation ColonLoc;\n\n  /// Nested name specifier for C++.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// Name of custom operator.\n  DeclarationNameInfo NameInfo;\n\n  /// Build clause with number of variables \\a N.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param ColonLoc Location of ':'.\n  /// \\param N Number of the variables in the clause.\n  /// \\param QualifierLoc The nested-name qualifier with location information\n  /// \\param NameInfo The full name info for reduction identifier.\n  OMPInReductionClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                       SourceLocation ColonLoc, SourceLocation EndLoc,\n                       unsigned N, NestedNameSpecifierLoc QualifierLoc,\n                       const DeclarationNameInfo &NameInfo)\n      : OMPVarListClause<OMPInReductionClause>(llvm::omp::OMPC_in_reduction,\n                                               StartLoc, LParenLoc, EndLoc, N),\n        OMPClauseWithPostUpdate(this), ColonLoc(ColonLoc),\n        QualifierLoc(QualifierLoc), NameInfo(NameInfo) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param N Number of variables.\n  explicit OMPInReductionClause(unsigned N)\n      : OMPVarListClause<OMPInReductionClause>(\n            llvm::omp::OMPC_in_reduction, SourceLocation(), SourceLocation(),\n            SourceLocation(), N),\n        OMPClauseWithPostUpdate(this) {}\n\n  /// Sets location of ':' symbol in clause.\n  void setColonLoc(SourceLocation CL) { ColonLoc = CL; }\n\n  /// Sets the name info for specified reduction identifier.\n  void setNameInfo(DeclarationNameInfo DNI) { NameInfo = DNI; }\n\n  /// Sets the nested name specifier.\n  void setQualifierLoc(NestedNameSpecifierLoc NSL) { QualifierLoc = NSL; }\n\n  /// Set list of helper expressions, required for proper codegen of the clause.\n  /// These expressions represent private copy of the reduction variable.\n  void setPrivates(ArrayRef<Expr *> Privates);\n\n  /// Get the list of helper privates.\n  MutableArrayRef<Expr *> getPrivates() {\n    return MutableArrayRef<Expr *>(varlist_end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getPrivates() const {\n    return llvm::makeArrayRef(varlist_end(), varlist_size());\n  }\n\n  /// Set list of helper expressions, required for proper codegen of the clause.\n  /// These expressions represent LHS expression in the final reduction\n  /// expression performed by the reduction clause.\n  void setLHSExprs(ArrayRef<Expr *> LHSExprs);\n\n  /// Get the list of helper LHS expressions.\n  MutableArrayRef<Expr *> getLHSExprs() {\n    return MutableArrayRef<Expr *>(getPrivates().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getLHSExprs() const {\n    return llvm::makeArrayRef(getPrivates().end(), varlist_size());\n  }\n\n  /// Set list of helper expressions, required for proper codegen of the clause.\n  /// These expressions represent RHS expression in the final reduction\n  /// expression performed by the reduction clause. Also, variables in these\n  /// expressions are used for proper initialization of reduction copies.\n  void setRHSExprs(ArrayRef<Expr *> RHSExprs);\n\n  ///  Get the list of helper destination expressions.\n  MutableArrayRef<Expr *> getRHSExprs() {\n    return MutableArrayRef<Expr *>(getLHSExprs().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getRHSExprs() const {\n    return llvm::makeArrayRef(getLHSExprs().end(), varlist_size());\n  }\n\n  /// Set list of helper reduction expressions, required for proper\n  /// codegen of the clause. These expressions are binary expressions or\n  /// operator/custom reduction call that calculates new value from source\n  /// helper expressions to destination helper expressions.\n  void setReductionOps(ArrayRef<Expr *> ReductionOps);\n\n  ///  Get the list of helper reduction expressions.\n  MutableArrayRef<Expr *> getReductionOps() {\n    return MutableArrayRef<Expr *>(getRHSExprs().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getReductionOps() const {\n    return llvm::makeArrayRef(getRHSExprs().end(), varlist_size());\n  }\n\n  /// Set list of helper reduction taskgroup descriptors.\n  void setTaskgroupDescriptors(ArrayRef<Expr *> ReductionOps);\n\n  ///  Get the list of helper reduction taskgroup descriptors.\n  MutableArrayRef<Expr *> getTaskgroupDescriptors() {\n    return MutableArrayRef<Expr *>(getReductionOps().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getTaskgroupDescriptors() const {\n    return llvm::makeArrayRef(getReductionOps().end(), varlist_size());\n  }\n\npublic:\n  /// Creates clause with a list of variables \\a VL.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param ColonLoc Location of ':'.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param VL The variables in the clause.\n  /// \\param QualifierLoc The nested-name qualifier with location information\n  /// \\param NameInfo The full name info for reduction identifier.\n  /// \\param Privates List of helper expressions for proper generation of\n  /// private copies.\n  /// \\param LHSExprs List of helper expressions for proper generation of\n  /// assignment operation required for copyprivate clause. This list represents\n  /// LHSs of the reduction expressions.\n  /// \\param RHSExprs List of helper expressions for proper generation of\n  /// assignment operation required for copyprivate clause. This list represents\n  /// RHSs of the reduction expressions.\n  /// Also, variables in these expressions are used for proper initialization of\n  /// reduction copies.\n  /// \\param ReductionOps List of helper expressions that represents reduction\n  /// expressions:\n  /// \\code\n  /// LHSExprs binop RHSExprs;\n  /// operator binop(LHSExpr, RHSExpr);\n  /// <CutomReduction>(LHSExpr, RHSExpr);\n  /// \\endcode\n  /// Required for proper codegen of final reduction operation performed by the\n  /// reduction clause.\n  /// \\param TaskgroupDescriptors List of helper taskgroup descriptors for\n  /// corresponding items in parent taskgroup task_reduction clause.\n  /// \\param PreInit Statement that must be executed before entering the OpenMP\n  /// region with this clause.\n  /// \\param PostUpdate Expression that must be executed after exit from the\n  /// OpenMP region with this clause.\n  static OMPInReductionClause *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation LParenLoc,\n         SourceLocation ColonLoc, SourceLocation EndLoc, ArrayRef<Expr *> VL,\n         NestedNameSpecifierLoc QualifierLoc,\n         const DeclarationNameInfo &NameInfo, ArrayRef<Expr *> Privates,\n         ArrayRef<Expr *> LHSExprs, ArrayRef<Expr *> RHSExprs,\n         ArrayRef<Expr *> ReductionOps, ArrayRef<Expr *> TaskgroupDescriptors,\n         Stmt *PreInit, Expr *PostUpdate);\n\n  /// Creates an empty clause with the place for \\a N variables.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of variables.\n  static OMPInReductionClause *CreateEmpty(const ASTContext &C, unsigned N);\n\n  /// Gets location of ':' symbol in clause.\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  /// Gets the name info for specified reduction identifier.\n  const DeclarationNameInfo &getNameInfo() const { return NameInfo; }\n\n  /// Gets the nested name specifier.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  using helper_expr_iterator = MutableArrayRef<Expr *>::iterator;\n  using helper_expr_const_iterator = ArrayRef<const Expr *>::iterator;\n  using helper_expr_range = llvm::iterator_range<helper_expr_iterator>;\n  using helper_expr_const_range =\n      llvm::iterator_range<helper_expr_const_iterator>;\n\n  helper_expr_const_range privates() const {\n    return helper_expr_const_range(getPrivates().begin(), getPrivates().end());\n  }\n\n  helper_expr_range privates() {\n    return helper_expr_range(getPrivates().begin(), getPrivates().end());\n  }\n\n  helper_expr_const_range lhs_exprs() const {\n    return helper_expr_const_range(getLHSExprs().begin(), getLHSExprs().end());\n  }\n\n  helper_expr_range lhs_exprs() {\n    return helper_expr_range(getLHSExprs().begin(), getLHSExprs().end());\n  }\n\n  helper_expr_const_range rhs_exprs() const {\n    return helper_expr_const_range(getRHSExprs().begin(), getRHSExprs().end());\n  }\n\n  helper_expr_range rhs_exprs() {\n    return helper_expr_range(getRHSExprs().begin(), getRHSExprs().end());\n  }\n\n  helper_expr_const_range reduction_ops() const {\n    return helper_expr_const_range(getReductionOps().begin(),\n                                   getReductionOps().end());\n  }\n\n  helper_expr_range reduction_ops() {\n    return helper_expr_range(getReductionOps().begin(),\n                             getReductionOps().end());\n  }\n\n  helper_expr_const_range taskgroup_descriptors() const {\n    return helper_expr_const_range(getTaskgroupDescriptors().begin(),\n                                   getTaskgroupDescriptors().end());\n  }\n\n  helper_expr_range taskgroup_descriptors() {\n    return helper_expr_range(getTaskgroupDescriptors().begin(),\n                             getTaskgroupDescriptors().end());\n  }\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPInReductionClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_in_reduction;\n  }\n};\n\n/// This represents clause 'linear' in the '#pragma omp ...'\n/// directives.\n///\n/// \\code\n/// #pragma omp simd linear(a,b : 2)\n/// \\endcode\n/// In this example directive '#pragma omp simd' has clause 'linear'\n/// with variables 'a', 'b' and linear step '2'.\nclass OMPLinearClause final\n    : public OMPVarListClause<OMPLinearClause>,\n      public OMPClauseWithPostUpdate,\n      private llvm::TrailingObjects<OMPLinearClause, Expr *> {\n  friend class OMPClauseReader;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Modifier of 'linear' clause.\n  OpenMPLinearClauseKind Modifier = OMPC_LINEAR_val;\n\n  /// Location of linear modifier if any.\n  SourceLocation ModifierLoc;\n\n  /// Location of ':'.\n  SourceLocation ColonLoc;\n\n  /// Sets the linear step for clause.\n  void setStep(Expr *Step) { *(getFinals().end()) = Step; }\n\n  /// Sets the expression to calculate linear step for clause.\n  void setCalcStep(Expr *CalcStep) { *(getFinals().end() + 1) = CalcStep; }\n\n  /// Build 'linear' clause with given number of variables \\a NumVars.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param ColonLoc Location of ':'.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param NumVars Number of variables.\n  OMPLinearClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                  OpenMPLinearClauseKind Modifier, SourceLocation ModifierLoc,\n                  SourceLocation ColonLoc, SourceLocation EndLoc,\n                  unsigned NumVars)\n      : OMPVarListClause<OMPLinearClause>(llvm::omp::OMPC_linear, StartLoc,\n                                          LParenLoc, EndLoc, NumVars),\n        OMPClauseWithPostUpdate(this), Modifier(Modifier),\n        ModifierLoc(ModifierLoc), ColonLoc(ColonLoc) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param NumVars Number of variables.\n  explicit OMPLinearClause(unsigned NumVars)\n      : OMPVarListClause<OMPLinearClause>(llvm::omp::OMPC_linear,\n                                          SourceLocation(), SourceLocation(),\n                                          SourceLocation(), NumVars),\n        OMPClauseWithPostUpdate(this) {}\n\n  /// Gets the list of initial values for linear variables.\n  ///\n  /// There are NumVars expressions with initial values allocated after the\n  /// varlist, they are followed by NumVars update expressions (used to update\n  /// the linear variable's value on current iteration) and they are followed by\n  /// NumVars final expressions (used to calculate the linear variable's\n  /// value after the loop body). After these lists, there are 2 helper\n  /// expressions - linear step and a helper to calculate it before the\n  /// loop body (used when the linear step is not constant):\n  ///\n  /// { Vars[] /* in OMPVarListClause */; Privates[]; Inits[]; Updates[];\n  /// Finals[]; Step; CalcStep; }\n  MutableArrayRef<Expr *> getPrivates() {\n    return MutableArrayRef<Expr *>(varlist_end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getPrivates() const {\n    return llvm::makeArrayRef(varlist_end(), varlist_size());\n  }\n\n  MutableArrayRef<Expr *> getInits() {\n    return MutableArrayRef<Expr *>(getPrivates().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getInits() const {\n    return llvm::makeArrayRef(getPrivates().end(), varlist_size());\n  }\n\n  /// Sets the list of update expressions for linear variables.\n  MutableArrayRef<Expr *> getUpdates() {\n    return MutableArrayRef<Expr *>(getInits().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getUpdates() const {\n    return llvm::makeArrayRef(getInits().end(), varlist_size());\n  }\n\n  /// Sets the list of final update expressions for linear variables.\n  MutableArrayRef<Expr *> getFinals() {\n    return MutableArrayRef<Expr *>(getUpdates().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getFinals() const {\n    return llvm::makeArrayRef(getUpdates().end(), varlist_size());\n  }\n\n  /// Gets the list of used expressions for linear variables.\n  MutableArrayRef<Expr *> getUsedExprs() {\n    return MutableArrayRef<Expr *>(getFinals().end() + 2, varlist_size() + 1);\n  }\n  ArrayRef<const Expr *> getUsedExprs() const {\n    return llvm::makeArrayRef(getFinals().end() + 2, varlist_size() + 1);\n  }\n\n  /// Sets the list of the copies of original linear variables.\n  /// \\param PL List of expressions.\n  void setPrivates(ArrayRef<Expr *> PL);\n\n  /// Sets the list of the initial values for linear variables.\n  /// \\param IL List of expressions.\n  void setInits(ArrayRef<Expr *> IL);\n\npublic:\n  /// Creates clause with a list of variables \\a VL and a linear step\n  /// \\a Step.\n  ///\n  /// \\param C AST Context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param Modifier Modifier of 'linear' clause.\n  /// \\param ModifierLoc Modifier location.\n  /// \\param ColonLoc Location of ':'.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param VL List of references to the variables.\n  /// \\param PL List of private copies of original variables.\n  /// \\param IL List of initial values for the variables.\n  /// \\param Step Linear step.\n  /// \\param CalcStep Calculation of the linear step.\n  /// \\param PreInit Statement that must be executed before entering the OpenMP\n  /// region with this clause.\n  /// \\param PostUpdate Expression that must be executed after exit from the\n  /// OpenMP region with this clause.\n  static OMPLinearClause *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation LParenLoc,\n         OpenMPLinearClauseKind Modifier, SourceLocation ModifierLoc,\n         SourceLocation ColonLoc, SourceLocation EndLoc, ArrayRef<Expr *> VL,\n         ArrayRef<Expr *> PL, ArrayRef<Expr *> IL, Expr *Step, Expr *CalcStep,\n         Stmt *PreInit, Expr *PostUpdate);\n\n  /// Creates an empty clause with the place for \\a NumVars variables.\n  ///\n  /// \\param C AST context.\n  /// \\param NumVars Number of variables.\n  static OMPLinearClause *CreateEmpty(const ASTContext &C, unsigned NumVars);\n\n  /// Set modifier.\n  void setModifier(OpenMPLinearClauseKind Kind) { Modifier = Kind; }\n\n  /// Return modifier.\n  OpenMPLinearClauseKind getModifier() const { return Modifier; }\n\n  /// Set modifier location.\n  void setModifierLoc(SourceLocation Loc) { ModifierLoc = Loc; }\n\n  /// Return modifier location.\n  SourceLocation getModifierLoc() const { return ModifierLoc; }\n\n  /// Sets the location of ':'.\n  void setColonLoc(SourceLocation Loc) { ColonLoc = Loc; }\n\n  /// Returns the location of ':'.\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  /// Returns linear step.\n  Expr *getStep() { return *(getFinals().end()); }\n\n  /// Returns linear step.\n  const Expr *getStep() const { return *(getFinals().end()); }\n\n  /// Returns expression to calculate linear step.\n  Expr *getCalcStep() { return *(getFinals().end() + 1); }\n\n  /// Returns expression to calculate linear step.\n  const Expr *getCalcStep() const { return *(getFinals().end() + 1); }\n\n  /// Sets the list of update expressions for linear variables.\n  /// \\param UL List of expressions.\n  void setUpdates(ArrayRef<Expr *> UL);\n\n  /// Sets the list of final update expressions for linear variables.\n  /// \\param FL List of expressions.\n  void setFinals(ArrayRef<Expr *> FL);\n\n  /// Sets the list of used expressions for the linear clause.\n  void setUsedExprs(ArrayRef<Expr *> UE);\n\n  using privates_iterator = MutableArrayRef<Expr *>::iterator;\n  using privates_const_iterator = ArrayRef<const Expr *>::iterator;\n  using privates_range = llvm::iterator_range<privates_iterator>;\n  using privates_const_range = llvm::iterator_range<privates_const_iterator>;\n\n  privates_range privates() {\n    return privates_range(getPrivates().begin(), getPrivates().end());\n  }\n\n  privates_const_range privates() const {\n    return privates_const_range(getPrivates().begin(), getPrivates().end());\n  }\n\n  using inits_iterator = MutableArrayRef<Expr *>::iterator;\n  using inits_const_iterator = ArrayRef<const Expr *>::iterator;\n  using inits_range = llvm::iterator_range<inits_iterator>;\n  using inits_const_range = llvm::iterator_range<inits_const_iterator>;\n\n  inits_range inits() {\n    return inits_range(getInits().begin(), getInits().end());\n  }\n\n  inits_const_range inits() const {\n    return inits_const_range(getInits().begin(), getInits().end());\n  }\n\n  using updates_iterator = MutableArrayRef<Expr *>::iterator;\n  using updates_const_iterator = ArrayRef<const Expr *>::iterator;\n  using updates_range = llvm::iterator_range<updates_iterator>;\n  using updates_const_range = llvm::iterator_range<updates_const_iterator>;\n\n  updates_range updates() {\n    return updates_range(getUpdates().begin(), getUpdates().end());\n  }\n\n  updates_const_range updates() const {\n    return updates_const_range(getUpdates().begin(), getUpdates().end());\n  }\n\n  using finals_iterator = MutableArrayRef<Expr *>::iterator;\n  using finals_const_iterator = ArrayRef<const Expr *>::iterator;\n  using finals_range = llvm::iterator_range<finals_iterator>;\n  using finals_const_range = llvm::iterator_range<finals_const_iterator>;\n\n  finals_range finals() {\n    return finals_range(getFinals().begin(), getFinals().end());\n  }\n\n  finals_const_range finals() const {\n    return finals_const_range(getFinals().begin(), getFinals().end());\n  }\n\n  using used_expressions_iterator = MutableArrayRef<Expr *>::iterator;\n  using used_expressions_const_iterator = ArrayRef<const Expr *>::iterator;\n  using used_expressions_range =\n      llvm::iterator_range<used_expressions_iterator>;\n  using used_expressions_const_range =\n      llvm::iterator_range<used_expressions_const_iterator>;\n\n  used_expressions_range used_expressions() {\n    return finals_range(getUsedExprs().begin(), getUsedExprs().end());\n  }\n\n  used_expressions_const_range used_expressions() const {\n    return finals_const_range(getUsedExprs().begin(), getUsedExprs().end());\n  }\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPLinearClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children();\n\n  const_child_range used_children() const {\n    auto Children = const_cast<OMPLinearClause *>(this)->used_children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_linear;\n  }\n};\n\n/// This represents clause 'aligned' in the '#pragma omp ...'\n/// directives.\n///\n/// \\code\n/// #pragma omp simd aligned(a,b : 8)\n/// \\endcode\n/// In this example directive '#pragma omp simd' has clause 'aligned'\n/// with variables 'a', 'b' and alignment '8'.\nclass OMPAlignedClause final\n    : public OMPVarListClause<OMPAlignedClause>,\n      private llvm::TrailingObjects<OMPAlignedClause, Expr *> {\n  friend class OMPClauseReader;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Location of ':'.\n  SourceLocation ColonLoc;\n\n  /// Sets the alignment for clause.\n  void setAlignment(Expr *A) { *varlist_end() = A; }\n\n  /// Build 'aligned' clause with given number of variables \\a NumVars.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param ColonLoc Location of ':'.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param NumVars Number of variables.\n  OMPAlignedClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                   SourceLocation ColonLoc, SourceLocation EndLoc,\n                   unsigned NumVars)\n      : OMPVarListClause<OMPAlignedClause>(llvm::omp::OMPC_aligned, StartLoc,\n                                           LParenLoc, EndLoc, NumVars),\n        ColonLoc(ColonLoc) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param NumVars Number of variables.\n  explicit OMPAlignedClause(unsigned NumVars)\n      : OMPVarListClause<OMPAlignedClause>(llvm::omp::OMPC_aligned,\n                                           SourceLocation(), SourceLocation(),\n                                           SourceLocation(), NumVars) {}\n\npublic:\n  /// Creates clause with a list of variables \\a VL and alignment \\a A.\n  ///\n  /// \\param C AST Context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param ColonLoc Location of ':'.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param VL List of references to the variables.\n  /// \\param A Alignment.\n  static OMPAlignedClause *Create(const ASTContext &C, SourceLocation StartLoc,\n                                  SourceLocation LParenLoc,\n                                  SourceLocation ColonLoc,\n                                  SourceLocation EndLoc, ArrayRef<Expr *> VL,\n                                  Expr *A);\n\n  /// Creates an empty clause with the place for \\a NumVars variables.\n  ///\n  /// \\param C AST context.\n  /// \\param NumVars Number of variables.\n  static OMPAlignedClause *CreateEmpty(const ASTContext &C, unsigned NumVars);\n\n  /// Sets the location of ':'.\n  void setColonLoc(SourceLocation Loc) { ColonLoc = Loc; }\n\n  /// Returns the location of ':'.\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  /// Returns alignment.\n  Expr *getAlignment() { return *varlist_end(); }\n\n  /// Returns alignment.\n  const Expr *getAlignment() const { return *varlist_end(); }\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPAlignedClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_aligned;\n  }\n};\n\n/// This represents clause 'copyin' in the '#pragma omp ...' directives.\n///\n/// \\code\n/// #pragma omp parallel copyin(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp parallel' has clause 'copyin'\n/// with the variables 'a' and 'b'.\nclass OMPCopyinClause final\n    : public OMPVarListClause<OMPCopyinClause>,\n      private llvm::TrailingObjects<OMPCopyinClause, Expr *> {\n  // Class has 3 additional tail allocated arrays:\n  // 1. List of helper expressions for proper generation of assignment operation\n  // required for copyin clause. This list represents sources.\n  // 2. List of helper expressions for proper generation of assignment operation\n  // required for copyin clause. This list represents destinations.\n  // 3. List of helper expressions that represents assignment operation:\n  // \\code\n  // DstExprs = SrcExprs;\n  // \\endcode\n  // Required for proper codegen of propagation of master's thread values of\n  // threadprivate variables to local instances of that variables in other\n  // implicit threads.\n\n  friend class OMPClauseReader;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Build clause with number of variables \\a N.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param N Number of the variables in the clause.\n  OMPCopyinClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                  SourceLocation EndLoc, unsigned N)\n      : OMPVarListClause<OMPCopyinClause>(llvm::omp::OMPC_copyin, StartLoc,\n                                          LParenLoc, EndLoc, N) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param N Number of variables.\n  explicit OMPCopyinClause(unsigned N)\n      : OMPVarListClause<OMPCopyinClause>(llvm::omp::OMPC_copyin,\n                                          SourceLocation(), SourceLocation(),\n                                          SourceLocation(), N) {}\n\n  /// Set list of helper expressions, required for proper codegen of the\n  /// clause. These expressions represent source expression in the final\n  /// assignment statement performed by the copyin clause.\n  void setSourceExprs(ArrayRef<Expr *> SrcExprs);\n\n  /// Get the list of helper source expressions.\n  MutableArrayRef<Expr *> getSourceExprs() {\n    return MutableArrayRef<Expr *>(varlist_end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getSourceExprs() const {\n    return llvm::makeArrayRef(varlist_end(), varlist_size());\n  }\n\n  /// Set list of helper expressions, required for proper codegen of the\n  /// clause. These expressions represent destination expression in the final\n  /// assignment statement performed by the copyin clause.\n  void setDestinationExprs(ArrayRef<Expr *> DstExprs);\n\n  /// Get the list of helper destination expressions.\n  MutableArrayRef<Expr *> getDestinationExprs() {\n    return MutableArrayRef<Expr *>(getSourceExprs().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getDestinationExprs() const {\n    return llvm::makeArrayRef(getSourceExprs().end(), varlist_size());\n  }\n\n  /// Set list of helper assignment expressions, required for proper\n  /// codegen of the clause. These expressions are assignment expressions that\n  /// assign source helper expressions to destination helper expressions\n  /// correspondingly.\n  void setAssignmentOps(ArrayRef<Expr *> AssignmentOps);\n\n  /// Get the list of helper assignment expressions.\n  MutableArrayRef<Expr *> getAssignmentOps() {\n    return MutableArrayRef<Expr *>(getDestinationExprs().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getAssignmentOps() const {\n    return llvm::makeArrayRef(getDestinationExprs().end(), varlist_size());\n  }\n\npublic:\n  /// Creates clause with a list of variables \\a VL.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param VL List of references to the variables.\n  /// \\param SrcExprs List of helper expressions for proper generation of\n  /// assignment operation required for copyin clause. This list represents\n  /// sources.\n  /// \\param DstExprs List of helper expressions for proper generation of\n  /// assignment operation required for copyin clause. This list represents\n  /// destinations.\n  /// \\param AssignmentOps List of helper expressions that represents assignment\n  /// operation:\n  /// \\code\n  /// DstExprs = SrcExprs;\n  /// \\endcode\n  /// Required for proper codegen of propagation of master's thread values of\n  /// threadprivate variables to local instances of that variables in other\n  /// implicit threads.\n  static OMPCopyinClause *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation LParenLoc,\n         SourceLocation EndLoc, ArrayRef<Expr *> VL, ArrayRef<Expr *> SrcExprs,\n         ArrayRef<Expr *> DstExprs, ArrayRef<Expr *> AssignmentOps);\n\n  /// Creates an empty clause with \\a N variables.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of variables.\n  static OMPCopyinClause *CreateEmpty(const ASTContext &C, unsigned N);\n\n  using helper_expr_iterator = MutableArrayRef<Expr *>::iterator;\n  using helper_expr_const_iterator = ArrayRef<const Expr *>::iterator;\n  using helper_expr_range = llvm::iterator_range<helper_expr_iterator>;\n  using helper_expr_const_range =\n      llvm::iterator_range<helper_expr_const_iterator>;\n\n  helper_expr_const_range source_exprs() const {\n    return helper_expr_const_range(getSourceExprs().begin(),\n                                   getSourceExprs().end());\n  }\n\n  helper_expr_range source_exprs() {\n    return helper_expr_range(getSourceExprs().begin(), getSourceExprs().end());\n  }\n\n  helper_expr_const_range destination_exprs() const {\n    return helper_expr_const_range(getDestinationExprs().begin(),\n                                   getDestinationExprs().end());\n  }\n\n  helper_expr_range destination_exprs() {\n    return helper_expr_range(getDestinationExprs().begin(),\n                             getDestinationExprs().end());\n  }\n\n  helper_expr_const_range assignment_ops() const {\n    return helper_expr_const_range(getAssignmentOps().begin(),\n                                   getAssignmentOps().end());\n  }\n\n  helper_expr_range assignment_ops() {\n    return helper_expr_range(getAssignmentOps().begin(),\n                             getAssignmentOps().end());\n  }\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPCopyinClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_copyin;\n  }\n};\n\n/// This represents clause 'copyprivate' in the '#pragma omp ...'\n/// directives.\n///\n/// \\code\n/// #pragma omp single copyprivate(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp single' has clause 'copyprivate'\n/// with the variables 'a' and 'b'.\nclass OMPCopyprivateClause final\n    : public OMPVarListClause<OMPCopyprivateClause>,\n      private llvm::TrailingObjects<OMPCopyprivateClause, Expr *> {\n  friend class OMPClauseReader;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Build clause with number of variables \\a N.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param N Number of the variables in the clause.\n  OMPCopyprivateClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                       SourceLocation EndLoc, unsigned N)\n      : OMPVarListClause<OMPCopyprivateClause>(llvm::omp::OMPC_copyprivate,\n                                               StartLoc, LParenLoc, EndLoc, N) {\n  }\n\n  /// Build an empty clause.\n  ///\n  /// \\param N Number of variables.\n  explicit OMPCopyprivateClause(unsigned N)\n      : OMPVarListClause<OMPCopyprivateClause>(\n            llvm::omp::OMPC_copyprivate, SourceLocation(), SourceLocation(),\n            SourceLocation(), N) {}\n\n  /// Set list of helper expressions, required for proper codegen of the\n  /// clause. These expressions represent source expression in the final\n  /// assignment statement performed by the copyprivate clause.\n  void setSourceExprs(ArrayRef<Expr *> SrcExprs);\n\n  /// Get the list of helper source expressions.\n  MutableArrayRef<Expr *> getSourceExprs() {\n    return MutableArrayRef<Expr *>(varlist_end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getSourceExprs() const {\n    return llvm::makeArrayRef(varlist_end(), varlist_size());\n  }\n\n  /// Set list of helper expressions, required for proper codegen of the\n  /// clause. These expressions represent destination expression in the final\n  /// assignment statement performed by the copyprivate clause.\n  void setDestinationExprs(ArrayRef<Expr *> DstExprs);\n\n  /// Get the list of helper destination expressions.\n  MutableArrayRef<Expr *> getDestinationExprs() {\n    return MutableArrayRef<Expr *>(getSourceExprs().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getDestinationExprs() const {\n    return llvm::makeArrayRef(getSourceExprs().end(), varlist_size());\n  }\n\n  /// Set list of helper assignment expressions, required for proper\n  /// codegen of the clause. These expressions are assignment expressions that\n  /// assign source helper expressions to destination helper expressions\n  /// correspondingly.\n  void setAssignmentOps(ArrayRef<Expr *> AssignmentOps);\n\n  /// Get the list of helper assignment expressions.\n  MutableArrayRef<Expr *> getAssignmentOps() {\n    return MutableArrayRef<Expr *>(getDestinationExprs().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getAssignmentOps() const {\n    return llvm::makeArrayRef(getDestinationExprs().end(), varlist_size());\n  }\n\npublic:\n  /// Creates clause with a list of variables \\a VL.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param VL List of references to the variables.\n  /// \\param SrcExprs List of helper expressions for proper generation of\n  /// assignment operation required for copyprivate clause. This list represents\n  /// sources.\n  /// \\param DstExprs List of helper expressions for proper generation of\n  /// assignment operation required for copyprivate clause. This list represents\n  /// destinations.\n  /// \\param AssignmentOps List of helper expressions that represents assignment\n  /// operation:\n  /// \\code\n  /// DstExprs = SrcExprs;\n  /// \\endcode\n  /// Required for proper codegen of final assignment performed by the\n  /// copyprivate clause.\n  static OMPCopyprivateClause *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation LParenLoc,\n         SourceLocation EndLoc, ArrayRef<Expr *> VL, ArrayRef<Expr *> SrcExprs,\n         ArrayRef<Expr *> DstExprs, ArrayRef<Expr *> AssignmentOps);\n\n  /// Creates an empty clause with \\a N variables.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of variables.\n  static OMPCopyprivateClause *CreateEmpty(const ASTContext &C, unsigned N);\n\n  using helper_expr_iterator = MutableArrayRef<Expr *>::iterator;\n  using helper_expr_const_iterator = ArrayRef<const Expr *>::iterator;\n  using helper_expr_range = llvm::iterator_range<helper_expr_iterator>;\n  using helper_expr_const_range =\n      llvm::iterator_range<helper_expr_const_iterator>;\n\n  helper_expr_const_range source_exprs() const {\n    return helper_expr_const_range(getSourceExprs().begin(),\n                                   getSourceExprs().end());\n  }\n\n  helper_expr_range source_exprs() {\n    return helper_expr_range(getSourceExprs().begin(), getSourceExprs().end());\n  }\n\n  helper_expr_const_range destination_exprs() const {\n    return helper_expr_const_range(getDestinationExprs().begin(),\n                                   getDestinationExprs().end());\n  }\n\n  helper_expr_range destination_exprs() {\n    return helper_expr_range(getDestinationExprs().begin(),\n                             getDestinationExprs().end());\n  }\n\n  helper_expr_const_range assignment_ops() const {\n    return helper_expr_const_range(getAssignmentOps().begin(),\n                                   getAssignmentOps().end());\n  }\n\n  helper_expr_range assignment_ops() {\n    return helper_expr_range(getAssignmentOps().begin(),\n                             getAssignmentOps().end());\n  }\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPCopyprivateClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_copyprivate;\n  }\n};\n\n/// This represents implicit clause 'flush' for the '#pragma omp flush'\n/// directive.\n/// This clause does not exist by itself, it can be only as a part of 'omp\n/// flush' directive. This clause is introduced to keep the original structure\n/// of \\a OMPExecutableDirective class and its derivatives and to use the\n/// existing infrastructure of clauses with the list of variables.\n///\n/// \\code\n/// #pragma omp flush(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp flush' has implicit clause 'flush'\n/// with the variables 'a' and 'b'.\nclass OMPFlushClause final\n    : public OMPVarListClause<OMPFlushClause>,\n      private llvm::TrailingObjects<OMPFlushClause, Expr *> {\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Build clause with number of variables \\a N.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param N Number of the variables in the clause.\n  OMPFlushClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                 SourceLocation EndLoc, unsigned N)\n      : OMPVarListClause<OMPFlushClause>(llvm::omp::OMPC_flush, StartLoc,\n                                         LParenLoc, EndLoc, N) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param N Number of variables.\n  explicit OMPFlushClause(unsigned N)\n      : OMPVarListClause<OMPFlushClause>(llvm::omp::OMPC_flush,\n                                         SourceLocation(), SourceLocation(),\n                                         SourceLocation(), N) {}\n\npublic:\n  /// Creates clause with a list of variables \\a VL.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param VL List of references to the variables.\n  static OMPFlushClause *Create(const ASTContext &C, SourceLocation StartLoc,\n                                SourceLocation LParenLoc, SourceLocation EndLoc,\n                                ArrayRef<Expr *> VL);\n\n  /// Creates an empty clause with \\a N variables.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of variables.\n  static OMPFlushClause *CreateEmpty(const ASTContext &C, unsigned N);\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPFlushClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_flush;\n  }\n};\n\n/// This represents implicit clause 'depobj' for the '#pragma omp depobj'\n/// directive.\n/// This clause does not exist by itself, it can be only as a part of 'omp\n/// depobj' directive. This clause is introduced to keep the original structure\n/// of \\a OMPExecutableDirective class and its derivatives and to use the\n/// existing infrastructure of clauses with the list of variables.\n///\n/// \\code\n/// #pragma omp depobj(a) destroy\n/// \\endcode\n/// In this example directive '#pragma omp depobj' has implicit clause 'depobj'\n/// with the depobj 'a'.\nclass OMPDepobjClause final : public OMPClause {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Chunk size.\n  Expr *Depobj = nullptr;\n\n  /// Build clause with number of variables \\a N.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  OMPDepobjClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                  SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_depobj, StartLoc, EndLoc),\n        LParenLoc(LParenLoc) {}\n\n  /// Build an empty clause.\n  ///\n  explicit OMPDepobjClause()\n      : OMPClause(llvm::omp::OMPC_depobj, SourceLocation(), SourceLocation()) {}\n\n  void setDepobj(Expr *E) { Depobj = E; }\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\npublic:\n  /// Creates clause.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param Depobj depobj expression associated with the 'depobj' directive.\n  static OMPDepobjClause *Create(const ASTContext &C, SourceLocation StartLoc,\n                                 SourceLocation LParenLoc,\n                                 SourceLocation EndLoc, Expr *Depobj);\n\n  /// Creates an empty clause.\n  ///\n  /// \\param C AST context.\n  static OMPDepobjClause *CreateEmpty(const ASTContext &C);\n\n  /// Returns depobj expression associated with the clause.\n  Expr *getDepobj() { return Depobj; }\n  const Expr *getDepobj() const { return Depobj; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(&Depobj),\n                       reinterpret_cast<Stmt **>(&Depobj) + 1);\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPDepobjClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_depobj;\n  }\n};\n\n/// This represents implicit clause 'depend' for the '#pragma omp task'\n/// directive.\n///\n/// \\code\n/// #pragma omp task depend(in:a,b)\n/// \\endcode\n/// In this example directive '#pragma omp task' with clause 'depend' with the\n/// variables 'a' and 'b' with dependency 'in'.\nclass OMPDependClause final\n    : public OMPVarListClause<OMPDependClause>,\n      private llvm::TrailingObjects<OMPDependClause, Expr *> {\n  friend class OMPClauseReader;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Dependency type (one of in, out, inout).\n  OpenMPDependClauseKind DepKind = OMPC_DEPEND_unknown;\n\n  /// Dependency type location.\n  SourceLocation DepLoc;\n\n  /// Colon location.\n  SourceLocation ColonLoc;\n\n  /// Number of loops, associated with the depend clause.\n  unsigned NumLoops = 0;\n\n  /// Build clause with number of variables \\a N.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param N Number of the variables in the clause.\n  /// \\param NumLoops Number of loops that is associated with this depend\n  /// clause.\n  OMPDependClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                  SourceLocation EndLoc, unsigned N, unsigned NumLoops)\n      : OMPVarListClause<OMPDependClause>(llvm::omp::OMPC_depend, StartLoc,\n                                          LParenLoc, EndLoc, N),\n        NumLoops(NumLoops) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param N Number of variables.\n  /// \\param NumLoops Number of loops that is associated with this depend\n  /// clause.\n  explicit OMPDependClause(unsigned N, unsigned NumLoops)\n      : OMPVarListClause<OMPDependClause>(llvm::omp::OMPC_depend,\n                                          SourceLocation(), SourceLocation(),\n                                          SourceLocation(), N),\n        NumLoops(NumLoops) {}\n\n  /// Set dependency kind.\n  void setDependencyKind(OpenMPDependClauseKind K) { DepKind = K; }\n\n  /// Set dependency kind and its location.\n  void setDependencyLoc(SourceLocation Loc) { DepLoc = Loc; }\n\n  /// Set colon location.\n  void setColonLoc(SourceLocation Loc) { ColonLoc = Loc; }\n\n  /// Sets optional dependency modifier.\n  void setModifier(Expr *DepModifier);\n\npublic:\n  /// Creates clause with a list of variables \\a VL.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param DepKind Dependency type.\n  /// \\param DepLoc Location of the dependency type.\n  /// \\param ColonLoc Colon location.\n  /// \\param VL List of references to the variables.\n  /// \\param NumLoops Number of loops that is associated with this depend\n  /// clause.\n  static OMPDependClause *Create(const ASTContext &C, SourceLocation StartLoc,\n                                 SourceLocation LParenLoc,\n                                 SourceLocation EndLoc, Expr *DepModifier,\n                                 OpenMPDependClauseKind DepKind,\n                                 SourceLocation DepLoc, SourceLocation ColonLoc,\n                                 ArrayRef<Expr *> VL, unsigned NumLoops);\n\n  /// Creates an empty clause with \\a N variables.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of variables.\n  /// \\param NumLoops Number of loops that is associated with this depend\n  /// clause.\n  static OMPDependClause *CreateEmpty(const ASTContext &C, unsigned N,\n                                      unsigned NumLoops);\n\n  /// Get dependency type.\n  OpenMPDependClauseKind getDependencyKind() const { return DepKind; }\n\n  /// Return optional depend modifier.\n  Expr *getModifier();\n  const Expr *getModifier() const {\n    return const_cast<OMPDependClause *>(this)->getModifier();\n  }\n\n  /// Get dependency type location.\n  SourceLocation getDependencyLoc() const { return DepLoc; }\n\n  /// Get colon location.\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  /// Get number of loops associated with the clause.\n  unsigned getNumLoops() const { return NumLoops; }\n\n  /// Set the loop data for the depend clauses with 'sink|source' kind of\n  /// dependency.\n  void setLoopData(unsigned NumLoop, Expr *Cnt);\n\n  /// Get the loop data.\n  Expr *getLoopData(unsigned NumLoop);\n  const Expr *getLoopData(unsigned NumLoop) const;\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPDependClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_depend;\n  }\n};\n\n/// This represents 'device' clause in the '#pragma omp ...'\n/// directive.\n///\n/// \\code\n/// #pragma omp target device(a)\n/// \\endcode\n/// In this example directive '#pragma omp target' has clause 'device'\n/// with single expression 'a'.\nclass OMPDeviceClause : public OMPClause, public OMPClauseWithPreInit {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Device clause modifier.\n  OpenMPDeviceClauseModifier Modifier = OMPC_DEVICE_unknown;\n\n  /// Location of the modifier.\n  SourceLocation ModifierLoc;\n\n  /// Device number.\n  Stmt *Device = nullptr;\n\n  /// Set the device number.\n  ///\n  /// \\param E Device number.\n  void setDevice(Expr *E) { Device = E; }\n\n  /// Sets modifier.\n  void setModifier(OpenMPDeviceClauseModifier M) { Modifier = M; }\n\n  /// Setst modifier location.\n  void setModifierLoc(SourceLocation Loc) { ModifierLoc = Loc; }\n\npublic:\n  /// Build 'device' clause.\n  ///\n  /// \\param Modifier Clause modifier.\n  /// \\param E Expression associated with this clause.\n  /// \\param CaptureRegion Innermost OpenMP region where expressions in this\n  /// clause must be captured.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param ModifierLoc Modifier location.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  OMPDeviceClause(OpenMPDeviceClauseModifier Modifier, Expr *E, Stmt *HelperE,\n                  OpenMPDirectiveKind CaptureRegion, SourceLocation StartLoc,\n                  SourceLocation LParenLoc, SourceLocation ModifierLoc,\n                  SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_device, StartLoc, EndLoc),\n        OMPClauseWithPreInit(this), LParenLoc(LParenLoc), Modifier(Modifier),\n        ModifierLoc(ModifierLoc), Device(E) {\n    setPreInitStmt(HelperE, CaptureRegion);\n  }\n\n  /// Build an empty clause.\n  OMPDeviceClause()\n      : OMPClause(llvm::omp::OMPC_device, SourceLocation(), SourceLocation()),\n        OMPClauseWithPreInit(this) {}\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Return device number.\n  Expr *getDevice() { return cast<Expr>(Device); }\n\n  /// Return device number.\n  Expr *getDevice() const { return cast<Expr>(Device); }\n\n  /// Gets modifier.\n  OpenMPDeviceClauseModifier getModifier() const { return Modifier; }\n\n  /// Gets modifier location.\n  SourceLocation getModifierLoc() const { return ModifierLoc; }\n\n  child_range children() { return child_range(&Device, &Device + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Device, &Device + 1);\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_device;\n  }\n};\n\n/// This represents 'threads' clause in the '#pragma omp ...' directive.\n///\n/// \\code\n/// #pragma omp ordered threads\n/// \\endcode\n/// In this example directive '#pragma omp ordered' has simple 'threads' clause.\nclass OMPThreadsClause : public OMPClause {\npublic:\n  /// Build 'threads' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPThreadsClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_threads, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPThreadsClause()\n      : OMPClause(llvm::omp::OMPC_threads, SourceLocation(), SourceLocation()) {\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_threads;\n  }\n};\n\n/// This represents 'simd' clause in the '#pragma omp ...' directive.\n///\n/// \\code\n/// #pragma omp ordered simd\n/// \\endcode\n/// In this example directive '#pragma omp ordered' has simple 'simd' clause.\nclass OMPSIMDClause : public OMPClause {\npublic:\n  /// Build 'simd' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPSIMDClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_simd, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPSIMDClause()\n      : OMPClause(llvm::omp::OMPC_simd, SourceLocation(), SourceLocation()) {}\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_simd;\n  }\n};\n\n/// Struct that defines common infrastructure to handle mappable\n/// expressions used in OpenMP clauses.\nclass OMPClauseMappableExprCommon {\npublic:\n  /// Class that represents a component of a mappable expression. E.g.\n  /// for an expression S.a, the first component is a declaration reference\n  /// expression associated with 'S' and the second is a member expression\n  /// associated with the field declaration 'a'. If the expression is an array\n  /// subscript it may not have any associated declaration. In that case the\n  /// associated declaration is set to nullptr.\n  class MappableComponent {\n    /// Pair of Expression and Non-contiguous pair  associated with the\n    /// component.\n    llvm::PointerIntPair<Expr *, 1, bool> AssociatedExpressionNonContiguousPr;\n\n    /// Declaration associated with the declaration. If the component does\n    /// not have a declaration (e.g. array subscripts or section), this is set\n    /// to nullptr.\n    ValueDecl *AssociatedDeclaration = nullptr;\n\n  public:\n    explicit MappableComponent() = default;\n    explicit MappableComponent(Expr *AssociatedExpression,\n                               ValueDecl *AssociatedDeclaration,\n                               bool IsNonContiguous)\n        : AssociatedExpressionNonContiguousPr(AssociatedExpression,\n                                              IsNonContiguous),\n          AssociatedDeclaration(\n              AssociatedDeclaration\n                  ? cast<ValueDecl>(AssociatedDeclaration->getCanonicalDecl())\n                  : nullptr) {}\n\n    Expr *getAssociatedExpression() const {\n      return AssociatedExpressionNonContiguousPr.getPointer();\n    }\n\n    bool isNonContiguous() const {\n      return AssociatedExpressionNonContiguousPr.getInt();\n    }\n\n    ValueDecl *getAssociatedDeclaration() const {\n      return AssociatedDeclaration;\n    }\n  };\n\n  // List of components of an expression. This first one is the whole\n  // expression and the last one is the base expression.\n  using MappableExprComponentList = SmallVector<MappableComponent, 8>;\n  using MappableExprComponentListRef = ArrayRef<MappableComponent>;\n\n  // List of all component lists associated to the same base declaration.\n  // E.g. if both 'S.a' and 'S.b' are a mappable expressions, each will have\n  // their component list but the same base declaration 'S'.\n  using MappableExprComponentLists = SmallVector<MappableExprComponentList, 8>;\n  using MappableExprComponentListsRef = ArrayRef<MappableExprComponentList>;\n\nprotected:\n  // Return the total number of elements in a list of component lists.\n  static unsigned\n  getComponentsTotalNumber(MappableExprComponentListsRef ComponentLists);\n\n  // Return the total number of elements in a list of declarations. All\n  // declarations are expected to be canonical.\n  static unsigned\n  getUniqueDeclarationsTotalNumber(ArrayRef<const ValueDecl *> Declarations);\n};\n\n/// This structure contains all sizes needed for by an\n/// OMPMappableExprListClause.\nstruct OMPMappableExprListSizeTy {\n  /// Number of expressions listed.\n  unsigned NumVars;\n  /// Number of unique base declarations.\n  unsigned NumUniqueDeclarations;\n  /// Number of component lists.\n  unsigned NumComponentLists;\n  /// Total number of expression components.\n  unsigned NumComponents;\n  OMPMappableExprListSizeTy() = default;\n  OMPMappableExprListSizeTy(unsigned NumVars, unsigned NumUniqueDeclarations,\n                            unsigned NumComponentLists, unsigned NumComponents)\n      : NumVars(NumVars), NumUniqueDeclarations(NumUniqueDeclarations),\n        NumComponentLists(NumComponentLists), NumComponents(NumComponents) {}\n};\n\n/// This represents clauses with a list of expressions that are mappable.\n/// Examples of these clauses are 'map' in\n/// '#pragma omp target [enter|exit] [data]...' directives, and  'to' and 'from\n/// in '#pragma omp target update...' directives.\ntemplate <class T>\nclass OMPMappableExprListClause : public OMPVarListClause<T>,\n                                  public OMPClauseMappableExprCommon {\n  friend class OMPClauseReader;\n\n  /// Number of unique declarations in this clause.\n  unsigned NumUniqueDeclarations;\n\n  /// Number of component lists in this clause.\n  unsigned NumComponentLists;\n\n  /// Total number of components in this clause.\n  unsigned NumComponents;\n\n  /// Whether this clause is possible to have user-defined mappers associated.\n  /// It should be true for map, to, and from clauses, and false for\n  /// use_device_ptr and is_device_ptr.\n  const bool SupportsMapper;\n\n  /// C++ nested name specifier for the associated user-defined mapper.\n  NestedNameSpecifierLoc MapperQualifierLoc;\n\n  /// The associated user-defined mapper identifier information.\n  DeclarationNameInfo MapperIdInfo;\n\nprotected:\n  /// Build a clause for \\a NumUniqueDeclarations declarations, \\a\n  /// NumComponentLists total component lists, and \\a NumComponents total\n  /// components.\n  ///\n  /// \\param K Kind of the clause.\n  /// \\param Locs Locations needed to build a mappable clause. It includes 1)\n  /// StartLoc: starting location of the clause (the clause keyword); 2)\n  /// LParenLoc: location of '('; 3) EndLoc: ending location of the clause.\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  /// \\param SupportsMapper Indicates whether this clause is possible to have\n  /// user-defined mappers associated.\n  /// \\param MapperQualifierLocPtr C++ nested name specifier for the associated\n  /// user-defined mapper.\n  /// \\param MapperIdInfoPtr The identifier of associated user-defined mapper.\n  OMPMappableExprListClause(\n      OpenMPClauseKind K, const OMPVarListLocTy &Locs,\n      const OMPMappableExprListSizeTy &Sizes, bool SupportsMapper = false,\n      NestedNameSpecifierLoc *MapperQualifierLocPtr = nullptr,\n      DeclarationNameInfo *MapperIdInfoPtr = nullptr)\n      : OMPVarListClause<T>(K, Locs.StartLoc, Locs.LParenLoc, Locs.EndLoc,\n                            Sizes.NumVars),\n        NumUniqueDeclarations(Sizes.NumUniqueDeclarations),\n        NumComponentLists(Sizes.NumComponentLists),\n        NumComponents(Sizes.NumComponents), SupportsMapper(SupportsMapper) {\n    if (MapperQualifierLocPtr)\n      MapperQualifierLoc = *MapperQualifierLocPtr;\n    if (MapperIdInfoPtr)\n      MapperIdInfo = *MapperIdInfoPtr;\n  }\n\n  /// Get the unique declarations that are in the trailing objects of the\n  /// class.\n  MutableArrayRef<ValueDecl *> getUniqueDeclsRef() {\n    return MutableArrayRef<ValueDecl *>(\n        static_cast<T *>(this)->template getTrailingObjects<ValueDecl *>(),\n        NumUniqueDeclarations);\n  }\n\n  /// Get the unique declarations that are in the trailing objects of the\n  /// class.\n  ArrayRef<ValueDecl *> getUniqueDeclsRef() const {\n    return ArrayRef<ValueDecl *>(\n        static_cast<const T *>(this)\n            ->template getTrailingObjects<ValueDecl *>(),\n        NumUniqueDeclarations);\n  }\n\n  /// Set the unique declarations that are in the trailing objects of the\n  /// class.\n  void setUniqueDecls(ArrayRef<ValueDecl *> UDs) {\n    assert(UDs.size() == NumUniqueDeclarations &&\n           \"Unexpected amount of unique declarations.\");\n    std::copy(UDs.begin(), UDs.end(), getUniqueDeclsRef().begin());\n  }\n\n  /// Get the number of lists per declaration that are in the trailing\n  /// objects of the class.\n  MutableArrayRef<unsigned> getDeclNumListsRef() {\n    return MutableArrayRef<unsigned>(\n        static_cast<T *>(this)->template getTrailingObjects<unsigned>(),\n        NumUniqueDeclarations);\n  }\n\n  /// Get the number of lists per declaration that are in the trailing\n  /// objects of the class.\n  ArrayRef<unsigned> getDeclNumListsRef() const {\n    return ArrayRef<unsigned>(\n        static_cast<const T *>(this)->template getTrailingObjects<unsigned>(),\n        NumUniqueDeclarations);\n  }\n\n  /// Set the number of lists per declaration that are in the trailing\n  /// objects of the class.\n  void setDeclNumLists(ArrayRef<unsigned> DNLs) {\n    assert(DNLs.size() == NumUniqueDeclarations &&\n           \"Unexpected amount of list numbers.\");\n    std::copy(DNLs.begin(), DNLs.end(), getDeclNumListsRef().begin());\n  }\n\n  /// Get the cumulative component lists sizes that are in the trailing\n  /// objects of the class. They are appended after the number of lists.\n  MutableArrayRef<unsigned> getComponentListSizesRef() {\n    return MutableArrayRef<unsigned>(\n        static_cast<T *>(this)->template getTrailingObjects<unsigned>() +\n            NumUniqueDeclarations,\n        NumComponentLists);\n  }\n\n  /// Get the cumulative component lists sizes that are in the trailing\n  /// objects of the class. They are appended after the number of lists.\n  ArrayRef<unsigned> getComponentListSizesRef() const {\n    return ArrayRef<unsigned>(\n        static_cast<const T *>(this)->template getTrailingObjects<unsigned>() +\n            NumUniqueDeclarations,\n        NumComponentLists);\n  }\n\n  /// Set the cumulative component lists sizes that are in the trailing\n  /// objects of the class.\n  void setComponentListSizes(ArrayRef<unsigned> CLSs) {\n    assert(CLSs.size() == NumComponentLists &&\n           \"Unexpected amount of component lists.\");\n    std::copy(CLSs.begin(), CLSs.end(), getComponentListSizesRef().begin());\n  }\n\n  /// Get the components that are in the trailing objects of the class.\n  MutableArrayRef<MappableComponent> getComponentsRef() {\n    return MutableArrayRef<MappableComponent>(\n        static_cast<T *>(this)\n            ->template getTrailingObjects<MappableComponent>(),\n        NumComponents);\n  }\n\n  /// Get the components that are in the trailing objects of the class.\n  ArrayRef<MappableComponent> getComponentsRef() const {\n    return ArrayRef<MappableComponent>(\n        static_cast<const T *>(this)\n            ->template getTrailingObjects<MappableComponent>(),\n        NumComponents);\n  }\n\n  /// Set the components that are in the trailing objects of the class.\n  /// This requires the list sizes so that it can also fill the original\n  /// expressions, which are the first component of each list.\n  void setComponents(ArrayRef<MappableComponent> Components,\n                     ArrayRef<unsigned> CLSs) {\n    assert(Components.size() == NumComponents &&\n           \"Unexpected amount of component lists.\");\n    assert(CLSs.size() == NumComponentLists &&\n           \"Unexpected amount of list sizes.\");\n    std::copy(Components.begin(), Components.end(), getComponentsRef().begin());\n  }\n\n  /// Fill the clause information from the list of declarations and\n  /// associated component lists.\n  void setClauseInfo(ArrayRef<ValueDecl *> Declarations,\n                     MappableExprComponentListsRef ComponentLists) {\n    // Perform some checks to make sure the data sizes are consistent with the\n    // information available when the clause was created.\n    assert(getUniqueDeclarationsTotalNumber(Declarations) ==\n               NumUniqueDeclarations &&\n           \"Unexpected number of mappable expression info entries!\");\n    assert(getComponentsTotalNumber(ComponentLists) == NumComponents &&\n           \"Unexpected total number of components!\");\n    assert(Declarations.size() == ComponentLists.size() &&\n           \"Declaration and component lists size is not consistent!\");\n    assert(Declarations.size() == NumComponentLists &&\n           \"Unexpected declaration and component lists size!\");\n\n    // Organize the components by declaration and retrieve the original\n    // expression. Original expressions are always the first component of the\n    // mappable component list.\n    llvm::MapVector<ValueDecl *, SmallVector<MappableExprComponentListRef, 8>>\n        ComponentListMap;\n    {\n      auto CI = ComponentLists.begin();\n      for (auto DI = Declarations.begin(), DE = Declarations.end(); DI != DE;\n           ++DI, ++CI) {\n        assert(!CI->empty() && \"Invalid component list!\");\n        ComponentListMap[*DI].push_back(*CI);\n      }\n    }\n\n    // Iterators of the target storage.\n    auto UniqueDeclarations = getUniqueDeclsRef();\n    auto UDI = UniqueDeclarations.begin();\n\n    auto DeclNumLists = getDeclNumListsRef();\n    auto DNLI = DeclNumLists.begin();\n\n    auto ComponentListSizes = getComponentListSizesRef();\n    auto CLSI = ComponentListSizes.begin();\n\n    auto Components = getComponentsRef();\n    auto CI = Components.begin();\n\n    // Variable to compute the accumulation of the number of components.\n    unsigned PrevSize = 0u;\n\n    // Scan all the declarations and associated component lists.\n    for (auto &M : ComponentListMap) {\n      // The declaration.\n      auto *D = M.first;\n      // The component lists.\n      auto CL = M.second;\n\n      // Initialize the entry.\n      *UDI = D;\n      ++UDI;\n\n      *DNLI = CL.size();\n      ++DNLI;\n\n      // Obtain the cumulative sizes and concatenate all the components in the\n      // reserved storage.\n      for (auto C : CL) {\n        // Accumulate with the previous size.\n        PrevSize += C.size();\n\n        // Save the size.\n        *CLSI = PrevSize;\n        ++CLSI;\n\n        // Append components after the current components iterator.\n        CI = std::copy(C.begin(), C.end(), CI);\n      }\n    }\n  }\n\n  /// Set the nested name specifier of associated user-defined mapper.\n  void setMapperQualifierLoc(NestedNameSpecifierLoc NNSL) {\n    MapperQualifierLoc = NNSL;\n  }\n\n  /// Set the name of associated user-defined mapper.\n  void setMapperIdInfo(DeclarationNameInfo MapperId) {\n    MapperIdInfo = MapperId;\n  }\n\n  /// Get the user-defined mapper references that are in the trailing objects of\n  /// the class.\n  MutableArrayRef<Expr *> getUDMapperRefs() {\n    assert(SupportsMapper &&\n           \"Must be a clause that is possible to have user-defined mappers\");\n    return llvm::makeMutableArrayRef<Expr *>(\n        static_cast<T *>(this)->template getTrailingObjects<Expr *>() +\n            OMPVarListClause<T>::varlist_size(),\n        OMPVarListClause<T>::varlist_size());\n  }\n\n  /// Get the user-defined mappers references that are in the trailing objects\n  /// of the class.\n  ArrayRef<Expr *> getUDMapperRefs() const {\n    assert(SupportsMapper &&\n           \"Must be a clause that is possible to have user-defined mappers\");\n    return llvm::makeArrayRef<Expr *>(\n        static_cast<const T *>(this)->template getTrailingObjects<Expr *>() +\n            OMPVarListClause<T>::varlist_size(),\n        OMPVarListClause<T>::varlist_size());\n  }\n\n  /// Set the user-defined mappers that are in the trailing objects of the\n  /// class.\n  void setUDMapperRefs(ArrayRef<Expr *> DMDs) {\n    assert(DMDs.size() == OMPVarListClause<T>::varlist_size() &&\n           \"Unexpected number of user-defined mappers.\");\n    assert(SupportsMapper &&\n           \"Must be a clause that is possible to have user-defined mappers\");\n    std::copy(DMDs.begin(), DMDs.end(), getUDMapperRefs().begin());\n  }\n\npublic:\n  /// Return the number of unique base declarations in this clause.\n  unsigned getUniqueDeclarationsNum() const { return NumUniqueDeclarations; }\n\n  /// Return the number of lists derived from the clause expressions.\n  unsigned getTotalComponentListNum() const { return NumComponentLists; }\n\n  /// Return the total number of components in all lists derived from the\n  /// clause.\n  unsigned getTotalComponentsNum() const { return NumComponents; }\n\n  /// Gets the nested name specifier for associated user-defined mapper.\n  NestedNameSpecifierLoc getMapperQualifierLoc() const {\n    return MapperQualifierLoc;\n  }\n\n  /// Gets the name info for associated user-defined mapper.\n  const DeclarationNameInfo &getMapperIdInfo() const { return MapperIdInfo; }\n\n  /// Iterator that browse the components by lists. It also allows\n  /// browsing components of a single declaration.\n  class const_component_lists_iterator\n      : public llvm::iterator_adaptor_base<\n            const_component_lists_iterator,\n            MappableExprComponentListRef::const_iterator,\n            std::forward_iterator_tag, MappableComponent, ptrdiff_t,\n            MappableComponent, MappableComponent> {\n    // The declaration the iterator currently refers to.\n    ArrayRef<ValueDecl *>::iterator DeclCur;\n\n    // The list number associated with the current declaration.\n    ArrayRef<unsigned>::iterator NumListsCur;\n\n    // Whether this clause is possible to have user-defined mappers associated.\n    const bool SupportsMapper;\n\n    // The user-defined mapper associated with the current declaration.\n    ArrayRef<Expr *>::iterator MapperCur;\n\n    // Remaining lists for the current declaration.\n    unsigned RemainingLists = 0;\n\n    // The cumulative size of the previous list, or zero if there is no previous\n    // list.\n    unsigned PrevListSize = 0;\n\n    // The cumulative sizes of the current list - it will delimit the remaining\n    // range of interest.\n    ArrayRef<unsigned>::const_iterator ListSizeCur;\n    ArrayRef<unsigned>::const_iterator ListSizeEnd;\n\n    // Iterator to the end of the components storage.\n    MappableExprComponentListRef::const_iterator End;\n\n  public:\n    /// Construct an iterator that scans all lists.\n    explicit const_component_lists_iterator(\n        ArrayRef<ValueDecl *> UniqueDecls, ArrayRef<unsigned> DeclsListNum,\n        ArrayRef<unsigned> CumulativeListSizes,\n        MappableExprComponentListRef Components, bool SupportsMapper,\n        ArrayRef<Expr *> Mappers)\n        : const_component_lists_iterator::iterator_adaptor_base(\n              Components.begin()),\n          DeclCur(UniqueDecls.begin()), NumListsCur(DeclsListNum.begin()),\n          SupportsMapper(SupportsMapper),\n          ListSizeCur(CumulativeListSizes.begin()),\n          ListSizeEnd(CumulativeListSizes.end()), End(Components.end()) {\n      assert(UniqueDecls.size() == DeclsListNum.size() &&\n             \"Inconsistent number of declarations and list sizes!\");\n      if (!DeclsListNum.empty())\n        RemainingLists = *NumListsCur;\n      if (SupportsMapper)\n        MapperCur = Mappers.begin();\n    }\n\n    /// Construct an iterator that scan lists for a given declaration \\a\n    /// Declaration.\n    explicit const_component_lists_iterator(\n        const ValueDecl *Declaration, ArrayRef<ValueDecl *> UniqueDecls,\n        ArrayRef<unsigned> DeclsListNum, ArrayRef<unsigned> CumulativeListSizes,\n        MappableExprComponentListRef Components, bool SupportsMapper,\n        ArrayRef<Expr *> Mappers)\n        : const_component_lists_iterator(UniqueDecls, DeclsListNum,\n                                         CumulativeListSizes, Components,\n                                         SupportsMapper, Mappers) {\n      // Look for the desired declaration. While we are looking for it, we\n      // update the state so that we know the component where a given list\n      // starts.\n      for (; DeclCur != UniqueDecls.end(); ++DeclCur, ++NumListsCur) {\n        if (*DeclCur == Declaration)\n          break;\n\n        assert(*NumListsCur > 0 && \"No lists associated with declaration??\");\n\n        // Skip the lists associated with the current declaration, but save the\n        // last list size that was skipped.\n        std::advance(ListSizeCur, *NumListsCur - 1);\n        PrevListSize = *ListSizeCur;\n        ++ListSizeCur;\n\n        if (SupportsMapper)\n          ++MapperCur;\n      }\n\n      // If we didn't find any declaration, advance the iterator to after the\n      // last component and set remaining lists to zero.\n      if (ListSizeCur == CumulativeListSizes.end()) {\n        this->I = End;\n        RemainingLists = 0u;\n        return;\n      }\n\n      // Set the remaining lists with the total number of lists of the current\n      // declaration.\n      RemainingLists = *NumListsCur;\n\n      // Adjust the list size end iterator to the end of the relevant range.\n      ListSizeEnd = ListSizeCur;\n      std::advance(ListSizeEnd, RemainingLists);\n\n      // Given that the list sizes are cumulative, the index of the component\n      // that start the list is the size of the previous list.\n      std::advance(this->I, PrevListSize);\n    }\n\n    // Return the array with the current list. The sizes are cumulative, so the\n    // array size is the difference between the current size and previous one.\n    std::tuple<const ValueDecl *, MappableExprComponentListRef,\n               const ValueDecl *>\n    operator*() const {\n      assert(ListSizeCur != ListSizeEnd && \"Invalid iterator!\");\n      const ValueDecl *Mapper = nullptr;\n      if (SupportsMapper && *MapperCur)\n        Mapper = cast<ValueDecl>(cast<DeclRefExpr>(*MapperCur)->getDecl());\n      return std::make_tuple(\n          *DeclCur,\n          MappableExprComponentListRef(&*this->I, *ListSizeCur - PrevListSize),\n          Mapper);\n    }\n    std::tuple<const ValueDecl *, MappableExprComponentListRef,\n               const ValueDecl *>\n    operator->() const {\n      return **this;\n    }\n\n    // Skip the components of the current list.\n    const_component_lists_iterator &operator++() {\n      assert(ListSizeCur != ListSizeEnd && RemainingLists &&\n             \"Invalid iterator!\");\n\n      // If we don't have more lists just skip all the components. Otherwise,\n      // advance the iterator by the number of components in the current list.\n      if (std::next(ListSizeCur) == ListSizeEnd) {\n        this->I = End;\n        RemainingLists = 0;\n      } else {\n        std::advance(this->I, *ListSizeCur - PrevListSize);\n        PrevListSize = *ListSizeCur;\n\n        // We are done with a declaration, move to the next one.\n        if (!(--RemainingLists)) {\n          ++DeclCur;\n          ++NumListsCur;\n          RemainingLists = *NumListsCur;\n          assert(RemainingLists && \"No lists in the following declaration??\");\n        }\n      }\n\n      ++ListSizeCur;\n      if (SupportsMapper)\n        ++MapperCur;\n      return *this;\n    }\n  };\n\n  using const_component_lists_range =\n      llvm::iterator_range<const_component_lists_iterator>;\n\n  /// Iterators for all component lists.\n  const_component_lists_iterator component_lists_begin() const {\n    return const_component_lists_iterator(\n        getUniqueDeclsRef(), getDeclNumListsRef(), getComponentListSizesRef(),\n        getComponentsRef(), SupportsMapper,\n        SupportsMapper ? getUDMapperRefs() : llvm::None);\n  }\n  const_component_lists_iterator component_lists_end() const {\n    return const_component_lists_iterator(\n        ArrayRef<ValueDecl *>(), ArrayRef<unsigned>(), ArrayRef<unsigned>(),\n        MappableExprComponentListRef(getComponentsRef().end(),\n                                     getComponentsRef().end()),\n        SupportsMapper, llvm::None);\n  }\n  const_component_lists_range component_lists() const {\n    return {component_lists_begin(), component_lists_end()};\n  }\n\n  /// Iterators for component lists associated with the provided\n  /// declaration.\n  const_component_lists_iterator\n  decl_component_lists_begin(const ValueDecl *VD) const {\n    return const_component_lists_iterator(\n        VD, getUniqueDeclsRef(), getDeclNumListsRef(),\n        getComponentListSizesRef(), getComponentsRef(), SupportsMapper,\n        SupportsMapper ? getUDMapperRefs() : llvm::None);\n  }\n  const_component_lists_iterator decl_component_lists_end() const {\n    return component_lists_end();\n  }\n  const_component_lists_range decl_component_lists(const ValueDecl *VD) const {\n    return {decl_component_lists_begin(VD), decl_component_lists_end()};\n  }\n\n  /// Iterators to access all the declarations, number of lists, list sizes, and\n  /// components.\n  using const_all_decls_iterator = ArrayRef<ValueDecl *>::iterator;\n  using const_all_decls_range = llvm::iterator_range<const_all_decls_iterator>;\n\n  const_all_decls_range all_decls() const {\n    auto A = getUniqueDeclsRef();\n    return const_all_decls_range(A.begin(), A.end());\n  }\n\n  using const_all_num_lists_iterator = ArrayRef<unsigned>::iterator;\n  using const_all_num_lists_range =\n      llvm::iterator_range<const_all_num_lists_iterator>;\n\n  const_all_num_lists_range all_num_lists() const {\n    auto A = getDeclNumListsRef();\n    return const_all_num_lists_range(A.begin(), A.end());\n  }\n\n  using const_all_lists_sizes_iterator = ArrayRef<unsigned>::iterator;\n  using const_all_lists_sizes_range =\n      llvm::iterator_range<const_all_lists_sizes_iterator>;\n\n  const_all_lists_sizes_range all_lists_sizes() const {\n    auto A = getComponentListSizesRef();\n    return const_all_lists_sizes_range(A.begin(), A.end());\n  }\n\n  using const_all_components_iterator = ArrayRef<MappableComponent>::iterator;\n  using const_all_components_range =\n      llvm::iterator_range<const_all_components_iterator>;\n\n  const_all_components_range all_components() const {\n    auto A = getComponentsRef();\n    return const_all_components_range(A.begin(), A.end());\n  }\n\n  using mapperlist_iterator = MutableArrayRef<Expr *>::iterator;\n  using mapperlist_const_iterator = ArrayRef<const Expr *>::iterator;\n  using mapperlist_range = llvm::iterator_range<mapperlist_iterator>;\n  using mapperlist_const_range =\n      llvm::iterator_range<mapperlist_const_iterator>;\n\n  mapperlist_iterator mapperlist_begin() { return getUDMapperRefs().begin(); }\n  mapperlist_iterator mapperlist_end() { return getUDMapperRefs().end(); }\n  mapperlist_const_iterator mapperlist_begin() const {\n    return getUDMapperRefs().begin();\n  }\n  mapperlist_const_iterator mapperlist_end() const {\n    return getUDMapperRefs().end();\n  }\n  mapperlist_range mapperlists() {\n    return mapperlist_range(mapperlist_begin(), mapperlist_end());\n  }\n  mapperlist_const_range mapperlists() const {\n    return mapperlist_const_range(mapperlist_begin(), mapperlist_end());\n  }\n};\n\n/// This represents clause 'map' in the '#pragma omp ...'\n/// directives.\n///\n/// \\code\n/// #pragma omp target map(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp target' has clause 'map'\n/// with the variables 'a' and 'b'.\nclass OMPMapClause final : public OMPMappableExprListClause<OMPMapClause>,\n                           private llvm::TrailingObjects<\n                               OMPMapClause, Expr *, ValueDecl *, unsigned,\n                               OMPClauseMappableExprCommon::MappableComponent> {\n  friend class OMPClauseReader;\n  friend OMPMappableExprListClause;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Define the sizes of each trailing object array except the last one. This\n  /// is required for TrailingObjects to work properly.\n  size_t numTrailingObjects(OverloadToken<Expr *>) const {\n    // There are varlist_size() of expressions, and varlist_size() of\n    // user-defined mappers.\n    return 2 * varlist_size();\n  }\n  size_t numTrailingObjects(OverloadToken<ValueDecl *>) const {\n    return getUniqueDeclarationsNum();\n  }\n  size_t numTrailingObjects(OverloadToken<unsigned>) const {\n    return getUniqueDeclarationsNum() + getTotalComponentListNum();\n  }\n\nprivate:\n  /// Map-type-modifiers for the 'map' clause.\n  OpenMPMapModifierKind MapTypeModifiers[NumberOfOMPMapClauseModifiers] = {\n      OMPC_MAP_MODIFIER_unknown, OMPC_MAP_MODIFIER_unknown,\n      OMPC_MAP_MODIFIER_unknown, OMPC_MAP_MODIFIER_unknown};\n\n  /// Location of map-type-modifiers for the 'map' clause.\n  SourceLocation MapTypeModifiersLoc[NumberOfOMPMapClauseModifiers];\n\n  /// Map type for the 'map' clause.\n  OpenMPMapClauseKind MapType = OMPC_MAP_unknown;\n\n  /// Is this an implicit map type or not.\n  bool MapTypeIsImplicit = false;\n\n  /// Location of the map type.\n  SourceLocation MapLoc;\n\n  /// Colon location.\n  SourceLocation ColonLoc;\n\n  /// Build a clause for \\a NumVars listed expressions, \\a\n  /// NumUniqueDeclarations declarations, \\a NumComponentLists total component\n  /// lists, and \\a NumComponents total expression components.\n  ///\n  /// \\param MapModifiers Map-type-modifiers.\n  /// \\param MapModifiersLoc Locations of map-type-modifiers.\n  /// \\param MapperQualifierLoc C++ nested name specifier for the associated\n  /// user-defined mapper.\n  /// \\param MapperIdInfo The identifier of associated user-defined mapper.\n  /// \\param MapType Map type.\n  /// \\param MapTypeIsImplicit Map type is inferred implicitly.\n  /// \\param MapLoc Location of the map type.\n  /// \\param Locs Locations needed to build a mappable clause. It includes 1)\n  /// StartLoc: starting location of the clause (the clause keyword); 2)\n  /// LParenLoc: location of '('; 3) EndLoc: ending location of the clause.\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  explicit OMPMapClause(ArrayRef<OpenMPMapModifierKind> MapModifiers,\n                        ArrayRef<SourceLocation> MapModifiersLoc,\n                        NestedNameSpecifierLoc MapperQualifierLoc,\n                        DeclarationNameInfo MapperIdInfo,\n                        OpenMPMapClauseKind MapType, bool MapTypeIsImplicit,\n                        SourceLocation MapLoc, const OMPVarListLocTy &Locs,\n                        const OMPMappableExprListSizeTy &Sizes)\n      : OMPMappableExprListClause(llvm::omp::OMPC_map, Locs, Sizes,\n                                  /*SupportsMapper=*/true, &MapperQualifierLoc,\n                                  &MapperIdInfo),\n        MapType(MapType), MapTypeIsImplicit(MapTypeIsImplicit), MapLoc(MapLoc) {\n    assert(llvm::array_lengthof(MapTypeModifiers) == MapModifiers.size() &&\n           \"Unexpected number of map type modifiers.\");\n    llvm::copy(MapModifiers, std::begin(MapTypeModifiers));\n\n    assert(llvm::array_lengthof(MapTypeModifiersLoc) ==\n               MapModifiersLoc.size() &&\n           \"Unexpected number of map type modifier locations.\");\n    llvm::copy(MapModifiersLoc, std::begin(MapTypeModifiersLoc));\n  }\n\n  /// Build an empty clause.\n  ///\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  explicit OMPMapClause(const OMPMappableExprListSizeTy &Sizes)\n      : OMPMappableExprListClause(llvm::omp::OMPC_map, OMPVarListLocTy(), Sizes,\n                                  /*SupportsMapper=*/true) {}\n\n  /// Set map-type-modifier for the clause.\n  ///\n  /// \\param I index for map-type-modifier.\n  /// \\param T map-type-modifier for the clause.\n  void setMapTypeModifier(unsigned I, OpenMPMapModifierKind T) {\n    assert(I < NumberOfOMPMapClauseModifiers &&\n           \"Unexpected index to store map type modifier, exceeds array size.\");\n    MapTypeModifiers[I] = T;\n  }\n\n  /// Set location for the map-type-modifier.\n  ///\n  /// \\param I index for map-type-modifier location.\n  /// \\param TLoc map-type-modifier location.\n  void setMapTypeModifierLoc(unsigned I, SourceLocation TLoc) {\n    assert(I < NumberOfOMPMapClauseModifiers &&\n           \"Index to store map type modifier location exceeds array size.\");\n    MapTypeModifiersLoc[I] = TLoc;\n  }\n\n  /// Set type for the clause.\n  ///\n  /// \\param T Type for the clause.\n  void setMapType(OpenMPMapClauseKind T) { MapType = T; }\n\n  /// Set type location.\n  ///\n  /// \\param TLoc Type location.\n  void setMapLoc(SourceLocation TLoc) { MapLoc = TLoc; }\n\n  /// Set colon location.\n  void setColonLoc(SourceLocation Loc) { ColonLoc = Loc; }\n\npublic:\n  /// Creates clause with a list of variables \\a VL.\n  ///\n  /// \\param C AST context.\n  /// \\param Locs Locations needed to build a mappable clause. It includes 1)\n  /// StartLoc: starting location of the clause (the clause keyword); 2)\n  /// LParenLoc: location of '('; 3) EndLoc: ending location of the clause.\n  /// \\param Vars The original expression used in the clause.\n  /// \\param Declarations Declarations used in the clause.\n  /// \\param ComponentLists Component lists used in the clause.\n  /// \\param UDMapperRefs References to user-defined mappers associated with\n  /// expressions used in the clause.\n  /// \\param MapModifiers Map-type-modifiers.\n  /// \\param MapModifiersLoc Location of map-type-modifiers.\n  /// \\param UDMQualifierLoc C++ nested name specifier for the associated\n  /// user-defined mapper.\n  /// \\param MapperId The identifier of associated user-defined mapper.\n  /// \\param Type Map type.\n  /// \\param TypeIsImplicit Map type is inferred implicitly.\n  /// \\param TypeLoc Location of the map type.\n  static OMPMapClause *\n  Create(const ASTContext &C, const OMPVarListLocTy &Locs,\n         ArrayRef<Expr *> Vars, ArrayRef<ValueDecl *> Declarations,\n         MappableExprComponentListsRef ComponentLists,\n         ArrayRef<Expr *> UDMapperRefs,\n         ArrayRef<OpenMPMapModifierKind> MapModifiers,\n         ArrayRef<SourceLocation> MapModifiersLoc,\n         NestedNameSpecifierLoc UDMQualifierLoc, DeclarationNameInfo MapperId,\n         OpenMPMapClauseKind Type, bool TypeIsImplicit, SourceLocation TypeLoc);\n\n  /// Creates an empty clause with the place for \\a NumVars original\n  /// expressions, \\a NumUniqueDeclarations declarations, \\NumComponentLists\n  /// lists, and \\a NumComponents expression components.\n  ///\n  /// \\param C AST context.\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  static OMPMapClause *CreateEmpty(const ASTContext &C,\n                                   const OMPMappableExprListSizeTy &Sizes);\n\n  /// Fetches mapping kind for the clause.\n  OpenMPMapClauseKind getMapType() const LLVM_READONLY { return MapType; }\n\n  /// Is this an implicit map type?\n  /// We have to capture 'IsMapTypeImplicit' from the parser for more\n  /// informative error messages.  It helps distinguish map(r) from\n  /// map(tofrom: r), which is important to print more helpful error\n  /// messages for some target directives.\n  bool isImplicitMapType() const LLVM_READONLY { return MapTypeIsImplicit; }\n\n  /// Fetches the map-type-modifier at 'Cnt' index of array of modifiers.\n  ///\n  /// \\param Cnt index for map-type-modifier.\n  OpenMPMapModifierKind getMapTypeModifier(unsigned Cnt) const LLVM_READONLY {\n    assert(Cnt < NumberOfOMPMapClauseModifiers &&\n           \"Requested modifier exceeds the total number of modifiers.\");\n    return MapTypeModifiers[Cnt];\n  }\n\n  /// Fetches the map-type-modifier location at 'Cnt' index of array of\n  /// modifiers' locations.\n  ///\n  /// \\param Cnt index for map-type-modifier location.\n  SourceLocation getMapTypeModifierLoc(unsigned Cnt) const LLVM_READONLY {\n    assert(Cnt < NumberOfOMPMapClauseModifiers &&\n           \"Requested modifier location exceeds total number of modifiers.\");\n    return MapTypeModifiersLoc[Cnt];\n  }\n\n  /// Fetches ArrayRef of map-type-modifiers.\n  ArrayRef<OpenMPMapModifierKind> getMapTypeModifiers() const LLVM_READONLY {\n    return llvm::makeArrayRef(MapTypeModifiers);\n  }\n\n  /// Fetches ArrayRef of location of map-type-modifiers.\n  ArrayRef<SourceLocation> getMapTypeModifiersLoc() const LLVM_READONLY {\n    return llvm::makeArrayRef(MapTypeModifiersLoc);\n  }\n\n  /// Fetches location of clause mapping kind.\n  SourceLocation getMapLoc() const LLVM_READONLY { return MapLoc; }\n\n  /// Get colon location.\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  child_range children() {\n    return child_range(\n        reinterpret_cast<Stmt **>(varlist_begin()),\n        reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPMapClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    if (MapType == OMPC_MAP_to || MapType == OMPC_MAP_tofrom)\n      return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                         reinterpret_cast<Stmt **>(varlist_end()));\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    auto Children = const_cast<OMPMapClause *>(this)->used_children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_map;\n  }\n};\n\n/// This represents 'num_teams' clause in the '#pragma omp ...'\n/// directive.\n///\n/// \\code\n/// #pragma omp teams num_teams(n)\n/// \\endcode\n/// In this example directive '#pragma omp teams' has clause 'num_teams'\n/// with single expression 'n'.\nclass OMPNumTeamsClause : public OMPClause, public OMPClauseWithPreInit {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// NumTeams number.\n  Stmt *NumTeams = nullptr;\n\n  /// Set the NumTeams number.\n  ///\n  /// \\param E NumTeams number.\n  void setNumTeams(Expr *E) { NumTeams = E; }\n\npublic:\n  /// Build 'num_teams' clause.\n  ///\n  /// \\param E Expression associated with this clause.\n  /// \\param HelperE Helper Expression associated with this clause.\n  /// \\param CaptureRegion Innermost OpenMP region where expressions in this\n  /// clause must be captured.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  OMPNumTeamsClause(Expr *E, Stmt *HelperE, OpenMPDirectiveKind CaptureRegion,\n                    SourceLocation StartLoc, SourceLocation LParenLoc,\n                    SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_num_teams, StartLoc, EndLoc),\n        OMPClauseWithPreInit(this), LParenLoc(LParenLoc), NumTeams(E) {\n    setPreInitStmt(HelperE, CaptureRegion);\n  }\n\n  /// Build an empty clause.\n  OMPNumTeamsClause()\n      : OMPClause(llvm::omp::OMPC_num_teams, SourceLocation(),\n                  SourceLocation()),\n        OMPClauseWithPreInit(this) {}\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Return NumTeams number.\n  Expr *getNumTeams() { return cast<Expr>(NumTeams); }\n\n  /// Return NumTeams number.\n  Expr *getNumTeams() const { return cast<Expr>(NumTeams); }\n\n  child_range children() { return child_range(&NumTeams, &NumTeams + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&NumTeams, &NumTeams + 1);\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_num_teams;\n  }\n};\n\n/// This represents 'thread_limit' clause in the '#pragma omp ...'\n/// directive.\n///\n/// \\code\n/// #pragma omp teams thread_limit(n)\n/// \\endcode\n/// In this example directive '#pragma omp teams' has clause 'thread_limit'\n/// with single expression 'n'.\nclass OMPThreadLimitClause : public OMPClause, public OMPClauseWithPreInit {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// ThreadLimit number.\n  Stmt *ThreadLimit = nullptr;\n\n  /// Set the ThreadLimit number.\n  ///\n  /// \\param E ThreadLimit number.\n  void setThreadLimit(Expr *E) { ThreadLimit = E; }\n\npublic:\n  /// Build 'thread_limit' clause.\n  ///\n  /// \\param E Expression associated with this clause.\n  /// \\param HelperE Helper Expression associated with this clause.\n  /// \\param CaptureRegion Innermost OpenMP region where expressions in this\n  /// clause must be captured.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  OMPThreadLimitClause(Expr *E, Stmt *HelperE,\n                       OpenMPDirectiveKind CaptureRegion,\n                       SourceLocation StartLoc, SourceLocation LParenLoc,\n                       SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_thread_limit, StartLoc, EndLoc),\n        OMPClauseWithPreInit(this), LParenLoc(LParenLoc), ThreadLimit(E) {\n    setPreInitStmt(HelperE, CaptureRegion);\n  }\n\n  /// Build an empty clause.\n  OMPThreadLimitClause()\n      : OMPClause(llvm::omp::OMPC_thread_limit, SourceLocation(),\n                  SourceLocation()),\n        OMPClauseWithPreInit(this) {}\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Return ThreadLimit number.\n  Expr *getThreadLimit() { return cast<Expr>(ThreadLimit); }\n\n  /// Return ThreadLimit number.\n  Expr *getThreadLimit() const { return cast<Expr>(ThreadLimit); }\n\n  child_range children() { return child_range(&ThreadLimit, &ThreadLimit + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&ThreadLimit, &ThreadLimit + 1);\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_thread_limit;\n  }\n};\n\n/// This represents 'priority' clause in the '#pragma omp ...'\n/// directive.\n///\n/// \\code\n/// #pragma omp task priority(n)\n/// \\endcode\n/// In this example directive '#pragma omp teams' has clause 'priority' with\n/// single expression 'n'.\nclass OMPPriorityClause : public OMPClause, public OMPClauseWithPreInit {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Priority number.\n  Stmt *Priority = nullptr;\n\n  /// Set the Priority number.\n  ///\n  /// \\param E Priority number.\n  void setPriority(Expr *E) { Priority = E; }\n\npublic:\n  /// Build 'priority' clause.\n  ///\n  /// \\param Priority Expression associated with this clause.\n  /// \\param HelperPriority Helper priority for the construct.\n  /// \\param CaptureRegion Innermost OpenMP region where expressions in this\n  /// clause must be captured.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  OMPPriorityClause(Expr *Priority, Stmt *HelperPriority,\n                    OpenMPDirectiveKind CaptureRegion, SourceLocation StartLoc,\n                    SourceLocation LParenLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_priority, StartLoc, EndLoc),\n        OMPClauseWithPreInit(this), LParenLoc(LParenLoc), Priority(Priority) {\n    setPreInitStmt(HelperPriority, CaptureRegion);\n  }\n\n  /// Build an empty clause.\n  OMPPriorityClause()\n      : OMPClause(llvm::omp::OMPC_priority, SourceLocation(), SourceLocation()),\n        OMPClauseWithPreInit(this) {}\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Return Priority number.\n  Expr *getPriority() { return cast<Expr>(Priority); }\n\n  /// Return Priority number.\n  Expr *getPriority() const { return cast<Expr>(Priority); }\n\n  child_range children() { return child_range(&Priority, &Priority + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Priority, &Priority + 1);\n  }\n\n  child_range used_children();\n  const_child_range used_children() const {\n    auto Children = const_cast<OMPPriorityClause *>(this)->used_children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_priority;\n  }\n};\n\n/// This represents 'grainsize' clause in the '#pragma omp ...'\n/// directive.\n///\n/// \\code\n/// #pragma omp taskloop grainsize(4)\n/// \\endcode\n/// In this example directive '#pragma omp taskloop' has clause 'grainsize'\n/// with single expression '4'.\nclass OMPGrainsizeClause : public OMPClause, public OMPClauseWithPreInit {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Safe iteration space distance.\n  Stmt *Grainsize = nullptr;\n\n  /// Set safelen.\n  void setGrainsize(Expr *Size) { Grainsize = Size; }\n\npublic:\n  /// Build 'grainsize' clause.\n  ///\n  /// \\param Size Expression associated with this clause.\n  /// \\param HelperSize Helper grainsize for the construct.\n  /// \\param CaptureRegion Innermost OpenMP region where expressions in this\n  /// clause must be captured.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPGrainsizeClause(Expr *Size, Stmt *HelperSize,\n                     OpenMPDirectiveKind CaptureRegion, SourceLocation StartLoc,\n                     SourceLocation LParenLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_grainsize, StartLoc, EndLoc),\n        OMPClauseWithPreInit(this), LParenLoc(LParenLoc), Grainsize(Size) {\n    setPreInitStmt(HelperSize, CaptureRegion);\n  }\n\n  /// Build an empty clause.\n  explicit OMPGrainsizeClause()\n      : OMPClause(llvm::omp::OMPC_grainsize, SourceLocation(),\n                  SourceLocation()),\n        OMPClauseWithPreInit(this) {}\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Return safe iteration space distance.\n  Expr *getGrainsize() const { return cast_or_null<Expr>(Grainsize); }\n\n  child_range children() { return child_range(&Grainsize, &Grainsize + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Grainsize, &Grainsize + 1);\n  }\n\n  child_range used_children();\n  const_child_range used_children() const {\n    auto Children = const_cast<OMPGrainsizeClause *>(this)->used_children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_grainsize;\n  }\n};\n\n/// This represents 'nogroup' clause in the '#pragma omp ...' directive.\n///\n/// \\code\n/// #pragma omp taskloop nogroup\n/// \\endcode\n/// In this example directive '#pragma omp taskloop' has 'nogroup' clause.\nclass OMPNogroupClause : public OMPClause {\npublic:\n  /// Build 'nogroup' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPNogroupClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_nogroup, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPNogroupClause()\n      : OMPClause(llvm::omp::OMPC_nogroup, SourceLocation(), SourceLocation()) {\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_nogroup;\n  }\n};\n\n/// This represents 'num_tasks' clause in the '#pragma omp ...'\n/// directive.\n///\n/// \\code\n/// #pragma omp taskloop num_tasks(4)\n/// \\endcode\n/// In this example directive '#pragma omp taskloop' has clause 'num_tasks'\n/// with single expression '4'.\nclass OMPNumTasksClause : public OMPClause, public OMPClauseWithPreInit {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Safe iteration space distance.\n  Stmt *NumTasks = nullptr;\n\n  /// Set safelen.\n  void setNumTasks(Expr *Size) { NumTasks = Size; }\n\npublic:\n  /// Build 'num_tasks' clause.\n  ///\n  /// \\param Size Expression associated with this clause.\n  /// \\param HelperSize Helper grainsize for the construct.\n  /// \\param CaptureRegion Innermost OpenMP region where expressions in this\n  /// clause must be captured.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPNumTasksClause(Expr *Size, Stmt *HelperSize,\n                    OpenMPDirectiveKind CaptureRegion, SourceLocation StartLoc,\n                    SourceLocation LParenLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_num_tasks, StartLoc, EndLoc),\n        OMPClauseWithPreInit(this), LParenLoc(LParenLoc), NumTasks(Size) {\n    setPreInitStmt(HelperSize, CaptureRegion);\n  }\n\n  /// Build an empty clause.\n  explicit OMPNumTasksClause()\n      : OMPClause(llvm::omp::OMPC_num_tasks, SourceLocation(),\n                  SourceLocation()),\n        OMPClauseWithPreInit(this) {}\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Return safe iteration space distance.\n  Expr *getNumTasks() const { return cast_or_null<Expr>(NumTasks); }\n\n  child_range children() { return child_range(&NumTasks, &NumTasks + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&NumTasks, &NumTasks + 1);\n  }\n\n  child_range used_children();\n  const_child_range used_children() const {\n    auto Children = const_cast<OMPNumTasksClause *>(this)->used_children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_num_tasks;\n  }\n};\n\n/// This represents 'hint' clause in the '#pragma omp ...' directive.\n///\n/// \\code\n/// #pragma omp critical (name) hint(6)\n/// \\endcode\n/// In this example directive '#pragma omp critical' has name 'name' and clause\n/// 'hint' with argument '6'.\nclass OMPHintClause : public OMPClause {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Hint expression of the 'hint' clause.\n  Stmt *Hint = nullptr;\n\n  /// Set hint expression.\n  void setHint(Expr *H) { Hint = H; }\n\npublic:\n  /// Build 'hint' clause with expression \\a Hint.\n  ///\n  /// \\param Hint Hint expression.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  OMPHintClause(Expr *Hint, SourceLocation StartLoc, SourceLocation LParenLoc,\n                SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_hint, StartLoc, EndLoc), LParenLoc(LParenLoc),\n        Hint(Hint) {}\n\n  /// Build an empty clause.\n  OMPHintClause()\n      : OMPClause(llvm::omp::OMPC_hint, SourceLocation(), SourceLocation()) {}\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Returns number of threads.\n  Expr *getHint() const { return cast_or_null<Expr>(Hint); }\n\n  child_range children() { return child_range(&Hint, &Hint + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Hint, &Hint + 1);\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_hint;\n  }\n};\n\n/// This represents 'dist_schedule' clause in the '#pragma omp ...'\n/// directive.\n///\n/// \\code\n/// #pragma omp distribute dist_schedule(static, 3)\n/// \\endcode\n/// In this example directive '#pragma omp distribute' has 'dist_schedule'\n/// clause with arguments 'static' and '3'.\nclass OMPDistScheduleClause : public OMPClause, public OMPClauseWithPreInit {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// A kind of the 'schedule' clause.\n  OpenMPDistScheduleClauseKind Kind = OMPC_DIST_SCHEDULE_unknown;\n\n  /// Start location of the schedule kind in source code.\n  SourceLocation KindLoc;\n\n  /// Location of ',' (if any).\n  SourceLocation CommaLoc;\n\n  /// Chunk size.\n  Expr *ChunkSize = nullptr;\n\n  /// Set schedule kind.\n  ///\n  /// \\param K Schedule kind.\n  void setDistScheduleKind(OpenMPDistScheduleClauseKind K) { Kind = K; }\n\n  /// Sets the location of '('.\n  ///\n  /// \\param Loc Location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Set schedule kind start location.\n  ///\n  /// \\param KLoc Schedule kind location.\n  void setDistScheduleKindLoc(SourceLocation KLoc) { KindLoc = KLoc; }\n\n  /// Set location of ','.\n  ///\n  /// \\param Loc Location of ','.\n  void setCommaLoc(SourceLocation Loc) { CommaLoc = Loc; }\n\n  /// Set chunk size.\n  ///\n  /// \\param E Chunk size.\n  void setChunkSize(Expr *E) { ChunkSize = E; }\n\npublic:\n  /// Build 'dist_schedule' clause with schedule kind \\a Kind and chunk\n  /// size expression \\a ChunkSize.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param KLoc Starting location of the argument.\n  /// \\param CommaLoc Location of ','.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param Kind DistSchedule kind.\n  /// \\param ChunkSize Chunk size.\n  /// \\param HelperChunkSize Helper chunk size for combined directives.\n  OMPDistScheduleClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                        SourceLocation KLoc, SourceLocation CommaLoc,\n                        SourceLocation EndLoc,\n                        OpenMPDistScheduleClauseKind Kind, Expr *ChunkSize,\n                        Stmt *HelperChunkSize)\n      : OMPClause(llvm::omp::OMPC_dist_schedule, StartLoc, EndLoc),\n        OMPClauseWithPreInit(this), LParenLoc(LParenLoc), Kind(Kind),\n        KindLoc(KLoc), CommaLoc(CommaLoc), ChunkSize(ChunkSize) {\n    setPreInitStmt(HelperChunkSize);\n  }\n\n  /// Build an empty clause.\n  explicit OMPDistScheduleClause()\n      : OMPClause(llvm::omp::OMPC_dist_schedule, SourceLocation(),\n                  SourceLocation()),\n        OMPClauseWithPreInit(this) {}\n\n  /// Get kind of the clause.\n  OpenMPDistScheduleClauseKind getDistScheduleKind() const { return Kind; }\n\n  /// Get location of '('.\n  SourceLocation getLParenLoc() { return LParenLoc; }\n\n  /// Get kind location.\n  SourceLocation getDistScheduleKindLoc() { return KindLoc; }\n\n  /// Get location of ','.\n  SourceLocation getCommaLoc() { return CommaLoc; }\n\n  /// Get chunk size.\n  Expr *getChunkSize() { return ChunkSize; }\n\n  /// Get chunk size.\n  const Expr *getChunkSize() const { return ChunkSize; }\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(&ChunkSize),\n                       reinterpret_cast<Stmt **>(&ChunkSize) + 1);\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPDistScheduleClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_dist_schedule;\n  }\n};\n\n/// This represents 'defaultmap' clause in the '#pragma omp ...' directive.\n///\n/// \\code\n/// #pragma omp target defaultmap(tofrom: scalar)\n/// \\endcode\n/// In this example directive '#pragma omp target' has 'defaultmap' clause of kind\n/// 'scalar' with modifier 'tofrom'.\nclass OMPDefaultmapClause : public OMPClause {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Modifiers for 'defaultmap' clause.\n  OpenMPDefaultmapClauseModifier Modifier = OMPC_DEFAULTMAP_MODIFIER_unknown;\n\n  /// Locations of modifiers.\n  SourceLocation ModifierLoc;\n\n  /// A kind of the 'defaultmap' clause.\n  OpenMPDefaultmapClauseKind Kind = OMPC_DEFAULTMAP_unknown;\n\n  /// Start location of the defaultmap kind in source code.\n  SourceLocation KindLoc;\n\n  /// Set defaultmap kind.\n  ///\n  /// \\param K Defaultmap kind.\n  void setDefaultmapKind(OpenMPDefaultmapClauseKind K) { Kind = K; }\n\n  /// Set the defaultmap modifier.\n  ///\n  /// \\param M Defaultmap modifier.\n  void setDefaultmapModifier(OpenMPDefaultmapClauseModifier M) {\n    Modifier = M;\n  }\n\n  /// Set location of the defaultmap modifier.\n  void setDefaultmapModifierLoc(SourceLocation Loc) {\n    ModifierLoc = Loc;\n  }\n\n  /// Sets the location of '('.\n  ///\n  /// \\param Loc Location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Set defaultmap kind start location.\n  ///\n  /// \\param KLoc Defaultmap kind location.\n  void setDefaultmapKindLoc(SourceLocation KLoc) { KindLoc = KLoc; }\n\npublic:\n  /// Build 'defaultmap' clause with defaultmap kind \\a Kind\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param KLoc Starting location of the argument.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param Kind Defaultmap kind.\n  /// \\param M The modifier applied to 'defaultmap' clause.\n  /// \\param MLoc Location of the modifier\n  OMPDefaultmapClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                      SourceLocation MLoc, SourceLocation KLoc,\n                      SourceLocation EndLoc, OpenMPDefaultmapClauseKind Kind,\n                      OpenMPDefaultmapClauseModifier M)\n      : OMPClause(llvm::omp::OMPC_defaultmap, StartLoc, EndLoc),\n        LParenLoc(LParenLoc), Modifier(M), ModifierLoc(MLoc), Kind(Kind),\n        KindLoc(KLoc) {}\n\n  /// Build an empty clause.\n  explicit OMPDefaultmapClause()\n      : OMPClause(llvm::omp::OMPC_defaultmap, SourceLocation(),\n                  SourceLocation()) {}\n\n  /// Get kind of the clause.\n  OpenMPDefaultmapClauseKind getDefaultmapKind() const { return Kind; }\n\n  /// Get the modifier of the clause.\n  OpenMPDefaultmapClauseModifier getDefaultmapModifier() const {\n    return Modifier;\n  }\n\n  /// Get location of '('.\n  SourceLocation getLParenLoc() { return LParenLoc; }\n\n  /// Get kind location.\n  SourceLocation getDefaultmapKindLoc() { return KindLoc; }\n\n  /// Get the modifier location.\n  SourceLocation getDefaultmapModifierLoc() const {\n    return ModifierLoc;\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_defaultmap;\n  }\n};\n\n/// This represents clause 'to' in the '#pragma omp ...'\n/// directives.\n///\n/// \\code\n/// #pragma omp target update to(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp target update' has clause 'to'\n/// with the variables 'a' and 'b'.\nclass OMPToClause final : public OMPMappableExprListClause<OMPToClause>,\n                          private llvm::TrailingObjects<\n                              OMPToClause, Expr *, ValueDecl *, unsigned,\n                              OMPClauseMappableExprCommon::MappableComponent> {\n  friend class OMPClauseReader;\n  friend OMPMappableExprListClause;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Motion-modifiers for the 'to' clause.\n  OpenMPMotionModifierKind MotionModifiers[NumberOfOMPMotionModifiers] = {\n      OMPC_MOTION_MODIFIER_unknown, OMPC_MOTION_MODIFIER_unknown};\n\n  /// Location of motion-modifiers for the 'to' clause.\n  SourceLocation MotionModifiersLoc[NumberOfOMPMotionModifiers];\n\n  /// Colon location.\n  SourceLocation ColonLoc;\n\n  /// Build clause with number of variables \\a NumVars.\n  ///\n  /// \\param TheMotionModifiers Motion-modifiers.\n  /// \\param TheMotionModifiersLoc Locations of motion-modifiers.\n  /// \\param MapperQualifierLoc C++ nested name specifier for the associated\n  /// user-defined mapper.\n  /// \\param MapperIdInfo The identifier of associated user-defined mapper.\n  /// \\param Locs Locations needed to build a mappable clause. It includes 1)\n  /// StartLoc: starting location of the clause (the clause keyword); 2)\n  /// LParenLoc: location of '('; 3) EndLoc: ending location of the clause.\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  explicit OMPToClause(ArrayRef<OpenMPMotionModifierKind> TheMotionModifiers,\n                       ArrayRef<SourceLocation> TheMotionModifiersLoc,\n                       NestedNameSpecifierLoc MapperQualifierLoc,\n                       DeclarationNameInfo MapperIdInfo,\n                       const OMPVarListLocTy &Locs,\n                       const OMPMappableExprListSizeTy &Sizes)\n      : OMPMappableExprListClause(llvm::omp::OMPC_to, Locs, Sizes,\n                                  /*SupportsMapper=*/true, &MapperQualifierLoc,\n                                  &MapperIdInfo) {\n    assert(llvm::array_lengthof(MotionModifiers) == TheMotionModifiers.size() &&\n           \"Unexpected number of motion modifiers.\");\n    llvm::copy(TheMotionModifiers, std::begin(MotionModifiers));\n\n    assert(llvm::array_lengthof(MotionModifiersLoc) ==\n               TheMotionModifiersLoc.size() &&\n           \"Unexpected number of motion modifier locations.\");\n    llvm::copy(TheMotionModifiersLoc, std::begin(MotionModifiersLoc));\n  }\n\n  /// Build an empty clause.\n  ///\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  explicit OMPToClause(const OMPMappableExprListSizeTy &Sizes)\n      : OMPMappableExprListClause(llvm::omp::OMPC_to, OMPVarListLocTy(), Sizes,\n                                  /*SupportsMapper=*/true) {}\n\n  /// Set motion-modifier for the clause.\n  ///\n  /// \\param I index for motion-modifier.\n  /// \\param T motion-modifier for the clause.\n  void setMotionModifier(unsigned I, OpenMPMotionModifierKind T) {\n    assert(I < NumberOfOMPMotionModifiers &&\n           \"Unexpected index to store motion modifier, exceeds array size.\");\n    MotionModifiers[I] = T;\n  }\n\n  /// Set location for the motion-modifier.\n  ///\n  /// \\param I index for motion-modifier location.\n  /// \\param TLoc motion-modifier location.\n  void setMotionModifierLoc(unsigned I, SourceLocation TLoc) {\n    assert(I < NumberOfOMPMotionModifiers &&\n           \"Index to store motion modifier location exceeds array size.\");\n    MotionModifiersLoc[I] = TLoc;\n  }\n\n  /// Set colon location.\n  void setColonLoc(SourceLocation Loc) { ColonLoc = Loc; }\n\n  /// Define the sizes of each trailing object array except the last one. This\n  /// is required for TrailingObjects to work properly.\n  size_t numTrailingObjects(OverloadToken<Expr *>) const {\n    // There are varlist_size() of expressions, and varlist_size() of\n    // user-defined mappers.\n    return 2 * varlist_size();\n  }\n  size_t numTrailingObjects(OverloadToken<ValueDecl *>) const {\n    return getUniqueDeclarationsNum();\n  }\n  size_t numTrailingObjects(OverloadToken<unsigned>) const {\n    return getUniqueDeclarationsNum() + getTotalComponentListNum();\n  }\n\npublic:\n  /// Creates clause with a list of variables \\a Vars.\n  ///\n  /// \\param C AST context.\n  /// \\param Locs Locations needed to build a mappable clause. It includes 1)\n  /// StartLoc: starting location of the clause (the clause keyword); 2)\n  /// LParenLoc: location of '('; 3) EndLoc: ending location of the clause.\n  /// \\param Vars The original expression used in the clause.\n  /// \\param Declarations Declarations used in the clause.\n  /// \\param ComponentLists Component lists used in the clause.\n  /// \\param MotionModifiers Motion-modifiers.\n  /// \\param MotionModifiersLoc Location of motion-modifiers.\n  /// \\param UDMapperRefs References to user-defined mappers associated with\n  /// expressions used in the clause.\n  /// \\param UDMQualifierLoc C++ nested name specifier for the associated\n  /// user-defined mapper.\n  /// \\param MapperId The identifier of associated user-defined mapper.\n  static OMPToClause *Create(const ASTContext &C, const OMPVarListLocTy &Locs,\n                             ArrayRef<Expr *> Vars,\n                             ArrayRef<ValueDecl *> Declarations,\n                             MappableExprComponentListsRef ComponentLists,\n                             ArrayRef<Expr *> UDMapperRefs,\n                             ArrayRef<OpenMPMotionModifierKind> MotionModifiers,\n                             ArrayRef<SourceLocation> MotionModifiersLoc,\n                             NestedNameSpecifierLoc UDMQualifierLoc,\n                             DeclarationNameInfo MapperId);\n\n  /// Creates an empty clause with the place for \\a NumVars variables.\n  ///\n  /// \\param C AST context.\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  static OMPToClause *CreateEmpty(const ASTContext &C,\n                                  const OMPMappableExprListSizeTy &Sizes);\n\n  /// Fetches the motion-modifier at 'Cnt' index of array of modifiers.\n  ///\n  /// \\param Cnt index for motion-modifier.\n  OpenMPMotionModifierKind getMotionModifier(unsigned Cnt) const LLVM_READONLY {\n    assert(Cnt < NumberOfOMPMotionModifiers &&\n           \"Requested modifier exceeds the total number of modifiers.\");\n    return MotionModifiers[Cnt];\n  }\n\n  /// Fetches the motion-modifier location at 'Cnt' index of array of modifiers'\n  /// locations.\n  ///\n  /// \\param Cnt index for motion-modifier location.\n  SourceLocation getMotionModifierLoc(unsigned Cnt) const LLVM_READONLY {\n    assert(Cnt < NumberOfOMPMotionModifiers &&\n           \"Requested modifier location exceeds total number of modifiers.\");\n    return MotionModifiersLoc[Cnt];\n  }\n\n  /// Fetches ArrayRef of motion-modifiers.\n  ArrayRef<OpenMPMotionModifierKind> getMotionModifiers() const LLVM_READONLY {\n    return llvm::makeArrayRef(MotionModifiers);\n  }\n\n  /// Fetches ArrayRef of location of motion-modifiers.\n  ArrayRef<SourceLocation> getMotionModifiersLoc() const LLVM_READONLY {\n    return llvm::makeArrayRef(MotionModifiersLoc);\n  }\n\n  /// Get colon location.\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPToClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_to;\n  }\n};\n\n/// This represents clause 'from' in the '#pragma omp ...'\n/// directives.\n///\n/// \\code\n/// #pragma omp target update from(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp target update' has clause 'from'\n/// with the variables 'a' and 'b'.\nclass OMPFromClause final\n    : public OMPMappableExprListClause<OMPFromClause>,\n      private llvm::TrailingObjects<\n          OMPFromClause, Expr *, ValueDecl *, unsigned,\n          OMPClauseMappableExprCommon::MappableComponent> {\n  friend class OMPClauseReader;\n  friend OMPMappableExprListClause;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Motion-modifiers for the 'from' clause.\n  OpenMPMotionModifierKind MotionModifiers[NumberOfOMPMotionModifiers] = {\n      OMPC_MOTION_MODIFIER_unknown, OMPC_MOTION_MODIFIER_unknown};\n\n  /// Location of motion-modifiers for the 'from' clause.\n  SourceLocation MotionModifiersLoc[NumberOfOMPMotionModifiers];\n\n  /// Colon location.\n  SourceLocation ColonLoc;\n\n  /// Build clause with number of variables \\a NumVars.\n  ///\n  /// \\param TheMotionModifiers Motion-modifiers.\n  /// \\param TheMotionModifiersLoc Locations of motion-modifiers.\n  /// \\param MapperQualifierLoc C++ nested name specifier for the associated\n  /// user-defined mapper.\n  /// \\param MapperIdInfo The identifier of associated user-defined mapper.\n  /// \\param Locs Locations needed to build a mappable clause. It includes 1)\n  /// StartLoc: starting location of the clause (the clause keyword); 2)\n  /// LParenLoc: location of '('; 3) EndLoc: ending location of the clause.\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  explicit OMPFromClause(ArrayRef<OpenMPMotionModifierKind> TheMotionModifiers,\n                         ArrayRef<SourceLocation> TheMotionModifiersLoc,\n                         NestedNameSpecifierLoc MapperQualifierLoc,\n                         DeclarationNameInfo MapperIdInfo,\n                         const OMPVarListLocTy &Locs,\n                         const OMPMappableExprListSizeTy &Sizes)\n      : OMPMappableExprListClause(llvm::omp::OMPC_from, Locs, Sizes,\n                                  /*SupportsMapper=*/true, &MapperQualifierLoc,\n                                  &MapperIdInfo) {\n    assert(llvm::array_lengthof(MotionModifiers) == TheMotionModifiers.size() &&\n           \"Unexpected number of motion modifiers.\");\n    llvm::copy(TheMotionModifiers, std::begin(MotionModifiers));\n\n    assert(llvm::array_lengthof(MotionModifiersLoc) ==\n               TheMotionModifiersLoc.size() &&\n           \"Unexpected number of motion modifier locations.\");\n    llvm::copy(TheMotionModifiersLoc, std::begin(MotionModifiersLoc));\n  }\n\n  /// Build an empty clause.\n  ///\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  explicit OMPFromClause(const OMPMappableExprListSizeTy &Sizes)\n      : OMPMappableExprListClause(llvm::omp::OMPC_from, OMPVarListLocTy(),\n                                  Sizes, /*SupportsMapper=*/true) {}\n\n  /// Set motion-modifier for the clause.\n  ///\n  /// \\param I index for motion-modifier.\n  /// \\param T motion-modifier for the clause.\n  void setMotionModifier(unsigned I, OpenMPMotionModifierKind T) {\n    assert(I < NumberOfOMPMotionModifiers &&\n           \"Unexpected index to store motion modifier, exceeds array size.\");\n    MotionModifiers[I] = T;\n  }\n\n  /// Set location for the motion-modifier.\n  ///\n  /// \\param I index for motion-modifier location.\n  /// \\param TLoc motion-modifier location.\n  void setMotionModifierLoc(unsigned I, SourceLocation TLoc) {\n    assert(I < NumberOfOMPMotionModifiers &&\n           \"Index to store motion modifier location exceeds array size.\");\n    MotionModifiersLoc[I] = TLoc;\n  }\n\n  /// Set colon location.\n  void setColonLoc(SourceLocation Loc) { ColonLoc = Loc; }\n\n  /// Define the sizes of each trailing object array except the last one. This\n  /// is required for TrailingObjects to work properly.\n  size_t numTrailingObjects(OverloadToken<Expr *>) const {\n    // There are varlist_size() of expressions, and varlist_size() of\n    // user-defined mappers.\n    return 2 * varlist_size();\n  }\n  size_t numTrailingObjects(OverloadToken<ValueDecl *>) const {\n    return getUniqueDeclarationsNum();\n  }\n  size_t numTrailingObjects(OverloadToken<unsigned>) const {\n    return getUniqueDeclarationsNum() + getTotalComponentListNum();\n  }\n\npublic:\n  /// Creates clause with a list of variables \\a Vars.\n  ///\n  /// \\param C AST context.\n  /// \\param Locs Locations needed to build a mappable clause. It includes 1)\n  /// StartLoc: starting location of the clause (the clause keyword); 2)\n  /// LParenLoc: location of '('; 3) EndLoc: ending location of the clause.\n  /// \\param Vars The original expression used in the clause.\n  /// \\param Declarations Declarations used in the clause.\n  /// \\param ComponentLists Component lists used in the clause.\n  /// \\param MotionModifiers Motion-modifiers.\n  /// \\param MotionModifiersLoc Location of motion-modifiers.\n  /// \\param UDMapperRefs References to user-defined mappers associated with\n  /// expressions used in the clause.\n  /// \\param UDMQualifierLoc C++ nested name specifier for the associated\n  /// user-defined mapper.\n  /// \\param MapperId The identifier of associated user-defined mapper.\n  static OMPFromClause *\n  Create(const ASTContext &C, const OMPVarListLocTy &Locs,\n         ArrayRef<Expr *> Vars, ArrayRef<ValueDecl *> Declarations,\n         MappableExprComponentListsRef ComponentLists,\n         ArrayRef<Expr *> UDMapperRefs,\n         ArrayRef<OpenMPMotionModifierKind> MotionModifiers,\n         ArrayRef<SourceLocation> MotionModifiersLoc,\n         NestedNameSpecifierLoc UDMQualifierLoc, DeclarationNameInfo MapperId);\n\n  /// Creates an empty clause with the place for \\a NumVars variables.\n  ///\n  /// \\param C AST context.\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  static OMPFromClause *CreateEmpty(const ASTContext &C,\n                                    const OMPMappableExprListSizeTy &Sizes);\n\n  /// Fetches the motion-modifier at 'Cnt' index of array of modifiers.\n  ///\n  /// \\param Cnt index for motion-modifier.\n  OpenMPMotionModifierKind getMotionModifier(unsigned Cnt) const LLVM_READONLY {\n    assert(Cnt < NumberOfOMPMotionModifiers &&\n           \"Requested modifier exceeds the total number of modifiers.\");\n    return MotionModifiers[Cnt];\n  }\n\n  /// Fetches the motion-modifier location at 'Cnt' index of array of modifiers'\n  /// locations.\n  ///\n  /// \\param Cnt index for motion-modifier location.\n  SourceLocation getMotionModifierLoc(unsigned Cnt) const LLVM_READONLY {\n    assert(Cnt < NumberOfOMPMotionModifiers &&\n           \"Requested modifier location exceeds total number of modifiers.\");\n    return MotionModifiersLoc[Cnt];\n  }\n\n  /// Fetches ArrayRef of motion-modifiers.\n  ArrayRef<OpenMPMotionModifierKind> getMotionModifiers() const LLVM_READONLY {\n    return llvm::makeArrayRef(MotionModifiers);\n  }\n\n  /// Fetches ArrayRef of location of motion-modifiers.\n  ArrayRef<SourceLocation> getMotionModifiersLoc() const LLVM_READONLY {\n    return llvm::makeArrayRef(MotionModifiersLoc);\n  }\n\n  /// Get colon location.\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPFromClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_from;\n  }\n};\n\n/// This represents clause 'use_device_ptr' in the '#pragma omp ...'\n/// directives.\n///\n/// \\code\n/// #pragma omp target data use_device_ptr(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp target data' has clause\n/// 'use_device_ptr' with the variables 'a' and 'b'.\nclass OMPUseDevicePtrClause final\n    : public OMPMappableExprListClause<OMPUseDevicePtrClause>,\n      private llvm::TrailingObjects<\n          OMPUseDevicePtrClause, Expr *, ValueDecl *, unsigned,\n          OMPClauseMappableExprCommon::MappableComponent> {\n  friend class OMPClauseReader;\n  friend OMPMappableExprListClause;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Build clause with number of variables \\a NumVars.\n  ///\n  /// \\param Locs Locations needed to build a mappable clause. It includes 1)\n  /// StartLoc: starting location of the clause (the clause keyword); 2)\n  /// LParenLoc: location of '('; 3) EndLoc: ending location of the clause.\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  explicit OMPUseDevicePtrClause(const OMPVarListLocTy &Locs,\n                                 const OMPMappableExprListSizeTy &Sizes)\n      : OMPMappableExprListClause(llvm::omp::OMPC_use_device_ptr, Locs, Sizes) {\n  }\n\n  /// Build an empty clause.\n  ///\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  explicit OMPUseDevicePtrClause(const OMPMappableExprListSizeTy &Sizes)\n      : OMPMappableExprListClause(llvm::omp::OMPC_use_device_ptr,\n                                  OMPVarListLocTy(), Sizes) {}\n\n  /// Define the sizes of each trailing object array except the last one. This\n  /// is required for TrailingObjects to work properly.\n  size_t numTrailingObjects(OverloadToken<Expr *>) const {\n    return 3 * varlist_size();\n  }\n  size_t numTrailingObjects(OverloadToken<ValueDecl *>) const {\n    return getUniqueDeclarationsNum();\n  }\n  size_t numTrailingObjects(OverloadToken<unsigned>) const {\n    return getUniqueDeclarationsNum() + getTotalComponentListNum();\n  }\n\n  /// Sets the list of references to private copies with initializers for new\n  /// private variables.\n  /// \\param VL List of references.\n  void setPrivateCopies(ArrayRef<Expr *> VL);\n\n  /// Gets the list of references to private copies with initializers for new\n  /// private variables.\n  MutableArrayRef<Expr *> getPrivateCopies() {\n    return MutableArrayRef<Expr *>(varlist_end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getPrivateCopies() const {\n    return llvm::makeArrayRef(varlist_end(), varlist_size());\n  }\n\n  /// Sets the list of references to initializer variables for new private\n  /// variables.\n  /// \\param VL List of references.\n  void setInits(ArrayRef<Expr *> VL);\n\n  /// Gets the list of references to initializer variables for new private\n  /// variables.\n  MutableArrayRef<Expr *> getInits() {\n    return MutableArrayRef<Expr *>(getPrivateCopies().end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getInits() const {\n    return llvm::makeArrayRef(getPrivateCopies().end(), varlist_size());\n  }\n\npublic:\n  /// Creates clause with a list of variables \\a Vars.\n  ///\n  /// \\param C AST context.\n  /// \\param Locs Locations needed to build a mappable clause. It includes 1)\n  /// StartLoc: starting location of the clause (the clause keyword); 2)\n  /// LParenLoc: location of '('; 3) EndLoc: ending location of the clause.\n  /// \\param Vars The original expression used in the clause.\n  /// \\param PrivateVars Expressions referring to private copies.\n  /// \\param Inits Expressions referring to private copy initializers.\n  /// \\param Declarations Declarations used in the clause.\n  /// \\param ComponentLists Component lists used in the clause.\n  static OMPUseDevicePtrClause *\n  Create(const ASTContext &C, const OMPVarListLocTy &Locs,\n         ArrayRef<Expr *> Vars, ArrayRef<Expr *> PrivateVars,\n         ArrayRef<Expr *> Inits, ArrayRef<ValueDecl *> Declarations,\n         MappableExprComponentListsRef ComponentLists);\n\n  /// Creates an empty clause with the place for \\a NumVars variables.\n  ///\n  /// \\param C AST context.\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  static OMPUseDevicePtrClause *\n  CreateEmpty(const ASTContext &C, const OMPMappableExprListSizeTy &Sizes);\n\n  using private_copies_iterator = MutableArrayRef<Expr *>::iterator;\n  using private_copies_const_iterator = ArrayRef<const Expr *>::iterator;\n  using private_copies_range = llvm::iterator_range<private_copies_iterator>;\n  using private_copies_const_range =\n      llvm::iterator_range<private_copies_const_iterator>;\n\n  private_copies_range private_copies() {\n    return private_copies_range(getPrivateCopies().begin(),\n                                getPrivateCopies().end());\n  }\n\n  private_copies_const_range private_copies() const {\n    return private_copies_const_range(getPrivateCopies().begin(),\n                                      getPrivateCopies().end());\n  }\n\n  using inits_iterator = MutableArrayRef<Expr *>::iterator;\n  using inits_const_iterator = ArrayRef<const Expr *>::iterator;\n  using inits_range = llvm::iterator_range<inits_iterator>;\n  using inits_const_range = llvm::iterator_range<inits_const_iterator>;\n\n  inits_range inits() {\n    return inits_range(getInits().begin(), getInits().end());\n  }\n\n  inits_const_range inits() const {\n    return inits_const_range(getInits().begin(), getInits().end());\n  }\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPUseDevicePtrClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_use_device_ptr;\n  }\n};\n\n/// This represents clause 'use_device_addr' in the '#pragma omp ...'\n/// directives.\n///\n/// \\code\n/// #pragma omp target data use_device_addr(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp target data' has clause\n/// 'use_device_addr' with the variables 'a' and 'b'.\nclass OMPUseDeviceAddrClause final\n    : public OMPMappableExprListClause<OMPUseDeviceAddrClause>,\n      private llvm::TrailingObjects<\n          OMPUseDeviceAddrClause, Expr *, ValueDecl *, unsigned,\n          OMPClauseMappableExprCommon::MappableComponent> {\n  friend class OMPClauseReader;\n  friend OMPMappableExprListClause;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Build clause with number of variables \\a NumVars.\n  ///\n  /// \\param Locs Locations needed to build a mappable clause. It includes 1)\n  /// StartLoc: starting location of the clause (the clause keyword); 2)\n  /// LParenLoc: location of '('; 3) EndLoc: ending location of the clause.\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  explicit OMPUseDeviceAddrClause(const OMPVarListLocTy &Locs,\n                                  const OMPMappableExprListSizeTy &Sizes)\n      : OMPMappableExprListClause(llvm::omp::OMPC_use_device_addr, Locs,\n                                  Sizes) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  explicit OMPUseDeviceAddrClause(const OMPMappableExprListSizeTy &Sizes)\n      : OMPMappableExprListClause(llvm::omp::OMPC_use_device_addr,\n                                  OMPVarListLocTy(), Sizes) {}\n\n  /// Define the sizes of each trailing object array except the last one. This\n  /// is required for TrailingObjects to work properly.\n  size_t numTrailingObjects(OverloadToken<Expr *>) const {\n    return varlist_size();\n  }\n  size_t numTrailingObjects(OverloadToken<ValueDecl *>) const {\n    return getUniqueDeclarationsNum();\n  }\n  size_t numTrailingObjects(OverloadToken<unsigned>) const {\n    return getUniqueDeclarationsNum() + getTotalComponentListNum();\n  }\n\npublic:\n  /// Creates clause with a list of variables \\a Vars.\n  ///\n  /// \\param C AST context.\n  /// \\param Locs Locations needed to build a mappable clause. It includes 1)\n  /// StartLoc: starting location of the clause (the clause keyword); 2)\n  /// LParenLoc: location of '('; 3) EndLoc: ending location of the clause.\n  /// \\param Vars The original expression used in the clause.\n  /// \\param Declarations Declarations used in the clause.\n  /// \\param ComponentLists Component lists used in the clause.\n  static OMPUseDeviceAddrClause *\n  Create(const ASTContext &C, const OMPVarListLocTy &Locs,\n         ArrayRef<Expr *> Vars, ArrayRef<ValueDecl *> Declarations,\n         MappableExprComponentListsRef ComponentLists);\n\n  /// Creates an empty clause with the place for \\a NumVars variables.\n  ///\n  /// \\param C AST context.\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  static OMPUseDeviceAddrClause *\n  CreateEmpty(const ASTContext &C, const OMPMappableExprListSizeTy &Sizes);\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPUseDeviceAddrClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_use_device_addr;\n  }\n};\n\n/// This represents clause 'is_device_ptr' in the '#pragma omp ...'\n/// directives.\n///\n/// \\code\n/// #pragma omp target is_device_ptr(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp target' has clause\n/// 'is_device_ptr' with the variables 'a' and 'b'.\nclass OMPIsDevicePtrClause final\n    : public OMPMappableExprListClause<OMPIsDevicePtrClause>,\n      private llvm::TrailingObjects<\n          OMPIsDevicePtrClause, Expr *, ValueDecl *, unsigned,\n          OMPClauseMappableExprCommon::MappableComponent> {\n  friend class OMPClauseReader;\n  friend OMPMappableExprListClause;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Build clause with number of variables \\a NumVars.\n  ///\n  /// \\param Locs Locations needed to build a mappable clause. It includes 1)\n  /// StartLoc: starting location of the clause (the clause keyword); 2)\n  /// LParenLoc: location of '('; 3) EndLoc: ending location of the clause.\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  explicit OMPIsDevicePtrClause(const OMPVarListLocTy &Locs,\n                                const OMPMappableExprListSizeTy &Sizes)\n      : OMPMappableExprListClause(llvm::omp::OMPC_is_device_ptr, Locs, Sizes) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  explicit OMPIsDevicePtrClause(const OMPMappableExprListSizeTy &Sizes)\n      : OMPMappableExprListClause(llvm::omp::OMPC_is_device_ptr,\n                                  OMPVarListLocTy(), Sizes) {}\n\n  /// Define the sizes of each trailing object array except the last one. This\n  /// is required for TrailingObjects to work properly.\n  size_t numTrailingObjects(OverloadToken<Expr *>) const {\n    return varlist_size();\n  }\n  size_t numTrailingObjects(OverloadToken<ValueDecl *>) const {\n    return getUniqueDeclarationsNum();\n  }\n  size_t numTrailingObjects(OverloadToken<unsigned>) const {\n    return getUniqueDeclarationsNum() + getTotalComponentListNum();\n  }\n\npublic:\n  /// Creates clause with a list of variables \\a Vars.\n  ///\n  /// \\param C AST context.\n  /// \\param Locs Locations needed to build a mappable clause. It includes 1)\n  /// StartLoc: starting location of the clause (the clause keyword); 2)\n  /// LParenLoc: location of '('; 3) EndLoc: ending location of the clause.\n  /// \\param Vars The original expression used in the clause.\n  /// \\param Declarations Declarations used in the clause.\n  /// \\param ComponentLists Component lists used in the clause.\n  static OMPIsDevicePtrClause *\n  Create(const ASTContext &C, const OMPVarListLocTy &Locs,\n         ArrayRef<Expr *> Vars, ArrayRef<ValueDecl *> Declarations,\n         MappableExprComponentListsRef ComponentLists);\n\n  /// Creates an empty clause with the place for \\a NumVars variables.\n  ///\n  /// \\param C AST context.\n  /// \\param Sizes All required sizes to build a mappable clause. It includes 1)\n  /// NumVars: number of expressions listed in this clause; 2)\n  /// NumUniqueDeclarations: number of unique base declarations in this clause;\n  /// 3) NumComponentLists: number of component lists in this clause; and 4)\n  /// NumComponents: total number of expression components in the clause.\n  static OMPIsDevicePtrClause *\n  CreateEmpty(const ASTContext &C, const OMPMappableExprListSizeTy &Sizes);\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPIsDevicePtrClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_is_device_ptr;\n  }\n};\n\n/// This represents clause 'nontemporal' in the '#pragma omp ...' directives.\n///\n/// \\code\n/// #pragma omp simd nontemporal(a)\n/// \\endcode\n/// In this example directive '#pragma omp simd' has clause 'nontemporal' for\n/// the variable 'a'.\nclass OMPNontemporalClause final\n    : public OMPVarListClause<OMPNontemporalClause>,\n      private llvm::TrailingObjects<OMPNontemporalClause, Expr *> {\n  friend class OMPClauseReader;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Build clause with number of variables \\a N.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param N Number of the variables in the clause.\n  OMPNontemporalClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                       SourceLocation EndLoc, unsigned N)\n      : OMPVarListClause<OMPNontemporalClause>(llvm::omp::OMPC_nontemporal,\n                                               StartLoc, LParenLoc, EndLoc, N) {\n  }\n\n  /// Build an empty clause.\n  ///\n  /// \\param N Number of variables.\n  explicit OMPNontemporalClause(unsigned N)\n      : OMPVarListClause<OMPNontemporalClause>(\n            llvm::omp::OMPC_nontemporal, SourceLocation(), SourceLocation(),\n            SourceLocation(), N) {}\n\n  /// Get the list of privatied copies if the member expression was captured by\n  /// one of the privatization clauses.\n  MutableArrayRef<Expr *> getPrivateRefs() {\n    return MutableArrayRef<Expr *>(varlist_end(), varlist_size());\n  }\n  ArrayRef<const Expr *> getPrivateRefs() const {\n    return llvm::makeArrayRef(varlist_end(), varlist_size());\n  }\n\npublic:\n  /// Creates clause with a list of variables \\a VL.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param VL List of references to the variables.\n  static OMPNontemporalClause *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation LParenLoc,\n         SourceLocation EndLoc, ArrayRef<Expr *> VL);\n\n  /// Creates an empty clause with the place for \\a N variables.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of variables.\n  static OMPNontemporalClause *CreateEmpty(const ASTContext &C, unsigned N);\n\n  /// Sets the list of references to private copies created in private clauses.\n  /// \\param VL List of references.\n  void setPrivateRefs(ArrayRef<Expr *> VL);\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPNontemporalClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range private_refs() {\n    return child_range(reinterpret_cast<Stmt **>(getPrivateRefs().begin()),\n                       reinterpret_cast<Stmt **>(getPrivateRefs().end()));\n  }\n\n  const_child_range private_refs() const {\n    auto Children = const_cast<OMPNontemporalClause *>(this)->private_refs();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_nontemporal;\n  }\n};\n\n/// This represents 'order' clause in the '#pragma omp ...' directive.\n///\n/// \\code\n/// #pragma omp simd order(concurrent)\n/// \\endcode\n/// In this example directive '#pragma omp parallel' has simple 'order'\n/// clause with kind 'concurrent'.\nclass OMPOrderClause final : public OMPClause {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// A kind of the 'default' clause.\n  OpenMPOrderClauseKind Kind = OMPC_ORDER_unknown;\n\n  /// Start location of the kind in source code.\n  SourceLocation KindKwLoc;\n\n  /// Set kind of the clause.\n  ///\n  /// \\param K Argument of clause.\n  void setKind(OpenMPOrderClauseKind K) { Kind = K; }\n\n  /// Set argument location.\n  ///\n  /// \\param KLoc Argument location.\n  void setKindKwLoc(SourceLocation KLoc) { KindKwLoc = KLoc; }\n\npublic:\n  /// Build 'order' clause with argument \\p A ('concurrent').\n  ///\n  /// \\param A Argument of the clause ('concurrent').\n  /// \\param ALoc Starting location of the argument.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  OMPOrderClause(OpenMPOrderClauseKind A, SourceLocation ALoc,\n                 SourceLocation StartLoc, SourceLocation LParenLoc,\n                 SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_order, StartLoc, EndLoc),\n        LParenLoc(LParenLoc), Kind(A), KindKwLoc(ALoc) {}\n\n  /// Build an empty clause.\n  OMPOrderClause()\n      : OMPClause(llvm::omp::OMPC_order, SourceLocation(), SourceLocation()) {}\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Returns kind of the clause.\n  OpenMPOrderClauseKind getKind() const { return Kind; }\n\n  /// Returns location of clause kind.\n  SourceLocation getKindKwLoc() const { return KindKwLoc; }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_order;\n  }\n};\n\n/// This represents 'destroy' clause in the '#pragma omp depobj'\n/// directive.\n///\n/// \\code\n/// #pragma omp depobj(a) destroy\n/// \\endcode\n/// In this example directive '#pragma omp depobj' has 'destroy' clause.\nclass OMPDestroyClause final : public OMPClause {\npublic:\n  /// Build 'destroy' clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param EndLoc Ending location of the clause.\n  OMPDestroyClause(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_destroy, StartLoc, EndLoc) {}\n\n  /// Build an empty clause.\n  OMPDestroyClause()\n      : OMPClause(llvm::omp::OMPC_destroy, SourceLocation(), SourceLocation()) {\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_destroy;\n  }\n};\n\n/// This represents 'detach' clause in the '#pragma omp task' directive.\n///\n/// \\code\n/// #pragma omp task detach(evt)\n/// \\endcode\n/// In this example directive '#pragma omp detach' has simple 'detach' clause\n/// with the variable 'evt'.\nclass OMPDetachClause final : public OMPClause {\n  friend class OMPClauseReader;\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n\n  /// Expression of the 'detach' clause.\n  Stmt *Evt = nullptr;\n\n  /// Set condition.\n  void setEventHandler(Expr *E) { Evt = E; }\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\npublic:\n  /// Build 'detach' clause with event-handler \\a Evt.\n  ///\n  /// \\param Evt Event handler expression.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  OMPDetachClause(Expr *Evt, SourceLocation StartLoc, SourceLocation LParenLoc,\n                  SourceLocation EndLoc)\n      : OMPClause(llvm::omp::OMPC_detach, StartLoc, EndLoc),\n        LParenLoc(LParenLoc), Evt(Evt) {}\n\n  /// Build an empty clause.\n  OMPDetachClause()\n      : OMPClause(llvm::omp::OMPC_detach, SourceLocation(), SourceLocation()) {}\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Returns event-handler expression.\n  Expr *getEventHandler() const { return cast_or_null<Expr>(Evt); }\n\n  child_range children() { return child_range(&Evt, &Evt + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Evt, &Evt + 1);\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_detach;\n  }\n};\n\n/// This represents clause 'inclusive' in the '#pragma omp scan' directive.\n///\n/// \\code\n/// #pragma omp scan inclusive(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp scan' has clause 'inclusive'\n/// with the variables 'a' and 'b'.\nclass OMPInclusiveClause final\n    : public OMPVarListClause<OMPInclusiveClause>,\n      private llvm::TrailingObjects<OMPInclusiveClause, Expr *> {\n  friend class OMPClauseReader;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Build clause with number of variables \\a N.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param N Number of the variables in the clause.\n  OMPInclusiveClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                     SourceLocation EndLoc, unsigned N)\n      : OMPVarListClause<OMPInclusiveClause>(llvm::omp::OMPC_inclusive,\n                                             StartLoc, LParenLoc, EndLoc, N) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param N Number of variables.\n  explicit OMPInclusiveClause(unsigned N)\n      : OMPVarListClause<OMPInclusiveClause>(llvm::omp::OMPC_inclusive,\n                                             SourceLocation(), SourceLocation(),\n                                             SourceLocation(), N) {}\n\npublic:\n  /// Creates clause with a list of variables \\a VL.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param VL List of references to the original variables.\n  static OMPInclusiveClause *Create(const ASTContext &C,\n                                    SourceLocation StartLoc,\n                                    SourceLocation LParenLoc,\n                                    SourceLocation EndLoc, ArrayRef<Expr *> VL);\n\n  /// Creates an empty clause with the place for \\a N variables.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of variables.\n  static OMPInclusiveClause *CreateEmpty(const ASTContext &C, unsigned N);\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPInclusiveClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_inclusive;\n  }\n};\n\n/// This represents clause 'exclusive' in the '#pragma omp scan' directive.\n///\n/// \\code\n/// #pragma omp scan exclusive(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp scan' has clause 'exclusive'\n/// with the variables 'a' and 'b'.\nclass OMPExclusiveClause final\n    : public OMPVarListClause<OMPExclusiveClause>,\n      private llvm::TrailingObjects<OMPExclusiveClause, Expr *> {\n  friend class OMPClauseReader;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Build clause with number of variables \\a N.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param N Number of the variables in the clause.\n  OMPExclusiveClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                     SourceLocation EndLoc, unsigned N)\n      : OMPVarListClause<OMPExclusiveClause>(llvm::omp::OMPC_exclusive,\n                                             StartLoc, LParenLoc, EndLoc, N) {}\n\n  /// Build an empty clause.\n  ///\n  /// \\param N Number of variables.\n  explicit OMPExclusiveClause(unsigned N)\n      : OMPVarListClause<OMPExclusiveClause>(llvm::omp::OMPC_exclusive,\n                                             SourceLocation(), SourceLocation(),\n                                             SourceLocation(), N) {}\n\npublic:\n  /// Creates clause with a list of variables \\a VL.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param VL List of references to the original variables.\n  static OMPExclusiveClause *Create(const ASTContext &C,\n                                    SourceLocation StartLoc,\n                                    SourceLocation LParenLoc,\n                                    SourceLocation EndLoc, ArrayRef<Expr *> VL);\n\n  /// Creates an empty clause with the place for \\a N variables.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of variables.\n  static OMPExclusiveClause *CreateEmpty(const ASTContext &C, unsigned N);\n\n  child_range children() {\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end()));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPExclusiveClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_exclusive;\n  }\n};\n\n/// This represents clause 'uses_allocators' in the '#pragma omp target'-based\n/// directives.\n///\n/// \\code\n/// #pragma omp target uses_allocators(default_allocator, my_allocator(traits))\n/// \\endcode\n/// In this example directive '#pragma omp target' has clause 'uses_allocators'\n/// with the allocators 'default_allocator' and user-defined 'my_allocator'.\nclass OMPUsesAllocatorsClause final\n    : public OMPClause,\n      private llvm::TrailingObjects<OMPUsesAllocatorsClause, Expr *,\n                                    SourceLocation> {\npublic:\n  /// Data for list of allocators.\n  struct Data {\n    /// Allocator.\n    Expr *Allocator = nullptr;\n    /// Allocator traits.\n    Expr *AllocatorTraits = nullptr;\n    /// Locations of '(' and ')' symbols.\n    SourceLocation LParenLoc, RParenLoc;\n  };\n\nprivate:\n  friend class OMPClauseReader;\n  friend TrailingObjects;\n\n  enum class ExprOffsets {\n    Allocator,\n    AllocatorTraits,\n    Total,\n  };\n\n  enum class ParenLocsOffsets {\n    LParen,\n    RParen,\n    Total,\n  };\n\n  /// Location of '('.\n  SourceLocation LParenLoc;\n  /// Total number of allocators in the clause.\n  unsigned NumOfAllocators = 0;\n\n  /// Build clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param N Number of allocators asssociated with the clause.\n  OMPUsesAllocatorsClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                          SourceLocation EndLoc, unsigned N)\n      : OMPClause(llvm::omp::OMPC_uses_allocators, StartLoc, EndLoc),\n        LParenLoc(LParenLoc), NumOfAllocators(N) {}\n\n  /// Build an empty clause.\n  /// \\param N Number of allocators asssociated with the clause.\n  ///\n  explicit OMPUsesAllocatorsClause(unsigned N)\n      : OMPClause(llvm::omp::OMPC_uses_allocators, SourceLocation(),\n                  SourceLocation()),\n        NumOfAllocators(N) {}\n\n  unsigned numTrailingObjects(OverloadToken<Expr *>) const {\n    return NumOfAllocators * static_cast<int>(ExprOffsets::Total);\n  }\n\n  /// Sets the location of '('.\n  void setLParenLoc(SourceLocation Loc) { LParenLoc = Loc; }\n\n  /// Sets the allocators data for the clause.\n  void setAllocatorsData(ArrayRef<OMPUsesAllocatorsClause::Data> Data);\n\npublic:\n  /// Creates clause with a list of allocators \\p Data.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param Data List of allocators.\n  static OMPUsesAllocatorsClause *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation LParenLoc,\n         SourceLocation EndLoc, ArrayRef<OMPUsesAllocatorsClause::Data> Data);\n\n  /// Creates an empty clause with the place for \\p N allocators.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of allocators.\n  static OMPUsesAllocatorsClause *CreateEmpty(const ASTContext &C, unsigned N);\n\n  /// Returns the location of '('.\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n\n  /// Returns number of allocators associated with the clause.\n  unsigned getNumberOfAllocators() const { return NumOfAllocators; }\n\n  /// Returns data for the specified allocator.\n  OMPUsesAllocatorsClause::Data getAllocatorData(unsigned I) const;\n\n  // Iterators\n  child_range children() {\n    Stmt **Begin = reinterpret_cast<Stmt **>(getTrailingObjects<Expr *>());\n    return child_range(Begin, Begin + NumOfAllocators *\n                                          static_cast<int>(ExprOffsets::Total));\n  }\n  const_child_range children() const {\n    Stmt *const *Begin =\n        reinterpret_cast<Stmt *const *>(getTrailingObjects<Expr *>());\n    return const_child_range(\n        Begin, Begin + NumOfAllocators * static_cast<int>(ExprOffsets::Total));\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_uses_allocators;\n  }\n};\n\n/// This represents clause 'affinity' in the '#pragma omp task'-based\n/// directives.\n///\n/// \\code\n/// #pragma omp task affinity(iterator(i = 0:n) : ([3][n])a, b[:n], c[i])\n/// \\endcode\n/// In this example directive '#pragma omp task' has clause 'affinity' with the\n/// affinity modifer 'iterator(i = 0:n)' and locator items '([3][n])a', 'b[:n]'\n/// and 'c[i]'.\nclass OMPAffinityClause final\n    : public OMPVarListClause<OMPAffinityClause>,\n      private llvm::TrailingObjects<OMPAffinityClause, Expr *> {\n  friend class OMPClauseReader;\n  friend OMPVarListClause;\n  friend TrailingObjects;\n\n  /// Location of ':' symbol.\n  SourceLocation ColonLoc;\n\n  /// Build clause.\n  ///\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param ColonLoc Location of ':'.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param N Number of locators asssociated with the clause.\n  OMPAffinityClause(SourceLocation StartLoc, SourceLocation LParenLoc,\n                    SourceLocation ColonLoc, SourceLocation EndLoc, unsigned N)\n      : OMPVarListClause<OMPAffinityClause>(llvm::omp::OMPC_affinity, StartLoc,\n                                            LParenLoc, EndLoc, N) {}\n\n  /// Build an empty clause.\n  /// \\param N Number of locators asssociated with the clause.\n  ///\n  explicit OMPAffinityClause(unsigned N)\n      : OMPVarListClause<OMPAffinityClause>(llvm::omp::OMPC_affinity,\n                                            SourceLocation(), SourceLocation(),\n                                            SourceLocation(), N) {}\n\n  /// Sets the affinity modifier for the clause, if any.\n  void setModifier(Expr *E) {\n    getTrailingObjects<Expr *>()[varlist_size()] = E;\n  }\n\n  /// Sets the location of ':' symbol.\n  void setColonLoc(SourceLocation Loc) { ColonLoc = Loc; }\n\npublic:\n  /// Creates clause with a modifier a list of locator items.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the clause.\n  /// \\param LParenLoc Location of '('.\n  /// \\param ColonLoc Location of ':'.\n  /// \\param EndLoc Ending location of the clause.\n  /// \\param Locators List of locator items.\n  static OMPAffinityClause *Create(const ASTContext &C, SourceLocation StartLoc,\n                                   SourceLocation LParenLoc,\n                                   SourceLocation ColonLoc,\n                                   SourceLocation EndLoc, Expr *Modifier,\n                                   ArrayRef<Expr *> Locators);\n\n  /// Creates an empty clause with the place for \\p N locator items.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of locator items.\n  static OMPAffinityClause *CreateEmpty(const ASTContext &C, unsigned N);\n\n  /// Gets affinity modifier.\n  Expr *getModifier() { return getTrailingObjects<Expr *>()[varlist_size()]; }\n  Expr *getModifier() const {\n    return getTrailingObjects<Expr *>()[varlist_size()];\n  }\n\n  /// Gets the location of ':' symbol.\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  // Iterators\n  child_range children() {\n    int Offset = getModifier() ? 1 : 0;\n    return child_range(reinterpret_cast<Stmt **>(varlist_begin()),\n                       reinterpret_cast<Stmt **>(varlist_end() + Offset));\n  }\n\n  const_child_range children() const {\n    auto Children = const_cast<OMPAffinityClause *>(this)->children();\n    return const_child_range(Children.begin(), Children.end());\n  }\n\n  child_range used_children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range used_children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  static bool classof(const OMPClause *T) {\n    return T->getClauseKind() == llvm::omp::OMPC_affinity;\n  }\n};\n\n/// This class implements a simple visitor for OMPClause\n/// subclasses.\ntemplate<class ImplClass, template <typename> class Ptr, typename RetTy>\nclass OMPClauseVisitorBase {\npublic:\n#define PTR(CLASS) Ptr<CLASS>\n#define DISPATCH(CLASS) \\\n  return static_cast<ImplClass*>(this)->Visit##CLASS(static_cast<PTR(CLASS)>(S))\n\n#define GEN_CLANG_CLAUSE_CLASS\n#define CLAUSE_CLASS(Enum, Str, Class)                                         \\\n  RetTy Visit##Class(PTR(Class) S) { DISPATCH(Class); }\n#include \"llvm/Frontend/OpenMP/OMP.inc\"\n\n  RetTy Visit(PTR(OMPClause) S) {\n    // Top switch clause: visit each OMPClause.\n    switch (S->getClauseKind()) {\n#define GEN_CLANG_CLAUSE_CLASS\n#define CLAUSE_CLASS(Enum, Str, Class)                                         \\\n  case llvm::omp::Clause::Enum:                                                \\\n    return Visit##Class(static_cast<PTR(Class)>(S));\n#define CLAUSE_NO_CLASS(Enum, Str)                                             \\\n  case llvm::omp::Clause::Enum:                                                \\\n    break;\n#include \"llvm/Frontend/OpenMP/OMP.inc\"\n    }\n  }\n  // Base case, ignore it. :)\n  RetTy VisitOMPClause(PTR(OMPClause) Node) { return RetTy(); }\n#undef PTR\n#undef DISPATCH\n};\n\ntemplate <typename T> using const_ptr = std::add_pointer_t<std::add_const_t<T>>;\n\ntemplate <class ImplClass, typename RetTy = void>\nclass OMPClauseVisitor\n    : public OMPClauseVisitorBase<ImplClass, std::add_pointer_t, RetTy> {};\ntemplate<class ImplClass, typename RetTy = void>\nclass ConstOMPClauseVisitor :\n      public OMPClauseVisitorBase <ImplClass, const_ptr, RetTy> {};\n\nclass OMPClausePrinter final : public OMPClauseVisitor<OMPClausePrinter> {\n  raw_ostream &OS;\n  const PrintingPolicy &Policy;\n\n  /// Process clauses with list of variables.\n  template <typename T> void VisitOMPClauseList(T *Node, char StartSym);\n  /// Process motion clauses.\n  template <typename T> void VisitOMPMotionClause(T *Node);\n\npublic:\n  OMPClausePrinter(raw_ostream &OS, const PrintingPolicy &Policy)\n      : OS(OS), Policy(Policy) {}\n\n#define GEN_CLANG_CLAUSE_CLASS\n#define CLAUSE_CLASS(Enum, Str, Class) void Visit##Class(Class *S);\n#include \"llvm/Frontend/OpenMP/OMP.inc\"\n};\n\nstruct OMPTraitProperty {\n  llvm::omp::TraitProperty Kind = llvm::omp::TraitProperty::invalid;\n\n  /// The raw string as we parsed it. This is needed for the `isa` trait set\n  /// (which accepts anything) and (later) extensions.\n  StringRef RawString;\n};\nstruct OMPTraitSelector {\n  Expr *ScoreOrCondition = nullptr;\n  llvm::omp::TraitSelector Kind = llvm::omp::TraitSelector::invalid;\n  llvm::SmallVector<OMPTraitProperty, 1> Properties;\n};\nstruct OMPTraitSet {\n  llvm::omp::TraitSet Kind = llvm::omp::TraitSet::invalid;\n  llvm::SmallVector<OMPTraitSelector, 2> Selectors;\n};\n\n/// Helper data structure representing the traits in a match clause of an\n/// `declare variant` or `metadirective`. The outer level is an ordered\n/// collection of selector sets, each with an associated kind and an ordered\n/// collection of selectors. A selector has a kind, an optional score/condition,\n/// and an ordered collection of properties.\nclass OMPTraitInfo {\n  /// Private constructor accesible only by ASTContext.\n  OMPTraitInfo() {}\n  friend class ASTContext;\n\npublic:\n  /// Reconstruct a (partial) OMPTraitInfo object from a mangled name.\n  OMPTraitInfo(StringRef MangledName);\n\n  /// The outermost level of selector sets.\n  llvm::SmallVector<OMPTraitSet, 2> Sets;\n\n  bool anyScoreOrCondition(\n      llvm::function_ref<bool(Expr *&, bool /* IsScore */)> Cond) {\n    return llvm::any_of(Sets, [&](OMPTraitSet &Set) {\n      return llvm::any_of(\n          Set.Selectors, [&](OMPTraitSelector &Selector) {\n            return Cond(Selector.ScoreOrCondition,\n                        /* IsScore */ Selector.Kind !=\n                            llvm::omp::TraitSelector::user_condition);\n          });\n    });\n  }\n\n  /// Create a variant match info object from this trait info object. While the\n  /// former is a flat representation the actual main difference is that the\n  /// latter uses clang::Expr to store the score/condition while the former is\n  /// independent of clang. Thus, expressions and conditions are evaluated in\n  /// this method.\n  void getAsVariantMatchInfo(ASTContext &ASTCtx,\n                             llvm::omp::VariantMatchInfo &VMI) const;\n\n  /// Return a string representation identifying this context selector.\n  std::string getMangledName() const;\n\n  /// Check the extension trait \\p TP is active.\n  bool isExtensionActive(llvm::omp::TraitProperty TP) {\n    for (const OMPTraitSet &Set : Sets) {\n      if (Set.Kind != llvm::omp::TraitSet::implementation)\n        continue;\n      for (const OMPTraitSelector &Selector : Set.Selectors) {\n        if (Selector.Kind != llvm::omp::TraitSelector::implementation_extension)\n          continue;\n        for (const OMPTraitProperty &Property : Selector.Properties) {\n          if (Property.Kind == TP)\n            return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /// Print a human readable representation into \\p OS.\n  void print(llvm::raw_ostream &OS, const PrintingPolicy &Policy) const;\n};\nllvm::raw_ostream &operator<<(llvm::raw_ostream &OS, const OMPTraitInfo &TI);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &OS, const OMPTraitInfo *TI);\n\n/// Clang specific specialization of the OMPContext to lookup target features.\nstruct TargetOMPContext final : public llvm::omp::OMPContext {\n\n  TargetOMPContext(ASTContext &ASTCtx,\n                   std::function<void(StringRef)> &&DiagUnknownTrait,\n                   const FunctionDecl *CurrentFunctionDecl);\n  virtual ~TargetOMPContext() = default;\n\n  /// See llvm::omp::OMPContext::matchesISATrait\n  bool matchesISATrait(StringRef RawString) const override;\n\nprivate:\n  std::function<bool(StringRef)> FeatureValidityCheck;\n  std::function<void(StringRef)> DiagUnknownTrait;\n  llvm::StringMap<bool> FeatureMap;\n};\n\n/// Contains data for OpenMP directives: clauses, children\n/// expressions/statements (helpers for codegen) and associated statement, if\n/// any.\nclass OMPChildren final\n    : private llvm::TrailingObjects<OMPChildren, OMPClause *, Stmt *> {\n  friend TrailingObjects;\n  friend class OMPClauseReader;\n  friend class OMPExecutableDirective;\n  template <typename T> friend class OMPDeclarativeDirective;\n\n  /// Numbers of clauses.\n  unsigned NumClauses = 0;\n  /// Number of child expressions/stmts.\n  unsigned NumChildren = 0;\n  /// true if the directive has associated statement.\n  bool HasAssociatedStmt = false;\n\n  /// Define the sizes of each trailing object array except the last one. This\n  /// is required for TrailingObjects to work properly.\n  size_t numTrailingObjects(OverloadToken<OMPClause *>) const {\n    return NumClauses;\n  }\n\n  OMPChildren() = delete;\n\n  OMPChildren(unsigned NumClauses, unsigned NumChildren, bool HasAssociatedStmt)\n      : NumClauses(NumClauses), NumChildren(NumChildren),\n        HasAssociatedStmt(HasAssociatedStmt) {}\n\n  static size_t size(unsigned NumClauses, bool HasAssociatedStmt,\n                     unsigned NumChildren);\n\n  static OMPChildren *Create(void *Mem, ArrayRef<OMPClause *> Clauses);\n  static OMPChildren *Create(void *Mem, ArrayRef<OMPClause *> Clauses, Stmt *S,\n                             unsigned NumChildren = 0);\n  static OMPChildren *CreateEmpty(void *Mem, unsigned NumClauses,\n                                  bool HasAssociatedStmt = false,\n                                  unsigned NumChildren = 0);\n\npublic:\n  unsigned getNumClauses() const { return NumClauses; }\n  unsigned getNumChildren() const { return NumChildren; }\n  bool hasAssociatedStmt() const { return HasAssociatedStmt; }\n\n  /// Set associated statement.\n  void setAssociatedStmt(Stmt *S) {\n    getTrailingObjects<Stmt *>()[NumChildren] = S;\n  }\n\n  void setChildren(ArrayRef<Stmt *> Children);\n\n  /// Sets the list of variables for this clause.\n  ///\n  /// \\param Clauses The list of clauses for the directive.\n  ///\n  void setClauses(ArrayRef<OMPClause *> Clauses);\n\n  /// Returns statement associated with the directive.\n  const Stmt *getAssociatedStmt() const {\n    return const_cast<OMPChildren *>(this)->getAssociatedStmt();\n  }\n  Stmt *getAssociatedStmt() {\n    assert(HasAssociatedStmt &&\n           \"Expected directive with the associated statement.\");\n    return getTrailingObjects<Stmt *>()[NumChildren];\n  }\n\n  /// Get the clauses storage.\n  MutableArrayRef<OMPClause *> getClauses() {\n    return llvm::makeMutableArrayRef(getTrailingObjects<OMPClause *>(),\n                                     NumClauses);\n  }\n  ArrayRef<OMPClause *> getClauses() const {\n    return const_cast<OMPChildren *>(this)->getClauses();\n  }\n\n  /// Returns the captured statement associated with the\n  /// component region within the (combined) directive.\n  ///\n  /// \\param RegionKind Component region kind.\n  const CapturedStmt *\n  getCapturedStmt(OpenMPDirectiveKind RegionKind,\n                  ArrayRef<OpenMPDirectiveKind> CaptureRegions) const {\n    assert(llvm::any_of(\n               CaptureRegions,\n               [=](const OpenMPDirectiveKind K) { return K == RegionKind; }) &&\n           \"RegionKind not found in OpenMP CaptureRegions.\");\n    auto *CS = cast<CapturedStmt>(getAssociatedStmt());\n    for (auto ThisCaptureRegion : CaptureRegions) {\n      if (ThisCaptureRegion == RegionKind)\n        return CS;\n      CS = cast<CapturedStmt>(CS->getCapturedStmt());\n    }\n    llvm_unreachable(\"Incorrect RegionKind specified for directive.\");\n  }\n\n  /// Get innermost captured statement for the construct.\n  CapturedStmt *\n  getInnermostCapturedStmt(ArrayRef<OpenMPDirectiveKind> CaptureRegions) {\n    assert(hasAssociatedStmt() && \"Must have associated captured statement.\");\n    assert(!CaptureRegions.empty() &&\n           \"At least one captured statement must be provided.\");\n    auto *CS = cast<CapturedStmt>(getAssociatedStmt());\n    for (unsigned Level = CaptureRegions.size(); Level > 1; --Level)\n      CS = cast<CapturedStmt>(CS->getCapturedStmt());\n    return CS;\n  }\n\n  const CapturedStmt *\n  getInnermostCapturedStmt(ArrayRef<OpenMPDirectiveKind> CaptureRegions) const {\n    return const_cast<OMPChildren *>(this)->getInnermostCapturedStmt(\n        CaptureRegions);\n  }\n\n  MutableArrayRef<Stmt *> getChildren();\n  ArrayRef<Stmt *> getChildren() const {\n    return const_cast<OMPChildren *>(this)->getChildren();\n  }\n\n  Stmt *getRawStmt() {\n    assert(HasAssociatedStmt &&\n           \"Expected directive with the associated statement.\");\n    if (auto *CS = dyn_cast<CapturedStmt>(getAssociatedStmt())) {\n      Stmt *S = nullptr;\n      do {\n        S = CS->getCapturedStmt();\n        CS = dyn_cast<CapturedStmt>(S);\n      } while (CS);\n      return S;\n    }\n    return getAssociatedStmt();\n  }\n  const Stmt *getRawStmt() const {\n    return const_cast<OMPChildren *>(this)->getRawStmt();\n  }\n\n  Stmt::child_range getAssociatedStmtAsRange() {\n    if (!HasAssociatedStmt)\n      return Stmt::child_range(Stmt::child_iterator(), Stmt::child_iterator());\n    return Stmt::child_range(&getTrailingObjects<Stmt *>()[NumChildren],\n                             &getTrailingObjects<Stmt *>()[NumChildren + 1]);\n  }\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_OPENMPCLAUSE_H\n"}, "23": {"id": 23, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtObjC.h", "content": "//===--- StmtObjC.h - Classes for representing ObjC statements --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n/// \\file\n/// Defines the Objective-C statement AST node classes.\n\n#ifndef LLVM_CLANG_AST_STMTOBJC_H\n#define LLVM_CLANG_AST_STMTOBJC_H\n\n#include \"clang/AST/Stmt.h\"\n#include \"llvm/Support/Compiler.h\"\n\nnamespace clang {\n\n/// Represents Objective-C's collection statement.\n///\n/// This is represented as 'for (element 'in' collection-expression)' stmt.\nclass ObjCForCollectionStmt : public Stmt {\n  enum { ELEM, COLLECTION, BODY, END_EXPR };\n  Stmt* SubExprs[END_EXPR]; // SubExprs[ELEM] is an expression or declstmt.\n  SourceLocation ForLoc;\n  SourceLocation RParenLoc;\npublic:\n  ObjCForCollectionStmt(Stmt *Elem, Expr *Collect, Stmt *Body,\n                        SourceLocation FCL, SourceLocation RPL);\n  explicit ObjCForCollectionStmt(EmptyShell Empty) :\n    Stmt(ObjCForCollectionStmtClass, Empty) { }\n\n  Stmt *getElement() { return SubExprs[ELEM]; }\n  Expr *getCollection() {\n    return reinterpret_cast<Expr*>(SubExprs[COLLECTION]);\n  }\n  Stmt *getBody() { return SubExprs[BODY]; }\n\n  const Stmt *getElement() const { return SubExprs[ELEM]; }\n  const Expr *getCollection() const {\n    return reinterpret_cast<Expr*>(SubExprs[COLLECTION]);\n  }\n  const Stmt *getBody() const { return SubExprs[BODY]; }\n\n  void setElement(Stmt *S) { SubExprs[ELEM] = S; }\n  void setCollection(Expr *E) {\n    SubExprs[COLLECTION] = reinterpret_cast<Stmt*>(E);\n  }\n  void setBody(Stmt *S) { SubExprs[BODY] = S; }\n\n  SourceLocation getForLoc() const { return ForLoc; }\n  void setForLoc(SourceLocation Loc) { ForLoc = Loc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation Loc) { RParenLoc = Loc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return ForLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return SubExprs[BODY]->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCForCollectionStmtClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[END_EXPR]);\n  }\n\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[END_EXPR]);\n  }\n};\n\n/// Represents Objective-C's \\@catch statement.\nclass ObjCAtCatchStmt : public Stmt {\nprivate:\n  VarDecl *ExceptionDecl;\n  Stmt *Body;\n  SourceLocation AtCatchLoc, RParenLoc;\n\npublic:\n  ObjCAtCatchStmt(SourceLocation atCatchLoc, SourceLocation rparenloc,\n                  VarDecl *catchVarDecl,\n                  Stmt *atCatchStmt)\n    : Stmt(ObjCAtCatchStmtClass), ExceptionDecl(catchVarDecl),\n    Body(atCatchStmt), AtCatchLoc(atCatchLoc), RParenLoc(rparenloc) { }\n\n  explicit ObjCAtCatchStmt(EmptyShell Empty) :\n    Stmt(ObjCAtCatchStmtClass, Empty) { }\n\n  const Stmt *getCatchBody() const { return Body; }\n  Stmt *getCatchBody() { return Body; }\n  void setCatchBody(Stmt *S) { Body = S; }\n\n  const VarDecl *getCatchParamDecl() const {\n    return ExceptionDecl;\n  }\n  VarDecl *getCatchParamDecl() {\n    return ExceptionDecl;\n  }\n  void setCatchParamDecl(VarDecl *D) { ExceptionDecl = D; }\n\n  SourceLocation getAtCatchLoc() const { return AtCatchLoc; }\n  void setAtCatchLoc(SourceLocation Loc) { AtCatchLoc = Loc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation Loc) { RParenLoc = Loc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AtCatchLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Body->getEndLoc(); }\n\n  bool hasEllipsis() const { return getCatchParamDecl() == nullptr; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCAtCatchStmtClass;\n  }\n\n  child_range children() { return child_range(&Body, &Body + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&Body, &Body + 1);\n  }\n};\n\n/// Represents Objective-C's \\@finally statement\nclass ObjCAtFinallyStmt : public Stmt {\n  SourceLocation AtFinallyLoc;\n  Stmt *AtFinallyStmt;\n\npublic:\n  ObjCAtFinallyStmt(SourceLocation atFinallyLoc, Stmt *atFinallyStmt)\n      : Stmt(ObjCAtFinallyStmtClass), AtFinallyLoc(atFinallyLoc),\n        AtFinallyStmt(atFinallyStmt) {}\n\n  explicit ObjCAtFinallyStmt(EmptyShell Empty) :\n    Stmt(ObjCAtFinallyStmtClass, Empty) { }\n\n  const Stmt *getFinallyBody() const { return AtFinallyStmt; }\n  Stmt *getFinallyBody() { return AtFinallyStmt; }\n  void setFinallyBody(Stmt *S) { AtFinallyStmt = S; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AtFinallyLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return AtFinallyStmt->getEndLoc();\n  }\n\n  SourceLocation getAtFinallyLoc() const { return AtFinallyLoc; }\n  void setAtFinallyLoc(SourceLocation Loc) { AtFinallyLoc = Loc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCAtFinallyStmtClass;\n  }\n\n  child_range children() {\n    return child_range(&AtFinallyStmt, &AtFinallyStmt+1);\n  }\n\n  const_child_range children() const {\n    return const_child_range(&AtFinallyStmt, &AtFinallyStmt + 1);\n  }\n};\n\n/// Represents Objective-C's \\@try ... \\@catch ... \\@finally statement.\nclass ObjCAtTryStmt : public Stmt {\nprivate:\n  // The location of the @ in the \\@try.\n  SourceLocation AtTryLoc;\n\n  // The number of catch blocks in this statement.\n  unsigned NumCatchStmts : 16;\n\n  // Whether this statement has a \\@finally statement.\n  bool HasFinally : 1;\n\n  /// Retrieve the statements that are stored after this \\@try statement.\n  ///\n  /// The order of the statements in memory follows the order in the source,\n  /// with the \\@try body first, followed by the \\@catch statements (if any)\n  /// and, finally, the \\@finally (if it exists).\n  Stmt **getStmts() { return reinterpret_cast<Stmt **> (this + 1); }\n  const Stmt* const *getStmts() const {\n    return reinterpret_cast<const Stmt * const*> (this + 1);\n  }\n\n  ObjCAtTryStmt(SourceLocation atTryLoc, Stmt *atTryStmt,\n                Stmt **CatchStmts, unsigned NumCatchStmts,\n                Stmt *atFinallyStmt);\n\n  explicit ObjCAtTryStmt(EmptyShell Empty, unsigned NumCatchStmts,\n                         bool HasFinally)\n    : Stmt(ObjCAtTryStmtClass, Empty), NumCatchStmts(NumCatchStmts),\n      HasFinally(HasFinally) { }\n\npublic:\n  static ObjCAtTryStmt *Create(const ASTContext &Context,\n                               SourceLocation atTryLoc, Stmt *atTryStmt,\n                               Stmt **CatchStmts, unsigned NumCatchStmts,\n                               Stmt *atFinallyStmt);\n  static ObjCAtTryStmt *CreateEmpty(const ASTContext &Context,\n                                    unsigned NumCatchStmts, bool HasFinally);\n\n  /// Retrieve the location of the @ in the \\@try.\n  SourceLocation getAtTryLoc() const { return AtTryLoc; }\n  void setAtTryLoc(SourceLocation Loc) { AtTryLoc = Loc; }\n\n  /// Retrieve the \\@try body.\n  const Stmt *getTryBody() const { return getStmts()[0]; }\n  Stmt *getTryBody() { return getStmts()[0]; }\n  void setTryBody(Stmt *S) { getStmts()[0] = S; }\n\n  /// Retrieve the number of \\@catch statements in this try-catch-finally\n  /// block.\n  unsigned getNumCatchStmts() const { return NumCatchStmts; }\n\n  /// Retrieve a \\@catch statement.\n  const ObjCAtCatchStmt *getCatchStmt(unsigned I) const {\n    assert(I < NumCatchStmts && \"Out-of-bounds @catch index\");\n    return cast_or_null<ObjCAtCatchStmt>(getStmts()[I + 1]);\n  }\n\n  /// Retrieve a \\@catch statement.\n  ObjCAtCatchStmt *getCatchStmt(unsigned I) {\n    assert(I < NumCatchStmts && \"Out-of-bounds @catch index\");\n    return cast_or_null<ObjCAtCatchStmt>(getStmts()[I + 1]);\n  }\n\n  /// Set a particular catch statement.\n  void setCatchStmt(unsigned I, ObjCAtCatchStmt *S) {\n    assert(I < NumCatchStmts && \"Out-of-bounds @catch index\");\n    getStmts()[I + 1] = S;\n  }\n\n  /// Retrieve the \\@finally statement, if any.\n  const ObjCAtFinallyStmt *getFinallyStmt() const {\n    if (!HasFinally)\n      return nullptr;\n\n    return cast_or_null<ObjCAtFinallyStmt>(getStmts()[1 + NumCatchStmts]);\n  }\n  ObjCAtFinallyStmt *getFinallyStmt() {\n    if (!HasFinally)\n      return nullptr;\n\n    return cast_or_null<ObjCAtFinallyStmt>(getStmts()[1 + NumCatchStmts]);\n  }\n  void setFinallyStmt(Stmt *S) {\n    assert(HasFinally && \"@try does not have a @finally slot!\");\n    getStmts()[1 + NumCatchStmts] = S;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AtTryLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCAtTryStmtClass;\n  }\n\n  child_range children() {\n    return child_range(getStmts(),\n                       getStmts() + 1 + NumCatchStmts + HasFinally);\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_cast<ObjCAtTryStmt *>(this)->children());\n  }\n};\n\n/// Represents Objective-C's \\@synchronized statement.\n///\n/// Example:\n/// \\code\n///   @synchronized (sem) {\n///     do-something;\n///   }\n/// \\endcode\nclass ObjCAtSynchronizedStmt : public Stmt {\nprivate:\n  SourceLocation AtSynchronizedLoc;\n  enum { SYNC_EXPR, SYNC_BODY, END_EXPR };\n  Stmt* SubStmts[END_EXPR];\n\npublic:\n  ObjCAtSynchronizedStmt(SourceLocation atSynchronizedLoc, Stmt *synchExpr,\n                         Stmt *synchBody)\n  : Stmt(ObjCAtSynchronizedStmtClass) {\n    SubStmts[SYNC_EXPR] = synchExpr;\n    SubStmts[SYNC_BODY] = synchBody;\n    AtSynchronizedLoc = atSynchronizedLoc;\n  }\n  explicit ObjCAtSynchronizedStmt(EmptyShell Empty) :\n    Stmt(ObjCAtSynchronizedStmtClass, Empty) { }\n\n  SourceLocation getAtSynchronizedLoc() const { return AtSynchronizedLoc; }\n  void setAtSynchronizedLoc(SourceLocation Loc) { AtSynchronizedLoc = Loc; }\n\n  const CompoundStmt *getSynchBody() const {\n    return reinterpret_cast<CompoundStmt*>(SubStmts[SYNC_BODY]);\n  }\n  CompoundStmt *getSynchBody() {\n    return reinterpret_cast<CompoundStmt*>(SubStmts[SYNC_BODY]);\n  }\n  void setSynchBody(Stmt *S) { SubStmts[SYNC_BODY] = S; }\n\n  const Expr *getSynchExpr() const {\n    return reinterpret_cast<Expr*>(SubStmts[SYNC_EXPR]);\n  }\n  Expr *getSynchExpr() {\n    return reinterpret_cast<Expr*>(SubStmts[SYNC_EXPR]);\n  }\n  void setSynchExpr(Stmt *S) { SubStmts[SYNC_EXPR] = S; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AtSynchronizedLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getSynchBody()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCAtSynchronizedStmtClass;\n  }\n\n  child_range children() {\n    return child_range(&SubStmts[0], &SubStmts[0]+END_EXPR);\n  }\n\n  const_child_range children() const {\n    return const_child_range(&SubStmts[0], &SubStmts[0] + END_EXPR);\n  }\n};\n\n/// Represents Objective-C's \\@throw statement.\nclass ObjCAtThrowStmt : public Stmt {\n  SourceLocation AtThrowLoc;\n  Stmt *Throw;\n\npublic:\n  ObjCAtThrowStmt(SourceLocation atThrowLoc, Stmt *throwExpr)\n  : Stmt(ObjCAtThrowStmtClass), Throw(throwExpr) {\n    AtThrowLoc = atThrowLoc;\n  }\n  explicit ObjCAtThrowStmt(EmptyShell Empty) :\n    Stmt(ObjCAtThrowStmtClass, Empty) { }\n\n  const Expr *getThrowExpr() const { return reinterpret_cast<Expr*>(Throw); }\n  Expr *getThrowExpr() { return reinterpret_cast<Expr*>(Throw); }\n  void setThrowExpr(Stmt *S) { Throw = S; }\n\n  SourceLocation getThrowLoc() const LLVM_READONLY { return AtThrowLoc; }\n  void setThrowLoc(SourceLocation Loc) { AtThrowLoc = Loc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AtThrowLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return Throw ? Throw->getEndLoc() : AtThrowLoc;\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCAtThrowStmtClass;\n  }\n\n  child_range children() { return child_range(&Throw, &Throw+1); }\n\n  const_child_range children() const {\n    return const_child_range(&Throw, &Throw + 1);\n  }\n};\n\n/// Represents Objective-C's \\@autoreleasepool Statement\nclass ObjCAutoreleasePoolStmt : public Stmt {\n  SourceLocation AtLoc;\n  Stmt *SubStmt;\n\npublic:\n  ObjCAutoreleasePoolStmt(SourceLocation atLoc, Stmt *subStmt)\n      : Stmt(ObjCAutoreleasePoolStmtClass), AtLoc(atLoc), SubStmt(subStmt) {}\n\n  explicit ObjCAutoreleasePoolStmt(EmptyShell Empty) :\n    Stmt(ObjCAutoreleasePoolStmtClass, Empty) { }\n\n  const Stmt *getSubStmt() const { return SubStmt; }\n  Stmt *getSubStmt() { return SubStmt; }\n  void setSubStmt(Stmt *S) { SubStmt = S; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AtLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return SubStmt->getEndLoc();\n  }\n\n  SourceLocation getAtLoc() const { return AtLoc; }\n  void setAtLoc(SourceLocation Loc) { AtLoc = Loc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ObjCAutoreleasePoolStmtClass;\n  }\n\n  child_range children() { return child_range(&SubStmt, &SubStmt + 1); }\n\n  const_child_range children() const {\n    return const_child_range(&SubStmt, &SubStmt + 1);\n  }\n};\n\n}  // end namespace clang\n\n#endif\n"}, "24": {"id": 24, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "content": "//===- StmtOpenMP.h - Classes for OpenMP directives  ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file\n/// This file defines OpenMP AST classes for executable directives and\n/// clauses.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_STMTOPENMP_H\n#define LLVM_CLANG_AST_STMTOPENMP_H\n\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/OpenMPClause.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/StmtCXX.h\"\n#include \"clang/Basic/OpenMPKinds.h\"\n#include \"clang/Basic/SourceLocation.h\"\n\nnamespace clang {\n\n//===----------------------------------------------------------------------===//\n// AST classes for directives.\n//===----------------------------------------------------------------------===//\n\n/// Representation of an OpenMP canonical loop.\n///\n/// OpenMP 1.0 C/C++, section 2.4.1 for Construct; canonical-shape\n/// OpenMP 2.0 C/C++, section 2.4.1 for Construct; canonical-shape\n/// OpenMP 2.5, section 2.5.1 Loop Construct; canonical form\n/// OpenMP 3.1, section 2.5.1 Loop Construct; canonical form\n/// OpenMP 4.0, section 2.6 Canonical Loop Form\n/// OpenMP 4.5, section 2.6 Canonical Loop Form\n/// OpenMP 5.0, section 2.9.1 Canonical Loop Form\n/// OpenMP 5.1, section 2.11.1 Canonical Loop Nest Form\n///\n/// An OpenMP canonical loop is a for-statement or range-based for-statement\n/// with additional requirements that ensure that the number of iterations is\n/// known before entering the loop and allow skipping to an arbitrary iteration.\n/// The OMPCanonicalLoop AST node wraps a ForStmt or CXXForRangeStmt that is\n/// known to fulfill OpenMP's canonical loop requirements because of being\n/// associated to an OMPLoopBasedDirective. That is, the general structure is:\n///\n///  OMPLoopBasedDirective\n/// [`- CapturedStmt   ]\n/// [   `- CapturedDecl]\n///        ` OMPCanonicalLoop\n///          `- ForStmt/CXXForRangeStmt\n///             `- Stmt\n///\n/// One or multiple CapturedStmt/CapturedDecl pairs may be inserted by some\n/// directives such as OMPParallelForDirective, but others do not need them\n/// (such as OMPTileDirective). In  The OMPCanonicalLoop and\n/// ForStmt/CXXForRangeStmt pair is repeated for loop associated with the\n/// directive. A OMPCanonicalLoop must not appear in the AST unless associated\n/// with a OMPLoopBasedDirective. In an imperfectly nested loop nest, the\n/// OMPCanonicalLoop may also be wrapped in a CompoundStmt:\n///\n/// [...]\n///  ` OMPCanonicalLoop\n///    `- ForStmt/CXXForRangeStmt\n///       `- CompoundStmt\n///          |- Leading in-between code (if any)\n///          |- OMPCanonicalLoop\n///          |  `- ForStmt/CXXForRangeStmt\n///          |     `- ...\n///          `- Trailing in-between code (if any)\n///\n/// The leading/trailing in-between code must not itself be a OMPCanonicalLoop\n/// to avoid confusion which loop belongs to the nesting.\n///\n/// There are three different kinds of iteration variables for different\n/// purposes:\n/// * Loop user variable: The user-accessible variable with different value for\n///   each iteration.\n/// * Loop iteration variable: The variable used to identify a loop iteration;\n///   for range-based for-statement, this is the hidden iterator '__begin'. For\n///   other loops, it is identical to the loop user variable. Must be a\n///   random-access iterator, pointer or integer type.\n/// * Logical iteration counter: Normalized loop counter starting at 0 and\n///   incrementing by one at each iteration. Allows abstracting over the type\n///   of the loop iteration variable and is always an unsigned integer type\n///   appropriate to represent the range of the loop iteration variable. Its\n///   value corresponds to the logical iteration number in the OpenMP\n///   specification.\n///\n/// This AST node provides two captured statements:\n/// * The distance function which computes the number of iterations.\n/// * The loop user variable function that computes the loop user variable when\n///   given a logical iteration number.\n///\n/// These captured statements provide the link between C/C++ semantics and the\n/// logical iteration counters used by the OpenMPIRBuilder which is\n/// language-agnostic and therefore does not know e.g. how to advance a\n/// random-access iterator. The OpenMPIRBuilder will use this information to\n/// apply simd, workshare-loop, distribute, taskloop and loop directives to the\n/// loop. For compatibility with the non-OpenMPIRBuilder codegen path, an\n/// OMPCanonicalLoop can itself also be wrapped into the CapturedStmts of an\n/// OMPLoopDirective and skipped when searching for the associated syntactical\n/// loop.\n///\n/// Example:\n/// <code>\n///   std::vector<std::string> Container{1,2,3};\n///   for (std::string Str : Container)\n///      Body(Str);\n/// </code>\n/// which is syntactic sugar for approximately:\n/// <code>\n///   auto &&__range = Container;\n///   auto __begin = std::begin(__range);\n///   auto __end = std::end(__range);\n///   for (; __begin != __end; ++__begin) {\n///     std::String Str = *__begin;\n///     Body(Str);\n///   }\n/// </code>\n/// In this example, the loop user variable is `Str`, the loop iteration\n/// variable is `__begin` of type `std::vector<std::string>::iterator` and the\n/// logical iteration number type is `size_t` (unsigned version of\n/// `std::vector<std::string>::iterator::difference_type` aka `ptrdiff_t`).\n/// Therefore, the distance function will be\n/// <code>\n///   [&](size_t &Result) { Result = __end - __begin; }\n/// </code>\n/// and the loop variable function is\n/// <code>\n///   [&,__begin](std::vector<std::string>::iterator &Result, size_t Logical) {\n///     Result = __begin + Logical;\n///   }\n/// </code>\n/// The variable `__begin`, aka the loop iteration variable, is captured by\n/// value because it is modified in the loop body, but both functions require\n/// the initial value. The OpenMP specification explicitly leaves unspecified\n/// when the loop expressions are evaluated such that a capture by reference is\n/// sufficient.\nclass OMPCanonicalLoop : public Stmt {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  /// Children of this AST node.\n  enum {\n    LOOP_STMT,\n    DISTANCE_FUNC,\n    LOOPVAR_FUNC,\n    LOOPVAR_REF,\n    LastSubStmt = LOOPVAR_REF\n  };\n\nprivate:\n  /// This AST node's children.\n  Stmt *SubStmts[LastSubStmt + 1] = {};\n\n  OMPCanonicalLoop() : Stmt(StmtClass::OMPCanonicalLoopClass) {}\n\npublic:\n  /// Create a new OMPCanonicalLoop.\n  static OMPCanonicalLoop *create(const ASTContext &Ctx, Stmt *LoopStmt,\n                                  CapturedStmt *DistanceFunc,\n                                  CapturedStmt *LoopVarFunc,\n                                  DeclRefExpr *LoopVarRef) {\n    OMPCanonicalLoop *S = new (Ctx) OMPCanonicalLoop();\n    S->setLoopStmt(LoopStmt);\n    S->setDistanceFunc(DistanceFunc);\n    S->setLoopVarFunc(LoopVarFunc);\n    S->setLoopVarRef(LoopVarRef);\n    return S;\n  }\n\n  /// Create an empty OMPCanonicalLoop for deserialization.\n  static OMPCanonicalLoop *createEmpty(const ASTContext &Ctx) {\n    return new (Ctx) OMPCanonicalLoop();\n  }\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() == StmtClass::OMPCanonicalLoopClass;\n  }\n\n  SourceLocation getBeginLoc() const { return getLoopStmt()->getBeginLoc(); }\n  SourceLocation getEndLoc() const { return getLoopStmt()->getEndLoc(); }\n\n  /// Return this AST node's children.\n  /// @{\n  child_range children() {\n    return child_range(&SubStmts[0], &SubStmts[0] + LastSubStmt + 1);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubStmts[0], &SubStmts[0] + LastSubStmt + 1);\n  }\n  /// @}\n\n  /// The wrapped syntactic loop statement (ForStmt or CXXForRangeStmt).\n  /// @{\n  Stmt *getLoopStmt() { return SubStmts[LOOP_STMT]; }\n  const Stmt *getLoopStmt() const { return SubStmts[LOOP_STMT]; }\n  void setLoopStmt(Stmt *S) {\n    assert((isa<ForStmt>(S) || isa<CXXForRangeStmt>(S)) &&\n           \"Canonical loop must be a for loop (range-based or otherwise)\");\n    SubStmts[LOOP_STMT] = S;\n  }\n  /// @}\n\n  /// The function that computes the number of loop iterations. Can be evaluated\n  /// before entering the loop but after the syntactical loop's init\n  /// statement(s).\n  ///\n  /// Function signature: void(LogicalTy &Result)\n  /// Any values necessary to compute the distance are captures of the closure.\n  /// @{\n  CapturedStmt *getDistanceFunc() {\n    return cast<CapturedStmt>(SubStmts[DISTANCE_FUNC]);\n  }\n  const CapturedStmt *getDistanceFunc() const {\n    return cast<CapturedStmt>(SubStmts[DISTANCE_FUNC]);\n  }\n  void setDistanceFunc(CapturedStmt *S) {\n    assert(S && \"Expected non-null captured statement\");\n    SubStmts[DISTANCE_FUNC] = S;\n  }\n  /// @}\n\n  /// The function that computes the loop user variable from a logical iteration\n  /// counter. Can be evaluated as first statement in the loop.\n  ///\n  /// Function signature: void(LoopVarTy &Result, LogicalTy Number)\n  /// Any other values required to compute the loop user variable (such as start\n  /// value, step size) are captured by the closure. In particular, the initial\n  /// value of loop iteration variable is captured by value to be unaffected by\n  /// previous iterations.\n  /// @{\n  CapturedStmt *getLoopVarFunc() {\n    return cast<CapturedStmt>(SubStmts[LOOPVAR_FUNC]);\n  }\n  const CapturedStmt *getLoopVarFunc() const {\n    return cast<CapturedStmt>(SubStmts[LOOPVAR_FUNC]);\n  }\n  void setLoopVarFunc(CapturedStmt *S) {\n    assert(S && \"Expected non-null captured statement\");\n    SubStmts[LOOPVAR_FUNC] = S;\n  }\n  /// @}\n\n  /// Reference to the loop user variable as accessed in the loop body.\n  /// @{\n  DeclRefExpr *getLoopVarRef() {\n    return cast<DeclRefExpr>(SubStmts[LOOPVAR_REF]);\n  }\n  const DeclRefExpr *getLoopVarRef() const {\n    return cast<DeclRefExpr>(SubStmts[LOOPVAR_REF]);\n  }\n  void setLoopVarRef(DeclRefExpr *E) {\n    assert(E && \"Expected non-null loop variable\");\n    SubStmts[LOOPVAR_REF] = E;\n  }\n  /// @}\n};\n\n/// This is a basic class for representing single OpenMP executable\n/// directive.\n///\nclass OMPExecutableDirective : public Stmt {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\n  /// Kind of the directive.\n  OpenMPDirectiveKind Kind = llvm::omp::OMPD_unknown;\n  /// Starting location of the directive (directive keyword).\n  SourceLocation StartLoc;\n  /// Ending location of the directive.\n  SourceLocation EndLoc;\n\n  /// Get the clauses storage.\n  MutableArrayRef<OMPClause *> getClauses() {\n    if (!Data)\n      return llvm::None;\n    return Data->getClauses();\n  }\n\nprotected:\n  /// Data, associated with the directive.\n  OMPChildren *Data = nullptr;\n\n  /// Build instance of directive of class \\a K.\n  ///\n  /// \\param SC Statement class.\n  /// \\param K Kind of OpenMP directive.\n  /// \\param StartLoc Starting location of the directive (directive keyword).\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPExecutableDirective(StmtClass SC, OpenMPDirectiveKind K,\n                         SourceLocation StartLoc, SourceLocation EndLoc)\n      : Stmt(SC), Kind(K), StartLoc(std::move(StartLoc)),\n        EndLoc(std::move(EndLoc)) {}\n\n  template <typename T, typename... Params>\n  static T *createDirective(const ASTContext &C, ArrayRef<OMPClause *> Clauses,\n                            Stmt *AssociatedStmt, unsigned NumChildren,\n                            Params &&... P) {\n    void *Mem =\n        C.Allocate(sizeof(T) + OMPChildren::size(Clauses.size(), AssociatedStmt,\n                                                 NumChildren),\n                   alignof(T));\n\n    auto *Data = OMPChildren::Create(reinterpret_cast<T *>(Mem) + 1, Clauses,\n                                     AssociatedStmt, NumChildren);\n    auto *Inst = new (Mem) T(std::forward<Params>(P)...);\n    Inst->Data = Data;\n    return Inst;\n  }\n\n  template <typename T, typename... Params>\n  static T *createEmptyDirective(const ASTContext &C, unsigned NumClauses,\n                                 bool HasAssociatedStmt, unsigned NumChildren,\n                                 Params &&... P) {\n    void *Mem =\n        C.Allocate(sizeof(T) + OMPChildren::size(NumClauses, HasAssociatedStmt,\n                                                 NumChildren),\n                   alignof(T));\n    auto *Data =\n        OMPChildren::CreateEmpty(reinterpret_cast<T *>(Mem) + 1, NumClauses,\n                                 HasAssociatedStmt, NumChildren);\n    auto *Inst = new (Mem) T(std::forward<Params>(P)...);\n    Inst->Data = Data;\n    return Inst;\n  }\n\n  template <typename T>\n  static T *createEmptyDirective(const ASTContext &C, unsigned NumClauses,\n                                 bool HasAssociatedStmt = false,\n                                 unsigned NumChildren = 0) {\n    void *Mem =\n        C.Allocate(sizeof(T) + OMPChildren::size(NumClauses, HasAssociatedStmt,\n                                                 NumChildren),\n                   alignof(T));\n    auto *Data =\n        OMPChildren::CreateEmpty(reinterpret_cast<T *>(Mem) + 1, NumClauses,\n                                 HasAssociatedStmt, NumChildren);\n    auto *Inst = new (Mem) T;\n    Inst->Data = Data;\n    return Inst;\n  }\n\npublic:\n  /// Iterates over expressions/statements used in the construct.\n  class used_clauses_child_iterator\n      : public llvm::iterator_adaptor_base<\n            used_clauses_child_iterator, ArrayRef<OMPClause *>::iterator,\n            std::forward_iterator_tag, Stmt *, ptrdiff_t, Stmt *, Stmt *> {\n    ArrayRef<OMPClause *>::iterator End;\n    OMPClause::child_iterator ChildI, ChildEnd;\n\n    void MoveToNext() {\n      if (ChildI != ChildEnd)\n        return;\n      while (this->I != End) {\n        ++this->I;\n        if (this->I != End) {\n          ChildI = (*this->I)->used_children().begin();\n          ChildEnd = (*this->I)->used_children().end();\n          if (ChildI != ChildEnd)\n            return;\n        }\n      }\n    }\n\n  public:\n    explicit used_clauses_child_iterator(ArrayRef<OMPClause *> Clauses)\n        : used_clauses_child_iterator::iterator_adaptor_base(Clauses.begin()),\n          End(Clauses.end()) {\n      if (this->I != End) {\n        ChildI = (*this->I)->used_children().begin();\n        ChildEnd = (*this->I)->used_children().end();\n        MoveToNext();\n      }\n    }\n    Stmt *operator*() const { return *ChildI; }\n    Stmt *operator->() const { return **this; }\n\n    used_clauses_child_iterator &operator++() {\n      ++ChildI;\n      if (ChildI != ChildEnd)\n        return *this;\n      if (this->I != End) {\n        ++this->I;\n        if (this->I != End) {\n          ChildI = (*this->I)->used_children().begin();\n          ChildEnd = (*this->I)->used_children().end();\n        }\n      }\n      MoveToNext();\n      return *this;\n    }\n  };\n\n  static llvm::iterator_range<used_clauses_child_iterator>\n  used_clauses_children(ArrayRef<OMPClause *> Clauses) {\n    return {used_clauses_child_iterator(Clauses),\n            used_clauses_child_iterator(llvm::makeArrayRef(Clauses.end(), 0))};\n  }\n\n  /// Iterates over a filtered subrange of clauses applied to a\n  /// directive.\n  ///\n  /// This iterator visits only clauses of type SpecificClause.\n  template <typename SpecificClause>\n  class specific_clause_iterator\n      : public llvm::iterator_adaptor_base<\n            specific_clause_iterator<SpecificClause>,\n            ArrayRef<OMPClause *>::const_iterator, std::forward_iterator_tag,\n            const SpecificClause *, ptrdiff_t, const SpecificClause *,\n            const SpecificClause *> {\n    ArrayRef<OMPClause *>::const_iterator End;\n\n    void SkipToNextClause() {\n      while (this->I != End && !isa<SpecificClause>(*this->I))\n        ++this->I;\n    }\n\n  public:\n    explicit specific_clause_iterator(ArrayRef<OMPClause *> Clauses)\n        : specific_clause_iterator::iterator_adaptor_base(Clauses.begin()),\n          End(Clauses.end()) {\n      SkipToNextClause();\n    }\n\n    const SpecificClause *operator*() const {\n      return cast<SpecificClause>(*this->I);\n    }\n    const SpecificClause *operator->() const { return **this; }\n\n    specific_clause_iterator &operator++() {\n      ++this->I;\n      SkipToNextClause();\n      return *this;\n    }\n  };\n\n  template <typename SpecificClause>\n  static llvm::iterator_range<specific_clause_iterator<SpecificClause>>\n  getClausesOfKind(ArrayRef<OMPClause *> Clauses) {\n    return {specific_clause_iterator<SpecificClause>(Clauses),\n            specific_clause_iterator<SpecificClause>(\n                llvm::makeArrayRef(Clauses.end(), 0))};\n  }\n\n  template <typename SpecificClause>\n  llvm::iterator_range<specific_clause_iterator<SpecificClause>>\n  getClausesOfKind() const {\n    return getClausesOfKind<SpecificClause>(clauses());\n  }\n\n  /// Gets a single clause of the specified kind associated with the\n  /// current directive iff there is only one clause of this kind (and assertion\n  /// is fired if there is more than one clause is associated with the\n  /// directive). Returns nullptr if no clause of this kind is associated with\n  /// the directive.\n  template <typename SpecificClause>\n  const SpecificClause *getSingleClause() const {\n    auto Clauses = getClausesOfKind<SpecificClause>();\n\n    if (Clauses.begin() != Clauses.end()) {\n      assert(std::next(Clauses.begin()) == Clauses.end() &&\n             \"There are at least 2 clauses of the specified kind\");\n      return *Clauses.begin();\n    }\n    return nullptr;\n  }\n\n  /// Returns true if the current directive has one or more clauses of a\n  /// specific kind.\n  template <typename SpecificClause>\n  bool hasClausesOfKind() const {\n    auto Clauses = getClausesOfKind<SpecificClause>();\n    return Clauses.begin() != Clauses.end();\n  }\n\n  /// Returns starting location of directive kind.\n  SourceLocation getBeginLoc() const { return StartLoc; }\n  /// Returns ending location of directive.\n  SourceLocation getEndLoc() const { return EndLoc; }\n\n  /// Set starting location of directive kind.\n  ///\n  /// \\param Loc New starting location of directive.\n  ///\n  void setLocStart(SourceLocation Loc) { StartLoc = Loc; }\n  /// Set ending location of directive.\n  ///\n  /// \\param Loc New ending location of directive.\n  ///\n  void setLocEnd(SourceLocation Loc) { EndLoc = Loc; }\n\n  /// Get number of clauses.\n  unsigned getNumClauses() const {\n    if (!Data)\n      return 0;\n    return Data->getNumClauses();\n  }\n\n  /// Returns specified clause.\n  ///\n  /// \\param I Number of clause.\n  ///\n  OMPClause *getClause(unsigned I) const { return clauses()[I]; }\n\n  /// Returns true if directive has associated statement.\n  bool hasAssociatedStmt() const { return Data && Data->hasAssociatedStmt(); }\n\n  /// Returns statement associated with the directive.\n  const Stmt *getAssociatedStmt() const {\n    return const_cast<OMPExecutableDirective *>(this)->getAssociatedStmt();\n  }\n  Stmt *getAssociatedStmt() {\n    assert(hasAssociatedStmt() &&\n           \"Expected directive with the associated statement.\");\n    return Data->getAssociatedStmt();\n  }\n\n  /// Returns the captured statement associated with the\n  /// component region within the (combined) directive.\n  ///\n  /// \\param RegionKind Component region kind.\n  const CapturedStmt *getCapturedStmt(OpenMPDirectiveKind RegionKind) const {\n    assert(hasAssociatedStmt() &&\n           \"Expected directive with the associated statement.\");\n    SmallVector<OpenMPDirectiveKind, 4> CaptureRegions;\n    getOpenMPCaptureRegions(CaptureRegions, getDirectiveKind());\n    return Data->getCapturedStmt(RegionKind, CaptureRegions);\n  }\n\n  /// Get innermost captured statement for the construct.\n  CapturedStmt *getInnermostCapturedStmt() {\n    assert(hasAssociatedStmt() &&\n           \"Expected directive with the associated statement.\");\n    SmallVector<OpenMPDirectiveKind, 4> CaptureRegions;\n    getOpenMPCaptureRegions(CaptureRegions, getDirectiveKind());\n    return Data->getInnermostCapturedStmt(CaptureRegions);\n  }\n\n  const CapturedStmt *getInnermostCapturedStmt() const {\n    return const_cast<OMPExecutableDirective *>(this)\n        ->getInnermostCapturedStmt();\n  }\n\n  OpenMPDirectiveKind getDirectiveKind() const { return Kind; }\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() >= firstOMPExecutableDirectiveConstant &&\n           S->getStmtClass() <= lastOMPExecutableDirectiveConstant;\n  }\n\n  child_range children() {\n    if (!Data)\n      return child_range(child_iterator(), child_iterator());\n    return Data->getAssociatedStmtAsRange();\n  }\n\n  const_child_range children() const {\n    return const_cast<OMPExecutableDirective *>(this)->children();\n  }\n\n  ArrayRef<OMPClause *> clauses() const {\n    if (!Data)\n      return llvm::None;\n    return Data->getClauses();\n  }\n\n  /// Returns whether or not this is a Standalone directive.\n  ///\n  /// Stand-alone directives are executable directives\n  /// that have no associated user code.\n  bool isStandaloneDirective() const;\n\n  /// Returns the AST node representing OpenMP structured-block of this\n  /// OpenMP executable directive,\n  /// Prerequisite: Executable Directive must not be Standalone directive.\n  const Stmt *getStructuredBlock() const {\n    return const_cast<OMPExecutableDirective *>(this)->getStructuredBlock();\n  }\n  Stmt *getStructuredBlock();\n\n  const Stmt *getRawStmt() const {\n    return const_cast<OMPExecutableDirective *>(this)->getRawStmt();\n  }\n  Stmt *getRawStmt() {\n    assert(hasAssociatedStmt() &&\n           \"Expected directive with the associated statement.\");\n    return Data->getRawStmt();\n  }\n};\n\n/// This represents '#pragma omp parallel' directive.\n///\n/// \\code\n/// #pragma omp parallel private(a,b) reduction(+: c,d)\n/// \\endcode\n/// In this example directive '#pragma omp parallel' has clauses 'private'\n/// with the variables 'a' and 'b' and 'reduction' with operator '+' and\n/// variables 'c' and 'd'.\n///\nclass OMPParallelDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// true if the construct has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive (directive keyword).\n  /// \\param EndLoc Ending Location of the directive.\n  ///\n  OMPParallelDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPParallelDirectiveClass,\n                               llvm::omp::OMPD_parallel, StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPParallelDirective()\n      : OMPExecutableDirective(OMPParallelDirectiveClass,\n                               llvm::omp::OMPD_parallel, SourceLocation(),\n                               SourceLocation()) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) { Data->getChildren()[0] = E; }\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement associated with the directive.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  /// \\param HasCancel true if this directive has inner cancel directive.\n  ///\n  static OMPParallelDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *TaskRedRef,\n         bool HasCancel);\n\n  /// Creates an empty directive with the place for \\a N clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPParallelDirective *CreateEmpty(const ASTContext &C,\n                                           unsigned NumClauses, EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[0]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPParallelDirective *>(this)->getTaskReductionRefExpr();\n  }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPParallelDirectiveClass;\n  }\n};\n\n/// The base class for all loop-based directives, including loop transformation\n/// directives.\nclass OMPLoopBasedDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n\nprotected:\n  /// Number of collapsed loops as specified by 'collapse' clause.\n  unsigned NumAssociatedLoops = 0;\n\n  /// Build instance of loop directive of class \\a Kind.\n  ///\n  /// \\param SC Statement class.\n  /// \\param Kind Kind of OpenMP directive.\n  /// \\param StartLoc Starting location of the directive (directive keyword).\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param NumAssociatedLoops Number of loops associated with the construct.\n  ///\n  OMPLoopBasedDirective(StmtClass SC, OpenMPDirectiveKind Kind,\n                        SourceLocation StartLoc, SourceLocation EndLoc,\n                        unsigned NumAssociatedLoops)\n      : OMPExecutableDirective(SC, Kind, StartLoc, EndLoc),\n        NumAssociatedLoops(NumAssociatedLoops) {}\n\npublic:\n  /// The expressions built to support OpenMP loops in combined/composite\n  /// pragmas (e.g. pragma omp distribute parallel for)\n  struct DistCombinedHelperExprs {\n    /// DistributeLowerBound - used when composing 'omp distribute' with\n    /// 'omp for' in a same construct.\n    Expr *LB;\n    /// DistributeUpperBound - used when composing 'omp distribute' with\n    /// 'omp for' in a same construct.\n    Expr *UB;\n    /// DistributeEnsureUpperBound - used when composing 'omp distribute'\n    ///  with 'omp for' in a same construct, EUB depends on DistUB\n    Expr *EUB;\n    /// Distribute loop iteration variable init used when composing 'omp\n    /// distribute'\n    ///  with 'omp for' in a same construct\n    Expr *Init;\n    /// Distribute Loop condition used when composing 'omp distribute'\n    ///  with 'omp for' in a same construct\n    Expr *Cond;\n    /// Update of LowerBound for statically scheduled omp loops for\n    /// outer loop in combined constructs (e.g. 'distribute parallel for')\n    Expr *NLB;\n    /// Update of UpperBound for statically scheduled omp loops for\n    /// outer loop in combined constructs (e.g. 'distribute parallel for')\n    Expr *NUB;\n    /// Distribute Loop condition used when composing 'omp distribute'\n    ///  with 'omp for' in a same construct when schedule is chunked.\n    Expr *DistCond;\n    /// 'omp parallel for' loop condition used when composed with\n    /// 'omp distribute' in the same construct and when schedule is\n    /// chunked and the chunk size is 1.\n    Expr *ParForInDistCond;\n  };\n\n  /// The expressions built for the OpenMP loop CodeGen for the\n  /// whole collapsed loop nest.\n  struct HelperExprs {\n    /// Loop iteration variable.\n    Expr *IterationVarRef;\n    /// Loop last iteration number.\n    Expr *LastIteration;\n    /// Loop number of iterations.\n    Expr *NumIterations;\n    /// Calculation of last iteration.\n    Expr *CalcLastIteration;\n    /// Loop pre-condition.\n    Expr *PreCond;\n    /// Loop condition.\n    Expr *Cond;\n    /// Loop iteration variable init.\n    Expr *Init;\n    /// Loop increment.\n    Expr *Inc;\n    /// IsLastIteration - local flag variable passed to runtime.\n    Expr *IL;\n    /// LowerBound - local variable passed to runtime.\n    Expr *LB;\n    /// UpperBound - local variable passed to runtime.\n    Expr *UB;\n    /// Stride - local variable passed to runtime.\n    Expr *ST;\n    /// EnsureUpperBound -- expression UB = min(UB, NumIterations).\n    Expr *EUB;\n    /// Update of LowerBound for statically scheduled 'omp for' loops.\n    Expr *NLB;\n    /// Update of UpperBound for statically scheduled 'omp for' loops.\n    Expr *NUB;\n    /// PreviousLowerBound - local variable passed to runtime in the\n    /// enclosing schedule or null if that does not apply.\n    Expr *PrevLB;\n    /// PreviousUpperBound - local variable passed to runtime in the\n    /// enclosing schedule or null if that does not apply.\n    Expr *PrevUB;\n    /// DistInc - increment expression for distribute loop when found\n    /// combined with a further loop level (e.g. in 'distribute parallel for')\n    /// expression IV = IV + ST\n    Expr *DistInc;\n    /// PrevEUB - expression similar to EUB but to be used when loop\n    /// scheduling uses PrevLB and PrevUB (e.g.  in 'distribute parallel for'\n    /// when ensuring that the UB is either the calculated UB by the runtime or\n    /// the end of the assigned distribute chunk)\n    /// expression UB = min (UB, PrevUB)\n    Expr *PrevEUB;\n    /// Counters Loop counters.\n    SmallVector<Expr *, 4> Counters;\n    /// PrivateCounters Loop counters.\n    SmallVector<Expr *, 4> PrivateCounters;\n    /// Expressions for loop counters inits for CodeGen.\n    SmallVector<Expr *, 4> Inits;\n    /// Expressions for loop counters update for CodeGen.\n    SmallVector<Expr *, 4> Updates;\n    /// Final loop counter values for GodeGen.\n    SmallVector<Expr *, 4> Finals;\n    /// List of counters required for the generation of the non-rectangular\n    /// loops.\n    SmallVector<Expr *, 4> DependentCounters;\n    /// List of initializers required for the generation of the non-rectangular\n    /// loops.\n    SmallVector<Expr *, 4> DependentInits;\n    /// List of final conditions required for the generation of the\n    /// non-rectangular loops.\n    SmallVector<Expr *, 4> FinalsConditions;\n    /// Init statement for all captured expressions.\n    Stmt *PreInits;\n\n    /// Expressions used when combining OpenMP loop pragmas\n    DistCombinedHelperExprs DistCombinedFields;\n\n    /// Check if all the expressions are built (does not check the\n    /// worksharing ones).\n    bool builtAll() {\n      return IterationVarRef != nullptr && LastIteration != nullptr &&\n             NumIterations != nullptr && PreCond != nullptr &&\n             Cond != nullptr && Init != nullptr && Inc != nullptr;\n    }\n\n    /// Initialize all the fields to null.\n    /// \\param Size Number of elements in the\n    /// counters/finals/updates/dependent_counters/dependent_inits/finals_conditions\n    /// arrays.\n    void clear(unsigned Size) {\n      IterationVarRef = nullptr;\n      LastIteration = nullptr;\n      CalcLastIteration = nullptr;\n      PreCond = nullptr;\n      Cond = nullptr;\n      Init = nullptr;\n      Inc = nullptr;\n      IL = nullptr;\n      LB = nullptr;\n      UB = nullptr;\n      ST = nullptr;\n      EUB = nullptr;\n      NLB = nullptr;\n      NUB = nullptr;\n      NumIterations = nullptr;\n      PrevLB = nullptr;\n      PrevUB = nullptr;\n      DistInc = nullptr;\n      PrevEUB = nullptr;\n      Counters.resize(Size);\n      PrivateCounters.resize(Size);\n      Inits.resize(Size);\n      Updates.resize(Size);\n      Finals.resize(Size);\n      DependentCounters.resize(Size);\n      DependentInits.resize(Size);\n      FinalsConditions.resize(Size);\n      for (unsigned I = 0; I < Size; ++I) {\n        Counters[I] = nullptr;\n        PrivateCounters[I] = nullptr;\n        Inits[I] = nullptr;\n        Updates[I] = nullptr;\n        Finals[I] = nullptr;\n        DependentCounters[I] = nullptr;\n        DependentInits[I] = nullptr;\n        FinalsConditions[I] = nullptr;\n      }\n      PreInits = nullptr;\n      DistCombinedFields.LB = nullptr;\n      DistCombinedFields.UB = nullptr;\n      DistCombinedFields.EUB = nullptr;\n      DistCombinedFields.Init = nullptr;\n      DistCombinedFields.Cond = nullptr;\n      DistCombinedFields.NLB = nullptr;\n      DistCombinedFields.NUB = nullptr;\n      DistCombinedFields.DistCond = nullptr;\n      DistCombinedFields.ParForInDistCond = nullptr;\n    }\n  };\n\n  /// Get number of collapsed loops.\n  unsigned getLoopsNumber() const { return NumAssociatedLoops; }\n\n  /// Try to find the next loop sub-statement in the specified statement \\p\n  /// CurStmt.\n  /// \\param TryImperfectlyNestedLoops true, if we need to try to look for the\n  /// imperfectly nested loop.\n  static Stmt *tryToFindNextInnerLoop(Stmt *CurStmt,\n                                      bool TryImperfectlyNestedLoops);\n  static const Stmt *tryToFindNextInnerLoop(const Stmt *CurStmt,\n                                            bool TryImperfectlyNestedLoops) {\n    return tryToFindNextInnerLoop(const_cast<Stmt *>(CurStmt),\n                                  TryImperfectlyNestedLoops);\n  }\n\n  /// Calls the specified callback function for all the loops in \\p CurStmt,\n  /// from the outermost to the innermost.\n  static bool\n  doForAllLoops(Stmt *CurStmt, bool TryImperfectlyNestedLoops,\n                unsigned NumLoops,\n                llvm::function_ref<bool(unsigned, Stmt *)> Callback);\n  static bool\n  doForAllLoops(const Stmt *CurStmt, bool TryImperfectlyNestedLoops,\n                unsigned NumLoops,\n                llvm::function_ref<bool(unsigned, const Stmt *)> Callback) {\n    auto &&NewCallback = [Callback](unsigned Cnt, Stmt *CurStmt) {\n      return Callback(Cnt, CurStmt);\n    };\n    return doForAllLoops(const_cast<Stmt *>(CurStmt), TryImperfectlyNestedLoops,\n                         NumLoops, NewCallback);\n  }\n\n  /// Calls the specified callback function for all the loop bodies in \\p\n  /// CurStmt, from the outermost loop to the innermost.\n  static void doForAllLoopsBodies(\n      Stmt *CurStmt, bool TryImperfectlyNestedLoops, unsigned NumLoops,\n      llvm::function_ref<void(unsigned, Stmt *, Stmt *)> Callback);\n  static void doForAllLoopsBodies(\n      const Stmt *CurStmt, bool TryImperfectlyNestedLoops, unsigned NumLoops,\n      llvm::function_ref<void(unsigned, const Stmt *, const Stmt *)> Callback) {\n    auto &&NewCallback = [Callback](unsigned Cnt, Stmt *Loop, Stmt *Body) {\n      Callback(Cnt, Loop, Body);\n    };\n    doForAllLoopsBodies(const_cast<Stmt *>(CurStmt), TryImperfectlyNestedLoops,\n                        NumLoops, NewCallback);\n  }\n\n  static bool classof(const Stmt *T) {\n    if (auto *D = dyn_cast<OMPExecutableDirective>(T))\n      return isOpenMPLoopDirective(D->getDirectiveKind());\n    return false;\n  }\n};\n\n/// This is a common base class for loop directives ('omp simd', 'omp\n/// for', 'omp for simd' etc.). It is responsible for the loop code generation.\n///\nclass OMPLoopDirective : public OMPLoopBasedDirective {\n  friend class ASTStmtReader;\n\n  /// Offsets to the stored exprs.\n  /// This enumeration contains offsets to all the pointers to children\n  /// expressions stored in OMPLoopDirective.\n  /// The first 9 children are necessary for all the loop directives,\n  /// the next 8 are specific to the worksharing ones, and the next 11 are\n  /// used for combined constructs containing two pragmas associated to loops.\n  /// After the fixed children, three arrays of length NumAssociatedLoops are\n  /// allocated: loop counters, their updates and final values.\n  /// PrevLowerBound and PrevUpperBound are used to communicate blocking\n  /// information in composite constructs which require loop blocking\n  /// DistInc is used to generate the increment expression for the distribute\n  /// loop when combined with a further nested loop\n  /// PrevEnsureUpperBound is used as the EnsureUpperBound expression for the\n  /// for loop when combined with a previous distribute loop in the same pragma\n  /// (e.g. 'distribute parallel for')\n  ///\n  enum {\n    IterationVariableOffset = 0,\n    LastIterationOffset = 1,\n    CalcLastIterationOffset = 2,\n    PreConditionOffset = 3,\n    CondOffset = 4,\n    InitOffset = 5,\n    IncOffset = 6,\n    PreInitsOffset = 7,\n    // The '...End' enumerators do not correspond to child expressions - they\n    // specify the offset to the end (and start of the following counters/\n    // updates/finals/dependent_counters/dependent_inits/finals_conditions\n    // arrays).\n    DefaultEnd = 8,\n    // The following 8 exprs are used by worksharing and distribute loops only.\n    IsLastIterVariableOffset = 8,\n    LowerBoundVariableOffset = 9,\n    UpperBoundVariableOffset = 10,\n    StrideVariableOffset = 11,\n    EnsureUpperBoundOffset = 12,\n    NextLowerBoundOffset = 13,\n    NextUpperBoundOffset = 14,\n    NumIterationsOffset = 15,\n    // Offset to the end for worksharing loop directives.\n    WorksharingEnd = 16,\n    PrevLowerBoundVariableOffset = 16,\n    PrevUpperBoundVariableOffset = 17,\n    DistIncOffset = 18,\n    PrevEnsureUpperBoundOffset = 19,\n    CombinedLowerBoundVariableOffset = 20,\n    CombinedUpperBoundVariableOffset = 21,\n    CombinedEnsureUpperBoundOffset = 22,\n    CombinedInitOffset = 23,\n    CombinedConditionOffset = 24,\n    CombinedNextLowerBoundOffset = 25,\n    CombinedNextUpperBoundOffset = 26,\n    CombinedDistConditionOffset = 27,\n    CombinedParForInDistConditionOffset = 28,\n    // Offset to the end (and start of the following\n    // counters/updates/finals/dependent_counters/dependent_inits/finals_conditions\n    // arrays) for combined distribute loop directives.\n    CombinedDistributeEnd = 29,\n  };\n\n  /// Get the counters storage.\n  MutableArrayRef<Expr *> getCounters() {\n    auto **Storage = reinterpret_cast<Expr **>(\n        &Data->getChildren()[getArraysOffset(getDirectiveKind())]);\n    return llvm::makeMutableArrayRef(Storage, getLoopsNumber());\n  }\n\n  /// Get the private counters storage.\n  MutableArrayRef<Expr *> getPrivateCounters() {\n    auto **Storage = reinterpret_cast<Expr **>(\n        &Data->getChildren()[getArraysOffset(getDirectiveKind()) +\n                             getLoopsNumber()]);\n    return llvm::makeMutableArrayRef(Storage, getLoopsNumber());\n  }\n\n  /// Get the updates storage.\n  MutableArrayRef<Expr *> getInits() {\n    auto **Storage = reinterpret_cast<Expr **>(\n        &Data->getChildren()[getArraysOffset(getDirectiveKind()) +\n                             2 * getLoopsNumber()]);\n    return llvm::makeMutableArrayRef(Storage, getLoopsNumber());\n  }\n\n  /// Get the updates storage.\n  MutableArrayRef<Expr *> getUpdates() {\n    auto **Storage = reinterpret_cast<Expr **>(\n        &Data->getChildren()[getArraysOffset(getDirectiveKind()) +\n                             3 * getLoopsNumber()]);\n    return llvm::makeMutableArrayRef(Storage, getLoopsNumber());\n  }\n\n  /// Get the final counter updates storage.\n  MutableArrayRef<Expr *> getFinals() {\n    auto **Storage = reinterpret_cast<Expr **>(\n        &Data->getChildren()[getArraysOffset(getDirectiveKind()) +\n                             4 * getLoopsNumber()]);\n    return llvm::makeMutableArrayRef(Storage, getLoopsNumber());\n  }\n\n  /// Get the dependent counters storage.\n  MutableArrayRef<Expr *> getDependentCounters() {\n    auto **Storage = reinterpret_cast<Expr **>(\n        &Data->getChildren()[getArraysOffset(getDirectiveKind()) +\n                             5 * getLoopsNumber()]);\n    return llvm::makeMutableArrayRef(Storage, getLoopsNumber());\n  }\n\n  /// Get the dependent inits storage.\n  MutableArrayRef<Expr *> getDependentInits() {\n    auto **Storage = reinterpret_cast<Expr **>(\n        &Data->getChildren()[getArraysOffset(getDirectiveKind()) +\n                             6 * getLoopsNumber()]);\n    return llvm::makeMutableArrayRef(Storage, getLoopsNumber());\n  }\n\n  /// Get the finals conditions storage.\n  MutableArrayRef<Expr *> getFinalsConditions() {\n    auto **Storage = reinterpret_cast<Expr **>(\n        &Data->getChildren()[getArraysOffset(getDirectiveKind()) +\n                             7 * getLoopsNumber()]);\n    return llvm::makeMutableArrayRef(Storage, getLoopsNumber());\n  }\n\nprotected:\n  /// Build instance of loop directive of class \\a Kind.\n  ///\n  /// \\param SC Statement class.\n  /// \\param Kind Kind of OpenMP directive.\n  /// \\param StartLoc Starting location of the directive (directive keyword).\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops from 'collapse' clause.\n  ///\n  OMPLoopDirective(StmtClass SC, OpenMPDirectiveKind Kind,\n                   SourceLocation StartLoc, SourceLocation EndLoc,\n                   unsigned CollapsedNum)\n      : OMPLoopBasedDirective(SC, Kind, StartLoc, EndLoc, CollapsedNum) {}\n\n  /// Offset to the start of children expression arrays.\n  static unsigned getArraysOffset(OpenMPDirectiveKind Kind) {\n    if (isOpenMPLoopBoundSharingDirective(Kind))\n      return CombinedDistributeEnd;\n    if (isOpenMPWorksharingDirective(Kind) || isOpenMPTaskLoopDirective(Kind) ||\n        isOpenMPDistributeDirective(Kind))\n      return WorksharingEnd;\n    return DefaultEnd;\n  }\n\n  /// Children number.\n  static unsigned numLoopChildren(unsigned CollapsedNum,\n                                  OpenMPDirectiveKind Kind) {\n    return getArraysOffset(Kind) +\n           8 * CollapsedNum; // Counters, PrivateCounters, Inits,\n                             // Updates, Finals, DependentCounters,\n                             // DependentInits, FinalsConditions.\n  }\n\n  void setIterationVariable(Expr *IV) {\n    Data->getChildren()[IterationVariableOffset] = IV;\n  }\n  void setLastIteration(Expr *LI) {\n    Data->getChildren()[LastIterationOffset] = LI;\n  }\n  void setCalcLastIteration(Expr *CLI) {\n    Data->getChildren()[CalcLastIterationOffset] = CLI;\n  }\n  void setPreCond(Expr *PC) { Data->getChildren()[PreConditionOffset] = PC; }\n  void setCond(Expr *Cond) { Data->getChildren()[CondOffset] = Cond; }\n  void setInit(Expr *Init) { Data->getChildren()[InitOffset] = Init; }\n  void setInc(Expr *Inc) { Data->getChildren()[IncOffset] = Inc; }\n  void setPreInits(Stmt *PreInits) {\n    Data->getChildren()[PreInitsOffset] = PreInits;\n  }\n  void setIsLastIterVariable(Expr *IL) {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    Data->getChildren()[IsLastIterVariableOffset] = IL;\n  }\n  void setLowerBoundVariable(Expr *LB) {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    Data->getChildren()[LowerBoundVariableOffset] = LB;\n  }\n  void setUpperBoundVariable(Expr *UB) {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    Data->getChildren()[UpperBoundVariableOffset] = UB;\n  }\n  void setStrideVariable(Expr *ST) {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    Data->getChildren()[StrideVariableOffset] = ST;\n  }\n  void setEnsureUpperBound(Expr *EUB) {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    Data->getChildren()[EnsureUpperBoundOffset] = EUB;\n  }\n  void setNextLowerBound(Expr *NLB) {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    Data->getChildren()[NextLowerBoundOffset] = NLB;\n  }\n  void setNextUpperBound(Expr *NUB) {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    Data->getChildren()[NextUpperBoundOffset] = NUB;\n  }\n  void setNumIterations(Expr *NI) {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    Data->getChildren()[NumIterationsOffset] = NI;\n  }\n  void setPrevLowerBoundVariable(Expr *PrevLB) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[PrevLowerBoundVariableOffset] = PrevLB;\n  }\n  void setPrevUpperBoundVariable(Expr *PrevUB) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[PrevUpperBoundVariableOffset] = PrevUB;\n  }\n  void setDistInc(Expr *DistInc) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[DistIncOffset] = DistInc;\n  }\n  void setPrevEnsureUpperBound(Expr *PrevEUB) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[PrevEnsureUpperBoundOffset] = PrevEUB;\n  }\n  void setCombinedLowerBoundVariable(Expr *CombLB) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[CombinedLowerBoundVariableOffset] = CombLB;\n  }\n  void setCombinedUpperBoundVariable(Expr *CombUB) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[CombinedUpperBoundVariableOffset] = CombUB;\n  }\n  void setCombinedEnsureUpperBound(Expr *CombEUB) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[CombinedEnsureUpperBoundOffset] = CombEUB;\n  }\n  void setCombinedInit(Expr *CombInit) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[CombinedInitOffset] = CombInit;\n  }\n  void setCombinedCond(Expr *CombCond) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[CombinedConditionOffset] = CombCond;\n  }\n  void setCombinedNextLowerBound(Expr *CombNLB) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[CombinedNextLowerBoundOffset] = CombNLB;\n  }\n  void setCombinedNextUpperBound(Expr *CombNUB) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    Data->getChildren()[CombinedNextUpperBoundOffset] = CombNUB;\n  }\n  void setCombinedDistCond(Expr *CombDistCond) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound distribute sharing directive\");\n    Data->getChildren()[CombinedDistConditionOffset] = CombDistCond;\n  }\n  void setCombinedParForInDistCond(Expr *CombParForInDistCond) {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound distribute sharing directive\");\n    Data->getChildren()[CombinedParForInDistConditionOffset] =\n        CombParForInDistCond;\n  }\n  void setCounters(ArrayRef<Expr *> A);\n  void setPrivateCounters(ArrayRef<Expr *> A);\n  void setInits(ArrayRef<Expr *> A);\n  void setUpdates(ArrayRef<Expr *> A);\n  void setFinals(ArrayRef<Expr *> A);\n  void setDependentCounters(ArrayRef<Expr *> A);\n  void setDependentInits(ArrayRef<Expr *> A);\n  void setFinalsConditions(ArrayRef<Expr *> A);\n\npublic:\n  Expr *getIterationVariable() const {\n    return cast<Expr>(Data->getChildren()[IterationVariableOffset]);\n  }\n  Expr *getLastIteration() const {\n    return cast<Expr>(Data->getChildren()[LastIterationOffset]);\n  }\n  Expr *getCalcLastIteration() const {\n    return cast<Expr>(Data->getChildren()[CalcLastIterationOffset]);\n  }\n  Expr *getPreCond() const {\n    return cast<Expr>(Data->getChildren()[PreConditionOffset]);\n  }\n  Expr *getCond() const { return cast<Expr>(Data->getChildren()[CondOffset]); }\n  Expr *getInit() const { return cast<Expr>(Data->getChildren()[InitOffset]); }\n  Expr *getInc() const { return cast<Expr>(Data->getChildren()[IncOffset]); }\n  const Stmt *getPreInits() const {\n    return Data->getChildren()[PreInitsOffset];\n  }\n  Stmt *getPreInits() { return Data->getChildren()[PreInitsOffset]; }\n  Expr *getIsLastIterVariable() const {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    return cast<Expr>(Data->getChildren()[IsLastIterVariableOffset]);\n  }\n  Expr *getLowerBoundVariable() const {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    return cast<Expr>(Data->getChildren()[LowerBoundVariableOffset]);\n  }\n  Expr *getUpperBoundVariable() const {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    return cast<Expr>(Data->getChildren()[UpperBoundVariableOffset]);\n  }\n  Expr *getStrideVariable() const {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    return cast<Expr>(Data->getChildren()[StrideVariableOffset]);\n  }\n  Expr *getEnsureUpperBound() const {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    return cast<Expr>(Data->getChildren()[EnsureUpperBoundOffset]);\n  }\n  Expr *getNextLowerBound() const {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    return cast<Expr>(Data->getChildren()[NextLowerBoundOffset]);\n  }\n  Expr *getNextUpperBound() const {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    return cast<Expr>(Data->getChildren()[NextUpperBoundOffset]);\n  }\n  Expr *getNumIterations() const {\n    assert((isOpenMPWorksharingDirective(getDirectiveKind()) ||\n            isOpenMPTaskLoopDirective(getDirectiveKind()) ||\n            isOpenMPDistributeDirective(getDirectiveKind())) &&\n           \"expected worksharing loop directive\");\n    return cast<Expr>(Data->getChildren()[NumIterationsOffset]);\n  }\n  Expr *getPrevLowerBoundVariable() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[PrevLowerBoundVariableOffset]);\n  }\n  Expr *getPrevUpperBoundVariable() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[PrevUpperBoundVariableOffset]);\n  }\n  Expr *getDistInc() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[DistIncOffset]);\n  }\n  Expr *getPrevEnsureUpperBound() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[PrevEnsureUpperBoundOffset]);\n  }\n  Expr *getCombinedLowerBoundVariable() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedLowerBoundVariableOffset]);\n  }\n  Expr *getCombinedUpperBoundVariable() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedUpperBoundVariableOffset]);\n  }\n  Expr *getCombinedEnsureUpperBound() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedEnsureUpperBoundOffset]);\n  }\n  Expr *getCombinedInit() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedInitOffset]);\n  }\n  Expr *getCombinedCond() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedConditionOffset]);\n  }\n  Expr *getCombinedNextLowerBound() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedNextLowerBoundOffset]);\n  }\n  Expr *getCombinedNextUpperBound() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedNextUpperBoundOffset]);\n  }\n  Expr *getCombinedDistCond() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound distribute sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedDistConditionOffset]);\n  }\n  Expr *getCombinedParForInDistCond() const {\n    assert(isOpenMPLoopBoundSharingDirective(getDirectiveKind()) &&\n           \"expected loop bound distribute sharing directive\");\n    return cast<Expr>(Data->getChildren()[CombinedParForInDistConditionOffset]);\n  }\n  Stmt *getBody();\n  const Stmt *getBody() const {\n    return const_cast<OMPLoopDirective *>(this)->getBody();\n  }\n\n  ArrayRef<Expr *> counters() { return getCounters(); }\n\n  ArrayRef<Expr *> counters() const {\n    return const_cast<OMPLoopDirective *>(this)->getCounters();\n  }\n\n  ArrayRef<Expr *> private_counters() { return getPrivateCounters(); }\n\n  ArrayRef<Expr *> private_counters() const {\n    return const_cast<OMPLoopDirective *>(this)->getPrivateCounters();\n  }\n\n  ArrayRef<Expr *> inits() { return getInits(); }\n\n  ArrayRef<Expr *> inits() const {\n    return const_cast<OMPLoopDirective *>(this)->getInits();\n  }\n\n  ArrayRef<Expr *> updates() { return getUpdates(); }\n\n  ArrayRef<Expr *> updates() const {\n    return const_cast<OMPLoopDirective *>(this)->getUpdates();\n  }\n\n  ArrayRef<Expr *> finals() { return getFinals(); }\n\n  ArrayRef<Expr *> finals() const {\n    return const_cast<OMPLoopDirective *>(this)->getFinals();\n  }\n\n  ArrayRef<Expr *> dependent_counters() { return getDependentCounters(); }\n\n  ArrayRef<Expr *> dependent_counters() const {\n    return const_cast<OMPLoopDirective *>(this)->getDependentCounters();\n  }\n\n  ArrayRef<Expr *> dependent_inits() { return getDependentInits(); }\n\n  ArrayRef<Expr *> dependent_inits() const {\n    return const_cast<OMPLoopDirective *>(this)->getDependentInits();\n  }\n\n  ArrayRef<Expr *> finals_conditions() { return getFinalsConditions(); }\n\n  ArrayRef<Expr *> finals_conditions() const {\n    return const_cast<OMPLoopDirective *>(this)->getFinalsConditions();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPSimdDirectiveClass ||\n           T->getStmtClass() == OMPForDirectiveClass ||\n           T->getStmtClass() == OMPForSimdDirectiveClass ||\n           T->getStmtClass() == OMPParallelForDirectiveClass ||\n           T->getStmtClass() == OMPParallelForSimdDirectiveClass ||\n           T->getStmtClass() == OMPTaskLoopDirectiveClass ||\n           T->getStmtClass() == OMPTaskLoopSimdDirectiveClass ||\n           T->getStmtClass() == OMPMasterTaskLoopDirectiveClass ||\n           T->getStmtClass() == OMPMasterTaskLoopSimdDirectiveClass ||\n           T->getStmtClass() == OMPParallelMasterTaskLoopDirectiveClass ||\n           T->getStmtClass() == OMPParallelMasterTaskLoopSimdDirectiveClass ||\n           T->getStmtClass() == OMPDistributeDirectiveClass ||\n           T->getStmtClass() == OMPTargetParallelForDirectiveClass ||\n           T->getStmtClass() == OMPDistributeParallelForDirectiveClass ||\n           T->getStmtClass() == OMPDistributeParallelForSimdDirectiveClass ||\n           T->getStmtClass() == OMPDistributeSimdDirectiveClass ||\n           T->getStmtClass() == OMPTargetParallelForSimdDirectiveClass ||\n           T->getStmtClass() == OMPTargetSimdDirectiveClass ||\n           T->getStmtClass() == OMPTeamsDistributeDirectiveClass ||\n           T->getStmtClass() == OMPTeamsDistributeSimdDirectiveClass ||\n           T->getStmtClass() ==\n               OMPTeamsDistributeParallelForSimdDirectiveClass ||\n           T->getStmtClass() == OMPTeamsDistributeParallelForDirectiveClass ||\n           T->getStmtClass() ==\n               OMPTargetTeamsDistributeParallelForDirectiveClass ||\n           T->getStmtClass() ==\n               OMPTargetTeamsDistributeParallelForSimdDirectiveClass ||\n           T->getStmtClass() == OMPTargetTeamsDistributeDirectiveClass ||\n           T->getStmtClass() == OMPTargetTeamsDistributeSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp simd' directive.\n///\n/// \\code\n/// #pragma omp simd private(a,b) linear(i,j:s) reduction(+:c,d)\n/// \\endcode\n/// In this example directive '#pragma omp simd' has clauses 'private'\n/// with the variables 'a' and 'b', 'linear' with variables 'i', 'j' and\n/// linear step 's', 'reduction' with operator '+' and variables 'c' and 'd'.\n///\nclass OMPSimdDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPSimdDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                   unsigned CollapsedNum)\n      : OMPLoopDirective(OMPSimdDirectiveClass, llvm::omp::OMPD_simd, StartLoc,\n                         EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPSimdDirectiveClass, llvm::omp::OMPD_simd,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPSimdDirective *Create(const ASTContext &C, SourceLocation StartLoc,\n                                  SourceLocation EndLoc, unsigned CollapsedNum,\n                                  ArrayRef<OMPClause *> Clauses,\n                                  Stmt *AssociatedStmt,\n                                  const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPSimdDirective *CreateEmpty(const ASTContext &C, unsigned NumClauses,\n                                       unsigned CollapsedNum, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp for' directive.\n///\n/// \\code\n/// #pragma omp for private(a,b) reduction(+:c,d)\n/// \\endcode\n/// In this example directive '#pragma omp for' has clauses 'private' with the\n/// variables 'a' and 'b' and 'reduction' with operator '+' and variables 'c'\n/// and 'd'.\n///\nclass OMPForDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// true if current directive has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPForDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                  unsigned CollapsedNum)\n      : OMPLoopDirective(OMPForDirectiveClass, llvm::omp::OMPD_for, StartLoc,\n                         EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPForDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPForDirectiveClass, llvm::omp::OMPD_for,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) {\n    Data->getChildren()[numLoopChildren(getLoopsNumber(),\n                                        llvm::omp::OMPD_for)] = E;\n  }\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  /// \\param HasCancel true if current directive has inner cancel directive.\n  ///\n  static OMPForDirective *Create(const ASTContext &C, SourceLocation StartLoc,\n                                 SourceLocation EndLoc, unsigned CollapsedNum,\n                                 ArrayRef<OMPClause *> Clauses,\n                                 Stmt *AssociatedStmt, const HelperExprs &Exprs,\n                                 Expr *TaskRedRef, bool HasCancel);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPForDirective *CreateEmpty(const ASTContext &C, unsigned NumClauses,\n                                      unsigned CollapsedNum, EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[numLoopChildren(\n        getLoopsNumber(), llvm::omp::OMPD_for)]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPForDirective *>(this)->getTaskReductionRefExpr();\n  }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPForDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp for simd' directive.\n///\n/// \\code\n/// #pragma omp for simd private(a,b) linear(i,j:s) reduction(+:c,d)\n/// \\endcode\n/// In this example directive '#pragma omp for simd' has clauses 'private'\n/// with the variables 'a' and 'b', 'linear' with variables 'i', 'j' and\n/// linear step 's', 'reduction' with operator '+' and variables 'c' and 'd'.\n///\nclass OMPForSimdDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPForSimdDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                      unsigned CollapsedNum)\n      : OMPLoopDirective(OMPForSimdDirectiveClass, llvm::omp::OMPD_for_simd,\n                         StartLoc, EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPForSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPForSimdDirectiveClass, llvm::omp::OMPD_for_simd,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPForSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPForSimdDirective *CreateEmpty(const ASTContext &C,\n                                          unsigned NumClauses,\n                                          unsigned CollapsedNum, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPForSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp sections' directive.\n///\n/// \\code\n/// #pragma omp sections private(a,b) reduction(+:c,d)\n/// \\endcode\n/// In this example directive '#pragma omp sections' has clauses 'private' with\n/// the variables 'a' and 'b' and 'reduction' with operator '+' and variables\n/// 'c' and 'd'.\n///\nclass OMPSectionsDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// true if current directive has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPSectionsDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPSectionsDirectiveClass,\n                               llvm::omp::OMPD_sections, StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPSectionsDirective()\n      : OMPExecutableDirective(OMPSectionsDirectiveClass,\n                               llvm::omp::OMPD_sections, SourceLocation(),\n                               SourceLocation()) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) { Data->getChildren()[0] = E; }\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  /// \\param HasCancel true if current directive has inner directive.\n  ///\n  static OMPSectionsDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *TaskRedRef,\n         bool HasCancel);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPSectionsDirective *CreateEmpty(const ASTContext &C,\n                                           unsigned NumClauses, EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[0]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPSectionsDirective *>(this)->getTaskReductionRefExpr();\n  }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPSectionsDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp section' directive.\n///\n/// \\code\n/// #pragma omp section\n/// \\endcode\n///\nclass OMPSectionDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// true if current directive has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPSectionDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPSectionDirectiveClass,\n                               llvm::omp::OMPD_section, StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPSectionDirective()\n      : OMPExecutableDirective(OMPSectionDirectiveClass,\n                               llvm::omp::OMPD_section, SourceLocation(),\n                               SourceLocation()) {}\n\npublic:\n  /// Creates directive.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param HasCancel true if current directive has inner directive.\n  ///\n  static OMPSectionDirective *Create(const ASTContext &C,\n                                     SourceLocation StartLoc,\n                                     SourceLocation EndLoc,\n                                     Stmt *AssociatedStmt, bool HasCancel);\n\n  /// Creates an empty directive.\n  ///\n  /// \\param C AST context.\n  ///\n  static OMPSectionDirective *CreateEmpty(const ASTContext &C, EmptyShell);\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPSectionDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp single' directive.\n///\n/// \\code\n/// #pragma omp single private(a,b) copyprivate(c,d)\n/// \\endcode\n/// In this example directive '#pragma omp single' has clauses 'private' with\n/// the variables 'a' and 'b' and 'copyprivate' with variables 'c' and 'd'.\n///\nclass OMPSingleDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPSingleDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPSingleDirectiveClass, llvm::omp::OMPD_single,\n                               StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPSingleDirective()\n      : OMPExecutableDirective(OMPSingleDirectiveClass, llvm::omp::OMPD_single,\n                               SourceLocation(), SourceLocation()) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  ///\n  static OMPSingleDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPSingleDirective *CreateEmpty(const ASTContext &C,\n                                         unsigned NumClauses, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPSingleDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp master' directive.\n///\n/// \\code\n/// #pragma omp master\n/// \\endcode\n///\nclass OMPMasterDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPMasterDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPMasterDirectiveClass, llvm::omp::OMPD_master,\n                               StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPMasterDirective()\n      : OMPExecutableDirective(OMPMasterDirectiveClass, llvm::omp::OMPD_master,\n                               SourceLocation(), SourceLocation()) {}\n\npublic:\n  /// Creates directive.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  ///\n  static OMPMasterDirective *Create(const ASTContext &C,\n                                    SourceLocation StartLoc,\n                                    SourceLocation EndLoc,\n                                    Stmt *AssociatedStmt);\n\n  /// Creates an empty directive.\n  ///\n  /// \\param C AST context.\n  ///\n  static OMPMasterDirective *CreateEmpty(const ASTContext &C, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPMasterDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp critical' directive.\n///\n/// \\code\n/// #pragma omp critical\n/// \\endcode\n///\nclass OMPCriticalDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Name of the directive.\n  DeclarationNameInfo DirName;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param Name Name of the directive.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPCriticalDirective(const DeclarationNameInfo &Name, SourceLocation StartLoc,\n                       SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPCriticalDirectiveClass,\n                               llvm::omp::OMPD_critical, StartLoc, EndLoc),\n        DirName(Name) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPCriticalDirective()\n      : OMPExecutableDirective(OMPCriticalDirectiveClass,\n                               llvm::omp::OMPD_critical, SourceLocation(),\n                               SourceLocation()) {}\n\n  /// Set name of the directive.\n  ///\n  /// \\param Name Name of the directive.\n  ///\n  void setDirectiveName(const DeclarationNameInfo &Name) { DirName = Name; }\n\npublic:\n  /// Creates directive.\n  ///\n  /// \\param C AST context.\n  /// \\param Name Name of the directive.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  ///\n  static OMPCriticalDirective *\n  Create(const ASTContext &C, const DeclarationNameInfo &Name,\n         SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt);\n\n  /// Creates an empty directive.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPCriticalDirective *CreateEmpty(const ASTContext &C,\n                                           unsigned NumClauses, EmptyShell);\n\n  /// Return name of the directive.\n  ///\n  DeclarationNameInfo getDirectiveName() const { return DirName; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPCriticalDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp parallel for' directive.\n///\n/// \\code\n/// #pragma omp parallel for private(a,b) reduction(+:c,d)\n/// \\endcode\n/// In this example directive '#pragma omp parallel for' has clauses 'private'\n/// with the variables 'a' and 'b' and 'reduction' with operator '+' and\n/// variables 'c' and 'd'.\n///\nclass OMPParallelForDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// true if current region has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPParallelForDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                          unsigned CollapsedNum)\n      : OMPLoopDirective(OMPParallelForDirectiveClass,\n                         llvm::omp::OMPD_parallel_for, StartLoc, EndLoc,\n                         CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPParallelForDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPParallelForDirectiveClass,\n                         llvm::omp::OMPD_parallel_for, SourceLocation(),\n                         SourceLocation(), CollapsedNum) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) {\n    Data->getChildren()[numLoopChildren(getLoopsNumber(),\n                                        llvm::omp::OMPD_parallel_for)] = E;\n  }\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  /// \\param HasCancel true if current directive has inner cancel directive.\n  ///\n  static OMPParallelForDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs, Expr *TaskRedRef,\n         bool HasCancel);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPParallelForDirective *CreateEmpty(const ASTContext &C,\n                                              unsigned NumClauses,\n                                              unsigned CollapsedNum,\n                                              EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[numLoopChildren(\n        getLoopsNumber(), llvm::omp::OMPD_parallel_for)]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPParallelForDirective *>(this)\n        ->getTaskReductionRefExpr();\n  }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPParallelForDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp parallel for simd' directive.\n///\n/// \\code\n/// #pragma omp parallel for simd private(a,b) linear(i,j:s) reduction(+:c,d)\n/// \\endcode\n/// In this example directive '#pragma omp parallel for simd' has clauses\n/// 'private' with the variables 'a' and 'b', 'linear' with variables 'i', 'j'\n/// and linear step 's', 'reduction' with operator '+' and variables 'c' and\n/// 'd'.\n///\nclass OMPParallelForSimdDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPParallelForSimdDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                              unsigned CollapsedNum)\n      : OMPLoopDirective(OMPParallelForSimdDirectiveClass,\n                         llvm::omp::OMPD_parallel_for_simd, StartLoc, EndLoc,\n                         CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPParallelForSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPParallelForSimdDirectiveClass,\n                         llvm::omp::OMPD_parallel_for_simd, SourceLocation(),\n                         SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPParallelForSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPParallelForSimdDirective *CreateEmpty(const ASTContext &C,\n                                                  unsigned NumClauses,\n                                                  unsigned CollapsedNum,\n                                                  EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPParallelForSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp parallel master' directive.\n///\n/// \\code\n/// #pragma omp parallel master private(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp parallel master' has clauses\n/// 'private' with the variables 'a' and 'b'\n///\nclass OMPParallelMasterDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  OMPParallelMasterDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPParallelMasterDirectiveClass,\n                               llvm::omp::OMPD_parallel_master, StartLoc,\n                               EndLoc) {}\n\n  explicit OMPParallelMasterDirective()\n      : OMPExecutableDirective(OMPParallelMasterDirectiveClass,\n                               llvm::omp::OMPD_parallel_master,\n                               SourceLocation(), SourceLocation()) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) { Data->getChildren()[0] = E; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  ///\n  static OMPParallelMasterDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *TaskRedRef);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPParallelMasterDirective *\n  CreateEmpty(const ASTContext &C, unsigned NumClauses, EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[0]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPParallelMasterDirective *>(this)\n        ->getTaskReductionRefExpr();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPParallelMasterDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp parallel sections' directive.\n///\n/// \\code\n/// #pragma omp parallel sections private(a,b) reduction(+:c,d)\n/// \\endcode\n/// In this example directive '#pragma omp parallel sections' has clauses\n/// 'private' with the variables 'a' and 'b' and 'reduction' with operator '+'\n/// and variables 'c' and 'd'.\n///\nclass OMPParallelSectionsDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// true if current directive has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPParallelSectionsDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPParallelSectionsDirectiveClass,\n                               llvm::omp::OMPD_parallel_sections, StartLoc,\n                               EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPParallelSectionsDirective()\n      : OMPExecutableDirective(OMPParallelSectionsDirectiveClass,\n                               llvm::omp::OMPD_parallel_sections,\n                               SourceLocation(), SourceLocation()) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) { Data->getChildren()[0] = E; }\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  /// \\param HasCancel true if current directive has inner cancel directive.\n  ///\n  static OMPParallelSectionsDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *TaskRedRef,\n         bool HasCancel);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPParallelSectionsDirective *\n  CreateEmpty(const ASTContext &C, unsigned NumClauses, EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[0]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPParallelSectionsDirective *>(this)\n        ->getTaskReductionRefExpr();\n  }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPParallelSectionsDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp task' directive.\n///\n/// \\code\n/// #pragma omp task private(a,b) final(d)\n/// \\endcode\n/// In this example directive '#pragma omp task' has clauses 'private' with the\n/// variables 'a' and 'b' and 'final' with condition 'd'.\n///\nclass OMPTaskDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// true if this directive has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPTaskDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTaskDirectiveClass, llvm::omp::OMPD_task,\n                               StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTaskDirective()\n      : OMPExecutableDirective(OMPTaskDirectiveClass, llvm::omp::OMPD_task,\n                               SourceLocation(), SourceLocation()) {}\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param HasCancel true, if current directive has inner cancel directive.\n  ///\n  static OMPTaskDirective *Create(const ASTContext &C, SourceLocation StartLoc,\n                                  SourceLocation EndLoc,\n                                  ArrayRef<OMPClause *> Clauses,\n                                  Stmt *AssociatedStmt, bool HasCancel);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTaskDirective *CreateEmpty(const ASTContext &C, unsigned NumClauses,\n                                       EmptyShell);\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTaskDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp taskyield' directive.\n///\n/// \\code\n/// #pragma omp taskyield\n/// \\endcode\n///\nclass OMPTaskyieldDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPTaskyieldDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTaskyieldDirectiveClass,\n                               llvm::omp::OMPD_taskyield, StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTaskyieldDirective()\n      : OMPExecutableDirective(OMPTaskyieldDirectiveClass,\n                               llvm::omp::OMPD_taskyield, SourceLocation(),\n                               SourceLocation()) {}\n\npublic:\n  /// Creates directive.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  ///\n  static OMPTaskyieldDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc);\n\n  /// Creates an empty directive.\n  ///\n  /// \\param C AST context.\n  ///\n  static OMPTaskyieldDirective *CreateEmpty(const ASTContext &C, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTaskyieldDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp barrier' directive.\n///\n/// \\code\n/// #pragma omp barrier\n/// \\endcode\n///\nclass OMPBarrierDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPBarrierDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPBarrierDirectiveClass,\n                               llvm::omp::OMPD_barrier, StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPBarrierDirective()\n      : OMPExecutableDirective(OMPBarrierDirectiveClass,\n                               llvm::omp::OMPD_barrier, SourceLocation(),\n                               SourceLocation()) {}\n\npublic:\n  /// Creates directive.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  ///\n  static OMPBarrierDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc);\n\n  /// Creates an empty directive.\n  ///\n  /// \\param C AST context.\n  ///\n  static OMPBarrierDirective *CreateEmpty(const ASTContext &C, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPBarrierDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp taskwait' directive.\n///\n/// \\code\n/// #pragma omp taskwait\n/// \\endcode\n///\nclass OMPTaskwaitDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPTaskwaitDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTaskwaitDirectiveClass,\n                               llvm::omp::OMPD_taskwait, StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTaskwaitDirective()\n      : OMPExecutableDirective(OMPTaskwaitDirectiveClass,\n                               llvm::omp::OMPD_taskwait, SourceLocation(),\n                               SourceLocation()) {}\n\npublic:\n  /// Creates directive.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  ///\n  static OMPTaskwaitDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc);\n\n  /// Creates an empty directive.\n  ///\n  /// \\param C AST context.\n  ///\n  static OMPTaskwaitDirective *CreateEmpty(const ASTContext &C, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTaskwaitDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp taskgroup' directive.\n///\n/// \\code\n/// #pragma omp taskgroup\n/// \\endcode\n///\nclass OMPTaskgroupDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPTaskgroupDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTaskgroupDirectiveClass,\n                               llvm::omp::OMPD_taskgroup, StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTaskgroupDirective()\n      : OMPExecutableDirective(OMPTaskgroupDirectiveClass,\n                               llvm::omp::OMPD_taskgroup, SourceLocation(),\n                               SourceLocation()) {}\n\n  /// Sets the task_reduction return variable.\n  void setReductionRef(Expr *RR) { Data->getChildren()[0] = RR; }\n\npublic:\n  /// Creates directive.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param ReductionRef Reference to the task_reduction return variable.\n  ///\n  static OMPTaskgroupDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt,\n         Expr *ReductionRef);\n\n  /// Creates an empty directive.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTaskgroupDirective *CreateEmpty(const ASTContext &C,\n                                            unsigned NumClauses, EmptyShell);\n\n\n  /// Returns reference to the task_reduction return variable.\n  const Expr *getReductionRef() const {\n    return const_cast<OMPTaskgroupDirective *>(this)->getReductionRef();\n  }\n  Expr *getReductionRef() { return cast_or_null<Expr>(Data->getChildren()[0]); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTaskgroupDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp flush' directive.\n///\n/// \\code\n/// #pragma omp flush(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp flush' has 2 arguments- variables 'a'\n/// and 'b'.\n/// 'omp flush' directive does not have clauses but have an optional list of\n/// variables to flush. This list of variables is stored within some fake clause\n/// FlushClause.\nclass OMPFlushDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPFlushDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPFlushDirectiveClass, llvm::omp::OMPD_flush,\n                               StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPFlushDirective()\n      : OMPExecutableDirective(OMPFlushDirectiveClass, llvm::omp::OMPD_flush,\n                               SourceLocation(), SourceLocation()) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses (only single OMPFlushClause clause is\n  /// allowed).\n  ///\n  static OMPFlushDirective *Create(const ASTContext &C, SourceLocation StartLoc,\n                                   SourceLocation EndLoc,\n                                   ArrayRef<OMPClause *> Clauses);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPFlushDirective *CreateEmpty(const ASTContext &C,\n                                        unsigned NumClauses, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPFlushDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp depobj' directive.\n///\n/// \\code\n/// #pragma omp depobj(a) depend(in:x,y)\n/// \\endcode\n/// In this example directive '#pragma omp  depobj' initializes a depobj object\n/// 'a' with dependence type 'in' and a list with 'x' and 'y' locators.\nclass OMPDepobjDirective final : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPDepobjDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPDepobjDirectiveClass, llvm::omp::OMPD_depobj,\n                               StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPDepobjDirective()\n      : OMPExecutableDirective(OMPDepobjDirectiveClass, llvm::omp::OMPD_depobj,\n                               SourceLocation(), SourceLocation()) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  ///\n  static OMPDepobjDirective *Create(const ASTContext &C,\n                                    SourceLocation StartLoc,\n                                    SourceLocation EndLoc,\n                                    ArrayRef<OMPClause *> Clauses);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPDepobjDirective *CreateEmpty(const ASTContext &C,\n                                         unsigned NumClauses, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPDepobjDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp ordered' directive.\n///\n/// \\code\n/// #pragma omp ordered\n/// \\endcode\n///\nclass OMPOrderedDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPOrderedDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPOrderedDirectiveClass,\n                               llvm::omp::OMPD_ordered, StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPOrderedDirective()\n      : OMPExecutableDirective(OMPOrderedDirectiveClass,\n                               llvm::omp::OMPD_ordered, SourceLocation(),\n                               SourceLocation()) {}\n\npublic:\n  /// Creates directive.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  ///\n  static OMPOrderedDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt);\n\n  /// Creates an empty directive.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  /// \\param IsStandalone true, if the the standalone directive is created.\n  ///\n  static OMPOrderedDirective *CreateEmpty(const ASTContext &C,\n                                          unsigned NumClauses,\n                                          bool IsStandalone, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPOrderedDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp atomic' directive.\n///\n/// \\code\n/// #pragma omp atomic capture\n/// \\endcode\n/// In this example directive '#pragma omp atomic' has clause 'capture'.\n///\nclass OMPAtomicDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Used for 'atomic update' or 'atomic capture' constructs. They may\n  /// have atomic expressions of forms\n  /// \\code\n  /// x = x binop expr;\n  /// x = expr binop x;\n  /// \\endcode\n  /// This field is true for the first form of the expression and false for the\n  /// second. Required for correct codegen of non-associative operations (like\n  /// << or >>).\n  bool IsXLHSInRHSPart = false;\n  /// Used for 'atomic update' or 'atomic capture' constructs. They may\n  /// have atomic expressions of forms\n  /// \\code\n  /// v = x; <update x>;\n  /// <update x>; v = x;\n  /// \\endcode\n  /// This field is true for the first(postfix) form of the expression and false\n  /// otherwise.\n  bool IsPostfixUpdate = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPAtomicDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPAtomicDirectiveClass, llvm::omp::OMPD_atomic,\n                               StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPAtomicDirective()\n      : OMPExecutableDirective(OMPAtomicDirectiveClass, llvm::omp::OMPD_atomic,\n                               SourceLocation(), SourceLocation()) {}\n\n  /// Set 'x' part of the associated expression/statement.\n  void setX(Expr *X) { Data->getChildren()[0] = X; }\n  /// Set helper expression of the form\n  /// 'OpaqueValueExpr(x) binop OpaqueValueExpr(expr)' or\n  /// 'OpaqueValueExpr(expr) binop OpaqueValueExpr(x)'.\n  void setUpdateExpr(Expr *UE) { Data->getChildren()[1] = UE; }\n  /// Set 'v' part of the associated expression/statement.\n  void setV(Expr *V) { Data->getChildren()[2] = V; }\n  /// Set 'expr' part of the associated expression/statement.\n  void setExpr(Expr *E) { Data->getChildren()[3] = E; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses and 'x', 'v' and 'expr'\n  /// parts of the atomic construct (see Section 2.12.6, atomic Construct, for\n  /// detailed description of 'x', 'v' and 'expr').\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param X 'x' part of the associated expression/statement.\n  /// \\param V 'v' part of the associated expression/statement.\n  /// \\param E 'expr' part of the associated expression/statement.\n  /// \\param UE Helper expression of the form\n  /// 'OpaqueValueExpr(x) binop OpaqueValueExpr(expr)' or\n  /// 'OpaqueValueExpr(expr) binop OpaqueValueExpr(x)'.\n  /// \\param IsXLHSInRHSPart true if \\a UE has the first form and false if the\n  /// second.\n  /// \\param IsPostfixUpdate true if original value of 'x' must be stored in\n  /// 'v', not an updated one.\n  static OMPAtomicDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *X, Expr *V,\n         Expr *E, Expr *UE, bool IsXLHSInRHSPart, bool IsPostfixUpdate);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPAtomicDirective *CreateEmpty(const ASTContext &C,\n                                         unsigned NumClauses, EmptyShell);\n\n  /// Get 'x' part of the associated expression/statement.\n  Expr *getX() { return cast_or_null<Expr>(Data->getChildren()[0]); }\n  const Expr *getX() const {\n    return cast_or_null<Expr>(Data->getChildren()[0]);\n  }\n  /// Get helper expression of the form\n  /// 'OpaqueValueExpr(x) binop OpaqueValueExpr(expr)' or\n  /// 'OpaqueValueExpr(expr) binop OpaqueValueExpr(x)'.\n  Expr *getUpdateExpr() { return cast_or_null<Expr>(Data->getChildren()[1]); }\n  const Expr *getUpdateExpr() const {\n    return cast_or_null<Expr>(Data->getChildren()[1]);\n  }\n  /// Return true if helper update expression has form\n  /// 'OpaqueValueExpr(x) binop OpaqueValueExpr(expr)' and false if it has form\n  /// 'OpaqueValueExpr(expr) binop OpaqueValueExpr(x)'.\n  bool isXLHSInRHSPart() const { return IsXLHSInRHSPart; }\n  /// Return true if 'v' expression must be updated to original value of\n  /// 'x', false if 'v' must be updated to the new value of 'x'.\n  bool isPostfixUpdate() const { return IsPostfixUpdate; }\n  /// Get 'v' part of the associated expression/statement.\n  Expr *getV() { return cast_or_null<Expr>(Data->getChildren()[2]); }\n  const Expr *getV() const {\n    return cast_or_null<Expr>(Data->getChildren()[2]);\n  }\n  /// Get 'expr' part of the associated expression/statement.\n  Expr *getExpr() { return cast_or_null<Expr>(Data->getChildren()[3]); }\n  const Expr *getExpr() const {\n    return cast_or_null<Expr>(Data->getChildren()[3]);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPAtomicDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target' directive.\n///\n/// \\code\n/// #pragma omp target if(a)\n/// \\endcode\n/// In this example directive '#pragma omp target' has clause 'if' with\n/// condition 'a'.\n///\nclass OMPTargetDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPTargetDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTargetDirectiveClass, llvm::omp::OMPD_target,\n                               StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTargetDirective()\n      : OMPExecutableDirective(OMPTargetDirectiveClass, llvm::omp::OMPD_target,\n                               SourceLocation(), SourceLocation()) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  ///\n  static OMPTargetDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTargetDirective *CreateEmpty(const ASTContext &C,\n                                         unsigned NumClauses, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target data' directive.\n///\n/// \\code\n/// #pragma omp target data device(0) if(a) map(b[:])\n/// \\endcode\n/// In this example directive '#pragma omp target data' has clauses 'device'\n/// with the value '0', 'if' with condition 'a' and 'map' with array\n/// section 'b[:]'.\n///\nclass OMPTargetDataDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  ///\n  OMPTargetDataDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTargetDataDirectiveClass,\n                               llvm::omp::OMPD_target_data, StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTargetDataDirective()\n      : OMPExecutableDirective(OMPTargetDataDirectiveClass,\n                               llvm::omp::OMPD_target_data, SourceLocation(),\n                               SourceLocation()) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  ///\n  static OMPTargetDataDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt);\n\n  /// Creates an empty directive with the place for \\a N clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of clauses.\n  ///\n  static OMPTargetDataDirective *CreateEmpty(const ASTContext &C, unsigned N,\n                                             EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetDataDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target enter data' directive.\n///\n/// \\code\n/// #pragma omp target enter data device(0) if(a) map(b[:])\n/// \\endcode\n/// In this example directive '#pragma omp target enter data' has clauses\n/// 'device' with the value '0', 'if' with condition 'a' and 'map' with array\n/// section 'b[:]'.\n///\nclass OMPTargetEnterDataDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  ///\n  OMPTargetEnterDataDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTargetEnterDataDirectiveClass,\n                               llvm::omp::OMPD_target_enter_data, StartLoc,\n                               EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTargetEnterDataDirective()\n      : OMPExecutableDirective(OMPTargetEnterDataDirectiveClass,\n                               llvm::omp::OMPD_target_enter_data,\n                               SourceLocation(), SourceLocation()) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  ///\n  static OMPTargetEnterDataDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt);\n\n  /// Creates an empty directive with the place for \\a N clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of clauses.\n  ///\n  static OMPTargetEnterDataDirective *CreateEmpty(const ASTContext &C,\n                                                  unsigned N, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetEnterDataDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target exit data' directive.\n///\n/// \\code\n/// #pragma omp target exit data device(0) if(a) map(b[:])\n/// \\endcode\n/// In this example directive '#pragma omp target exit data' has clauses\n/// 'device' with the value '0', 'if' with condition 'a' and 'map' with array\n/// section 'b[:]'.\n///\nclass OMPTargetExitDataDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  ///\n  OMPTargetExitDataDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTargetExitDataDirectiveClass,\n                               llvm::omp::OMPD_target_exit_data, StartLoc,\n                               EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTargetExitDataDirective()\n      : OMPExecutableDirective(OMPTargetExitDataDirectiveClass,\n                               llvm::omp::OMPD_target_exit_data,\n                               SourceLocation(), SourceLocation()) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  ///\n  static OMPTargetExitDataDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt);\n\n  /// Creates an empty directive with the place for \\a N clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param N The number of clauses.\n  ///\n  static OMPTargetExitDataDirective *CreateEmpty(const ASTContext &C,\n                                                 unsigned N, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetExitDataDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target parallel' directive.\n///\n/// \\code\n/// #pragma omp target parallel if(a)\n/// \\endcode\n/// In this example directive '#pragma omp target parallel' has clause 'if' with\n/// condition 'a'.\n///\nclass OMPTargetParallelDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// true if the construct has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPTargetParallelDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTargetParallelDirectiveClass,\n                               llvm::omp::OMPD_target_parallel, StartLoc,\n                               EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTargetParallelDirective()\n      : OMPExecutableDirective(OMPTargetParallelDirectiveClass,\n                               llvm::omp::OMPD_target_parallel,\n                               SourceLocation(), SourceLocation()) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) { Data->getChildren()[0] = E; }\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  /// \\param HasCancel true if this directive has inner cancel directive.\n  ///\n  static OMPTargetParallelDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt, Expr *TaskRedRef,\n         bool HasCancel);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTargetParallelDirective *\n  CreateEmpty(const ASTContext &C, unsigned NumClauses, EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[0]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPTargetParallelDirective *>(this)\n        ->getTaskReductionRefExpr();\n  }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetParallelDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target parallel for' directive.\n///\n/// \\code\n/// #pragma omp target parallel for private(a,b) reduction(+:c,d)\n/// \\endcode\n/// In this example directive '#pragma omp target parallel for' has clauses\n/// 'private' with the variables 'a' and 'b' and 'reduction' with operator '+'\n/// and variables 'c' and 'd'.\n///\nclass OMPTargetParallelForDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// true if current region has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTargetParallelForDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                                unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetParallelForDirectiveClass,\n                         llvm::omp::OMPD_target_parallel_for, StartLoc, EndLoc,\n                         CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTargetParallelForDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetParallelForDirectiveClass,\n                         llvm::omp::OMPD_target_parallel_for, SourceLocation(),\n                         SourceLocation(), CollapsedNum) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) {\n    Data->getChildren()[numLoopChildren(\n        getLoopsNumber(), llvm::omp::OMPD_target_parallel_for)] = E;\n  }\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  /// \\param HasCancel true if current directive has inner cancel directive.\n  ///\n  static OMPTargetParallelForDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs, Expr *TaskRedRef,\n         bool HasCancel);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTargetParallelForDirective *CreateEmpty(const ASTContext &C,\n                                                    unsigned NumClauses,\n                                                    unsigned CollapsedNum,\n                                                    EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[numLoopChildren(\n        getLoopsNumber(), llvm::omp::OMPD_target_parallel_for)]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPTargetParallelForDirective *>(this)\n        ->getTaskReductionRefExpr();\n  }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetParallelForDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp teams' directive.\n///\n/// \\code\n/// #pragma omp teams if(a)\n/// \\endcode\n/// In this example directive '#pragma omp teams' has clause 'if' with\n/// condition 'a'.\n///\nclass OMPTeamsDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPTeamsDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTeamsDirectiveClass, llvm::omp::OMPD_teams,\n                               StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTeamsDirective()\n      : OMPExecutableDirective(OMPTeamsDirectiveClass, llvm::omp::OMPD_teams,\n                               SourceLocation(), SourceLocation()) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  ///\n  static OMPTeamsDirective *Create(const ASTContext &C, SourceLocation StartLoc,\n                                   SourceLocation EndLoc,\n                                   ArrayRef<OMPClause *> Clauses,\n                                   Stmt *AssociatedStmt);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTeamsDirective *CreateEmpty(const ASTContext &C,\n                                        unsigned NumClauses, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTeamsDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp cancellation point' directive.\n///\n/// \\code\n/// #pragma omp cancellation point for\n/// \\endcode\n///\n/// In this example a cancellation point is created for innermost 'for' region.\nclass OMPCancellationPointDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  OpenMPDirectiveKind CancelRegion = llvm::omp::OMPD_unknown;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// statements and child expressions.\n  ///\n  OMPCancellationPointDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPCancellationPointDirectiveClass,\n                               llvm::omp::OMPD_cancellation_point, StartLoc,\n                               EndLoc) {}\n\n  /// Build an empty directive.\n  explicit OMPCancellationPointDirective()\n      : OMPExecutableDirective(OMPCancellationPointDirectiveClass,\n                               llvm::omp::OMPD_cancellation_point,\n                               SourceLocation(), SourceLocation()) {}\n\n  /// Set cancel region for current cancellation point.\n  /// \\param CR Cancellation region.\n  void setCancelRegion(OpenMPDirectiveKind CR) { CancelRegion = CR; }\n\npublic:\n  /// Creates directive.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  ///\n  static OMPCancellationPointDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         OpenMPDirectiveKind CancelRegion);\n\n  /// Creates an empty directive.\n  ///\n  /// \\param C AST context.\n  ///\n  static OMPCancellationPointDirective *CreateEmpty(const ASTContext &C,\n                                                    EmptyShell);\n\n  /// Get cancellation region for the current cancellation point.\n  OpenMPDirectiveKind getCancelRegion() const { return CancelRegion; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPCancellationPointDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp cancel' directive.\n///\n/// \\code\n/// #pragma omp cancel for\n/// \\endcode\n///\n/// In this example a cancel is created for innermost 'for' region.\nclass OMPCancelDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  OpenMPDirectiveKind CancelRegion = llvm::omp::OMPD_unknown;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPCancelDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPCancelDirectiveClass, llvm::omp::OMPD_cancel,\n                               StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPCancelDirective()\n      : OMPExecutableDirective(OMPCancelDirectiveClass, llvm::omp::OMPD_cancel,\n                               SourceLocation(), SourceLocation()) {}\n\n  /// Set cancel region for current cancellation point.\n  /// \\param CR Cancellation region.\n  void setCancelRegion(OpenMPDirectiveKind CR) { CancelRegion = CR; }\n\npublic:\n  /// Creates directive.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  ///\n  static OMPCancelDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, OpenMPDirectiveKind CancelRegion);\n\n  /// Creates an empty directive.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPCancelDirective *CreateEmpty(const ASTContext &C,\n                                         unsigned NumClauses, EmptyShell);\n\n  /// Get cancellation region for the current cancellation point.\n  OpenMPDirectiveKind getCancelRegion() const { return CancelRegion; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPCancelDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp taskloop' directive.\n///\n/// \\code\n/// #pragma omp taskloop private(a,b) grainsize(val) num_tasks(num)\n/// \\endcode\n/// In this example directive '#pragma omp taskloop' has clauses 'private'\n/// with the variables 'a' and 'b', 'grainsize' with expression 'val' and\n/// 'num_tasks' with expression 'num'.\n///\nclass OMPTaskLoopDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// true if the construct has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTaskLoopDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                       unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTaskLoopDirectiveClass, llvm::omp::OMPD_taskloop,\n                         StartLoc, EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTaskLoopDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTaskLoopDirectiveClass, llvm::omp::OMPD_taskloop,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  /// \\param HasCancel true if this directive has inner cancel directive.\n  ///\n  static OMPTaskLoopDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs, bool HasCancel);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTaskLoopDirective *CreateEmpty(const ASTContext &C,\n                                           unsigned NumClauses,\n                                           unsigned CollapsedNum, EmptyShell);\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTaskLoopDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp taskloop simd' directive.\n///\n/// \\code\n/// #pragma omp taskloop simd private(a,b) grainsize(val) num_tasks(num)\n/// \\endcode\n/// In this example directive '#pragma omp taskloop simd' has clauses 'private'\n/// with the variables 'a' and 'b', 'grainsize' with expression 'val' and\n/// 'num_tasks' with expression 'num'.\n///\nclass OMPTaskLoopSimdDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTaskLoopSimdDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                           unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTaskLoopSimdDirectiveClass,\n                         llvm::omp::OMPD_taskloop_simd, StartLoc, EndLoc,\n                         CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTaskLoopSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTaskLoopSimdDirectiveClass,\n                         llvm::omp::OMPD_taskloop_simd, SourceLocation(),\n                         SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPTaskLoopSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTaskLoopSimdDirective *CreateEmpty(const ASTContext &C,\n                                               unsigned NumClauses,\n                                               unsigned CollapsedNum,\n                                               EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTaskLoopSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp master taskloop' directive.\n///\n/// \\code\n/// #pragma omp master taskloop private(a,b) grainsize(val) num_tasks(num)\n/// \\endcode\n/// In this example directive '#pragma omp master taskloop' has clauses\n/// 'private' with the variables 'a' and 'b', 'grainsize' with expression 'val'\n/// and 'num_tasks' with expression 'num'.\n///\nclass OMPMasterTaskLoopDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// true if the construct has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPMasterTaskLoopDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                             unsigned CollapsedNum)\n      : OMPLoopDirective(OMPMasterTaskLoopDirectiveClass,\n                         llvm::omp::OMPD_master_taskloop, StartLoc, EndLoc,\n                         CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPMasterTaskLoopDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPMasterTaskLoopDirectiveClass,\n                         llvm::omp::OMPD_master_taskloop, SourceLocation(),\n                         SourceLocation(), CollapsedNum) {}\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  /// \\param HasCancel true if this directive has inner cancel directive.\n  ///\n  static OMPMasterTaskLoopDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs, bool HasCancel);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPMasterTaskLoopDirective *CreateEmpty(const ASTContext &C,\n                                                 unsigned NumClauses,\n                                                 unsigned CollapsedNum,\n                                                 EmptyShell);\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPMasterTaskLoopDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp master taskloop simd' directive.\n///\n/// \\code\n/// #pragma omp master taskloop simd private(a,b) grainsize(val) num_tasks(num)\n/// \\endcode\n/// In this example directive '#pragma omp master taskloop simd' has clauses\n/// 'private' with the variables 'a' and 'b', 'grainsize' with expression 'val'\n/// and 'num_tasks' with expression 'num'.\n///\nclass OMPMasterTaskLoopSimdDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPMasterTaskLoopSimdDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                                 unsigned CollapsedNum)\n      : OMPLoopDirective(OMPMasterTaskLoopSimdDirectiveClass,\n                         llvm::omp::OMPD_master_taskloop_simd, StartLoc, EndLoc,\n                         CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPMasterTaskLoopSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPMasterTaskLoopSimdDirectiveClass,\n                         llvm::omp::OMPD_master_taskloop_simd, SourceLocation(),\n                         SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\p Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPMasterTaskLoopSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place for \\p NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPMasterTaskLoopSimdDirective *CreateEmpty(const ASTContext &C,\n                                                     unsigned NumClauses,\n                                                     unsigned CollapsedNum,\n                                                     EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPMasterTaskLoopSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp parallel master taskloop' directive.\n///\n/// \\code\n/// #pragma omp parallel master taskloop private(a,b) grainsize(val)\n/// num_tasks(num)\n/// \\endcode\n/// In this example directive '#pragma omp parallel master taskloop' has clauses\n/// 'private' with the variables 'a' and 'b', 'grainsize' with expression 'val'\n/// and 'num_tasks' with expression 'num'.\n///\nclass OMPParallelMasterTaskLoopDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// true if the construct has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPParallelMasterTaskLoopDirective(SourceLocation StartLoc,\n                                     SourceLocation EndLoc,\n                                     unsigned CollapsedNum)\n      : OMPLoopDirective(OMPParallelMasterTaskLoopDirectiveClass,\n                         llvm::omp::OMPD_parallel_master_taskloop, StartLoc,\n                         EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPParallelMasterTaskLoopDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPParallelMasterTaskLoopDirectiveClass,\n                         llvm::omp::OMPD_parallel_master_taskloop,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  /// \\param HasCancel true if this directive has inner cancel directive.\n  ///\n  static OMPParallelMasterTaskLoopDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs, bool HasCancel);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPParallelMasterTaskLoopDirective *CreateEmpty(const ASTContext &C,\n                                                         unsigned NumClauses,\n                                                         unsigned CollapsedNum,\n                                                         EmptyShell);\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPParallelMasterTaskLoopDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp parallel master taskloop simd' directive.\n///\n/// \\code\n/// #pragma omp parallel master taskloop simd private(a,b) grainsize(val)\n/// num_tasks(num)\n/// \\endcode\n/// In this example directive '#pragma omp parallel master taskloop simd' has\n/// clauses 'private' with the variables 'a' and 'b', 'grainsize' with\n/// expression 'val' and 'num_tasks' with expression 'num'.\n///\nclass OMPParallelMasterTaskLoopSimdDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPParallelMasterTaskLoopSimdDirective(SourceLocation StartLoc,\n                                         SourceLocation EndLoc,\n                                         unsigned CollapsedNum)\n      : OMPLoopDirective(OMPParallelMasterTaskLoopSimdDirectiveClass,\n                         llvm::omp::OMPD_parallel_master_taskloop_simd,\n                         StartLoc, EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPParallelMasterTaskLoopSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPParallelMasterTaskLoopSimdDirectiveClass,\n                         llvm::omp::OMPD_parallel_master_taskloop_simd,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\p Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPParallelMasterTaskLoopSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPParallelMasterTaskLoopSimdDirective *\n  CreateEmpty(const ASTContext &C, unsigned NumClauses, unsigned CollapsedNum,\n              EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPParallelMasterTaskLoopSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp distribute' directive.\n///\n/// \\code\n/// #pragma omp distribute private(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp distribute' has clauses 'private'\n/// with the variables 'a' and 'b'\n///\nclass OMPDistributeDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPDistributeDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                         unsigned CollapsedNum)\n      : OMPLoopDirective(OMPDistributeDirectiveClass,\n                         llvm::omp::OMPD_distribute, StartLoc, EndLoc,\n                         CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPDistributeDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPDistributeDirectiveClass,\n                         llvm::omp::OMPD_distribute, SourceLocation(),\n                         SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPDistributeDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPDistributeDirective *CreateEmpty(const ASTContext &C,\n                                             unsigned NumClauses,\n                                             unsigned CollapsedNum, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPDistributeDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target update' directive.\n///\n/// \\code\n/// #pragma omp target update to(a) from(b) device(1)\n/// \\endcode\n/// In this example directive '#pragma omp target update' has clause 'to' with\n/// argument 'a', clause 'from' with argument 'b' and clause 'device' with\n/// argument '1'.\n///\nclass OMPTargetUpdateDirective : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  ///\n  OMPTargetUpdateDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTargetUpdateDirectiveClass,\n                               llvm::omp::OMPD_target_update, StartLoc,\n                               EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTargetUpdateDirective()\n      : OMPExecutableDirective(OMPTargetUpdateDirectiveClass,\n                               llvm::omp::OMPD_target_update, SourceLocation(),\n                               SourceLocation()) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  ///\n  static OMPTargetUpdateDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         ArrayRef<OMPClause *> Clauses, Stmt *AssociatedStmt);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses The number of clauses.\n  ///\n  static OMPTargetUpdateDirective *CreateEmpty(const ASTContext &C,\n                                               unsigned NumClauses, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetUpdateDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp distribute parallel for' composite\n///  directive.\n///\n/// \\code\n/// #pragma omp distribute parallel for private(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp distribute parallel for' has clause\n/// 'private' with the variables 'a' and 'b'\n///\nclass OMPDistributeParallelForDirective : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// true if the construct has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPDistributeParallelForDirective(SourceLocation StartLoc,\n                                    SourceLocation EndLoc,\n                                    unsigned CollapsedNum)\n      : OMPLoopDirective(OMPDistributeParallelForDirectiveClass,\n                         llvm::omp::OMPD_distribute_parallel_for, StartLoc,\n                         EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPDistributeParallelForDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPDistributeParallelForDirectiveClass,\n                         llvm::omp::OMPD_distribute_parallel_for,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) {\n    Data->getChildren()[numLoopChildren(\n        getLoopsNumber(), llvm::omp::OMPD_distribute_parallel_for)] = E;\n  }\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  /// \\param HasCancel true if this directive has inner cancel directive.\n  ///\n  static OMPDistributeParallelForDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs, Expr *TaskRedRef,\n         bool HasCancel);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPDistributeParallelForDirective *CreateEmpty(const ASTContext &C,\n                                                        unsigned NumClauses,\n                                                        unsigned CollapsedNum,\n                                                        EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[numLoopChildren(\n        getLoopsNumber(), llvm::omp::OMPD_distribute_parallel_for)]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPDistributeParallelForDirective *>(this)\n        ->getTaskReductionRefExpr();\n  }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPDistributeParallelForDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp distribute parallel for simd' composite\n/// directive.\n///\n/// \\code\n/// #pragma omp distribute parallel for simd private(x)\n/// \\endcode\n/// In this example directive '#pragma omp distribute parallel for simd' has\n/// clause 'private' with the variables 'x'\n///\nclass OMPDistributeParallelForSimdDirective final : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPDistributeParallelForSimdDirective(SourceLocation StartLoc,\n                                        SourceLocation EndLoc,\n                                        unsigned CollapsedNum)\n      : OMPLoopDirective(OMPDistributeParallelForSimdDirectiveClass,\n                         llvm::omp::OMPD_distribute_parallel_for_simd, StartLoc,\n                         EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPDistributeParallelForSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPDistributeParallelForSimdDirectiveClass,\n                         llvm::omp::OMPD_distribute_parallel_for_simd,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPDistributeParallelForSimdDirective *Create(\n      const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n      unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n      Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPDistributeParallelForSimdDirective *CreateEmpty(\n      const ASTContext &C, unsigned NumClauses, unsigned CollapsedNum,\n      EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPDistributeParallelForSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp distribute simd' composite directive.\n///\n/// \\code\n/// #pragma omp distribute simd private(x)\n/// \\endcode\n/// In this example directive '#pragma omp distribute simd' has clause\n/// 'private' with the variables 'x'\n///\nclass OMPDistributeSimdDirective final : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPDistributeSimdDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                             unsigned CollapsedNum)\n      : OMPLoopDirective(OMPDistributeSimdDirectiveClass,\n                         llvm::omp::OMPD_distribute_simd, StartLoc, EndLoc,\n                         CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPDistributeSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPDistributeSimdDirectiveClass,\n                         llvm::omp::OMPD_distribute_simd, SourceLocation(),\n                         SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPDistributeSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPDistributeSimdDirective *CreateEmpty(const ASTContext &C,\n                                                 unsigned NumClauses,\n                                                 unsigned CollapsedNum,\n                                                 EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPDistributeSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target parallel for simd' directive.\n///\n/// \\code\n/// #pragma omp target parallel for simd private(a) map(b) safelen(c)\n/// \\endcode\n/// In this example directive '#pragma omp target parallel for simd' has clauses\n/// 'private' with the variable 'a', 'map' with the variable 'b' and 'safelen'\n/// with the variable 'c'.\n///\nclass OMPTargetParallelForSimdDirective final : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTargetParallelForSimdDirective(SourceLocation StartLoc,\n                                    SourceLocation EndLoc,\n                                    unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetParallelForSimdDirectiveClass,\n                         llvm::omp::OMPD_target_parallel_for_simd, StartLoc,\n                         EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTargetParallelForSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetParallelForSimdDirectiveClass,\n                         llvm::omp::OMPD_target_parallel_for_simd,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPTargetParallelForSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTargetParallelForSimdDirective *CreateEmpty(const ASTContext &C,\n                                                        unsigned NumClauses,\n                                                        unsigned CollapsedNum,\n                                                        EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetParallelForSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target simd' directive.\n///\n/// \\code\n/// #pragma omp target simd private(a) map(b) safelen(c)\n/// \\endcode\n/// In this example directive '#pragma omp target simd' has clauses 'private'\n/// with the variable 'a', 'map' with the variable 'b' and 'safelen' with\n/// the variable 'c'.\n///\nclass OMPTargetSimdDirective final : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTargetSimdDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                         unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetSimdDirectiveClass,\n                         llvm::omp::OMPD_target_simd, StartLoc, EndLoc,\n                         CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTargetSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetSimdDirectiveClass,\n                         llvm::omp::OMPD_target_simd, SourceLocation(),\n                         SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPTargetSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTargetSimdDirective *CreateEmpty(const ASTContext &C,\n                                             unsigned NumClauses,\n                                             unsigned CollapsedNum,\n                                             EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp teams distribute' directive.\n///\n/// \\code\n/// #pragma omp teams distribute private(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp teams distribute' has clauses\n/// 'private' with the variables 'a' and 'b'\n///\nclass OMPTeamsDistributeDirective final : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTeamsDistributeDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                              unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTeamsDistributeDirectiveClass,\n                         llvm::omp::OMPD_teams_distribute, StartLoc, EndLoc,\n                         CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTeamsDistributeDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTeamsDistributeDirectiveClass,\n                         llvm::omp::OMPD_teams_distribute, SourceLocation(),\n                         SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPTeamsDistributeDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTeamsDistributeDirective *CreateEmpty(const ASTContext &C,\n                                                  unsigned NumClauses,\n                                                  unsigned CollapsedNum,\n                                                  EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTeamsDistributeDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp teams distribute simd'\n/// combined directive.\n///\n/// \\code\n/// #pragma omp teams distribute simd private(a,b)\n/// \\endcode\n/// In this example directive '#pragma omp teams distribute simd'\n/// has clause 'private' with the variables 'a' and 'b'\n///\nclass OMPTeamsDistributeSimdDirective final : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTeamsDistributeSimdDirective(SourceLocation StartLoc,\n                                  SourceLocation EndLoc, unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTeamsDistributeSimdDirectiveClass,\n                         llvm::omp::OMPD_teams_distribute_simd, StartLoc,\n                         EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTeamsDistributeSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTeamsDistributeSimdDirectiveClass,\n                         llvm::omp::OMPD_teams_distribute_simd,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPTeamsDistributeSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place\n  /// for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTeamsDistributeSimdDirective *CreateEmpty(const ASTContext &C,\n                                                      unsigned NumClauses,\n                                                      unsigned CollapsedNum,\n                                                      EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTeamsDistributeSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp teams distribute parallel for simd' composite\n/// directive.\n///\n/// \\code\n/// #pragma omp teams distribute parallel for simd private(x)\n/// \\endcode\n/// In this example directive '#pragma omp teams distribute parallel for simd'\n/// has clause 'private' with the variables 'x'\n///\nclass OMPTeamsDistributeParallelForSimdDirective final\n    : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTeamsDistributeParallelForSimdDirective(SourceLocation StartLoc,\n                                             SourceLocation EndLoc,\n                                             unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTeamsDistributeParallelForSimdDirectiveClass,\n                         llvm::omp::OMPD_teams_distribute_parallel_for_simd,\n                         StartLoc, EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTeamsDistributeParallelForSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTeamsDistributeParallelForSimdDirectiveClass,\n                         llvm::omp::OMPD_teams_distribute_parallel_for_simd,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPTeamsDistributeParallelForSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTeamsDistributeParallelForSimdDirective *\n  CreateEmpty(const ASTContext &C, unsigned NumClauses, unsigned CollapsedNum,\n              EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTeamsDistributeParallelForSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp teams distribute parallel for' composite\n/// directive.\n///\n/// \\code\n/// #pragma omp teams distribute parallel for private(x)\n/// \\endcode\n/// In this example directive '#pragma omp teams distribute parallel for'\n/// has clause 'private' with the variables 'x'\n///\nclass OMPTeamsDistributeParallelForDirective final : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// true if the construct has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTeamsDistributeParallelForDirective(SourceLocation StartLoc,\n                                         SourceLocation EndLoc,\n                                         unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTeamsDistributeParallelForDirectiveClass,\n                         llvm::omp::OMPD_teams_distribute_parallel_for,\n                         StartLoc, EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTeamsDistributeParallelForDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTeamsDistributeParallelForDirectiveClass,\n                         llvm::omp::OMPD_teams_distribute_parallel_for,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) {\n    Data->getChildren()[numLoopChildren(\n        getLoopsNumber(), llvm::omp::OMPD_teams_distribute_parallel_for)] = E;\n  }\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  /// \\param HasCancel true if this directive has inner cancel directive.\n  ///\n  static OMPTeamsDistributeParallelForDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs, Expr *TaskRedRef,\n         bool HasCancel);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTeamsDistributeParallelForDirective *\n  CreateEmpty(const ASTContext &C, unsigned NumClauses, unsigned CollapsedNum,\n              EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[numLoopChildren(\n        getLoopsNumber(), llvm::omp::OMPD_teams_distribute_parallel_for)]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPTeamsDistributeParallelForDirective *>(this)\n        ->getTaskReductionRefExpr();\n  }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTeamsDistributeParallelForDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target teams' directive.\n///\n/// \\code\n/// #pragma omp target teams if(a>0)\n/// \\endcode\n/// In this example directive '#pragma omp target teams' has clause 'if' with\n/// condition 'a>0'.\n///\nclass OMPTargetTeamsDirective final : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPTargetTeamsDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPTargetTeamsDirectiveClass,\n                               llvm::omp::OMPD_target_teams, StartLoc, EndLoc) {\n  }\n\n  /// Build an empty directive.\n  ///\n  explicit OMPTargetTeamsDirective()\n      : OMPExecutableDirective(OMPTargetTeamsDirectiveClass,\n                               llvm::omp::OMPD_target_teams, SourceLocation(),\n                               SourceLocation()) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  ///\n  static OMPTargetTeamsDirective *Create(const ASTContext &C,\n                                         SourceLocation StartLoc,\n                                         SourceLocation EndLoc,\n                                         ArrayRef<OMPClause *> Clauses,\n                                         Stmt *AssociatedStmt);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTargetTeamsDirective *CreateEmpty(const ASTContext &C,\n                                              unsigned NumClauses, EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetTeamsDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target teams distribute' combined directive.\n///\n/// \\code\n/// #pragma omp target teams distribute private(x)\n/// \\endcode\n/// In this example directive '#pragma omp target teams distribute' has clause\n/// 'private' with the variables 'x'\n///\nclass OMPTargetTeamsDistributeDirective final : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTargetTeamsDistributeDirective(SourceLocation StartLoc,\n                                    SourceLocation EndLoc,\n                                    unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetTeamsDistributeDirectiveClass,\n                         llvm::omp::OMPD_target_teams_distribute, StartLoc,\n                         EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTargetTeamsDistributeDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetTeamsDistributeDirectiveClass,\n                         llvm::omp::OMPD_target_teams_distribute,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPTargetTeamsDistributeDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTargetTeamsDistributeDirective *\n  CreateEmpty(const ASTContext &C, unsigned NumClauses, unsigned CollapsedNum,\n              EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetTeamsDistributeDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target teams distribute parallel for' combined\n/// directive.\n///\n/// \\code\n/// #pragma omp target teams distribute parallel for private(x)\n/// \\endcode\n/// In this example directive '#pragma omp target teams distribute parallel\n/// for' has clause 'private' with the variables 'x'\n///\nclass OMPTargetTeamsDistributeParallelForDirective final\n    : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// true if the construct has inner cancel directive.\n  bool HasCancel = false;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTargetTeamsDistributeParallelForDirective(SourceLocation StartLoc,\n                                               SourceLocation EndLoc,\n                                               unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetTeamsDistributeParallelForDirectiveClass,\n                         llvm::omp::OMPD_target_teams_distribute_parallel_for,\n                         StartLoc, EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTargetTeamsDistributeParallelForDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetTeamsDistributeParallelForDirectiveClass,\n                         llvm::omp::OMPD_target_teams_distribute_parallel_for,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\n  /// Sets special task reduction descriptor.\n  void setTaskReductionRefExpr(Expr *E) {\n    Data->getChildren()[numLoopChildren(\n        getLoopsNumber(),\n        llvm::omp::OMPD_target_teams_distribute_parallel_for)] = E;\n  }\n\n  /// Set cancel state.\n  void setHasCancel(bool Has) { HasCancel = Has; }\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  /// \\param TaskRedRef Task reduction special reference expression to handle\n  /// taskgroup descriptor.\n  /// \\param HasCancel true if this directive has inner cancel directive.\n  ///\n  static OMPTargetTeamsDistributeParallelForDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs, Expr *TaskRedRef,\n         bool HasCancel);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTargetTeamsDistributeParallelForDirective *\n  CreateEmpty(const ASTContext &C, unsigned NumClauses, unsigned CollapsedNum,\n              EmptyShell);\n\n  /// Returns special task reduction reference expression.\n  Expr *getTaskReductionRefExpr() {\n    return cast_or_null<Expr>(Data->getChildren()[numLoopChildren(\n        getLoopsNumber(),\n        llvm::omp::OMPD_target_teams_distribute_parallel_for)]);\n  }\n  const Expr *getTaskReductionRefExpr() const {\n    return const_cast<OMPTargetTeamsDistributeParallelForDirective *>(this)\n        ->getTaskReductionRefExpr();\n  }\n\n  /// Return true if current directive has inner cancel directive.\n  bool hasCancel() const { return HasCancel; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() ==\n           OMPTargetTeamsDistributeParallelForDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target teams distribute parallel for simd'\n/// combined directive.\n///\n/// \\code\n/// #pragma omp target teams distribute parallel for simd private(x)\n/// \\endcode\n/// In this example directive '#pragma omp target teams distribute parallel\n/// for simd' has clause 'private' with the variables 'x'\n///\nclass OMPTargetTeamsDistributeParallelForSimdDirective final\n    : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTargetTeamsDistributeParallelForSimdDirective(SourceLocation StartLoc,\n                                                   SourceLocation EndLoc,\n                                                   unsigned CollapsedNum)\n      : OMPLoopDirective(\n            OMPTargetTeamsDistributeParallelForSimdDirectiveClass,\n            llvm::omp::OMPD_target_teams_distribute_parallel_for_simd, StartLoc,\n            EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTargetTeamsDistributeParallelForSimdDirective(\n      unsigned CollapsedNum)\n      : OMPLoopDirective(\n            OMPTargetTeamsDistributeParallelForSimdDirectiveClass,\n            llvm::omp::OMPD_target_teams_distribute_parallel_for_simd,\n            SourceLocation(), SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPTargetTeamsDistributeParallelForSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTargetTeamsDistributeParallelForSimdDirective *\n  CreateEmpty(const ASTContext &C, unsigned NumClauses, unsigned CollapsedNum,\n              EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() ==\n           OMPTargetTeamsDistributeParallelForSimdDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp target teams distribute simd' combined\n/// directive.\n///\n/// \\code\n/// #pragma omp target teams distribute simd private(x)\n/// \\endcode\n/// In this example directive '#pragma omp target teams distribute simd'\n/// has clause 'private' with the variables 'x'\n///\nclass OMPTargetTeamsDistributeSimdDirective final : public OMPLoopDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  OMPTargetTeamsDistributeSimdDirective(SourceLocation StartLoc,\n                                        SourceLocation EndLoc,\n                                        unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetTeamsDistributeSimdDirectiveClass,\n                         llvm::omp::OMPD_target_teams_distribute_simd, StartLoc,\n                         EndLoc, CollapsedNum) {}\n\n  /// Build an empty directive.\n  ///\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  ///\n  explicit OMPTargetTeamsDistributeSimdDirective(unsigned CollapsedNum)\n      : OMPLoopDirective(OMPTargetTeamsDistributeSimdDirectiveClass,\n                         llvm::omp::OMPD_target_teams_distribute_simd,\n                         SourceLocation(), SourceLocation(), CollapsedNum) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param CollapsedNum Number of collapsed loops.\n  /// \\param Clauses List of clauses.\n  /// \\param AssociatedStmt Statement, associated with the directive.\n  /// \\param Exprs Helper expressions for CodeGen.\n  ///\n  static OMPTargetTeamsDistributeSimdDirective *\n  Create(const ASTContext &C, SourceLocation StartLoc, SourceLocation EndLoc,\n         unsigned CollapsedNum, ArrayRef<OMPClause *> Clauses,\n         Stmt *AssociatedStmt, const HelperExprs &Exprs);\n\n  /// Creates an empty directive with the place for \\a NumClauses clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param CollapsedNum Number of collapsed nested loops.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPTargetTeamsDistributeSimdDirective *\n  CreateEmpty(const ASTContext &C, unsigned NumClauses, unsigned CollapsedNum,\n              EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTargetTeamsDistributeSimdDirectiveClass;\n  }\n};\n\n/// This represents the '#pragma omp tile' loop transformation directive.\nclass OMPTileDirective final : public OMPLoopBasedDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n\n  /// Default list of offsets.\n  enum {\n    PreInitsOffset = 0,\n    TransformedStmtOffset,\n  };\n\n  explicit OMPTileDirective(SourceLocation StartLoc, SourceLocation EndLoc,\n                            unsigned NumLoops)\n      : OMPLoopBasedDirective(OMPTileDirectiveClass, llvm::omp::OMPD_tile,\n                              StartLoc, EndLoc, NumLoops) {}\n\n  void setPreInits(Stmt *PreInits) {\n    Data->getChildren()[PreInitsOffset] = PreInits;\n  }\n\n  void setTransformedStmt(Stmt *S) {\n    Data->getChildren()[TransformedStmtOffset] = S;\n  }\n\npublic:\n  /// Create a new AST node representation for '#pragma omp tile'.\n  ///\n  /// \\param C         Context of the AST.\n  /// \\param StartLoc  Location of the introducer (e.g. the 'omp' token).\n  /// \\param EndLoc    Location of the directive's end (e.g. the tok::eod).\n  /// \\param Clauses   The directive's clauses.\n  /// \\param NumLoops  Number of associated loops (number of items in the\n  ///                  'sizes' clause).\n  /// \\param AssociatedStmt The outermost associated loop.\n  /// \\param TransformedStmt The loop nest after tiling, or nullptr in\n  ///                        dependent contexts.\n  /// \\param PreInits Helper preinits statements for the loop nest.\n  static OMPTileDirective *Create(const ASTContext &C, SourceLocation StartLoc,\n                                  SourceLocation EndLoc,\n                                  ArrayRef<OMPClause *> Clauses,\n                                  unsigned NumLoops, Stmt *AssociatedStmt,\n                                  Stmt *TransformedStmt, Stmt *PreInits);\n\n  /// Build an empty '#pragma omp tile' AST node for deserialization.\n  ///\n  /// \\param C          Context of the AST.\n  /// \\param NumClauses Number of clauses to allocate.\n  /// \\param NumLoops   Number of associated loops to allocate.\n  static OMPTileDirective *CreateEmpty(const ASTContext &C, unsigned NumClauses,\n                                       unsigned NumLoops);\n\n  unsigned getNumAssociatedLoops() const { return getLoopsNumber(); }\n\n  /// Gets/sets the associated loops after tiling.\n  ///\n  /// This is in de-sugared format stored as a CompoundStmt.\n  ///\n  /// \\code\n  ///   for (...)\n  ///     ...\n  /// \\endcode\n  ///\n  /// Note that if the generated loops a become associated loops of another\n  /// directive, they may need to be hoisted before them.\n  Stmt *getTransformedStmt() const {\n    return Data->getChildren()[TransformedStmtOffset];\n  }\n\n  /// Return preinits statement.\n  Stmt *getPreInits() const { return Data->getChildren()[PreInitsOffset]; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPTileDirectiveClass;\n  }\n};\n\n/// This represents '#pragma omp scan' directive.\n///\n/// \\code\n/// #pragma omp scan inclusive(a)\n/// \\endcode\n/// In this example directive '#pragma omp scan' has clause 'inclusive' with\n/// list item 'a'.\nclass OMPScanDirective final : public OMPExecutableDirective {\n  friend class ASTStmtReader;\n  friend class OMPExecutableDirective;\n  /// Build directive with the given start and end location.\n  ///\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending location of the directive.\n  ///\n  OMPScanDirective(SourceLocation StartLoc, SourceLocation EndLoc)\n      : OMPExecutableDirective(OMPScanDirectiveClass, llvm::omp::OMPD_scan,\n                               StartLoc, EndLoc) {}\n\n  /// Build an empty directive.\n  ///\n  explicit OMPScanDirective()\n      : OMPExecutableDirective(OMPScanDirectiveClass, llvm::omp::OMPD_scan,\n                               SourceLocation(), SourceLocation()) {}\n\npublic:\n  /// Creates directive with a list of \\a Clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param StartLoc Starting location of the directive kind.\n  /// \\param EndLoc Ending Location of the directive.\n  /// \\param Clauses List of clauses (only single OMPFlushClause clause is\n  /// allowed).\n  ///\n  static OMPScanDirective *Create(const ASTContext &C, SourceLocation StartLoc,\n                                  SourceLocation EndLoc,\n                                  ArrayRef<OMPClause *> Clauses);\n\n  /// Creates an empty directive with the place for \\a NumClauses\n  /// clauses.\n  ///\n  /// \\param C AST context.\n  /// \\param NumClauses Number of clauses.\n  ///\n  static OMPScanDirective *CreateEmpty(const ASTContext &C, unsigned NumClauses,\n                                       EmptyShell);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OMPScanDirectiveClass;\n  }\n};\n\n} // end namespace clang\n\n#endif\n"}, "61": {"id": 61, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h", "content": "//===- CommonOptionsParser.h - common options for clang tools -*- C++ -*-=====//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file implements the CommonOptionsParser class used to parse common\n//  command-line options for clang tools, so that they can be run as separate\n//  command-line applications with a consistent common interface for handling\n//  compilation database and input files.\n//\n//  It provides a common subset of command-line options, common algorithm\n//  for locating a compilation database and source files, and help messages\n//  for the basic command-line interface.\n//\n//  It creates a CompilationDatabase and reads common command-line options.\n//\n//  This class uses the Clang Tooling infrastructure, see\n//    http://clang.llvm.org/docs/HowToSetupToolingForLLVM.html\n//  for details on setting it up with LLVM source tree.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLING_COMMONOPTIONSPARSER_H\n#define LLVM_CLANG_TOOLING_COMMONOPTIONSPARSER_H\n\n#include \"clang/Tooling/ArgumentsAdjusters.h\"\n#include \"clang/Tooling/CompilationDatabase.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/Error.h\"\n\nnamespace clang {\nnamespace tooling {\n/// A parser for options common to all command-line Clang tools.\n///\n/// Parses a common subset of command-line arguments, locates and loads a\n/// compilation commands database and runs a tool with user-specified action. It\n/// also contains a help message for the common command-line options.\n///\n/// An example of usage:\n/// \\code\n/// #include \"clang/Frontend/FrontendActions.h\"\n/// #include \"clang/Tooling/CommonOptionsParser.h\"\n/// #include \"clang/Tooling/Tooling.h\"\n/// #include \"llvm/Support/CommandLine.h\"\n///\n/// using namespace clang::tooling;\n/// using namespace llvm;\n///\n/// static cl::OptionCategory MyToolCategory(\"My tool options\");\n/// static cl::extrahelp CommonHelp(CommonOptionsParser::HelpMessage);\n/// static cl::extrahelp MoreHelp(\"\\nMore help text...\\n\");\n/// static cl::opt<bool> YourOwnOption(...);\n/// ...\n///\n/// int main(int argc, const char **argv) {\n///   CommonOptionsParser OptionsParser(argc, argv, MyToolCategory);\n///   ClangTool Tool(OptionsParser.getCompilations(),\n///                  OptionsParser.getSourcePathList());\n///   return Tool.run(newFrontendActionFactory<SyntaxOnlyAction>().get());\n/// }\n/// \\endcode\nclass CommonOptionsParser {\n\nprotected:\n  /// Parses command-line, initializes a compilation database.\n  ///\n  /// This constructor can change argc and argv contents, e.g. consume\n  /// command-line options used for creating FixedCompilationDatabase.\n  ///\n  /// All options not belonging to \\p Category become hidden.\n  ///\n  /// It also allows calls to set the required number of positional parameters.\n  CommonOptionsParser(\n      int &argc, const char **argv, llvm::cl::OptionCategory &Category,\n      llvm::cl::NumOccurrencesFlag OccurrencesFlag = llvm::cl::OneOrMore,\n      const char *Overview = nullptr);\n\npublic:\n  /// A factory method that is similar to the above constructor, except\n  /// this returns an error instead exiting the program on error.\n  static llvm::Expected<CommonOptionsParser>\n  create(int &argc, const char **argv, llvm::cl::OptionCategory &Category,\n         llvm::cl::NumOccurrencesFlag OccurrencesFlag = llvm::cl::OneOrMore,\n         const char *Overview = nullptr);\n\n  /// Returns a reference to the loaded compilations database.\n  CompilationDatabase &getCompilations() {\n    return *Compilations;\n  }\n\n  /// Returns a list of source file paths to process.\n  const std::vector<std::string> &getSourcePathList() const {\n    return SourcePathList;\n  }\n\n  /// Returns the argument adjuster calculated from \"--extra-arg\" and\n  //\"--extra-arg-before\" options.\n  ArgumentsAdjuster getArgumentsAdjuster() { return Adjuster; }\n\n  static const char *const HelpMessage;\n\nprivate:\n  CommonOptionsParser() = default;\n\n  llvm::Error init(int &argc, const char **argv,\n                   llvm::cl::OptionCategory &Category,\n                   llvm::cl::NumOccurrencesFlag OccurrencesFlag,\n                   const char *Overview);\n\n  std::unique_ptr<CompilationDatabase> Compilations;\n  std::vector<std::string> SourcePathList;\n  ArgumentsAdjuster Adjuster;\n};\n\nclass ArgumentsAdjustingCompilations : public CompilationDatabase {\npublic:\n  ArgumentsAdjustingCompilations(\n      std::unique_ptr<CompilationDatabase> Compilations)\n      : Compilations(std::move(Compilations)) {}\n\n  void appendArgumentsAdjuster(ArgumentsAdjuster Adjuster);\n\n  std::vector<CompileCommand>\n  getCompileCommands(StringRef FilePath) const override;\n\n  std::vector<std::string> getAllFiles() const override;\n\n  std::vector<CompileCommand> getAllCompileCommands() const override;\n\nprivate:\n  std::unique_ptr<CompilationDatabase> Compilations;\n  std::vector<ArgumentsAdjuster> Adjusters;\n\n  std::vector<CompileCommand>\n  adjustCommands(std::vector<CompileCommand> Commands) const;\n};\n\n}  // namespace tooling\n}  // namespace clang\n\n#endif  // LLVM_TOOLS_CLANG_INCLUDE_CLANG_TOOLING_COMMONOPTIONSPARSER_H\n"}, "63": {"id": 63, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Execution.h", "content": "//===--- Execution.h - Executing clang frontend actions -*- C++ ---------*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines framework for executing clang frontend actions.\n//\n//  The framework can be extended to support different execution plans including\n//  standalone execution on the given TUs or parallel execution on all TUs in\n//  the codebase.\n//\n//  In order to enable multiprocessing execution, tool actions are expected to\n//  output result into the ToolResults provided by the executor. The\n//  `ToolResults` is an interface that abstracts how results are stored e.g.\n//  in-memory for standalone execution or on-disk for large-scale execution.\n//\n//  New executors can be registered as ToolExecutorPlugins via the\n//  `ToolExecutorPluginRegistry`. CLI tools can use\n//  `createExecutorFromCommandLineArgs` to create a specific registered executor\n//  according to the command-line arguments.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLING_EXECUTION_H\n#define LLVM_CLANG_TOOLING_EXECUTION_H\n\n#include \"clang/Tooling/CommonOptionsParser.h\"\n#include \"clang/Tooling/Tooling.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/Registry.h\"\n#include \"llvm/Support/StringSaver.h\"\n\nnamespace clang {\nnamespace tooling {\n\nextern llvm::cl::opt<std::string> ExecutorName;\n\n/// An abstraction for the result of a tool execution. For example, the\n/// underlying result can be in-memory or on-disk.\n///\n/// Results should be string key-value pairs. For example, a refactoring tool\n/// can use source location as key and a replacement in YAML format as value.\nclass ToolResults {\npublic:\n  virtual ~ToolResults() = default;\n  virtual void addResult(StringRef Key, StringRef Value) = 0;\n  virtual std::vector<std::pair<llvm::StringRef, llvm::StringRef>>\n  AllKVResults() = 0;\n  virtual void forEachResult(\n      llvm::function_ref<void(StringRef Key, StringRef Value)> Callback) = 0;\n};\n\n/// Stores the key-value results in memory. It maintains the lifetime of\n/// the result. Clang tools using this class are expected to generate a small\n/// set of different results, or a large set of duplicated results.\nclass InMemoryToolResults : public ToolResults {\npublic:\n  InMemoryToolResults() : Strings(Arena) {}\n  void addResult(StringRef Key, StringRef Value) override;\n  std::vector<std::pair<llvm::StringRef, llvm::StringRef>>\n  AllKVResults() override;\n  void forEachResult(llvm::function_ref<void(StringRef Key, StringRef Value)>\n                         Callback) override;\n\nprivate:\n  llvm::BumpPtrAllocator Arena;\n  llvm::UniqueStringSaver Strings;\n\n  std::vector<std::pair<llvm::StringRef, llvm::StringRef>> KVResults;\n};\n\n/// The context of an execution, including the information about\n/// compilation and results.\nclass ExecutionContext {\npublic:\n  virtual ~ExecutionContext() {}\n\n  /// Initializes a context. This does not take ownership of `Results`.\n  explicit ExecutionContext(ToolResults *Results) : Results(Results) {}\n\n  /// Adds a KV pair to the result container of this execution.\n  void reportResult(StringRef Key, StringRef Value);\n\n  // Returns the source control system's revision number if applicable.\n  // Otherwise returns an empty string.\n  virtual std::string getRevision() { return \"\"; }\n\n  // Returns the corpus being analyzed, e.g. \"llvm\" for the LLVM codebase, if\n  // applicable.\n  virtual std::string getCorpus() { return \"\"; }\n\n  // Returns the currently processed compilation unit if available.\n  virtual std::string getCurrentCompilationUnit() { return \"\"; }\n\nprivate:\n  ToolResults *Results;\n};\n\n/// Interface for executing clang frontend actions.\n///\n/// This can be extended to support running tool actions in different\n/// execution mode, e.g. on a specific set of TUs or many TUs in parallel.\n///\n///  New executors can be registered as ToolExecutorPlugins via the\n///  `ToolExecutorPluginRegistry`. CLI tools can use\n///  `createExecutorFromCommandLineArgs` to create a specific registered\n///  executor according to the command-line arguments.\nclass ToolExecutor {\npublic:\n  virtual ~ToolExecutor() {}\n\n  /// Returns the name of a specific executor.\n  virtual StringRef getExecutorName() const = 0;\n\n  /// Executes each action with a corresponding arguments adjuster.\n  virtual llvm::Error\n  execute(llvm::ArrayRef<\n          std::pair<std::unique_ptr<FrontendActionFactory>, ArgumentsAdjuster>>\n              Actions) = 0;\n\n  /// Convenient functions for the above `execute`.\n  llvm::Error execute(std::unique_ptr<FrontendActionFactory> Action);\n  /// Executes an action with an argument adjuster.\n  llvm::Error execute(std::unique_ptr<FrontendActionFactory> Action,\n                      ArgumentsAdjuster Adjuster);\n\n  /// Returns a reference to the execution context.\n  ///\n  /// This should be passed to tool callbacks, and tool callbacks should report\n  /// results via the returned context.\n  virtual ExecutionContext *getExecutionContext() = 0;\n\n  /// Returns a reference to the result container.\n  ///\n  /// NOTE: This should only be used after the execution finishes. Tool\n  /// callbacks should report results via `ExecutionContext` instead.\n  virtual ToolResults *getToolResults() = 0;\n\n  /// Map a virtual file to be used while running the tool.\n  ///\n  /// \\param FilePath The path at which the content will be mapped.\n  /// \\param Content A buffer of the file's content.\n  virtual void mapVirtualFile(StringRef FilePath, StringRef Content) = 0;\n};\n\n/// Interface for factories that create specific executors. This is also\n/// used as a plugin to be registered into ToolExecutorPluginRegistry.\nclass ToolExecutorPlugin {\npublic:\n  virtual ~ToolExecutorPlugin() {}\n\n  /// Create an `ToolExecutor`.\n  ///\n  /// `OptionsParser` can be consumed (e.g. moved) if the creation succeeds.\n  virtual llvm::Expected<std::unique_ptr<ToolExecutor>>\n  create(CommonOptionsParser &OptionsParser) = 0;\n};\n\n/// This creates a ToolExecutor that is in the global registry based on\n/// commandline arguments.\n///\n/// This picks the right executor based on the `--executor` option. This parses\n/// the commandline arguments with `CommonOptionsParser`, so caller does not\n/// need to parse again.\n///\n/// By default, this creates a `StandaloneToolExecutor` (\"standalone\") if\n/// `--executor` is not provided.\nllvm::Expected<std::unique_ptr<ToolExecutor>>\ncreateExecutorFromCommandLineArgs(int &argc, const char **argv,\n                                  llvm::cl::OptionCategory &Category,\n                                  const char *Overview = nullptr);\n\nnamespace internal {\nllvm::Expected<std::unique_ptr<ToolExecutor>>\ncreateExecutorFromCommandLineArgsImpl(int &argc, const char **argv,\n                                      llvm::cl::OptionCategory &Category,\n                                      const char *Overview = nullptr);\n} // end namespace internal\n\n} // end namespace tooling\n} // end namespace clang\n\n#endif // LLVM_CLANG_TOOLING_EXECUTION_H\n"}, "64": {"id": 64, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/StandaloneExecution.h", "content": "//===--- StandaloneExecution.h - Standalone execution. -*- C++ ----------*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines standalone execution of clang tools.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLING_STANDALONEEXECUTION_H\n#define LLVM_CLANG_TOOLING_STANDALONEEXECUTION_H\n\n#include \"clang/Tooling/ArgumentsAdjusters.h\"\n#include \"clang/Tooling/Execution.h\"\n\nnamespace clang {\nnamespace tooling {\n\n/// A standalone executor that runs FrontendActions on a given set of\n/// TUs in sequence.\n///\n/// By default, this executor uses the following arguments adjusters (as defined\n/// in `clang/Tooling/ArgumentsAdjusters.h`):\n///   - `getClangStripOutputAdjuster()`\n///   - `getClangSyntaxOnlyAdjuster()`\n///   - `getClangStripDependencyFileAdjuster()`\nclass StandaloneToolExecutor : public ToolExecutor {\npublic:\n  static const char *ExecutorName;\n\n  /// Init with \\p CompilationDatabase and the paths of all files to be\n  /// proccessed.\n  StandaloneToolExecutor(\n      const CompilationDatabase &Compilations,\n      llvm::ArrayRef<std::string> SourcePaths,\n      IntrusiveRefCntPtr<llvm::vfs::FileSystem> BaseFS =\n          llvm::vfs::getRealFileSystem(),\n      std::shared_ptr<PCHContainerOperations> PCHContainerOps =\n          std::make_shared<PCHContainerOperations>());\n\n  /// Init with \\p CommonOptionsParser. This is expected to be used by\n  /// `createExecutorFromCommandLineArgs` based on commandline options.\n  ///\n  /// The executor takes ownership of \\p Options.\n  StandaloneToolExecutor(\n      CommonOptionsParser Options,\n      std::shared_ptr<PCHContainerOperations> PCHContainerOps =\n          std::make_shared<PCHContainerOperations>());\n\n  StringRef getExecutorName() const override { return ExecutorName; }\n\n  using ToolExecutor::execute;\n\n  llvm::Error\n  execute(llvm::ArrayRef<\n          std::pair<std::unique_ptr<FrontendActionFactory>, ArgumentsAdjuster>>\n              Actions) override;\n\n  /// Set a \\c DiagnosticConsumer to use during parsing.\n  void setDiagnosticConsumer(DiagnosticConsumer *DiagConsumer) {\n    Tool.setDiagnosticConsumer(DiagConsumer);\n  }\n\n  ExecutionContext *getExecutionContext() override { return &Context; };\n\n  ToolResults *getToolResults() override { return &Results; }\n\n  llvm::ArrayRef<std::string> getSourcePaths() const {\n    return Tool.getSourcePaths();\n  }\n\n  void mapVirtualFile(StringRef FilePath, StringRef Content) override {\n    Tool.mapVirtualFile(FilePath, Content);\n  }\n\n  /// Returns the file manager used in the tool.\n  ///\n  /// The file manager is shared between all translation units.\n  FileManager &getFiles() { return Tool.getFiles(); }\n\nprivate:\n  // Used to store the parser when the executor is initialized with parser.\n  llvm::Optional<CommonOptionsParser> OptionsParser;\n  // FIXME: The standalone executor is currently just a wrapper of `ClangTool`.\n  // Merge `ClangTool` implementation into the this.\n  ClangTool Tool;\n  ExecutionContext Context;\n  InMemoryToolResults Results;\n  ArgumentsAdjuster ArgsAdjuster;\n};\n\n} // end namespace tooling\n} // end namespace clang\n\n#endif // LLVM_CLANG_TOOLING_STANDALONEEXECUTION_H\n"}, "98": {"id": 98, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Format.h", "content": "//===- Format.h - Efficient printf-style formatting for streams -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements the format() function, which can be used with other\n// LLVM subsystems to provide printf-style formatting.  This gives all the power\n// and risk of printf.  This can be used like this (with raw_ostreams as an\n// example):\n//\n//    OS << \"mynumber: \" << format(\"%4.5f\", 1234.412) << '\\n';\n//\n// Or if you prefer:\n//\n//  OS << format(\"mynumber: %4.5f\\n\", 1234.412);\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_FORMAT_H\n#define LLVM_SUPPORT_FORMAT_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/DataTypes.h\"\n#include <cassert>\n#include <cstdio>\n#include <tuple>\n#include <utility>\n\nnamespace llvm {\n\n/// This is a helper class used for handling formatted output.  It is the\n/// abstract base class of a templated derived class.\nclass format_object_base {\nprotected:\n  const char *Fmt;\n  ~format_object_base() = default; // Disallow polymorphic deletion.\n  format_object_base(const format_object_base &) = default;\n  virtual void home(); // Out of line virtual method.\n\n  /// Call snprintf() for this object, on the given buffer and size.\n  virtual int snprint(char *Buffer, unsigned BufferSize) const = 0;\n\npublic:\n  format_object_base(const char *fmt) : Fmt(fmt) {}\n\n  /// Format the object into the specified buffer.  On success, this returns\n  /// the length of the formatted string.  If the buffer is too small, this\n  /// returns a length to retry with, which will be larger than BufferSize.\n  unsigned print(char *Buffer, unsigned BufferSize) const {\n    assert(BufferSize && \"Invalid buffer size!\");\n\n    // Print the string, leaving room for the terminating null.\n    int N = snprint(Buffer, BufferSize);\n\n    // VC++ and old GlibC return negative on overflow, just double the size.\n    if (N < 0)\n      return BufferSize * 2;\n\n    // Other implementations yield number of bytes needed, not including the\n    // final '\\0'.\n    if (unsigned(N) >= BufferSize)\n      return N + 1;\n\n    // Otherwise N is the length of output (not including the final '\\0').\n    return N;\n  }\n};\n\n/// These are templated helper classes used by the format function that\n/// capture the object to be formatted and the format string. When actually\n/// printed, this synthesizes the string into a temporary buffer provided and\n/// returns whether or not it is big enough.\n\n// Helper to validate that format() parameters are scalars or pointers.\ntemplate <typename... Args> struct validate_format_parameters;\ntemplate <typename Arg, typename... Args>\nstruct validate_format_parameters<Arg, Args...> {\n  static_assert(std::is_scalar<Arg>::value,\n                \"format can't be used with non fundamental / non pointer type\");\n  validate_format_parameters() { validate_format_parameters<Args...>(); }\n};\ntemplate <> struct validate_format_parameters<> {};\n\ntemplate <typename... Ts>\nclass format_object final : public format_object_base {\n  std::tuple<Ts...> Vals;\n\n  template <std::size_t... Is>\n  int snprint_tuple(char *Buffer, unsigned BufferSize,\n                    std::index_sequence<Is...>) const {\n#ifdef _MSC_VER\n    return _snprintf(Buffer, BufferSize, Fmt, std::get<Is>(Vals)...);\n#else\n    return snprintf(Buffer, BufferSize, Fmt, std::get<Is>(Vals)...);\n#endif\n  }\n\npublic:\n  format_object(const char *fmt, const Ts &... vals)\n      : format_object_base(fmt), Vals(vals...) {\n    validate_format_parameters<Ts...>();\n  }\n\n  int snprint(char *Buffer, unsigned BufferSize) const override {\n    return snprint_tuple(Buffer, BufferSize, std::index_sequence_for<Ts...>());\n  }\n};\n\n/// These are helper functions used to produce formatted output.  They use\n/// template type deduction to construct the appropriate instance of the\n/// format_object class to simplify their construction.\n///\n/// This is typically used like:\n/// \\code\n///   OS << format(\"%0.4f\", myfloat) << '\\n';\n/// \\endcode\n\ntemplate <typename... Ts>\ninline format_object<Ts...> format(const char *Fmt, const Ts &... Vals) {\n  return format_object<Ts...>(Fmt, Vals...);\n}\n\n/// This is a helper class for left_justify, right_justify, and center_justify.\nclass FormattedString {\npublic:\n  enum Justification { JustifyNone, JustifyLeft, JustifyRight, JustifyCenter };\n  FormattedString(StringRef S, unsigned W, Justification J)\n      : Str(S), Width(W), Justify(J) {}\n\nprivate:\n  StringRef Str;\n  unsigned Width;\n  Justification Justify;\n  friend class raw_ostream;\n};\n\n/// left_justify - append spaces after string so total output is\n/// \\p Width characters.  If \\p Str is larger that \\p Width, full string\n/// is written with no padding.\ninline FormattedString left_justify(StringRef Str, unsigned Width) {\n  return FormattedString(Str, Width, FormattedString::JustifyLeft);\n}\n\n/// right_justify - add spaces before string so total output is\n/// \\p Width characters.  If \\p Str is larger that \\p Width, full string\n/// is written with no padding.\ninline FormattedString right_justify(StringRef Str, unsigned Width) {\n  return FormattedString(Str, Width, FormattedString::JustifyRight);\n}\n\n/// center_justify - add spaces before and after string so total output is\n/// \\p Width characters.  If \\p Str is larger that \\p Width, full string\n/// is written with no padding.\ninline FormattedString center_justify(StringRef Str, unsigned Width) {\n  return FormattedString(Str, Width, FormattedString::JustifyCenter);\n}\n\n/// This is a helper class used for format_hex() and format_decimal().\nclass FormattedNumber {\n  uint64_t HexValue;\n  int64_t DecValue;\n  unsigned Width;\n  bool Hex;\n  bool Upper;\n  bool HexPrefix;\n  friend class raw_ostream;\n\npublic:\n  FormattedNumber(uint64_t HV, int64_t DV, unsigned W, bool H, bool U,\n                  bool Prefix)\n      : HexValue(HV), DecValue(DV), Width(W), Hex(H), Upper(U),\n        HexPrefix(Prefix) {}\n};\n\n/// format_hex - Output \\p N as a fixed width hexadecimal. If number will not\n/// fit in width, full number is still printed.  Examples:\n///   OS << format_hex(255, 4)              => 0xff\n///   OS << format_hex(255, 4, true)        => 0xFF\n///   OS << format_hex(255, 6)              => 0x00ff\n///   OS << format_hex(255, 2)              => 0xff\ninline FormattedNumber format_hex(uint64_t N, unsigned Width,\n                                  bool Upper = false) {\n  assert(Width <= 18 && \"hex width must be <= 18\");\n  return FormattedNumber(N, 0, Width, true, Upper, true);\n}\n\n/// format_hex_no_prefix - Output \\p N as a fixed width hexadecimal. Does not\n/// prepend '0x' to the outputted string.  If number will not fit in width,\n/// full number is still printed.  Examples:\n///   OS << format_hex_no_prefix(255, 2)              => ff\n///   OS << format_hex_no_prefix(255, 2, true)        => FF\n///   OS << format_hex_no_prefix(255, 4)              => 00ff\n///   OS << format_hex_no_prefix(255, 1)              => ff\ninline FormattedNumber format_hex_no_prefix(uint64_t N, unsigned Width,\n                                            bool Upper = false) {\n  assert(Width <= 16 && \"hex width must be <= 16\");\n  return FormattedNumber(N, 0, Width, true, Upper, false);\n}\n\n/// format_decimal - Output \\p N as a right justified, fixed-width decimal. If\n/// number will not fit in width, full number is still printed.  Examples:\n///   OS << format_decimal(0, 5)     => \"    0\"\n///   OS << format_decimal(255, 5)   => \"  255\"\n///   OS << format_decimal(-1, 3)    => \" -1\"\n///   OS << format_decimal(12345, 3) => \"12345\"\ninline FormattedNumber format_decimal(int64_t N, unsigned Width) {\n  return FormattedNumber(0, N, Width, false, false, false);\n}\n\nclass FormattedBytes {\n  ArrayRef<uint8_t> Bytes;\n\n  // If not None, display offsets for each line relative to starting value.\n  Optional<uint64_t> FirstByteOffset;\n  uint32_t IndentLevel;  // Number of characters to indent each line.\n  uint32_t NumPerLine;   // Number of bytes to show per line.\n  uint8_t ByteGroupSize; // How many hex bytes are grouped without spaces\n  bool Upper;            // Show offset and hex bytes as upper case.\n  bool ASCII;            // Show the ASCII bytes for the hex bytes to the right.\n  friend class raw_ostream;\n\npublic:\n  FormattedBytes(ArrayRef<uint8_t> B, uint32_t IL, Optional<uint64_t> O,\n                 uint32_t NPL, uint8_t BGS, bool U, bool A)\n      : Bytes(B), FirstByteOffset(O), IndentLevel(IL), NumPerLine(NPL),\n        ByteGroupSize(BGS), Upper(U), ASCII(A) {\n\n    if (ByteGroupSize > NumPerLine)\n      ByteGroupSize = NumPerLine;\n  }\n};\n\ninline FormattedBytes\nformat_bytes(ArrayRef<uint8_t> Bytes, Optional<uint64_t> FirstByteOffset = None,\n             uint32_t NumPerLine = 16, uint8_t ByteGroupSize = 4,\n             uint32_t IndentLevel = 0, bool Upper = false) {\n  return FormattedBytes(Bytes, IndentLevel, FirstByteOffset, NumPerLine,\n                        ByteGroupSize, Upper, false);\n}\n\ninline FormattedBytes\nformat_bytes_with_ascii(ArrayRef<uint8_t> Bytes,\n                        Optional<uint64_t> FirstByteOffset = None,\n                        uint32_t NumPerLine = 16, uint8_t ByteGroupSize = 4,\n                        uint32_t IndentLevel = 0, bool Upper = false) {\n  return FormattedBytes(Bytes, IndentLevel, FirstByteOffset, NumPerLine,\n                        ByteGroupSize, Upper, true);\n}\n\n} // end namespace llvm\n\n#endif\n"}, "107": {"id": 107, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TypeSize.h", "content": "//===- TypeSize.h - Wrapper around type sizes -------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file provides a struct that can be used to query the size of IR types\n// which may be scalable vectors. It provides convenience operators so that\n// it can be used in much the same way as a single scalar value.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_TYPESIZE_H\n#define LLVM_SUPPORT_TYPESIZE_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/WithColor.h\"\n\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <type_traits>\n\nnamespace llvm {\n\ntemplate <typename LeafTy> struct LinearPolyBaseTypeTraits {};\n\n//===----------------------------------------------------------------------===//\n// LinearPolyBase - a base class for linear polynomials with multiple\n// dimensions. This can e.g. be used to describe offsets that are have both a\n// fixed and scalable component.\n//===----------------------------------------------------------------------===//\n\n/// LinearPolyBase describes a linear polynomial:\n///  c0 * scale0 + c1 * scale1 + ... + cK * scaleK\n/// where the scale is implicit, so only the coefficients are encoded.\ntemplate <typename LeafTy>\nclass LinearPolyBase {\npublic:\n  using ScalarTy = typename LinearPolyBaseTypeTraits<LeafTy>::ScalarTy;\n  static constexpr auto Dimensions = LinearPolyBaseTypeTraits<LeafTy>::Dimensions;\n  static_assert(Dimensions != std::numeric_limits<unsigned>::max(),\n                \"Dimensions out of range\");\n\nprivate:\n  std::array<ScalarTy, Dimensions> Coefficients;\n\nprotected:\n  LinearPolyBase(ArrayRef<ScalarTy> Values) {\n    std::copy(Values.begin(), Values.end(), Coefficients.begin());\n  }\n\npublic:\n  friend LeafTy &operator+=(LeafTy &LHS, const LeafTy &RHS) {\n    for (unsigned I=0; I<Dimensions; ++I)\n      LHS.Coefficients[I] += RHS.Coefficients[I];\n    return LHS;\n  }\n\n  friend LeafTy &operator-=(LeafTy &LHS, const LeafTy &RHS) {\n    for (unsigned I=0; I<Dimensions; ++I)\n      LHS.Coefficients[I] -= RHS.Coefficients[I];\n    return LHS;\n  }\n\n  friend LeafTy &operator*=(LeafTy &LHS, ScalarTy RHS) {\n    for (auto &C : LHS.Coefficients)\n      C *= RHS;\n    return LHS;\n  }\n\n  friend LeafTy operator+(const LeafTy &LHS, const LeafTy &RHS) {\n    LeafTy Copy = LHS;\n    return Copy += RHS;\n  }\n\n  friend LeafTy operator-(const LeafTy &LHS, const LeafTy &RHS) {\n    LeafTy Copy = LHS;\n    return Copy -= RHS;\n  }\n\n  friend LeafTy operator*(const LeafTy &LHS, ScalarTy RHS) {\n    LeafTy Copy = LHS;\n    return Copy *= RHS;\n  }\n\n  template <typename U = ScalarTy>\n  friend typename std::enable_if_t<std::is_signed<U>::value, LeafTy>\n  operator-(const LeafTy &LHS) {\n    LeafTy Copy = LHS;\n    return Copy *= -1;\n  }\n\n  bool operator==(const LinearPolyBase &RHS) const {\n    return std::equal(Coefficients.begin(), Coefficients.end(),\n                      RHS.Coefficients.begin());\n  }\n\n  bool operator!=(const LinearPolyBase &RHS) const {\n    return !(*this == RHS);\n  }\n\n  bool isZero() const {\n    return all_of(Coefficients, [](const ScalarTy &C) { return C == 0; });\n  }\n  bool isNonZero() const { return !isZero(); }\n  explicit operator bool() const { return isNonZero(); }\n\n  ScalarTy getValue(unsigned Dim) const { return Coefficients[Dim]; }\n};\n\n//===----------------------------------------------------------------------===//\n// StackOffset - Represent an offset with named fixed and scalable components.\n//===----------------------------------------------------------------------===//\n\nclass StackOffset;\ntemplate <> struct LinearPolyBaseTypeTraits<StackOffset> {\n  using ScalarTy = int64_t;\n  static constexpr unsigned Dimensions = 2;\n};\n\n/// StackOffset is a class to represent an offset with 2 dimensions,\n/// named fixed and scalable, respectively. This class allows a value for both\n/// dimensions to depict e.g. \"8 bytes and 16 scalable bytes\", which is needed\n/// to represent stack offsets.\nclass StackOffset : public LinearPolyBase<StackOffset> {\nprotected:\n  StackOffset(ScalarTy Fixed, ScalarTy Scalable)\n      : LinearPolyBase<StackOffset>({Fixed, Scalable}) {}\n\npublic:\n  StackOffset() : StackOffset({0, 0}) {}\n  StackOffset(const LinearPolyBase<StackOffset> &Other)\n      : LinearPolyBase<StackOffset>(Other) {}\n  static StackOffset getFixed(ScalarTy Fixed) { return {Fixed, 0}; }\n  static StackOffset getScalable(ScalarTy Scalable) { return {0, Scalable}; }\n  static StackOffset get(ScalarTy Fixed, ScalarTy Scalable) {\n    return {Fixed, Scalable};\n  }\n\n  ScalarTy getFixed() const { return this->getValue(0); }\n  ScalarTy getScalable() const { return this->getValue(1); }\n};\n\n//===----------------------------------------------------------------------===//\n// UnivariateLinearPolyBase - a base class for linear polynomials with multiple\n// dimensions, but where only one dimension can be set at any time.\n// This can e.g. be used to describe sizes that are either fixed or scalable.\n//===----------------------------------------------------------------------===//\n\n/// UnivariateLinearPolyBase is a base class for ElementCount and TypeSize.\n/// Like LinearPolyBase it tries to represent a linear polynomial\n/// where only one dimension can be set at any time, e.g.\n///   0 * scale0 + 0 * scale1 + ... + cJ * scaleJ + ... + 0 * scaleK\n/// The dimension that is set is the univariate dimension.\ntemplate <typename LeafTy>\nclass UnivariateLinearPolyBase {\npublic:\n  using ScalarTy = typename LinearPolyBaseTypeTraits<LeafTy>::ScalarTy;\n  static constexpr auto Dimensions = LinearPolyBaseTypeTraits<LeafTy>::Dimensions;\n  static_assert(Dimensions != std::numeric_limits<unsigned>::max(),\n                \"Dimensions out of range\");\n\nprotected:\n  ScalarTy Value;         // The value at the univeriate dimension.\n  unsigned UnivariateDim; // The univeriate dimension.\n\n  UnivariateLinearPolyBase(ScalarTy Val, unsigned UnivariateDim)\n      : Value(Val), UnivariateDim(UnivariateDim) {\n    assert(UnivariateDim < Dimensions && \"Dimension out of range\");\n  }\n\n  friend LeafTy &operator+=(LeafTy &LHS, const LeafTy &RHS) {\n    assert(LHS.UnivariateDim == RHS.UnivariateDim && \"Invalid dimensions\");\n    LHS.Value += RHS.Value;\n    return LHS;\n  }\n\n  friend LeafTy &operator-=(LeafTy &LHS, const LeafTy &RHS) {\n    assert(LHS.UnivariateDim == RHS.UnivariateDim && \"Invalid dimensions\");\n    LHS.Value -= RHS.Value;\n    return LHS;\n  }\n\n  friend LeafTy &operator*=(LeafTy &LHS, ScalarTy RHS) {\n    LHS.Value *= RHS;\n    return LHS;\n  }\n\n  friend LeafTy operator+(const LeafTy &LHS, const LeafTy &RHS) {\n    LeafTy Copy = LHS;\n    return Copy += RHS;\n  }\n\n  friend LeafTy operator-(const LeafTy &LHS, const LeafTy &RHS) {\n    LeafTy Copy = LHS;\n    return Copy -= RHS;\n  }\n\n  friend LeafTy operator*(const LeafTy &LHS, ScalarTy RHS) {\n    LeafTy Copy = LHS;\n    return Copy *= RHS;\n  }\n\n  template <typename U = ScalarTy>\n  friend typename std::enable_if<std::is_signed<U>::value, LeafTy>::type\n  operator-(const LeafTy &LHS) {\n    LeafTy Copy = LHS;\n    return Copy *= -1;\n  }\n\npublic:\n  bool operator==(const UnivariateLinearPolyBase &RHS) const {\n    return Value == RHS.Value && UnivariateDim == RHS.UnivariateDim;\n  }\n\n  bool operator!=(const UnivariateLinearPolyBase &RHS) const {\n    return !(*this == RHS);\n  }\n\n  bool isZero() const { return !Value; }\n  bool isNonZero() const { return !isZero(); }\n  explicit operator bool() const { return isNonZero(); }\n  ScalarTy getValue() const { return Value; }\n  ScalarTy getValue(unsigned Dim) const {\n    return Dim == UnivariateDim ? Value : 0;\n  }\n\n  /// Add \\p RHS to the value at the univariate dimension.\n  LeafTy getWithIncrement(ScalarTy RHS) const {\n    return static_cast<LeafTy>(\n        UnivariateLinearPolyBase(Value + RHS, UnivariateDim));\n  }\n\n  /// Subtract \\p RHS from the value at the univariate dimension.\n  LeafTy getWithDecrement(ScalarTy RHS) const {\n    return static_cast<LeafTy>(\n        UnivariateLinearPolyBase(Value - RHS, UnivariateDim));\n  }\n};\n\n\n//===----------------------------------------------------------------------===//\n// LinearPolySize - base class for fixed- or scalable sizes.\n//  ^  ^ \n//  |  |\n//  |  +----- ElementCount - Leaf class to represent an element count\n//  |                        (vscale x unsigned)\n//  |\n//  +-------- TypeSize - Leaf class to represent a type size\n//                       (vscale x uint64_t)\n//===----------------------------------------------------------------------===//\n\n/// LinearPolySize is a base class to represent sizes. It is either\n/// fixed-sized or it is scalable-sized, but it cannot be both.\ntemplate <typename LeafTy>\nclass LinearPolySize : public UnivariateLinearPolyBase<LeafTy> {\n  // Make the parent class a friend, so that it can access the protected\n  // conversion/copy-constructor for UnivariatePolyBase<LeafTy> ->\n  // LinearPolySize<LeafTy>.\n  friend class UnivariateLinearPolyBase<LeafTy>;\n\npublic:\n  using ScalarTy = typename UnivariateLinearPolyBase<LeafTy>::ScalarTy;\n  enum Dims : unsigned { FixedDim = 0, ScalableDim = 1 };\n\nprotected:\n  LinearPolySize(ScalarTy MinVal, Dims D)\n      : UnivariateLinearPolyBase<LeafTy>(MinVal, D) {}\n\n  LinearPolySize(const UnivariateLinearPolyBase<LeafTy> &V)\n      : UnivariateLinearPolyBase<LeafTy>(V) {}\n\npublic:\n\n  static LeafTy getFixed(ScalarTy MinVal) {\n    return static_cast<LeafTy>(LinearPolySize(MinVal, FixedDim));\n  }\n  static LeafTy getScalable(ScalarTy MinVal) {\n    return static_cast<LeafTy>(LinearPolySize(MinVal, ScalableDim));\n  }\n  static LeafTy get(ScalarTy MinVal, bool Scalable) {\n    return static_cast<LeafTy>(\n        LinearPolySize(MinVal, Scalable ? ScalableDim : FixedDim));\n  }\n  static LeafTy getNull() { return get(0, false); }\n\n  /// Returns the minimum value this size can represent.\n  ScalarTy getKnownMinValue() const { return this->getValue(); }\n  /// Returns whether the size is scaled by a runtime quantity (vscale).\n  bool isScalable() const { return this->UnivariateDim == ScalableDim; }\n  /// A return value of true indicates we know at compile time that the number\n  /// of elements (vscale * Min) is definitely even. However, returning false\n  /// does not guarantee that the total number of elements is odd.\n  bool isKnownEven() const { return (getKnownMinValue() & 0x1) == 0; }\n  /// This function tells the caller whether the element count is known at\n  /// compile time to be a multiple of the scalar value RHS.\n  bool isKnownMultipleOf(ScalarTy RHS) const {\n    return getKnownMinValue() % RHS == 0;\n  }\n\n  // Return the minimum value with the assumption that the count is exact.\n  // Use in places where a scalable count doesn't make sense (e.g. non-vector\n  // types, or vectors in backends which don't support scalable vectors).\n  ScalarTy getFixedValue() const {\n    assert(!isScalable() &&\n           \"Request for a fixed element count on a scalable object\");\n    return getKnownMinValue();\n  }\n\n  // For some cases, size ordering between scalable and fixed size types cannot\n  // be determined at compile time, so such comparisons aren't allowed.\n  //\n  // e.g. <vscale x 2 x i16> could be bigger than <4 x i32> with a runtime\n  // vscale >= 5, equal sized with a vscale of 4, and smaller with\n  // a vscale <= 3.\n  //\n  // All the functions below make use of the fact vscale is always >= 1, which\n  // means that <vscale x 4 x i32> is guaranteed to be >= <4 x i32>, etc.\n\n  static bool isKnownLT(const LinearPolySize &LHS, const LinearPolySize &RHS) {\n    if (!LHS.isScalable() || RHS.isScalable())\n      return LHS.getKnownMinValue() < RHS.getKnownMinValue();\n    return false;\n  }\n\n  static bool isKnownGT(const LinearPolySize &LHS, const LinearPolySize &RHS) {\n    if (LHS.isScalable() || !RHS.isScalable())\n      return LHS.getKnownMinValue() > RHS.getKnownMinValue();\n    return false;\n  }\n\n  static bool isKnownLE(const LinearPolySize &LHS, const LinearPolySize &RHS) {\n    if (!LHS.isScalable() || RHS.isScalable())\n      return LHS.getKnownMinValue() <= RHS.getKnownMinValue();\n    return false;\n  }\n\n  static bool isKnownGE(const LinearPolySize &LHS, const LinearPolySize &RHS) {\n    if (LHS.isScalable() || !RHS.isScalable())\n      return LHS.getKnownMinValue() >= RHS.getKnownMinValue();\n    return false;\n  }\n\n  /// We do not provide the '/' operator here because division for polynomial\n  /// types does not work in the same way as for normal integer types. We can\n  /// only divide the minimum value (or coefficient) by RHS, which is not the\n  /// same as\n  ///   (Min * Vscale) / RHS\n  /// The caller is recommended to use this function in combination with\n  /// isKnownMultipleOf(RHS), which lets the caller know if it's possible to\n  /// perform a lossless divide by RHS.\n  LeafTy divideCoefficientBy(ScalarTy RHS) const {\n    return static_cast<LeafTy>(\n        LinearPolySize::get(getKnownMinValue() / RHS, isScalable()));\n  }\n\n  LeafTy coefficientNextPowerOf2() const {\n    return static_cast<LeafTy>(LinearPolySize::get(\n        static_cast<ScalarTy>(llvm::NextPowerOf2(getKnownMinValue())),\n        isScalable()));\n  }\n\n  /// Printing function.\n  void print(raw_ostream &OS) const {\n    if (isScalable())\n      OS << \"vscale x \";\n    OS << getKnownMinValue();\n  }\n};\n\nclass ElementCount;\ntemplate <> struct LinearPolyBaseTypeTraits<ElementCount> {\n  using ScalarTy = unsigned;\n  static constexpr unsigned Dimensions = 2;\n};\n\nclass ElementCount : public LinearPolySize<ElementCount> {\npublic:\n  ElementCount() : LinearPolySize(LinearPolySize::getNull()) {}\n\n  ElementCount(const LinearPolySize<ElementCount> &V) : LinearPolySize(V) {}\n\n  /// Counting predicates.\n  ///\n  ///@{ Number of elements..\n  /// Exactly one element.\n  bool isScalar() const { return !isScalable() && getKnownMinValue() == 1; }\n  /// One or more elements.\n  bool isVector() const {\n    return (isScalable() && getKnownMinValue() != 0) || getKnownMinValue() > 1;\n  }\n  ///@}\n};\n\n// This class is used to represent the size of types. If the type is of fixed\nclass TypeSize;\ntemplate <> struct LinearPolyBaseTypeTraits<TypeSize> {\n  using ScalarTy = uint64_t;\n  static constexpr unsigned Dimensions = 2;\n};\n\n// TODO: Most functionality in this class will gradually be phased out\n// so it will resemble LinearPolySize as much as possible.\n//\n// TypeSize is used to represent the size of types. If the type is of fixed\n// size, it will represent the exact size. If the type is a scalable vector,\n// it will represent the known minimum size.\nclass TypeSize : public LinearPolySize<TypeSize> {\npublic:\n  TypeSize(const LinearPolySize<TypeSize> &V) : LinearPolySize(V) {}\n  TypeSize(ScalarTy MinVal, bool IsScalable)\n      : LinearPolySize(LinearPolySize::get(MinVal, IsScalable)) {}\n\n  static TypeSize Fixed(ScalarTy MinVal) { return TypeSize(MinVal, false); }\n  static TypeSize Scalable(ScalarTy MinVal) { return TypeSize(MinVal, true); }\n\n  ScalarTy getFixedSize() const { return getFixedValue(); }\n  ScalarTy getKnownMinSize() const { return getKnownMinValue(); }\n\n  // All code for this class below this point is needed because of the\n  // temporary implicit conversion to uint64_t. The operator overloads are\n  // needed because otherwise the conversion of the parent class\n  // UnivariateLinearPolyBase -> TypeSize is ambiguous.\n  // TODO: Remove the implicit conversion.\n\n  // Casts to a uint64_t if this is a fixed-width size.\n  //\n  // This interface is deprecated and will be removed in a future version\n  // of LLVM in favour of upgrading uses that rely on this implicit conversion\n  // to uint64_t. Calls to functions that return a TypeSize should use the\n  // proper interfaces to TypeSize.\n  // In practice this is mostly calls to MVT/EVT::getSizeInBits().\n  //\n  // To determine how to upgrade the code:\n  //\n  //   if (<algorithm works for both scalable and fixed-width vectors>)\n  //     use getKnownMinValue()\n  //   else if (<algorithm works only for fixed-width vectors>) {\n  //     if <algorithm can be adapted for both scalable and fixed-width vectors>\n  //       update the algorithm and use getKnownMinValue()\n  //     else\n  //       bail out early for scalable vectors and use getFixedValue()\n  //   }\n  operator ScalarTy() const {\n#ifdef STRICT_FIXED_SIZE_VECTORS\n    return getFixedValue();\n#else\n    if (isScalable())\n      WithColor::warning() << \"Compiler has made implicit assumption that \"\n                              \"TypeSize is not scalable. This may or may not \"\n                              \"lead to broken code.\\n\";\n    return getKnownMinValue();\n#endif\n  }\n\n  // Additional operators needed to avoid ambiguous parses\n  // because of the implicit conversion hack.\n  friend TypeSize operator*(const TypeSize &LHS, const int RHS) {\n    return LHS * (ScalarTy)RHS;\n  }\n  friend TypeSize operator*(const TypeSize &LHS, const unsigned RHS) {\n    return LHS * (ScalarTy)RHS;\n  }\n  friend TypeSize operator*(const TypeSize &LHS, const int64_t RHS) {\n    return LHS * (ScalarTy)RHS;\n  }\n  friend TypeSize operator*(const int LHS, const TypeSize &RHS) {\n    return RHS * LHS;\n  }\n  friend TypeSize operator*(const unsigned LHS, const TypeSize &RHS) {\n    return RHS * LHS;\n  }\n  friend TypeSize operator*(const int64_t LHS, const TypeSize &RHS) {\n    return RHS * LHS;\n  }\n  friend TypeSize operator*(const uint64_t LHS, const TypeSize &RHS) {\n    return RHS * LHS;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Utilities\n//===----------------------------------------------------------------------===//\n\n/// Returns a TypeSize with a known minimum size that is the next integer\n/// (mod 2**64) that is greater than or equal to \\p Value and is a multiple\n/// of \\p Align. \\p Align must be non-zero.\n///\n/// Similar to the alignTo functions in MathExtras.h\ninline TypeSize alignTo(TypeSize Size, uint64_t Align) {\n  assert(Align != 0u && \"Align must be non-zero\");\n  return {(Size.getKnownMinValue() + Align - 1) / Align * Align,\n          Size.isScalable()};\n}\n\n/// Stream operator function for `LinearPolySize`.\ntemplate <typename LeafTy>\ninline raw_ostream &operator<<(raw_ostream &OS,\n                               const LinearPolySize<LeafTy> &PS) {\n  PS.print(OS);\n  return OS;\n}\n\ntemplate <typename T> struct DenseMapInfo;\ntemplate <> struct DenseMapInfo<ElementCount> {\n  static inline ElementCount getEmptyKey() {\n    return ElementCount::getScalable(~0U);\n  }\n  static inline ElementCount getTombstoneKey() {\n    return ElementCount::getFixed(~0U - 1);\n  }\n  static unsigned getHashValue(const ElementCount &EltCnt) {\n    unsigned HashVal = EltCnt.getKnownMinValue() * 37U;\n    if (EltCnt.isScalable())\n      return (HashVal - 1U);\n\n    return HashVal;\n  }\n\n  static bool isEqual(const ElementCount &LHS, const ElementCount &RHS) {\n    return LHS == RHS;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_TYPESIZE_H\n"}, "115": {"id": 115, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-internal.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Authors: wan@google.com (Zhanyong Wan), eefacm@gmail.com (Sean Mcafee)\n//\n// The Google C++ Testing Framework (Google Test)\n//\n// This header file declares functions and macros used internally by\n// Google Test.  They are subject to change without notice.\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_\n\n#include \"gtest/internal/gtest-port.h\"\n\n#if GTEST_OS_LINUX\n# include <stdlib.h>\n# include <sys/types.h>\n# include <sys/wait.h>\n# include <unistd.h>\n#endif  // GTEST_OS_LINUX\n\n#if GTEST_HAS_EXCEPTIONS\n# include <stdexcept>\n#endif\n\n#include <ctype.h>\n#include <float.h>\n#include <string.h>\n#include <iomanip>\n#include <limits>\n#include <map>\n#include <set>\n#include <string>\n#include <vector>\n\n#include \"gtest/gtest-message.h\"\n#include \"gtest/internal/gtest-string.h\"\n#include \"gtest/internal/gtest-filepath.h\"\n#include \"gtest/internal/gtest-type-util.h\"\n\n// Due to C++ preprocessor weirdness, we need double indirection to\n// concatenate two tokens when one of them is __LINE__.  Writing\n//\n//   foo ## __LINE__\n//\n// will result in the token foo__LINE__, instead of foo followed by\n// the current line number.  For more details, see\n// http://www.parashift.com/c++-faq-lite/misc-technical-issues.html#faq-39.6\n#define GTEST_CONCAT_TOKEN_(foo, bar) GTEST_CONCAT_TOKEN_IMPL_(foo, bar)\n#define GTEST_CONCAT_TOKEN_IMPL_(foo, bar) foo ## bar\n\nclass ProtocolMessage;\nnamespace proto2 { class Message; }\n\nnamespace testing {\n\n// Forward declarations.\n\nclass AssertionResult;                 // Result of an assertion.\nclass Message;                         // Represents a failure message.\nclass Test;                            // Represents a test.\nclass TestInfo;                        // Information about a test.\nclass TestPartResult;                  // Result of a test part.\nclass UnitTest;                        // A collection of test cases.\n\ntemplate <typename T>\n::std::string PrintToString(const T& value);\n\nnamespace internal {\n\nstruct TraceInfo;                      // Information about a trace point.\nclass ScopedTrace;                     // Implements scoped trace.\nclass TestInfoImpl;                    // Opaque implementation of TestInfo\nclass UnitTestImpl;                    // Opaque implementation of UnitTest\n\n// The text used in failure messages to indicate the start of the\n// stack trace.\nGTEST_API_ extern const char kStackTraceMarker[];\n\n// Two overloaded helpers for checking at compile time whether an\n// expression is a null pointer literal (i.e. NULL or any 0-valued\n// compile-time integral constant).  Their return values have\n// different sizes, so we can use sizeof() to test which version is\n// picked by the compiler.  These helpers have no implementations, as\n// we only need their signatures.\n//\n// Given IsNullLiteralHelper(x), the compiler will pick the first\n// version if x can be implicitly converted to Secret*, and pick the\n// second version otherwise.  Since Secret is a secret and incomplete\n// type, the only expression a user can write that has type Secret* is\n// a null pointer literal.  Therefore, we know that x is a null\n// pointer literal if and only if the first version is picked by the\n// compiler.\nchar IsNullLiteralHelper(Secret* p);\nchar (&IsNullLiteralHelper(...))[2];  // NOLINT\n\n// A compile-time bool constant that is true if and only if x is a\n// null pointer literal (i.e. NULL or any 0-valued compile-time\n// integral constant).\n#ifdef GTEST_ELLIPSIS_NEEDS_POD_\n// We lose support for NULL detection where the compiler doesn't like\n// passing non-POD classes through ellipsis (...).\n# define GTEST_IS_NULL_LITERAL_(x) false\n#else\n# define GTEST_IS_NULL_LITERAL_(x) \\\n    (sizeof(::testing::internal::IsNullLiteralHelper(x)) == 1)\n#endif  // GTEST_ELLIPSIS_NEEDS_POD_\n\n// Appends the user-supplied message to the Google-Test-generated message.\nGTEST_API_ std::string AppendUserMessage(\n    const std::string& gtest_msg, const Message& user_msg);\n\n#if GTEST_HAS_EXCEPTIONS\n\n// This exception is thrown by (and only by) a failed Google Test\n// assertion when GTEST_FLAG(throw_on_failure) is true (if exceptions\n// are enabled).  We derive it from std::runtime_error, which is for\n// errors presumably detectable only at run time.  Since\n// std::runtime_error inherits from std::exception, many testing\n// frameworks know how to extract and print the message inside it.\nclass GTEST_API_ GoogleTestFailureException : public ::std::runtime_error {\n public:\n  explicit GoogleTestFailureException(const TestPartResult& failure);\n};\n\n#endif  // GTEST_HAS_EXCEPTIONS\n\n// A helper class for creating scoped traces in user programs.\nclass GTEST_API_ ScopedTrace {\n public:\n  // The c'tor pushes the given source file location and message onto\n  // a trace stack maintained by Google Test.\n  ScopedTrace(const char* file, int line, const Message& message);\n\n  // The d'tor pops the info pushed by the c'tor.\n  //\n  // Note that the d'tor is not virtual in order to be efficient.\n  // Don't inherit from ScopedTrace!\n  ~ScopedTrace();\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ScopedTrace);\n} GTEST_ATTRIBUTE_UNUSED_;  // A ScopedTrace object does its job in its\n                            // c'tor and d'tor.  Therefore it doesn't\n                            // need to be used otherwise.\n\nnamespace edit_distance {\n// Returns the optimal edits to go from 'left' to 'right'.\n// All edits cost the same, with replace having lower priority than\n// add/remove.\n// Simple implementation of the Wagner\u2013Fischer algorithm.\n// See http://en.wikipedia.org/wiki/Wagner-Fischer_algorithm\nenum EditType { kMatch, kAdd, kRemove, kReplace };\nGTEST_API_ std::vector<EditType> CalculateOptimalEdits(\n    const std::vector<size_t>& left, const std::vector<size_t>& right);\n\n// Same as above, but the input is represented as strings.\nGTEST_API_ std::vector<EditType> CalculateOptimalEdits(\n    const std::vector<std::string>& left,\n    const std::vector<std::string>& right);\n\n// Create a diff of the input strings in Unified diff format.\nGTEST_API_ std::string CreateUnifiedDiff(const std::vector<std::string>& left,\n                                         const std::vector<std::string>& right,\n                                         size_t context = 2);\n\n}  // namespace edit_distance\n\n// Calculate the diff between 'left' and 'right' and return it in unified diff\n// format.\n// If not null, stores in 'total_line_count' the total number of lines found\n// in left + right.\nGTEST_API_ std::string DiffStrings(const std::string& left,\n                                   const std::string& right,\n                                   size_t* total_line_count);\n\n// Constructs and returns the message for an equality assertion\n// (e.g. ASSERT_EQ, EXPECT_STREQ, etc) failure.\n//\n// The first four parameters are the expressions used in the assertion\n// and their values, as strings.  For example, for ASSERT_EQ(foo, bar)\n// where foo is 5 and bar is 6, we have:\n//\n//   expected_expression: \"foo\"\n//   actual_expression:   \"bar\"\n//   expected_value:      \"5\"\n//   actual_value:        \"6\"\n//\n// The ignoring_case parameter is true iff the assertion is a\n// *_STRCASEEQ*.  When it's true, the string \" (ignoring case)\" will\n// be inserted into the message.\nGTEST_API_ AssertionResult EqFailure(const char* expected_expression,\n                                     const char* actual_expression,\n                                     const std::string& expected_value,\n                                     const std::string& actual_value,\n                                     bool ignoring_case);\n\n// Constructs a failure message for Boolean assertions such as EXPECT_TRUE.\nGTEST_API_ std::string GetBoolAssertionFailureMessage(\n    const AssertionResult& assertion_result,\n    const char* expression_text,\n    const char* actual_predicate_value,\n    const char* expected_predicate_value);\n\n// This template class represents an IEEE floating-point number\n// (either single-precision or double-precision, depending on the\n// template parameters).\n//\n// The purpose of this class is to do more sophisticated number\n// comparison.  (Due to round-off error, etc, it's very unlikely that\n// two floating-points will be equal exactly.  Hence a naive\n// comparison by the == operation often doesn't work.)\n//\n// Format of IEEE floating-point:\n//\n//   The most-significant bit being the leftmost, an IEEE\n//   floating-point looks like\n//\n//     sign_bit exponent_bits fraction_bits\n//\n//   Here, sign_bit is a single bit that designates the sign of the\n//   number.\n//\n//   For float, there are 8 exponent bits and 23 fraction bits.\n//\n//   For double, there are 11 exponent bits and 52 fraction bits.\n//\n//   More details can be found at\n//   http://en.wikipedia.org/wiki/IEEE_floating-point_standard.\n//\n// Template parameter:\n//\n//   RawType: the raw floating-point type (either float or double)\ntemplate <typename RawType>\nclass FloatingPoint {\n public:\n  // Defines the unsigned integer type that has the same size as the\n  // floating point number.\n  typedef typename TypeWithSize<sizeof(RawType)>::UInt Bits;\n\n  // Constants.\n\n  // # of bits in a number.\n  static const size_t kBitCount = 8*sizeof(RawType);\n\n  // # of fraction bits in a number.\n  static const size_t kFractionBitCount =\n    std::numeric_limits<RawType>::digits - 1;\n\n  // # of exponent bits in a number.\n  static const size_t kExponentBitCount = kBitCount - 1 - kFractionBitCount;\n\n  // The mask for the sign bit.\n  static const Bits kSignBitMask = static_cast<Bits>(1) << (kBitCount - 1);\n\n  // The mask for the fraction bits.\n  static const Bits kFractionBitMask =\n    ~static_cast<Bits>(0) >> (kExponentBitCount + 1);\n\n  // The mask for the exponent bits.\n  static const Bits kExponentBitMask = ~(kSignBitMask | kFractionBitMask);\n\n  // How many ULP's (Units in the Last Place) we want to tolerate when\n  // comparing two numbers.  The larger the value, the more error we\n  // allow.  A 0 value means that two numbers must be exactly the same\n  // to be considered equal.\n  //\n  // The maximum error of a single floating-point operation is 0.5\n  // units in the last place.  On Intel CPU's, all floating-point\n  // calculations are done with 80-bit precision, while double has 64\n  // bits.  Therefore, 4 should be enough for ordinary use.\n  //\n  // See the following article for more details on ULP:\n  // http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\n  static const size_t kMaxUlps = 4;\n\n  // Constructs a FloatingPoint from a raw floating-point number.\n  //\n  // On an Intel CPU, passing a non-normalized NAN (Not a Number)\n  // around may change its bits, although the new value is guaranteed\n  // to be also a NAN.  Therefore, don't expect this constructor to\n  // preserve the bits in x when x is a NAN.\n  explicit FloatingPoint(const RawType& x) { u_.value_ = x; }\n\n  // Static methods\n\n  // Reinterprets a bit pattern as a floating-point number.\n  //\n  // This function is needed to test the AlmostEquals() method.\n  static RawType ReinterpretBits(const Bits bits) {\n    FloatingPoint fp(0);\n    fp.u_.bits_ = bits;\n    return fp.u_.value_;\n  }\n\n  // Returns the floating-point number that represent positive infinity.\n  static RawType Infinity() {\n    return ReinterpretBits(kExponentBitMask);\n  }\n\n  // Returns the maximum representable finite floating-point number.\n  static RawType Max();\n\n  // Non-static methods\n\n  // Returns the bits that represents this number.\n  const Bits &bits() const { return u_.bits_; }\n\n  // Returns the exponent bits of this number.\n  Bits exponent_bits() const { return kExponentBitMask & u_.bits_; }\n\n  // Returns the fraction bits of this number.\n  Bits fraction_bits() const { return kFractionBitMask & u_.bits_; }\n\n  // Returns the sign bit of this number.\n  Bits sign_bit() const { return kSignBitMask & u_.bits_; }\n\n  // Returns true iff this is NAN (not a number).\n  bool is_nan() const {\n    // It's a NAN if the exponent bits are all ones and the fraction\n    // bits are not entirely zeros.\n    return (exponent_bits() == kExponentBitMask) && (fraction_bits() != 0);\n  }\n\n  // Returns true iff this number is at most kMaxUlps ULP's away from\n  // rhs.  In particular, this function:\n  //\n  //   - returns false if either number is (or both are) NAN.\n  //   - treats really large numbers as almost equal to infinity.\n  //   - thinks +0.0 and -0.0 are 0 DLP's apart.\n  bool AlmostEquals(const FloatingPoint& rhs) const {\n    // The IEEE standard says that any comparison operation involving\n    // a NAN must return false.\n    if (is_nan() || rhs.is_nan()) return false;\n\n    return DistanceBetweenSignAndMagnitudeNumbers(u_.bits_, rhs.u_.bits_)\n        <= kMaxUlps;\n  }\n\n private:\n  // The data type used to store the actual floating-point number.\n  union FloatingPointUnion {\n    RawType value_;  // The raw floating-point number.\n    Bits bits_;      // The bits that represent the number.\n  };\n\n  // Converts an integer from the sign-and-magnitude representation to\n  // the biased representation.  More precisely, let N be 2 to the\n  // power of (kBitCount - 1), an integer x is represented by the\n  // unsigned number x + N.\n  //\n  // For instance,\n  //\n  //   -N + 1 (the most negative number representable using\n  //          sign-and-magnitude) is represented by 1;\n  //   0      is represented by N; and\n  //   N - 1  (the biggest number representable using\n  //          sign-and-magnitude) is represented by 2N - 1.\n  //\n  // Read http://en.wikipedia.org/wiki/Signed_number_representations\n  // for more details on signed number representations.\n  static Bits SignAndMagnitudeToBiased(const Bits &sam) {\n    if (kSignBitMask & sam) {\n      // sam represents a negative number.\n      return ~sam + 1;\n    } else {\n      // sam represents a positive number.\n      return kSignBitMask | sam;\n    }\n  }\n\n  // Given two numbers in the sign-and-magnitude representation,\n  // returns the distance between them as an unsigned number.\n  static Bits DistanceBetweenSignAndMagnitudeNumbers(const Bits &sam1,\n                                                     const Bits &sam2) {\n    const Bits biased1 = SignAndMagnitudeToBiased(sam1);\n    const Bits biased2 = SignAndMagnitudeToBiased(sam2);\n    return (biased1 >= biased2) ? (biased1 - biased2) : (biased2 - biased1);\n  }\n\n  FloatingPointUnion u_;\n};\n\n// We cannot use std::numeric_limits<T>::max() as it clashes with the max()\n// macro defined by <windows.h>.\ntemplate <>\ninline float FloatingPoint<float>::Max() { return FLT_MAX; }\ntemplate <>\ninline double FloatingPoint<double>::Max() { return DBL_MAX; }\n\n// Typedefs the instances of the FloatingPoint template class that we\n// care to use.\ntypedef FloatingPoint<float> Float;\ntypedef FloatingPoint<double> Double;\n\n// In order to catch the mistake of putting tests that use different\n// test fixture classes in the same test case, we need to assign\n// unique IDs to fixture classes and compare them.  The TypeId type is\n// used to hold such IDs.  The user should treat TypeId as an opaque\n// type: the only operation allowed on TypeId values is to compare\n// them for equality using the == operator.\ntypedef const void* TypeId;\n\ntemplate <typename T>\nclass TypeIdHelper {\n public:\n  // dummy_ must not have a const type.  Otherwise an overly eager\n  // compiler (e.g. MSVC 7.1 & 8.0) may try to merge\n  // TypeIdHelper<T>::dummy_ for different Ts as an \"optimization\".\n  static bool dummy_;\n};\n\ntemplate <typename T>\nbool TypeIdHelper<T>::dummy_ = false;\n\n// GetTypeId<T>() returns the ID of type T.  Different values will be\n// returned for different types.  Calling the function twice with the\n// same type argument is guaranteed to return the same ID.\ntemplate <typename T>\nTypeId GetTypeId() {\n  // The compiler is required to allocate a different\n  // TypeIdHelper<T>::dummy_ variable for each T used to instantiate\n  // the template.  Therefore, the address of dummy_ is guaranteed to\n  // be unique.\n  return &(TypeIdHelper<T>::dummy_);\n}\n\n// Returns the type ID of ::testing::Test.  Always call this instead\n// of GetTypeId< ::testing::Test>() to get the type ID of\n// ::testing::Test, as the latter may give the wrong result due to a\n// suspected linker bug when compiling Google Test as a Mac OS X\n// framework.\nGTEST_API_ TypeId GetTestTypeId();\n\n// Defines the abstract factory interface that creates instances\n// of a Test object.\nclass TestFactoryBase {\n public:\n  virtual ~TestFactoryBase() {}\n\n  // Creates a test instance to run. The instance is both created and destroyed\n  // within TestInfoImpl::Run()\n  virtual Test* CreateTest() = 0;\n\n protected:\n  TestFactoryBase() {}\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestFactoryBase);\n};\n\n// This class provides implementation of TeastFactoryBase interface.\n// It is used in TEST and TEST_F macros.\ntemplate <class TestClass>\nclass TestFactoryImpl : public TestFactoryBase {\n public:\n  virtual Test* CreateTest() { return new TestClass; }\n};\n\n#if GTEST_OS_WINDOWS\n\n// Predicate-formatters for implementing the HRESULT checking macros\n// {ASSERT|EXPECT}_HRESULT_{SUCCEEDED|FAILED}\n// We pass a long instead of HRESULT to avoid causing an\n// include dependency for the HRESULT type.\nGTEST_API_ AssertionResult IsHRESULTSuccess(const char* expr,\n                                            long hr);  // NOLINT\nGTEST_API_ AssertionResult IsHRESULTFailure(const char* expr,\n                                            long hr);  // NOLINT\n\n#endif  // GTEST_OS_WINDOWS\n\n// Types of SetUpTestCase() and TearDownTestCase() functions.\ntypedef void (*SetUpTestCaseFunc)();\ntypedef void (*TearDownTestCaseFunc)();\n\nstruct CodeLocation {\n  CodeLocation(const string& a_file, int a_line) : file(a_file), line(a_line) {}\n\n  string file;\n  int line;\n};\n\n// Creates a new TestInfo object and registers it with Google Test;\n// returns the created object.\n//\n// Arguments:\n//\n//   test_case_name:   name of the test case\n//   name:             name of the test\n//   type_param        the name of the test's type parameter, or NULL if\n//                     this is not a typed or a type-parameterized test.\n//   value_param       text representation of the test's value parameter,\n//                     or NULL if this is not a type-parameterized test.\n//   code_location:    code location where the test is defined\n//   fixture_class_id: ID of the test fixture class\n//   set_up_tc:        pointer to the function that sets up the test case\n//   tear_down_tc:     pointer to the function that tears down the test case\n//   factory:          pointer to the factory that creates a test object.\n//                     The newly created TestInfo instance will assume\n//                     ownership of the factory object.\nGTEST_API_ TestInfo* MakeAndRegisterTestInfo(\n    const char* test_case_name,\n    const char* name,\n    const char* type_param,\n    const char* value_param,\n    CodeLocation code_location,\n    TypeId fixture_class_id,\n    SetUpTestCaseFunc set_up_tc,\n    TearDownTestCaseFunc tear_down_tc,\n    TestFactoryBase* factory);\n\n// If *pstr starts with the given prefix, modifies *pstr to be right\n// past the prefix and returns true; otherwise leaves *pstr unchanged\n// and returns false.  None of pstr, *pstr, and prefix can be NULL.\nGTEST_API_ bool SkipPrefix(const char* prefix, const char** pstr);\n\n#if GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P\n\n// State of the definition of a type-parameterized test case.\nclass GTEST_API_ TypedTestCasePState {\n public:\n  TypedTestCasePState() : registered_(false) {}\n\n  // Adds the given test name to defined_test_names_ and return true\n  // if the test case hasn't been registered; otherwise aborts the\n  // program.\n  bool AddTestName(const char* file, int line, const char* case_name,\n                   const char* test_name) {\n    if (registered_) {\n      fprintf(stderr, \"%s Test %s must be defined before \"\n              \"REGISTER_TYPED_TEST_CASE_P(%s, ...).\\n\",\n              FormatFileLocation(file, line).c_str(), test_name, case_name);\n      fflush(stderr);\n      posix::Abort();\n    }\n    registered_tests_.insert(\n        ::std::make_pair(test_name, CodeLocation(file, line)));\n    return true;\n  }\n\n  bool TestExists(const std::string& test_name) const {\n    return registered_tests_.count(test_name) > 0;\n  }\n\n  const CodeLocation& GetCodeLocation(const std::string& test_name) const {\n    RegisteredTestsMap::const_iterator it = registered_tests_.find(test_name);\n    GTEST_CHECK_(it != registered_tests_.end());\n    return it->second;\n  }\n\n  // Verifies that registered_tests match the test names in\n  // defined_test_names_; returns registered_tests if successful, or\n  // aborts the program otherwise.\n  const char* VerifyRegisteredTestNames(\n      const char* file, int line, const char* registered_tests);\n\n private:\n  typedef ::std::map<std::string, CodeLocation> RegisteredTestsMap;\n\n  bool registered_;\n  RegisteredTestsMap registered_tests_;\n};\n\n// Skips to the first non-space char after the first comma in 'str';\n// returns NULL if no comma is found in 'str'.\ninline const char* SkipComma(const char* str) {\n  const char* comma = strchr(str, ',');\n  if (comma == NULL) {\n    return NULL;\n  }\n  while (IsSpace(*(++comma))) {}\n  return comma;\n}\n\n// Returns the prefix of 'str' before the first comma in it; returns\n// the entire string if it contains no comma.\ninline std::string GetPrefixUntilComma(const char* str) {\n  const char* comma = strchr(str, ',');\n  return comma == NULL ? str : std::string(str, comma);\n}\n\n// Splits a given string on a given delimiter, populating a given\n// vector with the fields.\nvoid SplitString(const ::std::string& str, char delimiter,\n                 ::std::vector< ::std::string>* dest);\n\n// TypeParameterizedTest<Fixture, TestSel, Types>::Register()\n// registers a list of type-parameterized tests with Google Test.  The\n// return value is insignificant - we just need to return something\n// such that we can call this function in a namespace scope.\n//\n// Implementation note: The GTEST_TEMPLATE_ macro declares a template\n// template parameter.  It's defined in gtest-type-util.h.\ntemplate <GTEST_TEMPLATE_ Fixture, class TestSel, typename Types>\nclass TypeParameterizedTest {\n public:\n  // 'index' is the index of the test in the type list 'Types'\n  // specified in INSTANTIATE_TYPED_TEST_CASE_P(Prefix, TestCase,\n  // Types).  Valid values for 'index' are [0, N - 1] where N is the\n  // length of Types.\n  static bool Register(const char* prefix,\n                       CodeLocation code_location,\n                       const char* case_name, const char* test_names,\n                       int index) {\n    typedef typename Types::Head Type;\n    typedef Fixture<Type> FixtureClass;\n    typedef typename GTEST_BIND_(TestSel, Type) TestClass;\n\n    // First, registers the first type-parameterized test in the type\n    // list.\n    MakeAndRegisterTestInfo(\n        (std::string(prefix) + (prefix[0] == '\\0' ? \"\" : \"/\") + case_name + \"/\"\n         + StreamableToString(index)).c_str(),\n        StripTrailingSpaces(GetPrefixUntilComma(test_names)).c_str(),\n        GetTypeName<Type>().c_str(),\n        NULL,  // No value parameter.\n        code_location,\n        GetTypeId<FixtureClass>(),\n        TestClass::SetUpTestCase,\n        TestClass::TearDownTestCase,\n        new TestFactoryImpl<TestClass>);\n\n    // Next, recurses (at compile time) with the tail of the type list.\n    return TypeParameterizedTest<Fixture, TestSel, typename Types::Tail>\n        ::Register(prefix, code_location, case_name, test_names, index + 1);\n  }\n};\n\n// The base case for the compile time recursion.\ntemplate <GTEST_TEMPLATE_ Fixture, class TestSel>\nclass TypeParameterizedTest<Fixture, TestSel, Types0> {\n public:\n  static bool Register(const char* /*prefix*/, CodeLocation,\n                       const char* /*case_name*/, const char* /*test_names*/,\n                       int /*index*/) {\n    return true;\n  }\n};\n\n// TypeParameterizedTestCase<Fixture, Tests, Types>::Register()\n// registers *all combinations* of 'Tests' and 'Types' with Google\n// Test.  The return value is insignificant - we just need to return\n// something such that we can call this function in a namespace scope.\ntemplate <GTEST_TEMPLATE_ Fixture, typename Tests, typename Types>\nclass TypeParameterizedTestCase {\n public:\n  static bool Register(const char* prefix, CodeLocation code_location,\n                       const TypedTestCasePState* state,\n                       const char* case_name, const char* test_names) {\n    std::string test_name = StripTrailingSpaces(\n        GetPrefixUntilComma(test_names));\n    if (!state->TestExists(test_name)) {\n      fprintf(stderr, \"Failed to get code location for test %s.%s at %s.\",\n              case_name, test_name.c_str(),\n              FormatFileLocation(code_location.file.c_str(),\n                                 code_location.line).c_str());\n      fflush(stderr);\n      posix::Abort();\n    }\n    const CodeLocation& test_location = state->GetCodeLocation(test_name);\n\n    typedef typename Tests::Head Head;\n\n    // First, register the first test in 'Test' for each type in 'Types'.\n    TypeParameterizedTest<Fixture, Head, Types>::Register(\n        prefix, test_location, case_name, test_names, 0);\n\n    // Next, recurses (at compile time) with the tail of the test list.\n    return TypeParameterizedTestCase<Fixture, typename Tests::Tail, Types>\n        ::Register(prefix, code_location, state,\n                   case_name, SkipComma(test_names));\n  }\n};\n\n// The base case for the compile time recursion.\ntemplate <GTEST_TEMPLATE_ Fixture, typename Types>\nclass TypeParameterizedTestCase<Fixture, Templates0, Types> {\n public:\n  static bool Register(const char* /*prefix*/, CodeLocation,\n                       const TypedTestCasePState* /*state*/,\n                       const char* /*case_name*/, const char* /*test_names*/) {\n    return true;\n  }\n};\n\n#endif  // GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P\n\n// Returns the current OS stack trace as an std::string.\n//\n// The maximum number of stack frames to be included is specified by\n// the gtest_stack_trace_depth flag.  The skip_count parameter\n// specifies the number of top frames to be skipped, which doesn't\n// count against the number of frames to be included.\n//\n// For example, if Foo() calls Bar(), which in turn calls\n// GetCurrentOsStackTraceExceptTop(..., 1), Foo() will be included in\n// the trace but Bar() and GetCurrentOsStackTraceExceptTop() won't.\nGTEST_API_ std::string GetCurrentOsStackTraceExceptTop(\n    UnitTest* unit_test, int skip_count);\n\n// Helpers for suppressing warnings on unreachable code or constant\n// condition.\n\n// Always returns true.\nGTEST_API_ bool AlwaysTrue();\n\n// Always returns false.\ninline bool AlwaysFalse() { return !AlwaysTrue(); }\n\n// Helper for suppressing false warning from Clang on a const char*\n// variable declared in a conditional expression always being NULL in\n// the else branch.\nstruct GTEST_API_ ConstCharPtr {\n  ConstCharPtr(const char* str) : value(str) {}\n  operator bool() const { return true; }\n  const char* value;\n};\n\n// A simple Linear Congruential Generator for generating random\n// numbers with a uniform distribution.  Unlike rand() and srand(), it\n// doesn't use global state (and therefore can't interfere with user\n// code).  Unlike rand_r(), it's portable.  An LCG isn't very random,\n// but it's good enough for our purposes.\nclass GTEST_API_ Random {\n public:\n  static const UInt32 kMaxRange = 1u << 31;\n\n  explicit Random(UInt32 seed) : state_(seed) {}\n\n  void Reseed(UInt32 seed) { state_ = seed; }\n\n  // Generates a random number from [0, range).  Crashes if 'range' is\n  // 0 or greater than kMaxRange.\n  UInt32 Generate(UInt32 range);\n\n private:\n  UInt32 state_;\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Random);\n};\n\n// Defining a variable of type CompileAssertTypesEqual<T1, T2> will cause a\n// compiler error iff T1 and T2 are different types.\ntemplate <typename T1, typename T2>\nstruct CompileAssertTypesEqual;\n\ntemplate <typename T>\nstruct CompileAssertTypesEqual<T, T> {\n};\n\n// Removes the reference from a type if it is a reference type,\n// otherwise leaves it unchanged.  This is the same as\n// tr1::remove_reference, which is not widely available yet.\ntemplate <typename T>\nstruct RemoveReference { typedef T type; };  // NOLINT\ntemplate <typename T>\nstruct RemoveReference<T&> { typedef T type; };  // NOLINT\n\n// A handy wrapper around RemoveReference that works when the argument\n// T depends on template parameters.\n#define GTEST_REMOVE_REFERENCE_(T) \\\n    typename ::testing::internal::RemoveReference<T>::type\n\n// Removes const from a type if it is a const type, otherwise leaves\n// it unchanged.  This is the same as tr1::remove_const, which is not\n// widely available yet.\ntemplate <typename T>\nstruct RemoveConst { typedef T type; };  // NOLINT\ntemplate <typename T>\nstruct RemoveConst<const T> { typedef T type; };  // NOLINT\n\n// MSVC 8.0, Sun C++, and IBM XL C++ have a bug which causes the above\n// definition to fail to remove the const in 'const int[3]' and 'const\n// char[3][4]'.  The following specialization works around the bug.\ntemplate <typename T, size_t N>\nstruct RemoveConst<const T[N]> {\n  typedef typename RemoveConst<T>::type type[N];\n};\n\n#if defined(_MSC_VER) && _MSC_VER < 1400\n// This is the only specialization that allows VC++ 7.1 to remove const in\n// 'const int[3] and 'const int[3][4]'.  However, it causes trouble with GCC\n// and thus needs to be conditionally compiled.\ntemplate <typename T, size_t N>\nstruct RemoveConst<T[N]> {\n  typedef typename RemoveConst<T>::type type[N];\n};\n#endif\n\n// A handy wrapper around RemoveConst that works when the argument\n// T depends on template parameters.\n#define GTEST_REMOVE_CONST_(T) \\\n    typename ::testing::internal::RemoveConst<T>::type\n\n// Turns const U&, U&, const U, and U all into U.\n#define GTEST_REMOVE_REFERENCE_AND_CONST_(T) \\\n    GTEST_REMOVE_CONST_(GTEST_REMOVE_REFERENCE_(T))\n\n// Adds reference to a type if it is not a reference type,\n// otherwise leaves it unchanged.  This is the same as\n// tr1::add_reference, which is not widely available yet.\ntemplate <typename T>\nstruct AddReference { typedef T& type; };  // NOLINT\ntemplate <typename T>\nstruct AddReference<T&> { typedef T& type; };  // NOLINT\n\n// A handy wrapper around AddReference that works when the argument T\n// depends on template parameters.\n#define GTEST_ADD_REFERENCE_(T) \\\n    typename ::testing::internal::AddReference<T>::type\n\n// Adds a reference to const on top of T as necessary.  For example,\n// it transforms\n//\n//   char         ==> const char&\n//   const char   ==> const char&\n//   char&        ==> const char&\n//   const char&  ==> const char&\n//\n// The argument T must depend on some template parameters.\n#define GTEST_REFERENCE_TO_CONST_(T) \\\n    GTEST_ADD_REFERENCE_(const GTEST_REMOVE_REFERENCE_(T))\n\n// ImplicitlyConvertible<From, To>::value is a compile-time bool\n// constant that's true iff type From can be implicitly converted to\n// type To.\ntemplate <typename From, typename To>\nclass ImplicitlyConvertible {\n private:\n  // We need the following helper functions only for their types.\n  // They have no implementations.\n\n  // MakeFrom() is an expression whose type is From.  We cannot simply\n  // use From(), as the type From may not have a public default\n  // constructor.\n  static typename AddReference<From>::type MakeFrom();\n\n  // These two functions are overloaded.  Given an expression\n  // Helper(x), the compiler will pick the first version if x can be\n  // implicitly converted to type To; otherwise it will pick the\n  // second version.\n  //\n  // The first version returns a value of size 1, and the second\n  // version returns a value of size 2.  Therefore, by checking the\n  // size of Helper(x), which can be done at compile time, we can tell\n  // which version of Helper() is used, and hence whether x can be\n  // implicitly converted to type To.\n  static char Helper(To);\n  static char (&Helper(...))[2];  // NOLINT\n\n  // We have to put the 'public' section after the 'private' section,\n  // or MSVC refuses to compile the code.\n public:\n#if defined(__BORLANDC__)\n  // C++Builder cannot use member overload resolution during template\n  // instantiation.  The simplest workaround is to use its C++0x type traits\n  // functions (C++Builder 2009 and above only).\n  static const bool value = __is_convertible(From, To);\n#else\n  // MSVC warns about implicitly converting from double to int for\n  // possible loss of data, so we need to temporarily disable the\n  // warning.\n  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4244)\n  static const bool value =\n      sizeof(Helper(ImplicitlyConvertible::MakeFrom())) == 1;\n  GTEST_DISABLE_MSC_WARNINGS_POP_()\n#endif  // __BORLANDC__\n};\ntemplate <typename From, typename To>\nconst bool ImplicitlyConvertible<From, To>::value;\n\n// IsAProtocolMessage<T>::value is a compile-time bool constant that's\n// true iff T is type ProtocolMessage, proto2::Message, or a subclass\n// of those.\ntemplate <typename T>\nstruct IsAProtocolMessage\n    : public bool_constant<\n  ImplicitlyConvertible<const T*, const ::ProtocolMessage*>::value ||\n  ImplicitlyConvertible<const T*, const ::proto2::Message*>::value> {\n};\n\n// When the compiler sees expression IsContainerTest<C>(0), if C is an\n// STL-style container class, the first overload of IsContainerTest\n// will be viable (since both C::iterator* and C::const_iterator* are\n// valid types and NULL can be implicitly converted to them).  It will\n// be picked over the second overload as 'int' is a perfect match for\n// the type of argument 0.  If C::iterator or C::const_iterator is not\n// a valid type, the first overload is not viable, and the second\n// overload will be picked.  Therefore, we can determine whether C is\n// a container class by checking the type of IsContainerTest<C>(0).\n// The value of the expression is insignificant.\n//\n// Note that we look for both C::iterator and C::const_iterator.  The\n// reason is that C++ injects the name of a class as a member of the\n// class itself (e.g. you can refer to class iterator as either\n// 'iterator' or 'iterator::iterator').  If we look for C::iterator\n// only, for example, we would mistakenly think that a class named\n// iterator is an STL container.\n//\n// Also note that the simpler approach of overloading\n// IsContainerTest(typename C::const_iterator*) and\n// IsContainerTest(...) doesn't work with Visual Age C++ and Sun C++.\ntypedef int IsContainer;\ntemplate <class C>\nIsContainer IsContainerTest(int /* dummy */,\n                            typename C::iterator* /* it */ = NULL,\n                            typename C::const_iterator* /* const_it */ = NULL) {\n  return 0;\n}\n\ntypedef char IsNotContainer;\ntemplate <class C>\nIsNotContainer IsContainerTest(long /* dummy */) { return '\\0'; }\n\n// EnableIf<condition>::type is void when 'Cond' is true, and\n// undefined when 'Cond' is false.  To use SFINAE to make a function\n// overload only apply when a particular expression is true, add\n// \"typename EnableIf<expression>::type* = 0\" as the last parameter.\ntemplate<bool> struct EnableIf;\ntemplate<> struct EnableIf<true> { typedef void type; };  // NOLINT\n\n// Utilities for native arrays.\n\n// ArrayEq() compares two k-dimensional native arrays using the\n// elements' operator==, where k can be any integer >= 0.  When k is\n// 0, ArrayEq() degenerates into comparing a single pair of values.\n\ntemplate <typename T, typename U>\nbool ArrayEq(const T* lhs, size_t size, const U* rhs);\n\n// This generic version is used when k is 0.\ntemplate <typename T, typename U>\ninline bool ArrayEq(const T& lhs, const U& rhs) { return lhs == rhs; }\n\n// This overload is used when k >= 1.\ntemplate <typename T, typename U, size_t N>\ninline bool ArrayEq(const T(&lhs)[N], const U(&rhs)[N]) {\n  return internal::ArrayEq(lhs, N, rhs);\n}\n\n// This helper reduces code bloat.  If we instead put its logic inside\n// the previous ArrayEq() function, arrays with different sizes would\n// lead to different copies of the template code.\ntemplate <typename T, typename U>\nbool ArrayEq(const T* lhs, size_t size, const U* rhs) {\n  for (size_t i = 0; i != size; i++) {\n    if (!internal::ArrayEq(lhs[i], rhs[i]))\n      return false;\n  }\n  return true;\n}\n\n// Finds the first element in the iterator range [begin, end) that\n// equals elem.  Element may be a native array type itself.\ntemplate <typename Iter, typename Element>\nIter ArrayAwareFind(Iter begin, Iter end, const Element& elem) {\n  for (Iter it = begin; it != end; ++it) {\n    if (internal::ArrayEq(*it, elem))\n      return it;\n  }\n  return end;\n}\n\n// CopyArray() copies a k-dimensional native array using the elements'\n// operator=, where k can be any integer >= 0.  When k is 0,\n// CopyArray() degenerates into copying a single value.\n\ntemplate <typename T, typename U>\nvoid CopyArray(const T* from, size_t size, U* to);\n\n// This generic version is used when k is 0.\ntemplate <typename T, typename U>\ninline void CopyArray(const T& from, U* to) { *to = from; }\n\n// This overload is used when k >= 1.\ntemplate <typename T, typename U, size_t N>\ninline void CopyArray(const T(&from)[N], U(*to)[N]) {\n  internal::CopyArray(from, N, *to);\n}\n\n// This helper reduces code bloat.  If we instead put its logic inside\n// the previous CopyArray() function, arrays with different sizes\n// would lead to different copies of the template code.\ntemplate <typename T, typename U>\nvoid CopyArray(const T* from, size_t size, U* to) {\n  for (size_t i = 0; i != size; i++) {\n    internal::CopyArray(from[i], to + i);\n  }\n}\n\n// The relation between an NativeArray object (see below) and the\n// native array it represents.\n// We use 2 different structs to allow non-copyable types to be used, as long\n// as RelationToSourceReference() is passed.\nstruct RelationToSourceReference {};\nstruct RelationToSourceCopy {};\n\n// Adapts a native array to a read-only STL-style container.  Instead\n// of the complete STL container concept, this adaptor only implements\n// members useful for Google Mock's container matchers.  New members\n// should be added as needed.  To simplify the implementation, we only\n// support Element being a raw type (i.e. having no top-level const or\n// reference modifier).  It's the client's responsibility to satisfy\n// this requirement.  Element can be an array type itself (hence\n// multi-dimensional arrays are supported).\ntemplate <typename Element>\nclass NativeArray {\n public:\n  // STL-style container typedefs.\n  typedef Element value_type;\n  typedef Element* iterator;\n  typedef const Element* const_iterator;\n\n  // Constructs from a native array. References the source.\n  NativeArray(const Element* array, size_t count, RelationToSourceReference) {\n    InitRef(array, count);\n  }\n\n  // Constructs from a native array. Copies the source.\n  NativeArray(const Element* array, size_t count, RelationToSourceCopy) {\n    InitCopy(array, count);\n  }\n\n  // Copy constructor.\n  NativeArray(const NativeArray& rhs) {\n    (this->*rhs.clone_)(rhs.array_, rhs.size_);\n  }\n\n  ~NativeArray() {\n    if (clone_ != &NativeArray::InitRef)\n      delete[] array_;\n  }\n\n  // STL-style container methods.\n  size_t size() const { return size_; }\n  const_iterator begin() const { return array_; }\n  const_iterator end() const { return array_ + size_; }\n  bool operator==(const NativeArray& rhs) const {\n    return size() == rhs.size() &&\n        ArrayEq(begin(), size(), rhs.begin());\n  }\n\n private:\n  enum {\n    kCheckTypeIsNotConstOrAReference = StaticAssertTypeEqHelper<\n        Element, GTEST_REMOVE_REFERENCE_AND_CONST_(Element)>::value,\n  };\n\n  // Initializes this object with a copy of the input.\n  void InitCopy(const Element* array, size_t a_size) {\n    Element* const copy = new Element[a_size];\n    CopyArray(array, a_size, copy);\n    array_ = copy;\n    size_ = a_size;\n    clone_ = &NativeArray::InitCopy;\n  }\n\n  // Initializes this object with a reference of the input.\n  void InitRef(const Element* array, size_t a_size) {\n    array_ = array;\n    size_ = a_size;\n    clone_ = &NativeArray::InitRef;\n  }\n\n  const Element* array_;\n  size_t size_;\n  void (NativeArray::*clone_)(const Element*, size_t);\n\n  GTEST_DISALLOW_ASSIGN_(NativeArray);\n};\n\n}  // namespace internal\n}  // namespace testing\n\n#define GTEST_MESSAGE_AT_(file, line, message, result_type) \\\n  ::testing::internal::AssertHelper(result_type, file, line, message) \\\n    = ::testing::Message()\n\n#define GTEST_MESSAGE_(message, result_type) \\\n  GTEST_MESSAGE_AT_(__FILE__, __LINE__, message, result_type)\n\n#define GTEST_FATAL_FAILURE_(message) \\\n  return GTEST_MESSAGE_(message, ::testing::TestPartResult::kFatalFailure)\n\n#define GTEST_NONFATAL_FAILURE_(message) \\\n  GTEST_MESSAGE_(message, ::testing::TestPartResult::kNonFatalFailure)\n\n#define GTEST_SUCCESS_(message) \\\n  GTEST_MESSAGE_(message, ::testing::TestPartResult::kSuccess)\n\n// Suppresses MSVC warnings 4072 (unreachable code) for the code following\n// statement if it returns or throws (or doesn't return or throw in some\n// situations).\n#define GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement) \\\n  if (::testing::internal::AlwaysTrue()) { statement; }\n\n#define GTEST_TEST_THROW_(statement, expected_exception, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::ConstCharPtr gtest_msg = \"\") { \\\n    bool gtest_caught_expected = false; \\\n    try { \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    } \\\n    catch (expected_exception const&) { \\\n      gtest_caught_expected = true; \\\n    } \\\n    catch (...) { \\\n      gtest_msg.value = \\\n          \"Expected: \" #statement \" throws an exception of type \" \\\n          #expected_exception \".\\n  Actual: it throws a different type.\"; \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \\\n    } \\\n    if (!gtest_caught_expected) { \\\n      gtest_msg.value = \\\n          \"Expected: \" #statement \" throws an exception of type \" \\\n          #expected_exception \".\\n  Actual: it throws nothing.\"; \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__): \\\n      fail(gtest_msg.value)\n\n#define GTEST_TEST_NO_THROW_(statement, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::AlwaysTrue()) { \\\n    try { \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    } \\\n    catch (...) { \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__): \\\n      fail(\"Expected: \" #statement \" doesn't throw an exception.\\n\" \\\n           \"  Actual: it throws.\")\n\n#define GTEST_TEST_ANY_THROW_(statement, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::AlwaysTrue()) { \\\n    bool gtest_caught_any = false; \\\n    try { \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    } \\\n    catch (...) { \\\n      gtest_caught_any = true; \\\n    } \\\n    if (!gtest_caught_any) { \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__): \\\n      fail(\"Expected: \" #statement \" throws an exception.\\n\" \\\n           \"  Actual: it doesn't.\")\n\n\n// Implements Boolean test assertions such as EXPECT_TRUE. expression can be\n// either a boolean expression or an AssertionResult. text is a textual\n// represenation of expression as it was passed into the EXPECT_TRUE.\n#define GTEST_TEST_BOOLEAN_(expression, text, actual, expected, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (const ::testing::AssertionResult gtest_ar_ = \\\n      ::testing::AssertionResult(expression)) \\\n    ; \\\n  else \\\n    fail(::testing::internal::GetBoolAssertionFailureMessage(\\\n        gtest_ar_, text, #actual, #expected).c_str())\n\n#define GTEST_TEST_NO_FATAL_FAILURE_(statement, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::AlwaysTrue()) { \\\n    ::testing::internal::HasNewFatalFailureHelper gtest_fatal_failure_checker; \\\n    GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    if (gtest_fatal_failure_checker.has_new_fatal_failure()) { \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__): \\\n      fail(\"Expected: \" #statement \" doesn't generate new fatal \" \\\n           \"failures in the current thread.\\n\" \\\n           \"  Actual: it does.\")\n\n// Expands to the name of the class that implements the given test.\n#define GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \\\n  test_case_name##_##test_name##_Test\n\n// Helper macro for defining tests.\n#define GTEST_TEST_(test_case_name, test_name, parent_class, parent_id)\\\nclass GTEST_TEST_CLASS_NAME_(test_case_name, test_name) : public parent_class {\\\n public:\\\n  GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() {}\\\n private:\\\n  virtual void TestBody();\\\n  static ::testing::TestInfo* const test_info_ GTEST_ATTRIBUTE_UNUSED_;\\\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(\\\n      GTEST_TEST_CLASS_NAME_(test_case_name, test_name));\\\n};\\\n\\\n::testing::TestInfo* const GTEST_TEST_CLASS_NAME_(test_case_name, test_name)\\\n  ::test_info_ =\\\n    ::testing::internal::MakeAndRegisterTestInfo(\\\n        #test_case_name, #test_name, NULL, NULL, \\\n        ::testing::internal::CodeLocation(__FILE__, __LINE__), \\\n        (parent_id), \\\n        parent_class::SetUpTestCase, \\\n        parent_class::TearDownTestCase, \\\n        new ::testing::internal::TestFactoryImpl<\\\n            GTEST_TEST_CLASS_NAME_(test_case_name, test_name)>);\\\nvoid GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_\n\n"}}, "reports": [{"events": [{"location": {"col": 3, "file": 0, "line": 49}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 0, "line": 49}, "message": "'CommentInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clang-doc/Representation.h", "reportHash": "c91767c9ae6a70bc8b72a0cd44247119", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 115}, "message": "'Reference' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clang-doc/Representation.h", "reportHash": "b82b4c09f842c5b88e65593b3049fc5d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 158}, "message": "'TypeInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clang-doc/Representation.h", "reportHash": "def95c4310523a8f421057ca1553cdd7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 173}, "message": "'FieldTypeInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clang-doc/Representation.h", "reportHash": "520116e89c7f5ee3ff9e13ab894d0f7a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 215}, "message": "'Location' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clang-doc/Representation.h", "reportHash": "ef7cb63f60d3cb13c9d7d87ee74a854e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 0, "line": 252}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 0, "line": 252}, "message": "'Info' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clang-doc/Representation.h", "reportHash": "001277e70f96fffbc3739caf6802e1fd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 283}, "message": "'NamespaceInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clang-doc/Representation.h", "reportHash": "d68f06d2e77fb3409cecd52346059ab1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 304}, "message": "'SymbolInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clang-doc/Representation.h", "reportHash": "d6e23d0de52d801057a37c516872037f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 319}, "message": "'FunctionInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clang-doc/Representation.h", "reportHash": "cf8ec26f292a9735c8e10f8302217587", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 339}, "message": "'RecordInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clang-doc/Representation.h", "reportHash": "da1dd2055826ee26e68e8bfec7c2a9d2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 390}, "message": "'EnumInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clang-doc/Representation.h", "reportHash": "bf2ca06fd13c4d4f785a41371006a471", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 426}, "message": "'ClangDocContext' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clang-doc/Representation.h", "reportHash": "7acf4ffcda8c57605ea2a82ca7d8715d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 4, "line": 46}, "message": "'Attr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Attr.h", "reportHash": "f2efd1dab3c82ca3a093408fb2d6e8e5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 4, "line": 140}, "message": "'InheritableAttr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Attr.h", "reportHash": "786fa9eb47c2febffa94160ce2ae450f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 4, "line": 180}, "message": "'InheritableParamAttr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Attr.h", "reportHash": "52d25b9203b4b5c37303eca786a5a577", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 5, "line": 52}, "message": "'Comment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Comment.h", "reportHash": "dfe25cae198b3c72e15f249c2c803b29", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 5, "line": 60}, "message": "'CommentBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Comment.h", "reportHash": "367fd00bccea0c8771f6676f2cee40fd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 5, "line": 68}, "message": "'InlineContentCommentBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Comment.h", "reportHash": "e1472fa0bdf5549f6afb60d616235b6f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 5, "line": 79}, "message": "'TextCommentBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Comment.h", "reportHash": "205a62d62fc14b658d621edf5a7e18e5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 5, "line": 92}, "message": "'InlineCommandCommentBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Comment.h", "reportHash": "18d62b301025da1090c7b05d66a6bf83", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 5, "line": 104}, "message": "'HTMLTagCommentBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Comment.h", "reportHash": "57d997674ba09b96aacfd46df0481859", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 5, "line": 114}, "message": "'HTMLStartTagCommentBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Comment.h", "reportHash": "dc7df48a1897d4d90a291de65b2d904b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 5, "line": 125}, "message": "'ParagraphCommentBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Comment.h", "reportHash": "bf02dc65b46d2332a8d09b65e0046f93", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 5, "line": 138}, "message": "'BlockCommandCommentBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Comment.h", "reportHash": "fe54cd041d1a0098d34a4a2a2716023d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 5, "line": 152}, "message": "'ParamCommandCommentBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Comment.h", "reportHash": "893f7f0623d0c6f281881f218ab386ff", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 5, "line": 165}, "message": "'' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Comment.h", "reportHash": "fc2e69d9a89b7024bbdb54d4ab9976c0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 5, "line": 236}, "message": "'InlineContentComment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Comment.h", "reportHash": "d76a7d29bcbff1f48f47107b7f9b209c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 5, "line": 530}, "message": "'BlockContentComment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Comment.h", "reportHash": "bb2355656144e3de2bf5d924082db659", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 6, "line": 3806}, "message": "'RecordDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Decl.h", "reportHash": "7446b912fa4342b9c6d8060ef4701aa9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 7, "line": 1320}, "message": "'DeclContextBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclBase.h", "reportHash": "293899cc87f30fa16f3ef9e061ce8012", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 7, "line": 1361}, "message": "'TagDeclBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclBase.h", "reportHash": "5a86fe03070a3cf0b9489cef3d69c4cb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 7, "line": 1401}, "message": "'EnumDeclBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclBase.h", "reportHash": "91641a71fa54d1bcdf298ede0eac7a1c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 7, "line": 1440}, "message": "'RecordDeclBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclBase.h", "reportHash": "b6ded80d9e123fcad58986f96be6947d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 7, "line": 1494}, "message": "'OMPDeclareReductionDeclBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclBase.h", "reportHash": "dd6ccf9a237d1f1da28dfc00fab87272", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 7, "line": 1511}, "message": "'FunctionDeclBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclBase.h", "reportHash": "f06b7a2094e63a2ece1f3304fe92f2fa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 7, "line": 1578}, "message": "'CXXConstructorDeclBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclBase.h", "reportHash": "c8bf2bb4d1ed35e80d83d57b3455fe4f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 7, "line": 1608}, "message": "'ObjCMethodDeclBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclBase.h", "reportHash": "cf593553440db34b818f19b9648dc687", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 7, "line": 1670}, "message": "'ObjCContainerDeclBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclBase.h", "reportHash": "a79cc7dd70b5c858a7865ac5b3c8c13b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 7, "line": 1688}, "message": "'LinkageSpecDeclBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclBase.h", "reportHash": "fcbc5fc7efdf59b3735fe839619230c1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 7, "line": 1710}, "message": "'BlockDeclBitfields' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclBase.h", "reportHash": "4bd819c7a90ba30dc36e6062a45ba0ef", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 7, "line": 1750}, "message": "'' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclBase.h", "reportHash": "ae0d456ca73f68329744cfc74f8f7fba", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 254}, "message": "'CXXRecordDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclCXX.h", "reportHash": "82337e4dbcadd7097b827e55e1248de3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 53}, "message": "'FriendDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclFriend.h", "reportHash": "a6f46c42b774b2d19253265d6a9ac1b6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 11, "line": 171}, "message": "'OMPDeclareReductionDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclOpenMP.h", "reportHash": "462ab493f7bf6f9f3edc87b2b71845be", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 11, "line": 286}, "message": "'OMPDeclareMapperDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclOpenMP.h", "reportHash": "645ce14349b24e9c691baec6abf8384b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 16, "line": 40}, "message": "'ConceptSpecializationExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprConcepts.h", "reportHash": "3024915ce89deaf865c399814104c1ba", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 16, "line": 149}, "message": "'Requirement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprConcepts.h", "reportHash": "c7bae42776feea2d3cbafb7e00e96cfa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 16, "line": 268}, "message": "'ReturnTypeRequirement' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprConcepts.h", "reportHash": "fc0167199ed03c9f438e12b453910c38", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 16, "line": 475}, "message": "'RequiresExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprConcepts.h", "reportHash": "23c96b67bc62d030aa491bc2c5b241ad", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 18, "line": 56}, "message": "'OMPArraySectionExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprOpenMP.h", "reportHash": "a4b8d79e56fba69ec6a7ed58a96cc744", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 18, "line": 146}, "message": "'OMPArrayShapingExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprOpenMP.h", "reportHash": "4bda64b9bf084076d5c33db7d5182ae5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 18, "line": 272}, "message": "'OMPIteratorExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ExprOpenMP.h", "reportHash": "074a13f6ad674b14b859f2aee29222f4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 19, "line": 111}, "message": "'OMPClauseWithPreInit' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "459bb9f59bfbe5be103074ccc5463660", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 19, "line": 149}, "message": "'OMPClauseWithPostUpdate' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "121e9e7542aa562defe7968212357b8d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 19, "line": 175}, "message": "'OMPVarListLocTy' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/OpenMPClause.h", "reportHash": "0bbea39e43057e760effa6761c14156a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 23, "line": 23}, "message": "'ObjCForCollectionStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtObjC.h", "reportHash": "6c65bf028381cd1be26282c2bb236aa0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 23, "line": 77}, "message": "'ObjCAtCatchStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtObjC.h", "reportHash": "58609a0ae2878c35b5d623c8cfee6269", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 23, "line": 127}, "message": "'ObjCAtFinallyStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtObjC.h", "reportHash": "30cc9cf226dbcbcb5b9d2f3eca410294", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 23, "line": 165}, "message": "'ObjCAtTryStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtObjC.h", "reportHash": "812d79f2ec73d966c7decdd3d3dedaa1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 23, "line": 277}, "message": "'ObjCAtSynchronizedStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtObjC.h", "reportHash": "fdddbf25b99d8939fff389e52d5409ec", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 23, "line": 332}, "message": "'ObjCAtThrowStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtObjC.h", "reportHash": "8ac1bdc147b71397a18a5e8e3f751f60", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 23, "line": 368}, "message": "'ObjCAutoreleasePoolStmt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtObjC.h", "reportHash": "264bf459f19e77c6a9cb00f147fb434a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 24, "line": 142}, "message": "'OMPCanonicalLoop' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "reportHash": "331f152acc2c671d3683686a02deed62", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 24, "line": 266}, "message": "'OMPExecutableDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtOpenMP.h", "reportHash": "d070fa81e44d5e3aa6468093f9c95d38", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 61, "line": 118}, "message": "'ArgumentsAdjustingCompilations' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h", "reportHash": "2e890b100cc6c04916cd3f6a881aadeb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 63, "line": 59}, "message": "'InMemoryToolResults' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/Execution.h", "reportHash": "d46b84e40207ba3be75d92db56d34313", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 64, "line": 30}, "message": "'StandaloneToolExecutor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Tooling/StandaloneExecution.h", "reportHash": "68cd064627e9fe61172aa0b9f751a43f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 98, "line": 215}, "message": "'FormattedBytes' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Format.h", "reportHash": "76982b61480742edfc3a29235573d4f6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 107, "line": 413}, "message": "'TypeSize' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TypeSize.h", "reportHash": "095d93e2800ecca0b5febc5f9d928b3b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 115, "line": 504}, "message": "'CodeLocation' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-internal.h", "reportHash": "ca2979da45a2278b132302f4a1839673", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
